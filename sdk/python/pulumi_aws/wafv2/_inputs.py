# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'RegexPatternSetRegularExpressionArgs',
    'RegexPatternSetRegularExpressionArgsDict',
    'RuleGroupCustomResponseBodyArgs',
    'RuleGroupCustomResponseBodyArgsDict',
    'RuleGroupRuleArgs',
    'RuleGroupRuleArgsDict',
    'RuleGroupRuleActionArgs',
    'RuleGroupRuleActionArgsDict',
    'RuleGroupRuleActionAllowArgs',
    'RuleGroupRuleActionAllowArgsDict',
    'RuleGroupRuleActionAllowCustomRequestHandlingArgs',
    'RuleGroupRuleActionAllowCustomRequestHandlingArgsDict',
    'RuleGroupRuleActionAllowCustomRequestHandlingInsertHeaderArgs',
    'RuleGroupRuleActionAllowCustomRequestHandlingInsertHeaderArgsDict',
    'RuleGroupRuleActionBlockArgs',
    'RuleGroupRuleActionBlockArgsDict',
    'RuleGroupRuleActionBlockCustomResponseArgs',
    'RuleGroupRuleActionBlockCustomResponseArgsDict',
    'RuleGroupRuleActionBlockCustomResponseResponseHeaderArgs',
    'RuleGroupRuleActionBlockCustomResponseResponseHeaderArgsDict',
    'RuleGroupRuleActionCaptchaArgs',
    'RuleGroupRuleActionCaptchaArgsDict',
    'RuleGroupRuleActionCaptchaCustomRequestHandlingArgs',
    'RuleGroupRuleActionCaptchaCustomRequestHandlingArgsDict',
    'RuleGroupRuleActionCaptchaCustomRequestHandlingInsertHeaderArgs',
    'RuleGroupRuleActionCaptchaCustomRequestHandlingInsertHeaderArgsDict',
    'RuleGroupRuleActionChallengeArgs',
    'RuleGroupRuleActionChallengeArgsDict',
    'RuleGroupRuleActionChallengeCustomRequestHandlingArgs',
    'RuleGroupRuleActionChallengeCustomRequestHandlingArgsDict',
    'RuleGroupRuleActionChallengeCustomRequestHandlingInsertHeaderArgs',
    'RuleGroupRuleActionChallengeCustomRequestHandlingInsertHeaderArgsDict',
    'RuleGroupRuleActionCountArgs',
    'RuleGroupRuleActionCountArgsDict',
    'RuleGroupRuleActionCountCustomRequestHandlingArgs',
    'RuleGroupRuleActionCountCustomRequestHandlingArgsDict',
    'RuleGroupRuleActionCountCustomRequestHandlingInsertHeaderArgs',
    'RuleGroupRuleActionCountCustomRequestHandlingInsertHeaderArgsDict',
    'RuleGroupRuleCaptchaConfigArgs',
    'RuleGroupRuleCaptchaConfigArgsDict',
    'RuleGroupRuleCaptchaConfigImmunityTimePropertyArgs',
    'RuleGroupRuleCaptchaConfigImmunityTimePropertyArgsDict',
    'RuleGroupRuleRuleLabelArgs',
    'RuleGroupRuleRuleLabelArgsDict',
    'RuleGroupRuleStatementArgs',
    'RuleGroupRuleStatementArgsDict',
    'RuleGroupRuleStatementAndStatementArgs',
    'RuleGroupRuleStatementAndStatementArgsDict',
    'RuleGroupRuleStatementByteMatchStatementArgs',
    'RuleGroupRuleStatementByteMatchStatementArgsDict',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchArgs',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchArgsDict',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgsDict',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchBodyArgs',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchBodyArgsDict',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesArgs',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesArgsDict',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgsDict',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderArgs',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderArgsDict',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgsDict',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderOrderArgs',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderOrderArgsDict',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchJa3FingerprintArgs',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchJa3FingerprintArgsDict',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyArgs',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyArgsDict',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchMethodArgs',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchMethodArgsDict',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchQueryStringArgs',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchQueryStringArgsDict',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleHeaderArgs',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleHeaderArgsDict',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgsDict',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchUriPathArgs',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchUriPathArgsDict',
    'RuleGroupRuleStatementByteMatchStatementTextTransformationArgs',
    'RuleGroupRuleStatementByteMatchStatementTextTransformationArgsDict',
    'RuleGroupRuleStatementGeoMatchStatementArgs',
    'RuleGroupRuleStatementGeoMatchStatementArgsDict',
    'RuleGroupRuleStatementGeoMatchStatementForwardedIpConfigArgs',
    'RuleGroupRuleStatementGeoMatchStatementForwardedIpConfigArgsDict',
    'RuleGroupRuleStatementIpSetReferenceStatementArgs',
    'RuleGroupRuleStatementIpSetReferenceStatementArgsDict',
    'RuleGroupRuleStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs',
    'RuleGroupRuleStatementIpSetReferenceStatementIpSetForwardedIpConfigArgsDict',
    'RuleGroupRuleStatementLabelMatchStatementArgs',
    'RuleGroupRuleStatementLabelMatchStatementArgsDict',
    'RuleGroupRuleStatementNotStatementArgs',
    'RuleGroupRuleStatementNotStatementArgsDict',
    'RuleGroupRuleStatementOrStatementArgs',
    'RuleGroupRuleStatementOrStatementArgsDict',
    'RuleGroupRuleStatementRateBasedStatementArgs',
    'RuleGroupRuleStatementRateBasedStatementArgsDict',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyArgs',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyArgsDict',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyCookieArgs',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyCookieArgsDict',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyCookieTextTransformationArgs',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyCookieTextTransformationArgsDict',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyForwardedIpArgs',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyForwardedIpArgsDict',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyHeaderArgs',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyHeaderArgsDict',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyHeaderTextTransformationArgs',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyHeaderTextTransformationArgsDict',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyHttpMethodArgs',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyHttpMethodArgsDict',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyIpArgs',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyIpArgsDict',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyLabelNamespaceArgs',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyLabelNamespaceArgsDict',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgumentArgs',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgumentArgsDict',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformationArgs',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformationArgsDict',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyQueryStringArgs',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyQueryStringArgsDict',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformationArgs',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformationArgsDict',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyUriPathArgs',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyUriPathArgsDict',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyUriPathTextTransformationArgs',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyUriPathTextTransformationArgsDict',
    'RuleGroupRuleStatementRateBasedStatementForwardedIpConfigArgs',
    'RuleGroupRuleStatementRateBasedStatementForwardedIpConfigArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementAndStatementArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementAndStatementArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformationArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformationArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatementArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatementArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementNotStatementArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementNotStatementArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementOrStatementArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementOrStatementArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformationArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformationArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformationArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformationArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformationArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformationArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformationArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformationArgsDict',
    'RuleGroupRuleStatementRegexMatchStatementArgs',
    'RuleGroupRuleStatementRegexMatchStatementArgsDict',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchArgs',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchArgsDict',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgsDict',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchBodyArgs',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchBodyArgsDict',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesArgs',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesArgsDict',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgsDict',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderArgs',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderArgsDict',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgsDict',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderOrderArgs',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderOrderArgsDict',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchJa3FingerprintArgsDict',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyArgs',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyArgsDict',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchMethodArgs',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchMethodArgsDict',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchQueryStringArgs',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchQueryStringArgsDict',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleHeaderArgs',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleHeaderArgsDict',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgsDict',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchUriPathArgs',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchUriPathArgsDict',
    'RuleGroupRuleStatementRegexMatchStatementTextTransformationArgs',
    'RuleGroupRuleStatementRegexMatchStatementTextTransformationArgsDict',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementArgs',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementArgsDict',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchArgs',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchArgsDict',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgsDict',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgsDict',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgsDict',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgsDict',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgsDict',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgsDict',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgsDict',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgsDict',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgsDict',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgsDict',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgsDict',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgsDict',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgsDict',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgsDict',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgsDict',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgsDict',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgsDict',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgsDict',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementTextTransformationArgs',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementTextTransformationArgsDict',
    'RuleGroupRuleStatementSizeConstraintStatementArgs',
    'RuleGroupRuleStatementSizeConstraintStatementArgsDict',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchArgs',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchArgsDict',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgsDict',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchBodyArgs',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchBodyArgsDict',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesArgs',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesArgsDict',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgsDict',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgsDict',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderArgs',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderArgsDict',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgsDict',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgsDict',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderOrderArgsDict',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgsDict',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyArgs',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyArgsDict',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgsDict',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgsDict',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchMethodArgs',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchMethodArgsDict',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchQueryStringArgs',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchQueryStringArgsDict',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleHeaderArgsDict',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgsDict',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchUriPathArgs',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchUriPathArgsDict',
    'RuleGroupRuleStatementSizeConstraintStatementTextTransformationArgs',
    'RuleGroupRuleStatementSizeConstraintStatementTextTransformationArgsDict',
    'RuleGroupRuleStatementSqliMatchStatementArgs',
    'RuleGroupRuleStatementSqliMatchStatementArgsDict',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchArgs',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchArgsDict',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgsDict',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchBodyArgs',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchBodyArgsDict',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesArgs',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesArgsDict',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgsDict',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderArgs',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderArgsDict',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgsDict',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderOrderArgs',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderOrderArgsDict',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchJa3FingerprintArgsDict',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyArgs',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyArgsDict',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchMethodArgs',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchMethodArgsDict',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchQueryStringArgs',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchQueryStringArgsDict',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleHeaderArgs',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleHeaderArgsDict',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgsDict',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchUriPathArgs',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchUriPathArgsDict',
    'RuleGroupRuleStatementSqliMatchStatementTextTransformationArgs',
    'RuleGroupRuleStatementSqliMatchStatementTextTransformationArgsDict',
    'RuleGroupRuleStatementXssMatchStatementArgs',
    'RuleGroupRuleStatementXssMatchStatementArgsDict',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchArgs',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchArgsDict',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgsDict',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchBodyArgs',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchBodyArgsDict',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesArgs',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesArgsDict',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgsDict',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderArgs',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderArgsDict',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgsDict',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderOrderArgs',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderOrderArgsDict',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchJa3FingerprintArgs',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchJa3FingerprintArgsDict',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyArgs',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyArgsDict',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchMethodArgs',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchMethodArgsDict',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchQueryStringArgs',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchQueryStringArgsDict',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleHeaderArgs',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleHeaderArgsDict',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgsDict',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchUriPathArgs',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchUriPathArgsDict',
    'RuleGroupRuleStatementXssMatchStatementTextTransformationArgs',
    'RuleGroupRuleStatementXssMatchStatementTextTransformationArgsDict',
    'RuleGroupRuleVisibilityConfigArgs',
    'RuleGroupRuleVisibilityConfigArgsDict',
    'RuleGroupVisibilityConfigArgs',
    'RuleGroupVisibilityConfigArgsDict',
    'WebAclAssociationConfigArgs',
    'WebAclAssociationConfigArgsDict',
    'WebAclAssociationConfigRequestBodyArgs',
    'WebAclAssociationConfigRequestBodyArgsDict',
    'WebAclAssociationConfigRequestBodyApiGatewayArgs',
    'WebAclAssociationConfigRequestBodyApiGatewayArgsDict',
    'WebAclAssociationConfigRequestBodyAppRunnerServiceArgs',
    'WebAclAssociationConfigRequestBodyAppRunnerServiceArgsDict',
    'WebAclAssociationConfigRequestBodyCloudfrontArgs',
    'WebAclAssociationConfigRequestBodyCloudfrontArgsDict',
    'WebAclAssociationConfigRequestBodyCognitoUserPoolArgs',
    'WebAclAssociationConfigRequestBodyCognitoUserPoolArgsDict',
    'WebAclAssociationConfigRequestBodyVerifiedAccessInstanceArgs',
    'WebAclAssociationConfigRequestBodyVerifiedAccessInstanceArgsDict',
    'WebAclCaptchaConfigArgs',
    'WebAclCaptchaConfigArgsDict',
    'WebAclCaptchaConfigImmunityTimePropertyArgs',
    'WebAclCaptchaConfigImmunityTimePropertyArgsDict',
    'WebAclChallengeConfigArgs',
    'WebAclChallengeConfigArgsDict',
    'WebAclChallengeConfigImmunityTimePropertyArgs',
    'WebAclChallengeConfigImmunityTimePropertyArgsDict',
    'WebAclCustomResponseBodyArgs',
    'WebAclCustomResponseBodyArgsDict',
    'WebAclDefaultActionArgs',
    'WebAclDefaultActionArgsDict',
    'WebAclDefaultActionAllowArgs',
    'WebAclDefaultActionAllowArgsDict',
    'WebAclDefaultActionAllowCustomRequestHandlingArgs',
    'WebAclDefaultActionAllowCustomRequestHandlingArgsDict',
    'WebAclDefaultActionAllowCustomRequestHandlingInsertHeaderArgs',
    'WebAclDefaultActionAllowCustomRequestHandlingInsertHeaderArgsDict',
    'WebAclDefaultActionBlockArgs',
    'WebAclDefaultActionBlockArgsDict',
    'WebAclDefaultActionBlockCustomResponseArgs',
    'WebAclDefaultActionBlockCustomResponseArgsDict',
    'WebAclDefaultActionBlockCustomResponseResponseHeaderArgs',
    'WebAclDefaultActionBlockCustomResponseResponseHeaderArgsDict',
    'WebAclLoggingConfigurationLoggingFilterArgs',
    'WebAclLoggingConfigurationLoggingFilterArgsDict',
    'WebAclLoggingConfigurationLoggingFilterFilterArgs',
    'WebAclLoggingConfigurationLoggingFilterFilterArgsDict',
    'WebAclLoggingConfigurationLoggingFilterFilterConditionArgs',
    'WebAclLoggingConfigurationLoggingFilterFilterConditionArgsDict',
    'WebAclLoggingConfigurationLoggingFilterFilterConditionActionConditionArgs',
    'WebAclLoggingConfigurationLoggingFilterFilterConditionActionConditionArgsDict',
    'WebAclLoggingConfigurationLoggingFilterFilterConditionLabelNameConditionArgs',
    'WebAclLoggingConfigurationLoggingFilterFilterConditionLabelNameConditionArgsDict',
    'WebAclLoggingConfigurationRedactedFieldArgs',
    'WebAclLoggingConfigurationRedactedFieldArgsDict',
    'WebAclLoggingConfigurationRedactedFieldMethodArgs',
    'WebAclLoggingConfigurationRedactedFieldMethodArgsDict',
    'WebAclLoggingConfigurationRedactedFieldQueryStringArgs',
    'WebAclLoggingConfigurationRedactedFieldQueryStringArgsDict',
    'WebAclLoggingConfigurationRedactedFieldSingleHeaderArgs',
    'WebAclLoggingConfigurationRedactedFieldSingleHeaderArgsDict',
    'WebAclLoggingConfigurationRedactedFieldUriPathArgs',
    'WebAclLoggingConfigurationRedactedFieldUriPathArgsDict',
    'WebAclRuleArgs',
    'WebAclRuleArgsDict',
    'WebAclRuleActionArgs',
    'WebAclRuleActionArgsDict',
    'WebAclRuleActionAllowArgs',
    'WebAclRuleActionAllowArgsDict',
    'WebAclRuleActionAllowCustomRequestHandlingArgs',
    'WebAclRuleActionAllowCustomRequestHandlingArgsDict',
    'WebAclRuleActionAllowCustomRequestHandlingInsertHeaderArgs',
    'WebAclRuleActionAllowCustomRequestHandlingInsertHeaderArgsDict',
    'WebAclRuleActionBlockArgs',
    'WebAclRuleActionBlockArgsDict',
    'WebAclRuleActionBlockCustomResponseArgs',
    'WebAclRuleActionBlockCustomResponseArgsDict',
    'WebAclRuleActionBlockCustomResponseResponseHeaderArgs',
    'WebAclRuleActionBlockCustomResponseResponseHeaderArgsDict',
    'WebAclRuleActionCaptchaArgs',
    'WebAclRuleActionCaptchaArgsDict',
    'WebAclRuleActionCaptchaCustomRequestHandlingArgs',
    'WebAclRuleActionCaptchaCustomRequestHandlingArgsDict',
    'WebAclRuleActionCaptchaCustomRequestHandlingInsertHeaderArgs',
    'WebAclRuleActionCaptchaCustomRequestHandlingInsertHeaderArgsDict',
    'WebAclRuleActionChallengeArgs',
    'WebAclRuleActionChallengeArgsDict',
    'WebAclRuleActionChallengeCustomRequestHandlingArgs',
    'WebAclRuleActionChallengeCustomRequestHandlingArgsDict',
    'WebAclRuleActionChallengeCustomRequestHandlingInsertHeaderArgs',
    'WebAclRuleActionChallengeCustomRequestHandlingInsertHeaderArgsDict',
    'WebAclRuleActionCountArgs',
    'WebAclRuleActionCountArgsDict',
    'WebAclRuleActionCountCustomRequestHandlingArgs',
    'WebAclRuleActionCountCustomRequestHandlingArgsDict',
    'WebAclRuleActionCountCustomRequestHandlingInsertHeaderArgs',
    'WebAclRuleActionCountCustomRequestHandlingInsertHeaderArgsDict',
    'WebAclRuleCaptchaConfigArgs',
    'WebAclRuleCaptchaConfigArgsDict',
    'WebAclRuleCaptchaConfigImmunityTimePropertyArgs',
    'WebAclRuleCaptchaConfigImmunityTimePropertyArgsDict',
    'WebAclRuleOverrideActionArgs',
    'WebAclRuleOverrideActionArgsDict',
    'WebAclRuleOverrideActionCountArgs',
    'WebAclRuleOverrideActionCountArgsDict',
    'WebAclRuleOverrideActionNoneArgs',
    'WebAclRuleOverrideActionNoneArgsDict',
    'WebAclRuleRuleLabelArgs',
    'WebAclRuleRuleLabelArgsDict',
    'WebAclRuleStatementArgs',
    'WebAclRuleStatementArgsDict',
    'WebAclRuleStatementAndStatementArgs',
    'WebAclRuleStatementAndStatementArgsDict',
    'WebAclRuleStatementByteMatchStatementArgs',
    'WebAclRuleStatementByteMatchStatementArgsDict',
    'WebAclRuleStatementByteMatchStatementFieldToMatchArgs',
    'WebAclRuleStatementByteMatchStatementFieldToMatchArgsDict',
    'WebAclRuleStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs',
    'WebAclRuleStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgsDict',
    'WebAclRuleStatementByteMatchStatementFieldToMatchBodyArgs',
    'WebAclRuleStatementByteMatchStatementFieldToMatchBodyArgsDict',
    'WebAclRuleStatementByteMatchStatementFieldToMatchCookiesArgs',
    'WebAclRuleStatementByteMatchStatementFieldToMatchCookiesArgsDict',
    'WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs',
    'WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgsDict',
    'WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs',
    'WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict',
    'WebAclRuleStatementByteMatchStatementFieldToMatchHeaderArgs',
    'WebAclRuleStatementByteMatchStatementFieldToMatchHeaderArgsDict',
    'WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs',
    'WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgsDict',
    'WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs',
    'WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict',
    'WebAclRuleStatementByteMatchStatementFieldToMatchHeaderOrderArgs',
    'WebAclRuleStatementByteMatchStatementFieldToMatchHeaderOrderArgsDict',
    'WebAclRuleStatementByteMatchStatementFieldToMatchJa3FingerprintArgs',
    'WebAclRuleStatementByteMatchStatementFieldToMatchJa3FingerprintArgsDict',
    'WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyArgs',
    'WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyArgsDict',
    'WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs',
    'WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict',
    'WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict',
    'WebAclRuleStatementByteMatchStatementFieldToMatchMethodArgs',
    'WebAclRuleStatementByteMatchStatementFieldToMatchMethodArgsDict',
    'WebAclRuleStatementByteMatchStatementFieldToMatchQueryStringArgs',
    'WebAclRuleStatementByteMatchStatementFieldToMatchQueryStringArgsDict',
    'WebAclRuleStatementByteMatchStatementFieldToMatchSingleHeaderArgs',
    'WebAclRuleStatementByteMatchStatementFieldToMatchSingleHeaderArgsDict',
    'WebAclRuleStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs',
    'WebAclRuleStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgsDict',
    'WebAclRuleStatementByteMatchStatementFieldToMatchUriPathArgs',
    'WebAclRuleStatementByteMatchStatementFieldToMatchUriPathArgsDict',
    'WebAclRuleStatementByteMatchStatementTextTransformationArgs',
    'WebAclRuleStatementByteMatchStatementTextTransformationArgsDict',
    'WebAclRuleStatementGeoMatchStatementArgs',
    'WebAclRuleStatementGeoMatchStatementArgsDict',
    'WebAclRuleStatementGeoMatchStatementForwardedIpConfigArgs',
    'WebAclRuleStatementGeoMatchStatementForwardedIpConfigArgsDict',
    'WebAclRuleStatementIpSetReferenceStatementArgs',
    'WebAclRuleStatementIpSetReferenceStatementArgsDict',
    'WebAclRuleStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs',
    'WebAclRuleStatementIpSetReferenceStatementIpSetForwardedIpConfigArgsDict',
    'WebAclRuleStatementLabelMatchStatementArgs',
    'WebAclRuleStatementLabelMatchStatementArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementArgs',
    'WebAclRuleStatementManagedRuleGroupStatementArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionAddressFieldsArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionAddressFieldsArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionEmailFieldArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionEmailFieldArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionPasswordFieldArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionPasswordFieldArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionPhoneNumberFieldsArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionPhoneNumberFieldsArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionUsernameFieldArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionUsernameFieldArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionBodyContainsArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionBodyContainsArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionHeaderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionHeaderArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionJsonArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionJsonArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionStatusCodeArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionStatusCodeArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionPasswordFieldArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionPasswordFieldArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionUsernameFieldArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionUsernameFieldArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionBodyContainsArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionBodyContainsArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionHeaderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionHeaderArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionJsonArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionJsonArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionStatusCodeArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionStatusCodeArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesBotControlRuleSetArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesBotControlRuleSetArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigPasswordFieldArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigPasswordFieldArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigUsernameFieldArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigUsernameFieldArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideArgs',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseArgs',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowArgs',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingArgs',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeaderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeaderArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockArgs',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponseArgs',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponseArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeaderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeaderArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaArgs',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingArgs',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeaderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeaderArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeArgs',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingArgs',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeaderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeaderArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountArgs',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandlingArgs',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandlingArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeaderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeaderArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAndStatementArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAndStatementArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementTextTransformationArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementTextTransformationArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementLabelMatchStatementArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementLabelMatchStatementArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementNotStatementArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementNotStatementArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementOrStatementArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementOrStatementArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementTextTransformationArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementTextTransformationArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementTextTransformationArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementTextTransformationArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementTextTransformationArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementTextTransformationArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementTextTransformationArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementTextTransformationArgsDict',
    'WebAclRuleStatementNotStatementArgs',
    'WebAclRuleStatementNotStatementArgsDict',
    'WebAclRuleStatementOrStatementArgs',
    'WebAclRuleStatementOrStatementArgsDict',
    'WebAclRuleStatementRateBasedStatementArgs',
    'WebAclRuleStatementRateBasedStatementArgsDict',
    'WebAclRuleStatementRateBasedStatementCustomKeyArgs',
    'WebAclRuleStatementRateBasedStatementCustomKeyArgsDict',
    'WebAclRuleStatementRateBasedStatementCustomKeyCookieArgs',
    'WebAclRuleStatementRateBasedStatementCustomKeyCookieArgsDict',
    'WebAclRuleStatementRateBasedStatementCustomKeyCookieTextTransformationArgs',
    'WebAclRuleStatementRateBasedStatementCustomKeyCookieTextTransformationArgsDict',
    'WebAclRuleStatementRateBasedStatementCustomKeyForwardedIpArgs',
    'WebAclRuleStatementRateBasedStatementCustomKeyForwardedIpArgsDict',
    'WebAclRuleStatementRateBasedStatementCustomKeyHeaderArgs',
    'WebAclRuleStatementRateBasedStatementCustomKeyHeaderArgsDict',
    'WebAclRuleStatementRateBasedStatementCustomKeyHeaderTextTransformationArgs',
    'WebAclRuleStatementRateBasedStatementCustomKeyHeaderTextTransformationArgsDict',
    'WebAclRuleStatementRateBasedStatementCustomKeyHttpMethodArgs',
    'WebAclRuleStatementRateBasedStatementCustomKeyHttpMethodArgsDict',
    'WebAclRuleStatementRateBasedStatementCustomKeyIpArgs',
    'WebAclRuleStatementRateBasedStatementCustomKeyIpArgsDict',
    'WebAclRuleStatementRateBasedStatementCustomKeyLabelNamespaceArgs',
    'WebAclRuleStatementRateBasedStatementCustomKeyLabelNamespaceArgsDict',
    'WebAclRuleStatementRateBasedStatementCustomKeyQueryArgumentArgs',
    'WebAclRuleStatementRateBasedStatementCustomKeyQueryArgumentArgsDict',
    'WebAclRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformationArgs',
    'WebAclRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformationArgsDict',
    'WebAclRuleStatementRateBasedStatementCustomKeyQueryStringArgs',
    'WebAclRuleStatementRateBasedStatementCustomKeyQueryStringArgsDict',
    'WebAclRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformationArgs',
    'WebAclRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformationArgsDict',
    'WebAclRuleStatementRateBasedStatementCustomKeyUriPathArgs',
    'WebAclRuleStatementRateBasedStatementCustomKeyUriPathArgsDict',
    'WebAclRuleStatementRateBasedStatementCustomKeyUriPathTextTransformationArgs',
    'WebAclRuleStatementRateBasedStatementCustomKeyUriPathTextTransformationArgsDict',
    'WebAclRuleStatementRateBasedStatementForwardedIpConfigArgs',
    'WebAclRuleStatementRateBasedStatementForwardedIpConfigArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementAndStatementArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementAndStatementArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformationArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformationArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatementArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatementArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementNotStatementArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementNotStatementArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementOrStatementArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementOrStatementArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformationArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformationArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformationArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformationArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformationArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformationArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformationArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformationArgsDict',
    'WebAclRuleStatementRegexMatchStatementArgs',
    'WebAclRuleStatementRegexMatchStatementArgsDict',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchArgs',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchArgsDict',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgsDict',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchBodyArgs',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchBodyArgsDict',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesArgs',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesArgsDict',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgsDict',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderArgs',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderArgsDict',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgsDict',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderOrderArgs',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderOrderArgsDict',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchJa3FingerprintArgsDict',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyArgs',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyArgsDict',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchMethodArgs',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchMethodArgsDict',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchQueryStringArgs',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchQueryStringArgsDict',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchSingleHeaderArgs',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchSingleHeaderArgsDict',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgsDict',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchUriPathArgs',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchUriPathArgsDict',
    'WebAclRuleStatementRegexMatchStatementTextTransformationArgs',
    'WebAclRuleStatementRegexMatchStatementTextTransformationArgsDict',
    'WebAclRuleStatementRegexPatternSetReferenceStatementArgs',
    'WebAclRuleStatementRegexPatternSetReferenceStatementArgsDict',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchArgs',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchArgsDict',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgsDict',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgsDict',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgsDict',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgsDict',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgsDict',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgsDict',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgsDict',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgsDict',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgsDict',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgsDict',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgsDict',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgsDict',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgsDict',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgsDict',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgsDict',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgsDict',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgsDict',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgsDict',
    'WebAclRuleStatementRegexPatternSetReferenceStatementTextTransformationArgs',
    'WebAclRuleStatementRegexPatternSetReferenceStatementTextTransformationArgsDict',
    'WebAclRuleStatementRuleGroupReferenceStatementArgs',
    'WebAclRuleStatementRuleGroupReferenceStatementArgsDict',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideArgs',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideArgsDict',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseArgs',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseArgsDict',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowArgs',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowArgsDict',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingArgs',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingArgsDict',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeaderArgs',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeaderArgsDict',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockArgs',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockArgsDict',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponseArgs',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponseArgsDict',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeaderArgs',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeaderArgsDict',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaArgs',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaArgsDict',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingArgs',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingArgsDict',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeaderArgs',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeaderArgsDict',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeArgs',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeArgsDict',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingArgs',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingArgsDict',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeaderArgs',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeaderArgsDict',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountArgs',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountArgsDict',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandlingArgs',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandlingArgsDict',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeaderArgs',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeaderArgsDict',
    'WebAclRuleStatementSizeConstraintStatementArgs',
    'WebAclRuleStatementSizeConstraintStatementArgsDict',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchArgs',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchArgsDict',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgsDict',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchBodyArgs',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchBodyArgsDict',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesArgs',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesArgsDict',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgsDict',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgsDict',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderArgs',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderArgsDict',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgsDict',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgsDict',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderOrderArgsDict',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgsDict',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyArgs',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyArgsDict',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgsDict',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgsDict',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchMethodArgs',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchMethodArgsDict',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchQueryStringArgs',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchQueryStringArgsDict',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleHeaderArgsDict',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgsDict',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchUriPathArgs',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchUriPathArgsDict',
    'WebAclRuleStatementSizeConstraintStatementTextTransformationArgs',
    'WebAclRuleStatementSizeConstraintStatementTextTransformationArgsDict',
    'WebAclRuleStatementSqliMatchStatementArgs',
    'WebAclRuleStatementSqliMatchStatementArgsDict',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchArgs',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchArgsDict',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgsDict',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchBodyArgs',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchBodyArgsDict',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesArgs',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesArgsDict',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgsDict',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderArgs',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderArgsDict',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgsDict',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderOrderArgs',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderOrderArgsDict',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchJa3FingerprintArgsDict',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyArgs',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyArgsDict',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchMethodArgs',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchMethodArgsDict',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchQueryStringArgs',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchQueryStringArgsDict',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchSingleHeaderArgs',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchSingleHeaderArgsDict',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgsDict',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchUriPathArgs',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchUriPathArgsDict',
    'WebAclRuleStatementSqliMatchStatementTextTransformationArgs',
    'WebAclRuleStatementSqliMatchStatementTextTransformationArgsDict',
    'WebAclRuleStatementXssMatchStatementArgs',
    'WebAclRuleStatementXssMatchStatementArgsDict',
    'WebAclRuleStatementXssMatchStatementFieldToMatchArgs',
    'WebAclRuleStatementXssMatchStatementFieldToMatchArgsDict',
    'WebAclRuleStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs',
    'WebAclRuleStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgsDict',
    'WebAclRuleStatementXssMatchStatementFieldToMatchBodyArgs',
    'WebAclRuleStatementXssMatchStatementFieldToMatchBodyArgsDict',
    'WebAclRuleStatementXssMatchStatementFieldToMatchCookiesArgs',
    'WebAclRuleStatementXssMatchStatementFieldToMatchCookiesArgsDict',
    'WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs',
    'WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgsDict',
    'WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs',
    'WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict',
    'WebAclRuleStatementXssMatchStatementFieldToMatchHeaderArgs',
    'WebAclRuleStatementXssMatchStatementFieldToMatchHeaderArgsDict',
    'WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs',
    'WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgsDict',
    'WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs',
    'WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict',
    'WebAclRuleStatementXssMatchStatementFieldToMatchHeaderOrderArgs',
    'WebAclRuleStatementXssMatchStatementFieldToMatchHeaderOrderArgsDict',
    'WebAclRuleStatementXssMatchStatementFieldToMatchJa3FingerprintArgs',
    'WebAclRuleStatementXssMatchStatementFieldToMatchJa3FingerprintArgsDict',
    'WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyArgs',
    'WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyArgsDict',
    'WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs',
    'WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict',
    'WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict',
    'WebAclRuleStatementXssMatchStatementFieldToMatchMethodArgs',
    'WebAclRuleStatementXssMatchStatementFieldToMatchMethodArgsDict',
    'WebAclRuleStatementXssMatchStatementFieldToMatchQueryStringArgs',
    'WebAclRuleStatementXssMatchStatementFieldToMatchQueryStringArgsDict',
    'WebAclRuleStatementXssMatchStatementFieldToMatchSingleHeaderArgs',
    'WebAclRuleStatementXssMatchStatementFieldToMatchSingleHeaderArgsDict',
    'WebAclRuleStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs',
    'WebAclRuleStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgsDict',
    'WebAclRuleStatementXssMatchStatementFieldToMatchUriPathArgs',
    'WebAclRuleStatementXssMatchStatementFieldToMatchUriPathArgsDict',
    'WebAclRuleStatementXssMatchStatementTextTransformationArgs',
    'WebAclRuleStatementXssMatchStatementTextTransformationArgsDict',
    'WebAclRuleVisibilityConfigArgs',
    'WebAclRuleVisibilityConfigArgsDict',
    'WebAclVisibilityConfigArgs',
    'WebAclVisibilityConfigArgsDict',
]

MYPY = False

if not MYPY:
    class RegexPatternSetRegularExpressionArgsDict(TypedDict):
        regex_string: pulumi.Input[str]
        """
        The string representing the regular expression, see the AWS WAF [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-regex-pattern-set-creating.html) for more information.
        """
elif False:
    RegexPatternSetRegularExpressionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RegexPatternSetRegularExpressionArgs:
    def __init__(__self__, *,
                 regex_string: pulumi.Input[str]):
        """
        :param pulumi.Input[str] regex_string: The string representing the regular expression, see the AWS WAF [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-regex-pattern-set-creating.html) for more information.
        """
        pulumi.set(__self__, "regex_string", regex_string)

    @property
    @pulumi.getter(name="regexString")
    def regex_string(self) -> pulumi.Input[str]:
        """
        The string representing the regular expression, see the AWS WAF [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-regex-pattern-set-creating.html) for more information.
        """
        return pulumi.get(self, "regex_string")

    @regex_string.setter
    def regex_string(self, value: pulumi.Input[str]):
        pulumi.set(self, "regex_string", value)


if not MYPY:
    class RuleGroupCustomResponseBodyArgsDict(TypedDict):
        content: pulumi.Input[str]
        """
        The payload of the custom response.
        """
        content_type: pulumi.Input[str]
        """
        The type of content in the payload that you are defining in the `content` argument. Valid values are `TEXT_PLAIN`, `TEXT_HTML`, or `APPLICATION_JSON`.
        """
        key: pulumi.Input[str]
        """
        A unique key identifying the custom response body. This is referenced by the `custom_response_body_key` argument in the Custom Response block.
        """
elif False:
    RuleGroupCustomResponseBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupCustomResponseBodyArgs:
    def __init__(__self__, *,
                 content: pulumi.Input[str],
                 content_type: pulumi.Input[str],
                 key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] content: The payload of the custom response.
        :param pulumi.Input[str] content_type: The type of content in the payload that you are defining in the `content` argument. Valid values are `TEXT_PLAIN`, `TEXT_HTML`, or `APPLICATION_JSON`.
        :param pulumi.Input[str] key: A unique key identifying the custom response body. This is referenced by the `custom_response_body_key` argument in the Custom Response block.
        """
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "content_type", content_type)
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def content(self) -> pulumi.Input[str]:
        """
        The payload of the custom response.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: pulumi.Input[str]):
        pulumi.set(self, "content", value)

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> pulumi.Input[str]:
        """
        The type of content in the payload that you are defining in the `content` argument. Valid values are `TEXT_PLAIN`, `TEXT_HTML`, or `APPLICATION_JSON`.
        """
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "content_type", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        A unique key identifying the custom response body. This is referenced by the `custom_response_body_key` argument in the Custom Response block.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)


if not MYPY:
    class RuleGroupRuleArgsDict(TypedDict):
        action: pulumi.Input['RuleGroupRuleActionArgsDict']
        """
        The action that AWS WAF should take on a web request when it matches the rule's statement. Settings at the `wafv2.WebAcl` level can override the rule action setting. See Action below for details.
        """
        name: pulumi.Input[str]
        """
        A friendly name of the rule.
        """
        priority: pulumi.Input[int]
        """
        If you define more than one Rule in a WebACL, AWS WAF evaluates each request against the `rules` in order based on the value of `priority`. AWS WAF processes rules with lower priority first.
        """
        statement: pulumi.Input['RuleGroupRuleStatementArgsDict']
        """
        The AWS WAF processing statement for the rule, for example `byte_match_statement` or `geo_match_statement`. See Statement below for details.
        """
        visibility_config: pulumi.Input['RuleGroupRuleVisibilityConfigArgsDict']
        """
        Defines and enables Amazon CloudWatch metrics and web request sample collection. See Visibility Configuration below for details.
        """
        captcha_config: NotRequired[pulumi.Input['RuleGroupRuleCaptchaConfigArgsDict']]
        """
        Specifies how AWS WAF should handle CAPTCHA evaluations. See Captcha Configuration below for details.
        """
        rule_labels: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleRuleLabelArgsDict']]]]
        """
        Labels to apply to web requests that match the rule match statement. See Rule Label below for details.
        """
elif False:
    RuleGroupRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleArgs:
    def __init__(__self__, *,
                 action: pulumi.Input['RuleGroupRuleActionArgs'],
                 name: pulumi.Input[str],
                 priority: pulumi.Input[int],
                 statement: pulumi.Input['RuleGroupRuleStatementArgs'],
                 visibility_config: pulumi.Input['RuleGroupRuleVisibilityConfigArgs'],
                 captcha_config: Optional[pulumi.Input['RuleGroupRuleCaptchaConfigArgs']] = None,
                 rule_labels: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleRuleLabelArgs']]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleActionArgs'] action: The action that AWS WAF should take on a web request when it matches the rule's statement. Settings at the `wafv2.WebAcl` level can override the rule action setting. See Action below for details.
        :param pulumi.Input[str] name: A friendly name of the rule.
        :param pulumi.Input[int] priority: If you define more than one Rule in a WebACL, AWS WAF evaluates each request against the `rules` in order based on the value of `priority`. AWS WAF processes rules with lower priority first.
        :param pulumi.Input['RuleGroupRuleStatementArgs'] statement: The AWS WAF processing statement for the rule, for example `byte_match_statement` or `geo_match_statement`. See Statement below for details.
        :param pulumi.Input['RuleGroupRuleVisibilityConfigArgs'] visibility_config: Defines and enables Amazon CloudWatch metrics and web request sample collection. See Visibility Configuration below for details.
        :param pulumi.Input['RuleGroupRuleCaptchaConfigArgs'] captcha_config: Specifies how AWS WAF should handle CAPTCHA evaluations. See Captcha Configuration below for details.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleRuleLabelArgs']]] rule_labels: Labels to apply to web requests that match the rule match statement. See Rule Label below for details.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "statement", statement)
        pulumi.set(__self__, "visibility_config", visibility_config)
        if captcha_config is not None:
            pulumi.set(__self__, "captcha_config", captcha_config)
        if rule_labels is not None:
            pulumi.set(__self__, "rule_labels", rule_labels)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input['RuleGroupRuleActionArgs']:
        """
        The action that AWS WAF should take on a web request when it matches the rule's statement. Settings at the `wafv2.WebAcl` level can override the rule action setting. See Action below for details.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input['RuleGroupRuleActionArgs']):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        A friendly name of the rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        If you define more than one Rule in a WebACL, AWS WAF evaluates each request against the `rules` in order based on the value of `priority`. AWS WAF processes rules with lower priority first.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def statement(self) -> pulumi.Input['RuleGroupRuleStatementArgs']:
        """
        The AWS WAF processing statement for the rule, for example `byte_match_statement` or `geo_match_statement`. See Statement below for details.
        """
        return pulumi.get(self, "statement")

    @statement.setter
    def statement(self, value: pulumi.Input['RuleGroupRuleStatementArgs']):
        pulumi.set(self, "statement", value)

    @property
    @pulumi.getter(name="visibilityConfig")
    def visibility_config(self) -> pulumi.Input['RuleGroupRuleVisibilityConfigArgs']:
        """
        Defines and enables Amazon CloudWatch metrics and web request sample collection. See Visibility Configuration below for details.
        """
        return pulumi.get(self, "visibility_config")

    @visibility_config.setter
    def visibility_config(self, value: pulumi.Input['RuleGroupRuleVisibilityConfigArgs']):
        pulumi.set(self, "visibility_config", value)

    @property
    @pulumi.getter(name="captchaConfig")
    def captcha_config(self) -> Optional[pulumi.Input['RuleGroupRuleCaptchaConfigArgs']]:
        """
        Specifies how AWS WAF should handle CAPTCHA evaluations. See Captcha Configuration below for details.
        """
        return pulumi.get(self, "captcha_config")

    @captcha_config.setter
    def captcha_config(self, value: Optional[pulumi.Input['RuleGroupRuleCaptchaConfigArgs']]):
        pulumi.set(self, "captcha_config", value)

    @property
    @pulumi.getter(name="ruleLabels")
    def rule_labels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleRuleLabelArgs']]]]:
        """
        Labels to apply to web requests that match the rule match statement. See Rule Label below for details.
        """
        return pulumi.get(self, "rule_labels")

    @rule_labels.setter
    def rule_labels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleRuleLabelArgs']]]]):
        pulumi.set(self, "rule_labels", value)


if not MYPY:
    class RuleGroupRuleActionArgsDict(TypedDict):
        allow: NotRequired[pulumi.Input['RuleGroupRuleActionAllowArgsDict']]
        """
        Instructs AWS WAF to allow the web request. See Allow below for details.
        """
        block: NotRequired[pulumi.Input['RuleGroupRuleActionBlockArgsDict']]
        """
        Instructs AWS WAF to block the web request. See Block below for details.
        """
        captcha: NotRequired[pulumi.Input['RuleGroupRuleActionCaptchaArgsDict']]
        """
        Instructs AWS WAF to run a `CAPTCHA` check against the web request. See Captcha below for details.
        """
        challenge: NotRequired[pulumi.Input['RuleGroupRuleActionChallengeArgsDict']]
        """
        Instructs AWS WAF to run a check against the request to verify that the request is coming from a legitimate client session. See Challenge below for details.
        """
        count: NotRequired[pulumi.Input['RuleGroupRuleActionCountArgsDict']]
        """
        Instructs AWS WAF to count the web request and allow it. See Count below for details.
        """
elif False:
    RuleGroupRuleActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleActionArgs:
    def __init__(__self__, *,
                 allow: Optional[pulumi.Input['RuleGroupRuleActionAllowArgs']] = None,
                 block: Optional[pulumi.Input['RuleGroupRuleActionBlockArgs']] = None,
                 captcha: Optional[pulumi.Input['RuleGroupRuleActionCaptchaArgs']] = None,
                 challenge: Optional[pulumi.Input['RuleGroupRuleActionChallengeArgs']] = None,
                 count: Optional[pulumi.Input['RuleGroupRuleActionCountArgs']] = None):
        """
        :param pulumi.Input['RuleGroupRuleActionAllowArgs'] allow: Instructs AWS WAF to allow the web request. See Allow below for details.
        :param pulumi.Input['RuleGroupRuleActionBlockArgs'] block: Instructs AWS WAF to block the web request. See Block below for details.
        :param pulumi.Input['RuleGroupRuleActionCaptchaArgs'] captcha: Instructs AWS WAF to run a `CAPTCHA` check against the web request. See Captcha below for details.
        :param pulumi.Input['RuleGroupRuleActionChallengeArgs'] challenge: Instructs AWS WAF to run a check against the request to verify that the request is coming from a legitimate client session. See Challenge below for details.
        :param pulumi.Input['RuleGroupRuleActionCountArgs'] count: Instructs AWS WAF to count the web request and allow it. See Count below for details.
        """
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if block is not None:
            pulumi.set(__self__, "block", block)
        if captcha is not None:
            pulumi.set(__self__, "captcha", captcha)
        if challenge is not None:
            pulumi.set(__self__, "challenge", challenge)
        if count is not None:
            pulumi.set(__self__, "count", count)

    @property
    @pulumi.getter
    def allow(self) -> Optional[pulumi.Input['RuleGroupRuleActionAllowArgs']]:
        """
        Instructs AWS WAF to allow the web request. See Allow below for details.
        """
        return pulumi.get(self, "allow")

    @allow.setter
    def allow(self, value: Optional[pulumi.Input['RuleGroupRuleActionAllowArgs']]):
        pulumi.set(self, "allow", value)

    @property
    @pulumi.getter
    def block(self) -> Optional[pulumi.Input['RuleGroupRuleActionBlockArgs']]:
        """
        Instructs AWS WAF to block the web request. See Block below for details.
        """
        return pulumi.get(self, "block")

    @block.setter
    def block(self, value: Optional[pulumi.Input['RuleGroupRuleActionBlockArgs']]):
        pulumi.set(self, "block", value)

    @property
    @pulumi.getter
    def captcha(self) -> Optional[pulumi.Input['RuleGroupRuleActionCaptchaArgs']]:
        """
        Instructs AWS WAF to run a `CAPTCHA` check against the web request. See Captcha below for details.
        """
        return pulumi.get(self, "captcha")

    @captcha.setter
    def captcha(self, value: Optional[pulumi.Input['RuleGroupRuleActionCaptchaArgs']]):
        pulumi.set(self, "captcha", value)

    @property
    @pulumi.getter
    def challenge(self) -> Optional[pulumi.Input['RuleGroupRuleActionChallengeArgs']]:
        """
        Instructs AWS WAF to run a check against the request to verify that the request is coming from a legitimate client session. See Challenge below for details.
        """
        return pulumi.get(self, "challenge")

    @challenge.setter
    def challenge(self, value: Optional[pulumi.Input['RuleGroupRuleActionChallengeArgs']]):
        pulumi.set(self, "challenge", value)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input['RuleGroupRuleActionCountArgs']]:
        """
        Instructs AWS WAF to count the web request and allow it. See Count below for details.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input['RuleGroupRuleActionCountArgs']]):
        pulumi.set(self, "count", value)


if not MYPY:
    class RuleGroupRuleActionAllowArgsDict(TypedDict):
        custom_request_handling: NotRequired[pulumi.Input['RuleGroupRuleActionAllowCustomRequestHandlingArgsDict']]
        """
        Defines custom handling for the web request. See Custom Request Handling below for details.
        """
elif False:
    RuleGroupRuleActionAllowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleActionAllowArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['RuleGroupRuleActionAllowCustomRequestHandlingArgs']] = None):
        """
        :param pulumi.Input['RuleGroupRuleActionAllowCustomRequestHandlingArgs'] custom_request_handling: Defines custom handling for the web request. See Custom Request Handling below for details.
        """
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['RuleGroupRuleActionAllowCustomRequestHandlingArgs']]:
        """
        Defines custom handling for the web request. See Custom Request Handling below for details.
        """
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['RuleGroupRuleActionAllowCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


if not MYPY:
    class RuleGroupRuleActionAllowCustomRequestHandlingArgsDict(TypedDict):
        insert_headers: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleActionAllowCustomRequestHandlingInsertHeaderArgsDict']]]
        """
        The `insert_header` blocks used to define HTTP headers added to the request. See Custom HTTP Header below for details.
        """
elif False:
    RuleGroupRuleActionAllowCustomRequestHandlingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleActionAllowCustomRequestHandlingArgs:
    def __init__(__self__, *,
                 insert_headers: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleActionAllowCustomRequestHandlingInsertHeaderArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleActionAllowCustomRequestHandlingInsertHeaderArgs']]] insert_headers: The `insert_header` blocks used to define HTTP headers added to the request. See Custom HTTP Header below for details.
        """
        pulumi.set(__self__, "insert_headers", insert_headers)

    @property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleActionAllowCustomRequestHandlingInsertHeaderArgs']]]:
        """
        The `insert_header` blocks used to define HTTP headers added to the request. See Custom HTTP Header below for details.
        """
        return pulumi.get(self, "insert_headers")

    @insert_headers.setter
    def insert_headers(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleActionAllowCustomRequestHandlingInsertHeaderArgs']]]):
        pulumi.set(self, "insert_headers", value)


if not MYPY:
    class RuleGroupRuleActionAllowCustomRequestHandlingInsertHeaderArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        A friendly name of the rule group.
        """
        value: pulumi.Input[str]
        """
        The value of the custom header.
        """
elif False:
    RuleGroupRuleActionAllowCustomRequestHandlingInsertHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleActionAllowCustomRequestHandlingInsertHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: A friendly name of the rule group.
        :param pulumi.Input[str] value: The value of the custom header.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        A friendly name of the rule group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The value of the custom header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class RuleGroupRuleActionBlockArgsDict(TypedDict):
        custom_response: NotRequired[pulumi.Input['RuleGroupRuleActionBlockCustomResponseArgsDict']]
        """
        Defines a custom response for the web request. See Custom Response below for details.
        """
elif False:
    RuleGroupRuleActionBlockArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleActionBlockArgs:
    def __init__(__self__, *,
                 custom_response: Optional[pulumi.Input['RuleGroupRuleActionBlockCustomResponseArgs']] = None):
        """
        :param pulumi.Input['RuleGroupRuleActionBlockCustomResponseArgs'] custom_response: Defines a custom response for the web request. See Custom Response below for details.
        """
        if custom_response is not None:
            pulumi.set(__self__, "custom_response", custom_response)

    @property
    @pulumi.getter(name="customResponse")
    def custom_response(self) -> Optional[pulumi.Input['RuleGroupRuleActionBlockCustomResponseArgs']]:
        """
        Defines a custom response for the web request. See Custom Response below for details.
        """
        return pulumi.get(self, "custom_response")

    @custom_response.setter
    def custom_response(self, value: Optional[pulumi.Input['RuleGroupRuleActionBlockCustomResponseArgs']]):
        pulumi.set(self, "custom_response", value)


if not MYPY:
    class RuleGroupRuleActionBlockCustomResponseArgsDict(TypedDict):
        response_code: pulumi.Input[int]
        """
        The HTTP status code to return to the client.
        """
        custom_response_body_key: NotRequired[pulumi.Input[str]]
        """
        References the response body that you want AWS WAF to return to the web request client. This must reference a `key` defined in a `custom_response_body` block of this resource.
        """
        response_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleActionBlockCustomResponseResponseHeaderArgsDict']]]]
        """
        The `response_header` blocks used to define the HTTP response headers added to the response. See Custom HTTP Header below for details.
        """
elif False:
    RuleGroupRuleActionBlockCustomResponseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleActionBlockCustomResponseArgs:
    def __init__(__self__, *,
                 response_code: pulumi.Input[int],
                 custom_response_body_key: Optional[pulumi.Input[str]] = None,
                 response_headers: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleActionBlockCustomResponseResponseHeaderArgs']]]] = None):
        """
        :param pulumi.Input[int] response_code: The HTTP status code to return to the client.
        :param pulumi.Input[str] custom_response_body_key: References the response body that you want AWS WAF to return to the web request client. This must reference a `key` defined in a `custom_response_body` block of this resource.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleActionBlockCustomResponseResponseHeaderArgs']]] response_headers: The `response_header` blocks used to define the HTTP response headers added to the response. See Custom HTTP Header below for details.
        """
        pulumi.set(__self__, "response_code", response_code)
        if custom_response_body_key is not None:
            pulumi.set(__self__, "custom_response_body_key", custom_response_body_key)
        if response_headers is not None:
            pulumi.set(__self__, "response_headers", response_headers)

    @property
    @pulumi.getter(name="responseCode")
    def response_code(self) -> pulumi.Input[int]:
        """
        The HTTP status code to return to the client.
        """
        return pulumi.get(self, "response_code")

    @response_code.setter
    def response_code(self, value: pulumi.Input[int]):
        pulumi.set(self, "response_code", value)

    @property
    @pulumi.getter(name="customResponseBodyKey")
    def custom_response_body_key(self) -> Optional[pulumi.Input[str]]:
        """
        References the response body that you want AWS WAF to return to the web request client. This must reference a `key` defined in a `custom_response_body` block of this resource.
        """
        return pulumi.get(self, "custom_response_body_key")

    @custom_response_body_key.setter
    def custom_response_body_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_response_body_key", value)

    @property
    @pulumi.getter(name="responseHeaders")
    def response_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleActionBlockCustomResponseResponseHeaderArgs']]]]:
        """
        The `response_header` blocks used to define the HTTP response headers added to the response. See Custom HTTP Header below for details.
        """
        return pulumi.get(self, "response_headers")

    @response_headers.setter
    def response_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleActionBlockCustomResponseResponseHeaderArgs']]]]):
        pulumi.set(self, "response_headers", value)


if not MYPY:
    class RuleGroupRuleActionBlockCustomResponseResponseHeaderArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        A friendly name of the rule group.
        """
        value: pulumi.Input[str]
        """
        The value of the custom header.
        """
elif False:
    RuleGroupRuleActionBlockCustomResponseResponseHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleActionBlockCustomResponseResponseHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: A friendly name of the rule group.
        :param pulumi.Input[str] value: The value of the custom header.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        A friendly name of the rule group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The value of the custom header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class RuleGroupRuleActionCaptchaArgsDict(TypedDict):
        custom_request_handling: NotRequired[pulumi.Input['RuleGroupRuleActionCaptchaCustomRequestHandlingArgsDict']]
        """
        Defines custom handling for the web request. See Custom Request Handling below for details.
        """
elif False:
    RuleGroupRuleActionCaptchaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleActionCaptchaArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['RuleGroupRuleActionCaptchaCustomRequestHandlingArgs']] = None):
        """
        :param pulumi.Input['RuleGroupRuleActionCaptchaCustomRequestHandlingArgs'] custom_request_handling: Defines custom handling for the web request. See Custom Request Handling below for details.
        """
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['RuleGroupRuleActionCaptchaCustomRequestHandlingArgs']]:
        """
        Defines custom handling for the web request. See Custom Request Handling below for details.
        """
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['RuleGroupRuleActionCaptchaCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


if not MYPY:
    class RuleGroupRuleActionCaptchaCustomRequestHandlingArgsDict(TypedDict):
        insert_headers: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleActionCaptchaCustomRequestHandlingInsertHeaderArgsDict']]]
        """
        The `insert_header` blocks used to define HTTP headers added to the request. See Custom HTTP Header below for details.
        """
elif False:
    RuleGroupRuleActionCaptchaCustomRequestHandlingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleActionCaptchaCustomRequestHandlingArgs:
    def __init__(__self__, *,
                 insert_headers: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleActionCaptchaCustomRequestHandlingInsertHeaderArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleActionCaptchaCustomRequestHandlingInsertHeaderArgs']]] insert_headers: The `insert_header` blocks used to define HTTP headers added to the request. See Custom HTTP Header below for details.
        """
        pulumi.set(__self__, "insert_headers", insert_headers)

    @property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleActionCaptchaCustomRequestHandlingInsertHeaderArgs']]]:
        """
        The `insert_header` blocks used to define HTTP headers added to the request. See Custom HTTP Header below for details.
        """
        return pulumi.get(self, "insert_headers")

    @insert_headers.setter
    def insert_headers(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleActionCaptchaCustomRequestHandlingInsertHeaderArgs']]]):
        pulumi.set(self, "insert_headers", value)


if not MYPY:
    class RuleGroupRuleActionCaptchaCustomRequestHandlingInsertHeaderArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        A friendly name of the rule group.
        """
        value: pulumi.Input[str]
        """
        The value of the custom header.
        """
elif False:
    RuleGroupRuleActionCaptchaCustomRequestHandlingInsertHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleActionCaptchaCustomRequestHandlingInsertHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: A friendly name of the rule group.
        :param pulumi.Input[str] value: The value of the custom header.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        A friendly name of the rule group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The value of the custom header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class RuleGroupRuleActionChallengeArgsDict(TypedDict):
        custom_request_handling: NotRequired[pulumi.Input['RuleGroupRuleActionChallengeCustomRequestHandlingArgsDict']]
        """
        Defines custom handling for the web request. See Custom Request Handling below for details.
        """
elif False:
    RuleGroupRuleActionChallengeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleActionChallengeArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['RuleGroupRuleActionChallengeCustomRequestHandlingArgs']] = None):
        """
        :param pulumi.Input['RuleGroupRuleActionChallengeCustomRequestHandlingArgs'] custom_request_handling: Defines custom handling for the web request. See Custom Request Handling below for details.
        """
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['RuleGroupRuleActionChallengeCustomRequestHandlingArgs']]:
        """
        Defines custom handling for the web request. See Custom Request Handling below for details.
        """
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['RuleGroupRuleActionChallengeCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


if not MYPY:
    class RuleGroupRuleActionChallengeCustomRequestHandlingArgsDict(TypedDict):
        insert_headers: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleActionChallengeCustomRequestHandlingInsertHeaderArgsDict']]]
        """
        The `insert_header` blocks used to define HTTP headers added to the request. See Custom HTTP Header below for details.
        """
elif False:
    RuleGroupRuleActionChallengeCustomRequestHandlingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleActionChallengeCustomRequestHandlingArgs:
    def __init__(__self__, *,
                 insert_headers: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleActionChallengeCustomRequestHandlingInsertHeaderArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleActionChallengeCustomRequestHandlingInsertHeaderArgs']]] insert_headers: The `insert_header` blocks used to define HTTP headers added to the request. See Custom HTTP Header below for details.
        """
        pulumi.set(__self__, "insert_headers", insert_headers)

    @property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleActionChallengeCustomRequestHandlingInsertHeaderArgs']]]:
        """
        The `insert_header` blocks used to define HTTP headers added to the request. See Custom HTTP Header below for details.
        """
        return pulumi.get(self, "insert_headers")

    @insert_headers.setter
    def insert_headers(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleActionChallengeCustomRequestHandlingInsertHeaderArgs']]]):
        pulumi.set(self, "insert_headers", value)


if not MYPY:
    class RuleGroupRuleActionChallengeCustomRequestHandlingInsertHeaderArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        A friendly name of the rule group.
        """
        value: pulumi.Input[str]
        """
        The value of the custom header.
        """
elif False:
    RuleGroupRuleActionChallengeCustomRequestHandlingInsertHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleActionChallengeCustomRequestHandlingInsertHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: A friendly name of the rule group.
        :param pulumi.Input[str] value: The value of the custom header.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        A friendly name of the rule group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The value of the custom header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class RuleGroupRuleActionCountArgsDict(TypedDict):
        custom_request_handling: NotRequired[pulumi.Input['RuleGroupRuleActionCountCustomRequestHandlingArgsDict']]
        """
        Defines custom handling for the web request. See Custom Request Handling below for details.
        """
elif False:
    RuleGroupRuleActionCountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleActionCountArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['RuleGroupRuleActionCountCustomRequestHandlingArgs']] = None):
        """
        :param pulumi.Input['RuleGroupRuleActionCountCustomRequestHandlingArgs'] custom_request_handling: Defines custom handling for the web request. See Custom Request Handling below for details.
        """
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['RuleGroupRuleActionCountCustomRequestHandlingArgs']]:
        """
        Defines custom handling for the web request. See Custom Request Handling below for details.
        """
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['RuleGroupRuleActionCountCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


if not MYPY:
    class RuleGroupRuleActionCountCustomRequestHandlingArgsDict(TypedDict):
        insert_headers: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleActionCountCustomRequestHandlingInsertHeaderArgsDict']]]
        """
        The `insert_header` blocks used to define HTTP headers added to the request. See Custom HTTP Header below for details.
        """
elif False:
    RuleGroupRuleActionCountCustomRequestHandlingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleActionCountCustomRequestHandlingArgs:
    def __init__(__self__, *,
                 insert_headers: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleActionCountCustomRequestHandlingInsertHeaderArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleActionCountCustomRequestHandlingInsertHeaderArgs']]] insert_headers: The `insert_header` blocks used to define HTTP headers added to the request. See Custom HTTP Header below for details.
        """
        pulumi.set(__self__, "insert_headers", insert_headers)

    @property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleActionCountCustomRequestHandlingInsertHeaderArgs']]]:
        """
        The `insert_header` blocks used to define HTTP headers added to the request. See Custom HTTP Header below for details.
        """
        return pulumi.get(self, "insert_headers")

    @insert_headers.setter
    def insert_headers(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleActionCountCustomRequestHandlingInsertHeaderArgs']]]):
        pulumi.set(self, "insert_headers", value)


if not MYPY:
    class RuleGroupRuleActionCountCustomRequestHandlingInsertHeaderArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        A friendly name of the rule group.
        """
        value: pulumi.Input[str]
        """
        The value of the custom header.
        """
elif False:
    RuleGroupRuleActionCountCustomRequestHandlingInsertHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleActionCountCustomRequestHandlingInsertHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: A friendly name of the rule group.
        :param pulumi.Input[str] value: The value of the custom header.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        A friendly name of the rule group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The value of the custom header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class RuleGroupRuleCaptchaConfigArgsDict(TypedDict):
        immunity_time_property: NotRequired[pulumi.Input['RuleGroupRuleCaptchaConfigImmunityTimePropertyArgsDict']]
        """
        Defines custom immunity time. See Immunity Time Property below for details.
        """
elif False:
    RuleGroupRuleCaptchaConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleCaptchaConfigArgs:
    def __init__(__self__, *,
                 immunity_time_property: Optional[pulumi.Input['RuleGroupRuleCaptchaConfigImmunityTimePropertyArgs']] = None):
        """
        :param pulumi.Input['RuleGroupRuleCaptchaConfigImmunityTimePropertyArgs'] immunity_time_property: Defines custom immunity time. See Immunity Time Property below for details.
        """
        if immunity_time_property is not None:
            pulumi.set(__self__, "immunity_time_property", immunity_time_property)

    @property
    @pulumi.getter(name="immunityTimeProperty")
    def immunity_time_property(self) -> Optional[pulumi.Input['RuleGroupRuleCaptchaConfigImmunityTimePropertyArgs']]:
        """
        Defines custom immunity time. See Immunity Time Property below for details.
        """
        return pulumi.get(self, "immunity_time_property")

    @immunity_time_property.setter
    def immunity_time_property(self, value: Optional[pulumi.Input['RuleGroupRuleCaptchaConfigImmunityTimePropertyArgs']]):
        pulumi.set(self, "immunity_time_property", value)


if not MYPY:
    class RuleGroupRuleCaptchaConfigImmunityTimePropertyArgsDict(TypedDict):
        immunity_time: NotRequired[pulumi.Input[int]]
        """
        The amount of time, in seconds, that a CAPTCHA or challenge timestamp is considered valid by AWS WAF. The default setting is 300.
        """
elif False:
    RuleGroupRuleCaptchaConfigImmunityTimePropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleCaptchaConfigImmunityTimePropertyArgs:
    def __init__(__self__, *,
                 immunity_time: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] immunity_time: The amount of time, in seconds, that a CAPTCHA or challenge timestamp is considered valid by AWS WAF. The default setting is 300.
        """
        if immunity_time is not None:
            pulumi.set(__self__, "immunity_time", immunity_time)

    @property
    @pulumi.getter(name="immunityTime")
    def immunity_time(self) -> Optional[pulumi.Input[int]]:
        """
        The amount of time, in seconds, that a CAPTCHA or challenge timestamp is considered valid by AWS WAF. The default setting is 300.
        """
        return pulumi.get(self, "immunity_time")

    @immunity_time.setter
    def immunity_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "immunity_time", value)


if not MYPY:
    class RuleGroupRuleRuleLabelArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The label string.
        """
elif False:
    RuleGroupRuleRuleLabelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleRuleLabelArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The label string.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The label string.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RuleGroupRuleStatementArgsDict(TypedDict):
        and_statement: NotRequired[pulumi.Input['RuleGroupRuleStatementAndStatementArgsDict']]
        """
        A logical rule statement used to combine other rule statements with AND logic. See AND Statement below for details.
        """
        byte_match_statement: NotRequired[pulumi.Input['RuleGroupRuleStatementByteMatchStatementArgsDict']]
        """
        A rule statement that defines a string match search for AWS WAF to apply to web requests. See Byte Match Statement below for details.
        """
        geo_match_statement: NotRequired[pulumi.Input['RuleGroupRuleStatementGeoMatchStatementArgsDict']]
        """
        A rule statement used to identify web requests based on country of origin. See GEO Match Statement below for details.
        """
        ip_set_reference_statement: NotRequired[pulumi.Input['RuleGroupRuleStatementIpSetReferenceStatementArgsDict']]
        """
        A rule statement used to detect web requests coming from particular IP addresses or address ranges. See IP Set Reference Statement below for details.
        """
        label_match_statement: NotRequired[pulumi.Input['RuleGroupRuleStatementLabelMatchStatementArgsDict']]
        """
        A rule statement that defines a string match search against labels that have been added to the web request by rules that have already run in the web ACL. See Label Match Statement below for details.
        """
        not_statement: NotRequired[pulumi.Input['RuleGroupRuleStatementNotStatementArgsDict']]
        """
        A logical rule statement used to negate the results of another rule statement. See NOT Statement below for details.
        """
        or_statement: NotRequired[pulumi.Input['RuleGroupRuleStatementOrStatementArgsDict']]
        """
        A logical rule statement used to combine other rule statements with OR logic. See OR Statement below for details.
        """
        rate_based_statement: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementArgsDict']]
        """
        A rate-based rule tracks the rate of requests for each originating `IP address`, and triggers the rule action when the rate exceeds a limit that you specify on the number of requests in any `5-minute` time span. This statement can not be nested. See Rate Based Statement below for details.
        """
        regex_match_statement: NotRequired[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementArgsDict']]
        """
        A rule statement used to search web request components for a match against a single regular expression. See Regex Match Statement below for details.
        """
        regex_pattern_set_reference_statement: NotRequired[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementArgsDict']]
        """
        A rule statement used to search web request components for matches with regular expressions. See Regex Pattern Set Reference Statement below for details.
        """
        size_constraint_statement: NotRequired[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementArgsDict']]
        """
        A rule statement that compares a number of bytes against the size of a request component, using a comparison operator, such as greater than (>) or less than (<). See Size Constraint Statement below for more details.
        """
        sqli_match_statement: NotRequired[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementArgsDict']]
        """
        An SQL injection match condition identifies the part of web requests, such as the URI or the query string, that you want AWS WAF to inspect. See SQL Injection Match Statement below for details.
        """
        xss_match_statement: NotRequired[pulumi.Input['RuleGroupRuleStatementXssMatchStatementArgsDict']]
        """
        A rule statement that defines a cross-site scripting (XSS) match search for AWS WAF to apply to web requests. See XSS Match Statement below for details.
        """
elif False:
    RuleGroupRuleStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementArgs:
    def __init__(__self__, *,
                 and_statement: Optional[pulumi.Input['RuleGroupRuleStatementAndStatementArgs']] = None,
                 byte_match_statement: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementArgs']] = None,
                 geo_match_statement: Optional[pulumi.Input['RuleGroupRuleStatementGeoMatchStatementArgs']] = None,
                 ip_set_reference_statement: Optional[pulumi.Input['RuleGroupRuleStatementIpSetReferenceStatementArgs']] = None,
                 label_match_statement: Optional[pulumi.Input['RuleGroupRuleStatementLabelMatchStatementArgs']] = None,
                 not_statement: Optional[pulumi.Input['RuleGroupRuleStatementNotStatementArgs']] = None,
                 or_statement: Optional[pulumi.Input['RuleGroupRuleStatementOrStatementArgs']] = None,
                 rate_based_statement: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementArgs']] = None,
                 regex_match_statement: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementArgs']] = None,
                 regex_pattern_set_reference_statement: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementArgs']] = None,
                 size_constraint_statement: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementArgs']] = None,
                 sqli_match_statement: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementArgs']] = None,
                 xss_match_statement: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementArgs']] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementAndStatementArgs'] and_statement: A logical rule statement used to combine other rule statements with AND logic. See AND Statement below for details.
        :param pulumi.Input['RuleGroupRuleStatementByteMatchStatementArgs'] byte_match_statement: A rule statement that defines a string match search for AWS WAF to apply to web requests. See Byte Match Statement below for details.
        :param pulumi.Input['RuleGroupRuleStatementGeoMatchStatementArgs'] geo_match_statement: A rule statement used to identify web requests based on country of origin. See GEO Match Statement below for details.
        :param pulumi.Input['RuleGroupRuleStatementIpSetReferenceStatementArgs'] ip_set_reference_statement: A rule statement used to detect web requests coming from particular IP addresses or address ranges. See IP Set Reference Statement below for details.
        :param pulumi.Input['RuleGroupRuleStatementLabelMatchStatementArgs'] label_match_statement: A rule statement that defines a string match search against labels that have been added to the web request by rules that have already run in the web ACL. See Label Match Statement below for details.
        :param pulumi.Input['RuleGroupRuleStatementNotStatementArgs'] not_statement: A logical rule statement used to negate the results of another rule statement. See NOT Statement below for details.
        :param pulumi.Input['RuleGroupRuleStatementOrStatementArgs'] or_statement: A logical rule statement used to combine other rule statements with OR logic. See OR Statement below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementArgs'] rate_based_statement: A rate-based rule tracks the rate of requests for each originating `IP address`, and triggers the rule action when the rate exceeds a limit that you specify on the number of requests in any `5-minute` time span. This statement can not be nested. See Rate Based Statement below for details.
        :param pulumi.Input['RuleGroupRuleStatementRegexMatchStatementArgs'] regex_match_statement: A rule statement used to search web request components for a match against a single regular expression. See Regex Match Statement below for details.
        :param pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementArgs'] regex_pattern_set_reference_statement: A rule statement used to search web request components for matches with regular expressions. See Regex Pattern Set Reference Statement below for details.
        :param pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementArgs'] size_constraint_statement: A rule statement that compares a number of bytes against the size of a request component, using a comparison operator, such as greater than (>) or less than (<). See Size Constraint Statement below for more details.
        :param pulumi.Input['RuleGroupRuleStatementSqliMatchStatementArgs'] sqli_match_statement: An SQL injection match condition identifies the part of web requests, such as the URI or the query string, that you want AWS WAF to inspect. See SQL Injection Match Statement below for details.
        :param pulumi.Input['RuleGroupRuleStatementXssMatchStatementArgs'] xss_match_statement: A rule statement that defines a cross-site scripting (XSS) match search for AWS WAF to apply to web requests. See XSS Match Statement below for details.
        """
        if and_statement is not None:
            pulumi.set(__self__, "and_statement", and_statement)
        if byte_match_statement is not None:
            pulumi.set(__self__, "byte_match_statement", byte_match_statement)
        if geo_match_statement is not None:
            pulumi.set(__self__, "geo_match_statement", geo_match_statement)
        if ip_set_reference_statement is not None:
            pulumi.set(__self__, "ip_set_reference_statement", ip_set_reference_statement)
        if label_match_statement is not None:
            pulumi.set(__self__, "label_match_statement", label_match_statement)
        if not_statement is not None:
            pulumi.set(__self__, "not_statement", not_statement)
        if or_statement is not None:
            pulumi.set(__self__, "or_statement", or_statement)
        if rate_based_statement is not None:
            pulumi.set(__self__, "rate_based_statement", rate_based_statement)
        if regex_match_statement is not None:
            pulumi.set(__self__, "regex_match_statement", regex_match_statement)
        if regex_pattern_set_reference_statement is not None:
            pulumi.set(__self__, "regex_pattern_set_reference_statement", regex_pattern_set_reference_statement)
        if size_constraint_statement is not None:
            pulumi.set(__self__, "size_constraint_statement", size_constraint_statement)
        if sqli_match_statement is not None:
            pulumi.set(__self__, "sqli_match_statement", sqli_match_statement)
        if xss_match_statement is not None:
            pulumi.set(__self__, "xss_match_statement", xss_match_statement)

    @property
    @pulumi.getter(name="andStatement")
    def and_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementAndStatementArgs']]:
        """
        A logical rule statement used to combine other rule statements with AND logic. See AND Statement below for details.
        """
        return pulumi.get(self, "and_statement")

    @and_statement.setter
    def and_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementAndStatementArgs']]):
        pulumi.set(self, "and_statement", value)

    @property
    @pulumi.getter(name="byteMatchStatement")
    def byte_match_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementArgs']]:
        """
        A rule statement that defines a string match search for AWS WAF to apply to web requests. See Byte Match Statement below for details.
        """
        return pulumi.get(self, "byte_match_statement")

    @byte_match_statement.setter
    def byte_match_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementArgs']]):
        pulumi.set(self, "byte_match_statement", value)

    @property
    @pulumi.getter(name="geoMatchStatement")
    def geo_match_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementGeoMatchStatementArgs']]:
        """
        A rule statement used to identify web requests based on country of origin. See GEO Match Statement below for details.
        """
        return pulumi.get(self, "geo_match_statement")

    @geo_match_statement.setter
    def geo_match_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementGeoMatchStatementArgs']]):
        pulumi.set(self, "geo_match_statement", value)

    @property
    @pulumi.getter(name="ipSetReferenceStatement")
    def ip_set_reference_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementIpSetReferenceStatementArgs']]:
        """
        A rule statement used to detect web requests coming from particular IP addresses or address ranges. See IP Set Reference Statement below for details.
        """
        return pulumi.get(self, "ip_set_reference_statement")

    @ip_set_reference_statement.setter
    def ip_set_reference_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementIpSetReferenceStatementArgs']]):
        pulumi.set(self, "ip_set_reference_statement", value)

    @property
    @pulumi.getter(name="labelMatchStatement")
    def label_match_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementLabelMatchStatementArgs']]:
        """
        A rule statement that defines a string match search against labels that have been added to the web request by rules that have already run in the web ACL. See Label Match Statement below for details.
        """
        return pulumi.get(self, "label_match_statement")

    @label_match_statement.setter
    def label_match_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementLabelMatchStatementArgs']]):
        pulumi.set(self, "label_match_statement", value)

    @property
    @pulumi.getter(name="notStatement")
    def not_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementNotStatementArgs']]:
        """
        A logical rule statement used to negate the results of another rule statement. See NOT Statement below for details.
        """
        return pulumi.get(self, "not_statement")

    @not_statement.setter
    def not_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementNotStatementArgs']]):
        pulumi.set(self, "not_statement", value)

    @property
    @pulumi.getter(name="orStatement")
    def or_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementOrStatementArgs']]:
        """
        A logical rule statement used to combine other rule statements with OR logic. See OR Statement below for details.
        """
        return pulumi.get(self, "or_statement")

    @or_statement.setter
    def or_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementOrStatementArgs']]):
        pulumi.set(self, "or_statement", value)

    @property
    @pulumi.getter(name="rateBasedStatement")
    def rate_based_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementArgs']]:
        """
        A rate-based rule tracks the rate of requests for each originating `IP address`, and triggers the rule action when the rate exceeds a limit that you specify on the number of requests in any `5-minute` time span. This statement can not be nested. See Rate Based Statement below for details.
        """
        return pulumi.get(self, "rate_based_statement")

    @rate_based_statement.setter
    def rate_based_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementArgs']]):
        pulumi.set(self, "rate_based_statement", value)

    @property
    @pulumi.getter(name="regexMatchStatement")
    def regex_match_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementArgs']]:
        """
        A rule statement used to search web request components for a match against a single regular expression. See Regex Match Statement below for details.
        """
        return pulumi.get(self, "regex_match_statement")

    @regex_match_statement.setter
    def regex_match_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementArgs']]):
        pulumi.set(self, "regex_match_statement", value)

    @property
    @pulumi.getter(name="regexPatternSetReferenceStatement")
    def regex_pattern_set_reference_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementArgs']]:
        """
        A rule statement used to search web request components for matches with regular expressions. See Regex Pattern Set Reference Statement below for details.
        """
        return pulumi.get(self, "regex_pattern_set_reference_statement")

    @regex_pattern_set_reference_statement.setter
    def regex_pattern_set_reference_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementArgs']]):
        pulumi.set(self, "regex_pattern_set_reference_statement", value)

    @property
    @pulumi.getter(name="sizeConstraintStatement")
    def size_constraint_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementArgs']]:
        """
        A rule statement that compares a number of bytes against the size of a request component, using a comparison operator, such as greater than (>) or less than (<). See Size Constraint Statement below for more details.
        """
        return pulumi.get(self, "size_constraint_statement")

    @size_constraint_statement.setter
    def size_constraint_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementArgs']]):
        pulumi.set(self, "size_constraint_statement", value)

    @property
    @pulumi.getter(name="sqliMatchStatement")
    def sqli_match_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementArgs']]:
        """
        An SQL injection match condition identifies the part of web requests, such as the URI or the query string, that you want AWS WAF to inspect. See SQL Injection Match Statement below for details.
        """
        return pulumi.get(self, "sqli_match_statement")

    @sqli_match_statement.setter
    def sqli_match_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementArgs']]):
        pulumi.set(self, "sqli_match_statement", value)

    @property
    @pulumi.getter(name="xssMatchStatement")
    def xss_match_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementArgs']]:
        """
        A rule statement that defines a cross-site scripting (XSS) match search for AWS WAF to apply to web requests. See XSS Match Statement below for details.
        """
        return pulumi.get(self, "xss_match_statement")

    @xss_match_statement.setter
    def xss_match_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementArgs']]):
        pulumi.set(self, "xss_match_statement", value)


if not MYPY:
    class RuleGroupRuleStatementAndStatementArgsDict(TypedDict):
        statements: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgsDict']]]
        """
        The statements to combine.
        """
elif False:
    RuleGroupRuleStatementAndStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementAndStatementArgs:
    def __init__(__self__, *,
                 statements: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]] statements: The statements to combine.
        """
        pulumi.set(__self__, "statements", statements)

    @property
    @pulumi.getter
    def statements(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]]:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")

    @statements.setter
    def statements(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]]):
        pulumi.set(self, "statements", value)


if not MYPY:
    class RuleGroupRuleStatementByteMatchStatementArgsDict(TypedDict):
        positional_constraint: pulumi.Input[str]
        """
        The area within the portion of a web request that you want AWS WAF to search for `search_string`. Valid values include the following: `EXACTLY`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CONTAINS_WORD`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_ByteMatchStatement.html) for more information.
        """
        search_string: pulumi.Input[str]
        """
        A string value that you want AWS WAF to search for. AWS WAF searches only in the part of web requests that you designate for inspection in `field_to_match`. The maximum length of the value is 50 bytes.
        """
        text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementByteMatchStatementTextTransformationArgsDict']]]
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
        At least one required.
        See Text Transformation below for details.
        """
        field_to_match: NotRequired[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchArgsDict']]
        """
        The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
elif False:
    RuleGroupRuleStatementByteMatchStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementByteMatchStatementArgs:
    def __init__(__self__, *,
                 positional_constraint: pulumi.Input[str],
                 search_string: pulumi.Input[str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementByteMatchStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchArgs']] = None):
        """
        :param pulumi.Input[str] positional_constraint: The area within the portion of a web request that you want AWS WAF to search for `search_string`. Valid values include the following: `EXACTLY`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CONTAINS_WORD`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_ByteMatchStatement.html) for more information.
        :param pulumi.Input[str] search_string: A string value that you want AWS WAF to search for. AWS WAF searches only in the part of web requests that you designate for inspection in `field_to_match`. The maximum length of the value is 50 bytes.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementByteMatchStatementTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
               At least one required.
               See Text Transformation below for details.
        :param pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchArgs'] field_to_match: The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        pulumi.set(__self__, "positional_constraint", positional_constraint)
        pulumi.set(__self__, "search_string", search_string)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @property
    @pulumi.getter(name="positionalConstraint")
    def positional_constraint(self) -> pulumi.Input[str]:
        """
        The area within the portion of a web request that you want AWS WAF to search for `search_string`. Valid values include the following: `EXACTLY`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CONTAINS_WORD`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_ByteMatchStatement.html) for more information.
        """
        return pulumi.get(self, "positional_constraint")

    @positional_constraint.setter
    def positional_constraint(self, value: pulumi.Input[str]):
        pulumi.set(self, "positional_constraint", value)

    @property
    @pulumi.getter(name="searchString")
    def search_string(self) -> pulumi.Input[str]:
        """
        A string value that you want AWS WAF to search for. AWS WAF searches only in the part of web requests that you designate for inspection in `field_to_match`. The maximum length of the value is 50 bytes.
        """
        return pulumi.get(self, "search_string")

    @search_string.setter
    def search_string(self, value: pulumi.Input[str]):
        pulumi.set(self, "search_string", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementByteMatchStatementTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
        At least one required.
        See Text Transformation below for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementByteMatchStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchArgs']]:
        """
        The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


if not MYPY:
    class RuleGroupRuleStatementByteMatchStatementFieldToMatchArgsDict(TypedDict):
        all_query_arguments: NotRequired[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgsDict']]
        """
        Inspect all query arguments.
        """
        body: NotRequired[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchBodyArgsDict']]
        """
        Inspect the request body, which immediately follows the request headers.
        """
        cookies: NotRequired[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesArgsDict']]
        """
        Inspect the cookies in the web request. See Cookies below for details.
        """
        header_orders: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderOrderArgsDict']]]]
        """
        Inspect the request headers. See Header Order below for details.
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderArgsDict']]]]
        """
        Inspect the request headers. See Headers below for details.
        """
        ja3_fingerprint: NotRequired[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchJa3FingerprintArgsDict']]
        json_body: NotRequired[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyArgsDict']]
        """
        Inspect the request body as JSON. See JSON Body for details.
        """
        method: NotRequired[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchMethodArgsDict']]
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        query_string: NotRequired[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchQueryStringArgsDict']]
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        single_header: NotRequired[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleHeaderArgsDict']]
        """
        Inspect a single header. See Single Header below for details.
        """
        single_query_argument: NotRequired[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgsDict']]
        """
        Inspect a single query argument. See Single Query Argument below for details.
        """
        uri_path: NotRequired[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchUriPathArgsDict']]
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
elif False:
    RuleGroupRuleStatementByteMatchStatementFieldToMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchJa3FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_path: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchUriPathArgs']] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs'] all_query_arguments: Inspect all query arguments.
        :param pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchBodyArgs'] body: Inspect the request body, which immediately follows the request headers.
        :param pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesArgs'] cookies: Inspect the cookies in the web request. See Cookies below for details.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderOrderArgs']]] header_orders: Inspect the request headers. See Header Order below for details.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderArgs']]] headers: Inspect the request headers. See Headers below for details.
        :param pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyArgs'] json_body: Inspect the request body as JSON. See JSON Body for details.
        :param pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchMethodArgs'] method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchQueryStringArgs'] query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleHeaderArgs'] single_header: Inspect a single header. See Single Header below for details.
        :param pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs'] single_query_argument: Inspect a single query argument. See Single Query Argument below for details.
        :param pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchUriPathArgs'] uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs']]:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchBodyArgs']]:
        """
        Inspect the request body, which immediately follows the request headers.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesArgs']]:
        """
        Inspect the cookies in the web request. See Cookies below for details.
        """
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderOrderArgs']]]]:
        """
        Inspect the request headers. See Header Order below for details.
        """
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderArgs']]]]:
        """
        Inspect the request headers. See Headers below for details.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchJa3FingerprintArgs']]:
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyArgs']]:
        """
        Inspect the request body as JSON. See JSON Body for details.
        """
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchMethodArgs']]:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchQueryStringArgs']]:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleHeaderArgs']]:
        """
        Inspect a single header. See Single Header below for details.
        """
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs']]:
        """
        Inspect a single query argument. See Single Query Argument below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchUriPathArgs']]:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


if not MYPY:
    class RuleGroupRuleStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementByteMatchStatementFieldToMatchBodyArgsDict(TypedDict):
        oversize_handling: NotRequired[pulumi.Input[str]]
elif False:
    RuleGroupRuleStatementByteMatchStatementFieldToMatchBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesArgsDict(TypedDict):
        match_patterns: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgsDict']]]
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        oversize_handling: pulumi.Input[str]
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
elif False:
    RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs']]] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param pulumi.Input[str] match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs']]]:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        excluded_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        included_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_cookies", value)


if not MYPY:
    class RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderArgsDict(TypedDict):
        match_pattern: pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgsDict']
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        oversize_handling: pulumi.Input[str]
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
elif False:
    RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs'] match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param pulumi.Input[str] match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs']:
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        excluded_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        included_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
elif False:
    RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_headers", value)


if not MYPY:
    class RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderOrderArgsDict(TypedDict):
        oversize_handling: pulumi.Input[str]
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
elif False:
    RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderOrderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementByteMatchStatementFieldToMatchJa3FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[str]
elif False:
    RuleGroupRuleStatementByteMatchStatementFieldToMatchJa3FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyArgsDict(TypedDict):
        match_pattern: pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict']
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        invalid_fallback_behavior: NotRequired[pulumi.Input[str]]
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        oversize_handling: NotRequired[pulumi.Input[str]]
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
elif False:
    RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 invalid_fallback_behavior: Optional[pulumi.Input[str]] = None,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs'] match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param pulumi.Input[str] match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param pulumi.Input[str] invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param pulumi.Input[str] oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs']:
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        included_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_paths", value)


if not MYPY:
    class RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementByteMatchStatementFieldToMatchMethodArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementByteMatchStatementFieldToMatchMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementByteMatchStatementFieldToMatchQueryStringArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementByteMatchStatementFieldToMatchQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleHeaderArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
elif False:
    RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
elif False:
    RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RuleGroupRuleStatementByteMatchStatementFieldToMatchUriPathArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementByteMatchStatementFieldToMatchUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementByteMatchStatementTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[int]
        """
        The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        type: pulumi.Input[str]
        """
        The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
elif False:
    RuleGroupRuleStatementByteMatchStatementTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementByteMatchStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class RuleGroupRuleStatementGeoMatchStatementArgsDict(TypedDict):
        country_codes: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        An array of two-character country codes, for example, [ "US", "CN" ], from the alpha-2 country ISO codes of the `ISO 3166` international standard. See the [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_GeoMatchStatement.html) for valid values.
        """
        forwarded_ip_config: NotRequired[pulumi.Input['RuleGroupRuleStatementGeoMatchStatementForwardedIpConfigArgsDict']]
        """
        The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See Forwarded IP Config below for details.
        """
elif False:
    RuleGroupRuleStatementGeoMatchStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementGeoMatchStatementArgs:
    def __init__(__self__, *,
                 country_codes: pulumi.Input[Sequence[pulumi.Input[str]]],
                 forwarded_ip_config: Optional[pulumi.Input['RuleGroupRuleStatementGeoMatchStatementForwardedIpConfigArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] country_codes: An array of two-character country codes, for example, [ "US", "CN" ], from the alpha-2 country ISO codes of the `ISO 3166` international standard. See the [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_GeoMatchStatement.html) for valid values.
        :param pulumi.Input['RuleGroupRuleStatementGeoMatchStatementForwardedIpConfigArgs'] forwarded_ip_config: The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See Forwarded IP Config below for details.
        """
        pulumi.set(__self__, "country_codes", country_codes)
        if forwarded_ip_config is not None:
            pulumi.set(__self__, "forwarded_ip_config", forwarded_ip_config)

    @property
    @pulumi.getter(name="countryCodes")
    def country_codes(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        An array of two-character country codes, for example, [ "US", "CN" ], from the alpha-2 country ISO codes of the `ISO 3166` international standard. See the [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_GeoMatchStatement.html) for valid values.
        """
        return pulumi.get(self, "country_codes")

    @country_codes.setter
    def country_codes(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "country_codes", value)

    @property
    @pulumi.getter(name="forwardedIpConfig")
    def forwarded_ip_config(self) -> Optional[pulumi.Input['RuleGroupRuleStatementGeoMatchStatementForwardedIpConfigArgs']]:
        """
        The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See Forwarded IP Config below for details.
        """
        return pulumi.get(self, "forwarded_ip_config")

    @forwarded_ip_config.setter
    def forwarded_ip_config(self, value: Optional[pulumi.Input['RuleGroupRuleStatementGeoMatchStatementForwardedIpConfigArgs']]):
        pulumi.set(self, "forwarded_ip_config", value)


if not MYPY:
    class RuleGroupRuleStatementGeoMatchStatementForwardedIpConfigArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[str]
        """
        The match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        header_name: pulumi.Input[str]
        """
        The name of the HTTP header to use for the IP address.
        """
elif False:
    RuleGroupRuleStatementGeoMatchStatementForwardedIpConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementGeoMatchStatementForwardedIpConfigArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str],
                 header_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: The match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        :param pulumi.Input[str] header_name: The name of the HTTP header to use for the IP address.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        The match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> pulumi.Input[str]:
        """
        The name of the HTTP header to use for the IP address.
        """
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "header_name", value)


if not MYPY:
    class RuleGroupRuleStatementIpSetReferenceStatementArgsDict(TypedDict):
        arn: pulumi.Input[str]
        """
        The Amazon Resource Name (ARN) of the IP Set that this statement references.
        """
        ip_set_forwarded_ip_config: NotRequired[pulumi.Input['RuleGroupRuleStatementIpSetReferenceStatementIpSetForwardedIpConfigArgsDict']]
        """
        The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See IPSet Forwarded IP Config below for more details.
        """
elif False:
    RuleGroupRuleStatementIpSetReferenceStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementIpSetReferenceStatementArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[str],
                 ip_set_forwarded_ip_config: Optional[pulumi.Input['RuleGroupRuleStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs']] = None):
        """
        :param pulumi.Input[str] arn: The Amazon Resource Name (ARN) of the IP Set that this statement references.
        :param pulumi.Input['RuleGroupRuleStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs'] ip_set_forwarded_ip_config: The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See IPSet Forwarded IP Config below for more details.
        """
        pulumi.set(__self__, "arn", arn)
        if ip_set_forwarded_ip_config is not None:
            pulumi.set(__self__, "ip_set_forwarded_ip_config", ip_set_forwarded_ip_config)

    @property
    @pulumi.getter
    def arn(self) -> pulumi.Input[str]:
        """
        The Amazon Resource Name (ARN) of the IP Set that this statement references.
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "arn", value)

    @property
    @pulumi.getter(name="ipSetForwardedIpConfig")
    def ip_set_forwarded_ip_config(self) -> Optional[pulumi.Input['RuleGroupRuleStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs']]:
        """
        The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See IPSet Forwarded IP Config below for more details.
        """
        return pulumi.get(self, "ip_set_forwarded_ip_config")

    @ip_set_forwarded_ip_config.setter
    def ip_set_forwarded_ip_config(self, value: Optional[pulumi.Input['RuleGroupRuleStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs']]):
        pulumi.set(self, "ip_set_forwarded_ip_config", value)


if not MYPY:
    class RuleGroupRuleStatementIpSetReferenceStatementIpSetForwardedIpConfigArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[str]
        """
        The match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        header_name: pulumi.Input[str]
        """
        The name of the HTTP header to use for the IP address.
        """
        position: pulumi.Input[str]
        """
        The position in the header to search for the IP address. Valid values include: `FIRST`, `LAST`, or `ANY`. If `ANY` is specified and the header contains more than 10 IP addresses, AWS WAFv2 inspects the last 10.
        """
elif False:
    RuleGroupRuleStatementIpSetReferenceStatementIpSetForwardedIpConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str],
                 header_name: pulumi.Input[str],
                 position: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: The match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        :param pulumi.Input[str] header_name: The name of the HTTP header to use for the IP address.
        :param pulumi.Input[str] position: The position in the header to search for the IP address. Valid values include: `FIRST`, `LAST`, or `ANY`. If `ANY` is specified and the header contains more than 10 IP addresses, AWS WAFv2 inspects the last 10.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "position", position)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        The match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> pulumi.Input[str]:
        """
        The name of the HTTP header to use for the IP address.
        """
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "header_name", value)

    @property
    @pulumi.getter
    def position(self) -> pulumi.Input[str]:
        """
        The position in the header to search for the IP address. Valid values include: `FIRST`, `LAST`, or `ANY`. If `ANY` is specified and the header contains more than 10 IP addresses, AWS WAFv2 inspects the last 10.
        """
        return pulumi.get(self, "position")

    @position.setter
    def position(self, value: pulumi.Input[str]):
        pulumi.set(self, "position", value)


if not MYPY:
    class RuleGroupRuleStatementLabelMatchStatementArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        The string to match against.
        """
        scope: pulumi.Input[str]
        """
        Specify whether you want to match using the label name or just the namespace. Valid values are `LABEL` or `NAMESPACE`.
        """
elif False:
    RuleGroupRuleStatementLabelMatchStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementLabelMatchStatementArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 scope: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: The string to match against.
        :param pulumi.Input[str] scope: Specify whether you want to match using the label name or just the namespace. Valid values are `LABEL` or `NAMESPACE`.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The string to match against.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def scope(self) -> pulumi.Input[str]:
        """
        Specify whether you want to match using the label name or just the namespace. Valid values are `LABEL` or `NAMESPACE`.
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "scope", value)


if not MYPY:
    class RuleGroupRuleStatementNotStatementArgsDict(TypedDict):
        statements: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgsDict']]]
        """
        The statements to combine.
        """
elif False:
    RuleGroupRuleStatementNotStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementNotStatementArgs:
    def __init__(__self__, *,
                 statements: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]] statements: The statements to combine.
        """
        pulumi.set(__self__, "statements", statements)

    @property
    @pulumi.getter
    def statements(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]]:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")

    @statements.setter
    def statements(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]]):
        pulumi.set(self, "statements", value)


if not MYPY:
    class RuleGroupRuleStatementOrStatementArgsDict(TypedDict):
        statements: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgsDict']]]
        """
        The statements to combine.
        """
elif False:
    RuleGroupRuleStatementOrStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementOrStatementArgs:
    def __init__(__self__, *,
                 statements: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]] statements: The statements to combine.
        """
        pulumi.set(__self__, "statements", statements)

    @property
    @pulumi.getter
    def statements(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]]:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")

    @statements.setter
    def statements(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]]):
        pulumi.set(self, "statements", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementArgsDict(TypedDict):
        limit: pulumi.Input[int]
        """
        The limit on requests per 5-minute period for a single originating IP address.
        """
        aggregate_key_type: NotRequired[pulumi.Input[str]]
        """
        Setting that indicates how to aggregate the request counts. Valid values include: `CONSTANT`, `CUSTOM_KEYS`, `FORWARDED_IP` or `IP`. Default: `IP`.
        """
        custom_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyArgsDict']]]]
        """
        Aggregate the request counts using one or more web request components as the aggregate keys. See `custom_key` below for details.
        """
        evaluation_window_sec: NotRequired[pulumi.Input[int]]
        """
        The amount of time, in seconds, that AWS WAF should include in its request counts, looking back from the current time. Valid values are `60`, `120`, `300`, and `600`. Defaults to `300` (5 minutes).

        **NOTE:** This setting doesn't determine how often AWS WAF checks the rate, but how far back it looks each time it checks. AWS WAF checks the rate about every 10 seconds.
        """
        forwarded_ip_config: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementForwardedIpConfigArgsDict']]
        """
        The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. If `aggregate_key_type` is set to `FORWARDED_IP`, this block is required. See Forwarded IP Config below for details.
        """
        scope_down_statement: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementArgsDict']]
        """
        An optional nested statement that narrows the scope of the rate-based statement to matching web requests. This can be any nestable statement, and you can nest statements at any level below this scope-down statement. See Statement above for details. If `aggregate_key_type` is set to `CONSTANT`, this block is required.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementArgs:
    def __init__(__self__, *,
                 limit: pulumi.Input[int],
                 aggregate_key_type: Optional[pulumi.Input[str]] = None,
                 custom_keys: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyArgs']]]] = None,
                 evaluation_window_sec: Optional[pulumi.Input[int]] = None,
                 forwarded_ip_config: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementForwardedIpConfigArgs']] = None,
                 scope_down_statement: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementArgs']] = None):
        """
        :param pulumi.Input[int] limit: The limit on requests per 5-minute period for a single originating IP address.
        :param pulumi.Input[str] aggregate_key_type: Setting that indicates how to aggregate the request counts. Valid values include: `CONSTANT`, `CUSTOM_KEYS`, `FORWARDED_IP` or `IP`. Default: `IP`.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyArgs']]] custom_keys: Aggregate the request counts using one or more web request components as the aggregate keys. See `custom_key` below for details.
        :param pulumi.Input[int] evaluation_window_sec: The amount of time, in seconds, that AWS WAF should include in its request counts, looking back from the current time. Valid values are `60`, `120`, `300`, and `600`. Defaults to `300` (5 minutes).
               
               **NOTE:** This setting doesn't determine how often AWS WAF checks the rate, but how far back it looks each time it checks. AWS WAF checks the rate about every 10 seconds.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementForwardedIpConfigArgs'] forwarded_ip_config: The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. If `aggregate_key_type` is set to `FORWARDED_IP`, this block is required. See Forwarded IP Config below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementArgs'] scope_down_statement: An optional nested statement that narrows the scope of the rate-based statement to matching web requests. This can be any nestable statement, and you can nest statements at any level below this scope-down statement. See Statement above for details. If `aggregate_key_type` is set to `CONSTANT`, this block is required.
        """
        pulumi.set(__self__, "limit", limit)
        if aggregate_key_type is not None:
            pulumi.set(__self__, "aggregate_key_type", aggregate_key_type)
        if custom_keys is not None:
            pulumi.set(__self__, "custom_keys", custom_keys)
        if evaluation_window_sec is not None:
            pulumi.set(__self__, "evaluation_window_sec", evaluation_window_sec)
        if forwarded_ip_config is not None:
            pulumi.set(__self__, "forwarded_ip_config", forwarded_ip_config)
        if scope_down_statement is not None:
            pulumi.set(__self__, "scope_down_statement", scope_down_statement)

    @property
    @pulumi.getter
    def limit(self) -> pulumi.Input[int]:
        """
        The limit on requests per 5-minute period for a single originating IP address.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: pulumi.Input[int]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="aggregateKeyType")
    def aggregate_key_type(self) -> Optional[pulumi.Input[str]]:
        """
        Setting that indicates how to aggregate the request counts. Valid values include: `CONSTANT`, `CUSTOM_KEYS`, `FORWARDED_IP` or `IP`. Default: `IP`.
        """
        return pulumi.get(self, "aggregate_key_type")

    @aggregate_key_type.setter
    def aggregate_key_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregate_key_type", value)

    @property
    @pulumi.getter(name="customKeys")
    def custom_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyArgs']]]]:
        """
        Aggregate the request counts using one or more web request components as the aggregate keys. See `custom_key` below for details.
        """
        return pulumi.get(self, "custom_keys")

    @custom_keys.setter
    def custom_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyArgs']]]]):
        pulumi.set(self, "custom_keys", value)

    @property
    @pulumi.getter(name="evaluationWindowSec")
    def evaluation_window_sec(self) -> Optional[pulumi.Input[int]]:
        """
        The amount of time, in seconds, that AWS WAF should include in its request counts, looking back from the current time. Valid values are `60`, `120`, `300`, and `600`. Defaults to `300` (5 minutes).

        **NOTE:** This setting doesn't determine how often AWS WAF checks the rate, but how far back it looks each time it checks. AWS WAF checks the rate about every 10 seconds.
        """
        return pulumi.get(self, "evaluation_window_sec")

    @evaluation_window_sec.setter
    def evaluation_window_sec(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "evaluation_window_sec", value)

    @property
    @pulumi.getter(name="forwardedIpConfig")
    def forwarded_ip_config(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementForwardedIpConfigArgs']]:
        """
        The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. If `aggregate_key_type` is set to `FORWARDED_IP`, this block is required. See Forwarded IP Config below for details.
        """
        return pulumi.get(self, "forwarded_ip_config")

    @forwarded_ip_config.setter
    def forwarded_ip_config(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementForwardedIpConfigArgs']]):
        pulumi.set(self, "forwarded_ip_config", value)

    @property
    @pulumi.getter(name="scopeDownStatement")
    def scope_down_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementArgs']]:
        """
        An optional nested statement that narrows the scope of the rate-based statement to matching web requests. This can be any nestable statement, and you can nest statements at any level below this scope-down statement. See Statement above for details. If `aggregate_key_type` is set to `CONSTANT`, this block is required.
        """
        return pulumi.get(self, "scope_down_statement")

    @scope_down_statement.setter
    def scope_down_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementArgs']]):
        pulumi.set(self, "scope_down_statement", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementCustomKeyArgsDict(TypedDict):
        cookie: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyCookieArgsDict']]
        """
        (Optional) Use the value of a cookie in the request as an aggregate key. See RateLimit `cookie` below for details.
        """
        forwarded_ip: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyForwardedIpArgsDict']]
        """
        (Optional) Use the first IP address in an HTTP header as an aggregate key. See `forwarded_ip` below for details.
        """
        header: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyHeaderArgsDict']]
        """
        (Optional) Use the value of a header in the request as an aggregate key. See RateLimit `header` below for details.
        """
        http_method: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyHttpMethodArgsDict']]
        """
        (Optional) Use the request's HTTP method as an aggregate key. See RateLimit `http_method` below for details.
        """
        ip: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyIpArgsDict']]
        """
        (Optional) Use the request's originating IP address as an aggregate key. See `RateLimit ip` below for details.
        """
        label_namespace: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyLabelNamespaceArgsDict']]
        """
        (Optional) Use the specified label namespace as an aggregate key. See RateLimit `label_namespace` below for details.
        """
        query_argument: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgumentArgsDict']]
        """
        (Optional) Use the specified query argument as an aggregate key. See RateLimit `query_argument` below for details.
        """
        query_string: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyQueryStringArgsDict']]
        """
        (Optional) Use the request's query string as an aggregate key. See RateLimit `query_string` below for details.
        """
        uri_path: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyUriPathArgsDict']]
        """
        (Optional) Use the request's URI path as an aggregate key. See RateLimit `uri_path` below for details.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementCustomKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyArgs:
    def __init__(__self__, *,
                 cookie: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyCookieArgs']] = None,
                 forwarded_ip: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyForwardedIpArgs']] = None,
                 header: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyHeaderArgs']] = None,
                 http_method: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyHttpMethodArgs']] = None,
                 ip: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyIpArgs']] = None,
                 label_namespace: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyLabelNamespaceArgs']] = None,
                 query_argument: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgumentArgs']] = None,
                 query_string: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyQueryStringArgs']] = None,
                 uri_path: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyUriPathArgs']] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyCookieArgs'] cookie: (Optional) Use the value of a cookie in the request as an aggregate key. See RateLimit `cookie` below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyForwardedIpArgs'] forwarded_ip: (Optional) Use the first IP address in an HTTP header as an aggregate key. See `forwarded_ip` below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyHeaderArgs'] header: (Optional) Use the value of a header in the request as an aggregate key. See RateLimit `header` below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyHttpMethodArgs'] http_method: (Optional) Use the request's HTTP method as an aggregate key. See RateLimit `http_method` below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyIpArgs'] ip: (Optional) Use the request's originating IP address as an aggregate key. See `RateLimit ip` below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyLabelNamespaceArgs'] label_namespace: (Optional) Use the specified label namespace as an aggregate key. See RateLimit `label_namespace` below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgumentArgs'] query_argument: (Optional) Use the specified query argument as an aggregate key. See RateLimit `query_argument` below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyQueryStringArgs'] query_string: (Optional) Use the request's query string as an aggregate key. See RateLimit `query_string` below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyUriPathArgs'] uri_path: (Optional) Use the request's URI path as an aggregate key. See RateLimit `uri_path` below for details.
        """
        if cookie is not None:
            pulumi.set(__self__, "cookie", cookie)
        if forwarded_ip is not None:
            pulumi.set(__self__, "forwarded_ip", forwarded_ip)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if http_method is not None:
            pulumi.set(__self__, "http_method", http_method)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if label_namespace is not None:
            pulumi.set(__self__, "label_namespace", label_namespace)
        if query_argument is not None:
            pulumi.set(__self__, "query_argument", query_argument)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter
    def cookie(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyCookieArgs']]:
        """
        (Optional) Use the value of a cookie in the request as an aggregate key. See RateLimit `cookie` below for details.
        """
        return pulumi.get(self, "cookie")

    @cookie.setter
    def cookie(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyCookieArgs']]):
        pulumi.set(self, "cookie", value)

    @property
    @pulumi.getter(name="forwardedIp")
    def forwarded_ip(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyForwardedIpArgs']]:
        """
        (Optional) Use the first IP address in an HTTP header as an aggregate key. See `forwarded_ip` below for details.
        """
        return pulumi.get(self, "forwarded_ip")

    @forwarded_ip.setter
    def forwarded_ip(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyForwardedIpArgs']]):
        pulumi.set(self, "forwarded_ip", value)

    @property
    @pulumi.getter
    def header(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyHeaderArgs']]:
        """
        (Optional) Use the value of a header in the request as an aggregate key. See RateLimit `header` below for details.
        """
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyHeaderArgs']]):
        pulumi.set(self, "header", value)

    @property
    @pulumi.getter(name="httpMethod")
    def http_method(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyHttpMethodArgs']]:
        """
        (Optional) Use the request's HTTP method as an aggregate key. See RateLimit `http_method` below for details.
        """
        return pulumi.get(self, "http_method")

    @http_method.setter
    def http_method(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyHttpMethodArgs']]):
        pulumi.set(self, "http_method", value)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyIpArgs']]:
        """
        (Optional) Use the request's originating IP address as an aggregate key. See `RateLimit ip` below for details.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyIpArgs']]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter(name="labelNamespace")
    def label_namespace(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyLabelNamespaceArgs']]:
        """
        (Optional) Use the specified label namespace as an aggregate key. See RateLimit `label_namespace` below for details.
        """
        return pulumi.get(self, "label_namespace")

    @label_namespace.setter
    def label_namespace(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyLabelNamespaceArgs']]):
        pulumi.set(self, "label_namespace", value)

    @property
    @pulumi.getter(name="queryArgument")
    def query_argument(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgumentArgs']]:
        """
        (Optional) Use the specified query argument as an aggregate key. See RateLimit `query_argument` below for details.
        """
        return pulumi.get(self, "query_argument")

    @query_argument.setter
    def query_argument(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgumentArgs']]):
        pulumi.set(self, "query_argument", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyQueryStringArgs']]:
        """
        (Optional) Use the request's query string as an aggregate key. See RateLimit `query_string` below for details.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyUriPathArgs']]:
        """
        (Optional) Use the request's URI path as an aggregate key. See RateLimit `uri_path` below for details.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementCustomKeyCookieArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        A friendly name of the rule group.
        """
        text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyCookieTextTransformationArgsDict']]]
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. They are used in rate-based rule statements, to transform request components before using them as custom aggregation keys. Atleast one transformation is required. See Text Transformation above for details.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementCustomKeyCookieArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyCookieArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyCookieTextTransformationArgs']]]):
        """
        :param pulumi.Input[str] name: A friendly name of the rule group.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyCookieTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. They are used in rate-based rule statements, to transform request components before using them as custom aggregation keys. Atleast one transformation is required. See Text Transformation above for details.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        A friendly name of the rule group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyCookieTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. They are used in rate-based rule statements, to transform request components before using them as custom aggregation keys. Atleast one transformation is required. See Text Transformation above for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyCookieTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementCustomKeyCookieTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[int]
        """
        The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        type: pulumi.Input[str]
        """
        The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementCustomKeyCookieTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyCookieTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementCustomKeyForwardedIpArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementCustomKeyForwardedIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyForwardedIpArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementCustomKeyHeaderArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        A friendly name of the rule group.
        """
        text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyHeaderTextTransformationArgsDict']]]
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. They are used in rate-based rule statements, to transform request components before using them as custom aggregation keys. Atleast one transformation is required. See Text Transformation above for details.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementCustomKeyHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyHeaderTextTransformationArgs']]]):
        """
        :param pulumi.Input[str] name: A friendly name of the rule group.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyHeaderTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. They are used in rate-based rule statements, to transform request components before using them as custom aggregation keys. Atleast one transformation is required. See Text Transformation above for details.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        A friendly name of the rule group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyHeaderTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. They are used in rate-based rule statements, to transform request components before using them as custom aggregation keys. Atleast one transformation is required. See Text Transformation above for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyHeaderTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementCustomKeyHeaderTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[int]
        """
        The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        type: pulumi.Input[str]
        """
        The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementCustomKeyHeaderTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyHeaderTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementCustomKeyHttpMethodArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementCustomKeyHttpMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyHttpMethodArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementCustomKeyIpArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementCustomKeyIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyIpArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementCustomKeyLabelNamespaceArgsDict(TypedDict):
        namespace: pulumi.Input[str]
        """
        The namespace to use for aggregation
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementCustomKeyLabelNamespaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyLabelNamespaceArgs:
    def __init__(__self__, *,
                 namespace: pulumi.Input[str]):
        """
        :param pulumi.Input[str] namespace: The namespace to use for aggregation
        """
        pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[str]:
        """
        The namespace to use for aggregation
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[str]):
        pulumi.set(self, "namespace", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgumentArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        A friendly name of the rule group.
        """
        text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformationArgsDict']]]
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. They are used in rate-based rule statements, to transform request components before using them as custom aggregation keys. Atleast one transformation is required. See Text Transformation above for details.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformationArgs']]]):
        """
        :param pulumi.Input[str] name: A friendly name of the rule group.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. They are used in rate-based rule statements, to transform request components before using them as custom aggregation keys. Atleast one transformation is required. See Text Transformation above for details.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        A friendly name of the rule group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. They are used in rate-based rule statements, to transform request components before using them as custom aggregation keys. Atleast one transformation is required. See Text Transformation above for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[int]
        """
        The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        type: pulumi.Input[str]
        """
        The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementCustomKeyQueryStringArgsDict(TypedDict):
        text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformationArgsDict']]]
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. They are used in rate-based rule statements, to transform request components before using them as custom aggregation keys. Atleast one transformation is required. See Text Transformation above for details.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementCustomKeyQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyQueryStringArgs:
    def __init__(__self__, *,
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformationArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. They are used in rate-based rule statements, to transform request components before using them as custom aggregation keys. Atleast one transformation is required. See Text Transformation above for details.
        """
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. They are used in rate-based rule statements, to transform request components before using them as custom aggregation keys. Atleast one transformation is required. See Text Transformation above for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[int]
        """
        The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        type: pulumi.Input[str]
        """
        The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementCustomKeyUriPathArgsDict(TypedDict):
        text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyUriPathTextTransformationArgsDict']]]
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. They are used in rate-based rule statements, to transform request components before using them as custom aggregation keys. Atleast one transformation is required. See Text Transformation above for details.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementCustomKeyUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyUriPathArgs:
    def __init__(__self__, *,
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyUriPathTextTransformationArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyUriPathTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. They are used in rate-based rule statements, to transform request components before using them as custom aggregation keys. Atleast one transformation is required. See Text Transformation above for details.
        """
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyUriPathTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. They are used in rate-based rule statements, to transform request components before using them as custom aggregation keys. Atleast one transformation is required. See Text Transformation above for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyUriPathTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementCustomKeyUriPathTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[int]
        """
        The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        type: pulumi.Input[str]
        """
        The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementCustomKeyUriPathTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyUriPathTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementForwardedIpConfigArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[str]
        """
        The match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        header_name: pulumi.Input[str]
        """
        The name of the HTTP header to use for the IP address.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementForwardedIpConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementForwardedIpConfigArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str],
                 header_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: The match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        :param pulumi.Input[str] header_name: The name of the HTTP header to use for the IP address.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        The match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> pulumi.Input[str]:
        """
        The name of the HTTP header to use for the IP address.
        """
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "header_name", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementArgsDict(TypedDict):
        and_statement: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementAndStatementArgsDict']]
        """
        A logical rule statement used to combine other rule statements with AND logic. See AND Statement below for details.
        """
        byte_match_statement: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementArgsDict']]
        """
        A rule statement that defines a string match search for AWS WAF to apply to web requests. See Byte Match Statement below for details.
        """
        geo_match_statement: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementArgsDict']]
        """
        A rule statement used to identify web requests based on country of origin. See GEO Match Statement below for details.
        """
        ip_set_reference_statement: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementArgsDict']]
        """
        A rule statement used to detect web requests coming from particular IP addresses or address ranges. See IP Set Reference Statement below for details.
        """
        label_match_statement: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatementArgsDict']]
        """
        A rule statement that defines a string match search against labels that have been added to the web request by rules that have already run in the web ACL. See Label Match Statement below for details.
        """
        not_statement: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementNotStatementArgsDict']]
        """
        A logical rule statement used to negate the results of another rule statement. See NOT Statement below for details.
        """
        or_statement: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementOrStatementArgsDict']]
        """
        A logical rule statement used to combine other rule statements with OR logic. See OR Statement below for details.
        """
        regex_match_statement: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementArgsDict']]
        """
        A rule statement used to search web request components for a match against a single regular expression. See Regex Match Statement below for details.
        """
        regex_pattern_set_reference_statement: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementArgsDict']]
        """
        A rule statement used to search web request components for matches with regular expressions. See Regex Pattern Set Reference Statement below for details.
        """
        size_constraint_statement: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementArgsDict']]
        """
        A rule statement that compares a number of bytes against the size of a request component, using a comparison operator, such as greater than (>) or less than (<). See Size Constraint Statement below for more details.
        """
        sqli_match_statement: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementArgsDict']]
        """
        An SQL injection match condition identifies the part of web requests, such as the URI or the query string, that you want AWS WAF to inspect. See SQL Injection Match Statement below for details.
        """
        xss_match_statement: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementArgsDict']]
        """
        A rule statement that defines a cross-site scripting (XSS) match search for AWS WAF to apply to web requests. See XSS Match Statement below for details.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementArgs:
    def __init__(__self__, *,
                 and_statement: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementAndStatementArgs']] = None,
                 byte_match_statement: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementArgs']] = None,
                 geo_match_statement: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementArgs']] = None,
                 ip_set_reference_statement: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementArgs']] = None,
                 label_match_statement: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatementArgs']] = None,
                 not_statement: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementNotStatementArgs']] = None,
                 or_statement: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementOrStatementArgs']] = None,
                 regex_match_statement: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementArgs']] = None,
                 regex_pattern_set_reference_statement: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementArgs']] = None,
                 size_constraint_statement: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementArgs']] = None,
                 sqli_match_statement: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementArgs']] = None,
                 xss_match_statement: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementArgs']] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementAndStatementArgs'] and_statement: A logical rule statement used to combine other rule statements with AND logic. See AND Statement below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementArgs'] byte_match_statement: A rule statement that defines a string match search for AWS WAF to apply to web requests. See Byte Match Statement below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementArgs'] geo_match_statement: A rule statement used to identify web requests based on country of origin. See GEO Match Statement below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementArgs'] ip_set_reference_statement: A rule statement used to detect web requests coming from particular IP addresses or address ranges. See IP Set Reference Statement below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatementArgs'] label_match_statement: A rule statement that defines a string match search against labels that have been added to the web request by rules that have already run in the web ACL. See Label Match Statement below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementNotStatementArgs'] not_statement: A logical rule statement used to negate the results of another rule statement. See NOT Statement below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementOrStatementArgs'] or_statement: A logical rule statement used to combine other rule statements with OR logic. See OR Statement below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementArgs'] regex_match_statement: A rule statement used to search web request components for a match against a single regular expression. See Regex Match Statement below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementArgs'] regex_pattern_set_reference_statement: A rule statement used to search web request components for matches with regular expressions. See Regex Pattern Set Reference Statement below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementArgs'] size_constraint_statement: A rule statement that compares a number of bytes against the size of a request component, using a comparison operator, such as greater than (>) or less than (<). See Size Constraint Statement below for more details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementArgs'] sqli_match_statement: An SQL injection match condition identifies the part of web requests, such as the URI or the query string, that you want AWS WAF to inspect. See SQL Injection Match Statement below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementArgs'] xss_match_statement: A rule statement that defines a cross-site scripting (XSS) match search for AWS WAF to apply to web requests. See XSS Match Statement below for details.
        """
        if and_statement is not None:
            pulumi.set(__self__, "and_statement", and_statement)
        if byte_match_statement is not None:
            pulumi.set(__self__, "byte_match_statement", byte_match_statement)
        if geo_match_statement is not None:
            pulumi.set(__self__, "geo_match_statement", geo_match_statement)
        if ip_set_reference_statement is not None:
            pulumi.set(__self__, "ip_set_reference_statement", ip_set_reference_statement)
        if label_match_statement is not None:
            pulumi.set(__self__, "label_match_statement", label_match_statement)
        if not_statement is not None:
            pulumi.set(__self__, "not_statement", not_statement)
        if or_statement is not None:
            pulumi.set(__self__, "or_statement", or_statement)
        if regex_match_statement is not None:
            pulumi.set(__self__, "regex_match_statement", regex_match_statement)
        if regex_pattern_set_reference_statement is not None:
            pulumi.set(__self__, "regex_pattern_set_reference_statement", regex_pattern_set_reference_statement)
        if size_constraint_statement is not None:
            pulumi.set(__self__, "size_constraint_statement", size_constraint_statement)
        if sqli_match_statement is not None:
            pulumi.set(__self__, "sqli_match_statement", sqli_match_statement)
        if xss_match_statement is not None:
            pulumi.set(__self__, "xss_match_statement", xss_match_statement)

    @property
    @pulumi.getter(name="andStatement")
    def and_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementAndStatementArgs']]:
        """
        A logical rule statement used to combine other rule statements with AND logic. See AND Statement below for details.
        """
        return pulumi.get(self, "and_statement")

    @and_statement.setter
    def and_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementAndStatementArgs']]):
        pulumi.set(self, "and_statement", value)

    @property
    @pulumi.getter(name="byteMatchStatement")
    def byte_match_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementArgs']]:
        """
        A rule statement that defines a string match search for AWS WAF to apply to web requests. See Byte Match Statement below for details.
        """
        return pulumi.get(self, "byte_match_statement")

    @byte_match_statement.setter
    def byte_match_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementArgs']]):
        pulumi.set(self, "byte_match_statement", value)

    @property
    @pulumi.getter(name="geoMatchStatement")
    def geo_match_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementArgs']]:
        """
        A rule statement used to identify web requests based on country of origin. See GEO Match Statement below for details.
        """
        return pulumi.get(self, "geo_match_statement")

    @geo_match_statement.setter
    def geo_match_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementArgs']]):
        pulumi.set(self, "geo_match_statement", value)

    @property
    @pulumi.getter(name="ipSetReferenceStatement")
    def ip_set_reference_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementArgs']]:
        """
        A rule statement used to detect web requests coming from particular IP addresses or address ranges. See IP Set Reference Statement below for details.
        """
        return pulumi.get(self, "ip_set_reference_statement")

    @ip_set_reference_statement.setter
    def ip_set_reference_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementArgs']]):
        pulumi.set(self, "ip_set_reference_statement", value)

    @property
    @pulumi.getter(name="labelMatchStatement")
    def label_match_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatementArgs']]:
        """
        A rule statement that defines a string match search against labels that have been added to the web request by rules that have already run in the web ACL. See Label Match Statement below for details.
        """
        return pulumi.get(self, "label_match_statement")

    @label_match_statement.setter
    def label_match_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatementArgs']]):
        pulumi.set(self, "label_match_statement", value)

    @property
    @pulumi.getter(name="notStatement")
    def not_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementNotStatementArgs']]:
        """
        A logical rule statement used to negate the results of another rule statement. See NOT Statement below for details.
        """
        return pulumi.get(self, "not_statement")

    @not_statement.setter
    def not_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementNotStatementArgs']]):
        pulumi.set(self, "not_statement", value)

    @property
    @pulumi.getter(name="orStatement")
    def or_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementOrStatementArgs']]:
        """
        A logical rule statement used to combine other rule statements with OR logic. See OR Statement below for details.
        """
        return pulumi.get(self, "or_statement")

    @or_statement.setter
    def or_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementOrStatementArgs']]):
        pulumi.set(self, "or_statement", value)

    @property
    @pulumi.getter(name="regexMatchStatement")
    def regex_match_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementArgs']]:
        """
        A rule statement used to search web request components for a match against a single regular expression. See Regex Match Statement below for details.
        """
        return pulumi.get(self, "regex_match_statement")

    @regex_match_statement.setter
    def regex_match_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementArgs']]):
        pulumi.set(self, "regex_match_statement", value)

    @property
    @pulumi.getter(name="regexPatternSetReferenceStatement")
    def regex_pattern_set_reference_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementArgs']]:
        """
        A rule statement used to search web request components for matches with regular expressions. See Regex Pattern Set Reference Statement below for details.
        """
        return pulumi.get(self, "regex_pattern_set_reference_statement")

    @regex_pattern_set_reference_statement.setter
    def regex_pattern_set_reference_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementArgs']]):
        pulumi.set(self, "regex_pattern_set_reference_statement", value)

    @property
    @pulumi.getter(name="sizeConstraintStatement")
    def size_constraint_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementArgs']]:
        """
        A rule statement that compares a number of bytes against the size of a request component, using a comparison operator, such as greater than (>) or less than (<). See Size Constraint Statement below for more details.
        """
        return pulumi.get(self, "size_constraint_statement")

    @size_constraint_statement.setter
    def size_constraint_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementArgs']]):
        pulumi.set(self, "size_constraint_statement", value)

    @property
    @pulumi.getter(name="sqliMatchStatement")
    def sqli_match_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementArgs']]:
        """
        An SQL injection match condition identifies the part of web requests, such as the URI or the query string, that you want AWS WAF to inspect. See SQL Injection Match Statement below for details.
        """
        return pulumi.get(self, "sqli_match_statement")

    @sqli_match_statement.setter
    def sqli_match_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementArgs']]):
        pulumi.set(self, "sqli_match_statement", value)

    @property
    @pulumi.getter(name="xssMatchStatement")
    def xss_match_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementArgs']]:
        """
        A rule statement that defines a cross-site scripting (XSS) match search for AWS WAF to apply to web requests. See XSS Match Statement below for details.
        """
        return pulumi.get(self, "xss_match_statement")

    @xss_match_statement.setter
    def xss_match_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementArgs']]):
        pulumi.set(self, "xss_match_statement", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementAndStatementArgsDict(TypedDict):
        statements: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgsDict']]]
        """
        The statements to combine.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementAndStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementAndStatementArgs:
    def __init__(__self__, *,
                 statements: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]] statements: The statements to combine.
        """
        pulumi.set(__self__, "statements", statements)

    @property
    @pulumi.getter
    def statements(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]]:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")

    @statements.setter
    def statements(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]]):
        pulumi.set(self, "statements", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementArgsDict(TypedDict):
        positional_constraint: pulumi.Input[str]
        """
        The area within the portion of a web request that you want AWS WAF to search for `search_string`. Valid values include the following: `EXACTLY`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CONTAINS_WORD`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_ByteMatchStatement.html) for more information.
        """
        search_string: pulumi.Input[str]
        """
        A string value that you want AWS WAF to search for. AWS WAF searches only in the part of web requests that you designate for inspection in `field_to_match`. The maximum length of the value is 50 bytes.
        """
        text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformationArgsDict']]]
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
        At least one required.
        See Text Transformation below for details.
        """
        field_to_match: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchArgsDict']]
        """
        The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementArgs:
    def __init__(__self__, *,
                 positional_constraint: pulumi.Input[str],
                 search_string: pulumi.Input[str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchArgs']] = None):
        """
        :param pulumi.Input[str] positional_constraint: The area within the portion of a web request that you want AWS WAF to search for `search_string`. Valid values include the following: `EXACTLY`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CONTAINS_WORD`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_ByteMatchStatement.html) for more information.
        :param pulumi.Input[str] search_string: A string value that you want AWS WAF to search for. AWS WAF searches only in the part of web requests that you designate for inspection in `field_to_match`. The maximum length of the value is 50 bytes.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
               At least one required.
               See Text Transformation below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchArgs'] field_to_match: The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        pulumi.set(__self__, "positional_constraint", positional_constraint)
        pulumi.set(__self__, "search_string", search_string)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @property
    @pulumi.getter(name="positionalConstraint")
    def positional_constraint(self) -> pulumi.Input[str]:
        """
        The area within the portion of a web request that you want AWS WAF to search for `search_string`. Valid values include the following: `EXACTLY`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CONTAINS_WORD`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_ByteMatchStatement.html) for more information.
        """
        return pulumi.get(self, "positional_constraint")

    @positional_constraint.setter
    def positional_constraint(self, value: pulumi.Input[str]):
        pulumi.set(self, "positional_constraint", value)

    @property
    @pulumi.getter(name="searchString")
    def search_string(self) -> pulumi.Input[str]:
        """
        A string value that you want AWS WAF to search for. AWS WAF searches only in the part of web requests that you designate for inspection in `field_to_match`. The maximum length of the value is 50 bytes.
        """
        return pulumi.get(self, "search_string")

    @search_string.setter
    def search_string(self, value: pulumi.Input[str]):
        pulumi.set(self, "search_string", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
        At least one required.
        See Text Transformation below for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchArgs']]:
        """
        The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchArgsDict(TypedDict):
        all_query_arguments: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgsDict']]
        """
        Inspect all query arguments.
        """
        body: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgsDict']]
        """
        Inspect the request body, which immediately follows the request headers.
        """
        cookies: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgsDict']]
        """
        Inspect the cookies in the web request. See Cookies below for details.
        """
        header_orders: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgsDict']]]]
        """
        Inspect the request headers. See Header Order below for details.
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgsDict']]]]
        """
        Inspect the request headers. See Headers below for details.
        """
        ja3_fingerprint: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgsDict']]
        json_body: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgsDict']]
        """
        Inspect the request body as JSON. See JSON Body for details.
        """
        method: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgsDict']]
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        query_string: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgsDict']]
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        single_header: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgsDict']]
        """
        Inspect a single header. See Single Header below for details.
        """
        single_query_argument: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgsDict']]
        """
        Inspect a single query argument. See Single Query Argument below for details.
        """
        uri_path: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgsDict']]
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_path: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgs']] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs'] all_query_arguments: Inspect all query arguments.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgs'] body: Inspect the request body, which immediately follows the request headers.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgs'] cookies: Inspect the cookies in the web request. See Cookies below for details.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgs']]] header_orders: Inspect the request headers. See Header Order below for details.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgs']]] headers: Inspect the request headers. See Headers below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgs'] json_body: Inspect the request body as JSON. See JSON Body for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgs'] method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgs'] query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgs'] single_header: Inspect a single header. See Single Header below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs'] single_query_argument: Inspect a single query argument. See Single Query Argument below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgs'] uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs']]:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgs']]:
        """
        Inspect the request body, which immediately follows the request headers.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgs']]:
        """
        Inspect the cookies in the web request. See Cookies below for details.
        """
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgs']]]]:
        """
        Inspect the request headers. See Header Order below for details.
        """
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgs']]]]:
        """
        Inspect the request headers. See Headers below for details.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgs']]:
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgs']]:
        """
        Inspect the request body as JSON. See JSON Body for details.
        """
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgs']]:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgs']]:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgs']]:
        """
        Inspect a single header. See Single Header below for details.
        """
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs']]:
        """
        Inspect a single query argument. See Single Query Argument below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgs']]:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgsDict(TypedDict):
        oversize_handling: NotRequired[pulumi.Input[str]]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgsDict(TypedDict):
        match_patterns: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgsDict']]]
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        oversize_handling: pulumi.Input[str]
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs']]] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param pulumi.Input[str] match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs']]]:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        excluded_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        included_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_cookies", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgsDict(TypedDict):
        match_pattern: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgsDict']
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        oversize_handling: pulumi.Input[str]
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs'] match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param pulumi.Input[str] match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs']:
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        excluded_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        included_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_headers", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgsDict(TypedDict):
        oversize_handling: pulumi.Input[str]
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[str]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgsDict(TypedDict):
        match_pattern: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict']
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        invalid_fallback_behavior: NotRequired[pulumi.Input[str]]
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        oversize_handling: NotRequired[pulumi.Input[str]]
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 invalid_fallback_behavior: Optional[pulumi.Input[str]] = None,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs'] match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param pulumi.Input[str] match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param pulumi.Input[str] invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param pulumi.Input[str] oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs']:
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        included_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_paths", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[int]
        """
        The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        type: pulumi.Input[str]
        """
        The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementArgsDict(TypedDict):
        country_codes: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        An array of two-character country codes, for example, [ "US", "CN" ], from the alpha-2 country ISO codes of the `ISO 3166` international standard. See the [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_GeoMatchStatement.html) for valid values.
        """
        forwarded_ip_config: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgsDict']]
        """
        The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See Forwarded IP Config below for details.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementArgs:
    def __init__(__self__, *,
                 country_codes: pulumi.Input[Sequence[pulumi.Input[str]]],
                 forwarded_ip_config: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] country_codes: An array of two-character country codes, for example, [ "US", "CN" ], from the alpha-2 country ISO codes of the `ISO 3166` international standard. See the [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_GeoMatchStatement.html) for valid values.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgs'] forwarded_ip_config: The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See Forwarded IP Config below for details.
        """
        pulumi.set(__self__, "country_codes", country_codes)
        if forwarded_ip_config is not None:
            pulumi.set(__self__, "forwarded_ip_config", forwarded_ip_config)

    @property
    @pulumi.getter(name="countryCodes")
    def country_codes(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        An array of two-character country codes, for example, [ "US", "CN" ], from the alpha-2 country ISO codes of the `ISO 3166` international standard. See the [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_GeoMatchStatement.html) for valid values.
        """
        return pulumi.get(self, "country_codes")

    @country_codes.setter
    def country_codes(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "country_codes", value)

    @property
    @pulumi.getter(name="forwardedIpConfig")
    def forwarded_ip_config(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgs']]:
        """
        The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See Forwarded IP Config below for details.
        """
        return pulumi.get(self, "forwarded_ip_config")

    @forwarded_ip_config.setter
    def forwarded_ip_config(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgs']]):
        pulumi.set(self, "forwarded_ip_config", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[str]
        """
        The match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        header_name: pulumi.Input[str]
        """
        The name of the HTTP header to use for the IP address.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str],
                 header_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: The match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        :param pulumi.Input[str] header_name: The name of the HTTP header to use for the IP address.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        The match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> pulumi.Input[str]:
        """
        The name of the HTTP header to use for the IP address.
        """
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "header_name", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementArgsDict(TypedDict):
        arn: pulumi.Input[str]
        """
        The Amazon Resource Name (ARN) of the IP Set that this statement references.
        """
        ip_set_forwarded_ip_config: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgsDict']]
        """
        The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See IPSet Forwarded IP Config below for more details.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[str],
                 ip_set_forwarded_ip_config: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs']] = None):
        """
        :param pulumi.Input[str] arn: The Amazon Resource Name (ARN) of the IP Set that this statement references.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs'] ip_set_forwarded_ip_config: The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See IPSet Forwarded IP Config below for more details.
        """
        pulumi.set(__self__, "arn", arn)
        if ip_set_forwarded_ip_config is not None:
            pulumi.set(__self__, "ip_set_forwarded_ip_config", ip_set_forwarded_ip_config)

    @property
    @pulumi.getter
    def arn(self) -> pulumi.Input[str]:
        """
        The Amazon Resource Name (ARN) of the IP Set that this statement references.
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "arn", value)

    @property
    @pulumi.getter(name="ipSetForwardedIpConfig")
    def ip_set_forwarded_ip_config(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs']]:
        """
        The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See IPSet Forwarded IP Config below for more details.
        """
        return pulumi.get(self, "ip_set_forwarded_ip_config")

    @ip_set_forwarded_ip_config.setter
    def ip_set_forwarded_ip_config(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs']]):
        pulumi.set(self, "ip_set_forwarded_ip_config", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[str]
        """
        The match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        header_name: pulumi.Input[str]
        """
        The name of the HTTP header to use for the IP address.
        """
        position: pulumi.Input[str]
        """
        The position in the header to search for the IP address. Valid values include: `FIRST`, `LAST`, or `ANY`. If `ANY` is specified and the header contains more than 10 IP addresses, AWS WAFv2 inspects the last 10.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str],
                 header_name: pulumi.Input[str],
                 position: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: The match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        :param pulumi.Input[str] header_name: The name of the HTTP header to use for the IP address.
        :param pulumi.Input[str] position: The position in the header to search for the IP address. Valid values include: `FIRST`, `LAST`, or `ANY`. If `ANY` is specified and the header contains more than 10 IP addresses, AWS WAFv2 inspects the last 10.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "position", position)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        The match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> pulumi.Input[str]:
        """
        The name of the HTTP header to use for the IP address.
        """
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "header_name", value)

    @property
    @pulumi.getter
    def position(self) -> pulumi.Input[str]:
        """
        The position in the header to search for the IP address. Valid values include: `FIRST`, `LAST`, or `ANY`. If `ANY` is specified and the header contains more than 10 IP addresses, AWS WAFv2 inspects the last 10.
        """
        return pulumi.get(self, "position")

    @position.setter
    def position(self, value: pulumi.Input[str]):
        pulumi.set(self, "position", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatementArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        The string to match against.
        """
        scope: pulumi.Input[str]
        """
        Specify whether you want to match using the label name or just the namespace. Valid values are `LABEL` or `NAMESPACE`.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatementArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 scope: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: The string to match against.
        :param pulumi.Input[str] scope: Specify whether you want to match using the label name or just the namespace. Valid values are `LABEL` or `NAMESPACE`.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The string to match against.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def scope(self) -> pulumi.Input[str]:
        """
        Specify whether you want to match using the label name or just the namespace. Valid values are `LABEL` or `NAMESPACE`.
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "scope", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementNotStatementArgsDict(TypedDict):
        statements: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgsDict']]]
        """
        The statements to combine.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementNotStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementNotStatementArgs:
    def __init__(__self__, *,
                 statements: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]] statements: The statements to combine.
        """
        pulumi.set(__self__, "statements", statements)

    @property
    @pulumi.getter
    def statements(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]]:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")

    @statements.setter
    def statements(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]]):
        pulumi.set(self, "statements", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementOrStatementArgsDict(TypedDict):
        statements: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgsDict']]]
        """
        The statements to combine.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementOrStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementOrStatementArgs:
    def __init__(__self__, *,
                 statements: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]] statements: The statements to combine.
        """
        pulumi.set(__self__, "statements", statements)

    @property
    @pulumi.getter
    def statements(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]]:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")

    @statements.setter
    def statements(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]]):
        pulumi.set(self, "statements", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementArgsDict(TypedDict):
        regex_string: pulumi.Input[str]
        """
        The string representing the regular expression. **Note:** The fixed quota for the maximum number of characters in each regex pattern is 200, which can't be changed. See [AWS WAF quotas](https://docs.aws.amazon.com/waf/latest/developerguide/limits.html) for details.
        """
        text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformationArgsDict']]]
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
        At least one required.
        See Text Transformation below for details.
        """
        field_to_match: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchArgsDict']]
        """
        The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementArgs:
    def __init__(__self__, *,
                 regex_string: pulumi.Input[str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchArgs']] = None):
        """
        :param pulumi.Input[str] regex_string: The string representing the regular expression. **Note:** The fixed quota for the maximum number of characters in each regex pattern is 200, which can't be changed. See [AWS WAF quotas](https://docs.aws.amazon.com/waf/latest/developerguide/limits.html) for details.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
               At least one required.
               See Text Transformation below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchArgs'] field_to_match: The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        pulumi.set(__self__, "regex_string", regex_string)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @property
    @pulumi.getter(name="regexString")
    def regex_string(self) -> pulumi.Input[str]:
        """
        The string representing the regular expression. **Note:** The fixed quota for the maximum number of characters in each regex pattern is 200, which can't be changed. See [AWS WAF quotas](https://docs.aws.amazon.com/waf/latest/developerguide/limits.html) for details.
        """
        return pulumi.get(self, "regex_string")

    @regex_string.setter
    def regex_string(self, value: pulumi.Input[str]):
        pulumi.set(self, "regex_string", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
        At least one required.
        See Text Transformation below for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchArgs']]:
        """
        The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchArgsDict(TypedDict):
        all_query_arguments: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgsDict']]
        """
        Inspect all query arguments.
        """
        body: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgsDict']]
        """
        Inspect the request body, which immediately follows the request headers.
        """
        cookies: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgsDict']]
        """
        Inspect the cookies in the web request. See Cookies below for details.
        """
        header_orders: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgsDict']]]]
        """
        Inspect the request headers. See Header Order below for details.
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgsDict']]]]
        """
        Inspect the request headers. See Headers below for details.
        """
        ja3_fingerprint: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgsDict']]
        json_body: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgsDict']]
        """
        Inspect the request body as JSON. See JSON Body for details.
        """
        method: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgsDict']]
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        query_string: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgsDict']]
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        single_header: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgsDict']]
        """
        Inspect a single header. See Single Header below for details.
        """
        single_query_argument: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgsDict']]
        """
        Inspect a single query argument. See Single Query Argument below for details.
        """
        uri_path: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgsDict']]
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_path: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgs']] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs'] all_query_arguments: Inspect all query arguments.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgs'] body: Inspect the request body, which immediately follows the request headers.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgs'] cookies: Inspect the cookies in the web request. See Cookies below for details.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgs']]] header_orders: Inspect the request headers. See Header Order below for details.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgs']]] headers: Inspect the request headers. See Headers below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgs'] json_body: Inspect the request body as JSON. See JSON Body for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgs'] method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgs'] query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgs'] single_header: Inspect a single header. See Single Header below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs'] single_query_argument: Inspect a single query argument. See Single Query Argument below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgs'] uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs']]:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgs']]:
        """
        Inspect the request body, which immediately follows the request headers.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgs']]:
        """
        Inspect the cookies in the web request. See Cookies below for details.
        """
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgs']]]]:
        """
        Inspect the request headers. See Header Order below for details.
        """
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgs']]]]:
        """
        Inspect the request headers. See Headers below for details.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs']]:
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgs']]:
        """
        Inspect the request body as JSON. See JSON Body for details.
        """
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgs']]:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgs']]:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgs']]:
        """
        Inspect a single header. See Single Header below for details.
        """
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs']]:
        """
        Inspect a single query argument. See Single Query Argument below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgs']]:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgsDict(TypedDict):
        oversize_handling: NotRequired[pulumi.Input[str]]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgsDict(TypedDict):
        match_patterns: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgsDict']]]
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        oversize_handling: pulumi.Input[str]
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs']]] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param pulumi.Input[str] match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs']]]:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        excluded_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        included_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_cookies", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgsDict(TypedDict):
        match_pattern: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgsDict']
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        oversize_handling: pulumi.Input[str]
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs'] match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param pulumi.Input[str] match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs']:
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        excluded_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        included_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_headers", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgsDict(TypedDict):
        oversize_handling: pulumi.Input[str]
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[str]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgsDict(TypedDict):
        match_pattern: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict']
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        invalid_fallback_behavior: NotRequired[pulumi.Input[str]]
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        oversize_handling: NotRequired[pulumi.Input[str]]
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 invalid_fallback_behavior: Optional[pulumi.Input[str]] = None,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs'] match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param pulumi.Input[str] match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param pulumi.Input[str] invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param pulumi.Input[str] oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs']:
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        included_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_paths", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[int]
        """
        The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        type: pulumi.Input[str]
        """
        The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementArgsDict(TypedDict):
        arn: pulumi.Input[str]
        """
        The Amazon Resource Name (ARN) of the Regex Pattern Set that this statement references.
        """
        text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgsDict']]]
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
        At least one required.
        See Text Transformation below for details.
        """
        field_to_match: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgsDict']]
        """
        The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgs']] = None):
        """
        :param pulumi.Input[str] arn: The Amazon Resource Name (ARN) of the Regex Pattern Set that this statement references.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
               At least one required.
               See Text Transformation below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgs'] field_to_match: The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @property
    @pulumi.getter
    def arn(self) -> pulumi.Input[str]:
        """
        The Amazon Resource Name (ARN) of the Regex Pattern Set that this statement references.
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "arn", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
        At least one required.
        See Text Transformation below for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgs']]:
        """
        The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgsDict(TypedDict):
        all_query_arguments: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgsDict']]
        """
        Inspect all query arguments.
        """
        body: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgsDict']]
        """
        Inspect the request body, which immediately follows the request headers.
        """
        cookies: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgsDict']]
        """
        Inspect the cookies in the web request. See Cookies below for details.
        """
        header_orders: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgsDict']]]]
        """
        Inspect the request headers. See Header Order below for details.
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgsDict']]]]
        """
        Inspect the request headers. See Headers below for details.
        """
        ja3_fingerprint: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgsDict']]
        json_body: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgsDict']]
        """
        Inspect the request body as JSON. See JSON Body for details.
        """
        method: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgsDict']]
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        query_string: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgsDict']]
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        single_header: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgsDict']]
        """
        Inspect a single header. See Single Header below for details.
        """
        single_query_argument: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgsDict']]
        """
        Inspect a single query argument. See Single Query Argument below for details.
        """
        uri_path: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgsDict']]
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_path: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs']] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs'] all_query_arguments: Inspect all query arguments.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs'] body: Inspect the request body, which immediately follows the request headers.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs'] cookies: Inspect the cookies in the web request. See Cookies below for details.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs']]] header_orders: Inspect the request headers. See Header Order below for details.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs']]] headers: Inspect the request headers. See Headers below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs'] json_body: Inspect the request body as JSON. See JSON Body for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs'] method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs'] query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs'] single_header: Inspect a single header. See Single Header below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs'] single_query_argument: Inspect a single query argument. See Single Query Argument below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs'] uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs']]:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs']]:
        """
        Inspect the request body, which immediately follows the request headers.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs']]:
        """
        Inspect the cookies in the web request. See Cookies below for details.
        """
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs']]]]:
        """
        Inspect the request headers. See Header Order below for details.
        """
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs']]]]:
        """
        Inspect the request headers. See Headers below for details.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs']]:
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs']]:
        """
        Inspect the request body as JSON. See JSON Body for details.
        """
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs']]:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs']]:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs']]:
        """
        Inspect a single header. See Single Header below for details.
        """
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs']]:
        """
        Inspect a single query argument. See Single Query Argument below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs']]:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgsDict(TypedDict):
        oversize_handling: NotRequired[pulumi.Input[str]]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgsDict(TypedDict):
        match_patterns: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgsDict']]]
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        oversize_handling: pulumi.Input[str]
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs']]] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param pulumi.Input[str] match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs']]]:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        excluded_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        included_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_cookies", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgsDict(TypedDict):
        match_pattern: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgsDict']
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        oversize_handling: pulumi.Input[str]
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs'] match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param pulumi.Input[str] match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs']:
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        excluded_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        included_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_headers", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgsDict(TypedDict):
        oversize_handling: pulumi.Input[str]
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[str]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgsDict(TypedDict):
        match_pattern: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgsDict']
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        invalid_fallback_behavior: NotRequired[pulumi.Input[str]]
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        oversize_handling: NotRequired[pulumi.Input[str]]
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 invalid_fallback_behavior: Optional[pulumi.Input[str]] = None,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs'] match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param pulumi.Input[str] match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param pulumi.Input[str] invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param pulumi.Input[str] oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs']:
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        included_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_paths", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[int]
        """
        The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        type: pulumi.Input[str]
        """
        The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementArgsDict(TypedDict):
        comparison_operator: pulumi.Input[str]
        """
        The operator to use to compare the request part to the size setting. Valid values include: `EQ`, `NE`, `LE`, `LT`, `GE`, or `GT`.
        """
        size: pulumi.Input[int]
        """
        The size, in bytes, to compare to the request part, after any transformations. Valid values are integers between 0 and 21474836480, inclusive.
        """
        text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformationArgsDict']]]
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
        At least one required.
        See Text Transformation below for details.
        """
        field_to_match: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgsDict']]
        """
        The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementArgs:
    def __init__(__self__, *,
                 comparison_operator: pulumi.Input[str],
                 size: pulumi.Input[int],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgs']] = None):
        """
        :param pulumi.Input[str] comparison_operator: The operator to use to compare the request part to the size setting. Valid values include: `EQ`, `NE`, `LE`, `LT`, `GE`, or `GT`.
        :param pulumi.Input[int] size: The size, in bytes, to compare to the request part, after any transformations. Valid values are integers between 0 and 21474836480, inclusive.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
               At least one required.
               See Text Transformation below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgs'] field_to_match: The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        pulumi.set(__self__, "comparison_operator", comparison_operator)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> pulumi.Input[str]:
        """
        The operator to use to compare the request part to the size setting. Valid values include: `EQ`, `NE`, `LE`, `LT`, `GE`, or `GT`.
        """
        return pulumi.get(self, "comparison_operator")

    @comparison_operator.setter
    def comparison_operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "comparison_operator", value)

    @property
    @pulumi.getter
    def size(self) -> pulumi.Input[int]:
        """
        The size, in bytes, to compare to the request part, after any transformations. Valid values are integers between 0 and 21474836480, inclusive.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[int]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
        At least one required.
        See Text Transformation below for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgs']]:
        """
        The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgsDict(TypedDict):
        all_query_arguments: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgsDict']]
        """
        Inspect all query arguments.
        """
        body: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgsDict']]
        """
        Inspect the request body, which immediately follows the request headers.
        """
        cookies: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgsDict']]
        """
        Inspect the cookies in the web request. See Cookies below for details.
        """
        header_orders: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgsDict']]]]
        """
        Inspect the request headers. See Header Order below for details.
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgsDict']]]]
        """
        Inspect the request headers. See Headers below for details.
        """
        ja3_fingerprint: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgsDict']]
        json_body: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgsDict']]
        """
        Inspect the request body as JSON. See JSON Body for details.
        """
        method: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgsDict']]
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        query_string: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgsDict']]
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        single_header: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgsDict']]
        """
        Inspect a single header. See Single Header below for details.
        """
        single_query_argument: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgsDict']]
        """
        Inspect a single query argument. See Single Query Argument below for details.
        """
        uri_path: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgsDict']]
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_path: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgs']] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs'] all_query_arguments: Inspect all query arguments.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgs'] body: Inspect the request body, which immediately follows the request headers.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgs'] cookies: Inspect the cookies in the web request. See Cookies below for details.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs']]] header_orders: Inspect the request headers. See Header Order below for details.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgs']]] headers: Inspect the request headers. See Headers below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgs'] json_body: Inspect the request body as JSON. See JSON Body for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgs'] method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgs'] query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs'] single_header: Inspect a single header. See Single Header below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs'] single_query_argument: Inspect a single query argument. See Single Query Argument below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgs'] uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs']]:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgs']]:
        """
        Inspect the request body, which immediately follows the request headers.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgs']]:
        """
        Inspect the cookies in the web request. See Cookies below for details.
        """
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs']]]]:
        """
        Inspect the request headers. See Header Order below for details.
        """
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgs']]]]:
        """
        Inspect the request headers. See Headers below for details.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs']]:
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgs']]:
        """
        Inspect the request body as JSON. See JSON Body for details.
        """
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgs']]:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgs']]:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs']]:
        """
        Inspect a single header. See Single Header below for details.
        """
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs']]:
        """
        Inspect a single query argument. See Single Query Argument below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgs']]:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgsDict(TypedDict):
        oversize_handling: NotRequired[pulumi.Input[str]]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgsDict(TypedDict):
        match_patterns: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgsDict']]]
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        oversize_handling: pulumi.Input[str]
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs']]] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param pulumi.Input[str] match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs']]]:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        excluded_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        included_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_cookies", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgsDict(TypedDict):
        match_pattern: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgsDict']
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        oversize_handling: pulumi.Input[str]
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs'] match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param pulumi.Input[str] match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs']:
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        excluded_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        included_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_headers", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgsDict(TypedDict):
        oversize_handling: pulumi.Input[str]
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[str]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgsDict(TypedDict):
        match_pattern: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgsDict']
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        invalid_fallback_behavior: NotRequired[pulumi.Input[str]]
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        oversize_handling: NotRequired[pulumi.Input[str]]
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 invalid_fallback_behavior: Optional[pulumi.Input[str]] = None,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs'] match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param pulumi.Input[str] match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param pulumi.Input[str] invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param pulumi.Input[str] oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs']:
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        included_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_paths", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[int]
        """
        The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        type: pulumi.Input[str]
        """
        The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementArgsDict(TypedDict):
        text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformationArgsDict']]]
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
        At least one required.
        See Text Transformation below for details.
        """
        field_to_match: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchArgsDict']]
        """
        The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        sensitivity_level: NotRequired[pulumi.Input[str]]
        """
        Sensitivity that you want AWS WAF to use to inspect for SQL injection attacks. Valid values include: `LOW`, `HIGH`.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementArgs:
    def __init__(__self__, *,
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchArgs']] = None,
                 sensitivity_level: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
               At least one required.
               See Text Transformation below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchArgs'] field_to_match: The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        :param pulumi.Input[str] sensitivity_level: Sensitivity that you want AWS WAF to use to inspect for SQL injection attacks. Valid values include: `LOW`, `HIGH`.
        """
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)
        if sensitivity_level is not None:
            pulumi.set(__self__, "sensitivity_level", sensitivity_level)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
        At least one required.
        See Text Transformation below for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchArgs']]:
        """
        The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)

    @property
    @pulumi.getter(name="sensitivityLevel")
    def sensitivity_level(self) -> Optional[pulumi.Input[str]]:
        """
        Sensitivity that you want AWS WAF to use to inspect for SQL injection attacks. Valid values include: `LOW`, `HIGH`.
        """
        return pulumi.get(self, "sensitivity_level")

    @sensitivity_level.setter
    def sensitivity_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sensitivity_level", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchArgsDict(TypedDict):
        all_query_arguments: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgsDict']]
        """
        Inspect all query arguments.
        """
        body: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgsDict']]
        """
        Inspect the request body, which immediately follows the request headers.
        """
        cookies: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgsDict']]
        """
        Inspect the cookies in the web request. See Cookies below for details.
        """
        header_orders: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgsDict']]]]
        """
        Inspect the request headers. See Header Order below for details.
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgsDict']]]]
        """
        Inspect the request headers. See Headers below for details.
        """
        ja3_fingerprint: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgsDict']]
        json_body: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgsDict']]
        """
        Inspect the request body as JSON. See JSON Body for details.
        """
        method: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgsDict']]
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        query_string: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgsDict']]
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        single_header: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgsDict']]
        """
        Inspect a single header. See Single Header below for details.
        """
        single_query_argument: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgsDict']]
        """
        Inspect a single query argument. See Single Query Argument below for details.
        """
        uri_path: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgsDict']]
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_path: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgs']] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs'] all_query_arguments: Inspect all query arguments.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgs'] body: Inspect the request body, which immediately follows the request headers.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgs'] cookies: Inspect the cookies in the web request. See Cookies below for details.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgs']]] header_orders: Inspect the request headers. See Header Order below for details.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgs']]] headers: Inspect the request headers. See Headers below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgs'] json_body: Inspect the request body as JSON. See JSON Body for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgs'] method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgs'] query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgs'] single_header: Inspect a single header. See Single Header below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs'] single_query_argument: Inspect a single query argument. See Single Query Argument below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgs'] uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs']]:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgs']]:
        """
        Inspect the request body, which immediately follows the request headers.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgs']]:
        """
        Inspect the cookies in the web request. See Cookies below for details.
        """
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgs']]]]:
        """
        Inspect the request headers. See Header Order below for details.
        """
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgs']]]]:
        """
        Inspect the request headers. See Headers below for details.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs']]:
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgs']]:
        """
        Inspect the request body as JSON. See JSON Body for details.
        """
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgs']]:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgs']]:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgs']]:
        """
        Inspect a single header. See Single Header below for details.
        """
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs']]:
        """
        Inspect a single query argument. See Single Query Argument below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgs']]:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgsDict(TypedDict):
        oversize_handling: NotRequired[pulumi.Input[str]]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgsDict(TypedDict):
        match_patterns: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgsDict']]]
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        oversize_handling: pulumi.Input[str]
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs']]] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param pulumi.Input[str] match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs']]]:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        excluded_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        included_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_cookies", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgsDict(TypedDict):
        match_pattern: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgsDict']
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        oversize_handling: pulumi.Input[str]
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs'] match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param pulumi.Input[str] match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs']:
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        excluded_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        included_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_headers", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgsDict(TypedDict):
        oversize_handling: pulumi.Input[str]
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[str]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgsDict(TypedDict):
        match_pattern: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict']
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        invalid_fallback_behavior: NotRequired[pulumi.Input[str]]
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        oversize_handling: NotRequired[pulumi.Input[str]]
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 invalid_fallback_behavior: Optional[pulumi.Input[str]] = None,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs'] match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param pulumi.Input[str] match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param pulumi.Input[str] invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param pulumi.Input[str] oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs']:
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        included_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_paths", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[int]
        """
        The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        type: pulumi.Input[str]
        """
        The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementArgsDict(TypedDict):
        text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformationArgsDict']]]
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
        At least one required.
        See Text Transformation below for details.
        """
        field_to_match: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchArgsDict']]
        """
        The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementArgs:
    def __init__(__self__, *,
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
               At least one required.
               See Text Transformation below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchArgs'] field_to_match: The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
        At least one required.
        See Text Transformation below for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchArgs']]:
        """
        The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchArgsDict(TypedDict):
        all_query_arguments: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgsDict']]
        """
        Inspect all query arguments.
        """
        body: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgsDict']]
        """
        Inspect the request body, which immediately follows the request headers.
        """
        cookies: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgsDict']]
        """
        Inspect the cookies in the web request. See Cookies below for details.
        """
        header_orders: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgsDict']]]]
        """
        Inspect the request headers. See Header Order below for details.
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgsDict']]]]
        """
        Inspect the request headers. See Headers below for details.
        """
        ja3_fingerprint: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgsDict']]
        json_body: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgsDict']]
        """
        Inspect the request body as JSON. See JSON Body for details.
        """
        method: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgsDict']]
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        query_string: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgsDict']]
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        single_header: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgsDict']]
        """
        Inspect a single header. See Single Header below for details.
        """
        single_query_argument: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgsDict']]
        """
        Inspect a single query argument. See Single Query Argument below for details.
        """
        uri_path: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgsDict']]
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_path: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgs']] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs'] all_query_arguments: Inspect all query arguments.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgs'] body: Inspect the request body, which immediately follows the request headers.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgs'] cookies: Inspect the cookies in the web request. See Cookies below for details.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgs']]] header_orders: Inspect the request headers. See Header Order below for details.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgs']]] headers: Inspect the request headers. See Headers below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgs'] json_body: Inspect the request body as JSON. See JSON Body for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgs'] method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgs'] query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgs'] single_header: Inspect a single header. See Single Header below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs'] single_query_argument: Inspect a single query argument. See Single Query Argument below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgs'] uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs']]:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgs']]:
        """
        Inspect the request body, which immediately follows the request headers.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgs']]:
        """
        Inspect the cookies in the web request. See Cookies below for details.
        """
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgs']]]]:
        """
        Inspect the request headers. See Header Order below for details.
        """
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgs']]]]:
        """
        Inspect the request headers. See Headers below for details.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgs']]:
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgs']]:
        """
        Inspect the request body as JSON. See JSON Body for details.
        """
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgs']]:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgs']]:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgs']]:
        """
        Inspect a single header. See Single Header below for details.
        """
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs']]:
        """
        Inspect a single query argument. See Single Query Argument below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgs']]:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgsDict(TypedDict):
        oversize_handling: NotRequired[pulumi.Input[str]]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgsDict(TypedDict):
        match_patterns: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgsDict']]]
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        oversize_handling: pulumi.Input[str]
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs']]] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param pulumi.Input[str] match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs']]]:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        excluded_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        included_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_cookies", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgsDict(TypedDict):
        match_pattern: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgsDict']
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        oversize_handling: pulumi.Input[str]
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs'] match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param pulumi.Input[str] match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs']:
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        excluded_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        included_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_headers", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgsDict(TypedDict):
        oversize_handling: pulumi.Input[str]
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[str]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgsDict(TypedDict):
        match_pattern: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict']
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        invalid_fallback_behavior: NotRequired[pulumi.Input[str]]
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        oversize_handling: NotRequired[pulumi.Input[str]]
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 invalid_fallback_behavior: Optional[pulumi.Input[str]] = None,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs'] match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param pulumi.Input[str] match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param pulumi.Input[str] invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param pulumi.Input[str] oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs']:
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        included_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_paths", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[int]
        """
        The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        type: pulumi.Input[str]
        """
        The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class RuleGroupRuleStatementRegexMatchStatementArgsDict(TypedDict):
        regex_string: pulumi.Input[str]
        """
        The string representing the regular expression. **Note:** The fixed quota for the maximum number of characters in each regex pattern is 200, which can't be changed. See [AWS WAF quotas](https://docs.aws.amazon.com/waf/latest/developerguide/limits.html) for details.
        """
        text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementTextTransformationArgsDict']]]
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
        At least one required.
        See Text Transformation below for details.
        """
        field_to_match: NotRequired[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchArgsDict']]
        """
        The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
elif False:
    RuleGroupRuleStatementRegexMatchStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexMatchStatementArgs:
    def __init__(__self__, *,
                 regex_string: pulumi.Input[str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchArgs']] = None):
        """
        :param pulumi.Input[str] regex_string: The string representing the regular expression. **Note:** The fixed quota for the maximum number of characters in each regex pattern is 200, which can't be changed. See [AWS WAF quotas](https://docs.aws.amazon.com/waf/latest/developerguide/limits.html) for details.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
               At least one required.
               See Text Transformation below for details.
        :param pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchArgs'] field_to_match: The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        pulumi.set(__self__, "regex_string", regex_string)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @property
    @pulumi.getter(name="regexString")
    def regex_string(self) -> pulumi.Input[str]:
        """
        The string representing the regular expression. **Note:** The fixed quota for the maximum number of characters in each regex pattern is 200, which can't be changed. See [AWS WAF quotas](https://docs.aws.amazon.com/waf/latest/developerguide/limits.html) for details.
        """
        return pulumi.get(self, "regex_string")

    @regex_string.setter
    def regex_string(self, value: pulumi.Input[str]):
        pulumi.set(self, "regex_string", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
        At least one required.
        See Text Transformation below for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchArgs']]:
        """
        The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


if not MYPY:
    class RuleGroupRuleStatementRegexMatchStatementFieldToMatchArgsDict(TypedDict):
        all_query_arguments: NotRequired[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgsDict']]
        """
        Inspect all query arguments.
        """
        body: NotRequired[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchBodyArgsDict']]
        """
        Inspect the request body, which immediately follows the request headers.
        """
        cookies: NotRequired[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesArgsDict']]
        """
        Inspect the cookies in the web request. See Cookies below for details.
        """
        header_orders: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderOrderArgsDict']]]]
        """
        Inspect the request headers. See Header Order below for details.
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderArgsDict']]]]
        """
        Inspect the request headers. See Headers below for details.
        """
        ja3_fingerprint: NotRequired[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchJa3FingerprintArgsDict']]
        json_body: NotRequired[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyArgsDict']]
        """
        Inspect the request body as JSON. See JSON Body for details.
        """
        method: NotRequired[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchMethodArgsDict']]
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        query_string: NotRequired[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchQueryStringArgsDict']]
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        single_header: NotRequired[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleHeaderArgsDict']]
        """
        Inspect a single header. See Single Header below for details.
        """
        single_query_argument: NotRequired[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgsDict']]
        """
        Inspect a single query argument. See Single Query Argument below for details.
        """
        uri_path: NotRequired[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchUriPathArgsDict']]
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
elif False:
    RuleGroupRuleStatementRegexMatchStatementFieldToMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_path: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchUriPathArgs']] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs'] all_query_arguments: Inspect all query arguments.
        :param pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchBodyArgs'] body: Inspect the request body, which immediately follows the request headers.
        :param pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesArgs'] cookies: Inspect the cookies in the web request. See Cookies below for details.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderOrderArgs']]] header_orders: Inspect the request headers. See Header Order below for details.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderArgs']]] headers: Inspect the request headers. See Headers below for details.
        :param pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyArgs'] json_body: Inspect the request body as JSON. See JSON Body for details.
        :param pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchMethodArgs'] method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchQueryStringArgs'] query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleHeaderArgs'] single_header: Inspect a single header. See Single Header below for details.
        :param pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs'] single_query_argument: Inspect a single query argument. See Single Query Argument below for details.
        :param pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchUriPathArgs'] uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs']]:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchBodyArgs']]:
        """
        Inspect the request body, which immediately follows the request headers.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesArgs']]:
        """
        Inspect the cookies in the web request. See Cookies below for details.
        """
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderOrderArgs']]]]:
        """
        Inspect the request headers. See Header Order below for details.
        """
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderArgs']]]]:
        """
        Inspect the request headers. See Headers below for details.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs']]:
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyArgs']]:
        """
        Inspect the request body as JSON. See JSON Body for details.
        """
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchMethodArgs']]:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchQueryStringArgs']]:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleHeaderArgs']]:
        """
        Inspect a single header. See Single Header below for details.
        """
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs']]:
        """
        Inspect a single query argument. See Single Query Argument below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchUriPathArgs']]:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


if not MYPY:
    class RuleGroupRuleStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRegexMatchStatementFieldToMatchBodyArgsDict(TypedDict):
        oversize_handling: NotRequired[pulumi.Input[str]]
elif False:
    RuleGroupRuleStatementRegexMatchStatementFieldToMatchBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesArgsDict(TypedDict):
        match_patterns: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgsDict']]]
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        oversize_handling: pulumi.Input[str]
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
elif False:
    RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs']]] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param pulumi.Input[str] match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs']]]:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        excluded_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        included_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_cookies", value)


if not MYPY:
    class RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderArgsDict(TypedDict):
        match_pattern: pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgsDict']
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        oversize_handling: pulumi.Input[str]
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
elif False:
    RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs'] match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param pulumi.Input[str] match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs']:
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        excluded_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        included_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
elif False:
    RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_headers", value)


if not MYPY:
    class RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderOrderArgsDict(TypedDict):
        oversize_handling: pulumi.Input[str]
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
elif False:
    RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderOrderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRegexMatchStatementFieldToMatchJa3FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[str]
elif False:
    RuleGroupRuleStatementRegexMatchStatementFieldToMatchJa3FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyArgsDict(TypedDict):
        match_pattern: pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict']
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        invalid_fallback_behavior: NotRequired[pulumi.Input[str]]
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        oversize_handling: NotRequired[pulumi.Input[str]]
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
elif False:
    RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 invalid_fallback_behavior: Optional[pulumi.Input[str]] = None,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs'] match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param pulumi.Input[str] match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param pulumi.Input[str] invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param pulumi.Input[str] oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs']:
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        included_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_paths", value)


if not MYPY:
    class RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRegexMatchStatementFieldToMatchMethodArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRegexMatchStatementFieldToMatchMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRegexMatchStatementFieldToMatchQueryStringArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRegexMatchStatementFieldToMatchQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleHeaderArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
elif False:
    RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
elif False:
    RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RuleGroupRuleStatementRegexMatchStatementFieldToMatchUriPathArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRegexMatchStatementFieldToMatchUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRegexMatchStatementTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[int]
        """
        The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        type: pulumi.Input[str]
        """
        The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
elif False:
    RuleGroupRuleStatementRegexMatchStatementTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexMatchStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class RuleGroupRuleStatementRegexPatternSetReferenceStatementArgsDict(TypedDict):
        arn: pulumi.Input[str]
        """
        The Amazon Resource Name (ARN) of the Regex Pattern Set that this statement references.
        """
        text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementTextTransformationArgsDict']]]
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
        At least one required.
        See Text Transformation below for details.
        """
        field_to_match: NotRequired[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchArgsDict']]
        """
        The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
elif False:
    RuleGroupRuleStatementRegexPatternSetReferenceStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchArgs']] = None):
        """
        :param pulumi.Input[str] arn: The Amazon Resource Name (ARN) of the Regex Pattern Set that this statement references.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
               At least one required.
               See Text Transformation below for details.
        :param pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchArgs'] field_to_match: The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @property
    @pulumi.getter
    def arn(self) -> pulumi.Input[str]:
        """
        The Amazon Resource Name (ARN) of the Regex Pattern Set that this statement references.
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "arn", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
        At least one required.
        See Text Transformation below for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchArgs']]:
        """
        The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


if not MYPY:
    class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchArgsDict(TypedDict):
        all_query_arguments: NotRequired[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgsDict']]
        """
        Inspect all query arguments.
        """
        body: NotRequired[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgsDict']]
        """
        Inspect the request body, which immediately follows the request headers.
        """
        cookies: NotRequired[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgsDict']]
        """
        Inspect the cookies in the web request. See Cookies below for details.
        """
        header_orders: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgsDict']]]]
        """
        Inspect the request headers. See Header Order below for details.
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgsDict']]]]
        """
        Inspect the request headers. See Headers below for details.
        """
        ja3_fingerprint: NotRequired[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgsDict']]
        json_body: NotRequired[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgsDict']]
        """
        Inspect the request body as JSON. See JSON Body for details.
        """
        method: NotRequired[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgsDict']]
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        query_string: NotRequired[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgsDict']]
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        single_header: NotRequired[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgsDict']]
        """
        Inspect a single header. See Single Header below for details.
        """
        single_query_argument: NotRequired[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgsDict']]
        """
        Inspect a single query argument. See Single Query Argument below for details.
        """
        uri_path: NotRequired[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgsDict']]
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
elif False:
    RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_path: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs']] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs'] all_query_arguments: Inspect all query arguments.
        :param pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs'] body: Inspect the request body, which immediately follows the request headers.
        :param pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs'] cookies: Inspect the cookies in the web request. See Cookies below for details.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs']]] header_orders: Inspect the request headers. See Header Order below for details.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs']]] headers: Inspect the request headers. See Headers below for details.
        :param pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs'] json_body: Inspect the request body as JSON. See JSON Body for details.
        :param pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs'] method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs'] query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs'] single_header: Inspect a single header. See Single Header below for details.
        :param pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs'] single_query_argument: Inspect a single query argument. See Single Query Argument below for details.
        :param pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs'] uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs']]:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs']]:
        """
        Inspect the request body, which immediately follows the request headers.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs']]:
        """
        Inspect the cookies in the web request. See Cookies below for details.
        """
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs']]]]:
        """
        Inspect the request headers. See Header Order below for details.
        """
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs']]]]:
        """
        Inspect the request headers. See Headers below for details.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs']]:
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs']]:
        """
        Inspect the request body as JSON. See JSON Body for details.
        """
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs']]:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs']]:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs']]:
        """
        Inspect a single header. See Single Header below for details.
        """
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs']]:
        """
        Inspect a single query argument. See Single Query Argument below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs']]:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


if not MYPY:
    class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgsDict(TypedDict):
        oversize_handling: NotRequired[pulumi.Input[str]]
elif False:
    RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgsDict(TypedDict):
        match_patterns: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgsDict']]]
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        oversize_handling: pulumi.Input[str]
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
elif False:
    RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs']]] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param pulumi.Input[str] match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs']]]:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        excluded_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        included_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_cookies", value)


if not MYPY:
    class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgsDict(TypedDict):
        match_pattern: pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgsDict']
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        oversize_handling: pulumi.Input[str]
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
elif False:
    RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs'] match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param pulumi.Input[str] match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs']:
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        excluded_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        included_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
elif False:
    RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_headers", value)


if not MYPY:
    class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgsDict(TypedDict):
        oversize_handling: pulumi.Input[str]
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
elif False:
    RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[str]
elif False:
    RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgsDict(TypedDict):
        match_pattern: pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgsDict']
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        invalid_fallback_behavior: NotRequired[pulumi.Input[str]]
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        oversize_handling: NotRequired[pulumi.Input[str]]
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
elif False:
    RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 invalid_fallback_behavior: Optional[pulumi.Input[str]] = None,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs'] match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param pulumi.Input[str] match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param pulumi.Input[str] invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param pulumi.Input[str] oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs']:
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        included_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_paths", value)


if not MYPY:
    class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
elif False:
    RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
elif False:
    RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRegexPatternSetReferenceStatementTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[int]
        """
        The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        type: pulumi.Input[str]
        """
        The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
elif False:
    RuleGroupRuleStatementRegexPatternSetReferenceStatementTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class RuleGroupRuleStatementSizeConstraintStatementArgsDict(TypedDict):
        comparison_operator: pulumi.Input[str]
        """
        The operator to use to compare the request part to the size setting. Valid values include: `EQ`, `NE`, `LE`, `LT`, `GE`, or `GT`.
        """
        size: pulumi.Input[int]
        """
        The size, in bytes, to compare to the request part, after any transformations. Valid values are integers between 0 and 21474836480, inclusive.
        """
        text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementTextTransformationArgsDict']]]
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
        At least one required.
        See Text Transformation below for details.
        """
        field_to_match: NotRequired[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchArgsDict']]
        """
        The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
elif False:
    RuleGroupRuleStatementSizeConstraintStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSizeConstraintStatementArgs:
    def __init__(__self__, *,
                 comparison_operator: pulumi.Input[str],
                 size: pulumi.Input[int],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchArgs']] = None):
        """
        :param pulumi.Input[str] comparison_operator: The operator to use to compare the request part to the size setting. Valid values include: `EQ`, `NE`, `LE`, `LT`, `GE`, or `GT`.
        :param pulumi.Input[int] size: The size, in bytes, to compare to the request part, after any transformations. Valid values are integers between 0 and 21474836480, inclusive.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
               At least one required.
               See Text Transformation below for details.
        :param pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchArgs'] field_to_match: The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        pulumi.set(__self__, "comparison_operator", comparison_operator)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> pulumi.Input[str]:
        """
        The operator to use to compare the request part to the size setting. Valid values include: `EQ`, `NE`, `LE`, `LT`, `GE`, or `GT`.
        """
        return pulumi.get(self, "comparison_operator")

    @comparison_operator.setter
    def comparison_operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "comparison_operator", value)

    @property
    @pulumi.getter
    def size(self) -> pulumi.Input[int]:
        """
        The size, in bytes, to compare to the request part, after any transformations. Valid values are integers between 0 and 21474836480, inclusive.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[int]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
        At least one required.
        See Text Transformation below for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchArgs']]:
        """
        The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


if not MYPY:
    class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchArgsDict(TypedDict):
        all_query_arguments: NotRequired[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgsDict']]
        """
        Inspect all query arguments.
        """
        body: NotRequired[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchBodyArgsDict']]
        """
        Inspect the request body, which immediately follows the request headers.
        """
        cookies: NotRequired[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesArgsDict']]
        """
        Inspect the cookies in the web request. See Cookies below for details.
        """
        header_orders: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderOrderArgsDict']]]]
        """
        Inspect the request headers. See Header Order below for details.
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderArgsDict']]]]
        """
        Inspect the request headers. See Headers below for details.
        """
        ja3_fingerprint: NotRequired[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgsDict']]
        json_body: NotRequired[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyArgsDict']]
        """
        Inspect the request body as JSON. See JSON Body for details.
        """
        method: NotRequired[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchMethodArgsDict']]
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        query_string: NotRequired[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchQueryStringArgsDict']]
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        single_header: NotRequired[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleHeaderArgsDict']]
        """
        Inspect a single header. See Single Header below for details.
        """
        single_query_argument: NotRequired[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgsDict']]
        """
        Inspect a single query argument. See Single Query Argument below for details.
        """
        uri_path: NotRequired[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchUriPathArgsDict']]
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
elif False:
    RuleGroupRuleStatementSizeConstraintStatementFieldToMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_path: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchUriPathArgs']] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs'] all_query_arguments: Inspect all query arguments.
        :param pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchBodyArgs'] body: Inspect the request body, which immediately follows the request headers.
        :param pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesArgs'] cookies: Inspect the cookies in the web request. See Cookies below for details.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs']]] header_orders: Inspect the request headers. See Header Order below for details.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderArgs']]] headers: Inspect the request headers. See Headers below for details.
        :param pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyArgs'] json_body: Inspect the request body as JSON. See JSON Body for details.
        :param pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchMethodArgs'] method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchQueryStringArgs'] query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs'] single_header: Inspect a single header. See Single Header below for details.
        :param pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs'] single_query_argument: Inspect a single query argument. See Single Query Argument below for details.
        :param pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchUriPathArgs'] uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs']]:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchBodyArgs']]:
        """
        Inspect the request body, which immediately follows the request headers.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesArgs']]:
        """
        Inspect the cookies in the web request. See Cookies below for details.
        """
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs']]]]:
        """
        Inspect the request headers. See Header Order below for details.
        """
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderArgs']]]]:
        """
        Inspect the request headers. See Headers below for details.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs']]:
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyArgs']]:
        """
        Inspect the request body as JSON. See JSON Body for details.
        """
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchMethodArgs']]:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchQueryStringArgs']]:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs']]:
        """
        Inspect a single header. See Single Header below for details.
        """
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs']]:
        """
        Inspect a single query argument. See Single Query Argument below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchUriPathArgs']]:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


if not MYPY:
    class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchBodyArgsDict(TypedDict):
        oversize_handling: NotRequired[pulumi.Input[str]]
elif False:
    RuleGroupRuleStatementSizeConstraintStatementFieldToMatchBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesArgsDict(TypedDict):
        match_patterns: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgsDict']]]
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        oversize_handling: pulumi.Input[str]
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
elif False:
    RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs']]] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param pulumi.Input[str] match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs']]]:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        excluded_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        included_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_cookies", value)


if not MYPY:
    class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderArgsDict(TypedDict):
        match_pattern: pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgsDict']
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        oversize_handling: pulumi.Input[str]
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
elif False:
    RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs'] match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param pulumi.Input[str] match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs']:
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        excluded_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        included_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
elif False:
    RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_headers", value)


if not MYPY:
    class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderOrderArgsDict(TypedDict):
        oversize_handling: pulumi.Input[str]
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
elif False:
    RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderOrderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[str]
elif False:
    RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyArgsDict(TypedDict):
        match_pattern: pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgsDict']
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        invalid_fallback_behavior: NotRequired[pulumi.Input[str]]
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        oversize_handling: NotRequired[pulumi.Input[str]]
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
elif False:
    RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 invalid_fallback_behavior: Optional[pulumi.Input[str]] = None,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs'] match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param pulumi.Input[str] match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param pulumi.Input[str] invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param pulumi.Input[str] oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs']:
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        included_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_paths", value)


if not MYPY:
    class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchMethodArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementSizeConstraintStatementFieldToMatchMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchQueryStringArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementSizeConstraintStatementFieldToMatchQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleHeaderArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
elif False:
    RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
elif False:
    RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchUriPathArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementSizeConstraintStatementFieldToMatchUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementSizeConstraintStatementTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[int]
        """
        The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        type: pulumi.Input[str]
        """
        The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
elif False:
    RuleGroupRuleStatementSizeConstraintStatementTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSizeConstraintStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class RuleGroupRuleStatementSqliMatchStatementArgsDict(TypedDict):
        text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementTextTransformationArgsDict']]]
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
        At least one required.
        See Text Transformation below for details.
        """
        field_to_match: NotRequired[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchArgsDict']]
        """
        The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        sensitivity_level: NotRequired[pulumi.Input[str]]
        """
        Sensitivity that you want AWS WAF to use to inspect for SQL injection attacks. Valid values include: `LOW`, `HIGH`.
        """
elif False:
    RuleGroupRuleStatementSqliMatchStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSqliMatchStatementArgs:
    def __init__(__self__, *,
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchArgs']] = None,
                 sensitivity_level: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
               At least one required.
               See Text Transformation below for details.
        :param pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchArgs'] field_to_match: The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        :param pulumi.Input[str] sensitivity_level: Sensitivity that you want AWS WAF to use to inspect for SQL injection attacks. Valid values include: `LOW`, `HIGH`.
        """
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)
        if sensitivity_level is not None:
            pulumi.set(__self__, "sensitivity_level", sensitivity_level)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
        At least one required.
        See Text Transformation below for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchArgs']]:
        """
        The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)

    @property
    @pulumi.getter(name="sensitivityLevel")
    def sensitivity_level(self) -> Optional[pulumi.Input[str]]:
        """
        Sensitivity that you want AWS WAF to use to inspect for SQL injection attacks. Valid values include: `LOW`, `HIGH`.
        """
        return pulumi.get(self, "sensitivity_level")

    @sensitivity_level.setter
    def sensitivity_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sensitivity_level", value)


if not MYPY:
    class RuleGroupRuleStatementSqliMatchStatementFieldToMatchArgsDict(TypedDict):
        all_query_arguments: NotRequired[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgsDict']]
        """
        Inspect all query arguments.
        """
        body: NotRequired[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchBodyArgsDict']]
        """
        Inspect the request body, which immediately follows the request headers.
        """
        cookies: NotRequired[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesArgsDict']]
        """
        Inspect the cookies in the web request. See Cookies below for details.
        """
        header_orders: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderOrderArgsDict']]]]
        """
        Inspect the request headers. See Header Order below for details.
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderArgsDict']]]]
        """
        Inspect the request headers. See Headers below for details.
        """
        ja3_fingerprint: NotRequired[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchJa3FingerprintArgsDict']]
        json_body: NotRequired[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyArgsDict']]
        """
        Inspect the request body as JSON. See JSON Body for details.
        """
        method: NotRequired[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchMethodArgsDict']]
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        query_string: NotRequired[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchQueryStringArgsDict']]
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        single_header: NotRequired[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleHeaderArgsDict']]
        """
        Inspect a single header. See Single Header below for details.
        """
        single_query_argument: NotRequired[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgsDict']]
        """
        Inspect a single query argument. See Single Query Argument below for details.
        """
        uri_path: NotRequired[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchUriPathArgsDict']]
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
elif False:
    RuleGroupRuleStatementSqliMatchStatementFieldToMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_path: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchUriPathArgs']] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs'] all_query_arguments: Inspect all query arguments.
        :param pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchBodyArgs'] body: Inspect the request body, which immediately follows the request headers.
        :param pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesArgs'] cookies: Inspect the cookies in the web request. See Cookies below for details.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderOrderArgs']]] header_orders: Inspect the request headers. See Header Order below for details.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderArgs']]] headers: Inspect the request headers. See Headers below for details.
        :param pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyArgs'] json_body: Inspect the request body as JSON. See JSON Body for details.
        :param pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchMethodArgs'] method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchQueryStringArgs'] query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleHeaderArgs'] single_header: Inspect a single header. See Single Header below for details.
        :param pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs'] single_query_argument: Inspect a single query argument. See Single Query Argument below for details.
        :param pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchUriPathArgs'] uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs']]:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchBodyArgs']]:
        """
        Inspect the request body, which immediately follows the request headers.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesArgs']]:
        """
        Inspect the cookies in the web request. See Cookies below for details.
        """
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderOrderArgs']]]]:
        """
        Inspect the request headers. See Header Order below for details.
        """
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderArgs']]]]:
        """
        Inspect the request headers. See Headers below for details.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs']]:
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyArgs']]:
        """
        Inspect the request body as JSON. See JSON Body for details.
        """
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchMethodArgs']]:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchQueryStringArgs']]:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleHeaderArgs']]:
        """
        Inspect a single header. See Single Header below for details.
        """
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs']]:
        """
        Inspect a single query argument. See Single Query Argument below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchUriPathArgs']]:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


if not MYPY:
    class RuleGroupRuleStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementSqliMatchStatementFieldToMatchBodyArgsDict(TypedDict):
        oversize_handling: NotRequired[pulumi.Input[str]]
elif False:
    RuleGroupRuleStatementSqliMatchStatementFieldToMatchBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesArgsDict(TypedDict):
        match_patterns: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgsDict']]]
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        oversize_handling: pulumi.Input[str]
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
elif False:
    RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs']]] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param pulumi.Input[str] match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs']]]:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        excluded_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        included_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_cookies", value)


if not MYPY:
    class RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderArgsDict(TypedDict):
        match_pattern: pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgsDict']
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        oversize_handling: pulumi.Input[str]
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
elif False:
    RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs'] match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param pulumi.Input[str] match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs']:
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        excluded_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        included_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
elif False:
    RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_headers", value)


if not MYPY:
    class RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderOrderArgsDict(TypedDict):
        oversize_handling: pulumi.Input[str]
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
elif False:
    RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderOrderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementSqliMatchStatementFieldToMatchJa3FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[str]
elif False:
    RuleGroupRuleStatementSqliMatchStatementFieldToMatchJa3FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyArgsDict(TypedDict):
        match_pattern: pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict']
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        invalid_fallback_behavior: NotRequired[pulumi.Input[str]]
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        oversize_handling: NotRequired[pulumi.Input[str]]
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
elif False:
    RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 invalid_fallback_behavior: Optional[pulumi.Input[str]] = None,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs'] match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param pulumi.Input[str] match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param pulumi.Input[str] invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param pulumi.Input[str] oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs']:
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        included_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_paths", value)


if not MYPY:
    class RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementSqliMatchStatementFieldToMatchMethodArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementSqliMatchStatementFieldToMatchMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementSqliMatchStatementFieldToMatchQueryStringArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementSqliMatchStatementFieldToMatchQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleHeaderArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
elif False:
    RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
elif False:
    RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RuleGroupRuleStatementSqliMatchStatementFieldToMatchUriPathArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementSqliMatchStatementFieldToMatchUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementSqliMatchStatementTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[int]
        """
        The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        type: pulumi.Input[str]
        """
        The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
elif False:
    RuleGroupRuleStatementSqliMatchStatementTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSqliMatchStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class RuleGroupRuleStatementXssMatchStatementArgsDict(TypedDict):
        text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementXssMatchStatementTextTransformationArgsDict']]]
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
        At least one required.
        See Text Transformation below for details.
        """
        field_to_match: NotRequired[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchArgsDict']]
        """
        The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
elif False:
    RuleGroupRuleStatementXssMatchStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementXssMatchStatementArgs:
    def __init__(__self__, *,
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementXssMatchStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementXssMatchStatementTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
               At least one required.
               See Text Transformation below for details.
        :param pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchArgs'] field_to_match: The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementXssMatchStatementTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
        At least one required.
        See Text Transformation below for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementXssMatchStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchArgs']]:
        """
        The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


if not MYPY:
    class RuleGroupRuleStatementXssMatchStatementFieldToMatchArgsDict(TypedDict):
        all_query_arguments: NotRequired[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgsDict']]
        """
        Inspect all query arguments.
        """
        body: NotRequired[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchBodyArgsDict']]
        """
        Inspect the request body, which immediately follows the request headers.
        """
        cookies: NotRequired[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesArgsDict']]
        """
        Inspect the cookies in the web request. See Cookies below for details.
        """
        header_orders: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderOrderArgsDict']]]]
        """
        Inspect the request headers. See Header Order below for details.
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderArgsDict']]]]
        """
        Inspect the request headers. See Headers below for details.
        """
        ja3_fingerprint: NotRequired[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchJa3FingerprintArgsDict']]
        json_body: NotRequired[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyArgsDict']]
        """
        Inspect the request body as JSON. See JSON Body for details.
        """
        method: NotRequired[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchMethodArgsDict']]
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        query_string: NotRequired[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchQueryStringArgsDict']]
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        single_header: NotRequired[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleHeaderArgsDict']]
        """
        Inspect a single header. See Single Header below for details.
        """
        single_query_argument: NotRequired[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgsDict']]
        """
        Inspect a single query argument. See Single Query Argument below for details.
        """
        uri_path: NotRequired[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchUriPathArgsDict']]
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
elif False:
    RuleGroupRuleStatementXssMatchStatementFieldToMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchJa3FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_path: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchUriPathArgs']] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs'] all_query_arguments: Inspect all query arguments.
        :param pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchBodyArgs'] body: Inspect the request body, which immediately follows the request headers.
        :param pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesArgs'] cookies: Inspect the cookies in the web request. See Cookies below for details.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderOrderArgs']]] header_orders: Inspect the request headers. See Header Order below for details.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderArgs']]] headers: Inspect the request headers. See Headers below for details.
        :param pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyArgs'] json_body: Inspect the request body as JSON. See JSON Body for details.
        :param pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchMethodArgs'] method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchQueryStringArgs'] query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleHeaderArgs'] single_header: Inspect a single header. See Single Header below for details.
        :param pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs'] single_query_argument: Inspect a single query argument. See Single Query Argument below for details.
        :param pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchUriPathArgs'] uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs']]:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchBodyArgs']]:
        """
        Inspect the request body, which immediately follows the request headers.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesArgs']]:
        """
        Inspect the cookies in the web request. See Cookies below for details.
        """
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderOrderArgs']]]]:
        """
        Inspect the request headers. See Header Order below for details.
        """
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderArgs']]]]:
        """
        Inspect the request headers. See Headers below for details.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchJa3FingerprintArgs']]:
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyArgs']]:
        """
        Inspect the request body as JSON. See JSON Body for details.
        """
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchMethodArgs']]:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchQueryStringArgs']]:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleHeaderArgs']]:
        """
        Inspect a single header. See Single Header below for details.
        """
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs']]:
        """
        Inspect a single query argument. See Single Query Argument below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchUriPathArgs']]:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


if not MYPY:
    class RuleGroupRuleStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementXssMatchStatementFieldToMatchBodyArgsDict(TypedDict):
        oversize_handling: NotRequired[pulumi.Input[str]]
elif False:
    RuleGroupRuleStatementXssMatchStatementFieldToMatchBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesArgsDict(TypedDict):
        match_patterns: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgsDict']]]
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        oversize_handling: pulumi.Input[str]
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
elif False:
    RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs']]] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param pulumi.Input[str] match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs']]]:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        excluded_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        included_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_cookies", value)


if not MYPY:
    class RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderArgsDict(TypedDict):
        match_pattern: pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgsDict']
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        oversize_handling: pulumi.Input[str]
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
elif False:
    RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs'] match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param pulumi.Input[str] match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs']:
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        excluded_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        included_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
elif False:
    RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_headers", value)


if not MYPY:
    class RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderOrderArgsDict(TypedDict):
        oversize_handling: pulumi.Input[str]
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
elif False:
    RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderOrderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementXssMatchStatementFieldToMatchJa3FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[str]
elif False:
    RuleGroupRuleStatementXssMatchStatementFieldToMatchJa3FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyArgsDict(TypedDict):
        match_pattern: pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict']
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        invalid_fallback_behavior: NotRequired[pulumi.Input[str]]
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        oversize_handling: NotRequired[pulumi.Input[str]]
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
elif False:
    RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 invalid_fallback_behavior: Optional[pulumi.Input[str]] = None,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs'] match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param pulumi.Input[str] match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param pulumi.Input[str] invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param pulumi.Input[str] oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs']:
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        included_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_paths", value)


if not MYPY:
    class RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementXssMatchStatementFieldToMatchMethodArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementXssMatchStatementFieldToMatchMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementXssMatchStatementFieldToMatchQueryStringArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementXssMatchStatementFieldToMatchQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleHeaderArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
elif False:
    RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
elif False:
    RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RuleGroupRuleStatementXssMatchStatementFieldToMatchUriPathArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementXssMatchStatementFieldToMatchUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementXssMatchStatementTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[int]
        """
        The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        type: pulumi.Input[str]
        """
        The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
elif False:
    RuleGroupRuleStatementXssMatchStatementTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementXssMatchStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class RuleGroupRuleVisibilityConfigArgsDict(TypedDict):
        cloudwatch_metrics_enabled: pulumi.Input[bool]
        """
        A boolean indicating whether the associated resource sends metrics to CloudWatch. For the list of available metrics, see [AWS WAF Metrics](https://docs.aws.amazon.com/waf/latest/developerguide/monitoring-cloudwatch.html#waf-metrics).
        """
        metric_name: pulumi.Input[str]
        """
        A friendly name of the CloudWatch metric. The name can contain only alphanumeric characters (A-Z, a-z, 0-9) hyphen(-) and underscore (_), with length from one to 128 characters. It can't contain whitespace or metric names reserved for AWS WAF, for example `All` and `Default_Action`.
        """
        sampled_requests_enabled: pulumi.Input[bool]
        """
        A boolean indicating whether AWS WAF should store a sampling of the web requests that match the rules. You can view the sampled requests through the AWS WAF console.
        """
elif False:
    RuleGroupRuleVisibilityConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleVisibilityConfigArgs:
    def __init__(__self__, *,
                 cloudwatch_metrics_enabled: pulumi.Input[bool],
                 metric_name: pulumi.Input[str],
                 sampled_requests_enabled: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] cloudwatch_metrics_enabled: A boolean indicating whether the associated resource sends metrics to CloudWatch. For the list of available metrics, see [AWS WAF Metrics](https://docs.aws.amazon.com/waf/latest/developerguide/monitoring-cloudwatch.html#waf-metrics).
        :param pulumi.Input[str] metric_name: A friendly name of the CloudWatch metric. The name can contain only alphanumeric characters (A-Z, a-z, 0-9) hyphen(-) and underscore (_), with length from one to 128 characters. It can't contain whitespace or metric names reserved for AWS WAF, for example `All` and `Default_Action`.
        :param pulumi.Input[bool] sampled_requests_enabled: A boolean indicating whether AWS WAF should store a sampling of the web requests that match the rules. You can view the sampled requests through the AWS WAF console.
        """
        pulumi.set(__self__, "cloudwatch_metrics_enabled", cloudwatch_metrics_enabled)
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "sampled_requests_enabled", sampled_requests_enabled)

    @property
    @pulumi.getter(name="cloudwatchMetricsEnabled")
    def cloudwatch_metrics_enabled(self) -> pulumi.Input[bool]:
        """
        A boolean indicating whether the associated resource sends metrics to CloudWatch. For the list of available metrics, see [AWS WAF Metrics](https://docs.aws.amazon.com/waf/latest/developerguide/monitoring-cloudwatch.html#waf-metrics).
        """
        return pulumi.get(self, "cloudwatch_metrics_enabled")

    @cloudwatch_metrics_enabled.setter
    def cloudwatch_metrics_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "cloudwatch_metrics_enabled", value)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> pulumi.Input[str]:
        """
        A friendly name of the CloudWatch metric. The name can contain only alphanumeric characters (A-Z, a-z, 0-9) hyphen(-) and underscore (_), with length from one to 128 characters. It can't contain whitespace or metric names reserved for AWS WAF, for example `All` and `Default_Action`.
        """
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric_name", value)

    @property
    @pulumi.getter(name="sampledRequestsEnabled")
    def sampled_requests_enabled(self) -> pulumi.Input[bool]:
        """
        A boolean indicating whether AWS WAF should store a sampling of the web requests that match the rules. You can view the sampled requests through the AWS WAF console.
        """
        return pulumi.get(self, "sampled_requests_enabled")

    @sampled_requests_enabled.setter
    def sampled_requests_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "sampled_requests_enabled", value)


if not MYPY:
    class RuleGroupVisibilityConfigArgsDict(TypedDict):
        cloudwatch_metrics_enabled: pulumi.Input[bool]
        """
        A boolean indicating whether the associated resource sends metrics to CloudWatch. For the list of available metrics, see [AWS WAF Metrics](https://docs.aws.amazon.com/waf/latest/developerguide/monitoring-cloudwatch.html#waf-metrics).
        """
        metric_name: pulumi.Input[str]
        """
        A friendly name of the CloudWatch metric. The name can contain only alphanumeric characters (A-Z, a-z, 0-9) hyphen(-) and underscore (_), with length from one to 128 characters. It can't contain whitespace or metric names reserved for AWS WAF, for example `All` and `Default_Action`.
        """
        sampled_requests_enabled: pulumi.Input[bool]
        """
        A boolean indicating whether AWS WAF should store a sampling of the web requests that match the rules. You can view the sampled requests through the AWS WAF console.
        """
elif False:
    RuleGroupVisibilityConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupVisibilityConfigArgs:
    def __init__(__self__, *,
                 cloudwatch_metrics_enabled: pulumi.Input[bool],
                 metric_name: pulumi.Input[str],
                 sampled_requests_enabled: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] cloudwatch_metrics_enabled: A boolean indicating whether the associated resource sends metrics to CloudWatch. For the list of available metrics, see [AWS WAF Metrics](https://docs.aws.amazon.com/waf/latest/developerguide/monitoring-cloudwatch.html#waf-metrics).
        :param pulumi.Input[str] metric_name: A friendly name of the CloudWatch metric. The name can contain only alphanumeric characters (A-Z, a-z, 0-9) hyphen(-) and underscore (_), with length from one to 128 characters. It can't contain whitespace or metric names reserved for AWS WAF, for example `All` and `Default_Action`.
        :param pulumi.Input[bool] sampled_requests_enabled: A boolean indicating whether AWS WAF should store a sampling of the web requests that match the rules. You can view the sampled requests through the AWS WAF console.
        """
        pulumi.set(__self__, "cloudwatch_metrics_enabled", cloudwatch_metrics_enabled)
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "sampled_requests_enabled", sampled_requests_enabled)

    @property
    @pulumi.getter(name="cloudwatchMetricsEnabled")
    def cloudwatch_metrics_enabled(self) -> pulumi.Input[bool]:
        """
        A boolean indicating whether the associated resource sends metrics to CloudWatch. For the list of available metrics, see [AWS WAF Metrics](https://docs.aws.amazon.com/waf/latest/developerguide/monitoring-cloudwatch.html#waf-metrics).
        """
        return pulumi.get(self, "cloudwatch_metrics_enabled")

    @cloudwatch_metrics_enabled.setter
    def cloudwatch_metrics_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "cloudwatch_metrics_enabled", value)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> pulumi.Input[str]:
        """
        A friendly name of the CloudWatch metric. The name can contain only alphanumeric characters (A-Z, a-z, 0-9) hyphen(-) and underscore (_), with length from one to 128 characters. It can't contain whitespace or metric names reserved for AWS WAF, for example `All` and `Default_Action`.
        """
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric_name", value)

    @property
    @pulumi.getter(name="sampledRequestsEnabled")
    def sampled_requests_enabled(self) -> pulumi.Input[bool]:
        """
        A boolean indicating whether AWS WAF should store a sampling of the web requests that match the rules. You can view the sampled requests through the AWS WAF console.
        """
        return pulumi.get(self, "sampled_requests_enabled")

    @sampled_requests_enabled.setter
    def sampled_requests_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "sampled_requests_enabled", value)


if not MYPY:
    class WebAclAssociationConfigArgsDict(TypedDict):
        request_bodies: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclAssociationConfigRequestBodyArgsDict']]]]
        """
        Customizes the request body that your protected resource forward to AWS WAF for inspection. See `request_body` below for details.
        """
elif False:
    WebAclAssociationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclAssociationConfigArgs:
    def __init__(__self__, *,
                 request_bodies: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclAssociationConfigRequestBodyArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclAssociationConfigRequestBodyArgs']]] request_bodies: Customizes the request body that your protected resource forward to AWS WAF for inspection. See `request_body` below for details.
        """
        if request_bodies is not None:
            pulumi.set(__self__, "request_bodies", request_bodies)

    @property
    @pulumi.getter(name="requestBodies")
    def request_bodies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclAssociationConfigRequestBodyArgs']]]]:
        """
        Customizes the request body that your protected resource forward to AWS WAF for inspection. See `request_body` below for details.
        """
        return pulumi.get(self, "request_bodies")

    @request_bodies.setter
    def request_bodies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclAssociationConfigRequestBodyArgs']]]]):
        pulumi.set(self, "request_bodies", value)


if not MYPY:
    class WebAclAssociationConfigRequestBodyArgsDict(TypedDict):
        api_gateways: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclAssociationConfigRequestBodyApiGatewayArgsDict']]]]
        """
        Customizes the request body that your protected Amazon API Gateway REST APIs forward to AWS WAF for inspection. Applicable only when `scope` is set to `CLOUDFRONT`. See `api_gateway` below for details.
        """
        app_runner_services: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclAssociationConfigRequestBodyAppRunnerServiceArgsDict']]]]
        """
        Customizes the request body that your protected Amazon App Runner services forward to AWS WAF for inspection. Applicable only when `scope` is set to `REGIONAL`. See `app_runner_service` below for details.
        """
        cloudfronts: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclAssociationConfigRequestBodyCloudfrontArgsDict']]]]
        """
        Customizes the request body that your protected Amazon CloudFront distributions forward to AWS WAF for inspection. Applicable only when `scope` is set to `REGIONAL`. See `cloudfront` below for details.
        """
        cognito_user_pools: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclAssociationConfigRequestBodyCognitoUserPoolArgsDict']]]]
        """
        Customizes the request body that your protected Amazon Cognito user pools forward to AWS WAF for inspection. Applicable only when `scope` is set to `REGIONAL`. See `cognito_user_pool` below for details.
        """
        verified_access_instances: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclAssociationConfigRequestBodyVerifiedAccessInstanceArgsDict']]]]
        """
        Customizes the request body that your protected AWS Verfied Access instances forward to AWS WAF for inspection. Applicable only when `scope` is set to `REGIONAL`. See `verified_access_instance` below for details.
        """
elif False:
    WebAclAssociationConfigRequestBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclAssociationConfigRequestBodyArgs:
    def __init__(__self__, *,
                 api_gateways: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclAssociationConfigRequestBodyApiGatewayArgs']]]] = None,
                 app_runner_services: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclAssociationConfigRequestBodyAppRunnerServiceArgs']]]] = None,
                 cloudfronts: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclAssociationConfigRequestBodyCloudfrontArgs']]]] = None,
                 cognito_user_pools: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclAssociationConfigRequestBodyCognitoUserPoolArgs']]]] = None,
                 verified_access_instances: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclAssociationConfigRequestBodyVerifiedAccessInstanceArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclAssociationConfigRequestBodyApiGatewayArgs']]] api_gateways: Customizes the request body that your protected Amazon API Gateway REST APIs forward to AWS WAF for inspection. Applicable only when `scope` is set to `CLOUDFRONT`. See `api_gateway` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclAssociationConfigRequestBodyAppRunnerServiceArgs']]] app_runner_services: Customizes the request body that your protected Amazon App Runner services forward to AWS WAF for inspection. Applicable only when `scope` is set to `REGIONAL`. See `app_runner_service` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclAssociationConfigRequestBodyCloudfrontArgs']]] cloudfronts: Customizes the request body that your protected Amazon CloudFront distributions forward to AWS WAF for inspection. Applicable only when `scope` is set to `REGIONAL`. See `cloudfront` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclAssociationConfigRequestBodyCognitoUserPoolArgs']]] cognito_user_pools: Customizes the request body that your protected Amazon Cognito user pools forward to AWS WAF for inspection. Applicable only when `scope` is set to `REGIONAL`. See `cognito_user_pool` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclAssociationConfigRequestBodyVerifiedAccessInstanceArgs']]] verified_access_instances: Customizes the request body that your protected AWS Verfied Access instances forward to AWS WAF for inspection. Applicable only when `scope` is set to `REGIONAL`. See `verified_access_instance` below for details.
        """
        if api_gateways is not None:
            pulumi.set(__self__, "api_gateways", api_gateways)
        if app_runner_services is not None:
            pulumi.set(__self__, "app_runner_services", app_runner_services)
        if cloudfronts is not None:
            pulumi.set(__self__, "cloudfronts", cloudfronts)
        if cognito_user_pools is not None:
            pulumi.set(__self__, "cognito_user_pools", cognito_user_pools)
        if verified_access_instances is not None:
            pulumi.set(__self__, "verified_access_instances", verified_access_instances)

    @property
    @pulumi.getter(name="apiGateways")
    def api_gateways(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclAssociationConfigRequestBodyApiGatewayArgs']]]]:
        """
        Customizes the request body that your protected Amazon API Gateway REST APIs forward to AWS WAF for inspection. Applicable only when `scope` is set to `CLOUDFRONT`. See `api_gateway` below for details.
        """
        return pulumi.get(self, "api_gateways")

    @api_gateways.setter
    def api_gateways(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclAssociationConfigRequestBodyApiGatewayArgs']]]]):
        pulumi.set(self, "api_gateways", value)

    @property
    @pulumi.getter(name="appRunnerServices")
    def app_runner_services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclAssociationConfigRequestBodyAppRunnerServiceArgs']]]]:
        """
        Customizes the request body that your protected Amazon App Runner services forward to AWS WAF for inspection. Applicable only when `scope` is set to `REGIONAL`. See `app_runner_service` below for details.
        """
        return pulumi.get(self, "app_runner_services")

    @app_runner_services.setter
    def app_runner_services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclAssociationConfigRequestBodyAppRunnerServiceArgs']]]]):
        pulumi.set(self, "app_runner_services", value)

    @property
    @pulumi.getter
    def cloudfronts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclAssociationConfigRequestBodyCloudfrontArgs']]]]:
        """
        Customizes the request body that your protected Amazon CloudFront distributions forward to AWS WAF for inspection. Applicable only when `scope` is set to `REGIONAL`. See `cloudfront` below for details.
        """
        return pulumi.get(self, "cloudfronts")

    @cloudfronts.setter
    def cloudfronts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclAssociationConfigRequestBodyCloudfrontArgs']]]]):
        pulumi.set(self, "cloudfronts", value)

    @property
    @pulumi.getter(name="cognitoUserPools")
    def cognito_user_pools(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclAssociationConfigRequestBodyCognitoUserPoolArgs']]]]:
        """
        Customizes the request body that your protected Amazon Cognito user pools forward to AWS WAF for inspection. Applicable only when `scope` is set to `REGIONAL`. See `cognito_user_pool` below for details.
        """
        return pulumi.get(self, "cognito_user_pools")

    @cognito_user_pools.setter
    def cognito_user_pools(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclAssociationConfigRequestBodyCognitoUserPoolArgs']]]]):
        pulumi.set(self, "cognito_user_pools", value)

    @property
    @pulumi.getter(name="verifiedAccessInstances")
    def verified_access_instances(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclAssociationConfigRequestBodyVerifiedAccessInstanceArgs']]]]:
        """
        Customizes the request body that your protected AWS Verfied Access instances forward to AWS WAF for inspection. Applicable only when `scope` is set to `REGIONAL`. See `verified_access_instance` below for details.
        """
        return pulumi.get(self, "verified_access_instances")

    @verified_access_instances.setter
    def verified_access_instances(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclAssociationConfigRequestBodyVerifiedAccessInstanceArgs']]]]):
        pulumi.set(self, "verified_access_instances", value)


if not MYPY:
    class WebAclAssociationConfigRequestBodyApiGatewayArgsDict(TypedDict):
        default_size_inspection_limit: pulumi.Input[str]
        """
        Specifies the maximum size of the web request body component that an associated Amazon API Gateway REST APIs should send to AWS WAF for inspection. This applies to statements in the web ACL that inspect the body or JSON body. Valid values are `KB_16`, `KB_32`, `KB_48` and `KB_64`.
        """
elif False:
    WebAclAssociationConfigRequestBodyApiGatewayArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclAssociationConfigRequestBodyApiGatewayArgs:
    def __init__(__self__, *,
                 default_size_inspection_limit: pulumi.Input[str]):
        """
        :param pulumi.Input[str] default_size_inspection_limit: Specifies the maximum size of the web request body component that an associated Amazon API Gateway REST APIs should send to AWS WAF for inspection. This applies to statements in the web ACL that inspect the body or JSON body. Valid values are `KB_16`, `KB_32`, `KB_48` and `KB_64`.
        """
        pulumi.set(__self__, "default_size_inspection_limit", default_size_inspection_limit)

    @property
    @pulumi.getter(name="defaultSizeInspectionLimit")
    def default_size_inspection_limit(self) -> pulumi.Input[str]:
        """
        Specifies the maximum size of the web request body component that an associated Amazon API Gateway REST APIs should send to AWS WAF for inspection. This applies to statements in the web ACL that inspect the body or JSON body. Valid values are `KB_16`, `KB_32`, `KB_48` and `KB_64`.
        """
        return pulumi.get(self, "default_size_inspection_limit")

    @default_size_inspection_limit.setter
    def default_size_inspection_limit(self, value: pulumi.Input[str]):
        pulumi.set(self, "default_size_inspection_limit", value)


if not MYPY:
    class WebAclAssociationConfigRequestBodyAppRunnerServiceArgsDict(TypedDict):
        default_size_inspection_limit: pulumi.Input[str]
        """
        Specifies the maximum size of the web request body component that an associated Amazon App Runner services should send to AWS WAF for inspection. This applies to statements in the web ACL that inspect the body or JSON body. Valid values are `KB_16`, `KB_32`, `KB_48` and `KB_64`.
        """
elif False:
    WebAclAssociationConfigRequestBodyAppRunnerServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclAssociationConfigRequestBodyAppRunnerServiceArgs:
    def __init__(__self__, *,
                 default_size_inspection_limit: pulumi.Input[str]):
        """
        :param pulumi.Input[str] default_size_inspection_limit: Specifies the maximum size of the web request body component that an associated Amazon App Runner services should send to AWS WAF for inspection. This applies to statements in the web ACL that inspect the body or JSON body. Valid values are `KB_16`, `KB_32`, `KB_48` and `KB_64`.
        """
        pulumi.set(__self__, "default_size_inspection_limit", default_size_inspection_limit)

    @property
    @pulumi.getter(name="defaultSizeInspectionLimit")
    def default_size_inspection_limit(self) -> pulumi.Input[str]:
        """
        Specifies the maximum size of the web request body component that an associated Amazon App Runner services should send to AWS WAF for inspection. This applies to statements in the web ACL that inspect the body or JSON body. Valid values are `KB_16`, `KB_32`, `KB_48` and `KB_64`.
        """
        return pulumi.get(self, "default_size_inspection_limit")

    @default_size_inspection_limit.setter
    def default_size_inspection_limit(self, value: pulumi.Input[str]):
        pulumi.set(self, "default_size_inspection_limit", value)


if not MYPY:
    class WebAclAssociationConfigRequestBodyCloudfrontArgsDict(TypedDict):
        default_size_inspection_limit: pulumi.Input[str]
        """
        Specifies the maximum size of the web request body component that an associated Amazon CloudFront distribution should send to AWS WAF for inspection. This applies to statements in the web ACL that inspect the body or JSON body. Valid values are `KB_16`, `KB_32`, `KB_48` and `KB_64`.
        """
elif False:
    WebAclAssociationConfigRequestBodyCloudfrontArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclAssociationConfigRequestBodyCloudfrontArgs:
    def __init__(__self__, *,
                 default_size_inspection_limit: pulumi.Input[str]):
        """
        :param pulumi.Input[str] default_size_inspection_limit: Specifies the maximum size of the web request body component that an associated Amazon CloudFront distribution should send to AWS WAF for inspection. This applies to statements in the web ACL that inspect the body or JSON body. Valid values are `KB_16`, `KB_32`, `KB_48` and `KB_64`.
        """
        pulumi.set(__self__, "default_size_inspection_limit", default_size_inspection_limit)

    @property
    @pulumi.getter(name="defaultSizeInspectionLimit")
    def default_size_inspection_limit(self) -> pulumi.Input[str]:
        """
        Specifies the maximum size of the web request body component that an associated Amazon CloudFront distribution should send to AWS WAF for inspection. This applies to statements in the web ACL that inspect the body or JSON body. Valid values are `KB_16`, `KB_32`, `KB_48` and `KB_64`.
        """
        return pulumi.get(self, "default_size_inspection_limit")

    @default_size_inspection_limit.setter
    def default_size_inspection_limit(self, value: pulumi.Input[str]):
        pulumi.set(self, "default_size_inspection_limit", value)


if not MYPY:
    class WebAclAssociationConfigRequestBodyCognitoUserPoolArgsDict(TypedDict):
        default_size_inspection_limit: pulumi.Input[str]
        """
        Specifies the maximum size of the web request body component that an associated Amazon Cognito user pools should send to AWS WAF for inspection. This applies to statements in the web ACL that inspect the body or JSON body. Valid values are `KB_16`, `KB_32`, `KB_48` and `KB_64`.
        """
elif False:
    WebAclAssociationConfigRequestBodyCognitoUserPoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclAssociationConfigRequestBodyCognitoUserPoolArgs:
    def __init__(__self__, *,
                 default_size_inspection_limit: pulumi.Input[str]):
        """
        :param pulumi.Input[str] default_size_inspection_limit: Specifies the maximum size of the web request body component that an associated Amazon Cognito user pools should send to AWS WAF for inspection. This applies to statements in the web ACL that inspect the body or JSON body. Valid values are `KB_16`, `KB_32`, `KB_48` and `KB_64`.
        """
        pulumi.set(__self__, "default_size_inspection_limit", default_size_inspection_limit)

    @property
    @pulumi.getter(name="defaultSizeInspectionLimit")
    def default_size_inspection_limit(self) -> pulumi.Input[str]:
        """
        Specifies the maximum size of the web request body component that an associated Amazon Cognito user pools should send to AWS WAF for inspection. This applies to statements in the web ACL that inspect the body or JSON body. Valid values are `KB_16`, `KB_32`, `KB_48` and `KB_64`.
        """
        return pulumi.get(self, "default_size_inspection_limit")

    @default_size_inspection_limit.setter
    def default_size_inspection_limit(self, value: pulumi.Input[str]):
        pulumi.set(self, "default_size_inspection_limit", value)


if not MYPY:
    class WebAclAssociationConfigRequestBodyVerifiedAccessInstanceArgsDict(TypedDict):
        default_size_inspection_limit: pulumi.Input[str]
        """
        Specifies the maximum size of the web request body component that an associated AWS Verified Access instances should send to AWS WAF for inspection. This applies to statements in the web ACL that inspect the body or JSON body. Valid values are `KB_16`, `KB_32`, `KB_48` and `KB_64`.
        """
elif False:
    WebAclAssociationConfigRequestBodyVerifiedAccessInstanceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclAssociationConfigRequestBodyVerifiedAccessInstanceArgs:
    def __init__(__self__, *,
                 default_size_inspection_limit: pulumi.Input[str]):
        """
        :param pulumi.Input[str] default_size_inspection_limit: Specifies the maximum size of the web request body component that an associated AWS Verified Access instances should send to AWS WAF for inspection. This applies to statements in the web ACL that inspect the body or JSON body. Valid values are `KB_16`, `KB_32`, `KB_48` and `KB_64`.
        """
        pulumi.set(__self__, "default_size_inspection_limit", default_size_inspection_limit)

    @property
    @pulumi.getter(name="defaultSizeInspectionLimit")
    def default_size_inspection_limit(self) -> pulumi.Input[str]:
        """
        Specifies the maximum size of the web request body component that an associated AWS Verified Access instances should send to AWS WAF for inspection. This applies to statements in the web ACL that inspect the body or JSON body. Valid values are `KB_16`, `KB_32`, `KB_48` and `KB_64`.
        """
        return pulumi.get(self, "default_size_inspection_limit")

    @default_size_inspection_limit.setter
    def default_size_inspection_limit(self, value: pulumi.Input[str]):
        pulumi.set(self, "default_size_inspection_limit", value)


if not MYPY:
    class WebAclCaptchaConfigArgsDict(TypedDict):
        immunity_time_property: NotRequired[pulumi.Input['WebAclCaptchaConfigImmunityTimePropertyArgsDict']]
        """
        Defines custom immunity time. See `immunity_time_property` below for details.
        """
elif False:
    WebAclCaptchaConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclCaptchaConfigArgs:
    def __init__(__self__, *,
                 immunity_time_property: Optional[pulumi.Input['WebAclCaptchaConfigImmunityTimePropertyArgs']] = None):
        """
        :param pulumi.Input['WebAclCaptchaConfigImmunityTimePropertyArgs'] immunity_time_property: Defines custom immunity time. See `immunity_time_property` below for details.
        """
        if immunity_time_property is not None:
            pulumi.set(__self__, "immunity_time_property", immunity_time_property)

    @property
    @pulumi.getter(name="immunityTimeProperty")
    def immunity_time_property(self) -> Optional[pulumi.Input['WebAclCaptchaConfigImmunityTimePropertyArgs']]:
        """
        Defines custom immunity time. See `immunity_time_property` below for details.
        """
        return pulumi.get(self, "immunity_time_property")

    @immunity_time_property.setter
    def immunity_time_property(self, value: Optional[pulumi.Input['WebAclCaptchaConfigImmunityTimePropertyArgs']]):
        pulumi.set(self, "immunity_time_property", value)


if not MYPY:
    class WebAclCaptchaConfigImmunityTimePropertyArgsDict(TypedDict):
        immunity_time: NotRequired[pulumi.Input[int]]
        """
        The amount of time, in seconds, that a CAPTCHA or challenge timestamp is considered valid by AWS WAF. The default setting is 300.
        """
elif False:
    WebAclCaptchaConfigImmunityTimePropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclCaptchaConfigImmunityTimePropertyArgs:
    def __init__(__self__, *,
                 immunity_time: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] immunity_time: The amount of time, in seconds, that a CAPTCHA or challenge timestamp is considered valid by AWS WAF. The default setting is 300.
        """
        if immunity_time is not None:
            pulumi.set(__self__, "immunity_time", immunity_time)

    @property
    @pulumi.getter(name="immunityTime")
    def immunity_time(self) -> Optional[pulumi.Input[int]]:
        """
        The amount of time, in seconds, that a CAPTCHA or challenge timestamp is considered valid by AWS WAF. The default setting is 300.
        """
        return pulumi.get(self, "immunity_time")

    @immunity_time.setter
    def immunity_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "immunity_time", value)


if not MYPY:
    class WebAclChallengeConfigArgsDict(TypedDict):
        immunity_time_property: NotRequired[pulumi.Input['WebAclChallengeConfigImmunityTimePropertyArgsDict']]
        """
        Defines custom immunity time. See `immunity_time_property` below for details.
        """
elif False:
    WebAclChallengeConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclChallengeConfigArgs:
    def __init__(__self__, *,
                 immunity_time_property: Optional[pulumi.Input['WebAclChallengeConfigImmunityTimePropertyArgs']] = None):
        """
        :param pulumi.Input['WebAclChallengeConfigImmunityTimePropertyArgs'] immunity_time_property: Defines custom immunity time. See `immunity_time_property` below for details.
        """
        if immunity_time_property is not None:
            pulumi.set(__self__, "immunity_time_property", immunity_time_property)

    @property
    @pulumi.getter(name="immunityTimeProperty")
    def immunity_time_property(self) -> Optional[pulumi.Input['WebAclChallengeConfigImmunityTimePropertyArgs']]:
        """
        Defines custom immunity time. See `immunity_time_property` below for details.
        """
        return pulumi.get(self, "immunity_time_property")

    @immunity_time_property.setter
    def immunity_time_property(self, value: Optional[pulumi.Input['WebAclChallengeConfigImmunityTimePropertyArgs']]):
        pulumi.set(self, "immunity_time_property", value)


if not MYPY:
    class WebAclChallengeConfigImmunityTimePropertyArgsDict(TypedDict):
        immunity_time: NotRequired[pulumi.Input[int]]
        """
        The amount of time, in seconds, that a CAPTCHA or challenge timestamp is considered valid by AWS WAF. The default setting is 300.
        """
elif False:
    WebAclChallengeConfigImmunityTimePropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclChallengeConfigImmunityTimePropertyArgs:
    def __init__(__self__, *,
                 immunity_time: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] immunity_time: The amount of time, in seconds, that a CAPTCHA or challenge timestamp is considered valid by AWS WAF. The default setting is 300.
        """
        if immunity_time is not None:
            pulumi.set(__self__, "immunity_time", immunity_time)

    @property
    @pulumi.getter(name="immunityTime")
    def immunity_time(self) -> Optional[pulumi.Input[int]]:
        """
        The amount of time, in seconds, that a CAPTCHA or challenge timestamp is considered valid by AWS WAF. The default setting is 300.
        """
        return pulumi.get(self, "immunity_time")

    @immunity_time.setter
    def immunity_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "immunity_time", value)


if not MYPY:
    class WebAclCustomResponseBodyArgsDict(TypedDict):
        content: pulumi.Input[str]
        """
        Payload of the custom response.
        """
        content_type: pulumi.Input[str]
        """
        Type of content in the payload that you are defining in the `content` argument. Valid values are `TEXT_PLAIN`, `TEXT_HTML`, or `APPLICATION_JSON`.
        """
        key: pulumi.Input[str]
        """
        Unique key identifying the custom response body. This is referenced by the `custom_response_body_key` argument in the `custom_response` block.
        """
elif False:
    WebAclCustomResponseBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclCustomResponseBodyArgs:
    def __init__(__self__, *,
                 content: pulumi.Input[str],
                 content_type: pulumi.Input[str],
                 key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] content: Payload of the custom response.
        :param pulumi.Input[str] content_type: Type of content in the payload that you are defining in the `content` argument. Valid values are `TEXT_PLAIN`, `TEXT_HTML`, or `APPLICATION_JSON`.
        :param pulumi.Input[str] key: Unique key identifying the custom response body. This is referenced by the `custom_response_body_key` argument in the `custom_response` block.
        """
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "content_type", content_type)
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def content(self) -> pulumi.Input[str]:
        """
        Payload of the custom response.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: pulumi.Input[str]):
        pulumi.set(self, "content", value)

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> pulumi.Input[str]:
        """
        Type of content in the payload that you are defining in the `content` argument. Valid values are `TEXT_PLAIN`, `TEXT_HTML`, or `APPLICATION_JSON`.
        """
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "content_type", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Unique key identifying the custom response body. This is referenced by the `custom_response_body_key` argument in the `custom_response` block.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)


if not MYPY:
    class WebAclDefaultActionArgsDict(TypedDict):
        allow: NotRequired[pulumi.Input['WebAclDefaultActionAllowArgsDict']]
        """
        Specifies that AWS WAF should allow requests by default. See `allow` below for details.
        """
        block: NotRequired[pulumi.Input['WebAclDefaultActionBlockArgsDict']]
        """
        Specifies that AWS WAF should block requests by default. See `block` below for details.
        """
elif False:
    WebAclDefaultActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclDefaultActionArgs:
    def __init__(__self__, *,
                 allow: Optional[pulumi.Input['WebAclDefaultActionAllowArgs']] = None,
                 block: Optional[pulumi.Input['WebAclDefaultActionBlockArgs']] = None):
        """
        :param pulumi.Input['WebAclDefaultActionAllowArgs'] allow: Specifies that AWS WAF should allow requests by default. See `allow` below for details.
        :param pulumi.Input['WebAclDefaultActionBlockArgs'] block: Specifies that AWS WAF should block requests by default. See `block` below for details.
        """
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if block is not None:
            pulumi.set(__self__, "block", block)

    @property
    @pulumi.getter
    def allow(self) -> Optional[pulumi.Input['WebAclDefaultActionAllowArgs']]:
        """
        Specifies that AWS WAF should allow requests by default. See `allow` below for details.
        """
        return pulumi.get(self, "allow")

    @allow.setter
    def allow(self, value: Optional[pulumi.Input['WebAclDefaultActionAllowArgs']]):
        pulumi.set(self, "allow", value)

    @property
    @pulumi.getter
    def block(self) -> Optional[pulumi.Input['WebAclDefaultActionBlockArgs']]:
        """
        Specifies that AWS WAF should block requests by default. See `block` below for details.
        """
        return pulumi.get(self, "block")

    @block.setter
    def block(self, value: Optional[pulumi.Input['WebAclDefaultActionBlockArgs']]):
        pulumi.set(self, "block", value)


if not MYPY:
    class WebAclDefaultActionAllowArgsDict(TypedDict):
        custom_request_handling: NotRequired[pulumi.Input['WebAclDefaultActionAllowCustomRequestHandlingArgsDict']]
        """
        Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
elif False:
    WebAclDefaultActionAllowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclDefaultActionAllowArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['WebAclDefaultActionAllowCustomRequestHandlingArgs']] = None):
        """
        :param pulumi.Input['WebAclDefaultActionAllowCustomRequestHandlingArgs'] custom_request_handling: Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['WebAclDefaultActionAllowCustomRequestHandlingArgs']]:
        """
        Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['WebAclDefaultActionAllowCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


if not MYPY:
    class WebAclDefaultActionAllowCustomRequestHandlingArgsDict(TypedDict):
        insert_headers: pulumi.Input[Sequence[pulumi.Input['WebAclDefaultActionAllowCustomRequestHandlingInsertHeaderArgsDict']]]
        """
        The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
elif False:
    WebAclDefaultActionAllowCustomRequestHandlingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclDefaultActionAllowCustomRequestHandlingArgs:
    def __init__(__self__, *,
                 insert_headers: pulumi.Input[Sequence[pulumi.Input['WebAclDefaultActionAllowCustomRequestHandlingInsertHeaderArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclDefaultActionAllowCustomRequestHandlingInsertHeaderArgs']]] insert_headers: The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        pulumi.set(__self__, "insert_headers", insert_headers)

    @property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclDefaultActionAllowCustomRequestHandlingInsertHeaderArgs']]]:
        """
        The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        return pulumi.get(self, "insert_headers")

    @insert_headers.setter
    def insert_headers(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclDefaultActionAllowCustomRequestHandlingInsertHeaderArgs']]]):
        pulumi.set(self, "insert_headers", value)


if not MYPY:
    class WebAclDefaultActionAllowCustomRequestHandlingInsertHeaderArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        """
        value: pulumi.Input[str]
        """
        Value of the custom header.
        """
elif False:
    WebAclDefaultActionAllowCustomRequestHandlingInsertHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclDefaultActionAllowCustomRequestHandlingInsertHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        :param pulumi.Input[str] value: Value of the custom header.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value of the custom header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class WebAclDefaultActionBlockArgsDict(TypedDict):
        custom_response: NotRequired[pulumi.Input['WebAclDefaultActionBlockCustomResponseArgsDict']]
        """
        Defines a custom response for the web request. See `custom_response` below for details.
        """
elif False:
    WebAclDefaultActionBlockArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclDefaultActionBlockArgs:
    def __init__(__self__, *,
                 custom_response: Optional[pulumi.Input['WebAclDefaultActionBlockCustomResponseArgs']] = None):
        """
        :param pulumi.Input['WebAclDefaultActionBlockCustomResponseArgs'] custom_response: Defines a custom response for the web request. See `custom_response` below for details.
        """
        if custom_response is not None:
            pulumi.set(__self__, "custom_response", custom_response)

    @property
    @pulumi.getter(name="customResponse")
    def custom_response(self) -> Optional[pulumi.Input['WebAclDefaultActionBlockCustomResponseArgs']]:
        """
        Defines a custom response for the web request. See `custom_response` below for details.
        """
        return pulumi.get(self, "custom_response")

    @custom_response.setter
    def custom_response(self, value: Optional[pulumi.Input['WebAclDefaultActionBlockCustomResponseArgs']]):
        pulumi.set(self, "custom_response", value)


if not MYPY:
    class WebAclDefaultActionBlockCustomResponseArgsDict(TypedDict):
        response_code: pulumi.Input[int]
        """
        The HTTP status code to return to the client.
        """
        custom_response_body_key: NotRequired[pulumi.Input[str]]
        """
        References the response body that you want AWS WAF to return to the web request client. This must reference a `key` defined in a `custom_response_body` block of this resource.
        """
        response_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclDefaultActionBlockCustomResponseResponseHeaderArgsDict']]]]
        """
        The `response_header` blocks used to define the HTTP response headers added to the response. See `response_header` below for details.
        """
elif False:
    WebAclDefaultActionBlockCustomResponseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclDefaultActionBlockCustomResponseArgs:
    def __init__(__self__, *,
                 response_code: pulumi.Input[int],
                 custom_response_body_key: Optional[pulumi.Input[str]] = None,
                 response_headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclDefaultActionBlockCustomResponseResponseHeaderArgs']]]] = None):
        """
        :param pulumi.Input[int] response_code: The HTTP status code to return to the client.
        :param pulumi.Input[str] custom_response_body_key: References the response body that you want AWS WAF to return to the web request client. This must reference a `key` defined in a `custom_response_body` block of this resource.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclDefaultActionBlockCustomResponseResponseHeaderArgs']]] response_headers: The `response_header` blocks used to define the HTTP response headers added to the response. See `response_header` below for details.
        """
        pulumi.set(__self__, "response_code", response_code)
        if custom_response_body_key is not None:
            pulumi.set(__self__, "custom_response_body_key", custom_response_body_key)
        if response_headers is not None:
            pulumi.set(__self__, "response_headers", response_headers)

    @property
    @pulumi.getter(name="responseCode")
    def response_code(self) -> pulumi.Input[int]:
        """
        The HTTP status code to return to the client.
        """
        return pulumi.get(self, "response_code")

    @response_code.setter
    def response_code(self, value: pulumi.Input[int]):
        pulumi.set(self, "response_code", value)

    @property
    @pulumi.getter(name="customResponseBodyKey")
    def custom_response_body_key(self) -> Optional[pulumi.Input[str]]:
        """
        References the response body that you want AWS WAF to return to the web request client. This must reference a `key` defined in a `custom_response_body` block of this resource.
        """
        return pulumi.get(self, "custom_response_body_key")

    @custom_response_body_key.setter
    def custom_response_body_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_response_body_key", value)

    @property
    @pulumi.getter(name="responseHeaders")
    def response_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclDefaultActionBlockCustomResponseResponseHeaderArgs']]]]:
        """
        The `response_header` blocks used to define the HTTP response headers added to the response. See `response_header` below for details.
        """
        return pulumi.get(self, "response_headers")

    @response_headers.setter
    def response_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclDefaultActionBlockCustomResponseResponseHeaderArgs']]]]):
        pulumi.set(self, "response_headers", value)


if not MYPY:
    class WebAclDefaultActionBlockCustomResponseResponseHeaderArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        """
        value: pulumi.Input[str]
        """
        Value of the custom header.
        """
elif False:
    WebAclDefaultActionBlockCustomResponseResponseHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclDefaultActionBlockCustomResponseResponseHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        :param pulumi.Input[str] value: Value of the custom header.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value of the custom header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class WebAclLoggingConfigurationLoggingFilterArgsDict(TypedDict):
        default_behavior: pulumi.Input[str]
        """
        Default handling for logs that don't match any of the specified filtering conditions. Valid values for `default_behavior` are `KEEP` or `DROP`.
        """
        filters: pulumi.Input[Sequence[pulumi.Input['WebAclLoggingConfigurationLoggingFilterFilterArgsDict']]]
        """
        Filter(s) that you want to apply to the logs. See Filter below for more details.
        """
elif False:
    WebAclLoggingConfigurationLoggingFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclLoggingConfigurationLoggingFilterArgs:
    def __init__(__self__, *,
                 default_behavior: pulumi.Input[str],
                 filters: pulumi.Input[Sequence[pulumi.Input['WebAclLoggingConfigurationLoggingFilterFilterArgs']]]):
        """
        :param pulumi.Input[str] default_behavior: Default handling for logs that don't match any of the specified filtering conditions. Valid values for `default_behavior` are `KEEP` or `DROP`.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclLoggingConfigurationLoggingFilterFilterArgs']]] filters: Filter(s) that you want to apply to the logs. See Filter below for more details.
        """
        pulumi.set(__self__, "default_behavior", default_behavior)
        pulumi.set(__self__, "filters", filters)

    @property
    @pulumi.getter(name="defaultBehavior")
    def default_behavior(self) -> pulumi.Input[str]:
        """
        Default handling for logs that don't match any of the specified filtering conditions. Valid values for `default_behavior` are `KEEP` or `DROP`.
        """
        return pulumi.get(self, "default_behavior")

    @default_behavior.setter
    def default_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "default_behavior", value)

    @property
    @pulumi.getter
    def filters(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclLoggingConfigurationLoggingFilterFilterArgs']]]:
        """
        Filter(s) that you want to apply to the logs. See Filter below for more details.
        """
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclLoggingConfigurationLoggingFilterFilterArgs']]]):
        pulumi.set(self, "filters", value)


if not MYPY:
    class WebAclLoggingConfigurationLoggingFilterFilterArgsDict(TypedDict):
        behavior: pulumi.Input[str]
        """
        Parameter that determines how to handle logs that meet the conditions and requirements of the filter. The valid values for `behavior` are `KEEP` or `DROP`.
        """
        conditions: pulumi.Input[Sequence[pulumi.Input['WebAclLoggingConfigurationLoggingFilterFilterConditionArgsDict']]]
        """
        Match condition(s) for the filter. See Condition below for more details.
        """
        requirement: pulumi.Input[str]
        """
        Logic to apply to the filtering conditions. You can specify that a log must match all conditions or at least one condition in order to satisfy the filter. Valid values for `requirement` are `MEETS_ALL` or `MEETS_ANY`.
        """
elif False:
    WebAclLoggingConfigurationLoggingFilterFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclLoggingConfigurationLoggingFilterFilterArgs:
    def __init__(__self__, *,
                 behavior: pulumi.Input[str],
                 conditions: pulumi.Input[Sequence[pulumi.Input['WebAclLoggingConfigurationLoggingFilterFilterConditionArgs']]],
                 requirement: pulumi.Input[str]):
        """
        :param pulumi.Input[str] behavior: Parameter that determines how to handle logs that meet the conditions and requirements of the filter. The valid values for `behavior` are `KEEP` or `DROP`.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclLoggingConfigurationLoggingFilterFilterConditionArgs']]] conditions: Match condition(s) for the filter. See Condition below for more details.
        :param pulumi.Input[str] requirement: Logic to apply to the filtering conditions. You can specify that a log must match all conditions or at least one condition in order to satisfy the filter. Valid values for `requirement` are `MEETS_ALL` or `MEETS_ANY`.
        """
        pulumi.set(__self__, "behavior", behavior)
        pulumi.set(__self__, "conditions", conditions)
        pulumi.set(__self__, "requirement", requirement)

    @property
    @pulumi.getter
    def behavior(self) -> pulumi.Input[str]:
        """
        Parameter that determines how to handle logs that meet the conditions and requirements of the filter. The valid values for `behavior` are `KEEP` or `DROP`.
        """
        return pulumi.get(self, "behavior")

    @behavior.setter
    def behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "behavior", value)

    @property
    @pulumi.getter
    def conditions(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclLoggingConfigurationLoggingFilterFilterConditionArgs']]]:
        """
        Match condition(s) for the filter. See Condition below for more details.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclLoggingConfigurationLoggingFilterFilterConditionArgs']]]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter
    def requirement(self) -> pulumi.Input[str]:
        """
        Logic to apply to the filtering conditions. You can specify that a log must match all conditions or at least one condition in order to satisfy the filter. Valid values for `requirement` are `MEETS_ALL` or `MEETS_ANY`.
        """
        return pulumi.get(self, "requirement")

    @requirement.setter
    def requirement(self, value: pulumi.Input[str]):
        pulumi.set(self, "requirement", value)


if not MYPY:
    class WebAclLoggingConfigurationLoggingFilterFilterConditionArgsDict(TypedDict):
        action_condition: NotRequired[pulumi.Input['WebAclLoggingConfigurationLoggingFilterFilterConditionActionConditionArgsDict']]
        """
        Configuration for a single action condition. See Action Condition below for more details.
        """
        label_name_condition: NotRequired[pulumi.Input['WebAclLoggingConfigurationLoggingFilterFilterConditionLabelNameConditionArgsDict']]
        """
        Condition for a single label name. See Label Name Condition below for more details.
        """
elif False:
    WebAclLoggingConfigurationLoggingFilterFilterConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclLoggingConfigurationLoggingFilterFilterConditionArgs:
    def __init__(__self__, *,
                 action_condition: Optional[pulumi.Input['WebAclLoggingConfigurationLoggingFilterFilterConditionActionConditionArgs']] = None,
                 label_name_condition: Optional[pulumi.Input['WebAclLoggingConfigurationLoggingFilterFilterConditionLabelNameConditionArgs']] = None):
        """
        :param pulumi.Input['WebAclLoggingConfigurationLoggingFilterFilterConditionActionConditionArgs'] action_condition: Configuration for a single action condition. See Action Condition below for more details.
        :param pulumi.Input['WebAclLoggingConfigurationLoggingFilterFilterConditionLabelNameConditionArgs'] label_name_condition: Condition for a single label name. See Label Name Condition below for more details.
        """
        if action_condition is not None:
            pulumi.set(__self__, "action_condition", action_condition)
        if label_name_condition is not None:
            pulumi.set(__self__, "label_name_condition", label_name_condition)

    @property
    @pulumi.getter(name="actionCondition")
    def action_condition(self) -> Optional[pulumi.Input['WebAclLoggingConfigurationLoggingFilterFilterConditionActionConditionArgs']]:
        """
        Configuration for a single action condition. See Action Condition below for more details.
        """
        return pulumi.get(self, "action_condition")

    @action_condition.setter
    def action_condition(self, value: Optional[pulumi.Input['WebAclLoggingConfigurationLoggingFilterFilterConditionActionConditionArgs']]):
        pulumi.set(self, "action_condition", value)

    @property
    @pulumi.getter(name="labelNameCondition")
    def label_name_condition(self) -> Optional[pulumi.Input['WebAclLoggingConfigurationLoggingFilterFilterConditionLabelNameConditionArgs']]:
        """
        Condition for a single label name. See Label Name Condition below for more details.
        """
        return pulumi.get(self, "label_name_condition")

    @label_name_condition.setter
    def label_name_condition(self, value: Optional[pulumi.Input['WebAclLoggingConfigurationLoggingFilterFilterConditionLabelNameConditionArgs']]):
        pulumi.set(self, "label_name_condition", value)


if not MYPY:
    class WebAclLoggingConfigurationLoggingFilterFilterConditionActionConditionArgsDict(TypedDict):
        action: pulumi.Input[str]
        """
        Action setting that a log record must contain in order to meet the condition. Valid values for `action` are `ALLOW`, `BLOCK`, and `COUNT`.
        """
elif False:
    WebAclLoggingConfigurationLoggingFilterFilterConditionActionConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclLoggingConfigurationLoggingFilterFilterConditionActionConditionArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str]):
        """
        :param pulumi.Input[str] action: Action setting that a log record must contain in order to meet the condition. Valid values for `action` are `ALLOW`, `BLOCK`, and `COUNT`.
        """
        pulumi.set(__self__, "action", action)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        Action setting that a log record must contain in order to meet the condition. Valid values for `action` are `ALLOW`, `BLOCK`, and `COUNT`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)


if not MYPY:
    class WebAclLoggingConfigurationLoggingFilterFilterConditionLabelNameConditionArgsDict(TypedDict):
        label_name: pulumi.Input[str]
        """
        Name of the label that a log record must contain in order to meet the condition. It must be a fully qualified label name, which includes a prefix, optional namespaces, and the label name itself. The prefix identifies the rule group or web ACL context of the rule that added the label.
        """
elif False:
    WebAclLoggingConfigurationLoggingFilterFilterConditionLabelNameConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclLoggingConfigurationLoggingFilterFilterConditionLabelNameConditionArgs:
    def __init__(__self__, *,
                 label_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] label_name: Name of the label that a log record must contain in order to meet the condition. It must be a fully qualified label name, which includes a prefix, optional namespaces, and the label name itself. The prefix identifies the rule group or web ACL context of the rule that added the label.
        """
        pulumi.set(__self__, "label_name", label_name)

    @property
    @pulumi.getter(name="labelName")
    def label_name(self) -> pulumi.Input[str]:
        """
        Name of the label that a log record must contain in order to meet the condition. It must be a fully qualified label name, which includes a prefix, optional namespaces, and the label name itself. The prefix identifies the rule group or web ACL context of the rule that added the label.
        """
        return pulumi.get(self, "label_name")

    @label_name.setter
    def label_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "label_name", value)


if not MYPY:
    class WebAclLoggingConfigurationRedactedFieldArgsDict(TypedDict):
        method: NotRequired[pulumi.Input['WebAclLoggingConfigurationRedactedFieldMethodArgsDict']]
        """
        HTTP method to be redacted. It must be specified as an empty configuration block `{}`. The method indicates the type of operation that the request is asking the origin to perform.
        """
        query_string: NotRequired[pulumi.Input['WebAclLoggingConfigurationRedactedFieldQueryStringArgsDict']]
        """
        Whether to redact the query string. It must be specified as an empty configuration block `{}`. The query string is the part of a URL that appears after a `?` character, if any.
        """
        single_header: NotRequired[pulumi.Input['WebAclLoggingConfigurationRedactedFieldSingleHeaderArgsDict']]
        """
        "single_header" refers to the redaction of a single header. For more information, please see the details below under Single Header.
        """
        uri_path: NotRequired[pulumi.Input['WebAclLoggingConfigurationRedactedFieldUriPathArgsDict']]
        """
        Configuration block that redacts the request URI path. It should be specified as an empty configuration block `{}`. The URI path is the part of a web request that identifies a resource, such as `/images/daily-ad.jpg`.
        """
elif False:
    WebAclLoggingConfigurationRedactedFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclLoggingConfigurationRedactedFieldArgs:
    def __init__(__self__, *,
                 method: Optional[pulumi.Input['WebAclLoggingConfigurationRedactedFieldMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['WebAclLoggingConfigurationRedactedFieldQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['WebAclLoggingConfigurationRedactedFieldSingleHeaderArgs']] = None,
                 uri_path: Optional[pulumi.Input['WebAclLoggingConfigurationRedactedFieldUriPathArgs']] = None):
        """
        :param pulumi.Input['WebAclLoggingConfigurationRedactedFieldMethodArgs'] method: HTTP method to be redacted. It must be specified as an empty configuration block `{}`. The method indicates the type of operation that the request is asking the origin to perform.
        :param pulumi.Input['WebAclLoggingConfigurationRedactedFieldQueryStringArgs'] query_string: Whether to redact the query string. It must be specified as an empty configuration block `{}`. The query string is the part of a URL that appears after a `?` character, if any.
        :param pulumi.Input['WebAclLoggingConfigurationRedactedFieldSingleHeaderArgs'] single_header: "single_header" refers to the redaction of a single header. For more information, please see the details below under Single Header.
        :param pulumi.Input['WebAclLoggingConfigurationRedactedFieldUriPathArgs'] uri_path: Configuration block that redacts the request URI path. It should be specified as an empty configuration block `{}`. The URI path is the part of a web request that identifies a resource, such as `/images/daily-ad.jpg`.
        """
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['WebAclLoggingConfigurationRedactedFieldMethodArgs']]:
        """
        HTTP method to be redacted. It must be specified as an empty configuration block `{}`. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['WebAclLoggingConfigurationRedactedFieldMethodArgs']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['WebAclLoggingConfigurationRedactedFieldQueryStringArgs']]:
        """
        Whether to redact the query string. It must be specified as an empty configuration block `{}`. The query string is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['WebAclLoggingConfigurationRedactedFieldQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['WebAclLoggingConfigurationRedactedFieldSingleHeaderArgs']]:
        """
        "single_header" refers to the redaction of a single header. For more information, please see the details below under Single Header.
        """
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['WebAclLoggingConfigurationRedactedFieldSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['WebAclLoggingConfigurationRedactedFieldUriPathArgs']]:
        """
        Configuration block that redacts the request URI path. It should be specified as an empty configuration block `{}`. The URI path is the part of a web request that identifies a resource, such as `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['WebAclLoggingConfigurationRedactedFieldUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


if not MYPY:
    class WebAclLoggingConfigurationRedactedFieldMethodArgsDict(TypedDict):
        pass
elif False:
    WebAclLoggingConfigurationRedactedFieldMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclLoggingConfigurationRedactedFieldMethodArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclLoggingConfigurationRedactedFieldQueryStringArgsDict(TypedDict):
        pass
elif False:
    WebAclLoggingConfigurationRedactedFieldQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclLoggingConfigurationRedactedFieldQueryStringArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclLoggingConfigurationRedactedFieldSingleHeaderArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the query header to redact. This setting must be provided in lowercase characters.
        """
elif False:
    WebAclLoggingConfigurationRedactedFieldSingleHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclLoggingConfigurationRedactedFieldSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to redact. This setting must be provided in lowercase characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to redact. This setting must be provided in lowercase characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclLoggingConfigurationRedactedFieldUriPathArgsDict(TypedDict):
        pass
elif False:
    WebAclLoggingConfigurationRedactedFieldUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclLoggingConfigurationRedactedFieldUriPathArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Friendly name of the rule. Note that the provider assumes that rules with names matching this pattern, `^ShieldMitigationRuleGroup_<account-id>_<web-acl-guid>_.*`, are AWS-added for [automatic application layer DDoS mitigation activities](https://docs.aws.amazon.com/waf/latest/developerguide/ddos-automatic-app-layer-response-rg.html). Such rules will be ignored by the provider unless you explicitly include them in your configuration (for example, by using the AWS CLI to discover their properties and creating matching configuration). However, since these rules are owned and managed by AWS, you may get permission errors.
        """
        priority: pulumi.Input[int]
        """
        If you define more than one Rule in a WebACL, AWS WAF evaluates each request against the `rules` in order based on the value of `priority`. AWS WAF processes rules with lower priority first.
        """
        statement: pulumi.Input['WebAclRuleStatementArgsDict']
        """
        The AWS WAF processing statement for the rule, for example `byte_match_statement` or `geo_match_statement`. See `statement` below for details.
        """
        visibility_config: pulumi.Input['WebAclRuleVisibilityConfigArgsDict']
        """
        Defines and enables Amazon CloudWatch metrics and web request sample collection. See `visibility_config` below for details.
        """
        action: NotRequired[pulumi.Input['WebAclRuleActionArgsDict']]
        """
        Action that AWS WAF should take on a web request when it matches the rule's statement. This is used only for rules whose **statements do not reference a rule group**. See `action` for details.
        """
        captcha_config: NotRequired[pulumi.Input['WebAclRuleCaptchaConfigArgsDict']]
        """
        Specifies how AWS WAF should handle CAPTCHA evaluations. See `captcha_config` below for details.
        """
        override_action: NotRequired[pulumi.Input['WebAclRuleOverrideActionArgsDict']]
        """
        Override action to apply to the rules in a rule group. Used only for rule **statements that reference a rule group**, like `rule_group_reference_statement` and `managed_rule_group_statement`. See `override_action` below for details.
        """
        rule_labels: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleRuleLabelArgsDict']]]]
        """
        Labels to apply to web requests that match the rule match statement. See `rule_label` below for details.
        """
elif False:
    WebAclRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 priority: pulumi.Input[int],
                 statement: pulumi.Input['WebAclRuleStatementArgs'],
                 visibility_config: pulumi.Input['WebAclRuleVisibilityConfigArgs'],
                 action: Optional[pulumi.Input['WebAclRuleActionArgs']] = None,
                 captcha_config: Optional[pulumi.Input['WebAclRuleCaptchaConfigArgs']] = None,
                 override_action: Optional[pulumi.Input['WebAclRuleOverrideActionArgs']] = None,
                 rule_labels: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleRuleLabelArgs']]]] = None):
        """
        :param pulumi.Input[str] name: Friendly name of the rule. Note that the provider assumes that rules with names matching this pattern, `^ShieldMitigationRuleGroup_<account-id>_<web-acl-guid>_.*`, are AWS-added for [automatic application layer DDoS mitigation activities](https://docs.aws.amazon.com/waf/latest/developerguide/ddos-automatic-app-layer-response-rg.html). Such rules will be ignored by the provider unless you explicitly include them in your configuration (for example, by using the AWS CLI to discover their properties and creating matching configuration). However, since these rules are owned and managed by AWS, you may get permission errors.
        :param pulumi.Input[int] priority: If you define more than one Rule in a WebACL, AWS WAF evaluates each request against the `rules` in order based on the value of `priority`. AWS WAF processes rules with lower priority first.
        :param pulumi.Input['WebAclRuleStatementArgs'] statement: The AWS WAF processing statement for the rule, for example `byte_match_statement` or `geo_match_statement`. See `statement` below for details.
        :param pulumi.Input['WebAclRuleVisibilityConfigArgs'] visibility_config: Defines and enables Amazon CloudWatch metrics and web request sample collection. See `visibility_config` below for details.
        :param pulumi.Input['WebAclRuleActionArgs'] action: Action that AWS WAF should take on a web request when it matches the rule's statement. This is used only for rules whose **statements do not reference a rule group**. See `action` for details.
        :param pulumi.Input['WebAclRuleCaptchaConfigArgs'] captcha_config: Specifies how AWS WAF should handle CAPTCHA evaluations. See `captcha_config` below for details.
        :param pulumi.Input['WebAclRuleOverrideActionArgs'] override_action: Override action to apply to the rules in a rule group. Used only for rule **statements that reference a rule group**, like `rule_group_reference_statement` and `managed_rule_group_statement`. See `override_action` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleRuleLabelArgs']]] rule_labels: Labels to apply to web requests that match the rule match statement. See `rule_label` below for details.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "statement", statement)
        pulumi.set(__self__, "visibility_config", visibility_config)
        if action is not None:
            pulumi.set(__self__, "action", action)
        if captcha_config is not None:
            pulumi.set(__self__, "captcha_config", captcha_config)
        if override_action is not None:
            pulumi.set(__self__, "override_action", override_action)
        if rule_labels is not None:
            pulumi.set(__self__, "rule_labels", rule_labels)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Friendly name of the rule. Note that the provider assumes that rules with names matching this pattern, `^ShieldMitigationRuleGroup_<account-id>_<web-acl-guid>_.*`, are AWS-added for [automatic application layer DDoS mitigation activities](https://docs.aws.amazon.com/waf/latest/developerguide/ddos-automatic-app-layer-response-rg.html). Such rules will be ignored by the provider unless you explicitly include them in your configuration (for example, by using the AWS CLI to discover their properties and creating matching configuration). However, since these rules are owned and managed by AWS, you may get permission errors.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        If you define more than one Rule in a WebACL, AWS WAF evaluates each request against the `rules` in order based on the value of `priority`. AWS WAF processes rules with lower priority first.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def statement(self) -> pulumi.Input['WebAclRuleStatementArgs']:
        """
        The AWS WAF processing statement for the rule, for example `byte_match_statement` or `geo_match_statement`. See `statement` below for details.
        """
        return pulumi.get(self, "statement")

    @statement.setter
    def statement(self, value: pulumi.Input['WebAclRuleStatementArgs']):
        pulumi.set(self, "statement", value)

    @property
    @pulumi.getter(name="visibilityConfig")
    def visibility_config(self) -> pulumi.Input['WebAclRuleVisibilityConfigArgs']:
        """
        Defines and enables Amazon CloudWatch metrics and web request sample collection. See `visibility_config` below for details.
        """
        return pulumi.get(self, "visibility_config")

    @visibility_config.setter
    def visibility_config(self, value: pulumi.Input['WebAclRuleVisibilityConfigArgs']):
        pulumi.set(self, "visibility_config", value)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input['WebAclRuleActionArgs']]:
        """
        Action that AWS WAF should take on a web request when it matches the rule's statement. This is used only for rules whose **statements do not reference a rule group**. See `action` for details.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input['WebAclRuleActionArgs']]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter(name="captchaConfig")
    def captcha_config(self) -> Optional[pulumi.Input['WebAclRuleCaptchaConfigArgs']]:
        """
        Specifies how AWS WAF should handle CAPTCHA evaluations. See `captcha_config` below for details.
        """
        return pulumi.get(self, "captcha_config")

    @captcha_config.setter
    def captcha_config(self, value: Optional[pulumi.Input['WebAclRuleCaptchaConfigArgs']]):
        pulumi.set(self, "captcha_config", value)

    @property
    @pulumi.getter(name="overrideAction")
    def override_action(self) -> Optional[pulumi.Input['WebAclRuleOverrideActionArgs']]:
        """
        Override action to apply to the rules in a rule group. Used only for rule **statements that reference a rule group**, like `rule_group_reference_statement` and `managed_rule_group_statement`. See `override_action` below for details.
        """
        return pulumi.get(self, "override_action")

    @override_action.setter
    def override_action(self, value: Optional[pulumi.Input['WebAclRuleOverrideActionArgs']]):
        pulumi.set(self, "override_action", value)

    @property
    @pulumi.getter(name="ruleLabels")
    def rule_labels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleRuleLabelArgs']]]]:
        """
        Labels to apply to web requests that match the rule match statement. See `rule_label` below for details.
        """
        return pulumi.get(self, "rule_labels")

    @rule_labels.setter
    def rule_labels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleRuleLabelArgs']]]]):
        pulumi.set(self, "rule_labels", value)


if not MYPY:
    class WebAclRuleActionArgsDict(TypedDict):
        allow: NotRequired[pulumi.Input['WebAclRuleActionAllowArgsDict']]
        """
        Instructs AWS WAF to allow the web request. See `allow` below for details.
        """
        block: NotRequired[pulumi.Input['WebAclRuleActionBlockArgsDict']]
        """
        Instructs AWS WAF to block the web request. See `block` below for details.
        """
        captcha: NotRequired[pulumi.Input['WebAclRuleActionCaptchaArgsDict']]
        """
        Instructs AWS WAF to run a Captcha check against the web request. See `captcha` below for details.
        """
        challenge: NotRequired[pulumi.Input['WebAclRuleActionChallengeArgsDict']]
        """
        Instructs AWS WAF to run a check against the request to verify that the request is coming from a legitimate client session. See `challenge` below for details.
        """
        count: NotRequired[pulumi.Input['WebAclRuleActionCountArgsDict']]
        """
        Instructs AWS WAF to count the web request and allow it. See `count` below for details.
        """
elif False:
    WebAclRuleActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleActionArgs:
    def __init__(__self__, *,
                 allow: Optional[pulumi.Input['WebAclRuleActionAllowArgs']] = None,
                 block: Optional[pulumi.Input['WebAclRuleActionBlockArgs']] = None,
                 captcha: Optional[pulumi.Input['WebAclRuleActionCaptchaArgs']] = None,
                 challenge: Optional[pulumi.Input['WebAclRuleActionChallengeArgs']] = None,
                 count: Optional[pulumi.Input['WebAclRuleActionCountArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleActionAllowArgs'] allow: Instructs AWS WAF to allow the web request. See `allow` below for details.
        :param pulumi.Input['WebAclRuleActionBlockArgs'] block: Instructs AWS WAF to block the web request. See `block` below for details.
        :param pulumi.Input['WebAclRuleActionCaptchaArgs'] captcha: Instructs AWS WAF to run a Captcha check against the web request. See `captcha` below for details.
        :param pulumi.Input['WebAclRuleActionChallengeArgs'] challenge: Instructs AWS WAF to run a check against the request to verify that the request is coming from a legitimate client session. See `challenge` below for details.
        :param pulumi.Input['WebAclRuleActionCountArgs'] count: Instructs AWS WAF to count the web request and allow it. See `count` below for details.
        """
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if block is not None:
            pulumi.set(__self__, "block", block)
        if captcha is not None:
            pulumi.set(__self__, "captcha", captcha)
        if challenge is not None:
            pulumi.set(__self__, "challenge", challenge)
        if count is not None:
            pulumi.set(__self__, "count", count)

    @property
    @pulumi.getter
    def allow(self) -> Optional[pulumi.Input['WebAclRuleActionAllowArgs']]:
        """
        Instructs AWS WAF to allow the web request. See `allow` below for details.
        """
        return pulumi.get(self, "allow")

    @allow.setter
    def allow(self, value: Optional[pulumi.Input['WebAclRuleActionAllowArgs']]):
        pulumi.set(self, "allow", value)

    @property
    @pulumi.getter
    def block(self) -> Optional[pulumi.Input['WebAclRuleActionBlockArgs']]:
        """
        Instructs AWS WAF to block the web request. See `block` below for details.
        """
        return pulumi.get(self, "block")

    @block.setter
    def block(self, value: Optional[pulumi.Input['WebAclRuleActionBlockArgs']]):
        pulumi.set(self, "block", value)

    @property
    @pulumi.getter
    def captcha(self) -> Optional[pulumi.Input['WebAclRuleActionCaptchaArgs']]:
        """
        Instructs AWS WAF to run a Captcha check against the web request. See `captcha` below for details.
        """
        return pulumi.get(self, "captcha")

    @captcha.setter
    def captcha(self, value: Optional[pulumi.Input['WebAclRuleActionCaptchaArgs']]):
        pulumi.set(self, "captcha", value)

    @property
    @pulumi.getter
    def challenge(self) -> Optional[pulumi.Input['WebAclRuleActionChallengeArgs']]:
        """
        Instructs AWS WAF to run a check against the request to verify that the request is coming from a legitimate client session. See `challenge` below for details.
        """
        return pulumi.get(self, "challenge")

    @challenge.setter
    def challenge(self, value: Optional[pulumi.Input['WebAclRuleActionChallengeArgs']]):
        pulumi.set(self, "challenge", value)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input['WebAclRuleActionCountArgs']]:
        """
        Instructs AWS WAF to count the web request and allow it. See `count` below for details.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input['WebAclRuleActionCountArgs']]):
        pulumi.set(self, "count", value)


if not MYPY:
    class WebAclRuleActionAllowArgsDict(TypedDict):
        custom_request_handling: NotRequired[pulumi.Input['WebAclRuleActionAllowCustomRequestHandlingArgsDict']]
        """
        Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
elif False:
    WebAclRuleActionAllowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleActionAllowArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['WebAclRuleActionAllowCustomRequestHandlingArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleActionAllowCustomRequestHandlingArgs'] custom_request_handling: Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['WebAclRuleActionAllowCustomRequestHandlingArgs']]:
        """
        Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['WebAclRuleActionAllowCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


if not MYPY:
    class WebAclRuleActionAllowCustomRequestHandlingArgsDict(TypedDict):
        insert_headers: pulumi.Input[Sequence[pulumi.Input['WebAclRuleActionAllowCustomRequestHandlingInsertHeaderArgsDict']]]
        """
        The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
elif False:
    WebAclRuleActionAllowCustomRequestHandlingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleActionAllowCustomRequestHandlingArgs:
    def __init__(__self__, *,
                 insert_headers: pulumi.Input[Sequence[pulumi.Input['WebAclRuleActionAllowCustomRequestHandlingInsertHeaderArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleActionAllowCustomRequestHandlingInsertHeaderArgs']]] insert_headers: The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        pulumi.set(__self__, "insert_headers", insert_headers)

    @property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleActionAllowCustomRequestHandlingInsertHeaderArgs']]]:
        """
        The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        return pulumi.get(self, "insert_headers")

    @insert_headers.setter
    def insert_headers(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleActionAllowCustomRequestHandlingInsertHeaderArgs']]]):
        pulumi.set(self, "insert_headers", value)


if not MYPY:
    class WebAclRuleActionAllowCustomRequestHandlingInsertHeaderArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        """
        value: pulumi.Input[str]
        """
        Value of the custom header.
        """
elif False:
    WebAclRuleActionAllowCustomRequestHandlingInsertHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleActionAllowCustomRequestHandlingInsertHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        :param pulumi.Input[str] value: Value of the custom header.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value of the custom header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class WebAclRuleActionBlockArgsDict(TypedDict):
        custom_response: NotRequired[pulumi.Input['WebAclRuleActionBlockCustomResponseArgsDict']]
        """
        Defines a custom response for the web request. See `custom_response` below for details.
        """
elif False:
    WebAclRuleActionBlockArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleActionBlockArgs:
    def __init__(__self__, *,
                 custom_response: Optional[pulumi.Input['WebAclRuleActionBlockCustomResponseArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleActionBlockCustomResponseArgs'] custom_response: Defines a custom response for the web request. See `custom_response` below for details.
        """
        if custom_response is not None:
            pulumi.set(__self__, "custom_response", custom_response)

    @property
    @pulumi.getter(name="customResponse")
    def custom_response(self) -> Optional[pulumi.Input['WebAclRuleActionBlockCustomResponseArgs']]:
        """
        Defines a custom response for the web request. See `custom_response` below for details.
        """
        return pulumi.get(self, "custom_response")

    @custom_response.setter
    def custom_response(self, value: Optional[pulumi.Input['WebAclRuleActionBlockCustomResponseArgs']]):
        pulumi.set(self, "custom_response", value)


if not MYPY:
    class WebAclRuleActionBlockCustomResponseArgsDict(TypedDict):
        response_code: pulumi.Input[int]
        """
        The HTTP status code to return to the client.
        """
        custom_response_body_key: NotRequired[pulumi.Input[str]]
        """
        References the response body that you want AWS WAF to return to the web request client. This must reference a `key` defined in a `custom_response_body` block of this resource.
        """
        response_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleActionBlockCustomResponseResponseHeaderArgsDict']]]]
        """
        The `response_header` blocks used to define the HTTP response headers added to the response. See `response_header` below for details.
        """
elif False:
    WebAclRuleActionBlockCustomResponseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleActionBlockCustomResponseArgs:
    def __init__(__self__, *,
                 response_code: pulumi.Input[int],
                 custom_response_body_key: Optional[pulumi.Input[str]] = None,
                 response_headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleActionBlockCustomResponseResponseHeaderArgs']]]] = None):
        """
        :param pulumi.Input[int] response_code: The HTTP status code to return to the client.
        :param pulumi.Input[str] custom_response_body_key: References the response body that you want AWS WAF to return to the web request client. This must reference a `key` defined in a `custom_response_body` block of this resource.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleActionBlockCustomResponseResponseHeaderArgs']]] response_headers: The `response_header` blocks used to define the HTTP response headers added to the response. See `response_header` below for details.
        """
        pulumi.set(__self__, "response_code", response_code)
        if custom_response_body_key is not None:
            pulumi.set(__self__, "custom_response_body_key", custom_response_body_key)
        if response_headers is not None:
            pulumi.set(__self__, "response_headers", response_headers)

    @property
    @pulumi.getter(name="responseCode")
    def response_code(self) -> pulumi.Input[int]:
        """
        The HTTP status code to return to the client.
        """
        return pulumi.get(self, "response_code")

    @response_code.setter
    def response_code(self, value: pulumi.Input[int]):
        pulumi.set(self, "response_code", value)

    @property
    @pulumi.getter(name="customResponseBodyKey")
    def custom_response_body_key(self) -> Optional[pulumi.Input[str]]:
        """
        References the response body that you want AWS WAF to return to the web request client. This must reference a `key` defined in a `custom_response_body` block of this resource.
        """
        return pulumi.get(self, "custom_response_body_key")

    @custom_response_body_key.setter
    def custom_response_body_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_response_body_key", value)

    @property
    @pulumi.getter(name="responseHeaders")
    def response_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleActionBlockCustomResponseResponseHeaderArgs']]]]:
        """
        The `response_header` blocks used to define the HTTP response headers added to the response. See `response_header` below for details.
        """
        return pulumi.get(self, "response_headers")

    @response_headers.setter
    def response_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleActionBlockCustomResponseResponseHeaderArgs']]]]):
        pulumi.set(self, "response_headers", value)


if not MYPY:
    class WebAclRuleActionBlockCustomResponseResponseHeaderArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        """
        value: pulumi.Input[str]
        """
        Value of the custom header.
        """
elif False:
    WebAclRuleActionBlockCustomResponseResponseHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleActionBlockCustomResponseResponseHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        :param pulumi.Input[str] value: Value of the custom header.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value of the custom header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class WebAclRuleActionCaptchaArgsDict(TypedDict):
        custom_request_handling: NotRequired[pulumi.Input['WebAclRuleActionCaptchaCustomRequestHandlingArgsDict']]
        """
        Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
elif False:
    WebAclRuleActionCaptchaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleActionCaptchaArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['WebAclRuleActionCaptchaCustomRequestHandlingArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleActionCaptchaCustomRequestHandlingArgs'] custom_request_handling: Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['WebAclRuleActionCaptchaCustomRequestHandlingArgs']]:
        """
        Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['WebAclRuleActionCaptchaCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


if not MYPY:
    class WebAclRuleActionCaptchaCustomRequestHandlingArgsDict(TypedDict):
        insert_headers: pulumi.Input[Sequence[pulumi.Input['WebAclRuleActionCaptchaCustomRequestHandlingInsertHeaderArgsDict']]]
        """
        The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
elif False:
    WebAclRuleActionCaptchaCustomRequestHandlingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleActionCaptchaCustomRequestHandlingArgs:
    def __init__(__self__, *,
                 insert_headers: pulumi.Input[Sequence[pulumi.Input['WebAclRuleActionCaptchaCustomRequestHandlingInsertHeaderArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleActionCaptchaCustomRequestHandlingInsertHeaderArgs']]] insert_headers: The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        pulumi.set(__self__, "insert_headers", insert_headers)

    @property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleActionCaptchaCustomRequestHandlingInsertHeaderArgs']]]:
        """
        The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        return pulumi.get(self, "insert_headers")

    @insert_headers.setter
    def insert_headers(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleActionCaptchaCustomRequestHandlingInsertHeaderArgs']]]):
        pulumi.set(self, "insert_headers", value)


if not MYPY:
    class WebAclRuleActionCaptchaCustomRequestHandlingInsertHeaderArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        """
        value: pulumi.Input[str]
        """
        Value of the custom header.
        """
elif False:
    WebAclRuleActionCaptchaCustomRequestHandlingInsertHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleActionCaptchaCustomRequestHandlingInsertHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        :param pulumi.Input[str] value: Value of the custom header.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value of the custom header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class WebAclRuleActionChallengeArgsDict(TypedDict):
        custom_request_handling: NotRequired[pulumi.Input['WebAclRuleActionChallengeCustomRequestHandlingArgsDict']]
        """
        Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
elif False:
    WebAclRuleActionChallengeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleActionChallengeArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['WebAclRuleActionChallengeCustomRequestHandlingArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleActionChallengeCustomRequestHandlingArgs'] custom_request_handling: Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['WebAclRuleActionChallengeCustomRequestHandlingArgs']]:
        """
        Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['WebAclRuleActionChallengeCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


if not MYPY:
    class WebAclRuleActionChallengeCustomRequestHandlingArgsDict(TypedDict):
        insert_headers: pulumi.Input[Sequence[pulumi.Input['WebAclRuleActionChallengeCustomRequestHandlingInsertHeaderArgsDict']]]
        """
        The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
elif False:
    WebAclRuleActionChallengeCustomRequestHandlingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleActionChallengeCustomRequestHandlingArgs:
    def __init__(__self__, *,
                 insert_headers: pulumi.Input[Sequence[pulumi.Input['WebAclRuleActionChallengeCustomRequestHandlingInsertHeaderArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleActionChallengeCustomRequestHandlingInsertHeaderArgs']]] insert_headers: The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        pulumi.set(__self__, "insert_headers", insert_headers)

    @property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleActionChallengeCustomRequestHandlingInsertHeaderArgs']]]:
        """
        The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        return pulumi.get(self, "insert_headers")

    @insert_headers.setter
    def insert_headers(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleActionChallengeCustomRequestHandlingInsertHeaderArgs']]]):
        pulumi.set(self, "insert_headers", value)


if not MYPY:
    class WebAclRuleActionChallengeCustomRequestHandlingInsertHeaderArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        """
        value: pulumi.Input[str]
        """
        Value of the custom header.
        """
elif False:
    WebAclRuleActionChallengeCustomRequestHandlingInsertHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleActionChallengeCustomRequestHandlingInsertHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        :param pulumi.Input[str] value: Value of the custom header.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value of the custom header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class WebAclRuleActionCountArgsDict(TypedDict):
        custom_request_handling: NotRequired[pulumi.Input['WebAclRuleActionCountCustomRequestHandlingArgsDict']]
        """
        Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
elif False:
    WebAclRuleActionCountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleActionCountArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['WebAclRuleActionCountCustomRequestHandlingArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleActionCountCustomRequestHandlingArgs'] custom_request_handling: Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['WebAclRuleActionCountCustomRequestHandlingArgs']]:
        """
        Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['WebAclRuleActionCountCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


if not MYPY:
    class WebAclRuleActionCountCustomRequestHandlingArgsDict(TypedDict):
        insert_headers: pulumi.Input[Sequence[pulumi.Input['WebAclRuleActionCountCustomRequestHandlingInsertHeaderArgsDict']]]
        """
        The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
elif False:
    WebAclRuleActionCountCustomRequestHandlingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleActionCountCustomRequestHandlingArgs:
    def __init__(__self__, *,
                 insert_headers: pulumi.Input[Sequence[pulumi.Input['WebAclRuleActionCountCustomRequestHandlingInsertHeaderArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleActionCountCustomRequestHandlingInsertHeaderArgs']]] insert_headers: The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        pulumi.set(__self__, "insert_headers", insert_headers)

    @property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleActionCountCustomRequestHandlingInsertHeaderArgs']]]:
        """
        The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        return pulumi.get(self, "insert_headers")

    @insert_headers.setter
    def insert_headers(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleActionCountCustomRequestHandlingInsertHeaderArgs']]]):
        pulumi.set(self, "insert_headers", value)


if not MYPY:
    class WebAclRuleActionCountCustomRequestHandlingInsertHeaderArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        """
        value: pulumi.Input[str]
        """
        Value of the custom header.
        """
elif False:
    WebAclRuleActionCountCustomRequestHandlingInsertHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleActionCountCustomRequestHandlingInsertHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        :param pulumi.Input[str] value: Value of the custom header.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value of the custom header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class WebAclRuleCaptchaConfigArgsDict(TypedDict):
        immunity_time_property: NotRequired[pulumi.Input['WebAclRuleCaptchaConfigImmunityTimePropertyArgsDict']]
        """
        Defines custom immunity time. See `immunity_time_property` below for details.
        """
elif False:
    WebAclRuleCaptchaConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleCaptchaConfigArgs:
    def __init__(__self__, *,
                 immunity_time_property: Optional[pulumi.Input['WebAclRuleCaptchaConfigImmunityTimePropertyArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleCaptchaConfigImmunityTimePropertyArgs'] immunity_time_property: Defines custom immunity time. See `immunity_time_property` below for details.
        """
        if immunity_time_property is not None:
            pulumi.set(__self__, "immunity_time_property", immunity_time_property)

    @property
    @pulumi.getter(name="immunityTimeProperty")
    def immunity_time_property(self) -> Optional[pulumi.Input['WebAclRuleCaptchaConfigImmunityTimePropertyArgs']]:
        """
        Defines custom immunity time. See `immunity_time_property` below for details.
        """
        return pulumi.get(self, "immunity_time_property")

    @immunity_time_property.setter
    def immunity_time_property(self, value: Optional[pulumi.Input['WebAclRuleCaptchaConfigImmunityTimePropertyArgs']]):
        pulumi.set(self, "immunity_time_property", value)


if not MYPY:
    class WebAclRuleCaptchaConfigImmunityTimePropertyArgsDict(TypedDict):
        immunity_time: NotRequired[pulumi.Input[int]]
        """
        The amount of time, in seconds, that a CAPTCHA or challenge timestamp is considered valid by AWS WAF. The default setting is 300.
        """
elif False:
    WebAclRuleCaptchaConfigImmunityTimePropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleCaptchaConfigImmunityTimePropertyArgs:
    def __init__(__self__, *,
                 immunity_time: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] immunity_time: The amount of time, in seconds, that a CAPTCHA or challenge timestamp is considered valid by AWS WAF. The default setting is 300.
        """
        if immunity_time is not None:
            pulumi.set(__self__, "immunity_time", immunity_time)

    @property
    @pulumi.getter(name="immunityTime")
    def immunity_time(self) -> Optional[pulumi.Input[int]]:
        """
        The amount of time, in seconds, that a CAPTCHA or challenge timestamp is considered valid by AWS WAF. The default setting is 300.
        """
        return pulumi.get(self, "immunity_time")

    @immunity_time.setter
    def immunity_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "immunity_time", value)


if not MYPY:
    class WebAclRuleOverrideActionArgsDict(TypedDict):
        count: NotRequired[pulumi.Input['WebAclRuleOverrideActionCountArgsDict']]
        """
        Override the rule action setting to count (i.e., only count matches). Configured as an empty block `{}`.
        """
        none: NotRequired[pulumi.Input['WebAclRuleOverrideActionNoneArgsDict']]
        """
        Don't override the rule action setting. Configured as an empty block `{}`.
        """
elif False:
    WebAclRuleOverrideActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleOverrideActionArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input['WebAclRuleOverrideActionCountArgs']] = None,
                 none: Optional[pulumi.Input['WebAclRuleOverrideActionNoneArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleOverrideActionCountArgs'] count: Override the rule action setting to count (i.e., only count matches). Configured as an empty block `{}`.
        :param pulumi.Input['WebAclRuleOverrideActionNoneArgs'] none: Don't override the rule action setting. Configured as an empty block `{}`.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if none is not None:
            pulumi.set(__self__, "none", none)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input['WebAclRuleOverrideActionCountArgs']]:
        """
        Override the rule action setting to count (i.e., only count matches). Configured as an empty block `{}`.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input['WebAclRuleOverrideActionCountArgs']]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def none(self) -> Optional[pulumi.Input['WebAclRuleOverrideActionNoneArgs']]:
        """
        Don't override the rule action setting. Configured as an empty block `{}`.
        """
        return pulumi.get(self, "none")

    @none.setter
    def none(self, value: Optional[pulumi.Input['WebAclRuleOverrideActionNoneArgs']]):
        pulumi.set(self, "none", value)


if not MYPY:
    class WebAclRuleOverrideActionCountArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleOverrideActionCountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleOverrideActionCountArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleOverrideActionNoneArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleOverrideActionNoneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleOverrideActionNoneArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleRuleLabelArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Label string.
        """
elif False:
    WebAclRuleRuleLabelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleRuleLabelArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Label string.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Label string.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementArgsDict(TypedDict):
        and_statement: NotRequired[pulumi.Input['WebAclRuleStatementAndStatementArgsDict']]
        """
        Logical rule statement used to combine other rule statements with AND logic. See `and_statement` below for details.
        """
        byte_match_statement: NotRequired[pulumi.Input['WebAclRuleStatementByteMatchStatementArgsDict']]
        """
        Rule statement that defines a string match search for AWS WAF to apply to web requests. See `byte_match_statement` below for details.
        """
        geo_match_statement: NotRequired[pulumi.Input['WebAclRuleStatementGeoMatchStatementArgsDict']]
        """
        Rule statement used to identify web requests based on country of origin. See `geo_match_statement` below for details.
        """
        ip_set_reference_statement: NotRequired[pulumi.Input['WebAclRuleStatementIpSetReferenceStatementArgsDict']]
        """
        Rule statement used to detect web requests coming from particular IP addresses or address ranges. See `ip_set_reference_statement` below for details.
        """
        label_match_statement: NotRequired[pulumi.Input['WebAclRuleStatementLabelMatchStatementArgsDict']]
        """
        Rule statement that defines a string match search against labels that have been added to the web request by rules that have already run in the web ACL. See `label_match_statement` below for details.
        """
        managed_rule_group_statement: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementArgsDict']]
        """
        Rule statement used to run the rules that are defined in a managed rule group.  This statement can not be nested. See `managed_rule_group_statement` below for details.
        """
        not_statement: NotRequired[pulumi.Input['WebAclRuleStatementNotStatementArgsDict']]
        """
        Logical rule statement used to negate the results of another rule statement. See `not_statement` below for details.
        """
        or_statement: NotRequired[pulumi.Input['WebAclRuleStatementOrStatementArgsDict']]
        """
        Logical rule statement used to combine other rule statements with OR logic. See `or_statement` below for details.
        """
        rate_based_statement: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementArgsDict']]
        """
        Rate-based rule tracks the rate of requests for each originating `IP address`, and triggers the rule action when the rate exceeds a limit that you specify on the number of requests in any `5-minute` time span. This statement can not be nested. See `rate_based_statement` below for details.
        """
        regex_match_statement: NotRequired[pulumi.Input['WebAclRuleStatementRegexMatchStatementArgsDict']]
        """
        Rule statement used to search web request components for a match against a single regular expression. See `regex_match_statement` below for details.
        """
        regex_pattern_set_reference_statement: NotRequired[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementArgsDict']]
        """
        Rule statement used to search web request components for matches with regular expressions. See `regex_pattern_set_reference_statement` below for details.
        """
        rule_group_reference_statement: NotRequired[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementArgsDict']]
        """
        Rule statement used to run the rules that are defined in an WAFv2 Rule Group. See `rule_group_reference_statement` below for details.
        """
        size_constraint_statement: NotRequired[pulumi.Input['WebAclRuleStatementSizeConstraintStatementArgsDict']]
        """
        Rule statement that compares a number of bytes against the size of a request component, using a comparison operator, such as greater than (>) or less than (<). See `size_constraint_statement` below for more details.
        """
        sqli_match_statement: NotRequired[pulumi.Input['WebAclRuleStatementSqliMatchStatementArgsDict']]
        """
        An SQL injection match condition identifies the part of web requests, such as the URI or the query string, that you want AWS WAF to inspect. See `sqli_match_statement` below for details.
        """
        xss_match_statement: NotRequired[pulumi.Input['WebAclRuleStatementXssMatchStatementArgsDict']]
        """
        Rule statement that defines a cross-site scripting (XSS) match search for AWS WAF to apply to web requests. See `xss_match_statement` below for details.
        """
elif False:
    WebAclRuleStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementArgs:
    def __init__(__self__, *,
                 and_statement: Optional[pulumi.Input['WebAclRuleStatementAndStatementArgs']] = None,
                 byte_match_statement: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementArgs']] = None,
                 geo_match_statement: Optional[pulumi.Input['WebAclRuleStatementGeoMatchStatementArgs']] = None,
                 ip_set_reference_statement: Optional[pulumi.Input['WebAclRuleStatementIpSetReferenceStatementArgs']] = None,
                 label_match_statement: Optional[pulumi.Input['WebAclRuleStatementLabelMatchStatementArgs']] = None,
                 managed_rule_group_statement: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementArgs']] = None,
                 not_statement: Optional[pulumi.Input['WebAclRuleStatementNotStatementArgs']] = None,
                 or_statement: Optional[pulumi.Input['WebAclRuleStatementOrStatementArgs']] = None,
                 rate_based_statement: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementArgs']] = None,
                 regex_match_statement: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementArgs']] = None,
                 regex_pattern_set_reference_statement: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementArgs']] = None,
                 rule_group_reference_statement: Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementArgs']] = None,
                 size_constraint_statement: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementArgs']] = None,
                 sqli_match_statement: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementArgs']] = None,
                 xss_match_statement: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementAndStatementArgs'] and_statement: Logical rule statement used to combine other rule statements with AND logic. See `and_statement` below for details.
        :param pulumi.Input['WebAclRuleStatementByteMatchStatementArgs'] byte_match_statement: Rule statement that defines a string match search for AWS WAF to apply to web requests. See `byte_match_statement` below for details.
        :param pulumi.Input['WebAclRuleStatementGeoMatchStatementArgs'] geo_match_statement: Rule statement used to identify web requests based on country of origin. See `geo_match_statement` below for details.
        :param pulumi.Input['WebAclRuleStatementIpSetReferenceStatementArgs'] ip_set_reference_statement: Rule statement used to detect web requests coming from particular IP addresses or address ranges. See `ip_set_reference_statement` below for details.
        :param pulumi.Input['WebAclRuleStatementLabelMatchStatementArgs'] label_match_statement: Rule statement that defines a string match search against labels that have been added to the web request by rules that have already run in the web ACL. See `label_match_statement` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementArgs'] managed_rule_group_statement: Rule statement used to run the rules that are defined in a managed rule group.  This statement can not be nested. See `managed_rule_group_statement` below for details.
        :param pulumi.Input['WebAclRuleStatementNotStatementArgs'] not_statement: Logical rule statement used to negate the results of another rule statement. See `not_statement` below for details.
        :param pulumi.Input['WebAclRuleStatementOrStatementArgs'] or_statement: Logical rule statement used to combine other rule statements with OR logic. See `or_statement` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementArgs'] rate_based_statement: Rate-based rule tracks the rate of requests for each originating `IP address`, and triggers the rule action when the rate exceeds a limit that you specify on the number of requests in any `5-minute` time span. This statement can not be nested. See `rate_based_statement` below for details.
        :param pulumi.Input['WebAclRuleStatementRegexMatchStatementArgs'] regex_match_statement: Rule statement used to search web request components for a match against a single regular expression. See `regex_match_statement` below for details.
        :param pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementArgs'] regex_pattern_set_reference_statement: Rule statement used to search web request components for matches with regular expressions. See `regex_pattern_set_reference_statement` below for details.
        :param pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementArgs'] rule_group_reference_statement: Rule statement used to run the rules that are defined in an WAFv2 Rule Group. See `rule_group_reference_statement` below for details.
        :param pulumi.Input['WebAclRuleStatementSizeConstraintStatementArgs'] size_constraint_statement: Rule statement that compares a number of bytes against the size of a request component, using a comparison operator, such as greater than (>) or less than (<). See `size_constraint_statement` below for more details.
        :param pulumi.Input['WebAclRuleStatementSqliMatchStatementArgs'] sqli_match_statement: An SQL injection match condition identifies the part of web requests, such as the URI or the query string, that you want AWS WAF to inspect. See `sqli_match_statement` below for details.
        :param pulumi.Input['WebAclRuleStatementXssMatchStatementArgs'] xss_match_statement: Rule statement that defines a cross-site scripting (XSS) match search for AWS WAF to apply to web requests. See `xss_match_statement` below for details.
        """
        if and_statement is not None:
            pulumi.set(__self__, "and_statement", and_statement)
        if byte_match_statement is not None:
            pulumi.set(__self__, "byte_match_statement", byte_match_statement)
        if geo_match_statement is not None:
            pulumi.set(__self__, "geo_match_statement", geo_match_statement)
        if ip_set_reference_statement is not None:
            pulumi.set(__self__, "ip_set_reference_statement", ip_set_reference_statement)
        if label_match_statement is not None:
            pulumi.set(__self__, "label_match_statement", label_match_statement)
        if managed_rule_group_statement is not None:
            pulumi.set(__self__, "managed_rule_group_statement", managed_rule_group_statement)
        if not_statement is not None:
            pulumi.set(__self__, "not_statement", not_statement)
        if or_statement is not None:
            pulumi.set(__self__, "or_statement", or_statement)
        if rate_based_statement is not None:
            pulumi.set(__self__, "rate_based_statement", rate_based_statement)
        if regex_match_statement is not None:
            pulumi.set(__self__, "regex_match_statement", regex_match_statement)
        if regex_pattern_set_reference_statement is not None:
            pulumi.set(__self__, "regex_pattern_set_reference_statement", regex_pattern_set_reference_statement)
        if rule_group_reference_statement is not None:
            pulumi.set(__self__, "rule_group_reference_statement", rule_group_reference_statement)
        if size_constraint_statement is not None:
            pulumi.set(__self__, "size_constraint_statement", size_constraint_statement)
        if sqli_match_statement is not None:
            pulumi.set(__self__, "sqli_match_statement", sqli_match_statement)
        if xss_match_statement is not None:
            pulumi.set(__self__, "xss_match_statement", xss_match_statement)

    @property
    @pulumi.getter(name="andStatement")
    def and_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementAndStatementArgs']]:
        """
        Logical rule statement used to combine other rule statements with AND logic. See `and_statement` below for details.
        """
        return pulumi.get(self, "and_statement")

    @and_statement.setter
    def and_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementAndStatementArgs']]):
        pulumi.set(self, "and_statement", value)

    @property
    @pulumi.getter(name="byteMatchStatement")
    def byte_match_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementArgs']]:
        """
        Rule statement that defines a string match search for AWS WAF to apply to web requests. See `byte_match_statement` below for details.
        """
        return pulumi.get(self, "byte_match_statement")

    @byte_match_statement.setter
    def byte_match_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementArgs']]):
        pulumi.set(self, "byte_match_statement", value)

    @property
    @pulumi.getter(name="geoMatchStatement")
    def geo_match_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementGeoMatchStatementArgs']]:
        """
        Rule statement used to identify web requests based on country of origin. See `geo_match_statement` below for details.
        """
        return pulumi.get(self, "geo_match_statement")

    @geo_match_statement.setter
    def geo_match_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementGeoMatchStatementArgs']]):
        pulumi.set(self, "geo_match_statement", value)

    @property
    @pulumi.getter(name="ipSetReferenceStatement")
    def ip_set_reference_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementIpSetReferenceStatementArgs']]:
        """
        Rule statement used to detect web requests coming from particular IP addresses or address ranges. See `ip_set_reference_statement` below for details.
        """
        return pulumi.get(self, "ip_set_reference_statement")

    @ip_set_reference_statement.setter
    def ip_set_reference_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementIpSetReferenceStatementArgs']]):
        pulumi.set(self, "ip_set_reference_statement", value)

    @property
    @pulumi.getter(name="labelMatchStatement")
    def label_match_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementLabelMatchStatementArgs']]:
        """
        Rule statement that defines a string match search against labels that have been added to the web request by rules that have already run in the web ACL. See `label_match_statement` below for details.
        """
        return pulumi.get(self, "label_match_statement")

    @label_match_statement.setter
    def label_match_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementLabelMatchStatementArgs']]):
        pulumi.set(self, "label_match_statement", value)

    @property
    @pulumi.getter(name="managedRuleGroupStatement")
    def managed_rule_group_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementArgs']]:
        """
        Rule statement used to run the rules that are defined in a managed rule group.  This statement can not be nested. See `managed_rule_group_statement` below for details.
        """
        return pulumi.get(self, "managed_rule_group_statement")

    @managed_rule_group_statement.setter
    def managed_rule_group_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementArgs']]):
        pulumi.set(self, "managed_rule_group_statement", value)

    @property
    @pulumi.getter(name="notStatement")
    def not_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementNotStatementArgs']]:
        """
        Logical rule statement used to negate the results of another rule statement. See `not_statement` below for details.
        """
        return pulumi.get(self, "not_statement")

    @not_statement.setter
    def not_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementNotStatementArgs']]):
        pulumi.set(self, "not_statement", value)

    @property
    @pulumi.getter(name="orStatement")
    def or_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementOrStatementArgs']]:
        """
        Logical rule statement used to combine other rule statements with OR logic. See `or_statement` below for details.
        """
        return pulumi.get(self, "or_statement")

    @or_statement.setter
    def or_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementOrStatementArgs']]):
        pulumi.set(self, "or_statement", value)

    @property
    @pulumi.getter(name="rateBasedStatement")
    def rate_based_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementArgs']]:
        """
        Rate-based rule tracks the rate of requests for each originating `IP address`, and triggers the rule action when the rate exceeds a limit that you specify on the number of requests in any `5-minute` time span. This statement can not be nested. See `rate_based_statement` below for details.
        """
        return pulumi.get(self, "rate_based_statement")

    @rate_based_statement.setter
    def rate_based_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementArgs']]):
        pulumi.set(self, "rate_based_statement", value)

    @property
    @pulumi.getter(name="regexMatchStatement")
    def regex_match_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementArgs']]:
        """
        Rule statement used to search web request components for a match against a single regular expression. See `regex_match_statement` below for details.
        """
        return pulumi.get(self, "regex_match_statement")

    @regex_match_statement.setter
    def regex_match_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementArgs']]):
        pulumi.set(self, "regex_match_statement", value)

    @property
    @pulumi.getter(name="regexPatternSetReferenceStatement")
    def regex_pattern_set_reference_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementArgs']]:
        """
        Rule statement used to search web request components for matches with regular expressions. See `regex_pattern_set_reference_statement` below for details.
        """
        return pulumi.get(self, "regex_pattern_set_reference_statement")

    @regex_pattern_set_reference_statement.setter
    def regex_pattern_set_reference_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementArgs']]):
        pulumi.set(self, "regex_pattern_set_reference_statement", value)

    @property
    @pulumi.getter(name="ruleGroupReferenceStatement")
    def rule_group_reference_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementArgs']]:
        """
        Rule statement used to run the rules that are defined in an WAFv2 Rule Group. See `rule_group_reference_statement` below for details.
        """
        return pulumi.get(self, "rule_group_reference_statement")

    @rule_group_reference_statement.setter
    def rule_group_reference_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementArgs']]):
        pulumi.set(self, "rule_group_reference_statement", value)

    @property
    @pulumi.getter(name="sizeConstraintStatement")
    def size_constraint_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementArgs']]:
        """
        Rule statement that compares a number of bytes against the size of a request component, using a comparison operator, such as greater than (>) or less than (<). See `size_constraint_statement` below for more details.
        """
        return pulumi.get(self, "size_constraint_statement")

    @size_constraint_statement.setter
    def size_constraint_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementArgs']]):
        pulumi.set(self, "size_constraint_statement", value)

    @property
    @pulumi.getter(name="sqliMatchStatement")
    def sqli_match_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementArgs']]:
        """
        An SQL injection match condition identifies the part of web requests, such as the URI or the query string, that you want AWS WAF to inspect. See `sqli_match_statement` below for details.
        """
        return pulumi.get(self, "sqli_match_statement")

    @sqli_match_statement.setter
    def sqli_match_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementArgs']]):
        pulumi.set(self, "sqli_match_statement", value)

    @property
    @pulumi.getter(name="xssMatchStatement")
    def xss_match_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementArgs']]:
        """
        Rule statement that defines a cross-site scripting (XSS) match search for AWS WAF to apply to web requests. See `xss_match_statement` below for details.
        """
        return pulumi.get(self, "xss_match_statement")

    @xss_match_statement.setter
    def xss_match_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementArgs']]):
        pulumi.set(self, "xss_match_statement", value)


if not MYPY:
    class WebAclRuleStatementAndStatementArgsDict(TypedDict):
        statements: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgsDict']]]
        """
        The statements to combine.
        """
elif False:
    WebAclRuleStatementAndStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementAndStatementArgs:
    def __init__(__self__, *,
                 statements: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]] statements: The statements to combine.
        """
        pulumi.set(__self__, "statements", statements)

    @property
    @pulumi.getter
    def statements(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")

    @statements.setter
    def statements(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]):
        pulumi.set(self, "statements", value)


if not MYPY:
    class WebAclRuleStatementByteMatchStatementArgsDict(TypedDict):
        positional_constraint: pulumi.Input[str]
        """
        Area within the portion of a web request that you want AWS WAF to search for `search_string`. Valid values include the following: `EXACTLY`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CONTAINS_WORD`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_ByteMatchStatement.html) for more information.
        """
        search_string: pulumi.Input[str]
        """
        String value that you want AWS WAF to search for. AWS WAF searches only in the part of web requests that you designate for inspection in `field_to_match`. The maximum length of the value is 50 bytes.
        """
        text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementByteMatchStatementTextTransformationArgsDict']]]
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        field_to_match: NotRequired[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchArgsDict']]
        """
        Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
elif False:
    WebAclRuleStatementByteMatchStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementByteMatchStatementArgs:
    def __init__(__self__, *,
                 positional_constraint: pulumi.Input[str],
                 search_string: pulumi.Input[str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementByteMatchStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchArgs']] = None):
        """
        :param pulumi.Input[str] positional_constraint: Area within the portion of a web request that you want AWS WAF to search for `search_string`. Valid values include the following: `EXACTLY`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CONTAINS_WORD`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_ByteMatchStatement.html) for more information.
        :param pulumi.Input[str] search_string: String value that you want AWS WAF to search for. AWS WAF searches only in the part of web requests that you designate for inspection in `field_to_match`. The maximum length of the value is 50 bytes.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementByteMatchStatementTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        :param pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchArgs'] field_to_match: Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        pulumi.set(__self__, "positional_constraint", positional_constraint)
        pulumi.set(__self__, "search_string", search_string)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @property
    @pulumi.getter(name="positionalConstraint")
    def positional_constraint(self) -> pulumi.Input[str]:
        """
        Area within the portion of a web request that you want AWS WAF to search for `search_string`. Valid values include the following: `EXACTLY`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CONTAINS_WORD`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_ByteMatchStatement.html) for more information.
        """
        return pulumi.get(self, "positional_constraint")

    @positional_constraint.setter
    def positional_constraint(self, value: pulumi.Input[str]):
        pulumi.set(self, "positional_constraint", value)

    @property
    @pulumi.getter(name="searchString")
    def search_string(self) -> pulumi.Input[str]:
        """
        String value that you want AWS WAF to search for. AWS WAF searches only in the part of web requests that you designate for inspection in `field_to_match`. The maximum length of the value is 50 bytes.
        """
        return pulumi.get(self, "search_string")

    @search_string.setter
    def search_string(self, value: pulumi.Input[str]):
        pulumi.set(self, "search_string", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementByteMatchStatementTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementByteMatchStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchArgs']]:
        """
        Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


if not MYPY:
    class WebAclRuleStatementByteMatchStatementFieldToMatchArgsDict(TypedDict):
        all_query_arguments: NotRequired[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgsDict']]
        """
        Inspect all query arguments.
        """
        body: NotRequired[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchBodyArgsDict']]
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        cookies: NotRequired[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchCookiesArgsDict']]
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        header_orders: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchHeaderOrderArgsDict']]]]
        """
        Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchHeaderArgsDict']]]]
        """
        Inspect the request headers. See `headers` below for details.
        """
        ja3_fingerprint: NotRequired[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchJa3FingerprintArgsDict']]
        """
        Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        """
        json_body: NotRequired[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyArgsDict']]
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        method: NotRequired[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchMethodArgsDict']]
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        query_string: NotRequired[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchQueryStringArgsDict']]
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        single_header: NotRequired[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchSingleHeaderArgsDict']]
        """
        Inspect a single header. See `single_header` below for details.
        """
        single_query_argument: NotRequired[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgsDict']]
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        uri_path: NotRequired[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchUriPathArgsDict']]
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
elif False:
    WebAclRuleStatementByteMatchStatementFieldToMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementByteMatchStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchJa3FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_path: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchUriPathArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs'] all_query_arguments: Inspect all query arguments.
        :param pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchBodyArgs'] body: Inspect the request body, which immediately follows the request headers. See `body` below for details.
        :param pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchCookiesArgs'] cookies: Inspect the cookies in the web request. See `cookies` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchHeaderOrderArgs']]] header_orders: Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchHeaderArgs']]] headers: Inspect the request headers. See `headers` below for details.
        :param pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchJa3FingerprintArgs'] ja3_fingerprint: Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        :param pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyArgs'] json_body: Inspect the request body as JSON. See `json_body` for details.
        :param pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchMethodArgs'] method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchQueryStringArgs'] query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchSingleHeaderArgs'] single_header: Inspect a single header. See `single_header` below for details.
        :param pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs'] single_query_argument: Inspect a single query argument. See `single_query_argument` below for details.
        :param pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchUriPathArgs'] uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs']]:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchBodyArgs']]:
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchCookiesArgs']]:
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchHeaderOrderArgs']]]]:
        """
        Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        """
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchHeaderArgs']]]]:
        """
        Inspect the request headers. See `headers` below for details.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchJa3FingerprintArgs']]:
        """
        Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        """
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyArgs']]:
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchMethodArgs']]:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchQueryStringArgs']]:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchSingleHeaderArgs']]:
        """
        Inspect a single header. See `single_header` below for details.
        """
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs']]:
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchUriPathArgs']]:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


if not MYPY:
    class WebAclRuleStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementByteMatchStatementFieldToMatchBodyArgsDict(TypedDict):
        oversize_handling: NotRequired[pulumi.Input[str]]
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementByteMatchStatementFieldToMatchBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementByteMatchStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] oversize_handling: What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementByteMatchStatementFieldToMatchCookiesArgsDict(TypedDict):
        match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgsDict']]]
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        oversize_handling: pulumi.Input[str]
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementByteMatchStatementFieldToMatchCookiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementByteMatchStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs']]] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param pulumi.Input[str] match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs']]]:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        excluded_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        included_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_cookies", value)


if not MYPY:
    class WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementByteMatchStatementFieldToMatchHeaderArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgsDict']
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        oversize_handling: pulumi.Input[str]
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
elif False:
    WebAclRuleStatementByteMatchStatementFieldToMatchHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementByteMatchStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs'] match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param pulumi.Input[str] match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs']:
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        excluded_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        included_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
elif False:
    WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_headers", value)


if not MYPY:
    class WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementByteMatchStatementFieldToMatchHeaderOrderArgsDict(TypedDict):
        oversize_handling: pulumi.Input[str]
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
elif False:
    WebAclRuleStatementByteMatchStatementFieldToMatchHeaderOrderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementByteMatchStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementByteMatchStatementFieldToMatchJa3FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[str]
        """
        The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementByteMatchStatementFieldToMatchJa3FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementByteMatchStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict']
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        invalid_fallback_behavior: NotRequired[pulumi.Input[str]]
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        oversize_handling: NotRequired[pulumi.Input[str]]
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 invalid_fallback_behavior: Optional[pulumi.Input[str]] = None,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs'] match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param pulumi.Input[str] match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param pulumi.Input[str] invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param pulumi.Input[str] oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs']:
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        included_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_paths", value)


if not MYPY:
    class WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementByteMatchStatementFieldToMatchMethodArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementByteMatchStatementFieldToMatchMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementByteMatchStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementByteMatchStatementFieldToMatchQueryStringArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementByteMatchStatementFieldToMatchQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementByteMatchStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementByteMatchStatementFieldToMatchSingleHeaderArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
elif False:
    WebAclRuleStatementByteMatchStatementFieldToMatchSingleHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementByteMatchStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
elif False:
    WebAclRuleStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementByteMatchStatementFieldToMatchUriPathArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementByteMatchStatementFieldToMatchUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementByteMatchStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementByteMatchStatementTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[int]
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        type: pulumi.Input[str]
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
elif False:
    WebAclRuleStatementByteMatchStatementTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementByteMatchStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class WebAclRuleStatementGeoMatchStatementArgsDict(TypedDict):
        country_codes: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Array of two-character country codes, for example, [ "US", "CN" ], from the alpha-2 country ISO codes of the `ISO 3166` international standard. See the [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_GeoMatchStatement.html) for valid values.
        """
        forwarded_ip_config: NotRequired[pulumi.Input['WebAclRuleStatementGeoMatchStatementForwardedIpConfigArgsDict']]
        """
        Configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See `forwarded_ip_config` below for details.
        """
elif False:
    WebAclRuleStatementGeoMatchStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementGeoMatchStatementArgs:
    def __init__(__self__, *,
                 country_codes: pulumi.Input[Sequence[pulumi.Input[str]]],
                 forwarded_ip_config: Optional[pulumi.Input['WebAclRuleStatementGeoMatchStatementForwardedIpConfigArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] country_codes: Array of two-character country codes, for example, [ "US", "CN" ], from the alpha-2 country ISO codes of the `ISO 3166` international standard. See the [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_GeoMatchStatement.html) for valid values.
        :param pulumi.Input['WebAclRuleStatementGeoMatchStatementForwardedIpConfigArgs'] forwarded_ip_config: Configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See `forwarded_ip_config` below for details.
        """
        pulumi.set(__self__, "country_codes", country_codes)
        if forwarded_ip_config is not None:
            pulumi.set(__self__, "forwarded_ip_config", forwarded_ip_config)

    @property
    @pulumi.getter(name="countryCodes")
    def country_codes(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Array of two-character country codes, for example, [ "US", "CN" ], from the alpha-2 country ISO codes of the `ISO 3166` international standard. See the [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_GeoMatchStatement.html) for valid values.
        """
        return pulumi.get(self, "country_codes")

    @country_codes.setter
    def country_codes(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "country_codes", value)

    @property
    @pulumi.getter(name="forwardedIpConfig")
    def forwarded_ip_config(self) -> Optional[pulumi.Input['WebAclRuleStatementGeoMatchStatementForwardedIpConfigArgs']]:
        """
        Configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See `forwarded_ip_config` below for details.
        """
        return pulumi.get(self, "forwarded_ip_config")

    @forwarded_ip_config.setter
    def forwarded_ip_config(self, value: Optional[pulumi.Input['WebAclRuleStatementGeoMatchStatementForwardedIpConfigArgs']]):
        pulumi.set(self, "forwarded_ip_config", value)


if not MYPY:
    class WebAclRuleStatementGeoMatchStatementForwardedIpConfigArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[str]
        """
        Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        header_name: pulumi.Input[str]
        """
        Name of the HTTP header to use for the IP address.
        """
elif False:
    WebAclRuleStatementGeoMatchStatementForwardedIpConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementGeoMatchStatementForwardedIpConfigArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str],
                 header_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        :param pulumi.Input[str] header_name: Name of the HTTP header to use for the IP address.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> pulumi.Input[str]:
        """
        Name of the HTTP header to use for the IP address.
        """
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "header_name", value)


if not MYPY:
    class WebAclRuleStatementIpSetReferenceStatementArgsDict(TypedDict):
        arn: pulumi.Input[str]
        """
        The Amazon Resource Name (ARN) of the IP Set that this statement references.
        """
        ip_set_forwarded_ip_config: NotRequired[pulumi.Input['WebAclRuleStatementIpSetReferenceStatementIpSetForwardedIpConfigArgsDict']]
        """
        Configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See `ip_set_forwarded_ip_config` below for more details.
        """
elif False:
    WebAclRuleStatementIpSetReferenceStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementIpSetReferenceStatementArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[str],
                 ip_set_forwarded_ip_config: Optional[pulumi.Input['WebAclRuleStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs']] = None):
        """
        :param pulumi.Input[str] arn: The Amazon Resource Name (ARN) of the IP Set that this statement references.
        :param pulumi.Input['WebAclRuleStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs'] ip_set_forwarded_ip_config: Configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See `ip_set_forwarded_ip_config` below for more details.
        """
        pulumi.set(__self__, "arn", arn)
        if ip_set_forwarded_ip_config is not None:
            pulumi.set(__self__, "ip_set_forwarded_ip_config", ip_set_forwarded_ip_config)

    @property
    @pulumi.getter
    def arn(self) -> pulumi.Input[str]:
        """
        The Amazon Resource Name (ARN) of the IP Set that this statement references.
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "arn", value)

    @property
    @pulumi.getter(name="ipSetForwardedIpConfig")
    def ip_set_forwarded_ip_config(self) -> Optional[pulumi.Input['WebAclRuleStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs']]:
        """
        Configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See `ip_set_forwarded_ip_config` below for more details.
        """
        return pulumi.get(self, "ip_set_forwarded_ip_config")

    @ip_set_forwarded_ip_config.setter
    def ip_set_forwarded_ip_config(self, value: Optional[pulumi.Input['WebAclRuleStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs']]):
        pulumi.set(self, "ip_set_forwarded_ip_config", value)


if not MYPY:
    class WebAclRuleStatementIpSetReferenceStatementIpSetForwardedIpConfigArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[str]
        """
        Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        header_name: pulumi.Input[str]
        """
        Name of the HTTP header to use for the IP address.
        """
        position: pulumi.Input[str]
        """
        Position in the header to search for the IP address. Valid values include: `FIRST`, `LAST`, or `ANY`. If `ANY` is specified and the header contains more than 10 IP addresses, AWS WAFv2 inspects the last 10.
        """
elif False:
    WebAclRuleStatementIpSetReferenceStatementIpSetForwardedIpConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str],
                 header_name: pulumi.Input[str],
                 position: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        :param pulumi.Input[str] header_name: Name of the HTTP header to use for the IP address.
        :param pulumi.Input[str] position: Position in the header to search for the IP address. Valid values include: `FIRST`, `LAST`, or `ANY`. If `ANY` is specified and the header contains more than 10 IP addresses, AWS WAFv2 inspects the last 10.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "position", position)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> pulumi.Input[str]:
        """
        Name of the HTTP header to use for the IP address.
        """
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "header_name", value)

    @property
    @pulumi.getter
    def position(self) -> pulumi.Input[str]:
        """
        Position in the header to search for the IP address. Valid values include: `FIRST`, `LAST`, or `ANY`. If `ANY` is specified and the header contains more than 10 IP addresses, AWS WAFv2 inspects the last 10.
        """
        return pulumi.get(self, "position")

    @position.setter
    def position(self, value: pulumi.Input[str]):
        pulumi.set(self, "position", value)


if not MYPY:
    class WebAclRuleStatementLabelMatchStatementArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        String to match against.
        """
        scope: pulumi.Input[str]
        """
        Specify whether you want to match using the label name or just the namespace. Valid values are `LABEL` or `NAMESPACE`.
        """
elif False:
    WebAclRuleStatementLabelMatchStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementLabelMatchStatementArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 scope: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: String to match against.
        :param pulumi.Input[str] scope: Specify whether you want to match using the label name or just the namespace. Valid values are `LABEL` or `NAMESPACE`.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        String to match against.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def scope(self) -> pulumi.Input[str]:
        """
        Specify whether you want to match using the label name or just the namespace. Valid values are `LABEL` or `NAMESPACE`.
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "scope", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the managed rule group.
        """
        vendor_name: pulumi.Input[str]
        """
        Name of the managed rule group vendor.
        """
        managed_rule_group_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigArgsDict']]]]
        """
        Additional information that's used by a managed rule group. Only one rule attribute is allowed in each config. See `managed_rule_group_configs` for more details
        """
        rule_action_overrides: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideArgsDict']]]]
        """
        Action settings to use in the place of the rule actions that are configured inside the rule group. You specify one override for each rule whose action you want to change. See `rule_action_override` below for details.
        """
        scope_down_statement: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementArgsDict']]
        """
        Narrows the scope of the statement to matching web requests. This can be any nestable statement, and you can nest statements at any level below this scope-down statement. See `statement` above for details.
        """
        version: NotRequired[pulumi.Input[str]]
        """
        Version of the managed rule group. You can set `Version_1.0` or `Version_1.1` etc. If you want to use the default version, do not set anything.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 vendor_name: pulumi.Input[str],
                 managed_rule_group_configs: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigArgs']]]] = None,
                 rule_action_overrides: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideArgs']]]] = None,
                 scope_down_statement: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementArgs']] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the managed rule group.
        :param pulumi.Input[str] vendor_name: Name of the managed rule group vendor.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigArgs']]] managed_rule_group_configs: Additional information that's used by a managed rule group. Only one rule attribute is allowed in each config. See `managed_rule_group_configs` for more details
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideArgs']]] rule_action_overrides: Action settings to use in the place of the rule actions that are configured inside the rule group. You specify one override for each rule whose action you want to change. See `rule_action_override` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementArgs'] scope_down_statement: Narrows the scope of the statement to matching web requests. This can be any nestable statement, and you can nest statements at any level below this scope-down statement. See `statement` above for details.
        :param pulumi.Input[str] version: Version of the managed rule group. You can set `Version_1.0` or `Version_1.1` etc. If you want to use the default version, do not set anything.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "vendor_name", vendor_name)
        if managed_rule_group_configs is not None:
            pulumi.set(__self__, "managed_rule_group_configs", managed_rule_group_configs)
        if rule_action_overrides is not None:
            pulumi.set(__self__, "rule_action_overrides", rule_action_overrides)
        if scope_down_statement is not None:
            pulumi.set(__self__, "scope_down_statement", scope_down_statement)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the managed rule group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="vendorName")
    def vendor_name(self) -> pulumi.Input[str]:
        """
        Name of the managed rule group vendor.
        """
        return pulumi.get(self, "vendor_name")

    @vendor_name.setter
    def vendor_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "vendor_name", value)

    @property
    @pulumi.getter(name="managedRuleGroupConfigs")
    def managed_rule_group_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigArgs']]]]:
        """
        Additional information that's used by a managed rule group. Only one rule attribute is allowed in each config. See `managed_rule_group_configs` for more details
        """
        return pulumi.get(self, "managed_rule_group_configs")

    @managed_rule_group_configs.setter
    def managed_rule_group_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigArgs']]]]):
        pulumi.set(self, "managed_rule_group_configs", value)

    @property
    @pulumi.getter(name="ruleActionOverrides")
    def rule_action_overrides(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideArgs']]]]:
        """
        Action settings to use in the place of the rule actions that are configured inside the rule group. You specify one override for each rule whose action you want to change. See `rule_action_override` below for details.
        """
        return pulumi.get(self, "rule_action_overrides")

    @rule_action_overrides.setter
    def rule_action_overrides(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideArgs']]]]):
        pulumi.set(self, "rule_action_overrides", value)

    @property
    @pulumi.getter(name="scopeDownStatement")
    def scope_down_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementArgs']]:
        """
        Narrows the scope of the statement to matching web requests. This can be any nestable statement, and you can nest statements at any level below this scope-down statement. See `statement` above for details.
        """
        return pulumi.get(self, "scope_down_statement")

    @scope_down_statement.setter
    def scope_down_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementArgs']]):
        pulumi.set(self, "scope_down_statement", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Version of the managed rule group. You can set `Version_1.0` or `Version_1.1` etc. If you want to use the default version, do not set anything.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigArgsDict(TypedDict):
        aws_managed_rules_acfp_rule_set: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetArgsDict']]
        """
        Additional configuration for using the Account Creation Fraud Prevention managed rule group. Use this to specify information such as the registration page of your application and the type of content to accept or reject from the client.
        """
        aws_managed_rules_atp_rule_set: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetArgsDict']]
        """
        Additional configuration for using the Account Takeover Protection managed rule group. Use this to specify information such as the sign-in page of your application and the type of content to accept or reject from the client.
        """
        aws_managed_rules_bot_control_rule_set: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesBotControlRuleSetArgsDict']]
        """
        Additional configuration for using the Bot Control managed rule group. Use this to specify the inspection level that you want to use. See `aws_managed_rules_bot_control_rule_set` for more details
        """
        login_path: NotRequired[pulumi.Input[str]]
        """
        The path of the login endpoint for your application.
        """
        password_field: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigPasswordFieldArgsDict']]
        """
        Details about your login page password field. See `password_field` for more details.
        """
        payload_type: NotRequired[pulumi.Input[str]]
        """
        The payload type for your login endpoint, either JSON or form encoded.
        """
        username_field: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigUsernameFieldArgsDict']]
        """
        Details about your login page username field. See `username_field` for more details.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigArgs:
    def __init__(__self__, *,
                 aws_managed_rules_acfp_rule_set: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetArgs']] = None,
                 aws_managed_rules_atp_rule_set: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetArgs']] = None,
                 aws_managed_rules_bot_control_rule_set: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesBotControlRuleSetArgs']] = None,
                 login_path: Optional[pulumi.Input[str]] = None,
                 password_field: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigPasswordFieldArgs']] = None,
                 payload_type: Optional[pulumi.Input[str]] = None,
                 username_field: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigUsernameFieldArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetArgs'] aws_managed_rules_acfp_rule_set: Additional configuration for using the Account Creation Fraud Prevention managed rule group. Use this to specify information such as the registration page of your application and the type of content to accept or reject from the client.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetArgs'] aws_managed_rules_atp_rule_set: Additional configuration for using the Account Takeover Protection managed rule group. Use this to specify information such as the sign-in page of your application and the type of content to accept or reject from the client.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesBotControlRuleSetArgs'] aws_managed_rules_bot_control_rule_set: Additional configuration for using the Bot Control managed rule group. Use this to specify the inspection level that you want to use. See `aws_managed_rules_bot_control_rule_set` for more details
        :param pulumi.Input[str] login_path: The path of the login endpoint for your application.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigPasswordFieldArgs'] password_field: Details about your login page password field. See `password_field` for more details.
        :param pulumi.Input[str] payload_type: The payload type for your login endpoint, either JSON or form encoded.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigUsernameFieldArgs'] username_field: Details about your login page username field. See `username_field` for more details.
        """
        if aws_managed_rules_acfp_rule_set is not None:
            pulumi.set(__self__, "aws_managed_rules_acfp_rule_set", aws_managed_rules_acfp_rule_set)
        if aws_managed_rules_atp_rule_set is not None:
            pulumi.set(__self__, "aws_managed_rules_atp_rule_set", aws_managed_rules_atp_rule_set)
        if aws_managed_rules_bot_control_rule_set is not None:
            pulumi.set(__self__, "aws_managed_rules_bot_control_rule_set", aws_managed_rules_bot_control_rule_set)
        if login_path is not None:
            pulumi.set(__self__, "login_path", login_path)
        if password_field is not None:
            pulumi.set(__self__, "password_field", password_field)
        if payload_type is not None:
            pulumi.set(__self__, "payload_type", payload_type)
        if username_field is not None:
            pulumi.set(__self__, "username_field", username_field)

    @property
    @pulumi.getter(name="awsManagedRulesAcfpRuleSet")
    def aws_managed_rules_acfp_rule_set(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetArgs']]:
        """
        Additional configuration for using the Account Creation Fraud Prevention managed rule group. Use this to specify information such as the registration page of your application and the type of content to accept or reject from the client.
        """
        return pulumi.get(self, "aws_managed_rules_acfp_rule_set")

    @aws_managed_rules_acfp_rule_set.setter
    def aws_managed_rules_acfp_rule_set(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetArgs']]):
        pulumi.set(self, "aws_managed_rules_acfp_rule_set", value)

    @property
    @pulumi.getter(name="awsManagedRulesAtpRuleSet")
    def aws_managed_rules_atp_rule_set(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetArgs']]:
        """
        Additional configuration for using the Account Takeover Protection managed rule group. Use this to specify information such as the sign-in page of your application and the type of content to accept or reject from the client.
        """
        return pulumi.get(self, "aws_managed_rules_atp_rule_set")

    @aws_managed_rules_atp_rule_set.setter
    def aws_managed_rules_atp_rule_set(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetArgs']]):
        pulumi.set(self, "aws_managed_rules_atp_rule_set", value)

    @property
    @pulumi.getter(name="awsManagedRulesBotControlRuleSet")
    def aws_managed_rules_bot_control_rule_set(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesBotControlRuleSetArgs']]:
        """
        Additional configuration for using the Bot Control managed rule group. Use this to specify the inspection level that you want to use. See `aws_managed_rules_bot_control_rule_set` for more details
        """
        return pulumi.get(self, "aws_managed_rules_bot_control_rule_set")

    @aws_managed_rules_bot_control_rule_set.setter
    def aws_managed_rules_bot_control_rule_set(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesBotControlRuleSetArgs']]):
        pulumi.set(self, "aws_managed_rules_bot_control_rule_set", value)

    @property
    @pulumi.getter(name="loginPath")
    def login_path(self) -> Optional[pulumi.Input[str]]:
        """
        The path of the login endpoint for your application.
        """
        return pulumi.get(self, "login_path")

    @login_path.setter
    def login_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "login_path", value)

    @property
    @pulumi.getter(name="passwordField")
    def password_field(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigPasswordFieldArgs']]:
        """
        Details about your login page password field. See `password_field` for more details.
        """
        return pulumi.get(self, "password_field")

    @password_field.setter
    def password_field(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigPasswordFieldArgs']]):
        pulumi.set(self, "password_field", value)

    @property
    @pulumi.getter(name="payloadType")
    def payload_type(self) -> Optional[pulumi.Input[str]]:
        """
        The payload type for your login endpoint, either JSON or form encoded.
        """
        return pulumi.get(self, "payload_type")

    @payload_type.setter
    def payload_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "payload_type", value)

    @property
    @pulumi.getter(name="usernameField")
    def username_field(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigUsernameFieldArgs']]:
        """
        Details about your login page username field. See `username_field` for more details.
        """
        return pulumi.get(self, "username_field")

    @username_field.setter
    def username_field(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigUsernameFieldArgs']]):
        pulumi.set(self, "username_field", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetArgsDict(TypedDict):
        creation_path: pulumi.Input[str]
        """
        The path of the account creation endpoint for your application. This is the page on your website that accepts the completed registration form for a new user. This page must accept POST requests.
        """
        registration_page_path: pulumi.Input[str]
        """
        The path of the account registration endpoint for your application. This is the page on your website that presents the registration form to new users. This page must accept GET text/html requests.
        """
        request_inspection: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionArgsDict']
        """
        The criteria for inspecting login requests, used by the ATP rule group to validate credentials usage. See `request_inspection` for more details.
        """
        enable_regex_in_path: NotRequired[pulumi.Input[bool]]
        """
        Whether or not to allow the use of regular expressions in the login page path.
        """
        response_inspection: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionArgsDict']]
        """
        The criteria for inspecting responses to login requests, used by the ATP rule group to track login failure rates. Note that Response Inspection is available only on web ACLs that protect CloudFront distributions. See `response_inspection` for more details.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetArgs:
    def __init__(__self__, *,
                 creation_path: pulumi.Input[str],
                 registration_page_path: pulumi.Input[str],
                 request_inspection: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionArgs'],
                 enable_regex_in_path: Optional[pulumi.Input[bool]] = None,
                 response_inspection: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionArgs']] = None):
        """
        :param pulumi.Input[str] creation_path: The path of the account creation endpoint for your application. This is the page on your website that accepts the completed registration form for a new user. This page must accept POST requests.
        :param pulumi.Input[str] registration_page_path: The path of the account registration endpoint for your application. This is the page on your website that presents the registration form to new users. This page must accept GET text/html requests.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionArgs'] request_inspection: The criteria for inspecting login requests, used by the ATP rule group to validate credentials usage. See `request_inspection` for more details.
        :param pulumi.Input[bool] enable_regex_in_path: Whether or not to allow the use of regular expressions in the login page path.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionArgs'] response_inspection: The criteria for inspecting responses to login requests, used by the ATP rule group to track login failure rates. Note that Response Inspection is available only on web ACLs that protect CloudFront distributions. See `response_inspection` for more details.
        """
        pulumi.set(__self__, "creation_path", creation_path)
        pulumi.set(__self__, "registration_page_path", registration_page_path)
        pulumi.set(__self__, "request_inspection", request_inspection)
        if enable_regex_in_path is not None:
            pulumi.set(__self__, "enable_regex_in_path", enable_regex_in_path)
        if response_inspection is not None:
            pulumi.set(__self__, "response_inspection", response_inspection)

    @property
    @pulumi.getter(name="creationPath")
    def creation_path(self) -> pulumi.Input[str]:
        """
        The path of the account creation endpoint for your application. This is the page on your website that accepts the completed registration form for a new user. This page must accept POST requests.
        """
        return pulumi.get(self, "creation_path")

    @creation_path.setter
    def creation_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "creation_path", value)

    @property
    @pulumi.getter(name="registrationPagePath")
    def registration_page_path(self) -> pulumi.Input[str]:
        """
        The path of the account registration endpoint for your application. This is the page on your website that presents the registration form to new users. This page must accept GET text/html requests.
        """
        return pulumi.get(self, "registration_page_path")

    @registration_page_path.setter
    def registration_page_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "registration_page_path", value)

    @property
    @pulumi.getter(name="requestInspection")
    def request_inspection(self) -> pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionArgs']:
        """
        The criteria for inspecting login requests, used by the ATP rule group to validate credentials usage. See `request_inspection` for more details.
        """
        return pulumi.get(self, "request_inspection")

    @request_inspection.setter
    def request_inspection(self, value: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionArgs']):
        pulumi.set(self, "request_inspection", value)

    @property
    @pulumi.getter(name="enableRegexInPath")
    def enable_regex_in_path(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not to allow the use of regular expressions in the login page path.
        """
        return pulumi.get(self, "enable_regex_in_path")

    @enable_regex_in_path.setter
    def enable_regex_in_path(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_regex_in_path", value)

    @property
    @pulumi.getter(name="responseInspection")
    def response_inspection(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionArgs']]:
        """
        The criteria for inspecting responses to login requests, used by the ATP rule group to track login failure rates. Note that Response Inspection is available only on web ACLs that protect CloudFront distributions. See `response_inspection` for more details.
        """
        return pulumi.get(self, "response_inspection")

    @response_inspection.setter
    def response_inspection(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionArgs']]):
        pulumi.set(self, "response_inspection", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionArgsDict(TypedDict):
        payload_type: pulumi.Input[str]
        """
        The payload type for your login endpoint, either JSON or form encoded.
        """
        address_fields: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionAddressFieldsArgsDict']]
        """
        The names of the fields in the request payload that contain your customer's primary physical address. See `address_fields` for more details.
        """
        email_field: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionEmailFieldArgsDict']]
        """
        The name of the field in the request payload that contains your customer's email. See `email_field` for more details.
        """
        password_field: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionPasswordFieldArgsDict']]
        """
        Details about your login page password field. See `password_field` for more details.
        """
        phone_number_fields: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionPhoneNumberFieldsArgsDict']]
        """
        The names of the fields in the request payload that contain your customer's primary phone number. See `phone_number_fields` for more details.
        """
        username_field: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionUsernameFieldArgsDict']]
        """
        Details about your login page username field. See `username_field` for more details.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionArgs:
    def __init__(__self__, *,
                 payload_type: pulumi.Input[str],
                 address_fields: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionAddressFieldsArgs']] = None,
                 email_field: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionEmailFieldArgs']] = None,
                 password_field: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionPasswordFieldArgs']] = None,
                 phone_number_fields: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionPhoneNumberFieldsArgs']] = None,
                 username_field: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionUsernameFieldArgs']] = None):
        """
        :param pulumi.Input[str] payload_type: The payload type for your login endpoint, either JSON or form encoded.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionAddressFieldsArgs'] address_fields: The names of the fields in the request payload that contain your customer's primary physical address. See `address_fields` for more details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionEmailFieldArgs'] email_field: The name of the field in the request payload that contains your customer's email. See `email_field` for more details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionPasswordFieldArgs'] password_field: Details about your login page password field. See `password_field` for more details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionPhoneNumberFieldsArgs'] phone_number_fields: The names of the fields in the request payload that contain your customer's primary phone number. See `phone_number_fields` for more details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionUsernameFieldArgs'] username_field: Details about your login page username field. See `username_field` for more details.
        """
        pulumi.set(__self__, "payload_type", payload_type)
        if address_fields is not None:
            pulumi.set(__self__, "address_fields", address_fields)
        if email_field is not None:
            pulumi.set(__self__, "email_field", email_field)
        if password_field is not None:
            pulumi.set(__self__, "password_field", password_field)
        if phone_number_fields is not None:
            pulumi.set(__self__, "phone_number_fields", phone_number_fields)
        if username_field is not None:
            pulumi.set(__self__, "username_field", username_field)

    @property
    @pulumi.getter(name="payloadType")
    def payload_type(self) -> pulumi.Input[str]:
        """
        The payload type for your login endpoint, either JSON or form encoded.
        """
        return pulumi.get(self, "payload_type")

    @payload_type.setter
    def payload_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "payload_type", value)

    @property
    @pulumi.getter(name="addressFields")
    def address_fields(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionAddressFieldsArgs']]:
        """
        The names of the fields in the request payload that contain your customer's primary physical address. See `address_fields` for more details.
        """
        return pulumi.get(self, "address_fields")

    @address_fields.setter
    def address_fields(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionAddressFieldsArgs']]):
        pulumi.set(self, "address_fields", value)

    @property
    @pulumi.getter(name="emailField")
    def email_field(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionEmailFieldArgs']]:
        """
        The name of the field in the request payload that contains your customer's email. See `email_field` for more details.
        """
        return pulumi.get(self, "email_field")

    @email_field.setter
    def email_field(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionEmailFieldArgs']]):
        pulumi.set(self, "email_field", value)

    @property
    @pulumi.getter(name="passwordField")
    def password_field(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionPasswordFieldArgs']]:
        """
        Details about your login page password field. See `password_field` for more details.
        """
        return pulumi.get(self, "password_field")

    @password_field.setter
    def password_field(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionPasswordFieldArgs']]):
        pulumi.set(self, "password_field", value)

    @property
    @pulumi.getter(name="phoneNumberFields")
    def phone_number_fields(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionPhoneNumberFieldsArgs']]:
        """
        The names of the fields in the request payload that contain your customer's primary phone number. See `phone_number_fields` for more details.
        """
        return pulumi.get(self, "phone_number_fields")

    @phone_number_fields.setter
    def phone_number_fields(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionPhoneNumberFieldsArgs']]):
        pulumi.set(self, "phone_number_fields", value)

    @property
    @pulumi.getter(name="usernameField")
    def username_field(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionUsernameFieldArgs']]:
        """
        Details about your login page username field. See `username_field` for more details.
        """
        return pulumi.get(self, "username_field")

    @username_field.setter
    def username_field(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionUsernameFieldArgs']]):
        pulumi.set(self, "username_field", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionAddressFieldsArgsDict(TypedDict):
        identifiers: pulumi.Input[Sequence[pulumi.Input[str]]]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionAddressFieldsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionAddressFieldsArgs:
    def __init__(__self__, *,
                 identifiers: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(__self__, "identifiers", identifiers)

    @property
    @pulumi.getter
    def identifiers(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "identifiers")

    @identifiers.setter
    def identifiers(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "identifiers", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionEmailFieldArgsDict(TypedDict):
        identifier: pulumi.Input[str]
        """
        The name of the field in the request payload that contains your customer's email.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionEmailFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionEmailFieldArgs:
    def __init__(__self__, *,
                 identifier: pulumi.Input[str]):
        """
        :param pulumi.Input[str] identifier: The name of the field in the request payload that contains your customer's email.
        """
        pulumi.set(__self__, "identifier", identifier)

    @property
    @pulumi.getter
    def identifier(self) -> pulumi.Input[str]:
        """
        The name of the field in the request payload that contains your customer's email.
        """
        return pulumi.get(self, "identifier")

    @identifier.setter
    def identifier(self, value: pulumi.Input[str]):
        pulumi.set(self, "identifier", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionPasswordFieldArgsDict(TypedDict):
        identifier: pulumi.Input[str]
        """
        The name of the password field.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionPasswordFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionPasswordFieldArgs:
    def __init__(__self__, *,
                 identifier: pulumi.Input[str]):
        """
        :param pulumi.Input[str] identifier: The name of the password field.
        """
        pulumi.set(__self__, "identifier", identifier)

    @property
    @pulumi.getter
    def identifier(self) -> pulumi.Input[str]:
        """
        The name of the password field.
        """
        return pulumi.get(self, "identifier")

    @identifier.setter
    def identifier(self, value: pulumi.Input[str]):
        pulumi.set(self, "identifier", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionPhoneNumberFieldsArgsDict(TypedDict):
        identifiers: pulumi.Input[Sequence[pulumi.Input[str]]]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionPhoneNumberFieldsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionPhoneNumberFieldsArgs:
    def __init__(__self__, *,
                 identifiers: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(__self__, "identifiers", identifiers)

    @property
    @pulumi.getter
    def identifiers(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "identifiers")

    @identifiers.setter
    def identifiers(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "identifiers", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionUsernameFieldArgsDict(TypedDict):
        identifier: pulumi.Input[str]
        """
        The name of the username field.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionUsernameFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionUsernameFieldArgs:
    def __init__(__self__, *,
                 identifier: pulumi.Input[str]):
        """
        :param pulumi.Input[str] identifier: The name of the username field.
        """
        pulumi.set(__self__, "identifier", identifier)

    @property
    @pulumi.getter
    def identifier(self) -> pulumi.Input[str]:
        """
        The name of the username field.
        """
        return pulumi.get(self, "identifier")

    @identifier.setter
    def identifier(self, value: pulumi.Input[str]):
        pulumi.set(self, "identifier", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionArgsDict(TypedDict):
        body_contains: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionBodyContainsArgsDict']]
        """
        Configures inspection of the response body. See `body_contains` for more details.
        """
        header: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionHeaderArgsDict']]
        """
        Configures inspection of the response header.See `header` for more details.
        """
        json: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionJsonArgsDict']]
        """
        Configures inspection of the response JSON. See `json` for more details.
        """
        status_code: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionStatusCodeArgsDict']]
        """
        Configures inspection of the response status code.See `status_code` for more details.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionArgs:
    def __init__(__self__, *,
                 body_contains: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionBodyContainsArgs']] = None,
                 header: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionHeaderArgs']] = None,
                 json: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionJsonArgs']] = None,
                 status_code: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionStatusCodeArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionBodyContainsArgs'] body_contains: Configures inspection of the response body. See `body_contains` for more details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionHeaderArgs'] header: Configures inspection of the response header.See `header` for more details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionJsonArgs'] json: Configures inspection of the response JSON. See `json` for more details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionStatusCodeArgs'] status_code: Configures inspection of the response status code.See `status_code` for more details.
        """
        if body_contains is not None:
            pulumi.set(__self__, "body_contains", body_contains)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if json is not None:
            pulumi.set(__self__, "json", json)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)

    @property
    @pulumi.getter(name="bodyContains")
    def body_contains(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionBodyContainsArgs']]:
        """
        Configures inspection of the response body. See `body_contains` for more details.
        """
        return pulumi.get(self, "body_contains")

    @body_contains.setter
    def body_contains(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionBodyContainsArgs']]):
        pulumi.set(self, "body_contains", value)

    @property
    @pulumi.getter
    def header(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionHeaderArgs']]:
        """
        Configures inspection of the response header.See `header` for more details.
        """
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionHeaderArgs']]):
        pulumi.set(self, "header", value)

    @property
    @pulumi.getter
    def json(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionJsonArgs']]:
        """
        Configures inspection of the response JSON. See `json` for more details.
        """
        return pulumi.get(self, "json")

    @json.setter
    def json(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionJsonArgs']]):
        pulumi.set(self, "json", value)

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionStatusCodeArgs']]:
        """
        Configures inspection of the response status code.See `status_code` for more details.
        """
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionStatusCodeArgs']]):
        pulumi.set(self, "status_code", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionBodyContainsArgsDict(TypedDict):
        failure_strings: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Strings in the body of the response that indicate a failed login attempt.
        """
        success_strings: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Strings in the body of the response that indicate a successful login attempt.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionBodyContainsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionBodyContainsArgs:
    def __init__(__self__, *,
                 failure_strings: pulumi.Input[Sequence[pulumi.Input[str]]],
                 success_strings: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] failure_strings: Strings in the body of the response that indicate a failed login attempt.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] success_strings: Strings in the body of the response that indicate a successful login attempt.
        """
        pulumi.set(__self__, "failure_strings", failure_strings)
        pulumi.set(__self__, "success_strings", success_strings)

    @property
    @pulumi.getter(name="failureStrings")
    def failure_strings(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Strings in the body of the response that indicate a failed login attempt.
        """
        return pulumi.get(self, "failure_strings")

    @failure_strings.setter
    def failure_strings(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "failure_strings", value)

    @property
    @pulumi.getter(name="successStrings")
    def success_strings(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Strings in the body of the response that indicate a successful login attempt.
        """
        return pulumi.get(self, "success_strings")

    @success_strings.setter
    def success_strings(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "success_strings", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionHeaderArgsDict(TypedDict):
        failure_values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Values in the response header with the specified name that indicate a failed login attempt.
        """
        name: pulumi.Input[str]
        """
        The name of the header to use.
        """
        success_values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Values in the response header with the specified name that indicate a successful login attempt.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionHeaderArgs:
    def __init__(__self__, *,
                 failure_values: pulumi.Input[Sequence[pulumi.Input[str]]],
                 name: pulumi.Input[str],
                 success_values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] failure_values: Values in the response header with the specified name that indicate a failed login attempt.
        :param pulumi.Input[str] name: The name of the header to use.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] success_values: Values in the response header with the specified name that indicate a successful login attempt.
        """
        pulumi.set(__self__, "failure_values", failure_values)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "success_values", success_values)

    @property
    @pulumi.getter(name="failureValues")
    def failure_values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Values in the response header with the specified name that indicate a failed login attempt.
        """
        return pulumi.get(self, "failure_values")

    @failure_values.setter
    def failure_values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "failure_values", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the header to use.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="successValues")
    def success_values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Values in the response header with the specified name that indicate a successful login attempt.
        """
        return pulumi.get(self, "success_values")

    @success_values.setter
    def success_values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "success_values", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionJsonArgsDict(TypedDict):
        failure_values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Values in the response header with the specified name that indicate a failed login attempt.
        """
        identifier: pulumi.Input[str]
        """
        The identifier for the value to match against in the JSON.
        """
        success_values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Values in the response header with the specified name that indicate a successful login attempt.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionJsonArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionJsonArgs:
    def __init__(__self__, *,
                 failure_values: pulumi.Input[Sequence[pulumi.Input[str]]],
                 identifier: pulumi.Input[str],
                 success_values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] failure_values: Values in the response header with the specified name that indicate a failed login attempt.
        :param pulumi.Input[str] identifier: The identifier for the value to match against in the JSON.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] success_values: Values in the response header with the specified name that indicate a successful login attempt.
        """
        pulumi.set(__self__, "failure_values", failure_values)
        pulumi.set(__self__, "identifier", identifier)
        pulumi.set(__self__, "success_values", success_values)

    @property
    @pulumi.getter(name="failureValues")
    def failure_values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Values in the response header with the specified name that indicate a failed login attempt.
        """
        return pulumi.get(self, "failure_values")

    @failure_values.setter
    def failure_values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "failure_values", value)

    @property
    @pulumi.getter
    def identifier(self) -> pulumi.Input[str]:
        """
        The identifier for the value to match against in the JSON.
        """
        return pulumi.get(self, "identifier")

    @identifier.setter
    def identifier(self, value: pulumi.Input[str]):
        pulumi.set(self, "identifier", value)

    @property
    @pulumi.getter(name="successValues")
    def success_values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Values in the response header with the specified name that indicate a successful login attempt.
        """
        return pulumi.get(self, "success_values")

    @success_values.setter
    def success_values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "success_values", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionStatusCodeArgsDict(TypedDict):
        failure_codes: pulumi.Input[Sequence[pulumi.Input[int]]]
        """
        Status codes in the response that indicate a failed login attempt.
        """
        success_codes: pulumi.Input[Sequence[pulumi.Input[int]]]
        """
        Status codes in the response that indicate a successful login attempt.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionStatusCodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionStatusCodeArgs:
    def __init__(__self__, *,
                 failure_codes: pulumi.Input[Sequence[pulumi.Input[int]]],
                 success_codes: pulumi.Input[Sequence[pulumi.Input[int]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[int]]] failure_codes: Status codes in the response that indicate a failed login attempt.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] success_codes: Status codes in the response that indicate a successful login attempt.
        """
        pulumi.set(__self__, "failure_codes", failure_codes)
        pulumi.set(__self__, "success_codes", success_codes)

    @property
    @pulumi.getter(name="failureCodes")
    def failure_codes(self) -> pulumi.Input[Sequence[pulumi.Input[int]]]:
        """
        Status codes in the response that indicate a failed login attempt.
        """
        return pulumi.get(self, "failure_codes")

    @failure_codes.setter
    def failure_codes(self, value: pulumi.Input[Sequence[pulumi.Input[int]]]):
        pulumi.set(self, "failure_codes", value)

    @property
    @pulumi.getter(name="successCodes")
    def success_codes(self) -> pulumi.Input[Sequence[pulumi.Input[int]]]:
        """
        Status codes in the response that indicate a successful login attempt.
        """
        return pulumi.get(self, "success_codes")

    @success_codes.setter
    def success_codes(self, value: pulumi.Input[Sequence[pulumi.Input[int]]]):
        pulumi.set(self, "success_codes", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetArgsDict(TypedDict):
        login_path: pulumi.Input[str]
        """
        The path of the login endpoint for your application.
        """
        enable_regex_in_path: NotRequired[pulumi.Input[bool]]
        """
        Whether or not to allow the use of regular expressions in the login page path.
        """
        request_inspection: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionArgsDict']]
        """
        The criteria for inspecting login requests, used by the ATP rule group to validate credentials usage. See `request_inspection` for more details.
        """
        response_inspection: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionArgsDict']]
        """
        The criteria for inspecting responses to login requests, used by the ATP rule group to track login failure rates. Note that Response Inspection is available only on web ACLs that protect CloudFront distributions. See `response_inspection` for more details.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetArgs:
    def __init__(__self__, *,
                 login_path: pulumi.Input[str],
                 enable_regex_in_path: Optional[pulumi.Input[bool]] = None,
                 request_inspection: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionArgs']] = None,
                 response_inspection: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionArgs']] = None):
        """
        :param pulumi.Input[str] login_path: The path of the login endpoint for your application.
        :param pulumi.Input[bool] enable_regex_in_path: Whether or not to allow the use of regular expressions in the login page path.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionArgs'] request_inspection: The criteria for inspecting login requests, used by the ATP rule group to validate credentials usage. See `request_inspection` for more details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionArgs'] response_inspection: The criteria for inspecting responses to login requests, used by the ATP rule group to track login failure rates. Note that Response Inspection is available only on web ACLs that protect CloudFront distributions. See `response_inspection` for more details.
        """
        pulumi.set(__self__, "login_path", login_path)
        if enable_regex_in_path is not None:
            pulumi.set(__self__, "enable_regex_in_path", enable_regex_in_path)
        if request_inspection is not None:
            pulumi.set(__self__, "request_inspection", request_inspection)
        if response_inspection is not None:
            pulumi.set(__self__, "response_inspection", response_inspection)

    @property
    @pulumi.getter(name="loginPath")
    def login_path(self) -> pulumi.Input[str]:
        """
        The path of the login endpoint for your application.
        """
        return pulumi.get(self, "login_path")

    @login_path.setter
    def login_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "login_path", value)

    @property
    @pulumi.getter(name="enableRegexInPath")
    def enable_regex_in_path(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not to allow the use of regular expressions in the login page path.
        """
        return pulumi.get(self, "enable_regex_in_path")

    @enable_regex_in_path.setter
    def enable_regex_in_path(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_regex_in_path", value)

    @property
    @pulumi.getter(name="requestInspection")
    def request_inspection(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionArgs']]:
        """
        The criteria for inspecting login requests, used by the ATP rule group to validate credentials usage. See `request_inspection` for more details.
        """
        return pulumi.get(self, "request_inspection")

    @request_inspection.setter
    def request_inspection(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionArgs']]):
        pulumi.set(self, "request_inspection", value)

    @property
    @pulumi.getter(name="responseInspection")
    def response_inspection(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionArgs']]:
        """
        The criteria for inspecting responses to login requests, used by the ATP rule group to track login failure rates. Note that Response Inspection is available only on web ACLs that protect CloudFront distributions. See `response_inspection` for more details.
        """
        return pulumi.get(self, "response_inspection")

    @response_inspection.setter
    def response_inspection(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionArgs']]):
        pulumi.set(self, "response_inspection", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionArgsDict(TypedDict):
        password_field: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionPasswordFieldArgsDict']
        """
        Details about your login page password field. See `password_field` for more details.
        """
        payload_type: pulumi.Input[str]
        """
        The payload type for your login endpoint, either JSON or form encoded.
        """
        username_field: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionUsernameFieldArgsDict']
        """
        Details about your login page username field. See `username_field` for more details.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionArgs:
    def __init__(__self__, *,
                 password_field: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionPasswordFieldArgs'],
                 payload_type: pulumi.Input[str],
                 username_field: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionUsernameFieldArgs']):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionPasswordFieldArgs'] password_field: Details about your login page password field. See `password_field` for more details.
        :param pulumi.Input[str] payload_type: The payload type for your login endpoint, either JSON or form encoded.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionUsernameFieldArgs'] username_field: Details about your login page username field. See `username_field` for more details.
        """
        pulumi.set(__self__, "password_field", password_field)
        pulumi.set(__self__, "payload_type", payload_type)
        pulumi.set(__self__, "username_field", username_field)

    @property
    @pulumi.getter(name="passwordField")
    def password_field(self) -> pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionPasswordFieldArgs']:
        """
        Details about your login page password field. See `password_field` for more details.
        """
        return pulumi.get(self, "password_field")

    @password_field.setter
    def password_field(self, value: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionPasswordFieldArgs']):
        pulumi.set(self, "password_field", value)

    @property
    @pulumi.getter(name="payloadType")
    def payload_type(self) -> pulumi.Input[str]:
        """
        The payload type for your login endpoint, either JSON or form encoded.
        """
        return pulumi.get(self, "payload_type")

    @payload_type.setter
    def payload_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "payload_type", value)

    @property
    @pulumi.getter(name="usernameField")
    def username_field(self) -> pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionUsernameFieldArgs']:
        """
        Details about your login page username field. See `username_field` for more details.
        """
        return pulumi.get(self, "username_field")

    @username_field.setter
    def username_field(self, value: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionUsernameFieldArgs']):
        pulumi.set(self, "username_field", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionPasswordFieldArgsDict(TypedDict):
        identifier: pulumi.Input[str]
        """
        The name of the password field.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionPasswordFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionPasswordFieldArgs:
    def __init__(__self__, *,
                 identifier: pulumi.Input[str]):
        """
        :param pulumi.Input[str] identifier: The name of the password field.
        """
        pulumi.set(__self__, "identifier", identifier)

    @property
    @pulumi.getter
    def identifier(self) -> pulumi.Input[str]:
        """
        The name of the password field.
        """
        return pulumi.get(self, "identifier")

    @identifier.setter
    def identifier(self, value: pulumi.Input[str]):
        pulumi.set(self, "identifier", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionUsernameFieldArgsDict(TypedDict):
        identifier: pulumi.Input[str]
        """
        The name of the username field.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionUsernameFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionUsernameFieldArgs:
    def __init__(__self__, *,
                 identifier: pulumi.Input[str]):
        """
        :param pulumi.Input[str] identifier: The name of the username field.
        """
        pulumi.set(__self__, "identifier", identifier)

    @property
    @pulumi.getter
    def identifier(self) -> pulumi.Input[str]:
        """
        The name of the username field.
        """
        return pulumi.get(self, "identifier")

    @identifier.setter
    def identifier(self, value: pulumi.Input[str]):
        pulumi.set(self, "identifier", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionArgsDict(TypedDict):
        body_contains: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionBodyContainsArgsDict']]
        """
        Configures inspection of the response body. See `body_contains` for more details.
        """
        header: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionHeaderArgsDict']]
        """
        Configures inspection of the response header.See `header` for more details.
        """
        json: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionJsonArgsDict']]
        """
        Configures inspection of the response JSON. See `json` for more details.
        """
        status_code: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionStatusCodeArgsDict']]
        """
        Configures inspection of the response status code.See `status_code` for more details.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionArgs:
    def __init__(__self__, *,
                 body_contains: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionBodyContainsArgs']] = None,
                 header: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionHeaderArgs']] = None,
                 json: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionJsonArgs']] = None,
                 status_code: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionStatusCodeArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionBodyContainsArgs'] body_contains: Configures inspection of the response body. See `body_contains` for more details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionHeaderArgs'] header: Configures inspection of the response header.See `header` for more details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionJsonArgs'] json: Configures inspection of the response JSON. See `json` for more details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionStatusCodeArgs'] status_code: Configures inspection of the response status code.See `status_code` for more details.
        """
        if body_contains is not None:
            pulumi.set(__self__, "body_contains", body_contains)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if json is not None:
            pulumi.set(__self__, "json", json)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)

    @property
    @pulumi.getter(name="bodyContains")
    def body_contains(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionBodyContainsArgs']]:
        """
        Configures inspection of the response body. See `body_contains` for more details.
        """
        return pulumi.get(self, "body_contains")

    @body_contains.setter
    def body_contains(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionBodyContainsArgs']]):
        pulumi.set(self, "body_contains", value)

    @property
    @pulumi.getter
    def header(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionHeaderArgs']]:
        """
        Configures inspection of the response header.See `header` for more details.
        """
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionHeaderArgs']]):
        pulumi.set(self, "header", value)

    @property
    @pulumi.getter
    def json(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionJsonArgs']]:
        """
        Configures inspection of the response JSON. See `json` for more details.
        """
        return pulumi.get(self, "json")

    @json.setter
    def json(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionJsonArgs']]):
        pulumi.set(self, "json", value)

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionStatusCodeArgs']]:
        """
        Configures inspection of the response status code.See `status_code` for more details.
        """
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionStatusCodeArgs']]):
        pulumi.set(self, "status_code", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionBodyContainsArgsDict(TypedDict):
        failure_strings: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Strings in the body of the response that indicate a failed login attempt.
        """
        success_strings: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Strings in the body of the response that indicate a successful login attempt.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionBodyContainsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionBodyContainsArgs:
    def __init__(__self__, *,
                 failure_strings: pulumi.Input[Sequence[pulumi.Input[str]]],
                 success_strings: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] failure_strings: Strings in the body of the response that indicate a failed login attempt.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] success_strings: Strings in the body of the response that indicate a successful login attempt.
        """
        pulumi.set(__self__, "failure_strings", failure_strings)
        pulumi.set(__self__, "success_strings", success_strings)

    @property
    @pulumi.getter(name="failureStrings")
    def failure_strings(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Strings in the body of the response that indicate a failed login attempt.
        """
        return pulumi.get(self, "failure_strings")

    @failure_strings.setter
    def failure_strings(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "failure_strings", value)

    @property
    @pulumi.getter(name="successStrings")
    def success_strings(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Strings in the body of the response that indicate a successful login attempt.
        """
        return pulumi.get(self, "success_strings")

    @success_strings.setter
    def success_strings(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "success_strings", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionHeaderArgsDict(TypedDict):
        failure_values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Values in the response header with the specified name that indicate a failed login attempt.
        """
        name: pulumi.Input[str]
        """
        The name of the header to use.
        """
        success_values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Values in the response header with the specified name that indicate a successful login attempt.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionHeaderArgs:
    def __init__(__self__, *,
                 failure_values: pulumi.Input[Sequence[pulumi.Input[str]]],
                 name: pulumi.Input[str],
                 success_values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] failure_values: Values in the response header with the specified name that indicate a failed login attempt.
        :param pulumi.Input[str] name: The name of the header to use.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] success_values: Values in the response header with the specified name that indicate a successful login attempt.
        """
        pulumi.set(__self__, "failure_values", failure_values)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "success_values", success_values)

    @property
    @pulumi.getter(name="failureValues")
    def failure_values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Values in the response header with the specified name that indicate a failed login attempt.
        """
        return pulumi.get(self, "failure_values")

    @failure_values.setter
    def failure_values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "failure_values", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the header to use.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="successValues")
    def success_values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Values in the response header with the specified name that indicate a successful login attempt.
        """
        return pulumi.get(self, "success_values")

    @success_values.setter
    def success_values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "success_values", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionJsonArgsDict(TypedDict):
        failure_values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Values in the response header with the specified name that indicate a failed login attempt.
        """
        identifier: pulumi.Input[str]
        """
        The identifier for the value to match against in the JSON.
        """
        success_values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Values in the response header with the specified name that indicate a successful login attempt.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionJsonArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionJsonArgs:
    def __init__(__self__, *,
                 failure_values: pulumi.Input[Sequence[pulumi.Input[str]]],
                 identifier: pulumi.Input[str],
                 success_values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] failure_values: Values in the response header with the specified name that indicate a failed login attempt.
        :param pulumi.Input[str] identifier: The identifier for the value to match against in the JSON.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] success_values: Values in the response header with the specified name that indicate a successful login attempt.
        """
        pulumi.set(__self__, "failure_values", failure_values)
        pulumi.set(__self__, "identifier", identifier)
        pulumi.set(__self__, "success_values", success_values)

    @property
    @pulumi.getter(name="failureValues")
    def failure_values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Values in the response header with the specified name that indicate a failed login attempt.
        """
        return pulumi.get(self, "failure_values")

    @failure_values.setter
    def failure_values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "failure_values", value)

    @property
    @pulumi.getter
    def identifier(self) -> pulumi.Input[str]:
        """
        The identifier for the value to match against in the JSON.
        """
        return pulumi.get(self, "identifier")

    @identifier.setter
    def identifier(self, value: pulumi.Input[str]):
        pulumi.set(self, "identifier", value)

    @property
    @pulumi.getter(name="successValues")
    def success_values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Values in the response header with the specified name that indicate a successful login attempt.
        """
        return pulumi.get(self, "success_values")

    @success_values.setter
    def success_values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "success_values", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionStatusCodeArgsDict(TypedDict):
        failure_codes: pulumi.Input[Sequence[pulumi.Input[int]]]
        """
        Status codes in the response that indicate a failed login attempt.
        """
        success_codes: pulumi.Input[Sequence[pulumi.Input[int]]]
        """
        Status codes in the response that indicate a successful login attempt.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionStatusCodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionStatusCodeArgs:
    def __init__(__self__, *,
                 failure_codes: pulumi.Input[Sequence[pulumi.Input[int]]],
                 success_codes: pulumi.Input[Sequence[pulumi.Input[int]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[int]]] failure_codes: Status codes in the response that indicate a failed login attempt.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] success_codes: Status codes in the response that indicate a successful login attempt.
        """
        pulumi.set(__self__, "failure_codes", failure_codes)
        pulumi.set(__self__, "success_codes", success_codes)

    @property
    @pulumi.getter(name="failureCodes")
    def failure_codes(self) -> pulumi.Input[Sequence[pulumi.Input[int]]]:
        """
        Status codes in the response that indicate a failed login attempt.
        """
        return pulumi.get(self, "failure_codes")

    @failure_codes.setter
    def failure_codes(self, value: pulumi.Input[Sequence[pulumi.Input[int]]]):
        pulumi.set(self, "failure_codes", value)

    @property
    @pulumi.getter(name="successCodes")
    def success_codes(self) -> pulumi.Input[Sequence[pulumi.Input[int]]]:
        """
        Status codes in the response that indicate a successful login attempt.
        """
        return pulumi.get(self, "success_codes")

    @success_codes.setter
    def success_codes(self, value: pulumi.Input[Sequence[pulumi.Input[int]]]):
        pulumi.set(self, "success_codes", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesBotControlRuleSetArgsDict(TypedDict):
        inspection_level: pulumi.Input[str]
        """
        The inspection level to use for the Bot Control rule group.
        """
        enable_machine_learning: NotRequired[pulumi.Input[bool]]
        """
        Applies only to the targeted inspection level. Determines whether to use machine learning (ML) to analyze your web traffic for bot-related activity. Defaults to `true`.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesBotControlRuleSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesBotControlRuleSetArgs:
    def __init__(__self__, *,
                 inspection_level: pulumi.Input[str],
                 enable_machine_learning: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] inspection_level: The inspection level to use for the Bot Control rule group.
        :param pulumi.Input[bool] enable_machine_learning: Applies only to the targeted inspection level. Determines whether to use machine learning (ML) to analyze your web traffic for bot-related activity. Defaults to `true`.
        """
        pulumi.set(__self__, "inspection_level", inspection_level)
        if enable_machine_learning is not None:
            pulumi.set(__self__, "enable_machine_learning", enable_machine_learning)

    @property
    @pulumi.getter(name="inspectionLevel")
    def inspection_level(self) -> pulumi.Input[str]:
        """
        The inspection level to use for the Bot Control rule group.
        """
        return pulumi.get(self, "inspection_level")

    @inspection_level.setter
    def inspection_level(self, value: pulumi.Input[str]):
        pulumi.set(self, "inspection_level", value)

    @property
    @pulumi.getter(name="enableMachineLearning")
    def enable_machine_learning(self) -> Optional[pulumi.Input[bool]]:
        """
        Applies only to the targeted inspection level. Determines whether to use machine learning (ML) to analyze your web traffic for bot-related activity. Defaults to `true`.
        """
        return pulumi.get(self, "enable_machine_learning")

    @enable_machine_learning.setter
    def enable_machine_learning(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_machine_learning", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigPasswordFieldArgsDict(TypedDict):
        identifier: pulumi.Input[str]
        """
        The name of the password field.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigPasswordFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigPasswordFieldArgs:
    def __init__(__self__, *,
                 identifier: pulumi.Input[str]):
        """
        :param pulumi.Input[str] identifier: The name of the password field.
        """
        pulumi.set(__self__, "identifier", identifier)

    @property
    @pulumi.getter
    def identifier(self) -> pulumi.Input[str]:
        """
        The name of the password field.
        """
        return pulumi.get(self, "identifier")

    @identifier.setter
    def identifier(self, value: pulumi.Input[str]):
        pulumi.set(self, "identifier", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigUsernameFieldArgsDict(TypedDict):
        identifier: pulumi.Input[str]
        """
        The name of the username field.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigUsernameFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigUsernameFieldArgs:
    def __init__(__self__, *,
                 identifier: pulumi.Input[str]):
        """
        :param pulumi.Input[str] identifier: The name of the username field.
        """
        pulumi.set(__self__, "identifier", identifier)

    @property
    @pulumi.getter
    def identifier(self) -> pulumi.Input[str]:
        """
        The name of the username field.
        """
        return pulumi.get(self, "identifier")

    @identifier.setter
    def identifier(self, value: pulumi.Input[str]):
        pulumi.set(self, "identifier", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideArgsDict(TypedDict):
        action_to_use: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseArgsDict']
        """
        Override action to use, in place of the configured action of the rule in the rule group. See `action` for details.
        """
        name: pulumi.Input[str]
        """
        Name of the rule to override. See the [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/aws-managed-rule-groups-list.html) for a list of names in the appropriate rule group in use.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideArgs:
    def __init__(__self__, *,
                 action_to_use: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseArgs'],
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseArgs'] action_to_use: Override action to use, in place of the configured action of the rule in the rule group. See `action` for details.
        :param pulumi.Input[str] name: Name of the rule to override. See the [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/aws-managed-rule-groups-list.html) for a list of names in the appropriate rule group in use.
        """
        pulumi.set(__self__, "action_to_use", action_to_use)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="actionToUse")
    def action_to_use(self) -> pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseArgs']:
        """
        Override action to use, in place of the configured action of the rule in the rule group. See `action` for details.
        """
        return pulumi.get(self, "action_to_use")

    @action_to_use.setter
    def action_to_use(self, value: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseArgs']):
        pulumi.set(self, "action_to_use", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the rule to override. See the [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/aws-managed-rule-groups-list.html) for a list of names in the appropriate rule group in use.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseArgsDict(TypedDict):
        allow: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowArgsDict']]
        block: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockArgsDict']]
        captcha: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaArgsDict']]
        """
        Instructs AWS WAF to run a Captcha check against the web request. See `captcha` below for details.
        """
        challenge: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeArgsDict']]
        """
        Instructs AWS WAF to run a check against the request to verify that the request is coming from a legitimate client session. See `challenge` below for details.
        """
        count: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountArgsDict']]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseArgs:
    def __init__(__self__, *,
                 allow: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowArgs']] = None,
                 block: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockArgs']] = None,
                 captcha: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaArgs']] = None,
                 challenge: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeArgs']] = None,
                 count: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaArgs'] captcha: Instructs AWS WAF to run a Captcha check against the web request. See `captcha` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeArgs'] challenge: Instructs AWS WAF to run a check against the request to verify that the request is coming from a legitimate client session. See `challenge` below for details.
        """
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if block is not None:
            pulumi.set(__self__, "block", block)
        if captcha is not None:
            pulumi.set(__self__, "captcha", captcha)
        if challenge is not None:
            pulumi.set(__self__, "challenge", challenge)
        if count is not None:
            pulumi.set(__self__, "count", count)

    @property
    @pulumi.getter
    def allow(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowArgs']]:
        return pulumi.get(self, "allow")

    @allow.setter
    def allow(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowArgs']]):
        pulumi.set(self, "allow", value)

    @property
    @pulumi.getter
    def block(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockArgs']]:
        return pulumi.get(self, "block")

    @block.setter
    def block(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockArgs']]):
        pulumi.set(self, "block", value)

    @property
    @pulumi.getter
    def captcha(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaArgs']]:
        """
        Instructs AWS WAF to run a Captcha check against the web request. See `captcha` below for details.
        """
        return pulumi.get(self, "captcha")

    @captcha.setter
    def captcha(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaArgs']]):
        pulumi.set(self, "captcha", value)

    @property
    @pulumi.getter
    def challenge(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeArgs']]:
        """
        Instructs AWS WAF to run a check against the request to verify that the request is coming from a legitimate client session. See `challenge` below for details.
        """
        return pulumi.get(self, "challenge")

    @challenge.setter
    def challenge(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeArgs']]):
        pulumi.set(self, "challenge", value)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountArgs']]:
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountArgs']]):
        pulumi.set(self, "count", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowArgsDict(TypedDict):
        custom_request_handling: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingArgsDict']]
        """
        Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingArgs'] custom_request_handling: Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingArgs']]:
        """
        Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingArgsDict(TypedDict):
        insert_headers: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeaderArgsDict']]]
        """
        The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingArgs:
    def __init__(__self__, *,
                 insert_headers: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeaderArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeaderArgs']]] insert_headers: The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        pulumi.set(__self__, "insert_headers", insert_headers)

    @property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeaderArgs']]]:
        """
        The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        return pulumi.get(self, "insert_headers")

    @insert_headers.setter
    def insert_headers(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeaderArgs']]]):
        pulumi.set(self, "insert_headers", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeaderArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        """
        value: pulumi.Input[str]
        """
        Value of the custom header.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        :param pulumi.Input[str] value: Value of the custom header.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value of the custom header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockArgsDict(TypedDict):
        custom_response: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponseArgsDict']]
        """
        Defines a custom response for the web request. See `custom_response` below for details.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockArgs:
    def __init__(__self__, *,
                 custom_response: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponseArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponseArgs'] custom_response: Defines a custom response for the web request. See `custom_response` below for details.
        """
        if custom_response is not None:
            pulumi.set(__self__, "custom_response", custom_response)

    @property
    @pulumi.getter(name="customResponse")
    def custom_response(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponseArgs']]:
        """
        Defines a custom response for the web request. See `custom_response` below for details.
        """
        return pulumi.get(self, "custom_response")

    @custom_response.setter
    def custom_response(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponseArgs']]):
        pulumi.set(self, "custom_response", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponseArgsDict(TypedDict):
        response_code: pulumi.Input[int]
        """
        The HTTP status code to return to the client.
        """
        custom_response_body_key: NotRequired[pulumi.Input[str]]
        """
        References the response body that you want AWS WAF to return to the web request client. This must reference a `key` defined in a `custom_response_body` block of this resource.
        """
        response_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeaderArgsDict']]]]
        """
        The `response_header` blocks used to define the HTTP response headers added to the response. See `response_header` below for details.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponseArgs:
    def __init__(__self__, *,
                 response_code: pulumi.Input[int],
                 custom_response_body_key: Optional[pulumi.Input[str]] = None,
                 response_headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeaderArgs']]]] = None):
        """
        :param pulumi.Input[int] response_code: The HTTP status code to return to the client.
        :param pulumi.Input[str] custom_response_body_key: References the response body that you want AWS WAF to return to the web request client. This must reference a `key` defined in a `custom_response_body` block of this resource.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeaderArgs']]] response_headers: The `response_header` blocks used to define the HTTP response headers added to the response. See `response_header` below for details.
        """
        pulumi.set(__self__, "response_code", response_code)
        if custom_response_body_key is not None:
            pulumi.set(__self__, "custom_response_body_key", custom_response_body_key)
        if response_headers is not None:
            pulumi.set(__self__, "response_headers", response_headers)

    @property
    @pulumi.getter(name="responseCode")
    def response_code(self) -> pulumi.Input[int]:
        """
        The HTTP status code to return to the client.
        """
        return pulumi.get(self, "response_code")

    @response_code.setter
    def response_code(self, value: pulumi.Input[int]):
        pulumi.set(self, "response_code", value)

    @property
    @pulumi.getter(name="customResponseBodyKey")
    def custom_response_body_key(self) -> Optional[pulumi.Input[str]]:
        """
        References the response body that you want AWS WAF to return to the web request client. This must reference a `key` defined in a `custom_response_body` block of this resource.
        """
        return pulumi.get(self, "custom_response_body_key")

    @custom_response_body_key.setter
    def custom_response_body_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_response_body_key", value)

    @property
    @pulumi.getter(name="responseHeaders")
    def response_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeaderArgs']]]]:
        """
        The `response_header` blocks used to define the HTTP response headers added to the response. See `response_header` below for details.
        """
        return pulumi.get(self, "response_headers")

    @response_headers.setter
    def response_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeaderArgs']]]]):
        pulumi.set(self, "response_headers", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeaderArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        """
        value: pulumi.Input[str]
        """
        Value of the custom header.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        :param pulumi.Input[str] value: Value of the custom header.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value of the custom header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaArgsDict(TypedDict):
        custom_request_handling: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingArgsDict']]
        """
        Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingArgs'] custom_request_handling: Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingArgs']]:
        """
        Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingArgsDict(TypedDict):
        insert_headers: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeaderArgsDict']]]
        """
        The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingArgs:
    def __init__(__self__, *,
                 insert_headers: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeaderArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeaderArgs']]] insert_headers: The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        pulumi.set(__self__, "insert_headers", insert_headers)

    @property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeaderArgs']]]:
        """
        The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        return pulumi.get(self, "insert_headers")

    @insert_headers.setter
    def insert_headers(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeaderArgs']]]):
        pulumi.set(self, "insert_headers", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeaderArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        """
        value: pulumi.Input[str]
        """
        Value of the custom header.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        :param pulumi.Input[str] value: Value of the custom header.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value of the custom header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeArgsDict(TypedDict):
        custom_request_handling: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingArgsDict']]
        """
        Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingArgs'] custom_request_handling: Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingArgs']]:
        """
        Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingArgsDict(TypedDict):
        insert_headers: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeaderArgsDict']]]
        """
        The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingArgs:
    def __init__(__self__, *,
                 insert_headers: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeaderArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeaderArgs']]] insert_headers: The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        pulumi.set(__self__, "insert_headers", insert_headers)

    @property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeaderArgs']]]:
        """
        The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        return pulumi.get(self, "insert_headers")

    @insert_headers.setter
    def insert_headers(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeaderArgs']]]):
        pulumi.set(self, "insert_headers", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeaderArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        """
        value: pulumi.Input[str]
        """
        Value of the custom header.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        :param pulumi.Input[str] value: Value of the custom header.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value of the custom header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountArgsDict(TypedDict):
        custom_request_handling: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandlingArgsDict']]
        """
        Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandlingArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandlingArgs'] custom_request_handling: Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandlingArgs']]:
        """
        Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandlingArgsDict(TypedDict):
        insert_headers: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeaderArgsDict']]]
        """
        The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandlingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandlingArgs:
    def __init__(__self__, *,
                 insert_headers: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeaderArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeaderArgs']]] insert_headers: The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        pulumi.set(__self__, "insert_headers", insert_headers)

    @property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeaderArgs']]]:
        """
        The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        return pulumi.get(self, "insert_headers")

    @insert_headers.setter
    def insert_headers(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeaderArgs']]]):
        pulumi.set(self, "insert_headers", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeaderArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        """
        value: pulumi.Input[str]
        """
        Value of the custom header.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        :param pulumi.Input[str] value: Value of the custom header.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value of the custom header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementArgsDict(TypedDict):
        and_statement: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAndStatementArgsDict']]
        """
        Logical rule statement used to combine other rule statements with AND logic. See `and_statement` below for details.
        """
        byte_match_statement: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementArgsDict']]
        """
        Rule statement that defines a string match search for AWS WAF to apply to web requests. See `byte_match_statement` below for details.
        """
        geo_match_statement: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementArgsDict']]
        """
        Rule statement used to identify web requests based on country of origin. See `geo_match_statement` below for details.
        """
        ip_set_reference_statement: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementArgsDict']]
        """
        Rule statement used to detect web requests coming from particular IP addresses or address ranges. See `ip_set_reference_statement` below for details.
        """
        label_match_statement: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementLabelMatchStatementArgsDict']]
        """
        Rule statement that defines a string match search against labels that have been added to the web request by rules that have already run in the web ACL. See `label_match_statement` below for details.
        """
        not_statement: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementNotStatementArgsDict']]
        """
        Logical rule statement used to negate the results of another rule statement. See `not_statement` below for details.
        """
        or_statement: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementOrStatementArgsDict']]
        """
        Logical rule statement used to combine other rule statements with OR logic. See `or_statement` below for details.
        """
        regex_match_statement: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementArgsDict']]
        """
        Rule statement used to search web request components for a match against a single regular expression. See `regex_match_statement` below for details.
        """
        regex_pattern_set_reference_statement: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementArgsDict']]
        """
        Rule statement used to search web request components for matches with regular expressions. See `regex_pattern_set_reference_statement` below for details.
        """
        size_constraint_statement: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementArgsDict']]
        """
        Rule statement that compares a number of bytes against the size of a request component, using a comparison operator, such as greater than (>) or less than (<). See `size_constraint_statement` below for more details.
        """
        sqli_match_statement: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementArgsDict']]
        """
        An SQL injection match condition identifies the part of web requests, such as the URI or the query string, that you want AWS WAF to inspect. See `sqli_match_statement` below for details.
        """
        xss_match_statement: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementArgsDict']]
        """
        Rule statement that defines a cross-site scripting (XSS) match search for AWS WAF to apply to web requests. See `xss_match_statement` below for details.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementArgs:
    def __init__(__self__, *,
                 and_statement: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAndStatementArgs']] = None,
                 byte_match_statement: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementArgs']] = None,
                 geo_match_statement: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementArgs']] = None,
                 ip_set_reference_statement: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementArgs']] = None,
                 label_match_statement: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementLabelMatchStatementArgs']] = None,
                 not_statement: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementNotStatementArgs']] = None,
                 or_statement: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementOrStatementArgs']] = None,
                 regex_match_statement: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementArgs']] = None,
                 regex_pattern_set_reference_statement: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementArgs']] = None,
                 size_constraint_statement: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementArgs']] = None,
                 sqli_match_statement: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementArgs']] = None,
                 xss_match_statement: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAndStatementArgs'] and_statement: Logical rule statement used to combine other rule statements with AND logic. See `and_statement` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementArgs'] byte_match_statement: Rule statement that defines a string match search for AWS WAF to apply to web requests. See `byte_match_statement` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementArgs'] geo_match_statement: Rule statement used to identify web requests based on country of origin. See `geo_match_statement` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementArgs'] ip_set_reference_statement: Rule statement used to detect web requests coming from particular IP addresses or address ranges. See `ip_set_reference_statement` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementLabelMatchStatementArgs'] label_match_statement: Rule statement that defines a string match search against labels that have been added to the web request by rules that have already run in the web ACL. See `label_match_statement` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementNotStatementArgs'] not_statement: Logical rule statement used to negate the results of another rule statement. See `not_statement` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementOrStatementArgs'] or_statement: Logical rule statement used to combine other rule statements with OR logic. See `or_statement` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementArgs'] regex_match_statement: Rule statement used to search web request components for a match against a single regular expression. See `regex_match_statement` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementArgs'] regex_pattern_set_reference_statement: Rule statement used to search web request components for matches with regular expressions. See `regex_pattern_set_reference_statement` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementArgs'] size_constraint_statement: Rule statement that compares a number of bytes against the size of a request component, using a comparison operator, such as greater than (>) or less than (<). See `size_constraint_statement` below for more details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementArgs'] sqli_match_statement: An SQL injection match condition identifies the part of web requests, such as the URI or the query string, that you want AWS WAF to inspect. See `sqli_match_statement` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementArgs'] xss_match_statement: Rule statement that defines a cross-site scripting (XSS) match search for AWS WAF to apply to web requests. See `xss_match_statement` below for details.
        """
        if and_statement is not None:
            pulumi.set(__self__, "and_statement", and_statement)
        if byte_match_statement is not None:
            pulumi.set(__self__, "byte_match_statement", byte_match_statement)
        if geo_match_statement is not None:
            pulumi.set(__self__, "geo_match_statement", geo_match_statement)
        if ip_set_reference_statement is not None:
            pulumi.set(__self__, "ip_set_reference_statement", ip_set_reference_statement)
        if label_match_statement is not None:
            pulumi.set(__self__, "label_match_statement", label_match_statement)
        if not_statement is not None:
            pulumi.set(__self__, "not_statement", not_statement)
        if or_statement is not None:
            pulumi.set(__self__, "or_statement", or_statement)
        if regex_match_statement is not None:
            pulumi.set(__self__, "regex_match_statement", regex_match_statement)
        if regex_pattern_set_reference_statement is not None:
            pulumi.set(__self__, "regex_pattern_set_reference_statement", regex_pattern_set_reference_statement)
        if size_constraint_statement is not None:
            pulumi.set(__self__, "size_constraint_statement", size_constraint_statement)
        if sqli_match_statement is not None:
            pulumi.set(__self__, "sqli_match_statement", sqli_match_statement)
        if xss_match_statement is not None:
            pulumi.set(__self__, "xss_match_statement", xss_match_statement)

    @property
    @pulumi.getter(name="andStatement")
    def and_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAndStatementArgs']]:
        """
        Logical rule statement used to combine other rule statements with AND logic. See `and_statement` below for details.
        """
        return pulumi.get(self, "and_statement")

    @and_statement.setter
    def and_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAndStatementArgs']]):
        pulumi.set(self, "and_statement", value)

    @property
    @pulumi.getter(name="byteMatchStatement")
    def byte_match_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementArgs']]:
        """
        Rule statement that defines a string match search for AWS WAF to apply to web requests. See `byte_match_statement` below for details.
        """
        return pulumi.get(self, "byte_match_statement")

    @byte_match_statement.setter
    def byte_match_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementArgs']]):
        pulumi.set(self, "byte_match_statement", value)

    @property
    @pulumi.getter(name="geoMatchStatement")
    def geo_match_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementArgs']]:
        """
        Rule statement used to identify web requests based on country of origin. See `geo_match_statement` below for details.
        """
        return pulumi.get(self, "geo_match_statement")

    @geo_match_statement.setter
    def geo_match_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementArgs']]):
        pulumi.set(self, "geo_match_statement", value)

    @property
    @pulumi.getter(name="ipSetReferenceStatement")
    def ip_set_reference_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementArgs']]:
        """
        Rule statement used to detect web requests coming from particular IP addresses or address ranges. See `ip_set_reference_statement` below for details.
        """
        return pulumi.get(self, "ip_set_reference_statement")

    @ip_set_reference_statement.setter
    def ip_set_reference_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementArgs']]):
        pulumi.set(self, "ip_set_reference_statement", value)

    @property
    @pulumi.getter(name="labelMatchStatement")
    def label_match_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementLabelMatchStatementArgs']]:
        """
        Rule statement that defines a string match search against labels that have been added to the web request by rules that have already run in the web ACL. See `label_match_statement` below for details.
        """
        return pulumi.get(self, "label_match_statement")

    @label_match_statement.setter
    def label_match_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementLabelMatchStatementArgs']]):
        pulumi.set(self, "label_match_statement", value)

    @property
    @pulumi.getter(name="notStatement")
    def not_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementNotStatementArgs']]:
        """
        Logical rule statement used to negate the results of another rule statement. See `not_statement` below for details.
        """
        return pulumi.get(self, "not_statement")

    @not_statement.setter
    def not_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementNotStatementArgs']]):
        pulumi.set(self, "not_statement", value)

    @property
    @pulumi.getter(name="orStatement")
    def or_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementOrStatementArgs']]:
        """
        Logical rule statement used to combine other rule statements with OR logic. See `or_statement` below for details.
        """
        return pulumi.get(self, "or_statement")

    @or_statement.setter
    def or_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementOrStatementArgs']]):
        pulumi.set(self, "or_statement", value)

    @property
    @pulumi.getter(name="regexMatchStatement")
    def regex_match_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementArgs']]:
        """
        Rule statement used to search web request components for a match against a single regular expression. See `regex_match_statement` below for details.
        """
        return pulumi.get(self, "regex_match_statement")

    @regex_match_statement.setter
    def regex_match_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementArgs']]):
        pulumi.set(self, "regex_match_statement", value)

    @property
    @pulumi.getter(name="regexPatternSetReferenceStatement")
    def regex_pattern_set_reference_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementArgs']]:
        """
        Rule statement used to search web request components for matches with regular expressions. See `regex_pattern_set_reference_statement` below for details.
        """
        return pulumi.get(self, "regex_pattern_set_reference_statement")

    @regex_pattern_set_reference_statement.setter
    def regex_pattern_set_reference_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementArgs']]):
        pulumi.set(self, "regex_pattern_set_reference_statement", value)

    @property
    @pulumi.getter(name="sizeConstraintStatement")
    def size_constraint_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementArgs']]:
        """
        Rule statement that compares a number of bytes against the size of a request component, using a comparison operator, such as greater than (>) or less than (<). See `size_constraint_statement` below for more details.
        """
        return pulumi.get(self, "size_constraint_statement")

    @size_constraint_statement.setter
    def size_constraint_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementArgs']]):
        pulumi.set(self, "size_constraint_statement", value)

    @property
    @pulumi.getter(name="sqliMatchStatement")
    def sqli_match_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementArgs']]:
        """
        An SQL injection match condition identifies the part of web requests, such as the URI or the query string, that you want AWS WAF to inspect. See `sqli_match_statement` below for details.
        """
        return pulumi.get(self, "sqli_match_statement")

    @sqli_match_statement.setter
    def sqli_match_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementArgs']]):
        pulumi.set(self, "sqli_match_statement", value)

    @property
    @pulumi.getter(name="xssMatchStatement")
    def xss_match_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementArgs']]:
        """
        Rule statement that defines a cross-site scripting (XSS) match search for AWS WAF to apply to web requests. See `xss_match_statement` below for details.
        """
        return pulumi.get(self, "xss_match_statement")

    @xss_match_statement.setter
    def xss_match_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementArgs']]):
        pulumi.set(self, "xss_match_statement", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAndStatementArgsDict(TypedDict):
        statements: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgsDict']]]
        """
        The statements to combine.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAndStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAndStatementArgs:
    def __init__(__self__, *,
                 statements: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]] statements: The statements to combine.
        """
        pulumi.set(__self__, "statements", statements)

    @property
    @pulumi.getter
    def statements(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")

    @statements.setter
    def statements(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]):
        pulumi.set(self, "statements", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementArgsDict(TypedDict):
        positional_constraint: pulumi.Input[str]
        """
        Area within the portion of a web request that you want AWS WAF to search for `search_string`. Valid values include the following: `EXACTLY`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CONTAINS_WORD`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_ByteMatchStatement.html) for more information.
        """
        search_string: pulumi.Input[str]
        """
        String value that you want AWS WAF to search for. AWS WAF searches only in the part of web requests that you designate for inspection in `field_to_match`. The maximum length of the value is 50 bytes.
        """
        text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementTextTransformationArgsDict']]]
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        field_to_match: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchArgsDict']]
        """
        Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementArgs:
    def __init__(__self__, *,
                 positional_constraint: pulumi.Input[str],
                 search_string: pulumi.Input[str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchArgs']] = None):
        """
        :param pulumi.Input[str] positional_constraint: Area within the portion of a web request that you want AWS WAF to search for `search_string`. Valid values include the following: `EXACTLY`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CONTAINS_WORD`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_ByteMatchStatement.html) for more information.
        :param pulumi.Input[str] search_string: String value that you want AWS WAF to search for. AWS WAF searches only in the part of web requests that you designate for inspection in `field_to_match`. The maximum length of the value is 50 bytes.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchArgs'] field_to_match: Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        pulumi.set(__self__, "positional_constraint", positional_constraint)
        pulumi.set(__self__, "search_string", search_string)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @property
    @pulumi.getter(name="positionalConstraint")
    def positional_constraint(self) -> pulumi.Input[str]:
        """
        Area within the portion of a web request that you want AWS WAF to search for `search_string`. Valid values include the following: `EXACTLY`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CONTAINS_WORD`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_ByteMatchStatement.html) for more information.
        """
        return pulumi.get(self, "positional_constraint")

    @positional_constraint.setter
    def positional_constraint(self, value: pulumi.Input[str]):
        pulumi.set(self, "positional_constraint", value)

    @property
    @pulumi.getter(name="searchString")
    def search_string(self) -> pulumi.Input[str]:
        """
        String value that you want AWS WAF to search for. AWS WAF searches only in the part of web requests that you designate for inspection in `field_to_match`. The maximum length of the value is 50 bytes.
        """
        return pulumi.get(self, "search_string")

    @search_string.setter
    def search_string(self, value: pulumi.Input[str]):
        pulumi.set(self, "search_string", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchArgs']]:
        """
        Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchArgsDict(TypedDict):
        all_query_arguments: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgsDict']]
        """
        Inspect all query arguments.
        """
        body: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgsDict']]
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        cookies: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgsDict']]
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        header_orders: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgsDict']]]]
        """
        Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgsDict']]]]
        """
        Inspect the request headers. See `headers` below for details.
        """
        ja3_fingerprint: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgsDict']]
        """
        Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        """
        json_body: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgsDict']]
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        method: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgsDict']]
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        query_string: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgsDict']]
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        single_header: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgsDict']]
        """
        Inspect a single header. See `single_header` below for details.
        """
        single_query_argument: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgsDict']]
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        uri_path: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgsDict']]
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_path: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs'] all_query_arguments: Inspect all query arguments.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgs'] body: Inspect the request body, which immediately follows the request headers. See `body` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgs'] cookies: Inspect the cookies in the web request. See `cookies` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgs']]] header_orders: Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgs']]] headers: Inspect the request headers. See `headers` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgs'] ja3_fingerprint: Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgs'] json_body: Inspect the request body as JSON. See `json_body` for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgs'] method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgs'] query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgs'] single_header: Inspect a single header. See `single_header` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs'] single_query_argument: Inspect a single query argument. See `single_query_argument` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgs'] uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs']]:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgs']]:
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgs']]:
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgs']]]]:
        """
        Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        """
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgs']]]]:
        """
        Inspect the request headers. See `headers` below for details.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgs']]:
        """
        Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        """
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgs']]:
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgs']]:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgs']]:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgs']]:
        """
        Inspect a single header. See `single_header` below for details.
        """
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs']]:
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgs']]:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgsDict(TypedDict):
        oversize_handling: NotRequired[pulumi.Input[str]]
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] oversize_handling: What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgsDict(TypedDict):
        match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgsDict']]]
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        oversize_handling: pulumi.Input[str]
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs']]] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param pulumi.Input[str] match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs']]]:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        excluded_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        included_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_cookies", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgsDict']
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        oversize_handling: pulumi.Input[str]
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs'] match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param pulumi.Input[str] match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs']:
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        excluded_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        included_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_headers", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgsDict(TypedDict):
        oversize_handling: pulumi.Input[str]
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[str]
        """
        The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict']
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        invalid_fallback_behavior: NotRequired[pulumi.Input[str]]
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        oversize_handling: NotRequired[pulumi.Input[str]]
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 invalid_fallback_behavior: Optional[pulumi.Input[str]] = None,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs'] match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param pulumi.Input[str] match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param pulumi.Input[str] invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param pulumi.Input[str] oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs']:
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        included_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_paths", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[int]
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        type: pulumi.Input[str]
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementArgsDict(TypedDict):
        country_codes: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Array of two-character country codes, for example, [ "US", "CN" ], from the alpha-2 country ISO codes of the `ISO 3166` international standard. See the [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_GeoMatchStatement.html) for valid values.
        """
        forwarded_ip_config: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgsDict']]
        """
        Configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See `forwarded_ip_config` below for details.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementArgs:
    def __init__(__self__, *,
                 country_codes: pulumi.Input[Sequence[pulumi.Input[str]]],
                 forwarded_ip_config: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] country_codes: Array of two-character country codes, for example, [ "US", "CN" ], from the alpha-2 country ISO codes of the `ISO 3166` international standard. See the [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_GeoMatchStatement.html) for valid values.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgs'] forwarded_ip_config: Configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See `forwarded_ip_config` below for details.
        """
        pulumi.set(__self__, "country_codes", country_codes)
        if forwarded_ip_config is not None:
            pulumi.set(__self__, "forwarded_ip_config", forwarded_ip_config)

    @property
    @pulumi.getter(name="countryCodes")
    def country_codes(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Array of two-character country codes, for example, [ "US", "CN" ], from the alpha-2 country ISO codes of the `ISO 3166` international standard. See the [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_GeoMatchStatement.html) for valid values.
        """
        return pulumi.get(self, "country_codes")

    @country_codes.setter
    def country_codes(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "country_codes", value)

    @property
    @pulumi.getter(name="forwardedIpConfig")
    def forwarded_ip_config(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgs']]:
        """
        Configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See `forwarded_ip_config` below for details.
        """
        return pulumi.get(self, "forwarded_ip_config")

    @forwarded_ip_config.setter
    def forwarded_ip_config(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgs']]):
        pulumi.set(self, "forwarded_ip_config", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[str]
        """
        Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        header_name: pulumi.Input[str]
        """
        Name of the HTTP header to use for the IP address.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str],
                 header_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        :param pulumi.Input[str] header_name: Name of the HTTP header to use for the IP address.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> pulumi.Input[str]:
        """
        Name of the HTTP header to use for the IP address.
        """
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "header_name", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementArgsDict(TypedDict):
        arn: pulumi.Input[str]
        """
        The Amazon Resource Name (ARN) of the IP Set that this statement references.
        """
        ip_set_forwarded_ip_config: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgsDict']]
        """
        Configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See `ip_set_forwarded_ip_config` below for more details.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[str],
                 ip_set_forwarded_ip_config: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs']] = None):
        """
        :param pulumi.Input[str] arn: The Amazon Resource Name (ARN) of the IP Set that this statement references.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs'] ip_set_forwarded_ip_config: Configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See `ip_set_forwarded_ip_config` below for more details.
        """
        pulumi.set(__self__, "arn", arn)
        if ip_set_forwarded_ip_config is not None:
            pulumi.set(__self__, "ip_set_forwarded_ip_config", ip_set_forwarded_ip_config)

    @property
    @pulumi.getter
    def arn(self) -> pulumi.Input[str]:
        """
        The Amazon Resource Name (ARN) of the IP Set that this statement references.
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "arn", value)

    @property
    @pulumi.getter(name="ipSetForwardedIpConfig")
    def ip_set_forwarded_ip_config(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs']]:
        """
        Configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See `ip_set_forwarded_ip_config` below for more details.
        """
        return pulumi.get(self, "ip_set_forwarded_ip_config")

    @ip_set_forwarded_ip_config.setter
    def ip_set_forwarded_ip_config(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs']]):
        pulumi.set(self, "ip_set_forwarded_ip_config", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[str]
        """
        Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        header_name: pulumi.Input[str]
        """
        Name of the HTTP header to use for the IP address.
        """
        position: pulumi.Input[str]
        """
        Position in the header to search for the IP address. Valid values include: `FIRST`, `LAST`, or `ANY`. If `ANY` is specified and the header contains more than 10 IP addresses, AWS WAFv2 inspects the last 10.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str],
                 header_name: pulumi.Input[str],
                 position: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        :param pulumi.Input[str] header_name: Name of the HTTP header to use for the IP address.
        :param pulumi.Input[str] position: Position in the header to search for the IP address. Valid values include: `FIRST`, `LAST`, or `ANY`. If `ANY` is specified and the header contains more than 10 IP addresses, AWS WAFv2 inspects the last 10.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "position", position)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> pulumi.Input[str]:
        """
        Name of the HTTP header to use for the IP address.
        """
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "header_name", value)

    @property
    @pulumi.getter
    def position(self) -> pulumi.Input[str]:
        """
        Position in the header to search for the IP address. Valid values include: `FIRST`, `LAST`, or `ANY`. If `ANY` is specified and the header contains more than 10 IP addresses, AWS WAFv2 inspects the last 10.
        """
        return pulumi.get(self, "position")

    @position.setter
    def position(self, value: pulumi.Input[str]):
        pulumi.set(self, "position", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementLabelMatchStatementArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        String to match against.
        """
        scope: pulumi.Input[str]
        """
        Specify whether you want to match using the label name or just the namespace. Valid values are `LABEL` or `NAMESPACE`.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementLabelMatchStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementLabelMatchStatementArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 scope: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: String to match against.
        :param pulumi.Input[str] scope: Specify whether you want to match using the label name or just the namespace. Valid values are `LABEL` or `NAMESPACE`.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        String to match against.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def scope(self) -> pulumi.Input[str]:
        """
        Specify whether you want to match using the label name or just the namespace. Valid values are `LABEL` or `NAMESPACE`.
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "scope", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementNotStatementArgsDict(TypedDict):
        statements: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgsDict']]]
        """
        The statements to combine.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementNotStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementNotStatementArgs:
    def __init__(__self__, *,
                 statements: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]] statements: The statements to combine.
        """
        pulumi.set(__self__, "statements", statements)

    @property
    @pulumi.getter
    def statements(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")

    @statements.setter
    def statements(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]):
        pulumi.set(self, "statements", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementOrStatementArgsDict(TypedDict):
        statements: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgsDict']]]
        """
        The statements to combine.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementOrStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementOrStatementArgs:
    def __init__(__self__, *,
                 statements: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]] statements: The statements to combine.
        """
        pulumi.set(__self__, "statements", statements)

    @property
    @pulumi.getter
    def statements(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")

    @statements.setter
    def statements(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]):
        pulumi.set(self, "statements", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementArgsDict(TypedDict):
        regex_string: pulumi.Input[str]
        """
        String representing the regular expression. Minimum of `1` and maximum of `512` characters.
        """
        text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementTextTransformationArgsDict']]]
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        field_to_match: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchArgsDict']]
        """
        The part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementArgs:
    def __init__(__self__, *,
                 regex_string: pulumi.Input[str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchArgs']] = None):
        """
        :param pulumi.Input[str] regex_string: String representing the regular expression. Minimum of `1` and maximum of `512` characters.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchArgs'] field_to_match: The part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        pulumi.set(__self__, "regex_string", regex_string)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @property
    @pulumi.getter(name="regexString")
    def regex_string(self) -> pulumi.Input[str]:
        """
        String representing the regular expression. Minimum of `1` and maximum of `512` characters.
        """
        return pulumi.get(self, "regex_string")

    @regex_string.setter
    def regex_string(self, value: pulumi.Input[str]):
        pulumi.set(self, "regex_string", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchArgs']]:
        """
        The part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchArgsDict(TypedDict):
        all_query_arguments: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgsDict']]
        """
        Inspect all query arguments.
        """
        body: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgsDict']]
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        cookies: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgsDict']]
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        header_orders: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgsDict']]]]
        """
        Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgsDict']]]]
        """
        Inspect the request headers. See `headers` below for details.
        """
        ja3_fingerprint: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgsDict']]
        """
        Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        """
        json_body: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgsDict']]
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        method: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgsDict']]
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        query_string: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgsDict']]
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        single_header: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgsDict']]
        """
        Inspect a single header. See `single_header` below for details.
        """
        single_query_argument: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgsDict']]
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        uri_path: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgsDict']]
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_path: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs'] all_query_arguments: Inspect all query arguments.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgs'] body: Inspect the request body, which immediately follows the request headers. See `body` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgs'] cookies: Inspect the cookies in the web request. See `cookies` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgs']]] header_orders: Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgs']]] headers: Inspect the request headers. See `headers` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs'] ja3_fingerprint: Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgs'] json_body: Inspect the request body as JSON. See `json_body` for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgs'] method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgs'] query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgs'] single_header: Inspect a single header. See `single_header` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs'] single_query_argument: Inspect a single query argument. See `single_query_argument` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgs'] uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs']]:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgs']]:
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgs']]:
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgs']]]]:
        """
        Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        """
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgs']]]]:
        """
        Inspect the request headers. See `headers` below for details.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs']]:
        """
        Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        """
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgs']]:
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgs']]:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgs']]:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgs']]:
        """
        Inspect a single header. See `single_header` below for details.
        """
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs']]:
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgs']]:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgsDict(TypedDict):
        oversize_handling: NotRequired[pulumi.Input[str]]
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] oversize_handling: What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgsDict(TypedDict):
        match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgsDict']]]
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        oversize_handling: pulumi.Input[str]
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs']]] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param pulumi.Input[str] match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs']]]:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        excluded_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        included_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_cookies", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgsDict']
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        oversize_handling: pulumi.Input[str]
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs'] match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param pulumi.Input[str] match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs']:
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        excluded_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        included_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_headers", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgsDict(TypedDict):
        oversize_handling: pulumi.Input[str]
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[str]
        """
        The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict']
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        invalid_fallback_behavior: NotRequired[pulumi.Input[str]]
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        oversize_handling: NotRequired[pulumi.Input[str]]
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 invalid_fallback_behavior: Optional[pulumi.Input[str]] = None,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs'] match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param pulumi.Input[str] match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param pulumi.Input[str] invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param pulumi.Input[str] oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs']:
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        included_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_paths", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[int]
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        type: pulumi.Input[str]
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementArgsDict(TypedDict):
        arn: pulumi.Input[str]
        """
        The Amazon Resource Name (ARN) of the Regex Pattern Set that this statement references.
        """
        text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgsDict']]]
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        field_to_match: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgsDict']]
        """
        Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgs']] = None):
        """
        :param pulumi.Input[str] arn: The Amazon Resource Name (ARN) of the Regex Pattern Set that this statement references.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgs'] field_to_match: Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @property
    @pulumi.getter
    def arn(self) -> pulumi.Input[str]:
        """
        The Amazon Resource Name (ARN) of the Regex Pattern Set that this statement references.
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "arn", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgs']]:
        """
        Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgsDict(TypedDict):
        all_query_arguments: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgsDict']]
        """
        Inspect all query arguments.
        """
        body: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgsDict']]
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        cookies: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgsDict']]
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        header_orders: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgsDict']]]]
        """
        Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgsDict']]]]
        """
        Inspect the request headers. See `headers` below for details.
        """
        ja3_fingerprint: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgsDict']]
        """
        Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        """
        json_body: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgsDict']]
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        method: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgsDict']]
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        query_string: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgsDict']]
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        single_header: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgsDict']]
        """
        Inspect a single header. See `single_header` below for details.
        """
        single_query_argument: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgsDict']]
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        uri_path: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgsDict']]
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_path: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs'] all_query_arguments: Inspect all query arguments.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs'] body: Inspect the request body, which immediately follows the request headers. See `body` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs'] cookies: Inspect the cookies in the web request. See `cookies` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs']]] header_orders: Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs']]] headers: Inspect the request headers. See `headers` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs'] ja3_fingerprint: Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs'] json_body: Inspect the request body as JSON. See `json_body` for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs'] method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs'] query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs'] single_header: Inspect a single header. See `single_header` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs'] single_query_argument: Inspect a single query argument. See `single_query_argument` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs'] uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs']]:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs']]:
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs']]:
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs']]]]:
        """
        Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        """
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs']]]]:
        """
        Inspect the request headers. See `headers` below for details.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs']]:
        """
        Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        """
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs']]:
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs']]:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs']]:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs']]:
        """
        Inspect a single header. See `single_header` below for details.
        """
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs']]:
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs']]:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgsDict(TypedDict):
        oversize_handling: NotRequired[pulumi.Input[str]]
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] oversize_handling: What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgsDict(TypedDict):
        match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgsDict']]]
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        oversize_handling: pulumi.Input[str]
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs']]] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param pulumi.Input[str] match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs']]]:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        excluded_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        included_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_cookies", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgsDict']
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        oversize_handling: pulumi.Input[str]
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs'] match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param pulumi.Input[str] match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs']:
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        excluded_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        included_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_headers", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgsDict(TypedDict):
        oversize_handling: pulumi.Input[str]
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[str]
        """
        The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgsDict']
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        invalid_fallback_behavior: NotRequired[pulumi.Input[str]]
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        oversize_handling: NotRequired[pulumi.Input[str]]
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 invalid_fallback_behavior: Optional[pulumi.Input[str]] = None,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs'] match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param pulumi.Input[str] match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param pulumi.Input[str] invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param pulumi.Input[str] oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs']:
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        included_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_paths", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[int]
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        type: pulumi.Input[str]
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementArgsDict(TypedDict):
        comparison_operator: pulumi.Input[str]
        """
        Operator to use to compare the request part to the size setting. Valid values include: `EQ`, `NE`, `LE`, `LT`, `GE`, or `GT`.
        """
        size: pulumi.Input[int]
        """
        Size, in bytes, to compare to the request part, after any transformations. Valid values are integers between 0 and 21474836480, inclusive.
        """
        text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementTextTransformationArgsDict']]]
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        field_to_match: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgsDict']]
        """
        Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementArgs:
    def __init__(__self__, *,
                 comparison_operator: pulumi.Input[str],
                 size: pulumi.Input[int],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgs']] = None):
        """
        :param pulumi.Input[str] comparison_operator: Operator to use to compare the request part to the size setting. Valid values include: `EQ`, `NE`, `LE`, `LT`, `GE`, or `GT`.
        :param pulumi.Input[int] size: Size, in bytes, to compare to the request part, after any transformations. Valid values are integers between 0 and 21474836480, inclusive.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgs'] field_to_match: Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        pulumi.set(__self__, "comparison_operator", comparison_operator)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> pulumi.Input[str]:
        """
        Operator to use to compare the request part to the size setting. Valid values include: `EQ`, `NE`, `LE`, `LT`, `GE`, or `GT`.
        """
        return pulumi.get(self, "comparison_operator")

    @comparison_operator.setter
    def comparison_operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "comparison_operator", value)

    @property
    @pulumi.getter
    def size(self) -> pulumi.Input[int]:
        """
        Size, in bytes, to compare to the request part, after any transformations. Valid values are integers between 0 and 21474836480, inclusive.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[int]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgs']]:
        """
        Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgsDict(TypedDict):
        all_query_arguments: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgsDict']]
        """
        Inspect all query arguments.
        """
        body: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgsDict']]
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        cookies: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgsDict']]
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        header_orders: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgsDict']]]]
        """
        Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgsDict']]]]
        """
        Inspect the request headers. See `headers` below for details.
        """
        ja3_fingerprint: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgsDict']]
        """
        Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        """
        json_body: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgsDict']]
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        method: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgsDict']]
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        query_string: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgsDict']]
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        single_header: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgsDict']]
        """
        Inspect a single header. See `single_header` below for details.
        """
        single_query_argument: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgsDict']]
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        uri_path: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgsDict']]
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_path: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs'] all_query_arguments: Inspect all query arguments.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgs'] body: Inspect the request body, which immediately follows the request headers. See `body` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgs'] cookies: Inspect the cookies in the web request. See `cookies` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs']]] header_orders: Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgs']]] headers: Inspect the request headers. See `headers` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs'] ja3_fingerprint: Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgs'] json_body: Inspect the request body as JSON. See `json_body` for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgs'] method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgs'] query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs'] single_header: Inspect a single header. See `single_header` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs'] single_query_argument: Inspect a single query argument. See `single_query_argument` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgs'] uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs']]:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgs']]:
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgs']]:
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs']]]]:
        """
        Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        """
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgs']]]]:
        """
        Inspect the request headers. See `headers` below for details.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs']]:
        """
        Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        """
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgs']]:
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgs']]:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgs']]:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs']]:
        """
        Inspect a single header. See `single_header` below for details.
        """
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs']]:
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgs']]:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgsDict(TypedDict):
        oversize_handling: NotRequired[pulumi.Input[str]]
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] oversize_handling: What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgsDict(TypedDict):
        match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgsDict']]]
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        oversize_handling: pulumi.Input[str]
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs']]] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param pulumi.Input[str] match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs']]]:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        excluded_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        included_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_cookies", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgsDict']
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        oversize_handling: pulumi.Input[str]
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs'] match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param pulumi.Input[str] match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs']:
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        excluded_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        included_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_headers", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgsDict(TypedDict):
        oversize_handling: pulumi.Input[str]
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[str]
        """
        The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgsDict']
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        invalid_fallback_behavior: NotRequired[pulumi.Input[str]]
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        oversize_handling: NotRequired[pulumi.Input[str]]
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 invalid_fallback_behavior: Optional[pulumi.Input[str]] = None,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs'] match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param pulumi.Input[str] match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param pulumi.Input[str] invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param pulumi.Input[str] oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs']:
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        included_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_paths", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[int]
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        type: pulumi.Input[str]
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementArgsDict(TypedDict):
        text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementTextTransformationArgsDict']]]
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        field_to_match: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchArgsDict']]
        """
        Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        sensitivity_level: NotRequired[pulumi.Input[str]]
        """
        Sensitivity that you want AWS WAF to use to inspect for SQL injection attacks. Valid values include: `LOW`, `HIGH`.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementArgs:
    def __init__(__self__, *,
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchArgs']] = None,
                 sensitivity_level: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchArgs'] field_to_match: Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        :param pulumi.Input[str] sensitivity_level: Sensitivity that you want AWS WAF to use to inspect for SQL injection attacks. Valid values include: `LOW`, `HIGH`.
        """
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)
        if sensitivity_level is not None:
            pulumi.set(__self__, "sensitivity_level", sensitivity_level)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchArgs']]:
        """
        Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)

    @property
    @pulumi.getter(name="sensitivityLevel")
    def sensitivity_level(self) -> Optional[pulumi.Input[str]]:
        """
        Sensitivity that you want AWS WAF to use to inspect for SQL injection attacks. Valid values include: `LOW`, `HIGH`.
        """
        return pulumi.get(self, "sensitivity_level")

    @sensitivity_level.setter
    def sensitivity_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sensitivity_level", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchArgsDict(TypedDict):
        all_query_arguments: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgsDict']]
        """
        Inspect all query arguments.
        """
        body: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgsDict']]
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        cookies: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgsDict']]
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        header_orders: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgsDict']]]]
        """
        Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgsDict']]]]
        """
        Inspect the request headers. See `headers` below for details.
        """
        ja3_fingerprint: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgsDict']]
        """
        Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        """
        json_body: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgsDict']]
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        method: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgsDict']]
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        query_string: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgsDict']]
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        single_header: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgsDict']]
        """
        Inspect a single header. See `single_header` below for details.
        """
        single_query_argument: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgsDict']]
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        uri_path: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgsDict']]
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_path: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs'] all_query_arguments: Inspect all query arguments.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgs'] body: Inspect the request body, which immediately follows the request headers. See `body` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgs'] cookies: Inspect the cookies in the web request. See `cookies` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgs']]] header_orders: Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgs']]] headers: Inspect the request headers. See `headers` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs'] ja3_fingerprint: Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgs'] json_body: Inspect the request body as JSON. See `json_body` for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgs'] method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgs'] query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgs'] single_header: Inspect a single header. See `single_header` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs'] single_query_argument: Inspect a single query argument. See `single_query_argument` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgs'] uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs']]:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgs']]:
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgs']]:
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgs']]]]:
        """
        Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        """
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgs']]]]:
        """
        Inspect the request headers. See `headers` below for details.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs']]:
        """
        Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        """
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgs']]:
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgs']]:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgs']]:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgs']]:
        """
        Inspect a single header. See `single_header` below for details.
        """
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs']]:
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgs']]:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgsDict(TypedDict):
        oversize_handling: NotRequired[pulumi.Input[str]]
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] oversize_handling: What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgsDict(TypedDict):
        match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgsDict']]]
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        oversize_handling: pulumi.Input[str]
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs']]] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param pulumi.Input[str] match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs']]]:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        excluded_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        included_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_cookies", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgsDict']
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        oversize_handling: pulumi.Input[str]
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs'] match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param pulumi.Input[str] match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs']:
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        excluded_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        included_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_headers", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgsDict(TypedDict):
        oversize_handling: pulumi.Input[str]
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[str]
        """
        The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict']
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        invalid_fallback_behavior: NotRequired[pulumi.Input[str]]
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        oversize_handling: NotRequired[pulumi.Input[str]]
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 invalid_fallback_behavior: Optional[pulumi.Input[str]] = None,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs'] match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param pulumi.Input[str] match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param pulumi.Input[str] invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param pulumi.Input[str] oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs']:
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        included_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_paths", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[int]
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        type: pulumi.Input[str]
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementArgsDict(TypedDict):
        text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementTextTransformationArgsDict']]]
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        field_to_match: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchArgsDict']]
        """
        Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementArgs:
    def __init__(__self__, *,
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchArgs'] field_to_match: Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchArgs']]:
        """
        Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchArgsDict(TypedDict):
        all_query_arguments: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgsDict']]
        """
        Inspect all query arguments.
        """
        body: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgsDict']]
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        cookies: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgsDict']]
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        header_orders: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgsDict']]]]
        """
        Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgsDict']]]]
        """
        Inspect the request headers. See `headers` below for details.
        """
        ja3_fingerprint: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgsDict']]
        """
        Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        """
        json_body: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgsDict']]
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        method: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgsDict']]
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        query_string: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgsDict']]
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        single_header: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgsDict']]
        """
        Inspect a single header. See `single_header` below for details.
        """
        single_query_argument: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgsDict']]
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        uri_path: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgsDict']]
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_path: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs'] all_query_arguments: Inspect all query arguments.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgs'] body: Inspect the request body, which immediately follows the request headers. See `body` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgs'] cookies: Inspect the cookies in the web request. See `cookies` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgs']]] header_orders: Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgs']]] headers: Inspect the request headers. See `headers` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgs'] ja3_fingerprint: Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgs'] json_body: Inspect the request body as JSON. See `json_body` for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgs'] method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgs'] query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgs'] single_header: Inspect a single header. See `single_header` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs'] single_query_argument: Inspect a single query argument. See `single_query_argument` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgs'] uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs']]:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgs']]:
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgs']]:
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgs']]]]:
        """
        Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        """
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgs']]]]:
        """
        Inspect the request headers. See `headers` below for details.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgs']]:
        """
        Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        """
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgs']]:
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgs']]:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgs']]:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgs']]:
        """
        Inspect a single header. See `single_header` below for details.
        """
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs']]:
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgs']]:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgsDict(TypedDict):
        oversize_handling: NotRequired[pulumi.Input[str]]
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] oversize_handling: What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgsDict(TypedDict):
        match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgsDict']]]
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        oversize_handling: pulumi.Input[str]
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs']]] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param pulumi.Input[str] match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs']]]:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        excluded_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        included_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_cookies", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgsDict']
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        oversize_handling: pulumi.Input[str]
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs'] match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param pulumi.Input[str] match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs']:
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        excluded_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        included_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_headers", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgsDict(TypedDict):
        oversize_handling: pulumi.Input[str]
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[str]
        """
        The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict']
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        invalid_fallback_behavior: NotRequired[pulumi.Input[str]]
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        oversize_handling: NotRequired[pulumi.Input[str]]
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 invalid_fallback_behavior: Optional[pulumi.Input[str]] = None,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs'] match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param pulumi.Input[str] match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param pulumi.Input[str] invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param pulumi.Input[str] oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs']:
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        included_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_paths", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[int]
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        type: pulumi.Input[str]
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class WebAclRuleStatementNotStatementArgsDict(TypedDict):
        statements: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgsDict']]]
        """
        The statements to combine.
        """
elif False:
    WebAclRuleStatementNotStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementNotStatementArgs:
    def __init__(__self__, *,
                 statements: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]] statements: The statements to combine.
        """
        pulumi.set(__self__, "statements", statements)

    @property
    @pulumi.getter
    def statements(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")

    @statements.setter
    def statements(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]):
        pulumi.set(self, "statements", value)


if not MYPY:
    class WebAclRuleStatementOrStatementArgsDict(TypedDict):
        statements: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgsDict']]]
        """
        The statements to combine.
        """
elif False:
    WebAclRuleStatementOrStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementOrStatementArgs:
    def __init__(__self__, *,
                 statements: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]] statements: The statements to combine.
        """
        pulumi.set(__self__, "statements", statements)

    @property
    @pulumi.getter
    def statements(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")

    @statements.setter
    def statements(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]):
        pulumi.set(self, "statements", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementArgsDict(TypedDict):
        limit: pulumi.Input[int]
        """
        Limit on requests per 5-minute period for a single originating IP address.
        """
        aggregate_key_type: NotRequired[pulumi.Input[str]]
        """
        Setting that indicates how to aggregate the request counts. Valid values include: `CONSTANT`, `CUSTOM_KEYS`, `FORWARDED_IP`, or `IP`. Default: `IP`.
        """
        custom_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyArgsDict']]]]
        """
        Aggregate the request counts using one or more web request components as the aggregate keys. See `custom_key` below for details.
        """
        evaluation_window_sec: NotRequired[pulumi.Input[int]]
        """
        The amount of time, in seconds, that AWS WAF should include in its request counts, looking back from the current time. Valid values are `60`, `120`, `300`, and `600`. Defaults to `300` (5 minutes).

        **NOTE:** This setting doesn't determine how often AWS WAF checks the rate, but how far back it looks each time it checks. AWS WAF checks the rate about every 10 seconds.
        """
        forwarded_ip_config: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementForwardedIpConfigArgsDict']]
        """
        Configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. If `aggregate_key_type` is set to `FORWARDED_IP`, this block is required. See `forwarded_ip_config` below for details.
        """
        scope_down_statement: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementArgsDict']]
        """
        Optional nested statement that narrows the scope of the rate-based statement to matching web requests. This can be any nestable statement, and you can nest statements at any level below this scope-down statement. See `statement` above for details. If `aggregate_key_type` is set to `CONSTANT`, this block is required.
        """
elif False:
    WebAclRuleStatementRateBasedStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementArgs:
    def __init__(__self__, *,
                 limit: pulumi.Input[int],
                 aggregate_key_type: Optional[pulumi.Input[str]] = None,
                 custom_keys: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyArgs']]]] = None,
                 evaluation_window_sec: Optional[pulumi.Input[int]] = None,
                 forwarded_ip_config: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementForwardedIpConfigArgs']] = None,
                 scope_down_statement: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementArgs']] = None):
        """
        :param pulumi.Input[int] limit: Limit on requests per 5-minute period for a single originating IP address.
        :param pulumi.Input[str] aggregate_key_type: Setting that indicates how to aggregate the request counts. Valid values include: `CONSTANT`, `CUSTOM_KEYS`, `FORWARDED_IP`, or `IP`. Default: `IP`.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyArgs']]] custom_keys: Aggregate the request counts using one or more web request components as the aggregate keys. See `custom_key` below for details.
        :param pulumi.Input[int] evaluation_window_sec: The amount of time, in seconds, that AWS WAF should include in its request counts, looking back from the current time. Valid values are `60`, `120`, `300`, and `600`. Defaults to `300` (5 minutes).
               
               **NOTE:** This setting doesn't determine how often AWS WAF checks the rate, but how far back it looks each time it checks. AWS WAF checks the rate about every 10 seconds.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementForwardedIpConfigArgs'] forwarded_ip_config: Configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. If `aggregate_key_type` is set to `FORWARDED_IP`, this block is required. See `forwarded_ip_config` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementArgs'] scope_down_statement: Optional nested statement that narrows the scope of the rate-based statement to matching web requests. This can be any nestable statement, and you can nest statements at any level below this scope-down statement. See `statement` above for details. If `aggregate_key_type` is set to `CONSTANT`, this block is required.
        """
        pulumi.set(__self__, "limit", limit)
        if aggregate_key_type is not None:
            pulumi.set(__self__, "aggregate_key_type", aggregate_key_type)
        if custom_keys is not None:
            pulumi.set(__self__, "custom_keys", custom_keys)
        if evaluation_window_sec is not None:
            pulumi.set(__self__, "evaluation_window_sec", evaluation_window_sec)
        if forwarded_ip_config is not None:
            pulumi.set(__self__, "forwarded_ip_config", forwarded_ip_config)
        if scope_down_statement is not None:
            pulumi.set(__self__, "scope_down_statement", scope_down_statement)

    @property
    @pulumi.getter
    def limit(self) -> pulumi.Input[int]:
        """
        Limit on requests per 5-minute period for a single originating IP address.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: pulumi.Input[int]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="aggregateKeyType")
    def aggregate_key_type(self) -> Optional[pulumi.Input[str]]:
        """
        Setting that indicates how to aggregate the request counts. Valid values include: `CONSTANT`, `CUSTOM_KEYS`, `FORWARDED_IP`, or `IP`. Default: `IP`.
        """
        return pulumi.get(self, "aggregate_key_type")

    @aggregate_key_type.setter
    def aggregate_key_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregate_key_type", value)

    @property
    @pulumi.getter(name="customKeys")
    def custom_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyArgs']]]]:
        """
        Aggregate the request counts using one or more web request components as the aggregate keys. See `custom_key` below for details.
        """
        return pulumi.get(self, "custom_keys")

    @custom_keys.setter
    def custom_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyArgs']]]]):
        pulumi.set(self, "custom_keys", value)

    @property
    @pulumi.getter(name="evaluationWindowSec")
    def evaluation_window_sec(self) -> Optional[pulumi.Input[int]]:
        """
        The amount of time, in seconds, that AWS WAF should include in its request counts, looking back from the current time. Valid values are `60`, `120`, `300`, and `600`. Defaults to `300` (5 minutes).

        **NOTE:** This setting doesn't determine how often AWS WAF checks the rate, but how far back it looks each time it checks. AWS WAF checks the rate about every 10 seconds.
        """
        return pulumi.get(self, "evaluation_window_sec")

    @evaluation_window_sec.setter
    def evaluation_window_sec(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "evaluation_window_sec", value)

    @property
    @pulumi.getter(name="forwardedIpConfig")
    def forwarded_ip_config(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementForwardedIpConfigArgs']]:
        """
        Configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. If `aggregate_key_type` is set to `FORWARDED_IP`, this block is required. See `forwarded_ip_config` below for details.
        """
        return pulumi.get(self, "forwarded_ip_config")

    @forwarded_ip_config.setter
    def forwarded_ip_config(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementForwardedIpConfigArgs']]):
        pulumi.set(self, "forwarded_ip_config", value)

    @property
    @pulumi.getter(name="scopeDownStatement")
    def scope_down_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementArgs']]:
        """
        Optional nested statement that narrows the scope of the rate-based statement to matching web requests. This can be any nestable statement, and you can nest statements at any level below this scope-down statement. See `statement` above for details. If `aggregate_key_type` is set to `CONSTANT`, this block is required.
        """
        return pulumi.get(self, "scope_down_statement")

    @scope_down_statement.setter
    def scope_down_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementArgs']]):
        pulumi.set(self, "scope_down_statement", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementCustomKeyArgsDict(TypedDict):
        cookie: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyCookieArgsDict']]
        """
        Use the value of a cookie in the request as an aggregate key. See RateLimit `cookie` below for details.
        """
        forwarded_ip: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyForwardedIpArgsDict']]
        """
        Use the first IP address in an HTTP header as an aggregate key. See `forwarded_ip` below for details.
        """
        header: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyHeaderArgsDict']]
        """
        Use the value of a header in the request as an aggregate key. See RateLimit `header` below for details.
        """
        http_method: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyHttpMethodArgsDict']]
        """
        Use the request's HTTP method as an aggregate key. See RateLimit `http_method` below for details.
        """
        ip: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyIpArgsDict']]
        """
        Use the request's originating IP address as an aggregate key. See `RateLimit ip` below for details.
        """
        label_namespace: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyLabelNamespaceArgsDict']]
        """
        Use the specified label namespace as an aggregate key. See RateLimit `label_namespace` below for details.
        """
        query_argument: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyQueryArgumentArgsDict']]
        """
        Use the specified query argument as an aggregate key. See RateLimit `query_argument` below for details.
        """
        query_string: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyQueryStringArgsDict']]
        """
        Use the request's query string as an aggregate key. See RateLimit `query_string` below for details.
        """
        uri_path: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyUriPathArgsDict']]
        """
        Use the request's URI path as an aggregate key. See RateLimit `uri_path` below for details.
        """
elif False:
    WebAclRuleStatementRateBasedStatementCustomKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementCustomKeyArgs:
    def __init__(__self__, *,
                 cookie: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyCookieArgs']] = None,
                 forwarded_ip: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyForwardedIpArgs']] = None,
                 header: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyHeaderArgs']] = None,
                 http_method: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyHttpMethodArgs']] = None,
                 ip: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyIpArgs']] = None,
                 label_namespace: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyLabelNamespaceArgs']] = None,
                 query_argument: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyQueryArgumentArgs']] = None,
                 query_string: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyQueryStringArgs']] = None,
                 uri_path: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyUriPathArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyCookieArgs'] cookie: Use the value of a cookie in the request as an aggregate key. See RateLimit `cookie` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyForwardedIpArgs'] forwarded_ip: Use the first IP address in an HTTP header as an aggregate key. See `forwarded_ip` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyHeaderArgs'] header: Use the value of a header in the request as an aggregate key. See RateLimit `header` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyHttpMethodArgs'] http_method: Use the request's HTTP method as an aggregate key. See RateLimit `http_method` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyIpArgs'] ip: Use the request's originating IP address as an aggregate key. See `RateLimit ip` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyLabelNamespaceArgs'] label_namespace: Use the specified label namespace as an aggregate key. See RateLimit `label_namespace` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyQueryArgumentArgs'] query_argument: Use the specified query argument as an aggregate key. See RateLimit `query_argument` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyQueryStringArgs'] query_string: Use the request's query string as an aggregate key. See RateLimit `query_string` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyUriPathArgs'] uri_path: Use the request's URI path as an aggregate key. See RateLimit `uri_path` below for details.
        """
        if cookie is not None:
            pulumi.set(__self__, "cookie", cookie)
        if forwarded_ip is not None:
            pulumi.set(__self__, "forwarded_ip", forwarded_ip)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if http_method is not None:
            pulumi.set(__self__, "http_method", http_method)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if label_namespace is not None:
            pulumi.set(__self__, "label_namespace", label_namespace)
        if query_argument is not None:
            pulumi.set(__self__, "query_argument", query_argument)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter
    def cookie(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyCookieArgs']]:
        """
        Use the value of a cookie in the request as an aggregate key. See RateLimit `cookie` below for details.
        """
        return pulumi.get(self, "cookie")

    @cookie.setter
    def cookie(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyCookieArgs']]):
        pulumi.set(self, "cookie", value)

    @property
    @pulumi.getter(name="forwardedIp")
    def forwarded_ip(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyForwardedIpArgs']]:
        """
        Use the first IP address in an HTTP header as an aggregate key. See `forwarded_ip` below for details.
        """
        return pulumi.get(self, "forwarded_ip")

    @forwarded_ip.setter
    def forwarded_ip(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyForwardedIpArgs']]):
        pulumi.set(self, "forwarded_ip", value)

    @property
    @pulumi.getter
    def header(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyHeaderArgs']]:
        """
        Use the value of a header in the request as an aggregate key. See RateLimit `header` below for details.
        """
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyHeaderArgs']]):
        pulumi.set(self, "header", value)

    @property
    @pulumi.getter(name="httpMethod")
    def http_method(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyHttpMethodArgs']]:
        """
        Use the request's HTTP method as an aggregate key. See RateLimit `http_method` below for details.
        """
        return pulumi.get(self, "http_method")

    @http_method.setter
    def http_method(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyHttpMethodArgs']]):
        pulumi.set(self, "http_method", value)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyIpArgs']]:
        """
        Use the request's originating IP address as an aggregate key. See `RateLimit ip` below for details.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyIpArgs']]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter(name="labelNamespace")
    def label_namespace(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyLabelNamespaceArgs']]:
        """
        Use the specified label namespace as an aggregate key. See RateLimit `label_namespace` below for details.
        """
        return pulumi.get(self, "label_namespace")

    @label_namespace.setter
    def label_namespace(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyLabelNamespaceArgs']]):
        pulumi.set(self, "label_namespace", value)

    @property
    @pulumi.getter(name="queryArgument")
    def query_argument(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyQueryArgumentArgs']]:
        """
        Use the specified query argument as an aggregate key. See RateLimit `query_argument` below for details.
        """
        return pulumi.get(self, "query_argument")

    @query_argument.setter
    def query_argument(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyQueryArgumentArgs']]):
        pulumi.set(self, "query_argument", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyQueryStringArgs']]:
        """
        Use the request's query string as an aggregate key. See RateLimit `query_string` below for details.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyUriPathArgs']]:
        """
        Use the request's URI path as an aggregate key. See RateLimit `uri_path` below for details.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementCustomKeyCookieArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the cookie to use.
        """
        text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyCookieTextTransformationArgsDict']]]
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. They are used in rate-based rule statements, to transform request components before using them as custom aggregation keys. Atleast one transformation is required. See `text_transformation` above for details.
        """
elif False:
    WebAclRuleStatementRateBasedStatementCustomKeyCookieArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementCustomKeyCookieArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyCookieTextTransformationArgs']]]):
        """
        :param pulumi.Input[str] name: The name of the cookie to use.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyCookieTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. They are used in rate-based rule statements, to transform request components before using them as custom aggregation keys. Atleast one transformation is required. See `text_transformation` above for details.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the cookie to use.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyCookieTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. They are used in rate-based rule statements, to transform request components before using them as custom aggregation keys. Atleast one transformation is required. See `text_transformation` above for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyCookieTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementCustomKeyCookieTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[int]
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        type: pulumi.Input[str]
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
elif False:
    WebAclRuleStatementRateBasedStatementCustomKeyCookieTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementCustomKeyCookieTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementCustomKeyForwardedIpArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementCustomKeyForwardedIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementCustomKeyForwardedIpArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementCustomKeyHeaderArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the header to use.
        """
        text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyHeaderTextTransformationArgsDict']]]
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. They are used in rate-based rule statements, to transform request components before using them as custom aggregation keys. Atleast one transformation is required. See `text_transformation` above for details.
        """
elif False:
    WebAclRuleStatementRateBasedStatementCustomKeyHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementCustomKeyHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyHeaderTextTransformationArgs']]]):
        """
        :param pulumi.Input[str] name: The name of the header to use.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyHeaderTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. They are used in rate-based rule statements, to transform request components before using them as custom aggregation keys. Atleast one transformation is required. See `text_transformation` above for details.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the header to use.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyHeaderTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. They are used in rate-based rule statements, to transform request components before using them as custom aggregation keys. Atleast one transformation is required. See `text_transformation` above for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyHeaderTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementCustomKeyHeaderTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[int]
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        type: pulumi.Input[str]
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
elif False:
    WebAclRuleStatementRateBasedStatementCustomKeyHeaderTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementCustomKeyHeaderTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementCustomKeyHttpMethodArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementCustomKeyHttpMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementCustomKeyHttpMethodArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementCustomKeyIpArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementCustomKeyIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementCustomKeyIpArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementCustomKeyLabelNamespaceArgsDict(TypedDict):
        namespace: pulumi.Input[str]
        """
        The namespace to use for aggregation
        """
elif False:
    WebAclRuleStatementRateBasedStatementCustomKeyLabelNamespaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementCustomKeyLabelNamespaceArgs:
    def __init__(__self__, *,
                 namespace: pulumi.Input[str]):
        """
        :param pulumi.Input[str] namespace: The namespace to use for aggregation
        """
        pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[str]:
        """
        The namespace to use for aggregation
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[str]):
        pulumi.set(self, "namespace", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementCustomKeyQueryArgumentArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the query argument to use.
        """
        text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformationArgsDict']]]
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. They are used in rate-based rule statements, to transform request components before using them as custom aggregation keys. Atleast one transformation is required. See `text_transformation` above for details.
        """
elif False:
    WebAclRuleStatementRateBasedStatementCustomKeyQueryArgumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementCustomKeyQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformationArgs']]]):
        """
        :param pulumi.Input[str] name: The name of the query argument to use.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. They are used in rate-based rule statements, to transform request components before using them as custom aggregation keys. Atleast one transformation is required. See `text_transformation` above for details.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query argument to use.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. They are used in rate-based rule statements, to transform request components before using them as custom aggregation keys. Atleast one transformation is required. See `text_transformation` above for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[int]
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        type: pulumi.Input[str]
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
elif False:
    WebAclRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementCustomKeyQueryStringArgsDict(TypedDict):
        text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformationArgsDict']]]
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. They are used in rate-based rule statements, to transform request components before using them as custom aggregation keys. Atleast one transformation is required. See `text_transformation` above for details.
        """
elif False:
    WebAclRuleStatementRateBasedStatementCustomKeyQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementCustomKeyQueryStringArgs:
    def __init__(__self__, *,
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformationArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. They are used in rate-based rule statements, to transform request components before using them as custom aggregation keys. Atleast one transformation is required. See `text_transformation` above for details.
        """
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. They are used in rate-based rule statements, to transform request components before using them as custom aggregation keys. Atleast one transformation is required. See `text_transformation` above for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[int]
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        type: pulumi.Input[str]
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
elif False:
    WebAclRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementCustomKeyUriPathArgsDict(TypedDict):
        text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyUriPathTextTransformationArgsDict']]]
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. They are used in rate-based rule statements, to transform request components before using them as custom aggregation keys. Atleast one transformation is required. See `text_transformation` above for details.
        """
elif False:
    WebAclRuleStatementRateBasedStatementCustomKeyUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementCustomKeyUriPathArgs:
    def __init__(__self__, *,
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyUriPathTextTransformationArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyUriPathTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. They are used in rate-based rule statements, to transform request components before using them as custom aggregation keys. Atleast one transformation is required. See `text_transformation` above for details.
        """
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyUriPathTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. They are used in rate-based rule statements, to transform request components before using them as custom aggregation keys. Atleast one transformation is required. See `text_transformation` above for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyUriPathTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementCustomKeyUriPathTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[int]
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        type: pulumi.Input[str]
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
elif False:
    WebAclRuleStatementRateBasedStatementCustomKeyUriPathTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementCustomKeyUriPathTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementForwardedIpConfigArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[str]
        """
        Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        header_name: pulumi.Input[str]
        """
        Name of the HTTP header to use for the IP address.
        """
elif False:
    WebAclRuleStatementRateBasedStatementForwardedIpConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementForwardedIpConfigArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str],
                 header_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        :param pulumi.Input[str] header_name: Name of the HTTP header to use for the IP address.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> pulumi.Input[str]:
        """
        Name of the HTTP header to use for the IP address.
        """
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "header_name", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementArgsDict(TypedDict):
        and_statement: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementAndStatementArgsDict']]
        """
        Logical rule statement used to combine other rule statements with AND logic. See `and_statement` below for details.
        """
        byte_match_statement: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementArgsDict']]
        """
        Rule statement that defines a string match search for AWS WAF to apply to web requests. See `byte_match_statement` below for details.
        """
        geo_match_statement: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementArgsDict']]
        """
        Rule statement used to identify web requests based on country of origin. See `geo_match_statement` below for details.
        """
        ip_set_reference_statement: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementArgsDict']]
        """
        Rule statement used to detect web requests coming from particular IP addresses or address ranges. See `ip_set_reference_statement` below for details.
        """
        label_match_statement: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatementArgsDict']]
        """
        Rule statement that defines a string match search against labels that have been added to the web request by rules that have already run in the web ACL. See `label_match_statement` below for details.
        """
        not_statement: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementNotStatementArgsDict']]
        """
        Logical rule statement used to negate the results of another rule statement. See `not_statement` below for details.
        """
        or_statement: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementOrStatementArgsDict']]
        """
        Logical rule statement used to combine other rule statements with OR logic. See `or_statement` below for details.
        """
        regex_match_statement: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementArgsDict']]
        """
        Rule statement used to search web request components for a match against a single regular expression. See `regex_match_statement` below for details.
        """
        regex_pattern_set_reference_statement: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementArgsDict']]
        """
        Rule statement used to search web request components for matches with regular expressions. See `regex_pattern_set_reference_statement` below for details.
        """
        size_constraint_statement: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementArgsDict']]
        """
        Rule statement that compares a number of bytes against the size of a request component, using a comparison operator, such as greater than (>) or less than (<). See `size_constraint_statement` below for more details.
        """
        sqli_match_statement: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementArgsDict']]
        """
        An SQL injection match condition identifies the part of web requests, such as the URI or the query string, that you want AWS WAF to inspect. See `sqli_match_statement` below for details.
        """
        xss_match_statement: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementArgsDict']]
        """
        Rule statement that defines a cross-site scripting (XSS) match search for AWS WAF to apply to web requests. See `xss_match_statement` below for details.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementArgs:
    def __init__(__self__, *,
                 and_statement: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementAndStatementArgs']] = None,
                 byte_match_statement: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementArgs']] = None,
                 geo_match_statement: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementArgs']] = None,
                 ip_set_reference_statement: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementArgs']] = None,
                 label_match_statement: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatementArgs']] = None,
                 not_statement: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementNotStatementArgs']] = None,
                 or_statement: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementOrStatementArgs']] = None,
                 regex_match_statement: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementArgs']] = None,
                 regex_pattern_set_reference_statement: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementArgs']] = None,
                 size_constraint_statement: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementArgs']] = None,
                 sqli_match_statement: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementArgs']] = None,
                 xss_match_statement: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementAndStatementArgs'] and_statement: Logical rule statement used to combine other rule statements with AND logic. See `and_statement` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementArgs'] byte_match_statement: Rule statement that defines a string match search for AWS WAF to apply to web requests. See `byte_match_statement` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementArgs'] geo_match_statement: Rule statement used to identify web requests based on country of origin. See `geo_match_statement` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementArgs'] ip_set_reference_statement: Rule statement used to detect web requests coming from particular IP addresses or address ranges. See `ip_set_reference_statement` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatementArgs'] label_match_statement: Rule statement that defines a string match search against labels that have been added to the web request by rules that have already run in the web ACL. See `label_match_statement` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementNotStatementArgs'] not_statement: Logical rule statement used to negate the results of another rule statement. See `not_statement` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementOrStatementArgs'] or_statement: Logical rule statement used to combine other rule statements with OR logic. See `or_statement` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementArgs'] regex_match_statement: Rule statement used to search web request components for a match against a single regular expression. See `regex_match_statement` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementArgs'] regex_pattern_set_reference_statement: Rule statement used to search web request components for matches with regular expressions. See `regex_pattern_set_reference_statement` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementArgs'] size_constraint_statement: Rule statement that compares a number of bytes against the size of a request component, using a comparison operator, such as greater than (>) or less than (<). See `size_constraint_statement` below for more details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementArgs'] sqli_match_statement: An SQL injection match condition identifies the part of web requests, such as the URI or the query string, that you want AWS WAF to inspect. See `sqli_match_statement` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementArgs'] xss_match_statement: Rule statement that defines a cross-site scripting (XSS) match search for AWS WAF to apply to web requests. See `xss_match_statement` below for details.
        """
        if and_statement is not None:
            pulumi.set(__self__, "and_statement", and_statement)
        if byte_match_statement is not None:
            pulumi.set(__self__, "byte_match_statement", byte_match_statement)
        if geo_match_statement is not None:
            pulumi.set(__self__, "geo_match_statement", geo_match_statement)
        if ip_set_reference_statement is not None:
            pulumi.set(__self__, "ip_set_reference_statement", ip_set_reference_statement)
        if label_match_statement is not None:
            pulumi.set(__self__, "label_match_statement", label_match_statement)
        if not_statement is not None:
            pulumi.set(__self__, "not_statement", not_statement)
        if or_statement is not None:
            pulumi.set(__self__, "or_statement", or_statement)
        if regex_match_statement is not None:
            pulumi.set(__self__, "regex_match_statement", regex_match_statement)
        if regex_pattern_set_reference_statement is not None:
            pulumi.set(__self__, "regex_pattern_set_reference_statement", regex_pattern_set_reference_statement)
        if size_constraint_statement is not None:
            pulumi.set(__self__, "size_constraint_statement", size_constraint_statement)
        if sqli_match_statement is not None:
            pulumi.set(__self__, "sqli_match_statement", sqli_match_statement)
        if xss_match_statement is not None:
            pulumi.set(__self__, "xss_match_statement", xss_match_statement)

    @property
    @pulumi.getter(name="andStatement")
    def and_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementAndStatementArgs']]:
        """
        Logical rule statement used to combine other rule statements with AND logic. See `and_statement` below for details.
        """
        return pulumi.get(self, "and_statement")

    @and_statement.setter
    def and_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementAndStatementArgs']]):
        pulumi.set(self, "and_statement", value)

    @property
    @pulumi.getter(name="byteMatchStatement")
    def byte_match_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementArgs']]:
        """
        Rule statement that defines a string match search for AWS WAF to apply to web requests. See `byte_match_statement` below for details.
        """
        return pulumi.get(self, "byte_match_statement")

    @byte_match_statement.setter
    def byte_match_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementArgs']]):
        pulumi.set(self, "byte_match_statement", value)

    @property
    @pulumi.getter(name="geoMatchStatement")
    def geo_match_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementArgs']]:
        """
        Rule statement used to identify web requests based on country of origin. See `geo_match_statement` below for details.
        """
        return pulumi.get(self, "geo_match_statement")

    @geo_match_statement.setter
    def geo_match_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementArgs']]):
        pulumi.set(self, "geo_match_statement", value)

    @property
    @pulumi.getter(name="ipSetReferenceStatement")
    def ip_set_reference_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementArgs']]:
        """
        Rule statement used to detect web requests coming from particular IP addresses or address ranges. See `ip_set_reference_statement` below for details.
        """
        return pulumi.get(self, "ip_set_reference_statement")

    @ip_set_reference_statement.setter
    def ip_set_reference_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementArgs']]):
        pulumi.set(self, "ip_set_reference_statement", value)

    @property
    @pulumi.getter(name="labelMatchStatement")
    def label_match_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatementArgs']]:
        """
        Rule statement that defines a string match search against labels that have been added to the web request by rules that have already run in the web ACL. See `label_match_statement` below for details.
        """
        return pulumi.get(self, "label_match_statement")

    @label_match_statement.setter
    def label_match_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatementArgs']]):
        pulumi.set(self, "label_match_statement", value)

    @property
    @pulumi.getter(name="notStatement")
    def not_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementNotStatementArgs']]:
        """
        Logical rule statement used to negate the results of another rule statement. See `not_statement` below for details.
        """
        return pulumi.get(self, "not_statement")

    @not_statement.setter
    def not_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementNotStatementArgs']]):
        pulumi.set(self, "not_statement", value)

    @property
    @pulumi.getter(name="orStatement")
    def or_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementOrStatementArgs']]:
        """
        Logical rule statement used to combine other rule statements with OR logic. See `or_statement` below for details.
        """
        return pulumi.get(self, "or_statement")

    @or_statement.setter
    def or_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementOrStatementArgs']]):
        pulumi.set(self, "or_statement", value)

    @property
    @pulumi.getter(name="regexMatchStatement")
    def regex_match_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementArgs']]:
        """
        Rule statement used to search web request components for a match against a single regular expression. See `regex_match_statement` below for details.
        """
        return pulumi.get(self, "regex_match_statement")

    @regex_match_statement.setter
    def regex_match_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementArgs']]):
        pulumi.set(self, "regex_match_statement", value)

    @property
    @pulumi.getter(name="regexPatternSetReferenceStatement")
    def regex_pattern_set_reference_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementArgs']]:
        """
        Rule statement used to search web request components for matches with regular expressions. See `regex_pattern_set_reference_statement` below for details.
        """
        return pulumi.get(self, "regex_pattern_set_reference_statement")

    @regex_pattern_set_reference_statement.setter
    def regex_pattern_set_reference_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementArgs']]):
        pulumi.set(self, "regex_pattern_set_reference_statement", value)

    @property
    @pulumi.getter(name="sizeConstraintStatement")
    def size_constraint_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementArgs']]:
        """
        Rule statement that compares a number of bytes against the size of a request component, using a comparison operator, such as greater than (>) or less than (<). See `size_constraint_statement` below for more details.
        """
        return pulumi.get(self, "size_constraint_statement")

    @size_constraint_statement.setter
    def size_constraint_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementArgs']]):
        pulumi.set(self, "size_constraint_statement", value)

    @property
    @pulumi.getter(name="sqliMatchStatement")
    def sqli_match_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementArgs']]:
        """
        An SQL injection match condition identifies the part of web requests, such as the URI or the query string, that you want AWS WAF to inspect. See `sqli_match_statement` below for details.
        """
        return pulumi.get(self, "sqli_match_statement")

    @sqli_match_statement.setter
    def sqli_match_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementArgs']]):
        pulumi.set(self, "sqli_match_statement", value)

    @property
    @pulumi.getter(name="xssMatchStatement")
    def xss_match_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementArgs']]:
        """
        Rule statement that defines a cross-site scripting (XSS) match search for AWS WAF to apply to web requests. See `xss_match_statement` below for details.
        """
        return pulumi.get(self, "xss_match_statement")

    @xss_match_statement.setter
    def xss_match_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementArgs']]):
        pulumi.set(self, "xss_match_statement", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementAndStatementArgsDict(TypedDict):
        statements: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgsDict']]]
        """
        The statements to combine.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementAndStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementAndStatementArgs:
    def __init__(__self__, *,
                 statements: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]] statements: The statements to combine.
        """
        pulumi.set(__self__, "statements", statements)

    @property
    @pulumi.getter
    def statements(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")

    @statements.setter
    def statements(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]):
        pulumi.set(self, "statements", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementArgsDict(TypedDict):
        positional_constraint: pulumi.Input[str]
        """
        Area within the portion of a web request that you want AWS WAF to search for `search_string`. Valid values include the following: `EXACTLY`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CONTAINS_WORD`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_ByteMatchStatement.html) for more information.
        """
        search_string: pulumi.Input[str]
        """
        String value that you want AWS WAF to search for. AWS WAF searches only in the part of web requests that you designate for inspection in `field_to_match`. The maximum length of the value is 50 bytes.
        """
        text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformationArgsDict']]]
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        field_to_match: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchArgsDict']]
        """
        Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementArgs:
    def __init__(__self__, *,
                 positional_constraint: pulumi.Input[str],
                 search_string: pulumi.Input[str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchArgs']] = None):
        """
        :param pulumi.Input[str] positional_constraint: Area within the portion of a web request that you want AWS WAF to search for `search_string`. Valid values include the following: `EXACTLY`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CONTAINS_WORD`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_ByteMatchStatement.html) for more information.
        :param pulumi.Input[str] search_string: String value that you want AWS WAF to search for. AWS WAF searches only in the part of web requests that you designate for inspection in `field_to_match`. The maximum length of the value is 50 bytes.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchArgs'] field_to_match: Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        pulumi.set(__self__, "positional_constraint", positional_constraint)
        pulumi.set(__self__, "search_string", search_string)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @property
    @pulumi.getter(name="positionalConstraint")
    def positional_constraint(self) -> pulumi.Input[str]:
        """
        Area within the portion of a web request that you want AWS WAF to search for `search_string`. Valid values include the following: `EXACTLY`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CONTAINS_WORD`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_ByteMatchStatement.html) for more information.
        """
        return pulumi.get(self, "positional_constraint")

    @positional_constraint.setter
    def positional_constraint(self, value: pulumi.Input[str]):
        pulumi.set(self, "positional_constraint", value)

    @property
    @pulumi.getter(name="searchString")
    def search_string(self) -> pulumi.Input[str]:
        """
        String value that you want AWS WAF to search for. AWS WAF searches only in the part of web requests that you designate for inspection in `field_to_match`. The maximum length of the value is 50 bytes.
        """
        return pulumi.get(self, "search_string")

    @search_string.setter
    def search_string(self, value: pulumi.Input[str]):
        pulumi.set(self, "search_string", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchArgs']]:
        """
        Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchArgsDict(TypedDict):
        all_query_arguments: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgsDict']]
        """
        Inspect all query arguments.
        """
        body: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgsDict']]
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        cookies: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgsDict']]
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        header_orders: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgsDict']]]]
        """
        Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgsDict']]]]
        """
        Inspect the request headers. See `headers` below for details.
        """
        ja3_fingerprint: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgsDict']]
        """
        Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        """
        json_body: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgsDict']]
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        method: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgsDict']]
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        query_string: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgsDict']]
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        single_header: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgsDict']]
        """
        Inspect a single header. See `single_header` below for details.
        """
        single_query_argument: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgsDict']]
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        uri_path: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgsDict']]
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_path: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs'] all_query_arguments: Inspect all query arguments.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgs'] body: Inspect the request body, which immediately follows the request headers. See `body` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgs'] cookies: Inspect the cookies in the web request. See `cookies` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgs']]] header_orders: Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgs']]] headers: Inspect the request headers. See `headers` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgs'] ja3_fingerprint: Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgs'] json_body: Inspect the request body as JSON. See `json_body` for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgs'] method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgs'] query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgs'] single_header: Inspect a single header. See `single_header` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs'] single_query_argument: Inspect a single query argument. See `single_query_argument` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgs'] uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs']]:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgs']]:
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgs']]:
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgs']]]]:
        """
        Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        """
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgs']]]]:
        """
        Inspect the request headers. See `headers` below for details.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgs']]:
        """
        Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        """
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgs']]:
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgs']]:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgs']]:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgs']]:
        """
        Inspect a single header. See `single_header` below for details.
        """
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs']]:
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgs']]:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgsDict(TypedDict):
        oversize_handling: NotRequired[pulumi.Input[str]]
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] oversize_handling: What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgsDict(TypedDict):
        match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgsDict']]]
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        oversize_handling: pulumi.Input[str]
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs']]] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param pulumi.Input[str] match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs']]]:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        excluded_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        included_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_cookies", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgsDict']
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        oversize_handling: pulumi.Input[str]
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs'] match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param pulumi.Input[str] match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs']:
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        excluded_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        included_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_headers", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgsDict(TypedDict):
        oversize_handling: pulumi.Input[str]
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[str]
        """
        The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict']
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        invalid_fallback_behavior: NotRequired[pulumi.Input[str]]
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        oversize_handling: NotRequired[pulumi.Input[str]]
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 invalid_fallback_behavior: Optional[pulumi.Input[str]] = None,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs'] match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param pulumi.Input[str] match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param pulumi.Input[str] invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param pulumi.Input[str] oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs']:
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        included_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_paths", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[int]
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        type: pulumi.Input[str]
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementArgsDict(TypedDict):
        country_codes: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Array of two-character country codes, for example, [ "US", "CN" ], from the alpha-2 country ISO codes of the `ISO 3166` international standard. See the [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_GeoMatchStatement.html) for valid values.
        """
        forwarded_ip_config: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgsDict']]
        """
        Configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See `forwarded_ip_config` below for details.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementArgs:
    def __init__(__self__, *,
                 country_codes: pulumi.Input[Sequence[pulumi.Input[str]]],
                 forwarded_ip_config: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] country_codes: Array of two-character country codes, for example, [ "US", "CN" ], from the alpha-2 country ISO codes of the `ISO 3166` international standard. See the [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_GeoMatchStatement.html) for valid values.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgs'] forwarded_ip_config: Configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See `forwarded_ip_config` below for details.
        """
        pulumi.set(__self__, "country_codes", country_codes)
        if forwarded_ip_config is not None:
            pulumi.set(__self__, "forwarded_ip_config", forwarded_ip_config)

    @property
    @pulumi.getter(name="countryCodes")
    def country_codes(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Array of two-character country codes, for example, [ "US", "CN" ], from the alpha-2 country ISO codes of the `ISO 3166` international standard. See the [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_GeoMatchStatement.html) for valid values.
        """
        return pulumi.get(self, "country_codes")

    @country_codes.setter
    def country_codes(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "country_codes", value)

    @property
    @pulumi.getter(name="forwardedIpConfig")
    def forwarded_ip_config(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgs']]:
        """
        Configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See `forwarded_ip_config` below for details.
        """
        return pulumi.get(self, "forwarded_ip_config")

    @forwarded_ip_config.setter
    def forwarded_ip_config(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgs']]):
        pulumi.set(self, "forwarded_ip_config", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[str]
        """
        Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        header_name: pulumi.Input[str]
        """
        Name of the HTTP header to use for the IP address.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str],
                 header_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        :param pulumi.Input[str] header_name: Name of the HTTP header to use for the IP address.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> pulumi.Input[str]:
        """
        Name of the HTTP header to use for the IP address.
        """
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "header_name", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementArgsDict(TypedDict):
        arn: pulumi.Input[str]
        """
        The Amazon Resource Name (ARN) of the IP Set that this statement references.
        """
        ip_set_forwarded_ip_config: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgsDict']]
        """
        Configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See `ip_set_forwarded_ip_config` below for more details.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[str],
                 ip_set_forwarded_ip_config: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs']] = None):
        """
        :param pulumi.Input[str] arn: The Amazon Resource Name (ARN) of the IP Set that this statement references.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs'] ip_set_forwarded_ip_config: Configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See `ip_set_forwarded_ip_config` below for more details.
        """
        pulumi.set(__self__, "arn", arn)
        if ip_set_forwarded_ip_config is not None:
            pulumi.set(__self__, "ip_set_forwarded_ip_config", ip_set_forwarded_ip_config)

    @property
    @pulumi.getter
    def arn(self) -> pulumi.Input[str]:
        """
        The Amazon Resource Name (ARN) of the IP Set that this statement references.
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "arn", value)

    @property
    @pulumi.getter(name="ipSetForwardedIpConfig")
    def ip_set_forwarded_ip_config(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs']]:
        """
        Configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See `ip_set_forwarded_ip_config` below for more details.
        """
        return pulumi.get(self, "ip_set_forwarded_ip_config")

    @ip_set_forwarded_ip_config.setter
    def ip_set_forwarded_ip_config(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs']]):
        pulumi.set(self, "ip_set_forwarded_ip_config", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[str]
        """
        Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        header_name: pulumi.Input[str]
        """
        Name of the HTTP header to use for the IP address.
        """
        position: pulumi.Input[str]
        """
        Position in the header to search for the IP address. Valid values include: `FIRST`, `LAST`, or `ANY`. If `ANY` is specified and the header contains more than 10 IP addresses, AWS WAFv2 inspects the last 10.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str],
                 header_name: pulumi.Input[str],
                 position: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        :param pulumi.Input[str] header_name: Name of the HTTP header to use for the IP address.
        :param pulumi.Input[str] position: Position in the header to search for the IP address. Valid values include: `FIRST`, `LAST`, or `ANY`. If `ANY` is specified and the header contains more than 10 IP addresses, AWS WAFv2 inspects the last 10.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "position", position)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> pulumi.Input[str]:
        """
        Name of the HTTP header to use for the IP address.
        """
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "header_name", value)

    @property
    @pulumi.getter
    def position(self) -> pulumi.Input[str]:
        """
        Position in the header to search for the IP address. Valid values include: `FIRST`, `LAST`, or `ANY`. If `ANY` is specified and the header contains more than 10 IP addresses, AWS WAFv2 inspects the last 10.
        """
        return pulumi.get(self, "position")

    @position.setter
    def position(self, value: pulumi.Input[str]):
        pulumi.set(self, "position", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatementArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        String to match against.
        """
        scope: pulumi.Input[str]
        """
        Specify whether you want to match using the label name or just the namespace. Valid values are `LABEL` or `NAMESPACE`.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatementArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 scope: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: String to match against.
        :param pulumi.Input[str] scope: Specify whether you want to match using the label name or just the namespace. Valid values are `LABEL` or `NAMESPACE`.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        String to match against.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def scope(self) -> pulumi.Input[str]:
        """
        Specify whether you want to match using the label name or just the namespace. Valid values are `LABEL` or `NAMESPACE`.
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "scope", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementNotStatementArgsDict(TypedDict):
        statements: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgsDict']]]
        """
        The statements to combine.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementNotStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementNotStatementArgs:
    def __init__(__self__, *,
                 statements: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]] statements: The statements to combine.
        """
        pulumi.set(__self__, "statements", statements)

    @property
    @pulumi.getter
    def statements(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")

    @statements.setter
    def statements(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]):
        pulumi.set(self, "statements", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementOrStatementArgsDict(TypedDict):
        statements: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgsDict']]]
        """
        The statements to combine.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementOrStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementOrStatementArgs:
    def __init__(__self__, *,
                 statements: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]] statements: The statements to combine.
        """
        pulumi.set(__self__, "statements", statements)

    @property
    @pulumi.getter
    def statements(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")

    @statements.setter
    def statements(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]):
        pulumi.set(self, "statements", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementArgsDict(TypedDict):
        regex_string: pulumi.Input[str]
        """
        String representing the regular expression. Minimum of `1` and maximum of `512` characters.
        """
        text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformationArgsDict']]]
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        field_to_match: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchArgsDict']]
        """
        The part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementArgs:
    def __init__(__self__, *,
                 regex_string: pulumi.Input[str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchArgs']] = None):
        """
        :param pulumi.Input[str] regex_string: String representing the regular expression. Minimum of `1` and maximum of `512` characters.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchArgs'] field_to_match: The part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        pulumi.set(__self__, "regex_string", regex_string)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @property
    @pulumi.getter(name="regexString")
    def regex_string(self) -> pulumi.Input[str]:
        """
        String representing the regular expression. Minimum of `1` and maximum of `512` characters.
        """
        return pulumi.get(self, "regex_string")

    @regex_string.setter
    def regex_string(self, value: pulumi.Input[str]):
        pulumi.set(self, "regex_string", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchArgs']]:
        """
        The part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchArgsDict(TypedDict):
        all_query_arguments: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgsDict']]
        """
        Inspect all query arguments.
        """
        body: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgsDict']]
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        cookies: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgsDict']]
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        header_orders: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgsDict']]]]
        """
        Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgsDict']]]]
        """
        Inspect the request headers. See `headers` below for details.
        """
        ja3_fingerprint: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgsDict']]
        """
        Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        """
        json_body: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgsDict']]
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        method: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgsDict']]
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        query_string: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgsDict']]
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        single_header: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgsDict']]
        """
        Inspect a single header. See `single_header` below for details.
        """
        single_query_argument: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgsDict']]
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        uri_path: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgsDict']]
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_path: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs'] all_query_arguments: Inspect all query arguments.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgs'] body: Inspect the request body, which immediately follows the request headers. See `body` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgs'] cookies: Inspect the cookies in the web request. See `cookies` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgs']]] header_orders: Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgs']]] headers: Inspect the request headers. See `headers` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs'] ja3_fingerprint: Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgs'] json_body: Inspect the request body as JSON. See `json_body` for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgs'] method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgs'] query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgs'] single_header: Inspect a single header. See `single_header` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs'] single_query_argument: Inspect a single query argument. See `single_query_argument` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgs'] uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs']]:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgs']]:
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgs']]:
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgs']]]]:
        """
        Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        """
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgs']]]]:
        """
        Inspect the request headers. See `headers` below for details.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs']]:
        """
        Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        """
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgs']]:
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgs']]:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgs']]:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgs']]:
        """
        Inspect a single header. See `single_header` below for details.
        """
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs']]:
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgs']]:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgsDict(TypedDict):
        oversize_handling: NotRequired[pulumi.Input[str]]
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] oversize_handling: What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgsDict(TypedDict):
        match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgsDict']]]
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        oversize_handling: pulumi.Input[str]
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs']]] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param pulumi.Input[str] match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs']]]:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        excluded_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        included_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_cookies", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgsDict']
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        oversize_handling: pulumi.Input[str]
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs'] match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param pulumi.Input[str] match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs']:
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        excluded_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        included_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_headers", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgsDict(TypedDict):
        oversize_handling: pulumi.Input[str]
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[str]
        """
        The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict']
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        invalid_fallback_behavior: NotRequired[pulumi.Input[str]]
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        oversize_handling: NotRequired[pulumi.Input[str]]
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 invalid_fallback_behavior: Optional[pulumi.Input[str]] = None,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs'] match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param pulumi.Input[str] match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param pulumi.Input[str] invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param pulumi.Input[str] oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs']:
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        included_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_paths", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[int]
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        type: pulumi.Input[str]
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementArgsDict(TypedDict):
        arn: pulumi.Input[str]
        """
        The Amazon Resource Name (ARN) of the Regex Pattern Set that this statement references.
        """
        text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgsDict']]]
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        field_to_match: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgsDict']]
        """
        Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgs']] = None):
        """
        :param pulumi.Input[str] arn: The Amazon Resource Name (ARN) of the Regex Pattern Set that this statement references.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgs'] field_to_match: Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @property
    @pulumi.getter
    def arn(self) -> pulumi.Input[str]:
        """
        The Amazon Resource Name (ARN) of the Regex Pattern Set that this statement references.
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "arn", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgs']]:
        """
        Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgsDict(TypedDict):
        all_query_arguments: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgsDict']]
        """
        Inspect all query arguments.
        """
        body: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgsDict']]
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        cookies: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgsDict']]
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        header_orders: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgsDict']]]]
        """
        Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgsDict']]]]
        """
        Inspect the request headers. See `headers` below for details.
        """
        ja3_fingerprint: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgsDict']]
        """
        Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        """
        json_body: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgsDict']]
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        method: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgsDict']]
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        query_string: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgsDict']]
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        single_header: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgsDict']]
        """
        Inspect a single header. See `single_header` below for details.
        """
        single_query_argument: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgsDict']]
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        uri_path: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgsDict']]
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_path: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs'] all_query_arguments: Inspect all query arguments.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs'] body: Inspect the request body, which immediately follows the request headers. See `body` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs'] cookies: Inspect the cookies in the web request. See `cookies` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs']]] header_orders: Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs']]] headers: Inspect the request headers. See `headers` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs'] ja3_fingerprint: Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs'] json_body: Inspect the request body as JSON. See `json_body` for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs'] method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs'] query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs'] single_header: Inspect a single header. See `single_header` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs'] single_query_argument: Inspect a single query argument. See `single_query_argument` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs'] uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs']]:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs']]:
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs']]:
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs']]]]:
        """
        Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        """
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs']]]]:
        """
        Inspect the request headers. See `headers` below for details.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs']]:
        """
        Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        """
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs']]:
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs']]:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs']]:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs']]:
        """
        Inspect a single header. See `single_header` below for details.
        """
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs']]:
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs']]:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgsDict(TypedDict):
        oversize_handling: NotRequired[pulumi.Input[str]]
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] oversize_handling: What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgsDict(TypedDict):
        match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgsDict']]]
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        oversize_handling: pulumi.Input[str]
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs']]] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param pulumi.Input[str] match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs']]]:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        excluded_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        included_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_cookies", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgsDict']
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        oversize_handling: pulumi.Input[str]
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs'] match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param pulumi.Input[str] match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs']:
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        excluded_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        included_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_headers", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgsDict(TypedDict):
        oversize_handling: pulumi.Input[str]
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[str]
        """
        The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgsDict']
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        invalid_fallback_behavior: NotRequired[pulumi.Input[str]]
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        oversize_handling: NotRequired[pulumi.Input[str]]
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 invalid_fallback_behavior: Optional[pulumi.Input[str]] = None,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs'] match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param pulumi.Input[str] match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param pulumi.Input[str] invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param pulumi.Input[str] oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs']:
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        included_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_paths", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[int]
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        type: pulumi.Input[str]
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementArgsDict(TypedDict):
        comparison_operator: pulumi.Input[str]
        """
        Operator to use to compare the request part to the size setting. Valid values include: `EQ`, `NE`, `LE`, `LT`, `GE`, or `GT`.
        """
        size: pulumi.Input[int]
        """
        Size, in bytes, to compare to the request part, after any transformations. Valid values are integers between 0 and 21474836480, inclusive.
        """
        text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformationArgsDict']]]
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        field_to_match: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgsDict']]
        """
        Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementArgs:
    def __init__(__self__, *,
                 comparison_operator: pulumi.Input[str],
                 size: pulumi.Input[int],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgs']] = None):
        """
        :param pulumi.Input[str] comparison_operator: Operator to use to compare the request part to the size setting. Valid values include: `EQ`, `NE`, `LE`, `LT`, `GE`, or `GT`.
        :param pulumi.Input[int] size: Size, in bytes, to compare to the request part, after any transformations. Valid values are integers between 0 and 21474836480, inclusive.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgs'] field_to_match: Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        pulumi.set(__self__, "comparison_operator", comparison_operator)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> pulumi.Input[str]:
        """
        Operator to use to compare the request part to the size setting. Valid values include: `EQ`, `NE`, `LE`, `LT`, `GE`, or `GT`.
        """
        return pulumi.get(self, "comparison_operator")

    @comparison_operator.setter
    def comparison_operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "comparison_operator", value)

    @property
    @pulumi.getter
    def size(self) -> pulumi.Input[int]:
        """
        Size, in bytes, to compare to the request part, after any transformations. Valid values are integers between 0 and 21474836480, inclusive.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[int]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgs']]:
        """
        Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgsDict(TypedDict):
        all_query_arguments: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgsDict']]
        """
        Inspect all query arguments.
        """
        body: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgsDict']]
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        cookies: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgsDict']]
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        header_orders: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgsDict']]]]
        """
        Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgsDict']]]]
        """
        Inspect the request headers. See `headers` below for details.
        """
        ja3_fingerprint: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgsDict']]
        """
        Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        """
        json_body: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgsDict']]
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        method: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgsDict']]
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        query_string: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgsDict']]
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        single_header: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgsDict']]
        """
        Inspect a single header. See `single_header` below for details.
        """
        single_query_argument: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgsDict']]
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        uri_path: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgsDict']]
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_path: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs'] all_query_arguments: Inspect all query arguments.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgs'] body: Inspect the request body, which immediately follows the request headers. See `body` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgs'] cookies: Inspect the cookies in the web request. See `cookies` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs']]] header_orders: Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgs']]] headers: Inspect the request headers. See `headers` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs'] ja3_fingerprint: Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgs'] json_body: Inspect the request body as JSON. See `json_body` for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgs'] method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgs'] query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs'] single_header: Inspect a single header. See `single_header` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs'] single_query_argument: Inspect a single query argument. See `single_query_argument` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgs'] uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs']]:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgs']]:
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgs']]:
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs']]]]:
        """
        Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        """
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgs']]]]:
        """
        Inspect the request headers. See `headers` below for details.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs']]:
        """
        Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        """
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgs']]:
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgs']]:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgs']]:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs']]:
        """
        Inspect a single header. See `single_header` below for details.
        """
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs']]:
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgs']]:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgsDict(TypedDict):
        oversize_handling: NotRequired[pulumi.Input[str]]
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] oversize_handling: What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgsDict(TypedDict):
        match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgsDict']]]
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        oversize_handling: pulumi.Input[str]
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs']]] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param pulumi.Input[str] match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs']]]:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        excluded_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        included_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_cookies", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgsDict']
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        oversize_handling: pulumi.Input[str]
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs'] match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param pulumi.Input[str] match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs']:
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        excluded_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        included_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_headers", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgsDict(TypedDict):
        oversize_handling: pulumi.Input[str]
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[str]
        """
        The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgsDict']
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        invalid_fallback_behavior: NotRequired[pulumi.Input[str]]
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        oversize_handling: NotRequired[pulumi.Input[str]]
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 invalid_fallback_behavior: Optional[pulumi.Input[str]] = None,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs'] match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param pulumi.Input[str] match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param pulumi.Input[str] invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param pulumi.Input[str] oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs']:
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        included_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_paths", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[int]
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        type: pulumi.Input[str]
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementArgsDict(TypedDict):
        text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformationArgsDict']]]
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        field_to_match: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchArgsDict']]
        """
        Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        sensitivity_level: NotRequired[pulumi.Input[str]]
        """
        Sensitivity that you want AWS WAF to use to inspect for SQL injection attacks. Valid values include: `LOW`, `HIGH`.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementArgs:
    def __init__(__self__, *,
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchArgs']] = None,
                 sensitivity_level: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchArgs'] field_to_match: Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        :param pulumi.Input[str] sensitivity_level: Sensitivity that you want AWS WAF to use to inspect for SQL injection attacks. Valid values include: `LOW`, `HIGH`.
        """
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)
        if sensitivity_level is not None:
            pulumi.set(__self__, "sensitivity_level", sensitivity_level)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchArgs']]:
        """
        Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)

    @property
    @pulumi.getter(name="sensitivityLevel")
    def sensitivity_level(self) -> Optional[pulumi.Input[str]]:
        """
        Sensitivity that you want AWS WAF to use to inspect for SQL injection attacks. Valid values include: `LOW`, `HIGH`.
        """
        return pulumi.get(self, "sensitivity_level")

    @sensitivity_level.setter
    def sensitivity_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sensitivity_level", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchArgsDict(TypedDict):
        all_query_arguments: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgsDict']]
        """
        Inspect all query arguments.
        """
        body: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgsDict']]
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        cookies: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgsDict']]
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        header_orders: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgsDict']]]]
        """
        Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgsDict']]]]
        """
        Inspect the request headers. See `headers` below for details.
        """
        ja3_fingerprint: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgsDict']]
        """
        Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        """
        json_body: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgsDict']]
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        method: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgsDict']]
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        query_string: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgsDict']]
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        single_header: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgsDict']]
        """
        Inspect a single header. See `single_header` below for details.
        """
        single_query_argument: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgsDict']]
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        uri_path: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgsDict']]
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_path: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs'] all_query_arguments: Inspect all query arguments.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgs'] body: Inspect the request body, which immediately follows the request headers. See `body` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgs'] cookies: Inspect the cookies in the web request. See `cookies` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgs']]] header_orders: Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgs']]] headers: Inspect the request headers. See `headers` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs'] ja3_fingerprint: Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgs'] json_body: Inspect the request body as JSON. See `json_body` for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgs'] method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgs'] query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgs'] single_header: Inspect a single header. See `single_header` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs'] single_query_argument: Inspect a single query argument. See `single_query_argument` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgs'] uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs']]:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgs']]:
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgs']]:
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgs']]]]:
        """
        Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        """
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgs']]]]:
        """
        Inspect the request headers. See `headers` below for details.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs']]:
        """
        Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        """
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgs']]:
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgs']]:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgs']]:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgs']]:
        """
        Inspect a single header. See `single_header` below for details.
        """
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs']]:
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgs']]:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgsDict(TypedDict):
        oversize_handling: NotRequired[pulumi.Input[str]]
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] oversize_handling: What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgsDict(TypedDict):
        match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgsDict']]]
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        oversize_handling: pulumi.Input[str]
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs']]] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param pulumi.Input[str] match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs']]]:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        excluded_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        included_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_cookies", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgsDict']
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        oversize_handling: pulumi.Input[str]
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs'] match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param pulumi.Input[str] match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs']:
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        excluded_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        included_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_headers", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgsDict(TypedDict):
        oversize_handling: pulumi.Input[str]
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[str]
        """
        The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict']
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        invalid_fallback_behavior: NotRequired[pulumi.Input[str]]
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        oversize_handling: NotRequired[pulumi.Input[str]]
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 invalid_fallback_behavior: Optional[pulumi.Input[str]] = None,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs'] match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param pulumi.Input[str] match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param pulumi.Input[str] invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param pulumi.Input[str] oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs']:
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        included_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_paths", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[int]
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        type: pulumi.Input[str]
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementArgsDict(TypedDict):
        text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformationArgsDict']]]
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        field_to_match: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchArgsDict']]
        """
        Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementArgs:
    def __init__(__self__, *,
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchArgs'] field_to_match: Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchArgs']]:
        """
        Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchArgsDict(TypedDict):
        all_query_arguments: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgsDict']]
        """
        Inspect all query arguments.
        """
        body: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgsDict']]
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        cookies: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgsDict']]
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        header_orders: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgsDict']]]]
        """
        Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgsDict']]]]
        """
        Inspect the request headers. See `headers` below for details.
        """
        ja3_fingerprint: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgsDict']]
        """
        Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        """
        json_body: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgsDict']]
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        method: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgsDict']]
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        query_string: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgsDict']]
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        single_header: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgsDict']]
        """
        Inspect a single header. See `single_header` below for details.
        """
        single_query_argument: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgsDict']]
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        uri_path: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgsDict']]
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_path: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs'] all_query_arguments: Inspect all query arguments.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgs'] body: Inspect the request body, which immediately follows the request headers. See `body` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgs'] cookies: Inspect the cookies in the web request. See `cookies` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgs']]] header_orders: Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgs']]] headers: Inspect the request headers. See `headers` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgs'] ja3_fingerprint: Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgs'] json_body: Inspect the request body as JSON. See `json_body` for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgs'] method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgs'] query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgs'] single_header: Inspect a single header. See `single_header` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs'] single_query_argument: Inspect a single query argument. See `single_query_argument` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgs'] uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs']]:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgs']]:
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgs']]:
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgs']]]]:
        """
        Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        """
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgs']]]]:
        """
        Inspect the request headers. See `headers` below for details.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgs']]:
        """
        Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        """
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgs']]:
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgs']]:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgs']]:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgs']]:
        """
        Inspect a single header. See `single_header` below for details.
        """
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs']]:
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgs']]:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgsDict(TypedDict):
        oversize_handling: NotRequired[pulumi.Input[str]]
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] oversize_handling: What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgsDict(TypedDict):
        match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgsDict']]]
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        oversize_handling: pulumi.Input[str]
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs']]] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param pulumi.Input[str] match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs']]]:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        excluded_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        included_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_cookies", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgsDict']
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        oversize_handling: pulumi.Input[str]
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs'] match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param pulumi.Input[str] match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs']:
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        excluded_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        included_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_headers", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgsDict(TypedDict):
        oversize_handling: pulumi.Input[str]
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[str]
        """
        The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict']
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        invalid_fallback_behavior: NotRequired[pulumi.Input[str]]
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        oversize_handling: NotRequired[pulumi.Input[str]]
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 invalid_fallback_behavior: Optional[pulumi.Input[str]] = None,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs'] match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param pulumi.Input[str] match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param pulumi.Input[str] invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param pulumi.Input[str] oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs']:
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        included_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_paths", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[int]
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        type: pulumi.Input[str]
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class WebAclRuleStatementRegexMatchStatementArgsDict(TypedDict):
        regex_string: pulumi.Input[str]
        """
        String representing the regular expression. Minimum of `1` and maximum of `512` characters.
        """
        text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexMatchStatementTextTransformationArgsDict']]]
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        field_to_match: NotRequired[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchArgsDict']]
        """
        The part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
elif False:
    WebAclRuleStatementRegexMatchStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexMatchStatementArgs:
    def __init__(__self__, *,
                 regex_string: pulumi.Input[str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexMatchStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchArgs']] = None):
        """
        :param pulumi.Input[str] regex_string: String representing the regular expression. Minimum of `1` and maximum of `512` characters.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexMatchStatementTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        :param pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchArgs'] field_to_match: The part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        pulumi.set(__self__, "regex_string", regex_string)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @property
    @pulumi.getter(name="regexString")
    def regex_string(self) -> pulumi.Input[str]:
        """
        String representing the regular expression. Minimum of `1` and maximum of `512` characters.
        """
        return pulumi.get(self, "regex_string")

    @regex_string.setter
    def regex_string(self, value: pulumi.Input[str]):
        pulumi.set(self, "regex_string", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexMatchStatementTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexMatchStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchArgs']]:
        """
        The part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


if not MYPY:
    class WebAclRuleStatementRegexMatchStatementFieldToMatchArgsDict(TypedDict):
        all_query_arguments: NotRequired[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgsDict']]
        """
        Inspect all query arguments.
        """
        body: NotRequired[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchBodyArgsDict']]
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        cookies: NotRequired[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesArgsDict']]
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        header_orders: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderOrderArgsDict']]]]
        """
        Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderArgsDict']]]]
        """
        Inspect the request headers. See `headers` below for details.
        """
        ja3_fingerprint: NotRequired[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchJa3FingerprintArgsDict']]
        """
        Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        """
        json_body: NotRequired[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyArgsDict']]
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        method: NotRequired[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchMethodArgsDict']]
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        query_string: NotRequired[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchQueryStringArgsDict']]
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        single_header: NotRequired[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchSingleHeaderArgsDict']]
        """
        Inspect a single header. See `single_header` below for details.
        """
        single_query_argument: NotRequired[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgsDict']]
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        uri_path: NotRequired[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchUriPathArgsDict']]
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
elif False:
    WebAclRuleStatementRegexMatchStatementFieldToMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_path: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchUriPathArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs'] all_query_arguments: Inspect all query arguments.
        :param pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchBodyArgs'] body: Inspect the request body, which immediately follows the request headers. See `body` below for details.
        :param pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesArgs'] cookies: Inspect the cookies in the web request. See `cookies` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderOrderArgs']]] header_orders: Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderArgs']]] headers: Inspect the request headers. See `headers` below for details.
        :param pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs'] ja3_fingerprint: Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        :param pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyArgs'] json_body: Inspect the request body as JSON. See `json_body` for details.
        :param pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchMethodArgs'] method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchQueryStringArgs'] query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchSingleHeaderArgs'] single_header: Inspect a single header. See `single_header` below for details.
        :param pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs'] single_query_argument: Inspect a single query argument. See `single_query_argument` below for details.
        :param pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchUriPathArgs'] uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs']]:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchBodyArgs']]:
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesArgs']]:
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderOrderArgs']]]]:
        """
        Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        """
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderArgs']]]]:
        """
        Inspect the request headers. See `headers` below for details.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs']]:
        """
        Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        """
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyArgs']]:
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchMethodArgs']]:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchQueryStringArgs']]:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchSingleHeaderArgs']]:
        """
        Inspect a single header. See `single_header` below for details.
        """
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs']]:
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchUriPathArgs']]:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


if not MYPY:
    class WebAclRuleStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRegexMatchStatementFieldToMatchBodyArgsDict(TypedDict):
        oversize_handling: NotRequired[pulumi.Input[str]]
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementRegexMatchStatementFieldToMatchBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] oversize_handling: What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesArgsDict(TypedDict):
        match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgsDict']]]
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        oversize_handling: pulumi.Input[str]
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs']]] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param pulumi.Input[str] match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs']]]:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        excluded_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        included_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_cookies", value)


if not MYPY:
    class WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgsDict']
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        oversize_handling: pulumi.Input[str]
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
elif False:
    WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs'] match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param pulumi.Input[str] match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs']:
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        excluded_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        included_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
elif False:
    WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_headers", value)


if not MYPY:
    class WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderOrderArgsDict(TypedDict):
        oversize_handling: pulumi.Input[str]
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
elif False:
    WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderOrderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRegexMatchStatementFieldToMatchJa3FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[str]
        """
        The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementRegexMatchStatementFieldToMatchJa3FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict']
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        invalid_fallback_behavior: NotRequired[pulumi.Input[str]]
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        oversize_handling: NotRequired[pulumi.Input[str]]
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 invalid_fallback_behavior: Optional[pulumi.Input[str]] = None,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs'] match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param pulumi.Input[str] match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param pulumi.Input[str] invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param pulumi.Input[str] oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs']:
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        included_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_paths", value)


if not MYPY:
    class WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRegexMatchStatementFieldToMatchMethodArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRegexMatchStatementFieldToMatchMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRegexMatchStatementFieldToMatchQueryStringArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRegexMatchStatementFieldToMatchQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRegexMatchStatementFieldToMatchSingleHeaderArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
elif False:
    WebAclRuleStatementRegexMatchStatementFieldToMatchSingleHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
elif False:
    WebAclRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementRegexMatchStatementFieldToMatchUriPathArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRegexMatchStatementFieldToMatchUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRegexMatchStatementTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[int]
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        type: pulumi.Input[str]
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
elif False:
    WebAclRuleStatementRegexMatchStatementTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexMatchStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class WebAclRuleStatementRegexPatternSetReferenceStatementArgsDict(TypedDict):
        arn: pulumi.Input[str]
        """
        The Amazon Resource Name (ARN) of the Regex Pattern Set that this statement references.
        """
        text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementTextTransformationArgsDict']]]
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        field_to_match: NotRequired[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchArgsDict']]
        """
        Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
elif False:
    WebAclRuleStatementRegexPatternSetReferenceStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexPatternSetReferenceStatementArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchArgs']] = None):
        """
        :param pulumi.Input[str] arn: The Amazon Resource Name (ARN) of the Regex Pattern Set that this statement references.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        :param pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchArgs'] field_to_match: Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @property
    @pulumi.getter
    def arn(self) -> pulumi.Input[str]:
        """
        The Amazon Resource Name (ARN) of the Regex Pattern Set that this statement references.
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "arn", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchArgs']]:
        """
        Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


if not MYPY:
    class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchArgsDict(TypedDict):
        all_query_arguments: NotRequired[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgsDict']]
        """
        Inspect all query arguments.
        """
        body: NotRequired[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgsDict']]
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        cookies: NotRequired[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgsDict']]
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        header_orders: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgsDict']]]]
        """
        Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgsDict']]]]
        """
        Inspect the request headers. See `headers` below for details.
        """
        ja3_fingerprint: NotRequired[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgsDict']]
        """
        Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        """
        json_body: NotRequired[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgsDict']]
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        method: NotRequired[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgsDict']]
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        query_string: NotRequired[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgsDict']]
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        single_header: NotRequired[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgsDict']]
        """
        Inspect a single header. See `single_header` below for details.
        """
        single_query_argument: NotRequired[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgsDict']]
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        uri_path: NotRequired[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgsDict']]
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
elif False:
    WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_path: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs'] all_query_arguments: Inspect all query arguments.
        :param pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs'] body: Inspect the request body, which immediately follows the request headers. See `body` below for details.
        :param pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs'] cookies: Inspect the cookies in the web request. See `cookies` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs']]] header_orders: Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs']]] headers: Inspect the request headers. See `headers` below for details.
        :param pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs'] ja3_fingerprint: Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        :param pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs'] json_body: Inspect the request body as JSON. See `json_body` for details.
        :param pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs'] method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs'] query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs'] single_header: Inspect a single header. See `single_header` below for details.
        :param pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs'] single_query_argument: Inspect a single query argument. See `single_query_argument` below for details.
        :param pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs'] uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs']]:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs']]:
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs']]:
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs']]]]:
        """
        Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        """
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs']]]]:
        """
        Inspect the request headers. See `headers` below for details.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs']]:
        """
        Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        """
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs']]:
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs']]:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs']]:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs']]:
        """
        Inspect a single header. See `single_header` below for details.
        """
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs']]:
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs']]:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


if not MYPY:
    class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgsDict(TypedDict):
        oversize_handling: NotRequired[pulumi.Input[str]]
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] oversize_handling: What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgsDict(TypedDict):
        match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgsDict']]]
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        oversize_handling: pulumi.Input[str]
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs']]] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param pulumi.Input[str] match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs']]]:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        excluded_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        included_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_cookies", value)


if not MYPY:
    class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgsDict']
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        oversize_handling: pulumi.Input[str]
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
elif False:
    WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs'] match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param pulumi.Input[str] match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs']:
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        excluded_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        included_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
elif False:
    WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_headers", value)


if not MYPY:
    class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgsDict(TypedDict):
        oversize_handling: pulumi.Input[str]
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
elif False:
    WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[str]
        """
        The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgsDict']
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        invalid_fallback_behavior: NotRequired[pulumi.Input[str]]
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        oversize_handling: NotRequired[pulumi.Input[str]]
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 invalid_fallback_behavior: Optional[pulumi.Input[str]] = None,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs'] match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param pulumi.Input[str] match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param pulumi.Input[str] invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param pulumi.Input[str] oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs']:
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        included_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_paths", value)


if not MYPY:
    class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
elif False:
    WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
elif False:
    WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRegexPatternSetReferenceStatementTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[int]
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        type: pulumi.Input[str]
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
elif False:
    WebAclRuleStatementRegexPatternSetReferenceStatementTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexPatternSetReferenceStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class WebAclRuleStatementRuleGroupReferenceStatementArgsDict(TypedDict):
        arn: pulumi.Input[str]
        """
        The Amazon Resource Name (ARN) of the `wafv2.RuleGroup` resource.
        """
        rule_action_overrides: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideArgsDict']]]]
        """
        Action settings to use in the place of the rule actions that are configured inside the rule group. You specify one override for each rule whose action you want to change. See `rule_action_override` below for details.
        """
elif False:
    WebAclRuleStatementRuleGroupReferenceStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRuleGroupReferenceStatementArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[str],
                 rule_action_overrides: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideArgs']]]] = None):
        """
        :param pulumi.Input[str] arn: The Amazon Resource Name (ARN) of the `wafv2.RuleGroup` resource.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideArgs']]] rule_action_overrides: Action settings to use in the place of the rule actions that are configured inside the rule group. You specify one override for each rule whose action you want to change. See `rule_action_override` below for details.
        """
        pulumi.set(__self__, "arn", arn)
        if rule_action_overrides is not None:
            pulumi.set(__self__, "rule_action_overrides", rule_action_overrides)

    @property
    @pulumi.getter
    def arn(self) -> pulumi.Input[str]:
        """
        The Amazon Resource Name (ARN) of the `wafv2.RuleGroup` resource.
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "arn", value)

    @property
    @pulumi.getter(name="ruleActionOverrides")
    def rule_action_overrides(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideArgs']]]]:
        """
        Action settings to use in the place of the rule actions that are configured inside the rule group. You specify one override for each rule whose action you want to change. See `rule_action_override` below for details.
        """
        return pulumi.get(self, "rule_action_overrides")

    @rule_action_overrides.setter
    def rule_action_overrides(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideArgs']]]]):
        pulumi.set(self, "rule_action_overrides", value)


if not MYPY:
    class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideArgsDict(TypedDict):
        action_to_use: pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseArgsDict']
        """
        Override action to use, in place of the configured action of the rule in the rule group. See `action` for details.
        """
        name: pulumi.Input[str]
        """
        Name of the rule to override. See the [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/aws-managed-rule-groups-list.html) for a list of names in the appropriate rule group in use.
        """
elif False:
    WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideArgs:
    def __init__(__self__, *,
                 action_to_use: pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseArgs'],
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseArgs'] action_to_use: Override action to use, in place of the configured action of the rule in the rule group. See `action` for details.
        :param pulumi.Input[str] name: Name of the rule to override. See the [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/aws-managed-rule-groups-list.html) for a list of names in the appropriate rule group in use.
        """
        pulumi.set(__self__, "action_to_use", action_to_use)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="actionToUse")
    def action_to_use(self) -> pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseArgs']:
        """
        Override action to use, in place of the configured action of the rule in the rule group. See `action` for details.
        """
        return pulumi.get(self, "action_to_use")

    @action_to_use.setter
    def action_to_use(self, value: pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseArgs']):
        pulumi.set(self, "action_to_use", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the rule to override. See the [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/aws-managed-rule-groups-list.html) for a list of names in the appropriate rule group in use.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseArgsDict(TypedDict):
        allow: NotRequired[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowArgsDict']]
        block: NotRequired[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockArgsDict']]
        captcha: NotRequired[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaArgsDict']]
        """
        Instructs AWS WAF to run a Captcha check against the web request. See `captcha` below for details.
        """
        challenge: NotRequired[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeArgsDict']]
        """
        Instructs AWS WAF to run a check against the request to verify that the request is coming from a legitimate client session. See `challenge` below for details.
        """
        count: NotRequired[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountArgsDict']]
elif False:
    WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseArgs:
    def __init__(__self__, *,
                 allow: Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowArgs']] = None,
                 block: Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockArgs']] = None,
                 captcha: Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaArgs']] = None,
                 challenge: Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeArgs']] = None,
                 count: Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaArgs'] captcha: Instructs AWS WAF to run a Captcha check against the web request. See `captcha` below for details.
        :param pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeArgs'] challenge: Instructs AWS WAF to run a check against the request to verify that the request is coming from a legitimate client session. See `challenge` below for details.
        """
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if block is not None:
            pulumi.set(__self__, "block", block)
        if captcha is not None:
            pulumi.set(__self__, "captcha", captcha)
        if challenge is not None:
            pulumi.set(__self__, "challenge", challenge)
        if count is not None:
            pulumi.set(__self__, "count", count)

    @property
    @pulumi.getter
    def allow(self) -> Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowArgs']]:
        return pulumi.get(self, "allow")

    @allow.setter
    def allow(self, value: Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowArgs']]):
        pulumi.set(self, "allow", value)

    @property
    @pulumi.getter
    def block(self) -> Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockArgs']]:
        return pulumi.get(self, "block")

    @block.setter
    def block(self, value: Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockArgs']]):
        pulumi.set(self, "block", value)

    @property
    @pulumi.getter
    def captcha(self) -> Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaArgs']]:
        """
        Instructs AWS WAF to run a Captcha check against the web request. See `captcha` below for details.
        """
        return pulumi.get(self, "captcha")

    @captcha.setter
    def captcha(self, value: Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaArgs']]):
        pulumi.set(self, "captcha", value)

    @property
    @pulumi.getter
    def challenge(self) -> Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeArgs']]:
        """
        Instructs AWS WAF to run a check against the request to verify that the request is coming from a legitimate client session. See `challenge` below for details.
        """
        return pulumi.get(self, "challenge")

    @challenge.setter
    def challenge(self, value: Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeArgs']]):
        pulumi.set(self, "challenge", value)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountArgs']]:
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountArgs']]):
        pulumi.set(self, "count", value)


if not MYPY:
    class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowArgsDict(TypedDict):
        custom_request_handling: NotRequired[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingArgsDict']]
        """
        Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
elif False:
    WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingArgs'] custom_request_handling: Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingArgs']]:
        """
        Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


if not MYPY:
    class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingArgsDict(TypedDict):
        insert_headers: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeaderArgsDict']]]
        """
        The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
elif False:
    WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingArgs:
    def __init__(__self__, *,
                 insert_headers: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeaderArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeaderArgs']]] insert_headers: The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        pulumi.set(__self__, "insert_headers", insert_headers)

    @property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeaderArgs']]]:
        """
        The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        return pulumi.get(self, "insert_headers")

    @insert_headers.setter
    def insert_headers(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeaderArgs']]]):
        pulumi.set(self, "insert_headers", value)


if not MYPY:
    class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeaderArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        """
        value: pulumi.Input[str]
        """
        Value of the custom header.
        """
elif False:
    WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        :param pulumi.Input[str] value: Value of the custom header.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value of the custom header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockArgsDict(TypedDict):
        custom_response: NotRequired[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponseArgsDict']]
        """
        Defines a custom response for the web request. See `custom_response` below for details.
        """
elif False:
    WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockArgs:
    def __init__(__self__, *,
                 custom_response: Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponseArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponseArgs'] custom_response: Defines a custom response for the web request. See `custom_response` below for details.
        """
        if custom_response is not None:
            pulumi.set(__self__, "custom_response", custom_response)

    @property
    @pulumi.getter(name="customResponse")
    def custom_response(self) -> Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponseArgs']]:
        """
        Defines a custom response for the web request. See `custom_response` below for details.
        """
        return pulumi.get(self, "custom_response")

    @custom_response.setter
    def custom_response(self, value: Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponseArgs']]):
        pulumi.set(self, "custom_response", value)


if not MYPY:
    class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponseArgsDict(TypedDict):
        response_code: pulumi.Input[int]
        """
        The HTTP status code to return to the client.
        """
        custom_response_body_key: NotRequired[pulumi.Input[str]]
        """
        References the response body that you want AWS WAF to return to the web request client. This must reference a `key` defined in a `custom_response_body` block of this resource.
        """
        response_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeaderArgsDict']]]]
        """
        The `response_header` blocks used to define the HTTP response headers added to the response. See `response_header` below for details.
        """
elif False:
    WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponseArgs:
    def __init__(__self__, *,
                 response_code: pulumi.Input[int],
                 custom_response_body_key: Optional[pulumi.Input[str]] = None,
                 response_headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeaderArgs']]]] = None):
        """
        :param pulumi.Input[int] response_code: The HTTP status code to return to the client.
        :param pulumi.Input[str] custom_response_body_key: References the response body that you want AWS WAF to return to the web request client. This must reference a `key` defined in a `custom_response_body` block of this resource.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeaderArgs']]] response_headers: The `response_header` blocks used to define the HTTP response headers added to the response. See `response_header` below for details.
        """
        pulumi.set(__self__, "response_code", response_code)
        if custom_response_body_key is not None:
            pulumi.set(__self__, "custom_response_body_key", custom_response_body_key)
        if response_headers is not None:
            pulumi.set(__self__, "response_headers", response_headers)

    @property
    @pulumi.getter(name="responseCode")
    def response_code(self) -> pulumi.Input[int]:
        """
        The HTTP status code to return to the client.
        """
        return pulumi.get(self, "response_code")

    @response_code.setter
    def response_code(self, value: pulumi.Input[int]):
        pulumi.set(self, "response_code", value)

    @property
    @pulumi.getter(name="customResponseBodyKey")
    def custom_response_body_key(self) -> Optional[pulumi.Input[str]]:
        """
        References the response body that you want AWS WAF to return to the web request client. This must reference a `key` defined in a `custom_response_body` block of this resource.
        """
        return pulumi.get(self, "custom_response_body_key")

    @custom_response_body_key.setter
    def custom_response_body_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_response_body_key", value)

    @property
    @pulumi.getter(name="responseHeaders")
    def response_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeaderArgs']]]]:
        """
        The `response_header` blocks used to define the HTTP response headers added to the response. See `response_header` below for details.
        """
        return pulumi.get(self, "response_headers")

    @response_headers.setter
    def response_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeaderArgs']]]]):
        pulumi.set(self, "response_headers", value)


if not MYPY:
    class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeaderArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        """
        value: pulumi.Input[str]
        """
        Value of the custom header.
        """
elif False:
    WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        :param pulumi.Input[str] value: Value of the custom header.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value of the custom header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaArgsDict(TypedDict):
        custom_request_handling: NotRequired[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingArgsDict']]
        """
        Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
elif False:
    WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingArgs'] custom_request_handling: Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingArgs']]:
        """
        Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


if not MYPY:
    class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingArgsDict(TypedDict):
        insert_headers: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeaderArgsDict']]]
        """
        The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
elif False:
    WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingArgs:
    def __init__(__self__, *,
                 insert_headers: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeaderArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeaderArgs']]] insert_headers: The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        pulumi.set(__self__, "insert_headers", insert_headers)

    @property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeaderArgs']]]:
        """
        The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        return pulumi.get(self, "insert_headers")

    @insert_headers.setter
    def insert_headers(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeaderArgs']]]):
        pulumi.set(self, "insert_headers", value)


if not MYPY:
    class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeaderArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        """
        value: pulumi.Input[str]
        """
        Value of the custom header.
        """
elif False:
    WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        :param pulumi.Input[str] value: Value of the custom header.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value of the custom header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeArgsDict(TypedDict):
        custom_request_handling: NotRequired[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingArgsDict']]
        """
        Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
elif False:
    WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingArgs'] custom_request_handling: Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingArgs']]:
        """
        Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


if not MYPY:
    class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingArgsDict(TypedDict):
        insert_headers: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeaderArgsDict']]]
        """
        The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
elif False:
    WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingArgs:
    def __init__(__self__, *,
                 insert_headers: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeaderArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeaderArgs']]] insert_headers: The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        pulumi.set(__self__, "insert_headers", insert_headers)

    @property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeaderArgs']]]:
        """
        The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        return pulumi.get(self, "insert_headers")

    @insert_headers.setter
    def insert_headers(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeaderArgs']]]):
        pulumi.set(self, "insert_headers", value)


if not MYPY:
    class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeaderArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        """
        value: pulumi.Input[str]
        """
        Value of the custom header.
        """
elif False:
    WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        :param pulumi.Input[str] value: Value of the custom header.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value of the custom header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountArgsDict(TypedDict):
        custom_request_handling: NotRequired[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandlingArgsDict']]
        """
        Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
elif False:
    WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandlingArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandlingArgs'] custom_request_handling: Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandlingArgs']]:
        """
        Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


if not MYPY:
    class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandlingArgsDict(TypedDict):
        insert_headers: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeaderArgsDict']]]
        """
        The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
elif False:
    WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandlingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandlingArgs:
    def __init__(__self__, *,
                 insert_headers: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeaderArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeaderArgs']]] insert_headers: The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        pulumi.set(__self__, "insert_headers", insert_headers)

    @property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeaderArgs']]]:
        """
        The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        return pulumi.get(self, "insert_headers")

    @insert_headers.setter
    def insert_headers(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeaderArgs']]]):
        pulumi.set(self, "insert_headers", value)


if not MYPY:
    class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeaderArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        """
        value: pulumi.Input[str]
        """
        Value of the custom header.
        """
elif False:
    WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        :param pulumi.Input[str] value: Value of the custom header.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value of the custom header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class WebAclRuleStatementSizeConstraintStatementArgsDict(TypedDict):
        comparison_operator: pulumi.Input[str]
        """
        Operator to use to compare the request part to the size setting. Valid values include: `EQ`, `NE`, `LE`, `LT`, `GE`, or `GT`.
        """
        size: pulumi.Input[int]
        """
        Size, in bytes, to compare to the request part, after any transformations. Valid values are integers between 0 and 21474836480, inclusive.
        """
        text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSizeConstraintStatementTextTransformationArgsDict']]]
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        field_to_match: NotRequired[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchArgsDict']]
        """
        Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
elif False:
    WebAclRuleStatementSizeConstraintStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSizeConstraintStatementArgs:
    def __init__(__self__, *,
                 comparison_operator: pulumi.Input[str],
                 size: pulumi.Input[int],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSizeConstraintStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchArgs']] = None):
        """
        :param pulumi.Input[str] comparison_operator: Operator to use to compare the request part to the size setting. Valid values include: `EQ`, `NE`, `LE`, `LT`, `GE`, or `GT`.
        :param pulumi.Input[int] size: Size, in bytes, to compare to the request part, after any transformations. Valid values are integers between 0 and 21474836480, inclusive.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSizeConstraintStatementTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        :param pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchArgs'] field_to_match: Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        pulumi.set(__self__, "comparison_operator", comparison_operator)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> pulumi.Input[str]:
        """
        Operator to use to compare the request part to the size setting. Valid values include: `EQ`, `NE`, `LE`, `LT`, `GE`, or `GT`.
        """
        return pulumi.get(self, "comparison_operator")

    @comparison_operator.setter
    def comparison_operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "comparison_operator", value)

    @property
    @pulumi.getter
    def size(self) -> pulumi.Input[int]:
        """
        Size, in bytes, to compare to the request part, after any transformations. Valid values are integers between 0 and 21474836480, inclusive.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[int]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSizeConstraintStatementTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSizeConstraintStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchArgs']]:
        """
        Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


if not MYPY:
    class WebAclRuleStatementSizeConstraintStatementFieldToMatchArgsDict(TypedDict):
        all_query_arguments: NotRequired[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgsDict']]
        """
        Inspect all query arguments.
        """
        body: NotRequired[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchBodyArgsDict']]
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        cookies: NotRequired[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesArgsDict']]
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        header_orders: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderOrderArgsDict']]]]
        """
        Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderArgsDict']]]]
        """
        Inspect the request headers. See `headers` below for details.
        """
        ja3_fingerprint: NotRequired[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgsDict']]
        """
        Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        """
        json_body: NotRequired[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyArgsDict']]
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        method: NotRequired[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchMethodArgsDict']]
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        query_string: NotRequired[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchQueryStringArgsDict']]
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        single_header: NotRequired[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleHeaderArgsDict']]
        """
        Inspect a single header. See `single_header` below for details.
        """
        single_query_argument: NotRequired[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgsDict']]
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        uri_path: NotRequired[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchUriPathArgsDict']]
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
elif False:
    WebAclRuleStatementSizeConstraintStatementFieldToMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_path: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchUriPathArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs'] all_query_arguments: Inspect all query arguments.
        :param pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchBodyArgs'] body: Inspect the request body, which immediately follows the request headers. See `body` below for details.
        :param pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesArgs'] cookies: Inspect the cookies in the web request. See `cookies` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs']]] header_orders: Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderArgs']]] headers: Inspect the request headers. See `headers` below for details.
        :param pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs'] ja3_fingerprint: Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        :param pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyArgs'] json_body: Inspect the request body as JSON. See `json_body` for details.
        :param pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchMethodArgs'] method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchQueryStringArgs'] query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs'] single_header: Inspect a single header. See `single_header` below for details.
        :param pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs'] single_query_argument: Inspect a single query argument. See `single_query_argument` below for details.
        :param pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchUriPathArgs'] uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs']]:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchBodyArgs']]:
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesArgs']]:
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs']]]]:
        """
        Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        """
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderArgs']]]]:
        """
        Inspect the request headers. See `headers` below for details.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs']]:
        """
        Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        """
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyArgs']]:
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchMethodArgs']]:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchQueryStringArgs']]:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs']]:
        """
        Inspect a single header. See `single_header` below for details.
        """
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs']]:
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchUriPathArgs']]:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


if not MYPY:
    class WebAclRuleStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementSizeConstraintStatementFieldToMatchBodyArgsDict(TypedDict):
        oversize_handling: NotRequired[pulumi.Input[str]]
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementSizeConstraintStatementFieldToMatchBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] oversize_handling: What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesArgsDict(TypedDict):
        match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgsDict']]]
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        oversize_handling: pulumi.Input[str]
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs']]] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param pulumi.Input[str] match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs']]]:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        excluded_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        included_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_cookies", value)


if not MYPY:
    class WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgsDict']
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        oversize_handling: pulumi.Input[str]
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
elif False:
    WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs'] match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param pulumi.Input[str] match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs']:
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        excluded_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        included_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
elif False:
    WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_headers", value)


if not MYPY:
    class WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderOrderArgsDict(TypedDict):
        oversize_handling: pulumi.Input[str]
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
elif False:
    WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderOrderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[str]
        """
        The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgsDict']
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        invalid_fallback_behavior: NotRequired[pulumi.Input[str]]
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        oversize_handling: NotRequired[pulumi.Input[str]]
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 invalid_fallback_behavior: Optional[pulumi.Input[str]] = None,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs'] match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param pulumi.Input[str] match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param pulumi.Input[str] invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param pulumi.Input[str] oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs']:
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        included_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_paths", value)


if not MYPY:
    class WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementSizeConstraintStatementFieldToMatchMethodArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementSizeConstraintStatementFieldToMatchMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementSizeConstraintStatementFieldToMatchQueryStringArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementSizeConstraintStatementFieldToMatchQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleHeaderArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
elif False:
    WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
elif False:
    WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementSizeConstraintStatementFieldToMatchUriPathArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementSizeConstraintStatementFieldToMatchUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementSizeConstraintStatementTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[int]
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        type: pulumi.Input[str]
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
elif False:
    WebAclRuleStatementSizeConstraintStatementTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSizeConstraintStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class WebAclRuleStatementSqliMatchStatementArgsDict(TypedDict):
        text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSqliMatchStatementTextTransformationArgsDict']]]
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        field_to_match: NotRequired[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchArgsDict']]
        """
        Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        sensitivity_level: NotRequired[pulumi.Input[str]]
        """
        Sensitivity that you want AWS WAF to use to inspect for SQL injection attacks. Valid values include: `LOW`, `HIGH`.
        """
elif False:
    WebAclRuleStatementSqliMatchStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSqliMatchStatementArgs:
    def __init__(__self__, *,
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSqliMatchStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchArgs']] = None,
                 sensitivity_level: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSqliMatchStatementTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        :param pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchArgs'] field_to_match: Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        :param pulumi.Input[str] sensitivity_level: Sensitivity that you want AWS WAF to use to inspect for SQL injection attacks. Valid values include: `LOW`, `HIGH`.
        """
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)
        if sensitivity_level is not None:
            pulumi.set(__self__, "sensitivity_level", sensitivity_level)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSqliMatchStatementTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSqliMatchStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchArgs']]:
        """
        Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)

    @property
    @pulumi.getter(name="sensitivityLevel")
    def sensitivity_level(self) -> Optional[pulumi.Input[str]]:
        """
        Sensitivity that you want AWS WAF to use to inspect for SQL injection attacks. Valid values include: `LOW`, `HIGH`.
        """
        return pulumi.get(self, "sensitivity_level")

    @sensitivity_level.setter
    def sensitivity_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sensitivity_level", value)


if not MYPY:
    class WebAclRuleStatementSqliMatchStatementFieldToMatchArgsDict(TypedDict):
        all_query_arguments: NotRequired[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgsDict']]
        """
        Inspect all query arguments.
        """
        body: NotRequired[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchBodyArgsDict']]
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        cookies: NotRequired[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesArgsDict']]
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        header_orders: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderOrderArgsDict']]]]
        """
        Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderArgsDict']]]]
        """
        Inspect the request headers. See `headers` below for details.
        """
        ja3_fingerprint: NotRequired[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchJa3FingerprintArgsDict']]
        """
        Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        """
        json_body: NotRequired[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyArgsDict']]
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        method: NotRequired[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchMethodArgsDict']]
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        query_string: NotRequired[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchQueryStringArgsDict']]
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        single_header: NotRequired[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchSingleHeaderArgsDict']]
        """
        Inspect a single header. See `single_header` below for details.
        """
        single_query_argument: NotRequired[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgsDict']]
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        uri_path: NotRequired[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchUriPathArgsDict']]
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
elif False:
    WebAclRuleStatementSqliMatchStatementFieldToMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_path: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchUriPathArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs'] all_query_arguments: Inspect all query arguments.
        :param pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchBodyArgs'] body: Inspect the request body, which immediately follows the request headers. See `body` below for details.
        :param pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesArgs'] cookies: Inspect the cookies in the web request. See `cookies` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderOrderArgs']]] header_orders: Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderArgs']]] headers: Inspect the request headers. See `headers` below for details.
        :param pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs'] ja3_fingerprint: Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        :param pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyArgs'] json_body: Inspect the request body as JSON. See `json_body` for details.
        :param pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchMethodArgs'] method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchQueryStringArgs'] query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchSingleHeaderArgs'] single_header: Inspect a single header. See `single_header` below for details.
        :param pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs'] single_query_argument: Inspect a single query argument. See `single_query_argument` below for details.
        :param pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchUriPathArgs'] uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs']]:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchBodyArgs']]:
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesArgs']]:
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderOrderArgs']]]]:
        """
        Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        """
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderArgs']]]]:
        """
        Inspect the request headers. See `headers` below for details.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs']]:
        """
        Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        """
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyArgs']]:
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchMethodArgs']]:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchQueryStringArgs']]:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchSingleHeaderArgs']]:
        """
        Inspect a single header. See `single_header` below for details.
        """
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs']]:
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchUriPathArgs']]:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


if not MYPY:
    class WebAclRuleStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementSqliMatchStatementFieldToMatchBodyArgsDict(TypedDict):
        oversize_handling: NotRequired[pulumi.Input[str]]
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementSqliMatchStatementFieldToMatchBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] oversize_handling: What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesArgsDict(TypedDict):
        match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgsDict']]]
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        oversize_handling: pulumi.Input[str]
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs']]] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param pulumi.Input[str] match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs']]]:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        excluded_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        included_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_cookies", value)


if not MYPY:
    class WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgsDict']
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        oversize_handling: pulumi.Input[str]
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
elif False:
    WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs'] match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param pulumi.Input[str] match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs']:
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        excluded_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        included_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
elif False:
    WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_headers", value)


if not MYPY:
    class WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderOrderArgsDict(TypedDict):
        oversize_handling: pulumi.Input[str]
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
elif False:
    WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderOrderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementSqliMatchStatementFieldToMatchJa3FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[str]
        """
        The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementSqliMatchStatementFieldToMatchJa3FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict']
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        invalid_fallback_behavior: NotRequired[pulumi.Input[str]]
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        oversize_handling: NotRequired[pulumi.Input[str]]
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 invalid_fallback_behavior: Optional[pulumi.Input[str]] = None,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs'] match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param pulumi.Input[str] match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param pulumi.Input[str] invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param pulumi.Input[str] oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs']:
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        included_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_paths", value)


if not MYPY:
    class WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementSqliMatchStatementFieldToMatchMethodArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementSqliMatchStatementFieldToMatchMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementSqliMatchStatementFieldToMatchQueryStringArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementSqliMatchStatementFieldToMatchQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementSqliMatchStatementFieldToMatchSingleHeaderArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
elif False:
    WebAclRuleStatementSqliMatchStatementFieldToMatchSingleHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
elif False:
    WebAclRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementSqliMatchStatementFieldToMatchUriPathArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementSqliMatchStatementFieldToMatchUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementSqliMatchStatementTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[int]
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        type: pulumi.Input[str]
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
elif False:
    WebAclRuleStatementSqliMatchStatementTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSqliMatchStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class WebAclRuleStatementXssMatchStatementArgsDict(TypedDict):
        text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementXssMatchStatementTextTransformationArgsDict']]]
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        field_to_match: NotRequired[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchArgsDict']]
        """
        Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
elif False:
    WebAclRuleStatementXssMatchStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementXssMatchStatementArgs:
    def __init__(__self__, *,
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementXssMatchStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementXssMatchStatementTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        :param pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchArgs'] field_to_match: Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementXssMatchStatementTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementXssMatchStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchArgs']]:
        """
        Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


if not MYPY:
    class WebAclRuleStatementXssMatchStatementFieldToMatchArgsDict(TypedDict):
        all_query_arguments: NotRequired[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgsDict']]
        """
        Inspect all query arguments.
        """
        body: NotRequired[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchBodyArgsDict']]
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        cookies: NotRequired[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchCookiesArgsDict']]
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        header_orders: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchHeaderOrderArgsDict']]]]
        """
        Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchHeaderArgsDict']]]]
        """
        Inspect the request headers. See `headers` below for details.
        """
        ja3_fingerprint: NotRequired[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchJa3FingerprintArgsDict']]
        """
        Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        """
        json_body: NotRequired[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyArgsDict']]
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        method: NotRequired[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchMethodArgsDict']]
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        query_string: NotRequired[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchQueryStringArgsDict']]
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        single_header: NotRequired[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchSingleHeaderArgsDict']]
        """
        Inspect a single header. See `single_header` below for details.
        """
        single_query_argument: NotRequired[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgsDict']]
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        uri_path: NotRequired[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchUriPathArgsDict']]
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
elif False:
    WebAclRuleStatementXssMatchStatementFieldToMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementXssMatchStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchJa3FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_path: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchUriPathArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs'] all_query_arguments: Inspect all query arguments.
        :param pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchBodyArgs'] body: Inspect the request body, which immediately follows the request headers. See `body` below for details.
        :param pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchCookiesArgs'] cookies: Inspect the cookies in the web request. See `cookies` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchHeaderOrderArgs']]] header_orders: Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchHeaderArgs']]] headers: Inspect the request headers. See `headers` below for details.
        :param pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchJa3FingerprintArgs'] ja3_fingerprint: Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        :param pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyArgs'] json_body: Inspect the request body as JSON. See `json_body` for details.
        :param pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchMethodArgs'] method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchQueryStringArgs'] query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchSingleHeaderArgs'] single_header: Inspect a single header. See `single_header` below for details.
        :param pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs'] single_query_argument: Inspect a single query argument. See `single_query_argument` below for details.
        :param pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchUriPathArgs'] uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs']]:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchBodyArgs']]:
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchCookiesArgs']]:
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchHeaderOrderArgs']]]]:
        """
        Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        """
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchHeaderArgs']]]]:
        """
        Inspect the request headers. See `headers` below for details.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchJa3FingerprintArgs']]:
        """
        Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        """
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyArgs']]:
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchMethodArgs']]:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchQueryStringArgs']]:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchSingleHeaderArgs']]:
        """
        Inspect a single header. See `single_header` below for details.
        """
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs']]:
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchUriPathArgs']]:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


if not MYPY:
    class WebAclRuleStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementXssMatchStatementFieldToMatchBodyArgsDict(TypedDict):
        oversize_handling: NotRequired[pulumi.Input[str]]
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementXssMatchStatementFieldToMatchBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementXssMatchStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] oversize_handling: What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementXssMatchStatementFieldToMatchCookiesArgsDict(TypedDict):
        match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgsDict']]]
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        oversize_handling: pulumi.Input[str]
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementXssMatchStatementFieldToMatchCookiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementXssMatchStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs']]] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param pulumi.Input[str] match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs']]]:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        excluded_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        included_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_cookies", value)


if not MYPY:
    class WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementXssMatchStatementFieldToMatchHeaderArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgsDict']
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        oversize_handling: pulumi.Input[str]
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
elif False:
    WebAclRuleStatementXssMatchStatementFieldToMatchHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementXssMatchStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs'] match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param pulumi.Input[str] match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs']:
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        excluded_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        included_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
elif False:
    WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_headers", value)


if not MYPY:
    class WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementXssMatchStatementFieldToMatchHeaderOrderArgsDict(TypedDict):
        oversize_handling: pulumi.Input[str]
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
elif False:
    WebAclRuleStatementXssMatchStatementFieldToMatchHeaderOrderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementXssMatchStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementXssMatchStatementFieldToMatchJa3FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[str]
        """
        The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementXssMatchStatementFieldToMatchJa3FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementXssMatchStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict']
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        match_scope: pulumi.Input[str]
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        invalid_fallback_behavior: NotRequired[pulumi.Input[str]]
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        oversize_handling: NotRequired[pulumi.Input[str]]
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
elif False:
    WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 invalid_fallback_behavior: Optional[pulumi.Input[str]] = None,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs'] match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param pulumi.Input[str] match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param pulumi.Input[str] invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param pulumi.Input[str] oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs']:
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict']]
        """
        An empty configuration block that is used for inspecting all headers.
        """
        included_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_paths", value)


if not MYPY:
    class WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementXssMatchStatementFieldToMatchMethodArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementXssMatchStatementFieldToMatchMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementXssMatchStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementXssMatchStatementFieldToMatchQueryStringArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementXssMatchStatementFieldToMatchQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementXssMatchStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementXssMatchStatementFieldToMatchSingleHeaderArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
elif False:
    WebAclRuleStatementXssMatchStatementFieldToMatchSingleHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementXssMatchStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
elif False:
    WebAclRuleStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementXssMatchStatementFieldToMatchUriPathArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementXssMatchStatementFieldToMatchUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementXssMatchStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementXssMatchStatementTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[int]
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        type: pulumi.Input[str]
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
elif False:
    WebAclRuleStatementXssMatchStatementTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementXssMatchStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class WebAclRuleVisibilityConfigArgsDict(TypedDict):
        cloudwatch_metrics_enabled: pulumi.Input[bool]
        """
        Whether the associated resource sends metrics to CloudWatch. For the list of available metrics, see [AWS WAF Metrics](https://docs.aws.amazon.com/waf/latest/developerguide/monitoring-cloudwatch.html#waf-metrics).
        """
        metric_name: pulumi.Input[str]
        """
        A friendly name of the CloudWatch metric. The name can contain only alphanumeric characters (A-Z, a-z, 0-9) hyphen(-) and underscore (\\_), with length from one to 128 characters. It can't contain whitespace or metric names reserved for AWS WAF, for example `All` and `Default_Action`.
        """
        sampled_requests_enabled: pulumi.Input[bool]
        """
        Whether AWS WAF should store a sampling of the web requests that match the rules. You can view the sampled requests through the AWS WAF console.
        """
elif False:
    WebAclRuleVisibilityConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleVisibilityConfigArgs:
    def __init__(__self__, *,
                 cloudwatch_metrics_enabled: pulumi.Input[bool],
                 metric_name: pulumi.Input[str],
                 sampled_requests_enabled: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] cloudwatch_metrics_enabled: Whether the associated resource sends metrics to CloudWatch. For the list of available metrics, see [AWS WAF Metrics](https://docs.aws.amazon.com/waf/latest/developerguide/monitoring-cloudwatch.html#waf-metrics).
        :param pulumi.Input[str] metric_name: A friendly name of the CloudWatch metric. The name can contain only alphanumeric characters (A-Z, a-z, 0-9) hyphen(-) and underscore (\\_), with length from one to 128 characters. It can't contain whitespace or metric names reserved for AWS WAF, for example `All` and `Default_Action`.
        :param pulumi.Input[bool] sampled_requests_enabled: Whether AWS WAF should store a sampling of the web requests that match the rules. You can view the sampled requests through the AWS WAF console.
        """
        pulumi.set(__self__, "cloudwatch_metrics_enabled", cloudwatch_metrics_enabled)
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "sampled_requests_enabled", sampled_requests_enabled)

    @property
    @pulumi.getter(name="cloudwatchMetricsEnabled")
    def cloudwatch_metrics_enabled(self) -> pulumi.Input[bool]:
        """
        Whether the associated resource sends metrics to CloudWatch. For the list of available metrics, see [AWS WAF Metrics](https://docs.aws.amazon.com/waf/latest/developerguide/monitoring-cloudwatch.html#waf-metrics).
        """
        return pulumi.get(self, "cloudwatch_metrics_enabled")

    @cloudwatch_metrics_enabled.setter
    def cloudwatch_metrics_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "cloudwatch_metrics_enabled", value)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> pulumi.Input[str]:
        """
        A friendly name of the CloudWatch metric. The name can contain only alphanumeric characters (A-Z, a-z, 0-9) hyphen(-) and underscore (\\_), with length from one to 128 characters. It can't contain whitespace or metric names reserved for AWS WAF, for example `All` and `Default_Action`.
        """
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric_name", value)

    @property
    @pulumi.getter(name="sampledRequestsEnabled")
    def sampled_requests_enabled(self) -> pulumi.Input[bool]:
        """
        Whether AWS WAF should store a sampling of the web requests that match the rules. You can view the sampled requests through the AWS WAF console.
        """
        return pulumi.get(self, "sampled_requests_enabled")

    @sampled_requests_enabled.setter
    def sampled_requests_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "sampled_requests_enabled", value)


if not MYPY:
    class WebAclVisibilityConfigArgsDict(TypedDict):
        cloudwatch_metrics_enabled: pulumi.Input[bool]
        """
        Whether the associated resource sends metrics to CloudWatch. For the list of available metrics, see [AWS WAF Metrics](https://docs.aws.amazon.com/waf/latest/developerguide/monitoring-cloudwatch.html#waf-metrics).
        """
        metric_name: pulumi.Input[str]
        """
        A friendly name of the CloudWatch metric. The name can contain only alphanumeric characters (A-Z, a-z, 0-9) hyphen(-) and underscore (\\_), with length from one to 128 characters. It can't contain whitespace or metric names reserved for AWS WAF, for example `All` and `Default_Action`.
        """
        sampled_requests_enabled: pulumi.Input[bool]
        """
        Whether AWS WAF should store a sampling of the web requests that match the rules. You can view the sampled requests through the AWS WAF console.
        """
elif False:
    WebAclVisibilityConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclVisibilityConfigArgs:
    def __init__(__self__, *,
                 cloudwatch_metrics_enabled: pulumi.Input[bool],
                 metric_name: pulumi.Input[str],
                 sampled_requests_enabled: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] cloudwatch_metrics_enabled: Whether the associated resource sends metrics to CloudWatch. For the list of available metrics, see [AWS WAF Metrics](https://docs.aws.amazon.com/waf/latest/developerguide/monitoring-cloudwatch.html#waf-metrics).
        :param pulumi.Input[str] metric_name: A friendly name of the CloudWatch metric. The name can contain only alphanumeric characters (A-Z, a-z, 0-9) hyphen(-) and underscore (\\_), with length from one to 128 characters. It can't contain whitespace or metric names reserved for AWS WAF, for example `All` and `Default_Action`.
        :param pulumi.Input[bool] sampled_requests_enabled: Whether AWS WAF should store a sampling of the web requests that match the rules. You can view the sampled requests through the AWS WAF console.
        """
        pulumi.set(__self__, "cloudwatch_metrics_enabled", cloudwatch_metrics_enabled)
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "sampled_requests_enabled", sampled_requests_enabled)

    @property
    @pulumi.getter(name="cloudwatchMetricsEnabled")
    def cloudwatch_metrics_enabled(self) -> pulumi.Input[bool]:
        """
        Whether the associated resource sends metrics to CloudWatch. For the list of available metrics, see [AWS WAF Metrics](https://docs.aws.amazon.com/waf/latest/developerguide/monitoring-cloudwatch.html#waf-metrics).
        """
        return pulumi.get(self, "cloudwatch_metrics_enabled")

    @cloudwatch_metrics_enabled.setter
    def cloudwatch_metrics_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "cloudwatch_metrics_enabled", value)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> pulumi.Input[str]:
        """
        A friendly name of the CloudWatch metric. The name can contain only alphanumeric characters (A-Z, a-z, 0-9) hyphen(-) and underscore (\\_), with length from one to 128 characters. It can't contain whitespace or metric names reserved for AWS WAF, for example `All` and `Default_Action`.
        """
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric_name", value)

    @property
    @pulumi.getter(name="sampledRequestsEnabled")
    def sampled_requests_enabled(self) -> pulumi.Input[bool]:
        """
        Whether AWS WAF should store a sampling of the web requests that match the rules. You can view the sampled requests through the AWS WAF console.
        """
        return pulumi.get(self, "sampled_requests_enabled")

    @sampled_requests_enabled.setter
    def sampled_requests_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "sampled_requests_enabled", value)


