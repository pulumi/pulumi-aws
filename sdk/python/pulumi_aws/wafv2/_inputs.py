# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = [
    'RegexPatternSetRegularExpressionArgs',
    'RuleGroupCustomResponseBodyArgs',
    'RuleGroupRuleArgs',
    'RuleGroupRuleActionArgs',
    'RuleGroupRuleActionAllowArgs',
    'RuleGroupRuleActionAllowCustomRequestHandlingArgs',
    'RuleGroupRuleActionAllowCustomRequestHandlingInsertHeaderArgs',
    'RuleGroupRuleActionBlockArgs',
    'RuleGroupRuleActionBlockCustomResponseArgs',
    'RuleGroupRuleActionBlockCustomResponseResponseHeaderArgs',
    'RuleGroupRuleActionCaptchaArgs',
    'RuleGroupRuleActionCaptchaCustomRequestHandlingArgs',
    'RuleGroupRuleActionCaptchaCustomRequestHandlingInsertHeaderArgs',
    'RuleGroupRuleActionChallengeArgs',
    'RuleGroupRuleActionChallengeCustomRequestHandlingArgs',
    'RuleGroupRuleActionChallengeCustomRequestHandlingInsertHeaderArgs',
    'RuleGroupRuleActionCountArgs',
    'RuleGroupRuleActionCountCustomRequestHandlingArgs',
    'RuleGroupRuleActionCountCustomRequestHandlingInsertHeaderArgs',
    'RuleGroupRuleCaptchaConfigArgs',
    'RuleGroupRuleCaptchaConfigImmunityTimePropertyArgs',
    'RuleGroupRuleRuleLabelArgs',
    'RuleGroupRuleStatementArgs',
    'RuleGroupRuleStatementAndStatementArgs',
    'RuleGroupRuleStatementByteMatchStatementArgs',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchArgs',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchBodyArgs',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesArgs',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderArgs',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderOrderArgs',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchJa3FingerprintArgs',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyArgs',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchMethodArgs',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchQueryStringArgs',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleHeaderArgs',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchUriPathArgs',
    'RuleGroupRuleStatementByteMatchStatementTextTransformationArgs',
    'RuleGroupRuleStatementGeoMatchStatementArgs',
    'RuleGroupRuleStatementGeoMatchStatementForwardedIpConfigArgs',
    'RuleGroupRuleStatementIpSetReferenceStatementArgs',
    'RuleGroupRuleStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs',
    'RuleGroupRuleStatementLabelMatchStatementArgs',
    'RuleGroupRuleStatementNotStatementArgs',
    'RuleGroupRuleStatementOrStatementArgs',
    'RuleGroupRuleStatementRateBasedStatementArgs',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyArgs',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyCookieArgs',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyCookieTextTransformationArgs',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyForwardedIpArgs',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyHeaderArgs',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyHeaderTextTransformationArgs',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyHttpMethodArgs',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyIpArgs',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyLabelNamespaceArgs',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgumentArgs',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformationArgs',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyQueryStringArgs',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformationArgs',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyUriPathArgs',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyUriPathTextTransformationArgs',
    'RuleGroupRuleStatementRateBasedStatementForwardedIpConfigArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementAndStatementArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformationArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatementArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementNotStatementArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementOrStatementArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformationArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformationArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformationArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformationArgs',
    'RuleGroupRuleStatementRegexMatchStatementArgs',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchArgs',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchBodyArgs',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesArgs',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderArgs',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderOrderArgs',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyArgs',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchMethodArgs',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchQueryStringArgs',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleHeaderArgs',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchUriPathArgs',
    'RuleGroupRuleStatementRegexMatchStatementTextTransformationArgs',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementArgs',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchArgs',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementTextTransformationArgs',
    'RuleGroupRuleStatementSizeConstraintStatementArgs',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchArgs',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchBodyArgs',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesArgs',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderArgs',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyArgs',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchMethodArgs',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchQueryStringArgs',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchUriPathArgs',
    'RuleGroupRuleStatementSizeConstraintStatementTextTransformationArgs',
    'RuleGroupRuleStatementSqliMatchStatementArgs',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchArgs',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchBodyArgs',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesArgs',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderArgs',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderOrderArgs',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyArgs',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchMethodArgs',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchQueryStringArgs',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleHeaderArgs',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchUriPathArgs',
    'RuleGroupRuleStatementSqliMatchStatementTextTransformationArgs',
    'RuleGroupRuleStatementXssMatchStatementArgs',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchArgs',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchBodyArgs',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesArgs',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderArgs',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderOrderArgs',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchJa3FingerprintArgs',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyArgs',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchMethodArgs',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchQueryStringArgs',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleHeaderArgs',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchUriPathArgs',
    'RuleGroupRuleStatementXssMatchStatementTextTransformationArgs',
    'RuleGroupRuleVisibilityConfigArgs',
    'RuleGroupVisibilityConfigArgs',
    'WebAclAssociationConfigArgs',
    'WebAclAssociationConfigRequestBodyArgs',
    'WebAclAssociationConfigRequestBodyCloudfrontArgs',
    'WebAclCaptchaConfigArgs',
    'WebAclCaptchaConfigImmunityTimePropertyArgs',
    'WebAclChallengeConfigArgs',
    'WebAclChallengeConfigImmunityTimePropertyArgs',
    'WebAclCustomResponseBodyArgs',
    'WebAclDefaultActionArgs',
    'WebAclDefaultActionAllowArgs',
    'WebAclDefaultActionAllowCustomRequestHandlingArgs',
    'WebAclDefaultActionAllowCustomRequestHandlingInsertHeaderArgs',
    'WebAclDefaultActionBlockArgs',
    'WebAclDefaultActionBlockCustomResponseArgs',
    'WebAclDefaultActionBlockCustomResponseResponseHeaderArgs',
    'WebAclLoggingConfigurationLoggingFilterArgs',
    'WebAclLoggingConfigurationLoggingFilterFilterArgs',
    'WebAclLoggingConfigurationLoggingFilterFilterConditionArgs',
    'WebAclLoggingConfigurationLoggingFilterFilterConditionActionConditionArgs',
    'WebAclLoggingConfigurationLoggingFilterFilterConditionLabelNameConditionArgs',
    'WebAclLoggingConfigurationRedactedFieldArgs',
    'WebAclLoggingConfigurationRedactedFieldMethodArgs',
    'WebAclLoggingConfigurationRedactedFieldQueryStringArgs',
    'WebAclLoggingConfigurationRedactedFieldSingleHeaderArgs',
    'WebAclLoggingConfigurationRedactedFieldUriPathArgs',
    'WebAclRuleArgs',
    'WebAclRuleActionArgs',
    'WebAclRuleActionAllowArgs',
    'WebAclRuleActionAllowCustomRequestHandlingArgs',
    'WebAclRuleActionAllowCustomRequestHandlingInsertHeaderArgs',
    'WebAclRuleActionBlockArgs',
    'WebAclRuleActionBlockCustomResponseArgs',
    'WebAclRuleActionBlockCustomResponseResponseHeaderArgs',
    'WebAclRuleActionCaptchaArgs',
    'WebAclRuleActionCaptchaCustomRequestHandlingArgs',
    'WebAclRuleActionCaptchaCustomRequestHandlingInsertHeaderArgs',
    'WebAclRuleActionChallengeArgs',
    'WebAclRuleActionChallengeCustomRequestHandlingArgs',
    'WebAclRuleActionChallengeCustomRequestHandlingInsertHeaderArgs',
    'WebAclRuleActionCountArgs',
    'WebAclRuleActionCountCustomRequestHandlingArgs',
    'WebAclRuleActionCountCustomRequestHandlingInsertHeaderArgs',
    'WebAclRuleCaptchaConfigArgs',
    'WebAclRuleCaptchaConfigImmunityTimePropertyArgs',
    'WebAclRuleOverrideActionArgs',
    'WebAclRuleOverrideActionCountArgs',
    'WebAclRuleOverrideActionNoneArgs',
    'WebAclRuleRuleLabelArgs',
    'WebAclRuleStatementArgs',
    'WebAclRuleStatementAndStatementArgs',
    'WebAclRuleStatementByteMatchStatementArgs',
    'WebAclRuleStatementByteMatchStatementFieldToMatchArgs',
    'WebAclRuleStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs',
    'WebAclRuleStatementByteMatchStatementFieldToMatchBodyArgs',
    'WebAclRuleStatementByteMatchStatementFieldToMatchCookiesArgs',
    'WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs',
    'WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs',
    'WebAclRuleStatementByteMatchStatementFieldToMatchHeaderArgs',
    'WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs',
    'WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs',
    'WebAclRuleStatementByteMatchStatementFieldToMatchHeaderOrderArgs',
    'WebAclRuleStatementByteMatchStatementFieldToMatchJa3FingerprintArgs',
    'WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyArgs',
    'WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs',
    'WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'WebAclRuleStatementByteMatchStatementFieldToMatchMethodArgs',
    'WebAclRuleStatementByteMatchStatementFieldToMatchQueryStringArgs',
    'WebAclRuleStatementByteMatchStatementFieldToMatchSingleHeaderArgs',
    'WebAclRuleStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs',
    'WebAclRuleStatementByteMatchStatementFieldToMatchUriPathArgs',
    'WebAclRuleStatementByteMatchStatementTextTransformationArgs',
    'WebAclRuleStatementGeoMatchStatementArgs',
    'WebAclRuleStatementGeoMatchStatementForwardedIpConfigArgs',
    'WebAclRuleStatementIpSetReferenceStatementArgs',
    'WebAclRuleStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs',
    'WebAclRuleStatementLabelMatchStatementArgs',
    'WebAclRuleStatementManagedRuleGroupStatementArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionEmailFieldArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionPasswordFieldArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionUsernameFieldArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionBodyContainsArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionHeaderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionJsonArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionStatusCodeArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionPasswordFieldArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionUsernameFieldArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionBodyContainsArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionHeaderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionJsonArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionStatusCodeArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesBotControlRuleSetArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigPasswordFieldArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigUsernameFieldArgs',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideArgs',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseArgs',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowArgs',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingArgs',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeaderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockArgs',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponseArgs',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeaderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaArgs',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingArgs',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeaderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeArgs',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingArgs',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeaderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountArgs',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandlingArgs',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeaderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAndStatementArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementTextTransformationArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementLabelMatchStatementArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementNotStatementArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementOrStatementArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementTextTransformationArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementTextTransformationArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementTextTransformationArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementTextTransformationArgs',
    'WebAclRuleStatementNotStatementArgs',
    'WebAclRuleStatementOrStatementArgs',
    'WebAclRuleStatementRateBasedStatementArgs',
    'WebAclRuleStatementRateBasedStatementCustomKeyArgs',
    'WebAclRuleStatementRateBasedStatementCustomKeyCookieArgs',
    'WebAclRuleStatementRateBasedStatementCustomKeyCookieTextTransformationArgs',
    'WebAclRuleStatementRateBasedStatementCustomKeyForwardedIpArgs',
    'WebAclRuleStatementRateBasedStatementCustomKeyHeaderArgs',
    'WebAclRuleStatementRateBasedStatementCustomKeyHeaderTextTransformationArgs',
    'WebAclRuleStatementRateBasedStatementCustomKeyHttpMethodArgs',
    'WebAclRuleStatementRateBasedStatementCustomKeyIpArgs',
    'WebAclRuleStatementRateBasedStatementCustomKeyLabelNamespaceArgs',
    'WebAclRuleStatementRateBasedStatementCustomKeyQueryArgumentArgs',
    'WebAclRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformationArgs',
    'WebAclRuleStatementRateBasedStatementCustomKeyQueryStringArgs',
    'WebAclRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformationArgs',
    'WebAclRuleStatementRateBasedStatementCustomKeyUriPathArgs',
    'WebAclRuleStatementRateBasedStatementCustomKeyUriPathTextTransformationArgs',
    'WebAclRuleStatementRateBasedStatementForwardedIpConfigArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementAndStatementArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformationArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatementArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementNotStatementArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementOrStatementArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformationArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformationArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformationArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformationArgs',
    'WebAclRuleStatementRegexMatchStatementArgs',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchArgs',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchBodyArgs',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesArgs',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderArgs',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderOrderArgs',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyArgs',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchMethodArgs',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchQueryStringArgs',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchSingleHeaderArgs',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchUriPathArgs',
    'WebAclRuleStatementRegexMatchStatementTextTransformationArgs',
    'WebAclRuleStatementRegexPatternSetReferenceStatementArgs',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchArgs',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs',
    'WebAclRuleStatementRegexPatternSetReferenceStatementTextTransformationArgs',
    'WebAclRuleStatementRuleGroupReferenceStatementArgs',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideArgs',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseArgs',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowArgs',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingArgs',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeaderArgs',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockArgs',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponseArgs',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeaderArgs',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaArgs',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingArgs',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeaderArgs',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeArgs',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingArgs',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeaderArgs',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountArgs',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandlingArgs',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeaderArgs',
    'WebAclRuleStatementSizeConstraintStatementArgs',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchArgs',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchBodyArgs',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesArgs',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderArgs',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyArgs',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchMethodArgs',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchQueryStringArgs',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchUriPathArgs',
    'WebAclRuleStatementSizeConstraintStatementTextTransformationArgs',
    'WebAclRuleStatementSqliMatchStatementArgs',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchArgs',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchBodyArgs',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesArgs',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderArgs',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderOrderArgs',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyArgs',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchMethodArgs',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchQueryStringArgs',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchSingleHeaderArgs',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchUriPathArgs',
    'WebAclRuleStatementSqliMatchStatementTextTransformationArgs',
    'WebAclRuleStatementXssMatchStatementArgs',
    'WebAclRuleStatementXssMatchStatementFieldToMatchArgs',
    'WebAclRuleStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs',
    'WebAclRuleStatementXssMatchStatementFieldToMatchBodyArgs',
    'WebAclRuleStatementXssMatchStatementFieldToMatchCookiesArgs',
    'WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs',
    'WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs',
    'WebAclRuleStatementXssMatchStatementFieldToMatchHeaderArgs',
    'WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs',
    'WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs',
    'WebAclRuleStatementXssMatchStatementFieldToMatchHeaderOrderArgs',
    'WebAclRuleStatementXssMatchStatementFieldToMatchJa3FingerprintArgs',
    'WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyArgs',
    'WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs',
    'WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'WebAclRuleStatementXssMatchStatementFieldToMatchMethodArgs',
    'WebAclRuleStatementXssMatchStatementFieldToMatchQueryStringArgs',
    'WebAclRuleStatementXssMatchStatementFieldToMatchSingleHeaderArgs',
    'WebAclRuleStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs',
    'WebAclRuleStatementXssMatchStatementFieldToMatchUriPathArgs',
    'WebAclRuleStatementXssMatchStatementTextTransformationArgs',
    'WebAclRuleVisibilityConfigArgs',
    'WebAclVisibilityConfigArgs',
]

@pulumi.input_type
class RegexPatternSetRegularExpressionArgs:
    def __init__(__self__, *,
                 regex_string: pulumi.Input[str]):
        """
        :param pulumi.Input[str] regex_string: The string representing the regular expression, see the AWS WAF [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-regex-pattern-set-creating.html) for more information.
        """
        pulumi.set(__self__, "regex_string", regex_string)

    @property
    @pulumi.getter(name="regexString")
    def regex_string(self) -> pulumi.Input[str]:
        """
        The string representing the regular expression, see the AWS WAF [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-regex-pattern-set-creating.html) for more information.
        """
        return pulumi.get(self, "regex_string")

    @regex_string.setter
    def regex_string(self, value: pulumi.Input[str]):
        pulumi.set(self, "regex_string", value)


@pulumi.input_type
class RuleGroupCustomResponseBodyArgs:
    def __init__(__self__, *,
                 content: pulumi.Input[str],
                 content_type: pulumi.Input[str],
                 key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] content: The payload of the custom response.
        :param pulumi.Input[str] content_type: The type of content in the payload that you are defining in the `content` argument. Valid values are `TEXT_PLAIN`, `TEXT_HTML`, or `APPLICATION_JSON`.
        :param pulumi.Input[str] key: A unique key identifying the custom response body. This is referenced by the `custom_response_body_key` argument in the Custom Response block.
        """
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "content_type", content_type)
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def content(self) -> pulumi.Input[str]:
        """
        The payload of the custom response.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: pulumi.Input[str]):
        pulumi.set(self, "content", value)

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> pulumi.Input[str]:
        """
        The type of content in the payload that you are defining in the `content` argument. Valid values are `TEXT_PLAIN`, `TEXT_HTML`, or `APPLICATION_JSON`.
        """
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "content_type", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        A unique key identifying the custom response body. This is referenced by the `custom_response_body_key` argument in the Custom Response block.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)


@pulumi.input_type
class RuleGroupRuleArgs:
    def __init__(__self__, *,
                 action: pulumi.Input['RuleGroupRuleActionArgs'],
                 name: pulumi.Input[str],
                 priority: pulumi.Input[int],
                 statement: pulumi.Input['RuleGroupRuleStatementArgs'],
                 visibility_config: pulumi.Input['RuleGroupRuleVisibilityConfigArgs'],
                 captcha_config: Optional[pulumi.Input['RuleGroupRuleCaptchaConfigArgs']] = None,
                 rule_labels: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleRuleLabelArgs']]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleActionArgs'] action: The action that AWS WAF should take on a web request when it matches the rule's statement. Settings at the `wafv2.WebAcl` level can override the rule action setting. See Action below for details.
        :param pulumi.Input[str] name: A friendly name of the rule.
        :param pulumi.Input[int] priority: If you define more than one Rule in a WebACL, AWS WAF evaluates each request against the `rules` in order based on the value of `priority`. AWS WAF processes rules with lower priority first.
        :param pulumi.Input['RuleGroupRuleStatementArgs'] statement: The AWS WAF processing statement for the rule, for example `byte_match_statement` or `geo_match_statement`. See Statement below for details.
        :param pulumi.Input['RuleGroupRuleVisibilityConfigArgs'] visibility_config: Defines and enables Amazon CloudWatch metrics and web request sample collection. See Visibility Configuration below for details.
        :param pulumi.Input['RuleGroupRuleCaptchaConfigArgs'] captcha_config: Specifies how AWS WAF should handle CAPTCHA evaluations. See Captcha Configuration below for details.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleRuleLabelArgs']]] rule_labels: Labels to apply to web requests that match the rule match statement. See Rule Label below for details.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "statement", statement)
        pulumi.set(__self__, "visibility_config", visibility_config)
        if captcha_config is not None:
            pulumi.set(__self__, "captcha_config", captcha_config)
        if rule_labels is not None:
            pulumi.set(__self__, "rule_labels", rule_labels)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input['RuleGroupRuleActionArgs']:
        """
        The action that AWS WAF should take on a web request when it matches the rule's statement. Settings at the `wafv2.WebAcl` level can override the rule action setting. See Action below for details.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input['RuleGroupRuleActionArgs']):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        A friendly name of the rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        If you define more than one Rule in a WebACL, AWS WAF evaluates each request against the `rules` in order based on the value of `priority`. AWS WAF processes rules with lower priority first.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def statement(self) -> pulumi.Input['RuleGroupRuleStatementArgs']:
        """
        The AWS WAF processing statement for the rule, for example `byte_match_statement` or `geo_match_statement`. See Statement below for details.
        """
        return pulumi.get(self, "statement")

    @statement.setter
    def statement(self, value: pulumi.Input['RuleGroupRuleStatementArgs']):
        pulumi.set(self, "statement", value)

    @property
    @pulumi.getter(name="visibilityConfig")
    def visibility_config(self) -> pulumi.Input['RuleGroupRuleVisibilityConfigArgs']:
        """
        Defines and enables Amazon CloudWatch metrics and web request sample collection. See Visibility Configuration below for details.
        """
        return pulumi.get(self, "visibility_config")

    @visibility_config.setter
    def visibility_config(self, value: pulumi.Input['RuleGroupRuleVisibilityConfigArgs']):
        pulumi.set(self, "visibility_config", value)

    @property
    @pulumi.getter(name="captchaConfig")
    def captcha_config(self) -> Optional[pulumi.Input['RuleGroupRuleCaptchaConfigArgs']]:
        """
        Specifies how AWS WAF should handle CAPTCHA evaluations. See Captcha Configuration below for details.
        """
        return pulumi.get(self, "captcha_config")

    @captcha_config.setter
    def captcha_config(self, value: Optional[pulumi.Input['RuleGroupRuleCaptchaConfigArgs']]):
        pulumi.set(self, "captcha_config", value)

    @property
    @pulumi.getter(name="ruleLabels")
    def rule_labels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleRuleLabelArgs']]]]:
        """
        Labels to apply to web requests that match the rule match statement. See Rule Label below for details.
        """
        return pulumi.get(self, "rule_labels")

    @rule_labels.setter
    def rule_labels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleRuleLabelArgs']]]]):
        pulumi.set(self, "rule_labels", value)


@pulumi.input_type
class RuleGroupRuleActionArgs:
    def __init__(__self__, *,
                 allow: Optional[pulumi.Input['RuleGroupRuleActionAllowArgs']] = None,
                 block: Optional[pulumi.Input['RuleGroupRuleActionBlockArgs']] = None,
                 captcha: Optional[pulumi.Input['RuleGroupRuleActionCaptchaArgs']] = None,
                 challenge: Optional[pulumi.Input['RuleGroupRuleActionChallengeArgs']] = None,
                 count: Optional[pulumi.Input['RuleGroupRuleActionCountArgs']] = None):
        """
        :param pulumi.Input['RuleGroupRuleActionAllowArgs'] allow: Instructs AWS WAF to allow the web request. See Allow below for details.
        :param pulumi.Input['RuleGroupRuleActionBlockArgs'] block: Instructs AWS WAF to block the web request. See Block below for details.
        :param pulumi.Input['RuleGroupRuleActionCaptchaArgs'] captcha: Instructs AWS WAF to run a `CAPTCHA` check against the web request. See Captcha below for details.
        :param pulumi.Input['RuleGroupRuleActionChallengeArgs'] challenge: Instructs AWS WAF to run a check against the request to verify that the request is coming from a legitimate client session. See Challenge below for details.
        :param pulumi.Input['RuleGroupRuleActionCountArgs'] count: Instructs AWS WAF to count the web request and allow it. See Count below for details.
        """
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if block is not None:
            pulumi.set(__self__, "block", block)
        if captcha is not None:
            pulumi.set(__self__, "captcha", captcha)
        if challenge is not None:
            pulumi.set(__self__, "challenge", challenge)
        if count is not None:
            pulumi.set(__self__, "count", count)

    @property
    @pulumi.getter
    def allow(self) -> Optional[pulumi.Input['RuleGroupRuleActionAllowArgs']]:
        """
        Instructs AWS WAF to allow the web request. See Allow below for details.
        """
        return pulumi.get(self, "allow")

    @allow.setter
    def allow(self, value: Optional[pulumi.Input['RuleGroupRuleActionAllowArgs']]):
        pulumi.set(self, "allow", value)

    @property
    @pulumi.getter
    def block(self) -> Optional[pulumi.Input['RuleGroupRuleActionBlockArgs']]:
        """
        Instructs AWS WAF to block the web request. See Block below for details.
        """
        return pulumi.get(self, "block")

    @block.setter
    def block(self, value: Optional[pulumi.Input['RuleGroupRuleActionBlockArgs']]):
        pulumi.set(self, "block", value)

    @property
    @pulumi.getter
    def captcha(self) -> Optional[pulumi.Input['RuleGroupRuleActionCaptchaArgs']]:
        """
        Instructs AWS WAF to run a `CAPTCHA` check against the web request. See Captcha below for details.
        """
        return pulumi.get(self, "captcha")

    @captcha.setter
    def captcha(self, value: Optional[pulumi.Input['RuleGroupRuleActionCaptchaArgs']]):
        pulumi.set(self, "captcha", value)

    @property
    @pulumi.getter
    def challenge(self) -> Optional[pulumi.Input['RuleGroupRuleActionChallengeArgs']]:
        """
        Instructs AWS WAF to run a check against the request to verify that the request is coming from a legitimate client session. See Challenge below for details.
        """
        return pulumi.get(self, "challenge")

    @challenge.setter
    def challenge(self, value: Optional[pulumi.Input['RuleGroupRuleActionChallengeArgs']]):
        pulumi.set(self, "challenge", value)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input['RuleGroupRuleActionCountArgs']]:
        """
        Instructs AWS WAF to count the web request and allow it. See Count below for details.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input['RuleGroupRuleActionCountArgs']]):
        pulumi.set(self, "count", value)


@pulumi.input_type
class RuleGroupRuleActionAllowArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['RuleGroupRuleActionAllowCustomRequestHandlingArgs']] = None):
        """
        :param pulumi.Input['RuleGroupRuleActionAllowCustomRequestHandlingArgs'] custom_request_handling: Defines custom handling for the web request. See Custom Request Handling below for details.
        """
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['RuleGroupRuleActionAllowCustomRequestHandlingArgs']]:
        """
        Defines custom handling for the web request. See Custom Request Handling below for details.
        """
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['RuleGroupRuleActionAllowCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


@pulumi.input_type
class RuleGroupRuleActionAllowCustomRequestHandlingArgs:
    def __init__(__self__, *,
                 insert_headers: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleActionAllowCustomRequestHandlingInsertHeaderArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleActionAllowCustomRequestHandlingInsertHeaderArgs']]] insert_headers: The `insert_header` blocks used to define HTTP headers added to the request. See Custom HTTP Header below for details.
        """
        pulumi.set(__self__, "insert_headers", insert_headers)

    @property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleActionAllowCustomRequestHandlingInsertHeaderArgs']]]:
        """
        The `insert_header` blocks used to define HTTP headers added to the request. See Custom HTTP Header below for details.
        """
        return pulumi.get(self, "insert_headers")

    @insert_headers.setter
    def insert_headers(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleActionAllowCustomRequestHandlingInsertHeaderArgs']]]):
        pulumi.set(self, "insert_headers", value)


@pulumi.input_type
class RuleGroupRuleActionAllowCustomRequestHandlingInsertHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: A friendly name of the rule group.
        :param pulumi.Input[str] value: The value of the custom header.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        A friendly name of the rule group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The value of the custom header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class RuleGroupRuleActionBlockArgs:
    def __init__(__self__, *,
                 custom_response: Optional[pulumi.Input['RuleGroupRuleActionBlockCustomResponseArgs']] = None):
        """
        :param pulumi.Input['RuleGroupRuleActionBlockCustomResponseArgs'] custom_response: Defines a custom response for the web request. See Custom Response below for details.
        """
        if custom_response is not None:
            pulumi.set(__self__, "custom_response", custom_response)

    @property
    @pulumi.getter(name="customResponse")
    def custom_response(self) -> Optional[pulumi.Input['RuleGroupRuleActionBlockCustomResponseArgs']]:
        """
        Defines a custom response for the web request. See Custom Response below for details.
        """
        return pulumi.get(self, "custom_response")

    @custom_response.setter
    def custom_response(self, value: Optional[pulumi.Input['RuleGroupRuleActionBlockCustomResponseArgs']]):
        pulumi.set(self, "custom_response", value)


@pulumi.input_type
class RuleGroupRuleActionBlockCustomResponseArgs:
    def __init__(__self__, *,
                 response_code: pulumi.Input[int],
                 custom_response_body_key: Optional[pulumi.Input[str]] = None,
                 response_headers: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleActionBlockCustomResponseResponseHeaderArgs']]]] = None):
        """
        :param pulumi.Input[int] response_code: The HTTP status code to return to the client.
        :param pulumi.Input[str] custom_response_body_key: References the response body that you want AWS WAF to return to the web request client. This must reference a `key` defined in a `custom_response_body` block of this resource.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleActionBlockCustomResponseResponseHeaderArgs']]] response_headers: The `response_header` blocks used to define the HTTP response headers added to the response. See Custom HTTP Header below for details.
        """
        pulumi.set(__self__, "response_code", response_code)
        if custom_response_body_key is not None:
            pulumi.set(__self__, "custom_response_body_key", custom_response_body_key)
        if response_headers is not None:
            pulumi.set(__self__, "response_headers", response_headers)

    @property
    @pulumi.getter(name="responseCode")
    def response_code(self) -> pulumi.Input[int]:
        """
        The HTTP status code to return to the client.
        """
        return pulumi.get(self, "response_code")

    @response_code.setter
    def response_code(self, value: pulumi.Input[int]):
        pulumi.set(self, "response_code", value)

    @property
    @pulumi.getter(name="customResponseBodyKey")
    def custom_response_body_key(self) -> Optional[pulumi.Input[str]]:
        """
        References the response body that you want AWS WAF to return to the web request client. This must reference a `key` defined in a `custom_response_body` block of this resource.
        """
        return pulumi.get(self, "custom_response_body_key")

    @custom_response_body_key.setter
    def custom_response_body_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_response_body_key", value)

    @property
    @pulumi.getter(name="responseHeaders")
    def response_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleActionBlockCustomResponseResponseHeaderArgs']]]]:
        """
        The `response_header` blocks used to define the HTTP response headers added to the response. See Custom HTTP Header below for details.
        """
        return pulumi.get(self, "response_headers")

    @response_headers.setter
    def response_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleActionBlockCustomResponseResponseHeaderArgs']]]]):
        pulumi.set(self, "response_headers", value)


@pulumi.input_type
class RuleGroupRuleActionBlockCustomResponseResponseHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: A friendly name of the rule group.
        :param pulumi.Input[str] value: The value of the custom header.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        A friendly name of the rule group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The value of the custom header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class RuleGroupRuleActionCaptchaArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['RuleGroupRuleActionCaptchaCustomRequestHandlingArgs']] = None):
        """
        :param pulumi.Input['RuleGroupRuleActionCaptchaCustomRequestHandlingArgs'] custom_request_handling: Defines custom handling for the web request. See Custom Request Handling below for details.
        """
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['RuleGroupRuleActionCaptchaCustomRequestHandlingArgs']]:
        """
        Defines custom handling for the web request. See Custom Request Handling below for details.
        """
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['RuleGroupRuleActionCaptchaCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


@pulumi.input_type
class RuleGroupRuleActionCaptchaCustomRequestHandlingArgs:
    def __init__(__self__, *,
                 insert_headers: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleActionCaptchaCustomRequestHandlingInsertHeaderArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleActionCaptchaCustomRequestHandlingInsertHeaderArgs']]] insert_headers: The `insert_header` blocks used to define HTTP headers added to the request. See Custom HTTP Header below for details.
        """
        pulumi.set(__self__, "insert_headers", insert_headers)

    @property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleActionCaptchaCustomRequestHandlingInsertHeaderArgs']]]:
        """
        The `insert_header` blocks used to define HTTP headers added to the request. See Custom HTTP Header below for details.
        """
        return pulumi.get(self, "insert_headers")

    @insert_headers.setter
    def insert_headers(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleActionCaptchaCustomRequestHandlingInsertHeaderArgs']]]):
        pulumi.set(self, "insert_headers", value)


@pulumi.input_type
class RuleGroupRuleActionCaptchaCustomRequestHandlingInsertHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: A friendly name of the rule group.
        :param pulumi.Input[str] value: The value of the custom header.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        A friendly name of the rule group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The value of the custom header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class RuleGroupRuleActionChallengeArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['RuleGroupRuleActionChallengeCustomRequestHandlingArgs']] = None):
        """
        :param pulumi.Input['RuleGroupRuleActionChallengeCustomRequestHandlingArgs'] custom_request_handling: Defines custom handling for the web request. See Custom Request Handling below for details.
        """
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['RuleGroupRuleActionChallengeCustomRequestHandlingArgs']]:
        """
        Defines custom handling for the web request. See Custom Request Handling below for details.
        """
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['RuleGroupRuleActionChallengeCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


@pulumi.input_type
class RuleGroupRuleActionChallengeCustomRequestHandlingArgs:
    def __init__(__self__, *,
                 insert_headers: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleActionChallengeCustomRequestHandlingInsertHeaderArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleActionChallengeCustomRequestHandlingInsertHeaderArgs']]] insert_headers: The `insert_header` blocks used to define HTTP headers added to the request. See Custom HTTP Header below for details.
        """
        pulumi.set(__self__, "insert_headers", insert_headers)

    @property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleActionChallengeCustomRequestHandlingInsertHeaderArgs']]]:
        """
        The `insert_header` blocks used to define HTTP headers added to the request. See Custom HTTP Header below for details.
        """
        return pulumi.get(self, "insert_headers")

    @insert_headers.setter
    def insert_headers(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleActionChallengeCustomRequestHandlingInsertHeaderArgs']]]):
        pulumi.set(self, "insert_headers", value)


@pulumi.input_type
class RuleGroupRuleActionChallengeCustomRequestHandlingInsertHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: A friendly name of the rule group.
        :param pulumi.Input[str] value: The value of the custom header.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        A friendly name of the rule group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The value of the custom header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class RuleGroupRuleActionCountArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['RuleGroupRuleActionCountCustomRequestHandlingArgs']] = None):
        """
        :param pulumi.Input['RuleGroupRuleActionCountCustomRequestHandlingArgs'] custom_request_handling: Defines custom handling for the web request. See Custom Request Handling below for details.
        """
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['RuleGroupRuleActionCountCustomRequestHandlingArgs']]:
        """
        Defines custom handling for the web request. See Custom Request Handling below for details.
        """
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['RuleGroupRuleActionCountCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


@pulumi.input_type
class RuleGroupRuleActionCountCustomRequestHandlingArgs:
    def __init__(__self__, *,
                 insert_headers: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleActionCountCustomRequestHandlingInsertHeaderArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleActionCountCustomRequestHandlingInsertHeaderArgs']]] insert_headers: The `insert_header` blocks used to define HTTP headers added to the request. See Custom HTTP Header below for details.
        """
        pulumi.set(__self__, "insert_headers", insert_headers)

    @property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleActionCountCustomRequestHandlingInsertHeaderArgs']]]:
        """
        The `insert_header` blocks used to define HTTP headers added to the request. See Custom HTTP Header below for details.
        """
        return pulumi.get(self, "insert_headers")

    @insert_headers.setter
    def insert_headers(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleActionCountCustomRequestHandlingInsertHeaderArgs']]]):
        pulumi.set(self, "insert_headers", value)


@pulumi.input_type
class RuleGroupRuleActionCountCustomRequestHandlingInsertHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: A friendly name of the rule group.
        :param pulumi.Input[str] value: The value of the custom header.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        A friendly name of the rule group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The value of the custom header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class RuleGroupRuleCaptchaConfigArgs:
    def __init__(__self__, *,
                 immunity_time_property: Optional[pulumi.Input['RuleGroupRuleCaptchaConfigImmunityTimePropertyArgs']] = None):
        """
        :param pulumi.Input['RuleGroupRuleCaptchaConfigImmunityTimePropertyArgs'] immunity_time_property: Defines custom immunity time. See Immunity Time Property below for details.
        """
        if immunity_time_property is not None:
            pulumi.set(__self__, "immunity_time_property", immunity_time_property)

    @property
    @pulumi.getter(name="immunityTimeProperty")
    def immunity_time_property(self) -> Optional[pulumi.Input['RuleGroupRuleCaptchaConfigImmunityTimePropertyArgs']]:
        """
        Defines custom immunity time. See Immunity Time Property below for details.
        """
        return pulumi.get(self, "immunity_time_property")

    @immunity_time_property.setter
    def immunity_time_property(self, value: Optional[pulumi.Input['RuleGroupRuleCaptchaConfigImmunityTimePropertyArgs']]):
        pulumi.set(self, "immunity_time_property", value)


@pulumi.input_type
class RuleGroupRuleCaptchaConfigImmunityTimePropertyArgs:
    def __init__(__self__, *,
                 immunity_time: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] immunity_time: The amount of time, in seconds, that a CAPTCHA or challenge timestamp is considered valid by AWS WAF. The default setting is 300.
        """
        if immunity_time is not None:
            pulumi.set(__self__, "immunity_time", immunity_time)

    @property
    @pulumi.getter(name="immunityTime")
    def immunity_time(self) -> Optional[pulumi.Input[int]]:
        """
        The amount of time, in seconds, that a CAPTCHA or challenge timestamp is considered valid by AWS WAF. The default setting is 300.
        """
        return pulumi.get(self, "immunity_time")

    @immunity_time.setter
    def immunity_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "immunity_time", value)


@pulumi.input_type
class RuleGroupRuleRuleLabelArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The label string.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The label string.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class RuleGroupRuleStatementArgs:
    def __init__(__self__, *,
                 and_statement: Optional[pulumi.Input['RuleGroupRuleStatementAndStatementArgs']] = None,
                 byte_match_statement: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementArgs']] = None,
                 geo_match_statement: Optional[pulumi.Input['RuleGroupRuleStatementGeoMatchStatementArgs']] = None,
                 ip_set_reference_statement: Optional[pulumi.Input['RuleGroupRuleStatementIpSetReferenceStatementArgs']] = None,
                 label_match_statement: Optional[pulumi.Input['RuleGroupRuleStatementLabelMatchStatementArgs']] = None,
                 not_statement: Optional[pulumi.Input['RuleGroupRuleStatementNotStatementArgs']] = None,
                 or_statement: Optional[pulumi.Input['RuleGroupRuleStatementOrStatementArgs']] = None,
                 rate_based_statement: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementArgs']] = None,
                 regex_match_statement: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementArgs']] = None,
                 regex_pattern_set_reference_statement: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementArgs']] = None,
                 size_constraint_statement: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementArgs']] = None,
                 sqli_match_statement: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementArgs']] = None,
                 xss_match_statement: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementArgs']] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementAndStatementArgs'] and_statement: A logical rule statement used to combine other rule statements with AND logic. See AND Statement below for details.
        :param pulumi.Input['RuleGroupRuleStatementByteMatchStatementArgs'] byte_match_statement: A rule statement that defines a string match search for AWS WAF to apply to web requests. See Byte Match Statement below for details.
        :param pulumi.Input['RuleGroupRuleStatementGeoMatchStatementArgs'] geo_match_statement: A rule statement used to identify web requests based on country of origin. See GEO Match Statement below for details.
        :param pulumi.Input['RuleGroupRuleStatementIpSetReferenceStatementArgs'] ip_set_reference_statement: A rule statement used to detect web requests coming from particular IP addresses or address ranges. See IP Set Reference Statement below for details.
        :param pulumi.Input['RuleGroupRuleStatementLabelMatchStatementArgs'] label_match_statement: A rule statement that defines a string match search against labels that have been added to the web request by rules that have already run in the web ACL. See Label Match Statement below for details.
        :param pulumi.Input['RuleGroupRuleStatementNotStatementArgs'] not_statement: A logical rule statement used to negate the results of another rule statement. See NOT Statement below for details.
        :param pulumi.Input['RuleGroupRuleStatementOrStatementArgs'] or_statement: A logical rule statement used to combine other rule statements with OR logic. See OR Statement below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementArgs'] rate_based_statement: A rate-based rule tracks the rate of requests for each originating `IP address`, and triggers the rule action when the rate exceeds a limit that you specify on the number of requests in any `5-minute` time span. This statement can not be nested. See Rate Based Statement below for details.
        :param pulumi.Input['RuleGroupRuleStatementRegexMatchStatementArgs'] regex_match_statement: A rule statement used to search web request components for a match against a single regular expression. See Regex Match Statement below for details.
        :param pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementArgs'] regex_pattern_set_reference_statement: A rule statement used to search web request components for matches with regular expressions. See Regex Pattern Set Reference Statement below for details.
        :param pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementArgs'] size_constraint_statement: A rule statement that compares a number of bytes against the size of a request component, using a comparison operator, such as greater than (>) or less than (<). See Size Constraint Statement below for more details.
        :param pulumi.Input['RuleGroupRuleStatementSqliMatchStatementArgs'] sqli_match_statement: An SQL injection match condition identifies the part of web requests, such as the URI or the query string, that you want AWS WAF to inspect. See SQL Injection Match Statement below for details.
        :param pulumi.Input['RuleGroupRuleStatementXssMatchStatementArgs'] xss_match_statement: A rule statement that defines a cross-site scripting (XSS) match search for AWS WAF to apply to web requests. See XSS Match Statement below for details.
        """
        if and_statement is not None:
            pulumi.set(__self__, "and_statement", and_statement)
        if byte_match_statement is not None:
            pulumi.set(__self__, "byte_match_statement", byte_match_statement)
        if geo_match_statement is not None:
            pulumi.set(__self__, "geo_match_statement", geo_match_statement)
        if ip_set_reference_statement is not None:
            pulumi.set(__self__, "ip_set_reference_statement", ip_set_reference_statement)
        if label_match_statement is not None:
            pulumi.set(__self__, "label_match_statement", label_match_statement)
        if not_statement is not None:
            pulumi.set(__self__, "not_statement", not_statement)
        if or_statement is not None:
            pulumi.set(__self__, "or_statement", or_statement)
        if rate_based_statement is not None:
            pulumi.set(__self__, "rate_based_statement", rate_based_statement)
        if regex_match_statement is not None:
            pulumi.set(__self__, "regex_match_statement", regex_match_statement)
        if regex_pattern_set_reference_statement is not None:
            pulumi.set(__self__, "regex_pattern_set_reference_statement", regex_pattern_set_reference_statement)
        if size_constraint_statement is not None:
            pulumi.set(__self__, "size_constraint_statement", size_constraint_statement)
        if sqli_match_statement is not None:
            pulumi.set(__self__, "sqli_match_statement", sqli_match_statement)
        if xss_match_statement is not None:
            pulumi.set(__self__, "xss_match_statement", xss_match_statement)

    @property
    @pulumi.getter(name="andStatement")
    def and_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementAndStatementArgs']]:
        """
        A logical rule statement used to combine other rule statements with AND logic. See AND Statement below for details.
        """
        return pulumi.get(self, "and_statement")

    @and_statement.setter
    def and_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementAndStatementArgs']]):
        pulumi.set(self, "and_statement", value)

    @property
    @pulumi.getter(name="byteMatchStatement")
    def byte_match_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementArgs']]:
        """
        A rule statement that defines a string match search for AWS WAF to apply to web requests. See Byte Match Statement below for details.
        """
        return pulumi.get(self, "byte_match_statement")

    @byte_match_statement.setter
    def byte_match_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementArgs']]):
        pulumi.set(self, "byte_match_statement", value)

    @property
    @pulumi.getter(name="geoMatchStatement")
    def geo_match_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementGeoMatchStatementArgs']]:
        """
        A rule statement used to identify web requests based on country of origin. See GEO Match Statement below for details.
        """
        return pulumi.get(self, "geo_match_statement")

    @geo_match_statement.setter
    def geo_match_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementGeoMatchStatementArgs']]):
        pulumi.set(self, "geo_match_statement", value)

    @property
    @pulumi.getter(name="ipSetReferenceStatement")
    def ip_set_reference_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementIpSetReferenceStatementArgs']]:
        """
        A rule statement used to detect web requests coming from particular IP addresses or address ranges. See IP Set Reference Statement below for details.
        """
        return pulumi.get(self, "ip_set_reference_statement")

    @ip_set_reference_statement.setter
    def ip_set_reference_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementIpSetReferenceStatementArgs']]):
        pulumi.set(self, "ip_set_reference_statement", value)

    @property
    @pulumi.getter(name="labelMatchStatement")
    def label_match_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementLabelMatchStatementArgs']]:
        """
        A rule statement that defines a string match search against labels that have been added to the web request by rules that have already run in the web ACL. See Label Match Statement below for details.
        """
        return pulumi.get(self, "label_match_statement")

    @label_match_statement.setter
    def label_match_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementLabelMatchStatementArgs']]):
        pulumi.set(self, "label_match_statement", value)

    @property
    @pulumi.getter(name="notStatement")
    def not_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementNotStatementArgs']]:
        """
        A logical rule statement used to negate the results of another rule statement. See NOT Statement below for details.
        """
        return pulumi.get(self, "not_statement")

    @not_statement.setter
    def not_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementNotStatementArgs']]):
        pulumi.set(self, "not_statement", value)

    @property
    @pulumi.getter(name="orStatement")
    def or_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementOrStatementArgs']]:
        """
        A logical rule statement used to combine other rule statements with OR logic. See OR Statement below for details.
        """
        return pulumi.get(self, "or_statement")

    @or_statement.setter
    def or_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementOrStatementArgs']]):
        pulumi.set(self, "or_statement", value)

    @property
    @pulumi.getter(name="rateBasedStatement")
    def rate_based_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementArgs']]:
        """
        A rate-based rule tracks the rate of requests for each originating `IP address`, and triggers the rule action when the rate exceeds a limit that you specify on the number of requests in any `5-minute` time span. This statement can not be nested. See Rate Based Statement below for details.
        """
        return pulumi.get(self, "rate_based_statement")

    @rate_based_statement.setter
    def rate_based_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementArgs']]):
        pulumi.set(self, "rate_based_statement", value)

    @property
    @pulumi.getter(name="regexMatchStatement")
    def regex_match_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementArgs']]:
        """
        A rule statement used to search web request components for a match against a single regular expression. See Regex Match Statement below for details.
        """
        return pulumi.get(self, "regex_match_statement")

    @regex_match_statement.setter
    def regex_match_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementArgs']]):
        pulumi.set(self, "regex_match_statement", value)

    @property
    @pulumi.getter(name="regexPatternSetReferenceStatement")
    def regex_pattern_set_reference_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementArgs']]:
        """
        A rule statement used to search web request components for matches with regular expressions. See Regex Pattern Set Reference Statement below for details.
        """
        return pulumi.get(self, "regex_pattern_set_reference_statement")

    @regex_pattern_set_reference_statement.setter
    def regex_pattern_set_reference_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementArgs']]):
        pulumi.set(self, "regex_pattern_set_reference_statement", value)

    @property
    @pulumi.getter(name="sizeConstraintStatement")
    def size_constraint_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementArgs']]:
        """
        A rule statement that compares a number of bytes against the size of a request component, using a comparison operator, such as greater than (>) or less than (<). See Size Constraint Statement below for more details.
        """
        return pulumi.get(self, "size_constraint_statement")

    @size_constraint_statement.setter
    def size_constraint_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementArgs']]):
        pulumi.set(self, "size_constraint_statement", value)

    @property
    @pulumi.getter(name="sqliMatchStatement")
    def sqli_match_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementArgs']]:
        """
        An SQL injection match condition identifies the part of web requests, such as the URI or the query string, that you want AWS WAF to inspect. See SQL Injection Match Statement below for details.
        """
        return pulumi.get(self, "sqli_match_statement")

    @sqli_match_statement.setter
    def sqli_match_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementArgs']]):
        pulumi.set(self, "sqli_match_statement", value)

    @property
    @pulumi.getter(name="xssMatchStatement")
    def xss_match_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementArgs']]:
        """
        A rule statement that defines a cross-site scripting (XSS) match search for AWS WAF to apply to web requests. See XSS Match Statement below for details.
        """
        return pulumi.get(self, "xss_match_statement")

    @xss_match_statement.setter
    def xss_match_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementArgs']]):
        pulumi.set(self, "xss_match_statement", value)


@pulumi.input_type
class RuleGroupRuleStatementAndStatementArgs:
    def __init__(__self__, *,
                 statements: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]] statements: The statements to combine.
        """
        pulumi.set(__self__, "statements", statements)

    @property
    @pulumi.getter
    def statements(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]]:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")

    @statements.setter
    def statements(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]]):
        pulumi.set(self, "statements", value)


@pulumi.input_type
class RuleGroupRuleStatementByteMatchStatementArgs:
    def __init__(__self__, *,
                 positional_constraint: pulumi.Input[str],
                 search_string: pulumi.Input[str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementByteMatchStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchArgs']] = None):
        """
        :param pulumi.Input[str] positional_constraint: The area within the portion of a web request that you want AWS WAF to search for `search_string`. Valid values include the following: `EXACTLY`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CONTAINS_WORD`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_ByteMatchStatement.html) for more information.
        :param pulumi.Input[str] search_string: A string value that you want AWS WAF to search for. AWS WAF searches only in the part of web requests that you designate for inspection in `field_to_match`. The maximum length of the value is 50 bytes.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementByteMatchStatementTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
               At least one required.
               See Text Transformation below for details.
        :param pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchArgs'] field_to_match: The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        pulumi.set(__self__, "positional_constraint", positional_constraint)
        pulumi.set(__self__, "search_string", search_string)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @property
    @pulumi.getter(name="positionalConstraint")
    def positional_constraint(self) -> pulumi.Input[str]:
        """
        The area within the portion of a web request that you want AWS WAF to search for `search_string`. Valid values include the following: `EXACTLY`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CONTAINS_WORD`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_ByteMatchStatement.html) for more information.
        """
        return pulumi.get(self, "positional_constraint")

    @positional_constraint.setter
    def positional_constraint(self, value: pulumi.Input[str]):
        pulumi.set(self, "positional_constraint", value)

    @property
    @pulumi.getter(name="searchString")
    def search_string(self) -> pulumi.Input[str]:
        """
        A string value that you want AWS WAF to search for. AWS WAF searches only in the part of web requests that you designate for inspection in `field_to_match`. The maximum length of the value is 50 bytes.
        """
        return pulumi.get(self, "search_string")

    @search_string.setter
    def search_string(self, value: pulumi.Input[str]):
        pulumi.set(self, "search_string", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementByteMatchStatementTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
        At least one required.
        See Text Transformation below for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementByteMatchStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchArgs']]:
        """
        The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


@pulumi.input_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchJa3FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_path: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchUriPathArgs']] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs'] all_query_arguments: Inspect all query arguments.
        :param pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchBodyArgs'] body: Inspect the request body, which immediately follows the request headers.
        :param pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesArgs'] cookies: Inspect the cookies in the web request. See Cookies below for details.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderOrderArgs']]] header_orders: Inspect the request headers. See Header Order below for details.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderArgs']]] headers: Inspect the request headers. See Headers below for details.
        :param pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyArgs'] json_body: Inspect the request body as JSON. See JSON Body for details.
        :param pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchMethodArgs'] method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchQueryStringArgs'] query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleHeaderArgs'] single_header: Inspect a single header. See Single Header below for details.
        :param pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs'] single_query_argument: Inspect a single query argument. See Single Query Argument below for details.
        :param pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchUriPathArgs'] uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs']]:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchBodyArgs']]:
        """
        Inspect the request body, which immediately follows the request headers.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesArgs']]:
        """
        Inspect the cookies in the web request. See Cookies below for details.
        """
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderOrderArgs']]]]:
        """
        Inspect the request headers. See Header Order below for details.
        """
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderArgs']]]]:
        """
        Inspect the request headers. See Headers below for details.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchJa3FingerprintArgs']]:
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyArgs']]:
        """
        Inspect the request body as JSON. See JSON Body for details.
        """
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchMethodArgs']]:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchQueryStringArgs']]:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleHeaderArgs']]:
        """
        Inspect a single header. See Single Header below for details.
        """
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs']]:
        """
        Inspect a single query argument. See Single Query Argument below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchUriPathArgs']]:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


@pulumi.input_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs']]] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param pulumi.Input[str] match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs']]]:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_cookies", value)


@pulumi.input_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs'] match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param pulumi.Input[str] match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs']:
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_headers", value)


@pulumi.input_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: The match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        The match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)


@pulumi.input_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 invalid_fallback_behavior: Optional[pulumi.Input[str]] = None,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs'] match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param pulumi.Input[str] match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param pulumi.Input[str] invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param pulumi.Input[str] oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs']:
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_paths", value)


@pulumi.input_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementByteMatchStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class RuleGroupRuleStatementGeoMatchStatementArgs:
    def __init__(__self__, *,
                 country_codes: pulumi.Input[Sequence[pulumi.Input[str]]],
                 forwarded_ip_config: Optional[pulumi.Input['RuleGroupRuleStatementGeoMatchStatementForwardedIpConfigArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] country_codes: An array of two-character country codes, for example, [ "US", "CN" ], from the alpha-2 country ISO codes of the `ISO 3166` international standard. See the [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_GeoMatchStatement.html) for valid values.
        :param pulumi.Input['RuleGroupRuleStatementGeoMatchStatementForwardedIpConfigArgs'] forwarded_ip_config: The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See Forwarded IP Config below for details.
        """
        pulumi.set(__self__, "country_codes", country_codes)
        if forwarded_ip_config is not None:
            pulumi.set(__self__, "forwarded_ip_config", forwarded_ip_config)

    @property
    @pulumi.getter(name="countryCodes")
    def country_codes(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        An array of two-character country codes, for example, [ "US", "CN" ], from the alpha-2 country ISO codes of the `ISO 3166` international standard. See the [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_GeoMatchStatement.html) for valid values.
        """
        return pulumi.get(self, "country_codes")

    @country_codes.setter
    def country_codes(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "country_codes", value)

    @property
    @pulumi.getter(name="forwardedIpConfig")
    def forwarded_ip_config(self) -> Optional[pulumi.Input['RuleGroupRuleStatementGeoMatchStatementForwardedIpConfigArgs']]:
        """
        The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See Forwarded IP Config below for details.
        """
        return pulumi.get(self, "forwarded_ip_config")

    @forwarded_ip_config.setter
    def forwarded_ip_config(self, value: Optional[pulumi.Input['RuleGroupRuleStatementGeoMatchStatementForwardedIpConfigArgs']]):
        pulumi.set(self, "forwarded_ip_config", value)


@pulumi.input_type
class RuleGroupRuleStatementGeoMatchStatementForwardedIpConfigArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str],
                 header_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: The match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        :param pulumi.Input[str] header_name: The name of the HTTP header to use for the IP address.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        The match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> pulumi.Input[str]:
        """
        The name of the HTTP header to use for the IP address.
        """
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "header_name", value)


@pulumi.input_type
class RuleGroupRuleStatementIpSetReferenceStatementArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[str],
                 ip_set_forwarded_ip_config: Optional[pulumi.Input['RuleGroupRuleStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs']] = None):
        """
        :param pulumi.Input[str] arn: The Amazon Resource Name (ARN) of the IP Set that this statement references.
        :param pulumi.Input['RuleGroupRuleStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs'] ip_set_forwarded_ip_config: The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See IPSet Forwarded IP Config below for more details.
        """
        pulumi.set(__self__, "arn", arn)
        if ip_set_forwarded_ip_config is not None:
            pulumi.set(__self__, "ip_set_forwarded_ip_config", ip_set_forwarded_ip_config)

    @property
    @pulumi.getter
    def arn(self) -> pulumi.Input[str]:
        """
        The Amazon Resource Name (ARN) of the IP Set that this statement references.
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "arn", value)

    @property
    @pulumi.getter(name="ipSetForwardedIpConfig")
    def ip_set_forwarded_ip_config(self) -> Optional[pulumi.Input['RuleGroupRuleStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs']]:
        """
        The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See IPSet Forwarded IP Config below for more details.
        """
        return pulumi.get(self, "ip_set_forwarded_ip_config")

    @ip_set_forwarded_ip_config.setter
    def ip_set_forwarded_ip_config(self, value: Optional[pulumi.Input['RuleGroupRuleStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs']]):
        pulumi.set(self, "ip_set_forwarded_ip_config", value)


@pulumi.input_type
class RuleGroupRuleStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str],
                 header_name: pulumi.Input[str],
                 position: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: The match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        :param pulumi.Input[str] header_name: The name of the HTTP header to use for the IP address.
        :param pulumi.Input[str] position: The position in the header to search for the IP address. Valid values include: `FIRST`, `LAST`, or `ANY`. If `ANY` is specified and the header contains more than 10 IP addresses, AWS WAFv2 inspects the last 10.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "position", position)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        The match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> pulumi.Input[str]:
        """
        The name of the HTTP header to use for the IP address.
        """
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "header_name", value)

    @property
    @pulumi.getter
    def position(self) -> pulumi.Input[str]:
        """
        The position in the header to search for the IP address. Valid values include: `FIRST`, `LAST`, or `ANY`. If `ANY` is specified and the header contains more than 10 IP addresses, AWS WAFv2 inspects the last 10.
        """
        return pulumi.get(self, "position")

    @position.setter
    def position(self, value: pulumi.Input[str]):
        pulumi.set(self, "position", value)


@pulumi.input_type
class RuleGroupRuleStatementLabelMatchStatementArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 scope: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: The string to match against.
        :param pulumi.Input[str] scope: Specify whether you want to match using the label name or just the namespace. Valid values are `LABEL` or `NAMESPACE`.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The string to match against.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def scope(self) -> pulumi.Input[str]:
        """
        Specify whether you want to match using the label name or just the namespace. Valid values are `LABEL` or `NAMESPACE`.
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "scope", value)


@pulumi.input_type
class RuleGroupRuleStatementNotStatementArgs:
    def __init__(__self__, *,
                 statements: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]] statements: The statements to combine.
        """
        pulumi.set(__self__, "statements", statements)

    @property
    @pulumi.getter
    def statements(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]]:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")

    @statements.setter
    def statements(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]]):
        pulumi.set(self, "statements", value)


@pulumi.input_type
class RuleGroupRuleStatementOrStatementArgs:
    def __init__(__self__, *,
                 statements: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]] statements: The statements to combine.
        """
        pulumi.set(__self__, "statements", statements)

    @property
    @pulumi.getter
    def statements(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]]:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")

    @statements.setter
    def statements(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]]):
        pulumi.set(self, "statements", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementArgs:
    def __init__(__self__, *,
                 limit: pulumi.Input[int],
                 aggregate_key_type: Optional[pulumi.Input[str]] = None,
                 custom_keys: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyArgs']]]] = None,
                 forwarded_ip_config: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementForwardedIpConfigArgs']] = None,
                 scope_down_statement: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementArgs']] = None):
        """
        :param pulumi.Input[int] limit: The limit on requests per 5-minute period for a single originating IP address.
        :param pulumi.Input[str] aggregate_key_type: Setting that indicates how to aggregate the request counts. Valid values include: `CONSTANT`, `CUSTOM_KEYS`, `FORWARDED_IP` or `IP`. Default: `IP`.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyArgs']]] custom_keys: Aggregate the request counts using one or more web request components as the aggregate keys. See `custom_key` below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementForwardedIpConfigArgs'] forwarded_ip_config: The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. If `aggregate_key_type` is set to `FORWARDED_IP`, this block is required. See Forwarded IP Config below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementArgs'] scope_down_statement: An optional nested statement that narrows the scope of the rate-based statement to matching web requests. This can be any nestable statement, and you can nest statements at any level below this scope-down statement. See Statement above for details. If `aggregate_key_type` is set to `CONSTANT`, this block is required.
        """
        pulumi.set(__self__, "limit", limit)
        if aggregate_key_type is not None:
            pulumi.set(__self__, "aggregate_key_type", aggregate_key_type)
        if custom_keys is not None:
            pulumi.set(__self__, "custom_keys", custom_keys)
        if forwarded_ip_config is not None:
            pulumi.set(__self__, "forwarded_ip_config", forwarded_ip_config)
        if scope_down_statement is not None:
            pulumi.set(__self__, "scope_down_statement", scope_down_statement)

    @property
    @pulumi.getter
    def limit(self) -> pulumi.Input[int]:
        """
        The limit on requests per 5-minute period for a single originating IP address.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: pulumi.Input[int]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="aggregateKeyType")
    def aggregate_key_type(self) -> Optional[pulumi.Input[str]]:
        """
        Setting that indicates how to aggregate the request counts. Valid values include: `CONSTANT`, `CUSTOM_KEYS`, `FORWARDED_IP` or `IP`. Default: `IP`.
        """
        return pulumi.get(self, "aggregate_key_type")

    @aggregate_key_type.setter
    def aggregate_key_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregate_key_type", value)

    @property
    @pulumi.getter(name="customKeys")
    def custom_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyArgs']]]]:
        """
        Aggregate the request counts using one or more web request components as the aggregate keys. See `custom_key` below for details.
        """
        return pulumi.get(self, "custom_keys")

    @custom_keys.setter
    def custom_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyArgs']]]]):
        pulumi.set(self, "custom_keys", value)

    @property
    @pulumi.getter(name="forwardedIpConfig")
    def forwarded_ip_config(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementForwardedIpConfigArgs']]:
        """
        The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. If `aggregate_key_type` is set to `FORWARDED_IP`, this block is required. See Forwarded IP Config below for details.
        """
        return pulumi.get(self, "forwarded_ip_config")

    @forwarded_ip_config.setter
    def forwarded_ip_config(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementForwardedIpConfigArgs']]):
        pulumi.set(self, "forwarded_ip_config", value)

    @property
    @pulumi.getter(name="scopeDownStatement")
    def scope_down_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementArgs']]:
        """
        An optional nested statement that narrows the scope of the rate-based statement to matching web requests. This can be any nestable statement, and you can nest statements at any level below this scope-down statement. See Statement above for details. If `aggregate_key_type` is set to `CONSTANT`, this block is required.
        """
        return pulumi.get(self, "scope_down_statement")

    @scope_down_statement.setter
    def scope_down_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementArgs']]):
        pulumi.set(self, "scope_down_statement", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyArgs:
    def __init__(__self__, *,
                 cookie: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyCookieArgs']] = None,
                 forwarded_ip: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyForwardedIpArgs']] = None,
                 header: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyHeaderArgs']] = None,
                 http_method: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyHttpMethodArgs']] = None,
                 ip: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyIpArgs']] = None,
                 label_namespace: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyLabelNamespaceArgs']] = None,
                 query_argument: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgumentArgs']] = None,
                 query_string: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyQueryStringArgs']] = None,
                 uri_path: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyUriPathArgs']] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyCookieArgs'] cookie: (Optional) Use the value of a cookie in the request as an aggregate key. See RateLimit `cookie` below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyForwardedIpArgs'] forwarded_ip: (Optional) Use the first IP address in an HTTP header as an aggregate key. See `forwarded_ip` below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyHeaderArgs'] header: (Optional) Use the value of a header in the request as an aggregate key. See RateLimit `header` below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyHttpMethodArgs'] http_method: (Optional) Use the request's HTTP method as an aggregate key. See RateLimit `http_method` below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyIpArgs'] ip: (Optional) Use the request's originating IP address as an aggregate key. See `RateLimit ip` below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyLabelNamespaceArgs'] label_namespace: (Optional) Use the specified label namespace as an aggregate key. See RateLimit `label_namespace` below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgumentArgs'] query_argument: (Optional) Use the specified query argument as an aggregate key. See RateLimit `query_argument` below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyQueryStringArgs'] query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyUriPathArgs'] uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        if cookie is not None:
            pulumi.set(__self__, "cookie", cookie)
        if forwarded_ip is not None:
            pulumi.set(__self__, "forwarded_ip", forwarded_ip)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if http_method is not None:
            pulumi.set(__self__, "http_method", http_method)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if label_namespace is not None:
            pulumi.set(__self__, "label_namespace", label_namespace)
        if query_argument is not None:
            pulumi.set(__self__, "query_argument", query_argument)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter
    def cookie(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyCookieArgs']]:
        """
        (Optional) Use the value of a cookie in the request as an aggregate key. See RateLimit `cookie` below for details.
        """
        return pulumi.get(self, "cookie")

    @cookie.setter
    def cookie(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyCookieArgs']]):
        pulumi.set(self, "cookie", value)

    @property
    @pulumi.getter(name="forwardedIp")
    def forwarded_ip(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyForwardedIpArgs']]:
        """
        (Optional) Use the first IP address in an HTTP header as an aggregate key. See `forwarded_ip` below for details.
        """
        return pulumi.get(self, "forwarded_ip")

    @forwarded_ip.setter
    def forwarded_ip(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyForwardedIpArgs']]):
        pulumi.set(self, "forwarded_ip", value)

    @property
    @pulumi.getter
    def header(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyHeaderArgs']]:
        """
        (Optional) Use the value of a header in the request as an aggregate key. See RateLimit `header` below for details.
        """
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyHeaderArgs']]):
        pulumi.set(self, "header", value)

    @property
    @pulumi.getter(name="httpMethod")
    def http_method(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyHttpMethodArgs']]:
        """
        (Optional) Use the request's HTTP method as an aggregate key. See RateLimit `http_method` below for details.
        """
        return pulumi.get(self, "http_method")

    @http_method.setter
    def http_method(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyHttpMethodArgs']]):
        pulumi.set(self, "http_method", value)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyIpArgs']]:
        """
        (Optional) Use the request's originating IP address as an aggregate key. See `RateLimit ip` below for details.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyIpArgs']]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter(name="labelNamespace")
    def label_namespace(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyLabelNamespaceArgs']]:
        """
        (Optional) Use the specified label namespace as an aggregate key. See RateLimit `label_namespace` below for details.
        """
        return pulumi.get(self, "label_namespace")

    @label_namespace.setter
    def label_namespace(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyLabelNamespaceArgs']]):
        pulumi.set(self, "label_namespace", value)

    @property
    @pulumi.getter(name="queryArgument")
    def query_argument(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgumentArgs']]:
        """
        (Optional) Use the specified query argument as an aggregate key. See RateLimit `query_argument` below for details.
        """
        return pulumi.get(self, "query_argument")

    @query_argument.setter
    def query_argument(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgumentArgs']]):
        pulumi.set(self, "query_argument", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyQueryStringArgs']]:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyUriPathArgs']]:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyCookieArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyCookieTextTransformationArgs']]]):
        """
        :param pulumi.Input[str] name: A friendly name of the rule group.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyCookieTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
               At least one required.
               See Text Transformation below for details.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        A friendly name of the rule group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyCookieTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
        At least one required.
        See Text Transformation below for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyCookieTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyCookieTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyForwardedIpArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyHeaderTextTransformationArgs']]]):
        """
        :param pulumi.Input[str] name: A friendly name of the rule group.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyHeaderTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
               At least one required.
               See Text Transformation below for details.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        A friendly name of the rule group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyHeaderTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
        At least one required.
        See Text Transformation below for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyHeaderTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyHeaderTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyHttpMethodArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyIpArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyLabelNamespaceArgs:
    def __init__(__self__, *,
                 namespace: pulumi.Input[str]):
        """
        :param pulumi.Input[str] namespace: The namespace to use for aggregation
        """
        pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[str]:
        """
        The namespace to use for aggregation
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[str]):
        pulumi.set(self, "namespace", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformationArgs']]]):
        """
        :param pulumi.Input[str] name: A friendly name of the rule group.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
               At least one required.
               See Text Transformation below for details.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        A friendly name of the rule group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
        At least one required.
        See Text Transformation below for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyQueryStringArgs:
    def __init__(__self__, *,
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformationArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
               At least one required.
               See Text Transformation below for details.
        """
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
        At least one required.
        See Text Transformation below for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyUriPathArgs:
    def __init__(__self__, *,
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyUriPathTextTransformationArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyUriPathTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
               At least one required.
               See Text Transformation below for details.
        """
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyUriPathTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
        At least one required.
        See Text Transformation below for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyUriPathTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyUriPathTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementForwardedIpConfigArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str],
                 header_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: The match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        :param pulumi.Input[str] header_name: The name of the HTTP header to use for the IP address.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        The match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> pulumi.Input[str]:
        """
        The name of the HTTP header to use for the IP address.
        """
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "header_name", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementArgs:
    def __init__(__self__, *,
                 and_statement: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementAndStatementArgs']] = None,
                 byte_match_statement: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementArgs']] = None,
                 geo_match_statement: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementArgs']] = None,
                 ip_set_reference_statement: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementArgs']] = None,
                 label_match_statement: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatementArgs']] = None,
                 not_statement: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementNotStatementArgs']] = None,
                 or_statement: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementOrStatementArgs']] = None,
                 regex_match_statement: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementArgs']] = None,
                 regex_pattern_set_reference_statement: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementArgs']] = None,
                 size_constraint_statement: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementArgs']] = None,
                 sqli_match_statement: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementArgs']] = None,
                 xss_match_statement: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementArgs']] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementAndStatementArgs'] and_statement: A logical rule statement used to combine other rule statements with AND logic. See AND Statement below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementArgs'] byte_match_statement: A rule statement that defines a string match search for AWS WAF to apply to web requests. See Byte Match Statement below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementArgs'] geo_match_statement: A rule statement used to identify web requests based on country of origin. See GEO Match Statement below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementArgs'] ip_set_reference_statement: A rule statement used to detect web requests coming from particular IP addresses or address ranges. See IP Set Reference Statement below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatementArgs'] label_match_statement: A rule statement that defines a string match search against labels that have been added to the web request by rules that have already run in the web ACL. See Label Match Statement below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementNotStatementArgs'] not_statement: A logical rule statement used to negate the results of another rule statement. See NOT Statement below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementOrStatementArgs'] or_statement: A logical rule statement used to combine other rule statements with OR logic. See OR Statement below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementArgs'] regex_match_statement: A rule statement used to search web request components for a match against a single regular expression. See Regex Match Statement below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementArgs'] regex_pattern_set_reference_statement: A rule statement used to search web request components for matches with regular expressions. See Regex Pattern Set Reference Statement below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementArgs'] size_constraint_statement: A rule statement that compares a number of bytes against the size of a request component, using a comparison operator, such as greater than (>) or less than (<). See Size Constraint Statement below for more details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementArgs'] sqli_match_statement: An SQL injection match condition identifies the part of web requests, such as the URI or the query string, that you want AWS WAF to inspect. See SQL Injection Match Statement below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementArgs'] xss_match_statement: A rule statement that defines a cross-site scripting (XSS) match search for AWS WAF to apply to web requests. See XSS Match Statement below for details.
        """
        if and_statement is not None:
            pulumi.set(__self__, "and_statement", and_statement)
        if byte_match_statement is not None:
            pulumi.set(__self__, "byte_match_statement", byte_match_statement)
        if geo_match_statement is not None:
            pulumi.set(__self__, "geo_match_statement", geo_match_statement)
        if ip_set_reference_statement is not None:
            pulumi.set(__self__, "ip_set_reference_statement", ip_set_reference_statement)
        if label_match_statement is not None:
            pulumi.set(__self__, "label_match_statement", label_match_statement)
        if not_statement is not None:
            pulumi.set(__self__, "not_statement", not_statement)
        if or_statement is not None:
            pulumi.set(__self__, "or_statement", or_statement)
        if regex_match_statement is not None:
            pulumi.set(__self__, "regex_match_statement", regex_match_statement)
        if regex_pattern_set_reference_statement is not None:
            pulumi.set(__self__, "regex_pattern_set_reference_statement", regex_pattern_set_reference_statement)
        if size_constraint_statement is not None:
            pulumi.set(__self__, "size_constraint_statement", size_constraint_statement)
        if sqli_match_statement is not None:
            pulumi.set(__self__, "sqli_match_statement", sqli_match_statement)
        if xss_match_statement is not None:
            pulumi.set(__self__, "xss_match_statement", xss_match_statement)

    @property
    @pulumi.getter(name="andStatement")
    def and_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementAndStatementArgs']]:
        """
        A logical rule statement used to combine other rule statements with AND logic. See AND Statement below for details.
        """
        return pulumi.get(self, "and_statement")

    @and_statement.setter
    def and_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementAndStatementArgs']]):
        pulumi.set(self, "and_statement", value)

    @property
    @pulumi.getter(name="byteMatchStatement")
    def byte_match_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementArgs']]:
        """
        A rule statement that defines a string match search for AWS WAF to apply to web requests. See Byte Match Statement below for details.
        """
        return pulumi.get(self, "byte_match_statement")

    @byte_match_statement.setter
    def byte_match_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementArgs']]):
        pulumi.set(self, "byte_match_statement", value)

    @property
    @pulumi.getter(name="geoMatchStatement")
    def geo_match_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementArgs']]:
        """
        A rule statement used to identify web requests based on country of origin. See GEO Match Statement below for details.
        """
        return pulumi.get(self, "geo_match_statement")

    @geo_match_statement.setter
    def geo_match_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementArgs']]):
        pulumi.set(self, "geo_match_statement", value)

    @property
    @pulumi.getter(name="ipSetReferenceStatement")
    def ip_set_reference_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementArgs']]:
        """
        A rule statement used to detect web requests coming from particular IP addresses or address ranges. See IP Set Reference Statement below for details.
        """
        return pulumi.get(self, "ip_set_reference_statement")

    @ip_set_reference_statement.setter
    def ip_set_reference_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementArgs']]):
        pulumi.set(self, "ip_set_reference_statement", value)

    @property
    @pulumi.getter(name="labelMatchStatement")
    def label_match_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatementArgs']]:
        """
        A rule statement that defines a string match search against labels that have been added to the web request by rules that have already run in the web ACL. See Label Match Statement below for details.
        """
        return pulumi.get(self, "label_match_statement")

    @label_match_statement.setter
    def label_match_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatementArgs']]):
        pulumi.set(self, "label_match_statement", value)

    @property
    @pulumi.getter(name="notStatement")
    def not_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementNotStatementArgs']]:
        """
        A logical rule statement used to negate the results of another rule statement. See NOT Statement below for details.
        """
        return pulumi.get(self, "not_statement")

    @not_statement.setter
    def not_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementNotStatementArgs']]):
        pulumi.set(self, "not_statement", value)

    @property
    @pulumi.getter(name="orStatement")
    def or_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementOrStatementArgs']]:
        """
        A logical rule statement used to combine other rule statements with OR logic. See OR Statement below for details.
        """
        return pulumi.get(self, "or_statement")

    @or_statement.setter
    def or_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementOrStatementArgs']]):
        pulumi.set(self, "or_statement", value)

    @property
    @pulumi.getter(name="regexMatchStatement")
    def regex_match_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementArgs']]:
        """
        A rule statement used to search web request components for a match against a single regular expression. See Regex Match Statement below for details.
        """
        return pulumi.get(self, "regex_match_statement")

    @regex_match_statement.setter
    def regex_match_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementArgs']]):
        pulumi.set(self, "regex_match_statement", value)

    @property
    @pulumi.getter(name="regexPatternSetReferenceStatement")
    def regex_pattern_set_reference_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementArgs']]:
        """
        A rule statement used to search web request components for matches with regular expressions. See Regex Pattern Set Reference Statement below for details.
        """
        return pulumi.get(self, "regex_pattern_set_reference_statement")

    @regex_pattern_set_reference_statement.setter
    def regex_pattern_set_reference_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementArgs']]):
        pulumi.set(self, "regex_pattern_set_reference_statement", value)

    @property
    @pulumi.getter(name="sizeConstraintStatement")
    def size_constraint_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementArgs']]:
        """
        A rule statement that compares a number of bytes against the size of a request component, using a comparison operator, such as greater than (>) or less than (<). See Size Constraint Statement below for more details.
        """
        return pulumi.get(self, "size_constraint_statement")

    @size_constraint_statement.setter
    def size_constraint_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementArgs']]):
        pulumi.set(self, "size_constraint_statement", value)

    @property
    @pulumi.getter(name="sqliMatchStatement")
    def sqli_match_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementArgs']]:
        """
        An SQL injection match condition identifies the part of web requests, such as the URI or the query string, that you want AWS WAF to inspect. See SQL Injection Match Statement below for details.
        """
        return pulumi.get(self, "sqli_match_statement")

    @sqli_match_statement.setter
    def sqli_match_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementArgs']]):
        pulumi.set(self, "sqli_match_statement", value)

    @property
    @pulumi.getter(name="xssMatchStatement")
    def xss_match_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementArgs']]:
        """
        A rule statement that defines a cross-site scripting (XSS) match search for AWS WAF to apply to web requests. See XSS Match Statement below for details.
        """
        return pulumi.get(self, "xss_match_statement")

    @xss_match_statement.setter
    def xss_match_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementArgs']]):
        pulumi.set(self, "xss_match_statement", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementAndStatementArgs:
    def __init__(__self__, *,
                 statements: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]] statements: The statements to combine.
        """
        pulumi.set(__self__, "statements", statements)

    @property
    @pulumi.getter
    def statements(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]]:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")

    @statements.setter
    def statements(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]]):
        pulumi.set(self, "statements", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementArgs:
    def __init__(__self__, *,
                 positional_constraint: pulumi.Input[str],
                 search_string: pulumi.Input[str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchArgs']] = None):
        """
        :param pulumi.Input[str] positional_constraint: The area within the portion of a web request that you want AWS WAF to search for `search_string`. Valid values include the following: `EXACTLY`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CONTAINS_WORD`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_ByteMatchStatement.html) for more information.
        :param pulumi.Input[str] search_string: A string value that you want AWS WAF to search for. AWS WAF searches only in the part of web requests that you designate for inspection in `field_to_match`. The maximum length of the value is 50 bytes.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
               At least one required.
               See Text Transformation below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchArgs'] field_to_match: The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        pulumi.set(__self__, "positional_constraint", positional_constraint)
        pulumi.set(__self__, "search_string", search_string)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @property
    @pulumi.getter(name="positionalConstraint")
    def positional_constraint(self) -> pulumi.Input[str]:
        """
        The area within the portion of a web request that you want AWS WAF to search for `search_string`. Valid values include the following: `EXACTLY`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CONTAINS_WORD`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_ByteMatchStatement.html) for more information.
        """
        return pulumi.get(self, "positional_constraint")

    @positional_constraint.setter
    def positional_constraint(self, value: pulumi.Input[str]):
        pulumi.set(self, "positional_constraint", value)

    @property
    @pulumi.getter(name="searchString")
    def search_string(self) -> pulumi.Input[str]:
        """
        A string value that you want AWS WAF to search for. AWS WAF searches only in the part of web requests that you designate for inspection in `field_to_match`. The maximum length of the value is 50 bytes.
        """
        return pulumi.get(self, "search_string")

    @search_string.setter
    def search_string(self, value: pulumi.Input[str]):
        pulumi.set(self, "search_string", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
        At least one required.
        See Text Transformation below for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchArgs']]:
        """
        The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_path: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgs']] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs'] all_query_arguments: Inspect all query arguments.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgs'] body: Inspect the request body, which immediately follows the request headers.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgs'] cookies: Inspect the cookies in the web request. See Cookies below for details.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgs']]] header_orders: Inspect the request headers. See Header Order below for details.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgs']]] headers: Inspect the request headers. See Headers below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgs'] json_body: Inspect the request body as JSON. See JSON Body for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgs'] method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgs'] query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgs'] single_header: Inspect a single header. See Single Header below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs'] single_query_argument: Inspect a single query argument. See Single Query Argument below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgs'] uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs']]:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgs']]:
        """
        Inspect the request body, which immediately follows the request headers.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgs']]:
        """
        Inspect the cookies in the web request. See Cookies below for details.
        """
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgs']]]]:
        """
        Inspect the request headers. See Header Order below for details.
        """
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgs']]]]:
        """
        Inspect the request headers. See Headers below for details.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgs']]:
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgs']]:
        """
        Inspect the request body as JSON. See JSON Body for details.
        """
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgs']]:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgs']]:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgs']]:
        """
        Inspect a single header. See Single Header below for details.
        """
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs']]:
        """
        Inspect a single query argument. See Single Query Argument below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgs']]:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs']]] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param pulumi.Input[str] match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs']]]:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_cookies", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs'] match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param pulumi.Input[str] match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs']:
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_headers", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: The match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        The match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 invalid_fallback_behavior: Optional[pulumi.Input[str]] = None,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs'] match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param pulumi.Input[str] match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param pulumi.Input[str] invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param pulumi.Input[str] oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs']:
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_paths", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementArgs:
    def __init__(__self__, *,
                 country_codes: pulumi.Input[Sequence[pulumi.Input[str]]],
                 forwarded_ip_config: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] country_codes: An array of two-character country codes, for example, [ "US", "CN" ], from the alpha-2 country ISO codes of the `ISO 3166` international standard. See the [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_GeoMatchStatement.html) for valid values.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgs'] forwarded_ip_config: The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See Forwarded IP Config below for details.
        """
        pulumi.set(__self__, "country_codes", country_codes)
        if forwarded_ip_config is not None:
            pulumi.set(__self__, "forwarded_ip_config", forwarded_ip_config)

    @property
    @pulumi.getter(name="countryCodes")
    def country_codes(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        An array of two-character country codes, for example, [ "US", "CN" ], from the alpha-2 country ISO codes of the `ISO 3166` international standard. See the [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_GeoMatchStatement.html) for valid values.
        """
        return pulumi.get(self, "country_codes")

    @country_codes.setter
    def country_codes(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "country_codes", value)

    @property
    @pulumi.getter(name="forwardedIpConfig")
    def forwarded_ip_config(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgs']]:
        """
        The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See Forwarded IP Config below for details.
        """
        return pulumi.get(self, "forwarded_ip_config")

    @forwarded_ip_config.setter
    def forwarded_ip_config(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgs']]):
        pulumi.set(self, "forwarded_ip_config", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str],
                 header_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: The match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        :param pulumi.Input[str] header_name: The name of the HTTP header to use for the IP address.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        The match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> pulumi.Input[str]:
        """
        The name of the HTTP header to use for the IP address.
        """
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "header_name", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[str],
                 ip_set_forwarded_ip_config: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs']] = None):
        """
        :param pulumi.Input[str] arn: The Amazon Resource Name (ARN) of the IP Set that this statement references.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs'] ip_set_forwarded_ip_config: The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See IPSet Forwarded IP Config below for more details.
        """
        pulumi.set(__self__, "arn", arn)
        if ip_set_forwarded_ip_config is not None:
            pulumi.set(__self__, "ip_set_forwarded_ip_config", ip_set_forwarded_ip_config)

    @property
    @pulumi.getter
    def arn(self) -> pulumi.Input[str]:
        """
        The Amazon Resource Name (ARN) of the IP Set that this statement references.
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "arn", value)

    @property
    @pulumi.getter(name="ipSetForwardedIpConfig")
    def ip_set_forwarded_ip_config(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs']]:
        """
        The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See IPSet Forwarded IP Config below for more details.
        """
        return pulumi.get(self, "ip_set_forwarded_ip_config")

    @ip_set_forwarded_ip_config.setter
    def ip_set_forwarded_ip_config(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs']]):
        pulumi.set(self, "ip_set_forwarded_ip_config", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str],
                 header_name: pulumi.Input[str],
                 position: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: The match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        :param pulumi.Input[str] header_name: The name of the HTTP header to use for the IP address.
        :param pulumi.Input[str] position: The position in the header to search for the IP address. Valid values include: `FIRST`, `LAST`, or `ANY`. If `ANY` is specified and the header contains more than 10 IP addresses, AWS WAFv2 inspects the last 10.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "position", position)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        The match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> pulumi.Input[str]:
        """
        The name of the HTTP header to use for the IP address.
        """
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "header_name", value)

    @property
    @pulumi.getter
    def position(self) -> pulumi.Input[str]:
        """
        The position in the header to search for the IP address. Valid values include: `FIRST`, `LAST`, or `ANY`. If `ANY` is specified and the header contains more than 10 IP addresses, AWS WAFv2 inspects the last 10.
        """
        return pulumi.get(self, "position")

    @position.setter
    def position(self, value: pulumi.Input[str]):
        pulumi.set(self, "position", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatementArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 scope: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: The string to match against.
        :param pulumi.Input[str] scope: Specify whether you want to match using the label name or just the namespace. Valid values are `LABEL` or `NAMESPACE`.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The string to match against.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def scope(self) -> pulumi.Input[str]:
        """
        Specify whether you want to match using the label name or just the namespace. Valid values are `LABEL` or `NAMESPACE`.
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "scope", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementNotStatementArgs:
    def __init__(__self__, *,
                 statements: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]] statements: The statements to combine.
        """
        pulumi.set(__self__, "statements", statements)

    @property
    @pulumi.getter
    def statements(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]]:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")

    @statements.setter
    def statements(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]]):
        pulumi.set(self, "statements", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementOrStatementArgs:
    def __init__(__self__, *,
                 statements: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]] statements: The statements to combine.
        """
        pulumi.set(__self__, "statements", statements)

    @property
    @pulumi.getter
    def statements(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]]:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")

    @statements.setter
    def statements(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]]):
        pulumi.set(self, "statements", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementArgs:
    def __init__(__self__, *,
                 regex_string: pulumi.Input[str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchArgs']] = None):
        """
        :param pulumi.Input[str] regex_string: The string representing the regular expression. **Note:** The fixed quota for the maximum number of characters in each regex pattern is 200, which can't be changed. See [AWS WAF quotas](https://docs.aws.amazon.com/waf/latest/developerguide/limits.html) for details.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
               At least one required.
               See Text Transformation below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchArgs'] field_to_match: The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        pulumi.set(__self__, "regex_string", regex_string)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @property
    @pulumi.getter(name="regexString")
    def regex_string(self) -> pulumi.Input[str]:
        """
        The string representing the regular expression. **Note:** The fixed quota for the maximum number of characters in each regex pattern is 200, which can't be changed. See [AWS WAF quotas](https://docs.aws.amazon.com/waf/latest/developerguide/limits.html) for details.
        """
        return pulumi.get(self, "regex_string")

    @regex_string.setter
    def regex_string(self, value: pulumi.Input[str]):
        pulumi.set(self, "regex_string", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
        At least one required.
        See Text Transformation below for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchArgs']]:
        """
        The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_path: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgs']] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs'] all_query_arguments: Inspect all query arguments.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgs'] body: Inspect the request body, which immediately follows the request headers.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgs'] cookies: Inspect the cookies in the web request. See Cookies below for details.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgs']]] header_orders: Inspect the request headers. See Header Order below for details.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgs']]] headers: Inspect the request headers. See Headers below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgs'] json_body: Inspect the request body as JSON. See JSON Body for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgs'] method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgs'] query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgs'] single_header: Inspect a single header. See Single Header below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs'] single_query_argument: Inspect a single query argument. See Single Query Argument below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgs'] uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs']]:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgs']]:
        """
        Inspect the request body, which immediately follows the request headers.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgs']]:
        """
        Inspect the cookies in the web request. See Cookies below for details.
        """
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgs']]]]:
        """
        Inspect the request headers. See Header Order below for details.
        """
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgs']]]]:
        """
        Inspect the request headers. See Headers below for details.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs']]:
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgs']]:
        """
        Inspect the request body as JSON. See JSON Body for details.
        """
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgs']]:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgs']]:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgs']]:
        """
        Inspect a single header. See Single Header below for details.
        """
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs']]:
        """
        Inspect a single query argument. See Single Query Argument below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgs']]:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs']]] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param pulumi.Input[str] match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs']]]:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_cookies", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs'] match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param pulumi.Input[str] match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs']:
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_headers", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: The match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        The match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 invalid_fallback_behavior: Optional[pulumi.Input[str]] = None,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs'] match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param pulumi.Input[str] match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param pulumi.Input[str] invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param pulumi.Input[str] oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs']:
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_paths", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgs']] = None):
        """
        :param pulumi.Input[str] arn: The Amazon Resource Name (ARN) of the Regex Pattern Set that this statement references.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
               At least one required.
               See Text Transformation below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgs'] field_to_match: The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @property
    @pulumi.getter
    def arn(self) -> pulumi.Input[str]:
        """
        The Amazon Resource Name (ARN) of the Regex Pattern Set that this statement references.
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "arn", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
        At least one required.
        See Text Transformation below for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgs']]:
        """
        The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_path: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs']] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs'] all_query_arguments: Inspect all query arguments.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs'] body: Inspect the request body, which immediately follows the request headers.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs'] cookies: Inspect the cookies in the web request. See Cookies below for details.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs']]] header_orders: Inspect the request headers. See Header Order below for details.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs']]] headers: Inspect the request headers. See Headers below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs'] json_body: Inspect the request body as JSON. See JSON Body for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs'] method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs'] query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs'] single_header: Inspect a single header. See Single Header below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs'] single_query_argument: Inspect a single query argument. See Single Query Argument below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs'] uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs']]:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs']]:
        """
        Inspect the request body, which immediately follows the request headers.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs']]:
        """
        Inspect the cookies in the web request. See Cookies below for details.
        """
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs']]]]:
        """
        Inspect the request headers. See Header Order below for details.
        """
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs']]]]:
        """
        Inspect the request headers. See Headers below for details.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs']]:
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs']]:
        """
        Inspect the request body as JSON. See JSON Body for details.
        """
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs']]:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs']]:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs']]:
        """
        Inspect a single header. See Single Header below for details.
        """
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs']]:
        """
        Inspect a single query argument. See Single Query Argument below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs']]:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs']]] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param pulumi.Input[str] match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs']]]:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_cookies", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs'] match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param pulumi.Input[str] match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs']:
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_headers", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: The match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        The match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 invalid_fallback_behavior: Optional[pulumi.Input[str]] = None,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs'] match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param pulumi.Input[str] match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param pulumi.Input[str] invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param pulumi.Input[str] oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs']:
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_paths", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementArgs:
    def __init__(__self__, *,
                 comparison_operator: pulumi.Input[str],
                 size: pulumi.Input[int],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgs']] = None):
        """
        :param pulumi.Input[str] comparison_operator: The operator to use to compare the request part to the size setting. Valid values include: `EQ`, `NE`, `LE`, `LT`, `GE`, or `GT`.
        :param pulumi.Input[int] size: The size, in bytes, to compare to the request part, after any transformations. Valid values are integers between 0 and 21474836480, inclusive.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
               At least one required.
               See Text Transformation below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgs'] field_to_match: The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        pulumi.set(__self__, "comparison_operator", comparison_operator)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> pulumi.Input[str]:
        """
        The operator to use to compare the request part to the size setting. Valid values include: `EQ`, `NE`, `LE`, `LT`, `GE`, or `GT`.
        """
        return pulumi.get(self, "comparison_operator")

    @comparison_operator.setter
    def comparison_operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "comparison_operator", value)

    @property
    @pulumi.getter
    def size(self) -> pulumi.Input[int]:
        """
        The size, in bytes, to compare to the request part, after any transformations. Valid values are integers between 0 and 21474836480, inclusive.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[int]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
        At least one required.
        See Text Transformation below for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgs']]:
        """
        The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_path: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgs']] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs'] all_query_arguments: Inspect all query arguments.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgs'] body: Inspect the request body, which immediately follows the request headers.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgs'] cookies: Inspect the cookies in the web request. See Cookies below for details.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs']]] header_orders: Inspect the request headers. See Header Order below for details.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgs']]] headers: Inspect the request headers. See Headers below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgs'] json_body: Inspect the request body as JSON. See JSON Body for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgs'] method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgs'] query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs'] single_header: Inspect a single header. See Single Header below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs'] single_query_argument: Inspect a single query argument. See Single Query Argument below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgs'] uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs']]:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgs']]:
        """
        Inspect the request body, which immediately follows the request headers.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgs']]:
        """
        Inspect the cookies in the web request. See Cookies below for details.
        """
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs']]]]:
        """
        Inspect the request headers. See Header Order below for details.
        """
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgs']]]]:
        """
        Inspect the request headers. See Headers below for details.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs']]:
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgs']]:
        """
        Inspect the request body as JSON. See JSON Body for details.
        """
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgs']]:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgs']]:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs']]:
        """
        Inspect a single header. See Single Header below for details.
        """
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs']]:
        """
        Inspect a single query argument. See Single Query Argument below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgs']]:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs']]] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param pulumi.Input[str] match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs']]]:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_cookies", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs'] match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param pulumi.Input[str] match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs']:
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_headers", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: The match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        The match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 invalid_fallback_behavior: Optional[pulumi.Input[str]] = None,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs'] match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param pulumi.Input[str] match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param pulumi.Input[str] invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param pulumi.Input[str] oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs']:
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_paths", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementArgs:
    def __init__(__self__, *,
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
               At least one required.
               See Text Transformation below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchArgs'] field_to_match: The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
        At least one required.
        See Text Transformation below for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchArgs']]:
        """
        The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_path: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgs']] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs'] all_query_arguments: Inspect all query arguments.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgs'] body: Inspect the request body, which immediately follows the request headers.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgs'] cookies: Inspect the cookies in the web request. See Cookies below for details.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgs']]] header_orders: Inspect the request headers. See Header Order below for details.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgs']]] headers: Inspect the request headers. See Headers below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgs'] json_body: Inspect the request body as JSON. See JSON Body for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgs'] method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgs'] query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgs'] single_header: Inspect a single header. See Single Header below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs'] single_query_argument: Inspect a single query argument. See Single Query Argument below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgs'] uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs']]:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgs']]:
        """
        Inspect the request body, which immediately follows the request headers.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgs']]:
        """
        Inspect the cookies in the web request. See Cookies below for details.
        """
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgs']]]]:
        """
        Inspect the request headers. See Header Order below for details.
        """
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgs']]]]:
        """
        Inspect the request headers. See Headers below for details.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs']]:
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgs']]:
        """
        Inspect the request body as JSON. See JSON Body for details.
        """
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgs']]:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgs']]:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgs']]:
        """
        Inspect a single header. See Single Header below for details.
        """
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs']]:
        """
        Inspect a single query argument. See Single Query Argument below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgs']]:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs']]] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param pulumi.Input[str] match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs']]]:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_cookies", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs'] match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param pulumi.Input[str] match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs']:
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_headers", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: The match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        The match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 invalid_fallback_behavior: Optional[pulumi.Input[str]] = None,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs'] match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param pulumi.Input[str] match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param pulumi.Input[str] invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param pulumi.Input[str] oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs']:
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_paths", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementArgs:
    def __init__(__self__, *,
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
               At least one required.
               See Text Transformation below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchArgs'] field_to_match: The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
        At least one required.
        See Text Transformation below for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchArgs']]:
        """
        The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_path: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgs']] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs'] all_query_arguments: Inspect all query arguments.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgs'] body: Inspect the request body, which immediately follows the request headers.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgs'] cookies: Inspect the cookies in the web request. See Cookies below for details.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgs']]] header_orders: Inspect the request headers. See Header Order below for details.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgs']]] headers: Inspect the request headers. See Headers below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgs'] json_body: Inspect the request body as JSON. See JSON Body for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgs'] method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgs'] query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgs'] single_header: Inspect a single header. See Single Header below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs'] single_query_argument: Inspect a single query argument. See Single Query Argument below for details.
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgs'] uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs']]:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgs']]:
        """
        Inspect the request body, which immediately follows the request headers.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgs']]:
        """
        Inspect the cookies in the web request. See Cookies below for details.
        """
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgs']]]]:
        """
        Inspect the request headers. See Header Order below for details.
        """
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgs']]]]:
        """
        Inspect the request headers. See Headers below for details.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgs']]:
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgs']]:
        """
        Inspect the request body as JSON. See JSON Body for details.
        """
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgs']]:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgs']]:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgs']]:
        """
        Inspect a single header. See Single Header below for details.
        """
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs']]:
        """
        Inspect a single query argument. See Single Query Argument below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgs']]:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs']]] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param pulumi.Input[str] match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs']]]:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_cookies", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs'] match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param pulumi.Input[str] match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs']:
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_headers", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: The match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        The match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 invalid_fallback_behavior: Optional[pulumi.Input[str]] = None,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs'] match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param pulumi.Input[str] match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param pulumi.Input[str] invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param pulumi.Input[str] oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs']:
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_paths", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class RuleGroupRuleStatementRegexMatchStatementArgs:
    def __init__(__self__, *,
                 regex_string: pulumi.Input[str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchArgs']] = None):
        """
        :param pulumi.Input[str] regex_string: The string representing the regular expression. **Note:** The fixed quota for the maximum number of characters in each regex pattern is 200, which can't be changed. See [AWS WAF quotas](https://docs.aws.amazon.com/waf/latest/developerguide/limits.html) for details.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
               At least one required.
               See Text Transformation below for details.
        :param pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchArgs'] field_to_match: The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        pulumi.set(__self__, "regex_string", regex_string)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @property
    @pulumi.getter(name="regexString")
    def regex_string(self) -> pulumi.Input[str]:
        """
        The string representing the regular expression. **Note:** The fixed quota for the maximum number of characters in each regex pattern is 200, which can't be changed. See [AWS WAF quotas](https://docs.aws.amazon.com/waf/latest/developerguide/limits.html) for details.
        """
        return pulumi.get(self, "regex_string")

    @regex_string.setter
    def regex_string(self, value: pulumi.Input[str]):
        pulumi.set(self, "regex_string", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
        At least one required.
        See Text Transformation below for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchArgs']]:
        """
        The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


@pulumi.input_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_path: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchUriPathArgs']] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs'] all_query_arguments: Inspect all query arguments.
        :param pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchBodyArgs'] body: Inspect the request body, which immediately follows the request headers.
        :param pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesArgs'] cookies: Inspect the cookies in the web request. See Cookies below for details.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderOrderArgs']]] header_orders: Inspect the request headers. See Header Order below for details.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderArgs']]] headers: Inspect the request headers. See Headers below for details.
        :param pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyArgs'] json_body: Inspect the request body as JSON. See JSON Body for details.
        :param pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchMethodArgs'] method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchQueryStringArgs'] query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleHeaderArgs'] single_header: Inspect a single header. See Single Header below for details.
        :param pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs'] single_query_argument: Inspect a single query argument. See Single Query Argument below for details.
        :param pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchUriPathArgs'] uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs']]:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchBodyArgs']]:
        """
        Inspect the request body, which immediately follows the request headers.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesArgs']]:
        """
        Inspect the cookies in the web request. See Cookies below for details.
        """
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderOrderArgs']]]]:
        """
        Inspect the request headers. See Header Order below for details.
        """
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderArgs']]]]:
        """
        Inspect the request headers. See Headers below for details.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs']]:
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyArgs']]:
        """
        Inspect the request body as JSON. See JSON Body for details.
        """
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchMethodArgs']]:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchQueryStringArgs']]:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleHeaderArgs']]:
        """
        Inspect a single header. See Single Header below for details.
        """
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs']]:
        """
        Inspect a single query argument. See Single Query Argument below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchUriPathArgs']]:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


@pulumi.input_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs']]] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param pulumi.Input[str] match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs']]]:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_cookies", value)


@pulumi.input_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs'] match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param pulumi.Input[str] match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs']:
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_headers", value)


@pulumi.input_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: The match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        The match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)


@pulumi.input_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 invalid_fallback_behavior: Optional[pulumi.Input[str]] = None,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs'] match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param pulumi.Input[str] match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param pulumi.Input[str] invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param pulumi.Input[str] oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs']:
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_paths", value)


@pulumi.input_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementRegexMatchStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchArgs']] = None):
        """
        :param pulumi.Input[str] arn: The Amazon Resource Name (ARN) of the Regex Pattern Set that this statement references.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
               At least one required.
               See Text Transformation below for details.
        :param pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchArgs'] field_to_match: The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @property
    @pulumi.getter
    def arn(self) -> pulumi.Input[str]:
        """
        The Amazon Resource Name (ARN) of the Regex Pattern Set that this statement references.
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "arn", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
        At least one required.
        See Text Transformation below for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchArgs']]:
        """
        The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


@pulumi.input_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_path: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs']] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs'] all_query_arguments: Inspect all query arguments.
        :param pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs'] body: Inspect the request body, which immediately follows the request headers.
        :param pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs'] cookies: Inspect the cookies in the web request. See Cookies below for details.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs']]] header_orders: Inspect the request headers. See Header Order below for details.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs']]] headers: Inspect the request headers. See Headers below for details.
        :param pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs'] json_body: Inspect the request body as JSON. See JSON Body for details.
        :param pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs'] method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs'] query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs'] single_header: Inspect a single header. See Single Header below for details.
        :param pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs'] single_query_argument: Inspect a single query argument. See Single Query Argument below for details.
        :param pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs'] uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs']]:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs']]:
        """
        Inspect the request body, which immediately follows the request headers.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs']]:
        """
        Inspect the cookies in the web request. See Cookies below for details.
        """
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs']]]]:
        """
        Inspect the request headers. See Header Order below for details.
        """
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs']]]]:
        """
        Inspect the request headers. See Headers below for details.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs']]:
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs']]:
        """
        Inspect the request body as JSON. See JSON Body for details.
        """
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs']]:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs']]:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs']]:
        """
        Inspect a single header. See Single Header below for details.
        """
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs']]:
        """
        Inspect a single query argument. See Single Query Argument below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs']]:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


@pulumi.input_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs']]] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param pulumi.Input[str] match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs']]]:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_cookies", value)


@pulumi.input_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs'] match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param pulumi.Input[str] match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs']:
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_headers", value)


@pulumi.input_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: The match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        The match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)


@pulumi.input_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 invalid_fallback_behavior: Optional[pulumi.Input[str]] = None,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs'] match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param pulumi.Input[str] match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param pulumi.Input[str] invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param pulumi.Input[str] oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs']:
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_paths", value)


@pulumi.input_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class RuleGroupRuleStatementSizeConstraintStatementArgs:
    def __init__(__self__, *,
                 comparison_operator: pulumi.Input[str],
                 size: pulumi.Input[int],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchArgs']] = None):
        """
        :param pulumi.Input[str] comparison_operator: The operator to use to compare the request part to the size setting. Valid values include: `EQ`, `NE`, `LE`, `LT`, `GE`, or `GT`.
        :param pulumi.Input[int] size: The size, in bytes, to compare to the request part, after any transformations. Valid values are integers between 0 and 21474836480, inclusive.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
               At least one required.
               See Text Transformation below for details.
        :param pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchArgs'] field_to_match: The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        pulumi.set(__self__, "comparison_operator", comparison_operator)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> pulumi.Input[str]:
        """
        The operator to use to compare the request part to the size setting. Valid values include: `EQ`, `NE`, `LE`, `LT`, `GE`, or `GT`.
        """
        return pulumi.get(self, "comparison_operator")

    @comparison_operator.setter
    def comparison_operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "comparison_operator", value)

    @property
    @pulumi.getter
    def size(self) -> pulumi.Input[int]:
        """
        The size, in bytes, to compare to the request part, after any transformations. Valid values are integers between 0 and 21474836480, inclusive.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[int]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
        At least one required.
        See Text Transformation below for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchArgs']]:
        """
        The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


@pulumi.input_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_path: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchUriPathArgs']] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs'] all_query_arguments: Inspect all query arguments.
        :param pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchBodyArgs'] body: Inspect the request body, which immediately follows the request headers.
        :param pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesArgs'] cookies: Inspect the cookies in the web request. See Cookies below for details.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs']]] header_orders: Inspect the request headers. See Header Order below for details.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderArgs']]] headers: Inspect the request headers. See Headers below for details.
        :param pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyArgs'] json_body: Inspect the request body as JSON. See JSON Body for details.
        :param pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchMethodArgs'] method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchQueryStringArgs'] query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs'] single_header: Inspect a single header. See Single Header below for details.
        :param pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs'] single_query_argument: Inspect a single query argument. See Single Query Argument below for details.
        :param pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchUriPathArgs'] uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs']]:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchBodyArgs']]:
        """
        Inspect the request body, which immediately follows the request headers.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesArgs']]:
        """
        Inspect the cookies in the web request. See Cookies below for details.
        """
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs']]]]:
        """
        Inspect the request headers. See Header Order below for details.
        """
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderArgs']]]]:
        """
        Inspect the request headers. See Headers below for details.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs']]:
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyArgs']]:
        """
        Inspect the request body as JSON. See JSON Body for details.
        """
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchMethodArgs']]:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchQueryStringArgs']]:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs']]:
        """
        Inspect a single header. See Single Header below for details.
        """
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs']]:
        """
        Inspect a single query argument. See Single Query Argument below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchUriPathArgs']]:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


@pulumi.input_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs']]] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param pulumi.Input[str] match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs']]]:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_cookies", value)


@pulumi.input_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs'] match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param pulumi.Input[str] match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs']:
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_headers", value)


@pulumi.input_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: The match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        The match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)


@pulumi.input_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 invalid_fallback_behavior: Optional[pulumi.Input[str]] = None,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs'] match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param pulumi.Input[str] match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param pulumi.Input[str] invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param pulumi.Input[str] oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs']:
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_paths", value)


@pulumi.input_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementSizeConstraintStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class RuleGroupRuleStatementSqliMatchStatementArgs:
    def __init__(__self__, *,
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
               At least one required.
               See Text Transformation below for details.
        :param pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchArgs'] field_to_match: The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
        At least one required.
        See Text Transformation below for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchArgs']]:
        """
        The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


@pulumi.input_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_path: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchUriPathArgs']] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs'] all_query_arguments: Inspect all query arguments.
        :param pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchBodyArgs'] body: Inspect the request body, which immediately follows the request headers.
        :param pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesArgs'] cookies: Inspect the cookies in the web request. See Cookies below for details.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderOrderArgs']]] header_orders: Inspect the request headers. See Header Order below for details.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderArgs']]] headers: Inspect the request headers. See Headers below for details.
        :param pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyArgs'] json_body: Inspect the request body as JSON. See JSON Body for details.
        :param pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchMethodArgs'] method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchQueryStringArgs'] query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleHeaderArgs'] single_header: Inspect a single header. See Single Header below for details.
        :param pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs'] single_query_argument: Inspect a single query argument. See Single Query Argument below for details.
        :param pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchUriPathArgs'] uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs']]:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchBodyArgs']]:
        """
        Inspect the request body, which immediately follows the request headers.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesArgs']]:
        """
        Inspect the cookies in the web request. See Cookies below for details.
        """
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderOrderArgs']]]]:
        """
        Inspect the request headers. See Header Order below for details.
        """
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderArgs']]]]:
        """
        Inspect the request headers. See Headers below for details.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs']]:
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyArgs']]:
        """
        Inspect the request body as JSON. See JSON Body for details.
        """
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchMethodArgs']]:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchQueryStringArgs']]:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleHeaderArgs']]:
        """
        Inspect a single header. See Single Header below for details.
        """
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs']]:
        """
        Inspect a single query argument. See Single Query Argument below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchUriPathArgs']]:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


@pulumi.input_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs']]] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param pulumi.Input[str] match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs']]]:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_cookies", value)


@pulumi.input_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs'] match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param pulumi.Input[str] match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs']:
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_headers", value)


@pulumi.input_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: The match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        The match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)


@pulumi.input_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 invalid_fallback_behavior: Optional[pulumi.Input[str]] = None,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs'] match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param pulumi.Input[str] match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param pulumi.Input[str] invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param pulumi.Input[str] oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs']:
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_paths", value)


@pulumi.input_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementSqliMatchStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class RuleGroupRuleStatementXssMatchStatementArgs:
    def __init__(__self__, *,
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementXssMatchStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementXssMatchStatementTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
               At least one required.
               See Text Transformation below for details.
        :param pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchArgs'] field_to_match: The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementXssMatchStatementTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
        At least one required.
        See Text Transformation below for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementXssMatchStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchArgs']]:
        """
        The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


@pulumi.input_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchJa3FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_path: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchUriPathArgs']] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs'] all_query_arguments: Inspect all query arguments.
        :param pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchBodyArgs'] body: Inspect the request body, which immediately follows the request headers.
        :param pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesArgs'] cookies: Inspect the cookies in the web request. See Cookies below for details.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderOrderArgs']]] header_orders: Inspect the request headers. See Header Order below for details.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderArgs']]] headers: Inspect the request headers. See Headers below for details.
        :param pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyArgs'] json_body: Inspect the request body as JSON. See JSON Body for details.
        :param pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchMethodArgs'] method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchQueryStringArgs'] query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleHeaderArgs'] single_header: Inspect a single header. See Single Header below for details.
        :param pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs'] single_query_argument: Inspect a single query argument. See Single Query Argument below for details.
        :param pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchUriPathArgs'] uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs']]:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchBodyArgs']]:
        """
        Inspect the request body, which immediately follows the request headers.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesArgs']]:
        """
        Inspect the cookies in the web request. See Cookies below for details.
        """
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderOrderArgs']]]]:
        """
        Inspect the request headers. See Header Order below for details.
        """
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderArgs']]]]:
        """
        Inspect the request headers. See Headers below for details.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchJa3FingerprintArgs']]:
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyArgs']]:
        """
        Inspect the request body as JSON. See JSON Body for details.
        """
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchMethodArgs']]:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchQueryStringArgs']]:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleHeaderArgs']]:
        """
        Inspect a single header. See Single Header below for details.
        """
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs']]:
        """
        Inspect a single query argument. See Single Query Argument below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchUriPathArgs']]:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


@pulumi.input_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs']]] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param pulumi.Input[str] match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs']]]:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_cookies", value)


@pulumi.input_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs'] match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param pulumi.Input[str] match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs']:
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_headers", value)


@pulumi.input_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: The match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        The match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)


@pulumi.input_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 invalid_fallback_behavior: Optional[pulumi.Input[str]] = None,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs'] match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param pulumi.Input[str] match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param pulumi.Input[str] invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param pulumi.Input[str] oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs']:
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_paths", value)


@pulumi.input_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class RuleGroupRuleStatementXssMatchStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class RuleGroupRuleVisibilityConfigArgs:
    def __init__(__self__, *,
                 cloudwatch_metrics_enabled: pulumi.Input[bool],
                 metric_name: pulumi.Input[str],
                 sampled_requests_enabled: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] cloudwatch_metrics_enabled: A boolean indicating whether the associated resource sends metrics to CloudWatch. For the list of available metrics, see [AWS WAF Metrics](https://docs.aws.amazon.com/waf/latest/developerguide/monitoring-cloudwatch.html#waf-metrics).
        :param pulumi.Input[str] metric_name: A friendly name of the CloudWatch metric. The name can contain only alphanumeric characters (A-Z, a-z, 0-9) hyphen(-) and underscore (_), with length from one to 128 characters. It can't contain whitespace or metric names reserved for AWS WAF, for example `All` and `Default_Action`.
        :param pulumi.Input[bool] sampled_requests_enabled: A boolean indicating whether AWS WAF should store a sampling of the web requests that match the rules. You can view the sampled requests through the AWS WAF console.
        """
        pulumi.set(__self__, "cloudwatch_metrics_enabled", cloudwatch_metrics_enabled)
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "sampled_requests_enabled", sampled_requests_enabled)

    @property
    @pulumi.getter(name="cloudwatchMetricsEnabled")
    def cloudwatch_metrics_enabled(self) -> pulumi.Input[bool]:
        """
        A boolean indicating whether the associated resource sends metrics to CloudWatch. For the list of available metrics, see [AWS WAF Metrics](https://docs.aws.amazon.com/waf/latest/developerguide/monitoring-cloudwatch.html#waf-metrics).
        """
        return pulumi.get(self, "cloudwatch_metrics_enabled")

    @cloudwatch_metrics_enabled.setter
    def cloudwatch_metrics_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "cloudwatch_metrics_enabled", value)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> pulumi.Input[str]:
        """
        A friendly name of the CloudWatch metric. The name can contain only alphanumeric characters (A-Z, a-z, 0-9) hyphen(-) and underscore (_), with length from one to 128 characters. It can't contain whitespace or metric names reserved for AWS WAF, for example `All` and `Default_Action`.
        """
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric_name", value)

    @property
    @pulumi.getter(name="sampledRequestsEnabled")
    def sampled_requests_enabled(self) -> pulumi.Input[bool]:
        """
        A boolean indicating whether AWS WAF should store a sampling of the web requests that match the rules. You can view the sampled requests through the AWS WAF console.
        """
        return pulumi.get(self, "sampled_requests_enabled")

    @sampled_requests_enabled.setter
    def sampled_requests_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "sampled_requests_enabled", value)


@pulumi.input_type
class RuleGroupVisibilityConfigArgs:
    def __init__(__self__, *,
                 cloudwatch_metrics_enabled: pulumi.Input[bool],
                 metric_name: pulumi.Input[str],
                 sampled_requests_enabled: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] cloudwatch_metrics_enabled: A boolean indicating whether the associated resource sends metrics to CloudWatch. For the list of available metrics, see [AWS WAF Metrics](https://docs.aws.amazon.com/waf/latest/developerguide/monitoring-cloudwatch.html#waf-metrics).
        :param pulumi.Input[str] metric_name: A friendly name of the CloudWatch metric. The name can contain only alphanumeric characters (A-Z, a-z, 0-9) hyphen(-) and underscore (_), with length from one to 128 characters. It can't contain whitespace or metric names reserved for AWS WAF, for example `All` and `Default_Action`.
        :param pulumi.Input[bool] sampled_requests_enabled: A boolean indicating whether AWS WAF should store a sampling of the web requests that match the rules. You can view the sampled requests through the AWS WAF console.
        """
        pulumi.set(__self__, "cloudwatch_metrics_enabled", cloudwatch_metrics_enabled)
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "sampled_requests_enabled", sampled_requests_enabled)

    @property
    @pulumi.getter(name="cloudwatchMetricsEnabled")
    def cloudwatch_metrics_enabled(self) -> pulumi.Input[bool]:
        """
        A boolean indicating whether the associated resource sends metrics to CloudWatch. For the list of available metrics, see [AWS WAF Metrics](https://docs.aws.amazon.com/waf/latest/developerguide/monitoring-cloudwatch.html#waf-metrics).
        """
        return pulumi.get(self, "cloudwatch_metrics_enabled")

    @cloudwatch_metrics_enabled.setter
    def cloudwatch_metrics_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "cloudwatch_metrics_enabled", value)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> pulumi.Input[str]:
        """
        A friendly name of the CloudWatch metric. The name can contain only alphanumeric characters (A-Z, a-z, 0-9) hyphen(-) and underscore (_), with length from one to 128 characters. It can't contain whitespace or metric names reserved for AWS WAF, for example `All` and `Default_Action`.
        """
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric_name", value)

    @property
    @pulumi.getter(name="sampledRequestsEnabled")
    def sampled_requests_enabled(self) -> pulumi.Input[bool]:
        """
        A boolean indicating whether AWS WAF should store a sampling of the web requests that match the rules. You can view the sampled requests through the AWS WAF console.
        """
        return pulumi.get(self, "sampled_requests_enabled")

    @sampled_requests_enabled.setter
    def sampled_requests_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "sampled_requests_enabled", value)


@pulumi.input_type
class WebAclAssociationConfigArgs:
    def __init__(__self__, *,
                 request_bodies: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclAssociationConfigRequestBodyArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclAssociationConfigRequestBodyArgs']]] request_bodies: Customizes the request body that your protected resource forward to AWS WAF for inspection. See `request_body` below for details.
        """
        if request_bodies is not None:
            pulumi.set(__self__, "request_bodies", request_bodies)

    @property
    @pulumi.getter(name="requestBodies")
    def request_bodies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclAssociationConfigRequestBodyArgs']]]]:
        """
        Customizes the request body that your protected resource forward to AWS WAF for inspection. See `request_body` below for details.
        """
        return pulumi.get(self, "request_bodies")

    @request_bodies.setter
    def request_bodies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclAssociationConfigRequestBodyArgs']]]]):
        pulumi.set(self, "request_bodies", value)


@pulumi.input_type
class WebAclAssociationConfigRequestBodyArgs:
    def __init__(__self__, *,
                 cloudfronts: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclAssociationConfigRequestBodyCloudfrontArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclAssociationConfigRequestBodyCloudfrontArgs']]] cloudfronts: Customizes the request body that your protected CloudFront distributions forward to AWS WAF for inspection. See `cloudfront` below for details.
        """
        if cloudfronts is not None:
            pulumi.set(__self__, "cloudfronts", cloudfronts)

    @property
    @pulumi.getter
    def cloudfronts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclAssociationConfigRequestBodyCloudfrontArgs']]]]:
        """
        Customizes the request body that your protected CloudFront distributions forward to AWS WAF for inspection. See `cloudfront` below for details.
        """
        return pulumi.get(self, "cloudfronts")

    @cloudfronts.setter
    def cloudfronts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclAssociationConfigRequestBodyCloudfrontArgs']]]]):
        pulumi.set(self, "cloudfronts", value)


@pulumi.input_type
class WebAclAssociationConfigRequestBodyCloudfrontArgs:
    def __init__(__self__, *,
                 default_size_inspection_limit: pulumi.Input[str]):
        """
        :param pulumi.Input[str] default_size_inspection_limit: Specifies the maximum size of the web request body component that an associated CloudFront distribution should send to AWS WAF for inspection. This applies to statements in the web ACL that inspect the body or JSON body. Valid values are `KB_16`, `KB_32`, `KB_48` and `KB_64`.
        """
        pulumi.set(__self__, "default_size_inspection_limit", default_size_inspection_limit)

    @property
    @pulumi.getter(name="defaultSizeInspectionLimit")
    def default_size_inspection_limit(self) -> pulumi.Input[str]:
        """
        Specifies the maximum size of the web request body component that an associated CloudFront distribution should send to AWS WAF for inspection. This applies to statements in the web ACL that inspect the body or JSON body. Valid values are `KB_16`, `KB_32`, `KB_48` and `KB_64`.
        """
        return pulumi.get(self, "default_size_inspection_limit")

    @default_size_inspection_limit.setter
    def default_size_inspection_limit(self, value: pulumi.Input[str]):
        pulumi.set(self, "default_size_inspection_limit", value)


@pulumi.input_type
class WebAclCaptchaConfigArgs:
    def __init__(__self__, *,
                 immunity_time_property: Optional[pulumi.Input['WebAclCaptchaConfigImmunityTimePropertyArgs']] = None):
        """
        :param pulumi.Input['WebAclCaptchaConfigImmunityTimePropertyArgs'] immunity_time_property: Defines custom immunity time. See `immunity_time_property` below for details.
        """
        if immunity_time_property is not None:
            pulumi.set(__self__, "immunity_time_property", immunity_time_property)

    @property
    @pulumi.getter(name="immunityTimeProperty")
    def immunity_time_property(self) -> Optional[pulumi.Input['WebAclCaptchaConfigImmunityTimePropertyArgs']]:
        """
        Defines custom immunity time. See `immunity_time_property` below for details.
        """
        return pulumi.get(self, "immunity_time_property")

    @immunity_time_property.setter
    def immunity_time_property(self, value: Optional[pulumi.Input['WebAclCaptchaConfigImmunityTimePropertyArgs']]):
        pulumi.set(self, "immunity_time_property", value)


@pulumi.input_type
class WebAclCaptchaConfigImmunityTimePropertyArgs:
    def __init__(__self__, *,
                 immunity_time: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] immunity_time: The amount of time, in seconds, that a CAPTCHA or challenge timestamp is considered valid by AWS WAF. The default setting is 300.
        """
        if immunity_time is not None:
            pulumi.set(__self__, "immunity_time", immunity_time)

    @property
    @pulumi.getter(name="immunityTime")
    def immunity_time(self) -> Optional[pulumi.Input[int]]:
        """
        The amount of time, in seconds, that a CAPTCHA or challenge timestamp is considered valid by AWS WAF. The default setting is 300.
        """
        return pulumi.get(self, "immunity_time")

    @immunity_time.setter
    def immunity_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "immunity_time", value)


@pulumi.input_type
class WebAclChallengeConfigArgs:
    def __init__(__self__, *,
                 immunity_time_property: Optional[pulumi.Input['WebAclChallengeConfigImmunityTimePropertyArgs']] = None):
        """
        :param pulumi.Input['WebAclChallengeConfigImmunityTimePropertyArgs'] immunity_time_property: Defines custom immunity time. See `immunity_time_property` below for details.
        """
        if immunity_time_property is not None:
            pulumi.set(__self__, "immunity_time_property", immunity_time_property)

    @property
    @pulumi.getter(name="immunityTimeProperty")
    def immunity_time_property(self) -> Optional[pulumi.Input['WebAclChallengeConfigImmunityTimePropertyArgs']]:
        """
        Defines custom immunity time. See `immunity_time_property` below for details.
        """
        return pulumi.get(self, "immunity_time_property")

    @immunity_time_property.setter
    def immunity_time_property(self, value: Optional[pulumi.Input['WebAclChallengeConfigImmunityTimePropertyArgs']]):
        pulumi.set(self, "immunity_time_property", value)


@pulumi.input_type
class WebAclChallengeConfigImmunityTimePropertyArgs:
    def __init__(__self__, *,
                 immunity_time: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] immunity_time: The amount of time, in seconds, that a CAPTCHA or challenge timestamp is considered valid by AWS WAF. The default setting is 300.
        """
        if immunity_time is not None:
            pulumi.set(__self__, "immunity_time", immunity_time)

    @property
    @pulumi.getter(name="immunityTime")
    def immunity_time(self) -> Optional[pulumi.Input[int]]:
        """
        The amount of time, in seconds, that a CAPTCHA or challenge timestamp is considered valid by AWS WAF. The default setting is 300.
        """
        return pulumi.get(self, "immunity_time")

    @immunity_time.setter
    def immunity_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "immunity_time", value)


@pulumi.input_type
class WebAclCustomResponseBodyArgs:
    def __init__(__self__, *,
                 content: pulumi.Input[str],
                 content_type: pulumi.Input[str],
                 key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] content: Payload of the custom response.
        :param pulumi.Input[str] content_type: Type of content in the payload that you are defining in the `content` argument. Valid values are `TEXT_PLAIN`, `TEXT_HTML`, or `APPLICATION_JSON`.
        :param pulumi.Input[str] key: Unique key identifying the custom response body. This is referenced by the `custom_response_body_key` argument in the `custom_response` block.
        """
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "content_type", content_type)
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def content(self) -> pulumi.Input[str]:
        """
        Payload of the custom response.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: pulumi.Input[str]):
        pulumi.set(self, "content", value)

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> pulumi.Input[str]:
        """
        Type of content in the payload that you are defining in the `content` argument. Valid values are `TEXT_PLAIN`, `TEXT_HTML`, or `APPLICATION_JSON`.
        """
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "content_type", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Unique key identifying the custom response body. This is referenced by the `custom_response_body_key` argument in the `custom_response` block.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)


@pulumi.input_type
class WebAclDefaultActionArgs:
    def __init__(__self__, *,
                 allow: Optional[pulumi.Input['WebAclDefaultActionAllowArgs']] = None,
                 block: Optional[pulumi.Input['WebAclDefaultActionBlockArgs']] = None):
        """
        :param pulumi.Input['WebAclDefaultActionAllowArgs'] allow: Specifies that AWS WAF should allow requests by default. See `allow` below for details.
        :param pulumi.Input['WebAclDefaultActionBlockArgs'] block: Specifies that AWS WAF should block requests by default. See `block` below for details.
        """
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if block is not None:
            pulumi.set(__self__, "block", block)

    @property
    @pulumi.getter
    def allow(self) -> Optional[pulumi.Input['WebAclDefaultActionAllowArgs']]:
        """
        Specifies that AWS WAF should allow requests by default. See `allow` below for details.
        """
        return pulumi.get(self, "allow")

    @allow.setter
    def allow(self, value: Optional[pulumi.Input['WebAclDefaultActionAllowArgs']]):
        pulumi.set(self, "allow", value)

    @property
    @pulumi.getter
    def block(self) -> Optional[pulumi.Input['WebAclDefaultActionBlockArgs']]:
        """
        Specifies that AWS WAF should block requests by default. See `block` below for details.
        """
        return pulumi.get(self, "block")

    @block.setter
    def block(self, value: Optional[pulumi.Input['WebAclDefaultActionBlockArgs']]):
        pulumi.set(self, "block", value)


@pulumi.input_type
class WebAclDefaultActionAllowArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['WebAclDefaultActionAllowCustomRequestHandlingArgs']] = None):
        """
        :param pulumi.Input['WebAclDefaultActionAllowCustomRequestHandlingArgs'] custom_request_handling: Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['WebAclDefaultActionAllowCustomRequestHandlingArgs']]:
        """
        Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['WebAclDefaultActionAllowCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


@pulumi.input_type
class WebAclDefaultActionAllowCustomRequestHandlingArgs:
    def __init__(__self__, *,
                 insert_headers: pulumi.Input[Sequence[pulumi.Input['WebAclDefaultActionAllowCustomRequestHandlingInsertHeaderArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclDefaultActionAllowCustomRequestHandlingInsertHeaderArgs']]] insert_headers: The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        pulumi.set(__self__, "insert_headers", insert_headers)

    @property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclDefaultActionAllowCustomRequestHandlingInsertHeaderArgs']]]:
        """
        The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        return pulumi.get(self, "insert_headers")

    @insert_headers.setter
    def insert_headers(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclDefaultActionAllowCustomRequestHandlingInsertHeaderArgs']]]):
        pulumi.set(self, "insert_headers", value)


@pulumi.input_type
class WebAclDefaultActionAllowCustomRequestHandlingInsertHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        :param pulumi.Input[str] value: Value of the custom header.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value of the custom header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class WebAclDefaultActionBlockArgs:
    def __init__(__self__, *,
                 custom_response: Optional[pulumi.Input['WebAclDefaultActionBlockCustomResponseArgs']] = None):
        """
        :param pulumi.Input['WebAclDefaultActionBlockCustomResponseArgs'] custom_response: Defines a custom response for the web request. See `custom_response` below for details.
        """
        if custom_response is not None:
            pulumi.set(__self__, "custom_response", custom_response)

    @property
    @pulumi.getter(name="customResponse")
    def custom_response(self) -> Optional[pulumi.Input['WebAclDefaultActionBlockCustomResponseArgs']]:
        """
        Defines a custom response for the web request. See `custom_response` below for details.
        """
        return pulumi.get(self, "custom_response")

    @custom_response.setter
    def custom_response(self, value: Optional[pulumi.Input['WebAclDefaultActionBlockCustomResponseArgs']]):
        pulumi.set(self, "custom_response", value)


@pulumi.input_type
class WebAclDefaultActionBlockCustomResponseArgs:
    def __init__(__self__, *,
                 response_code: pulumi.Input[int],
                 custom_response_body_key: Optional[pulumi.Input[str]] = None,
                 response_headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclDefaultActionBlockCustomResponseResponseHeaderArgs']]]] = None):
        """
        :param pulumi.Input[int] response_code: The HTTP status code to return to the client.
        :param pulumi.Input[str] custom_response_body_key: References the response body that you want AWS WAF to return to the web request client. This must reference a `key` defined in a `custom_response_body` block of this resource.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclDefaultActionBlockCustomResponseResponseHeaderArgs']]] response_headers: The `response_header` blocks used to define the HTTP response headers added to the response. See `response_header` below for details.
        """
        pulumi.set(__self__, "response_code", response_code)
        if custom_response_body_key is not None:
            pulumi.set(__self__, "custom_response_body_key", custom_response_body_key)
        if response_headers is not None:
            pulumi.set(__self__, "response_headers", response_headers)

    @property
    @pulumi.getter(name="responseCode")
    def response_code(self) -> pulumi.Input[int]:
        """
        The HTTP status code to return to the client.
        """
        return pulumi.get(self, "response_code")

    @response_code.setter
    def response_code(self, value: pulumi.Input[int]):
        pulumi.set(self, "response_code", value)

    @property
    @pulumi.getter(name="customResponseBodyKey")
    def custom_response_body_key(self) -> Optional[pulumi.Input[str]]:
        """
        References the response body that you want AWS WAF to return to the web request client. This must reference a `key` defined in a `custom_response_body` block of this resource.
        """
        return pulumi.get(self, "custom_response_body_key")

    @custom_response_body_key.setter
    def custom_response_body_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_response_body_key", value)

    @property
    @pulumi.getter(name="responseHeaders")
    def response_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclDefaultActionBlockCustomResponseResponseHeaderArgs']]]]:
        """
        The `response_header` blocks used to define the HTTP response headers added to the response. See `response_header` below for details.
        """
        return pulumi.get(self, "response_headers")

    @response_headers.setter
    def response_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclDefaultActionBlockCustomResponseResponseHeaderArgs']]]]):
        pulumi.set(self, "response_headers", value)


@pulumi.input_type
class WebAclDefaultActionBlockCustomResponseResponseHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        :param pulumi.Input[str] value: Value of the custom header.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value of the custom header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class WebAclLoggingConfigurationLoggingFilterArgs:
    def __init__(__self__, *,
                 default_behavior: pulumi.Input[str],
                 filters: pulumi.Input[Sequence[pulumi.Input['WebAclLoggingConfigurationLoggingFilterFilterArgs']]]):
        """
        :param pulumi.Input[str] default_behavior: Default handling for logs that don't match any of the specified filtering conditions. Valid values for `default_behavior` are `KEEP` or `DROP`.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclLoggingConfigurationLoggingFilterFilterArgs']]] filters: Filter(s) that you want to apply to the logs. See Filter below for more details.
        """
        pulumi.set(__self__, "default_behavior", default_behavior)
        pulumi.set(__self__, "filters", filters)

    @property
    @pulumi.getter(name="defaultBehavior")
    def default_behavior(self) -> pulumi.Input[str]:
        """
        Default handling for logs that don't match any of the specified filtering conditions. Valid values for `default_behavior` are `KEEP` or `DROP`.
        """
        return pulumi.get(self, "default_behavior")

    @default_behavior.setter
    def default_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "default_behavior", value)

    @property
    @pulumi.getter
    def filters(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclLoggingConfigurationLoggingFilterFilterArgs']]]:
        """
        Filter(s) that you want to apply to the logs. See Filter below for more details.
        """
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclLoggingConfigurationLoggingFilterFilterArgs']]]):
        pulumi.set(self, "filters", value)


@pulumi.input_type
class WebAclLoggingConfigurationLoggingFilterFilterArgs:
    def __init__(__self__, *,
                 behavior: pulumi.Input[str],
                 conditions: pulumi.Input[Sequence[pulumi.Input['WebAclLoggingConfigurationLoggingFilterFilterConditionArgs']]],
                 requirement: pulumi.Input[str]):
        """
        :param pulumi.Input[str] behavior: Parameter that determines how to handle logs that meet the conditions and requirements of the filter. The valid values for `behavior` are `KEEP` or `DROP`.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclLoggingConfigurationLoggingFilterFilterConditionArgs']]] conditions: Match condition(s) for the filter. See Condition below for more details.
        :param pulumi.Input[str] requirement: Logic to apply to the filtering conditions. You can specify that a log must match all conditions or at least one condition in order to satisfy the filter. Valid values for `requirement` are `MEETS_ALL` or `MEETS_ANY`.
        """
        pulumi.set(__self__, "behavior", behavior)
        pulumi.set(__self__, "conditions", conditions)
        pulumi.set(__self__, "requirement", requirement)

    @property
    @pulumi.getter
    def behavior(self) -> pulumi.Input[str]:
        """
        Parameter that determines how to handle logs that meet the conditions and requirements of the filter. The valid values for `behavior` are `KEEP` or `DROP`.
        """
        return pulumi.get(self, "behavior")

    @behavior.setter
    def behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "behavior", value)

    @property
    @pulumi.getter
    def conditions(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclLoggingConfigurationLoggingFilterFilterConditionArgs']]]:
        """
        Match condition(s) for the filter. See Condition below for more details.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclLoggingConfigurationLoggingFilterFilterConditionArgs']]]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter
    def requirement(self) -> pulumi.Input[str]:
        """
        Logic to apply to the filtering conditions. You can specify that a log must match all conditions or at least one condition in order to satisfy the filter. Valid values for `requirement` are `MEETS_ALL` or `MEETS_ANY`.
        """
        return pulumi.get(self, "requirement")

    @requirement.setter
    def requirement(self, value: pulumi.Input[str]):
        pulumi.set(self, "requirement", value)


@pulumi.input_type
class WebAclLoggingConfigurationLoggingFilterFilterConditionArgs:
    def __init__(__self__, *,
                 action_condition: Optional[pulumi.Input['WebAclLoggingConfigurationLoggingFilterFilterConditionActionConditionArgs']] = None,
                 label_name_condition: Optional[pulumi.Input['WebAclLoggingConfigurationLoggingFilterFilterConditionLabelNameConditionArgs']] = None):
        """
        :param pulumi.Input['WebAclLoggingConfigurationLoggingFilterFilterConditionActionConditionArgs'] action_condition: Configuration for a single action condition. See Action Condition below for more details.
        :param pulumi.Input['WebAclLoggingConfigurationLoggingFilterFilterConditionLabelNameConditionArgs'] label_name_condition: Condition for a single label name. See Label Name Condition below for more details.
        """
        if action_condition is not None:
            pulumi.set(__self__, "action_condition", action_condition)
        if label_name_condition is not None:
            pulumi.set(__self__, "label_name_condition", label_name_condition)

    @property
    @pulumi.getter(name="actionCondition")
    def action_condition(self) -> Optional[pulumi.Input['WebAclLoggingConfigurationLoggingFilterFilterConditionActionConditionArgs']]:
        """
        Configuration for a single action condition. See Action Condition below for more details.
        """
        return pulumi.get(self, "action_condition")

    @action_condition.setter
    def action_condition(self, value: Optional[pulumi.Input['WebAclLoggingConfigurationLoggingFilterFilterConditionActionConditionArgs']]):
        pulumi.set(self, "action_condition", value)

    @property
    @pulumi.getter(name="labelNameCondition")
    def label_name_condition(self) -> Optional[pulumi.Input['WebAclLoggingConfigurationLoggingFilterFilterConditionLabelNameConditionArgs']]:
        """
        Condition for a single label name. See Label Name Condition below for more details.
        """
        return pulumi.get(self, "label_name_condition")

    @label_name_condition.setter
    def label_name_condition(self, value: Optional[pulumi.Input['WebAclLoggingConfigurationLoggingFilterFilterConditionLabelNameConditionArgs']]):
        pulumi.set(self, "label_name_condition", value)


@pulumi.input_type
class WebAclLoggingConfigurationLoggingFilterFilterConditionActionConditionArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str]):
        """
        :param pulumi.Input[str] action: Action setting that a log record must contain in order to meet the condition. Valid values for `action` are `ALLOW`, `BLOCK`, and `COUNT`.
        """
        pulumi.set(__self__, "action", action)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        Action setting that a log record must contain in order to meet the condition. Valid values for `action` are `ALLOW`, `BLOCK`, and `COUNT`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)


@pulumi.input_type
class WebAclLoggingConfigurationLoggingFilterFilterConditionLabelNameConditionArgs:
    def __init__(__self__, *,
                 label_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] label_name: Name of the label that a log record must contain in order to meet the condition. It must be a fully qualified label name, which includes a prefix, optional namespaces, and the label name itself. The prefix identifies the rule group or web ACL context of the rule that added the label.
        """
        pulumi.set(__self__, "label_name", label_name)

    @property
    @pulumi.getter(name="labelName")
    def label_name(self) -> pulumi.Input[str]:
        """
        Name of the label that a log record must contain in order to meet the condition. It must be a fully qualified label name, which includes a prefix, optional namespaces, and the label name itself. The prefix identifies the rule group or web ACL context of the rule that added the label.
        """
        return pulumi.get(self, "label_name")

    @label_name.setter
    def label_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "label_name", value)


@pulumi.input_type
class WebAclLoggingConfigurationRedactedFieldArgs:
    def __init__(__self__, *,
                 method: Optional[pulumi.Input['WebAclLoggingConfigurationRedactedFieldMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['WebAclLoggingConfigurationRedactedFieldQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['WebAclLoggingConfigurationRedactedFieldSingleHeaderArgs']] = None,
                 uri_path: Optional[pulumi.Input['WebAclLoggingConfigurationRedactedFieldUriPathArgs']] = None):
        """
        :param pulumi.Input['WebAclLoggingConfigurationRedactedFieldMethodArgs'] method: HTTP method to be redacted. It must be specified as an empty configuration block `{}`. The method indicates the type of operation that the request is asking the origin to perform.
        :param pulumi.Input['WebAclLoggingConfigurationRedactedFieldQueryStringArgs'] query_string: Whether to redact the query string. It must be specified as an empty configuration block `{}`. The query string is the part of a URL that appears after a `?` character, if any.
        :param pulumi.Input['WebAclLoggingConfigurationRedactedFieldSingleHeaderArgs'] single_header: "single_header" refers to the redaction of a single header. For more information, please see the details below under Single Header.
        :param pulumi.Input['WebAclLoggingConfigurationRedactedFieldUriPathArgs'] uri_path: Configuration block that redacts the request URI path. It should be specified as an empty configuration block `{}`. The URI path is the part of a web request that identifies a resource, such as `/images/daily-ad.jpg`.
        """
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['WebAclLoggingConfigurationRedactedFieldMethodArgs']]:
        """
        HTTP method to be redacted. It must be specified as an empty configuration block `{}`. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['WebAclLoggingConfigurationRedactedFieldMethodArgs']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['WebAclLoggingConfigurationRedactedFieldQueryStringArgs']]:
        """
        Whether to redact the query string. It must be specified as an empty configuration block `{}`. The query string is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['WebAclLoggingConfigurationRedactedFieldQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['WebAclLoggingConfigurationRedactedFieldSingleHeaderArgs']]:
        """
        "single_header" refers to the redaction of a single header. For more information, please see the details below under Single Header.
        """
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['WebAclLoggingConfigurationRedactedFieldSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['WebAclLoggingConfigurationRedactedFieldUriPathArgs']]:
        """
        Configuration block that redacts the request URI path. It should be specified as an empty configuration block `{}`. The URI path is the part of a web request that identifies a resource, such as `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['WebAclLoggingConfigurationRedactedFieldUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


@pulumi.input_type
class WebAclLoggingConfigurationRedactedFieldMethodArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclLoggingConfigurationRedactedFieldQueryStringArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclLoggingConfigurationRedactedFieldSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to redact. This setting must be provided in lowercase characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to redact. This setting must be provided in lowercase characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class WebAclLoggingConfigurationRedactedFieldUriPathArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 priority: pulumi.Input[int],
                 statement: pulumi.Input['WebAclRuleStatementArgs'],
                 visibility_config: pulumi.Input['WebAclRuleVisibilityConfigArgs'],
                 action: Optional[pulumi.Input['WebAclRuleActionArgs']] = None,
                 captcha_config: Optional[pulumi.Input['WebAclRuleCaptchaConfigArgs']] = None,
                 override_action: Optional[pulumi.Input['WebAclRuleOverrideActionArgs']] = None,
                 rule_labels: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleRuleLabelArgs']]]] = None):
        """
        :param pulumi.Input[str] name: Friendly name of the rule. Note that the provider assumes that rules with names matching this pattern, `^ShieldMitigationRuleGroup_<account-id>_<web-acl-guid>_.*`, are AWS-added for [automatic application layer DDoS mitigation activities](https://docs.aws.amazon.com/waf/latest/developerguide/ddos-automatic-app-layer-response-rg.html). Such rules will be ignored by the provider unless you explicitly include them in your configuration (for example, by using the AWS CLI to discover their properties and creating matching configuration). However, since these rules are owned and managed by AWS, you may get permission errors.
        :param pulumi.Input[int] priority: If you define more than one Rule in a WebACL, AWS WAF evaluates each request against the `rules` in order based on the value of `priority`. AWS WAF processes rules with lower priority first.
        :param pulumi.Input['WebAclRuleStatementArgs'] statement: The AWS WAF processing statement for the rule, for example `byte_match_statement` or `geo_match_statement`. See `statement` below for details.
        :param pulumi.Input['WebAclRuleVisibilityConfigArgs'] visibility_config: Defines and enables Amazon CloudWatch metrics and web request sample collection. See `visibility_config` below for details.
        :param pulumi.Input['WebAclRuleActionArgs'] action: Action that AWS WAF should take on a web request when it matches the rule's statement. This is used only for rules whose **statements do not reference a rule group**. See `action` for details.
        :param pulumi.Input['WebAclRuleCaptchaConfigArgs'] captcha_config: Specifies how AWS WAF should handle CAPTCHA evaluations. See `captcha_config` below for details.
        :param pulumi.Input['WebAclRuleOverrideActionArgs'] override_action: Override action to apply to the rules in a rule group. Used only for rule **statements that reference a rule group**, like `rule_group_reference_statement` and `managed_rule_group_statement`. See `override_action` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleRuleLabelArgs']]] rule_labels: Labels to apply to web requests that match the rule match statement. See `rule_label` below for details.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "statement", statement)
        pulumi.set(__self__, "visibility_config", visibility_config)
        if action is not None:
            pulumi.set(__self__, "action", action)
        if captcha_config is not None:
            pulumi.set(__self__, "captcha_config", captcha_config)
        if override_action is not None:
            pulumi.set(__self__, "override_action", override_action)
        if rule_labels is not None:
            pulumi.set(__self__, "rule_labels", rule_labels)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Friendly name of the rule. Note that the provider assumes that rules with names matching this pattern, `^ShieldMitigationRuleGroup_<account-id>_<web-acl-guid>_.*`, are AWS-added for [automatic application layer DDoS mitigation activities](https://docs.aws.amazon.com/waf/latest/developerguide/ddos-automatic-app-layer-response-rg.html). Such rules will be ignored by the provider unless you explicitly include them in your configuration (for example, by using the AWS CLI to discover their properties and creating matching configuration). However, since these rules are owned and managed by AWS, you may get permission errors.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        If you define more than one Rule in a WebACL, AWS WAF evaluates each request against the `rules` in order based on the value of `priority`. AWS WAF processes rules with lower priority first.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def statement(self) -> pulumi.Input['WebAclRuleStatementArgs']:
        """
        The AWS WAF processing statement for the rule, for example `byte_match_statement` or `geo_match_statement`. See `statement` below for details.
        """
        return pulumi.get(self, "statement")

    @statement.setter
    def statement(self, value: pulumi.Input['WebAclRuleStatementArgs']):
        pulumi.set(self, "statement", value)

    @property
    @pulumi.getter(name="visibilityConfig")
    def visibility_config(self) -> pulumi.Input['WebAclRuleVisibilityConfigArgs']:
        """
        Defines and enables Amazon CloudWatch metrics and web request sample collection. See `visibility_config` below for details.
        """
        return pulumi.get(self, "visibility_config")

    @visibility_config.setter
    def visibility_config(self, value: pulumi.Input['WebAclRuleVisibilityConfigArgs']):
        pulumi.set(self, "visibility_config", value)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input['WebAclRuleActionArgs']]:
        """
        Action that AWS WAF should take on a web request when it matches the rule's statement. This is used only for rules whose **statements do not reference a rule group**. See `action` for details.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input['WebAclRuleActionArgs']]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter(name="captchaConfig")
    def captcha_config(self) -> Optional[pulumi.Input['WebAclRuleCaptchaConfigArgs']]:
        """
        Specifies how AWS WAF should handle CAPTCHA evaluations. See `captcha_config` below for details.
        """
        return pulumi.get(self, "captcha_config")

    @captcha_config.setter
    def captcha_config(self, value: Optional[pulumi.Input['WebAclRuleCaptchaConfigArgs']]):
        pulumi.set(self, "captcha_config", value)

    @property
    @pulumi.getter(name="overrideAction")
    def override_action(self) -> Optional[pulumi.Input['WebAclRuleOverrideActionArgs']]:
        """
        Override action to apply to the rules in a rule group. Used only for rule **statements that reference a rule group**, like `rule_group_reference_statement` and `managed_rule_group_statement`. See `override_action` below for details.
        """
        return pulumi.get(self, "override_action")

    @override_action.setter
    def override_action(self, value: Optional[pulumi.Input['WebAclRuleOverrideActionArgs']]):
        pulumi.set(self, "override_action", value)

    @property
    @pulumi.getter(name="ruleLabels")
    def rule_labels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleRuleLabelArgs']]]]:
        """
        Labels to apply to web requests that match the rule match statement. See `rule_label` below for details.
        """
        return pulumi.get(self, "rule_labels")

    @rule_labels.setter
    def rule_labels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleRuleLabelArgs']]]]):
        pulumi.set(self, "rule_labels", value)


@pulumi.input_type
class WebAclRuleActionArgs:
    def __init__(__self__, *,
                 allow: Optional[pulumi.Input['WebAclRuleActionAllowArgs']] = None,
                 block: Optional[pulumi.Input['WebAclRuleActionBlockArgs']] = None,
                 captcha: Optional[pulumi.Input['WebAclRuleActionCaptchaArgs']] = None,
                 challenge: Optional[pulumi.Input['WebAclRuleActionChallengeArgs']] = None,
                 count: Optional[pulumi.Input['WebAclRuleActionCountArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleActionAllowArgs'] allow: Instructs AWS WAF to allow the web request. See `allow` below for details.
        :param pulumi.Input['WebAclRuleActionBlockArgs'] block: Instructs AWS WAF to block the web request. See `block` below for details.
        :param pulumi.Input['WebAclRuleActionCaptchaArgs'] captcha: Instructs AWS WAF to run a Captcha check against the web request. See `captcha` below for details.
        :param pulumi.Input['WebAclRuleActionChallengeArgs'] challenge: Instructs AWS WAF to run a check against the request to verify that the request is coming from a legitimate client session. See `challenge` below for details.
        :param pulumi.Input['WebAclRuleActionCountArgs'] count: Instructs AWS WAF to count the web request and allow it. See `count` below for details.
        """
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if block is not None:
            pulumi.set(__self__, "block", block)
        if captcha is not None:
            pulumi.set(__self__, "captcha", captcha)
        if challenge is not None:
            pulumi.set(__self__, "challenge", challenge)
        if count is not None:
            pulumi.set(__self__, "count", count)

    @property
    @pulumi.getter
    def allow(self) -> Optional[pulumi.Input['WebAclRuleActionAllowArgs']]:
        """
        Instructs AWS WAF to allow the web request. See `allow` below for details.
        """
        return pulumi.get(self, "allow")

    @allow.setter
    def allow(self, value: Optional[pulumi.Input['WebAclRuleActionAllowArgs']]):
        pulumi.set(self, "allow", value)

    @property
    @pulumi.getter
    def block(self) -> Optional[pulumi.Input['WebAclRuleActionBlockArgs']]:
        """
        Instructs AWS WAF to block the web request. See `block` below for details.
        """
        return pulumi.get(self, "block")

    @block.setter
    def block(self, value: Optional[pulumi.Input['WebAclRuleActionBlockArgs']]):
        pulumi.set(self, "block", value)

    @property
    @pulumi.getter
    def captcha(self) -> Optional[pulumi.Input['WebAclRuleActionCaptchaArgs']]:
        """
        Instructs AWS WAF to run a Captcha check against the web request. See `captcha` below for details.
        """
        return pulumi.get(self, "captcha")

    @captcha.setter
    def captcha(self, value: Optional[pulumi.Input['WebAclRuleActionCaptchaArgs']]):
        pulumi.set(self, "captcha", value)

    @property
    @pulumi.getter
    def challenge(self) -> Optional[pulumi.Input['WebAclRuleActionChallengeArgs']]:
        """
        Instructs AWS WAF to run a check against the request to verify that the request is coming from a legitimate client session. See `challenge` below for details.
        """
        return pulumi.get(self, "challenge")

    @challenge.setter
    def challenge(self, value: Optional[pulumi.Input['WebAclRuleActionChallengeArgs']]):
        pulumi.set(self, "challenge", value)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input['WebAclRuleActionCountArgs']]:
        """
        Instructs AWS WAF to count the web request and allow it. See `count` below for details.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input['WebAclRuleActionCountArgs']]):
        pulumi.set(self, "count", value)


@pulumi.input_type
class WebAclRuleActionAllowArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['WebAclRuleActionAllowCustomRequestHandlingArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleActionAllowCustomRequestHandlingArgs'] custom_request_handling: Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['WebAclRuleActionAllowCustomRequestHandlingArgs']]:
        """
        Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['WebAclRuleActionAllowCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


@pulumi.input_type
class WebAclRuleActionAllowCustomRequestHandlingArgs:
    def __init__(__self__, *,
                 insert_headers: pulumi.Input[Sequence[pulumi.Input['WebAclRuleActionAllowCustomRequestHandlingInsertHeaderArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleActionAllowCustomRequestHandlingInsertHeaderArgs']]] insert_headers: The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        pulumi.set(__self__, "insert_headers", insert_headers)

    @property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleActionAllowCustomRequestHandlingInsertHeaderArgs']]]:
        """
        The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        return pulumi.get(self, "insert_headers")

    @insert_headers.setter
    def insert_headers(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleActionAllowCustomRequestHandlingInsertHeaderArgs']]]):
        pulumi.set(self, "insert_headers", value)


@pulumi.input_type
class WebAclRuleActionAllowCustomRequestHandlingInsertHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        :param pulumi.Input[str] value: Value of the custom header.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value of the custom header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class WebAclRuleActionBlockArgs:
    def __init__(__self__, *,
                 custom_response: Optional[pulumi.Input['WebAclRuleActionBlockCustomResponseArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleActionBlockCustomResponseArgs'] custom_response: Defines a custom response for the web request. See `custom_response` below for details.
        """
        if custom_response is not None:
            pulumi.set(__self__, "custom_response", custom_response)

    @property
    @pulumi.getter(name="customResponse")
    def custom_response(self) -> Optional[pulumi.Input['WebAclRuleActionBlockCustomResponseArgs']]:
        """
        Defines a custom response for the web request. See `custom_response` below for details.
        """
        return pulumi.get(self, "custom_response")

    @custom_response.setter
    def custom_response(self, value: Optional[pulumi.Input['WebAclRuleActionBlockCustomResponseArgs']]):
        pulumi.set(self, "custom_response", value)


@pulumi.input_type
class WebAclRuleActionBlockCustomResponseArgs:
    def __init__(__self__, *,
                 response_code: pulumi.Input[int],
                 custom_response_body_key: Optional[pulumi.Input[str]] = None,
                 response_headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleActionBlockCustomResponseResponseHeaderArgs']]]] = None):
        """
        :param pulumi.Input[int] response_code: The HTTP status code to return to the client.
        :param pulumi.Input[str] custom_response_body_key: References the response body that you want AWS WAF to return to the web request client. This must reference a `key` defined in a `custom_response_body` block of this resource.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleActionBlockCustomResponseResponseHeaderArgs']]] response_headers: The `response_header` blocks used to define the HTTP response headers added to the response. See `response_header` below for details.
        """
        pulumi.set(__self__, "response_code", response_code)
        if custom_response_body_key is not None:
            pulumi.set(__self__, "custom_response_body_key", custom_response_body_key)
        if response_headers is not None:
            pulumi.set(__self__, "response_headers", response_headers)

    @property
    @pulumi.getter(name="responseCode")
    def response_code(self) -> pulumi.Input[int]:
        """
        The HTTP status code to return to the client.
        """
        return pulumi.get(self, "response_code")

    @response_code.setter
    def response_code(self, value: pulumi.Input[int]):
        pulumi.set(self, "response_code", value)

    @property
    @pulumi.getter(name="customResponseBodyKey")
    def custom_response_body_key(self) -> Optional[pulumi.Input[str]]:
        """
        References the response body that you want AWS WAF to return to the web request client. This must reference a `key` defined in a `custom_response_body` block of this resource.
        """
        return pulumi.get(self, "custom_response_body_key")

    @custom_response_body_key.setter
    def custom_response_body_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_response_body_key", value)

    @property
    @pulumi.getter(name="responseHeaders")
    def response_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleActionBlockCustomResponseResponseHeaderArgs']]]]:
        """
        The `response_header` blocks used to define the HTTP response headers added to the response. See `response_header` below for details.
        """
        return pulumi.get(self, "response_headers")

    @response_headers.setter
    def response_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleActionBlockCustomResponseResponseHeaderArgs']]]]):
        pulumi.set(self, "response_headers", value)


@pulumi.input_type
class WebAclRuleActionBlockCustomResponseResponseHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        :param pulumi.Input[str] value: Value of the custom header.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value of the custom header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class WebAclRuleActionCaptchaArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['WebAclRuleActionCaptchaCustomRequestHandlingArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleActionCaptchaCustomRequestHandlingArgs'] custom_request_handling: Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['WebAclRuleActionCaptchaCustomRequestHandlingArgs']]:
        """
        Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['WebAclRuleActionCaptchaCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


@pulumi.input_type
class WebAclRuleActionCaptchaCustomRequestHandlingArgs:
    def __init__(__self__, *,
                 insert_headers: pulumi.Input[Sequence[pulumi.Input['WebAclRuleActionCaptchaCustomRequestHandlingInsertHeaderArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleActionCaptchaCustomRequestHandlingInsertHeaderArgs']]] insert_headers: The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        pulumi.set(__self__, "insert_headers", insert_headers)

    @property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleActionCaptchaCustomRequestHandlingInsertHeaderArgs']]]:
        """
        The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        return pulumi.get(self, "insert_headers")

    @insert_headers.setter
    def insert_headers(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleActionCaptchaCustomRequestHandlingInsertHeaderArgs']]]):
        pulumi.set(self, "insert_headers", value)


@pulumi.input_type
class WebAclRuleActionCaptchaCustomRequestHandlingInsertHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        :param pulumi.Input[str] value: Value of the custom header.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value of the custom header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class WebAclRuleActionChallengeArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['WebAclRuleActionChallengeCustomRequestHandlingArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleActionChallengeCustomRequestHandlingArgs'] custom_request_handling: Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['WebAclRuleActionChallengeCustomRequestHandlingArgs']]:
        """
        Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['WebAclRuleActionChallengeCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


@pulumi.input_type
class WebAclRuleActionChallengeCustomRequestHandlingArgs:
    def __init__(__self__, *,
                 insert_headers: pulumi.Input[Sequence[pulumi.Input['WebAclRuleActionChallengeCustomRequestHandlingInsertHeaderArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleActionChallengeCustomRequestHandlingInsertHeaderArgs']]] insert_headers: The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        pulumi.set(__self__, "insert_headers", insert_headers)

    @property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleActionChallengeCustomRequestHandlingInsertHeaderArgs']]]:
        """
        The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        return pulumi.get(self, "insert_headers")

    @insert_headers.setter
    def insert_headers(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleActionChallengeCustomRequestHandlingInsertHeaderArgs']]]):
        pulumi.set(self, "insert_headers", value)


@pulumi.input_type
class WebAclRuleActionChallengeCustomRequestHandlingInsertHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        :param pulumi.Input[str] value: Value of the custom header.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value of the custom header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class WebAclRuleActionCountArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['WebAclRuleActionCountCustomRequestHandlingArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleActionCountCustomRequestHandlingArgs'] custom_request_handling: Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['WebAclRuleActionCountCustomRequestHandlingArgs']]:
        """
        Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['WebAclRuleActionCountCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


@pulumi.input_type
class WebAclRuleActionCountCustomRequestHandlingArgs:
    def __init__(__self__, *,
                 insert_headers: pulumi.Input[Sequence[pulumi.Input['WebAclRuleActionCountCustomRequestHandlingInsertHeaderArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleActionCountCustomRequestHandlingInsertHeaderArgs']]] insert_headers: The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        pulumi.set(__self__, "insert_headers", insert_headers)

    @property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleActionCountCustomRequestHandlingInsertHeaderArgs']]]:
        """
        The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        return pulumi.get(self, "insert_headers")

    @insert_headers.setter
    def insert_headers(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleActionCountCustomRequestHandlingInsertHeaderArgs']]]):
        pulumi.set(self, "insert_headers", value)


@pulumi.input_type
class WebAclRuleActionCountCustomRequestHandlingInsertHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        :param pulumi.Input[str] value: Value of the custom header.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value of the custom header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class WebAclRuleCaptchaConfigArgs:
    def __init__(__self__, *,
                 immunity_time_property: Optional[pulumi.Input['WebAclRuleCaptchaConfigImmunityTimePropertyArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleCaptchaConfigImmunityTimePropertyArgs'] immunity_time_property: Defines custom immunity time. See `immunity_time_property` below for details.
        """
        if immunity_time_property is not None:
            pulumi.set(__self__, "immunity_time_property", immunity_time_property)

    @property
    @pulumi.getter(name="immunityTimeProperty")
    def immunity_time_property(self) -> Optional[pulumi.Input['WebAclRuleCaptchaConfigImmunityTimePropertyArgs']]:
        """
        Defines custom immunity time. See `immunity_time_property` below for details.
        """
        return pulumi.get(self, "immunity_time_property")

    @immunity_time_property.setter
    def immunity_time_property(self, value: Optional[pulumi.Input['WebAclRuleCaptchaConfigImmunityTimePropertyArgs']]):
        pulumi.set(self, "immunity_time_property", value)


@pulumi.input_type
class WebAclRuleCaptchaConfigImmunityTimePropertyArgs:
    def __init__(__self__, *,
                 immunity_time: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] immunity_time: The amount of time, in seconds, that a CAPTCHA or challenge timestamp is considered valid by AWS WAF. The default setting is 300.
        """
        if immunity_time is not None:
            pulumi.set(__self__, "immunity_time", immunity_time)

    @property
    @pulumi.getter(name="immunityTime")
    def immunity_time(self) -> Optional[pulumi.Input[int]]:
        """
        The amount of time, in seconds, that a CAPTCHA or challenge timestamp is considered valid by AWS WAF. The default setting is 300.
        """
        return pulumi.get(self, "immunity_time")

    @immunity_time.setter
    def immunity_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "immunity_time", value)


@pulumi.input_type
class WebAclRuleOverrideActionArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input['WebAclRuleOverrideActionCountArgs']] = None,
                 none: Optional[pulumi.Input['WebAclRuleOverrideActionNoneArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleOverrideActionCountArgs'] count: Override the rule action setting to count (i.e., only count matches). Configured as an empty block `{}`.
        :param pulumi.Input['WebAclRuleOverrideActionNoneArgs'] none: Don't override the rule action setting. Configured as an empty block `{}`.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if none is not None:
            pulumi.set(__self__, "none", none)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input['WebAclRuleOverrideActionCountArgs']]:
        """
        Override the rule action setting to count (i.e., only count matches). Configured as an empty block `{}`.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input['WebAclRuleOverrideActionCountArgs']]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def none(self) -> Optional[pulumi.Input['WebAclRuleOverrideActionNoneArgs']]:
        """
        Don't override the rule action setting. Configured as an empty block `{}`.
        """
        return pulumi.get(self, "none")

    @none.setter
    def none(self, value: Optional[pulumi.Input['WebAclRuleOverrideActionNoneArgs']]):
        pulumi.set(self, "none", value)


@pulumi.input_type
class WebAclRuleOverrideActionCountArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleOverrideActionNoneArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleRuleLabelArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Label string.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Label string.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class WebAclRuleStatementArgs:
    def __init__(__self__, *,
                 and_statement: Optional[pulumi.Input['WebAclRuleStatementAndStatementArgs']] = None,
                 byte_match_statement: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementArgs']] = None,
                 geo_match_statement: Optional[pulumi.Input['WebAclRuleStatementGeoMatchStatementArgs']] = None,
                 ip_set_reference_statement: Optional[pulumi.Input['WebAclRuleStatementIpSetReferenceStatementArgs']] = None,
                 label_match_statement: Optional[pulumi.Input['WebAclRuleStatementLabelMatchStatementArgs']] = None,
                 managed_rule_group_statement: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementArgs']] = None,
                 not_statement: Optional[pulumi.Input['WebAclRuleStatementNotStatementArgs']] = None,
                 or_statement: Optional[pulumi.Input['WebAclRuleStatementOrStatementArgs']] = None,
                 rate_based_statement: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementArgs']] = None,
                 regex_match_statement: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementArgs']] = None,
                 regex_pattern_set_reference_statement: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementArgs']] = None,
                 rule_group_reference_statement: Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementArgs']] = None,
                 size_constraint_statement: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementArgs']] = None,
                 sqli_match_statement: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementArgs']] = None,
                 xss_match_statement: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementAndStatementArgs'] and_statement: Logical rule statement used to combine other rule statements with AND logic. See `and_statement` below for details.
        :param pulumi.Input['WebAclRuleStatementByteMatchStatementArgs'] byte_match_statement: Rule statement that defines a string match search for AWS WAF to apply to web requests. See `byte_match_statement` below for details.
        :param pulumi.Input['WebAclRuleStatementGeoMatchStatementArgs'] geo_match_statement: Rule statement used to identify web requests based on country of origin. See `geo_match_statement` below for details.
        :param pulumi.Input['WebAclRuleStatementIpSetReferenceStatementArgs'] ip_set_reference_statement: Rule statement used to detect web requests coming from particular IP addresses or address ranges. See `ip_set_reference_statement` below for details.
        :param pulumi.Input['WebAclRuleStatementLabelMatchStatementArgs'] label_match_statement: Rule statement that defines a string match search against labels that have been added to the web request by rules that have already run in the web ACL. See `label_match_statement` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementArgs'] managed_rule_group_statement: Rule statement used to run the rules that are defined in a managed rule group.  This statement can not be nested. See `managed_rule_group_statement` below for details.
        :param pulumi.Input['WebAclRuleStatementNotStatementArgs'] not_statement: Logical rule statement used to negate the results of another rule statement. See `not_statement` below for details.
        :param pulumi.Input['WebAclRuleStatementOrStatementArgs'] or_statement: Logical rule statement used to combine other rule statements with OR logic. See `or_statement` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementArgs'] rate_based_statement: Rate-based rule tracks the rate of requests for each originating `IP address`, and triggers the rule action when the rate exceeds a limit that you specify on the number of requests in any `5-minute` time span. This statement can not be nested. See `rate_based_statement` below for details.
        :param pulumi.Input['WebAclRuleStatementRegexMatchStatementArgs'] regex_match_statement: Rule statement used to search web request components for a match against a single regular expression. See `regex_match_statement` below for details.
        :param pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementArgs'] regex_pattern_set_reference_statement: Rule statement used to search web request components for matches with regular expressions. See `regex_pattern_set_reference_statement` below for details.
        :param pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementArgs'] rule_group_reference_statement: Rule statement used to run the rules that are defined in an WAFv2 Rule Group. See `rule_group_reference_statement` below for details.
        :param pulumi.Input['WebAclRuleStatementSizeConstraintStatementArgs'] size_constraint_statement: Rule statement that compares a number of bytes against the size of a request component, using a comparison operator, such as greater than (>) or less than (<). See `size_constraint_statement` below for more details.
        :param pulumi.Input['WebAclRuleStatementSqliMatchStatementArgs'] sqli_match_statement: An SQL injection match condition identifies the part of web requests, such as the URI or the query string, that you want AWS WAF to inspect. See `sqli_match_statement` below for details.
        :param pulumi.Input['WebAclRuleStatementXssMatchStatementArgs'] xss_match_statement: Rule statement that defines a cross-site scripting (XSS) match search for AWS WAF to apply to web requests. See `xss_match_statement` below for details.
        """
        if and_statement is not None:
            pulumi.set(__self__, "and_statement", and_statement)
        if byte_match_statement is not None:
            pulumi.set(__self__, "byte_match_statement", byte_match_statement)
        if geo_match_statement is not None:
            pulumi.set(__self__, "geo_match_statement", geo_match_statement)
        if ip_set_reference_statement is not None:
            pulumi.set(__self__, "ip_set_reference_statement", ip_set_reference_statement)
        if label_match_statement is not None:
            pulumi.set(__self__, "label_match_statement", label_match_statement)
        if managed_rule_group_statement is not None:
            pulumi.set(__self__, "managed_rule_group_statement", managed_rule_group_statement)
        if not_statement is not None:
            pulumi.set(__self__, "not_statement", not_statement)
        if or_statement is not None:
            pulumi.set(__self__, "or_statement", or_statement)
        if rate_based_statement is not None:
            pulumi.set(__self__, "rate_based_statement", rate_based_statement)
        if regex_match_statement is not None:
            pulumi.set(__self__, "regex_match_statement", regex_match_statement)
        if regex_pattern_set_reference_statement is not None:
            pulumi.set(__self__, "regex_pattern_set_reference_statement", regex_pattern_set_reference_statement)
        if rule_group_reference_statement is not None:
            pulumi.set(__self__, "rule_group_reference_statement", rule_group_reference_statement)
        if size_constraint_statement is not None:
            pulumi.set(__self__, "size_constraint_statement", size_constraint_statement)
        if sqli_match_statement is not None:
            pulumi.set(__self__, "sqli_match_statement", sqli_match_statement)
        if xss_match_statement is not None:
            pulumi.set(__self__, "xss_match_statement", xss_match_statement)

    @property
    @pulumi.getter(name="andStatement")
    def and_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementAndStatementArgs']]:
        """
        Logical rule statement used to combine other rule statements with AND logic. See `and_statement` below for details.
        """
        return pulumi.get(self, "and_statement")

    @and_statement.setter
    def and_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementAndStatementArgs']]):
        pulumi.set(self, "and_statement", value)

    @property
    @pulumi.getter(name="byteMatchStatement")
    def byte_match_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementArgs']]:
        """
        Rule statement that defines a string match search for AWS WAF to apply to web requests. See `byte_match_statement` below for details.
        """
        return pulumi.get(self, "byte_match_statement")

    @byte_match_statement.setter
    def byte_match_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementArgs']]):
        pulumi.set(self, "byte_match_statement", value)

    @property
    @pulumi.getter(name="geoMatchStatement")
    def geo_match_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementGeoMatchStatementArgs']]:
        """
        Rule statement used to identify web requests based on country of origin. See `geo_match_statement` below for details.
        """
        return pulumi.get(self, "geo_match_statement")

    @geo_match_statement.setter
    def geo_match_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementGeoMatchStatementArgs']]):
        pulumi.set(self, "geo_match_statement", value)

    @property
    @pulumi.getter(name="ipSetReferenceStatement")
    def ip_set_reference_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementIpSetReferenceStatementArgs']]:
        """
        Rule statement used to detect web requests coming from particular IP addresses or address ranges. See `ip_set_reference_statement` below for details.
        """
        return pulumi.get(self, "ip_set_reference_statement")

    @ip_set_reference_statement.setter
    def ip_set_reference_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementIpSetReferenceStatementArgs']]):
        pulumi.set(self, "ip_set_reference_statement", value)

    @property
    @pulumi.getter(name="labelMatchStatement")
    def label_match_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementLabelMatchStatementArgs']]:
        """
        Rule statement that defines a string match search against labels that have been added to the web request by rules that have already run in the web ACL. See `label_match_statement` below for details.
        """
        return pulumi.get(self, "label_match_statement")

    @label_match_statement.setter
    def label_match_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementLabelMatchStatementArgs']]):
        pulumi.set(self, "label_match_statement", value)

    @property
    @pulumi.getter(name="managedRuleGroupStatement")
    def managed_rule_group_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementArgs']]:
        """
        Rule statement used to run the rules that are defined in a managed rule group.  This statement can not be nested. See `managed_rule_group_statement` below for details.
        """
        return pulumi.get(self, "managed_rule_group_statement")

    @managed_rule_group_statement.setter
    def managed_rule_group_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementArgs']]):
        pulumi.set(self, "managed_rule_group_statement", value)

    @property
    @pulumi.getter(name="notStatement")
    def not_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementNotStatementArgs']]:
        """
        Logical rule statement used to negate the results of another rule statement. See `not_statement` below for details.
        """
        return pulumi.get(self, "not_statement")

    @not_statement.setter
    def not_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementNotStatementArgs']]):
        pulumi.set(self, "not_statement", value)

    @property
    @pulumi.getter(name="orStatement")
    def or_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementOrStatementArgs']]:
        """
        Logical rule statement used to combine other rule statements with OR logic. See `or_statement` below for details.
        """
        return pulumi.get(self, "or_statement")

    @or_statement.setter
    def or_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementOrStatementArgs']]):
        pulumi.set(self, "or_statement", value)

    @property
    @pulumi.getter(name="rateBasedStatement")
    def rate_based_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementArgs']]:
        """
        Rate-based rule tracks the rate of requests for each originating `IP address`, and triggers the rule action when the rate exceeds a limit that you specify on the number of requests in any `5-minute` time span. This statement can not be nested. See `rate_based_statement` below for details.
        """
        return pulumi.get(self, "rate_based_statement")

    @rate_based_statement.setter
    def rate_based_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementArgs']]):
        pulumi.set(self, "rate_based_statement", value)

    @property
    @pulumi.getter(name="regexMatchStatement")
    def regex_match_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementArgs']]:
        """
        Rule statement used to search web request components for a match against a single regular expression. See `regex_match_statement` below for details.
        """
        return pulumi.get(self, "regex_match_statement")

    @regex_match_statement.setter
    def regex_match_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementArgs']]):
        pulumi.set(self, "regex_match_statement", value)

    @property
    @pulumi.getter(name="regexPatternSetReferenceStatement")
    def regex_pattern_set_reference_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementArgs']]:
        """
        Rule statement used to search web request components for matches with regular expressions. See `regex_pattern_set_reference_statement` below for details.
        """
        return pulumi.get(self, "regex_pattern_set_reference_statement")

    @regex_pattern_set_reference_statement.setter
    def regex_pattern_set_reference_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementArgs']]):
        pulumi.set(self, "regex_pattern_set_reference_statement", value)

    @property
    @pulumi.getter(name="ruleGroupReferenceStatement")
    def rule_group_reference_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementArgs']]:
        """
        Rule statement used to run the rules that are defined in an WAFv2 Rule Group. See `rule_group_reference_statement` below for details.
        """
        return pulumi.get(self, "rule_group_reference_statement")

    @rule_group_reference_statement.setter
    def rule_group_reference_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementArgs']]):
        pulumi.set(self, "rule_group_reference_statement", value)

    @property
    @pulumi.getter(name="sizeConstraintStatement")
    def size_constraint_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementArgs']]:
        """
        Rule statement that compares a number of bytes against the size of a request component, using a comparison operator, such as greater than (>) or less than (<). See `size_constraint_statement` below for more details.
        """
        return pulumi.get(self, "size_constraint_statement")

    @size_constraint_statement.setter
    def size_constraint_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementArgs']]):
        pulumi.set(self, "size_constraint_statement", value)

    @property
    @pulumi.getter(name="sqliMatchStatement")
    def sqli_match_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementArgs']]:
        """
        An SQL injection match condition identifies the part of web requests, such as the URI or the query string, that you want AWS WAF to inspect. See `sqli_match_statement` below for details.
        """
        return pulumi.get(self, "sqli_match_statement")

    @sqli_match_statement.setter
    def sqli_match_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementArgs']]):
        pulumi.set(self, "sqli_match_statement", value)

    @property
    @pulumi.getter(name="xssMatchStatement")
    def xss_match_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementArgs']]:
        """
        Rule statement that defines a cross-site scripting (XSS) match search for AWS WAF to apply to web requests. See `xss_match_statement` below for details.
        """
        return pulumi.get(self, "xss_match_statement")

    @xss_match_statement.setter
    def xss_match_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementArgs']]):
        pulumi.set(self, "xss_match_statement", value)


@pulumi.input_type
class WebAclRuleStatementAndStatementArgs:
    def __init__(__self__, *,
                 statements: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]] statements: The statements to combine.
        """
        pulumi.set(__self__, "statements", statements)

    @property
    @pulumi.getter
    def statements(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")

    @statements.setter
    def statements(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]):
        pulumi.set(self, "statements", value)


@pulumi.input_type
class WebAclRuleStatementByteMatchStatementArgs:
    def __init__(__self__, *,
                 positional_constraint: pulumi.Input[str],
                 search_string: pulumi.Input[str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementByteMatchStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchArgs']] = None):
        """
        :param pulumi.Input[str] positional_constraint: Area within the portion of a web request that you want AWS WAF to search for `search_string`. Valid values include the following: `EXACTLY`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CONTAINS_WORD`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_ByteMatchStatement.html) for more information.
        :param pulumi.Input[str] search_string: String value that you want AWS WAF to search for. AWS WAF searches only in the part of web requests that you designate for inspection in `field_to_match`. The maximum length of the value is 50 bytes.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementByteMatchStatementTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        :param pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchArgs'] field_to_match: Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        pulumi.set(__self__, "positional_constraint", positional_constraint)
        pulumi.set(__self__, "search_string", search_string)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @property
    @pulumi.getter(name="positionalConstraint")
    def positional_constraint(self) -> pulumi.Input[str]:
        """
        Area within the portion of a web request that you want AWS WAF to search for `search_string`. Valid values include the following: `EXACTLY`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CONTAINS_WORD`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_ByteMatchStatement.html) for more information.
        """
        return pulumi.get(self, "positional_constraint")

    @positional_constraint.setter
    def positional_constraint(self, value: pulumi.Input[str]):
        pulumi.set(self, "positional_constraint", value)

    @property
    @pulumi.getter(name="searchString")
    def search_string(self) -> pulumi.Input[str]:
        """
        String value that you want AWS WAF to search for. AWS WAF searches only in the part of web requests that you designate for inspection in `field_to_match`. The maximum length of the value is 50 bytes.
        """
        return pulumi.get(self, "search_string")

    @search_string.setter
    def search_string(self, value: pulumi.Input[str]):
        pulumi.set(self, "search_string", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementByteMatchStatementTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementByteMatchStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchArgs']]:
        """
        Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


@pulumi.input_type
class WebAclRuleStatementByteMatchStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchJa3FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_path: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchUriPathArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs'] all_query_arguments: Inspect all query arguments.
        :param pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchBodyArgs'] body: Inspect the request body, which immediately follows the request headers. See `body` below for details.
        :param pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchCookiesArgs'] cookies: Inspect the cookies in the web request. See `cookies` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchHeaderOrderArgs']]] header_orders: Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchHeaderArgs']]] headers: Inspect the request headers. See `headers` below for details.
        :param pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchJa3FingerprintArgs'] ja3_fingerprint: Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        :param pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyArgs'] json_body: Inspect the request body as JSON. See `json_body` for details.
        :param pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchMethodArgs'] method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchQueryStringArgs'] query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchSingleHeaderArgs'] single_header: Inspect a single header. See `single_header` below for details.
        :param pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs'] single_query_argument: Inspect a single query argument. See `single_query_argument` below for details.
        :param pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchUriPathArgs'] uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs']]:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchBodyArgs']]:
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchCookiesArgs']]:
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchHeaderOrderArgs']]]]:
        """
        Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        """
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchHeaderArgs']]]]:
        """
        Inspect the request headers. See `headers` below for details.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchJa3FingerprintArgs']]:
        """
        Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        """
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyArgs']]:
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchMethodArgs']]:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchQueryStringArgs']]:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchSingleHeaderArgs']]:
        """
        Inspect a single header. See `single_header` below for details.
        """
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs']]:
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchUriPathArgs']]:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


@pulumi.input_type
class WebAclRuleStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementByteMatchStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] oversize_handling: What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementByteMatchStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs']]] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param pulumi.Input[str] match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs']]]:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_cookies", value)


@pulumi.input_type
class WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementByteMatchStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs'] match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param pulumi.Input[str] match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs']:
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_headers", value)


@pulumi.input_type
class WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementByteMatchStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementByteMatchStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)


@pulumi.input_type
class WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 invalid_fallback_behavior: Optional[pulumi.Input[str]] = None,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs'] match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param pulumi.Input[str] match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param pulumi.Input[str] invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param pulumi.Input[str] oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs']:
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_paths", value)


@pulumi.input_type
class WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementByteMatchStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementByteMatchStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementByteMatchStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class WebAclRuleStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class WebAclRuleStatementByteMatchStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementByteMatchStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class WebAclRuleStatementGeoMatchStatementArgs:
    def __init__(__self__, *,
                 country_codes: pulumi.Input[Sequence[pulumi.Input[str]]],
                 forwarded_ip_config: Optional[pulumi.Input['WebAclRuleStatementGeoMatchStatementForwardedIpConfigArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] country_codes: Array of two-character country codes, for example, [ "US", "CN" ], from the alpha-2 country ISO codes of the `ISO 3166` international standard. See the [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_GeoMatchStatement.html) for valid values.
        :param pulumi.Input['WebAclRuleStatementGeoMatchStatementForwardedIpConfigArgs'] forwarded_ip_config: Configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See `forwarded_ip_config` below for details.
        """
        pulumi.set(__self__, "country_codes", country_codes)
        if forwarded_ip_config is not None:
            pulumi.set(__self__, "forwarded_ip_config", forwarded_ip_config)

    @property
    @pulumi.getter(name="countryCodes")
    def country_codes(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Array of two-character country codes, for example, [ "US", "CN" ], from the alpha-2 country ISO codes of the `ISO 3166` international standard. See the [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_GeoMatchStatement.html) for valid values.
        """
        return pulumi.get(self, "country_codes")

    @country_codes.setter
    def country_codes(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "country_codes", value)

    @property
    @pulumi.getter(name="forwardedIpConfig")
    def forwarded_ip_config(self) -> Optional[pulumi.Input['WebAclRuleStatementGeoMatchStatementForwardedIpConfigArgs']]:
        """
        Configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See `forwarded_ip_config` below for details.
        """
        return pulumi.get(self, "forwarded_ip_config")

    @forwarded_ip_config.setter
    def forwarded_ip_config(self, value: Optional[pulumi.Input['WebAclRuleStatementGeoMatchStatementForwardedIpConfigArgs']]):
        pulumi.set(self, "forwarded_ip_config", value)


@pulumi.input_type
class WebAclRuleStatementGeoMatchStatementForwardedIpConfigArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str],
                 header_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        :param pulumi.Input[str] header_name: Name of the HTTP header to use for the IP address.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> pulumi.Input[str]:
        """
        Name of the HTTP header to use for the IP address.
        """
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "header_name", value)


@pulumi.input_type
class WebAclRuleStatementIpSetReferenceStatementArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[str],
                 ip_set_forwarded_ip_config: Optional[pulumi.Input['WebAclRuleStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs']] = None):
        """
        :param pulumi.Input[str] arn: The Amazon Resource Name (ARN) of the IP Set that this statement references.
        :param pulumi.Input['WebAclRuleStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs'] ip_set_forwarded_ip_config: Configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See `ip_set_forwarded_ip_config` below for more details.
        """
        pulumi.set(__self__, "arn", arn)
        if ip_set_forwarded_ip_config is not None:
            pulumi.set(__self__, "ip_set_forwarded_ip_config", ip_set_forwarded_ip_config)

    @property
    @pulumi.getter
    def arn(self) -> pulumi.Input[str]:
        """
        The Amazon Resource Name (ARN) of the IP Set that this statement references.
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "arn", value)

    @property
    @pulumi.getter(name="ipSetForwardedIpConfig")
    def ip_set_forwarded_ip_config(self) -> Optional[pulumi.Input['WebAclRuleStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs']]:
        """
        Configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See `ip_set_forwarded_ip_config` below for more details.
        """
        return pulumi.get(self, "ip_set_forwarded_ip_config")

    @ip_set_forwarded_ip_config.setter
    def ip_set_forwarded_ip_config(self, value: Optional[pulumi.Input['WebAclRuleStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs']]):
        pulumi.set(self, "ip_set_forwarded_ip_config", value)


@pulumi.input_type
class WebAclRuleStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str],
                 header_name: pulumi.Input[str],
                 position: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        :param pulumi.Input[str] header_name: Name of the HTTP header to use for the IP address.
        :param pulumi.Input[str] position: Position in the header to search for the IP address. Valid values include: `FIRST`, `LAST`, or `ANY`. If `ANY` is specified and the header contains more than 10 IP addresses, AWS WAFv2 inspects the last 10.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "position", position)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> pulumi.Input[str]:
        """
        Name of the HTTP header to use for the IP address.
        """
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "header_name", value)

    @property
    @pulumi.getter
    def position(self) -> pulumi.Input[str]:
        """
        Position in the header to search for the IP address. Valid values include: `FIRST`, `LAST`, or `ANY`. If `ANY` is specified and the header contains more than 10 IP addresses, AWS WAFv2 inspects the last 10.
        """
        return pulumi.get(self, "position")

    @position.setter
    def position(self, value: pulumi.Input[str]):
        pulumi.set(self, "position", value)


@pulumi.input_type
class WebAclRuleStatementLabelMatchStatementArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 scope: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: String to match against.
        :param pulumi.Input[str] scope: Specify whether you want to match using the label name or just the namespace. Valid values are `LABEL` or `NAMESPACE`.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        String to match against.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def scope(self) -> pulumi.Input[str]:
        """
        Specify whether you want to match using the label name or just the namespace. Valid values are `LABEL` or `NAMESPACE`.
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "scope", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 vendor_name: pulumi.Input[str],
                 managed_rule_group_configs: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigArgs']]]] = None,
                 rule_action_overrides: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideArgs']]]] = None,
                 scope_down_statement: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementArgs']] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the managed rule group.
        :param pulumi.Input[str] vendor_name: Name of the managed rule group vendor.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigArgs']]] managed_rule_group_configs: Additional information that's used by a managed rule group. Only one rule attribute is allowed in each config. See `managed_rule_group_configs` for more details
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideArgs']]] rule_action_overrides: Action settings to use in the place of the rule actions that are configured inside the rule group. You specify one override for each rule whose action you want to change. See `rule_action_override` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementArgs'] scope_down_statement: Narrows the scope of the statement to matching web requests. This can be any nestable statement, and you can nest statements at any level below this scope-down statement. See `statement` above for details.
        :param pulumi.Input[str] version: Version of the managed rule group. You can set `Version_1.0` or `Version_1.1` etc. If you want to use the default version, do not set anything.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "vendor_name", vendor_name)
        if managed_rule_group_configs is not None:
            pulumi.set(__self__, "managed_rule_group_configs", managed_rule_group_configs)
        if rule_action_overrides is not None:
            pulumi.set(__self__, "rule_action_overrides", rule_action_overrides)
        if scope_down_statement is not None:
            pulumi.set(__self__, "scope_down_statement", scope_down_statement)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the managed rule group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="vendorName")
    def vendor_name(self) -> pulumi.Input[str]:
        """
        Name of the managed rule group vendor.
        """
        return pulumi.get(self, "vendor_name")

    @vendor_name.setter
    def vendor_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "vendor_name", value)

    @property
    @pulumi.getter(name="managedRuleGroupConfigs")
    def managed_rule_group_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigArgs']]]]:
        """
        Additional information that's used by a managed rule group. Only one rule attribute is allowed in each config. See `managed_rule_group_configs` for more details
        """
        return pulumi.get(self, "managed_rule_group_configs")

    @managed_rule_group_configs.setter
    def managed_rule_group_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigArgs']]]]):
        pulumi.set(self, "managed_rule_group_configs", value)

    @property
    @pulumi.getter(name="ruleActionOverrides")
    def rule_action_overrides(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideArgs']]]]:
        """
        Action settings to use in the place of the rule actions that are configured inside the rule group. You specify one override for each rule whose action you want to change. See `rule_action_override` below for details.
        """
        return pulumi.get(self, "rule_action_overrides")

    @rule_action_overrides.setter
    def rule_action_overrides(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideArgs']]]]):
        pulumi.set(self, "rule_action_overrides", value)

    @property
    @pulumi.getter(name="scopeDownStatement")
    def scope_down_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementArgs']]:
        """
        Narrows the scope of the statement to matching web requests. This can be any nestable statement, and you can nest statements at any level below this scope-down statement. See `statement` above for details.
        """
        return pulumi.get(self, "scope_down_statement")

    @scope_down_statement.setter
    def scope_down_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementArgs']]):
        pulumi.set(self, "scope_down_statement", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Version of the managed rule group. You can set `Version_1.0` or `Version_1.1` etc. If you want to use the default version, do not set anything.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigArgs:
    def __init__(__self__, *,
                 aws_managed_rules_acfp_rule_set: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetArgs']] = None,
                 aws_managed_rules_atp_rule_set: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetArgs']] = None,
                 aws_managed_rules_bot_control_rule_set: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesBotControlRuleSetArgs']] = None,
                 login_path: Optional[pulumi.Input[str]] = None,
                 password_field: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigPasswordFieldArgs']] = None,
                 payload_type: Optional[pulumi.Input[str]] = None,
                 username_field: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigUsernameFieldArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetArgs'] aws_managed_rules_acfp_rule_set: Additional configuration for using the Account Creation Fraud Prevention managed rule group. Use this to specify information such as the registration page of your application and the type of content to accept or reject from the client.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetArgs'] aws_managed_rules_atp_rule_set: Additional configuration for using the Account Takeover Protection managed rule group. Use this to specify information such as the sign-in page of your application and the type of content to accept or reject from the client.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesBotControlRuleSetArgs'] aws_managed_rules_bot_control_rule_set: Additional configuration for using the Bot Control managed rule group. Use this to specify the inspection level that you want to use. See `aws_managed_rules_bot_control_rule_set` for more details
        :param pulumi.Input[str] login_path: The path of the login endpoint for your application.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigPasswordFieldArgs'] password_field: Details about your login page password field. See `password_field` for more details.
        :param pulumi.Input[str] payload_type: The payload type for your login endpoint, either JSON or form encoded.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigUsernameFieldArgs'] username_field: Details about your login page username field. See `username_field` for more details.
        """
        if aws_managed_rules_acfp_rule_set is not None:
            pulumi.set(__self__, "aws_managed_rules_acfp_rule_set", aws_managed_rules_acfp_rule_set)
        if aws_managed_rules_atp_rule_set is not None:
            pulumi.set(__self__, "aws_managed_rules_atp_rule_set", aws_managed_rules_atp_rule_set)
        if aws_managed_rules_bot_control_rule_set is not None:
            pulumi.set(__self__, "aws_managed_rules_bot_control_rule_set", aws_managed_rules_bot_control_rule_set)
        if login_path is not None:
            pulumi.set(__self__, "login_path", login_path)
        if password_field is not None:
            pulumi.set(__self__, "password_field", password_field)
        if payload_type is not None:
            pulumi.set(__self__, "payload_type", payload_type)
        if username_field is not None:
            pulumi.set(__self__, "username_field", username_field)

    @property
    @pulumi.getter(name="awsManagedRulesAcfpRuleSet")
    def aws_managed_rules_acfp_rule_set(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetArgs']]:
        """
        Additional configuration for using the Account Creation Fraud Prevention managed rule group. Use this to specify information such as the registration page of your application and the type of content to accept or reject from the client.
        """
        return pulumi.get(self, "aws_managed_rules_acfp_rule_set")

    @aws_managed_rules_acfp_rule_set.setter
    def aws_managed_rules_acfp_rule_set(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetArgs']]):
        pulumi.set(self, "aws_managed_rules_acfp_rule_set", value)

    @property
    @pulumi.getter(name="awsManagedRulesAtpRuleSet")
    def aws_managed_rules_atp_rule_set(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetArgs']]:
        """
        Additional configuration for using the Account Takeover Protection managed rule group. Use this to specify information such as the sign-in page of your application and the type of content to accept or reject from the client.
        """
        return pulumi.get(self, "aws_managed_rules_atp_rule_set")

    @aws_managed_rules_atp_rule_set.setter
    def aws_managed_rules_atp_rule_set(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetArgs']]):
        pulumi.set(self, "aws_managed_rules_atp_rule_set", value)

    @property
    @pulumi.getter(name="awsManagedRulesBotControlRuleSet")
    def aws_managed_rules_bot_control_rule_set(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesBotControlRuleSetArgs']]:
        """
        Additional configuration for using the Bot Control managed rule group. Use this to specify the inspection level that you want to use. See `aws_managed_rules_bot_control_rule_set` for more details
        """
        return pulumi.get(self, "aws_managed_rules_bot_control_rule_set")

    @aws_managed_rules_bot_control_rule_set.setter
    def aws_managed_rules_bot_control_rule_set(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesBotControlRuleSetArgs']]):
        pulumi.set(self, "aws_managed_rules_bot_control_rule_set", value)

    @property
    @pulumi.getter(name="loginPath")
    def login_path(self) -> Optional[pulumi.Input[str]]:
        """
        The path of the login endpoint for your application.
        """
        return pulumi.get(self, "login_path")

    @login_path.setter
    def login_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "login_path", value)

    @property
    @pulumi.getter(name="passwordField")
    def password_field(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigPasswordFieldArgs']]:
        """
        Details about your login page password field. See `password_field` for more details.
        """
        return pulumi.get(self, "password_field")

    @password_field.setter
    def password_field(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigPasswordFieldArgs']]):
        pulumi.set(self, "password_field", value)

    @property
    @pulumi.getter(name="payloadType")
    def payload_type(self) -> Optional[pulumi.Input[str]]:
        """
        The payload type for your login endpoint, either JSON or form encoded.
        """
        return pulumi.get(self, "payload_type")

    @payload_type.setter
    def payload_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "payload_type", value)

    @property
    @pulumi.getter(name="usernameField")
    def username_field(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigUsernameFieldArgs']]:
        """
        Details about your login page username field. See `username_field` for more details.
        """
        return pulumi.get(self, "username_field")

    @username_field.setter
    def username_field(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigUsernameFieldArgs']]):
        pulumi.set(self, "username_field", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetArgs:
    def __init__(__self__, *,
                 creation_path: pulumi.Input[str],
                 registration_page_path: pulumi.Input[str],
                 request_inspection: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionArgs'],
                 enable_regex_in_path: Optional[pulumi.Input[bool]] = None,
                 response_inspection: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionArgs']] = None):
        """
        :param pulumi.Input[str] creation_path: The path of the account creation endpoint for your application. This is the page on your website that accepts the completed registration form for a new user. This page must accept POST requests.
        :param pulumi.Input[str] registration_page_path: The path of the account registration endpoint for your application. This is the page on your website that presents the registration form to new users. This page must accept GET text/html requests.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionArgs'] request_inspection: The criteria for inspecting login requests, used by the ATP rule group to validate credentials usage. See `request_inspection` for more details.
        :param pulumi.Input[bool] enable_regex_in_path: Whether or not to allow the use of regular expressions in the login page path.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionArgs'] response_inspection: The criteria for inspecting responses to login requests, used by the ATP rule group to track login failure rates. Note that Response Inspection is available only on web ACLs that protect CloudFront distributions. See `response_inspection` for more details.
        """
        pulumi.set(__self__, "creation_path", creation_path)
        pulumi.set(__self__, "registration_page_path", registration_page_path)
        pulumi.set(__self__, "request_inspection", request_inspection)
        if enable_regex_in_path is not None:
            pulumi.set(__self__, "enable_regex_in_path", enable_regex_in_path)
        if response_inspection is not None:
            pulumi.set(__self__, "response_inspection", response_inspection)

    @property
    @pulumi.getter(name="creationPath")
    def creation_path(self) -> pulumi.Input[str]:
        """
        The path of the account creation endpoint for your application. This is the page on your website that accepts the completed registration form for a new user. This page must accept POST requests.
        """
        return pulumi.get(self, "creation_path")

    @creation_path.setter
    def creation_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "creation_path", value)

    @property
    @pulumi.getter(name="registrationPagePath")
    def registration_page_path(self) -> pulumi.Input[str]:
        """
        The path of the account registration endpoint for your application. This is the page on your website that presents the registration form to new users. This page must accept GET text/html requests.
        """
        return pulumi.get(self, "registration_page_path")

    @registration_page_path.setter
    def registration_page_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "registration_page_path", value)

    @property
    @pulumi.getter(name="requestInspection")
    def request_inspection(self) -> pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionArgs']:
        """
        The criteria for inspecting login requests, used by the ATP rule group to validate credentials usage. See `request_inspection` for more details.
        """
        return pulumi.get(self, "request_inspection")

    @request_inspection.setter
    def request_inspection(self, value: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionArgs']):
        pulumi.set(self, "request_inspection", value)

    @property
    @pulumi.getter(name="enableRegexInPath")
    def enable_regex_in_path(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not to allow the use of regular expressions in the login page path.
        """
        return pulumi.get(self, "enable_regex_in_path")

    @enable_regex_in_path.setter
    def enable_regex_in_path(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_regex_in_path", value)

    @property
    @pulumi.getter(name="responseInspection")
    def response_inspection(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionArgs']]:
        """
        The criteria for inspecting responses to login requests, used by the ATP rule group to track login failure rates. Note that Response Inspection is available only on web ACLs that protect CloudFront distributions. See `response_inspection` for more details.
        """
        return pulumi.get(self, "response_inspection")

    @response_inspection.setter
    def response_inspection(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionArgs']]):
        pulumi.set(self, "response_inspection", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionArgs:
    def __init__(__self__, *,
                 payload_type: pulumi.Input[str],
                 email_field: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionEmailFieldArgs']] = None,
                 password_field: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionPasswordFieldArgs']] = None,
                 username_field: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionUsernameFieldArgs']] = None):
        """
        :param pulumi.Input[str] payload_type: The payload type for your login endpoint, either JSON or form encoded.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionPasswordFieldArgs'] password_field: Details about your login page password field. See `password_field` for more details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionUsernameFieldArgs'] username_field: Details about your login page username field. See `username_field` for more details.
        """
        pulumi.set(__self__, "payload_type", payload_type)
        if email_field is not None:
            pulumi.set(__self__, "email_field", email_field)
        if password_field is not None:
            pulumi.set(__self__, "password_field", password_field)
        if username_field is not None:
            pulumi.set(__self__, "username_field", username_field)

    @property
    @pulumi.getter(name="payloadType")
    def payload_type(self) -> pulumi.Input[str]:
        """
        The payload type for your login endpoint, either JSON or form encoded.
        """
        return pulumi.get(self, "payload_type")

    @payload_type.setter
    def payload_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "payload_type", value)

    @property
    @pulumi.getter(name="emailField")
    def email_field(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionEmailFieldArgs']]:
        return pulumi.get(self, "email_field")

    @email_field.setter
    def email_field(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionEmailFieldArgs']]):
        pulumi.set(self, "email_field", value)

    @property
    @pulumi.getter(name="passwordField")
    def password_field(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionPasswordFieldArgs']]:
        """
        Details about your login page password field. See `password_field` for more details.
        """
        return pulumi.get(self, "password_field")

    @password_field.setter
    def password_field(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionPasswordFieldArgs']]):
        pulumi.set(self, "password_field", value)

    @property
    @pulumi.getter(name="usernameField")
    def username_field(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionUsernameFieldArgs']]:
        """
        Details about your login page username field. See `username_field` for more details.
        """
        return pulumi.get(self, "username_field")

    @username_field.setter
    def username_field(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionUsernameFieldArgs']]):
        pulumi.set(self, "username_field", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionEmailFieldArgs:
    def __init__(__self__, *,
                 identifier: pulumi.Input[str]):
        """
        :param pulumi.Input[str] identifier: The identifier for the value to match against in the JSON.
        """
        pulumi.set(__self__, "identifier", identifier)

    @property
    @pulumi.getter
    def identifier(self) -> pulumi.Input[str]:
        """
        The identifier for the value to match against in the JSON.
        """
        return pulumi.get(self, "identifier")

    @identifier.setter
    def identifier(self, value: pulumi.Input[str]):
        pulumi.set(self, "identifier", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionPasswordFieldArgs:
    def __init__(__self__, *,
                 identifier: pulumi.Input[str]):
        """
        :param pulumi.Input[str] identifier: The name of the password field.
        """
        pulumi.set(__self__, "identifier", identifier)

    @property
    @pulumi.getter
    def identifier(self) -> pulumi.Input[str]:
        """
        The name of the password field.
        """
        return pulumi.get(self, "identifier")

    @identifier.setter
    def identifier(self, value: pulumi.Input[str]):
        pulumi.set(self, "identifier", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionUsernameFieldArgs:
    def __init__(__self__, *,
                 identifier: pulumi.Input[str]):
        """
        :param pulumi.Input[str] identifier: The name of the username field.
        """
        pulumi.set(__self__, "identifier", identifier)

    @property
    @pulumi.getter
    def identifier(self) -> pulumi.Input[str]:
        """
        The name of the username field.
        """
        return pulumi.get(self, "identifier")

    @identifier.setter
    def identifier(self, value: pulumi.Input[str]):
        pulumi.set(self, "identifier", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionArgs:
    def __init__(__self__, *,
                 body_contains: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionBodyContainsArgs']] = None,
                 header: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionHeaderArgs']] = None,
                 json: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionJsonArgs']] = None,
                 status_code: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionStatusCodeArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionBodyContainsArgs'] body_contains: Configures inspection of the response body. See `body_contains` for more details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionHeaderArgs'] header: Configures inspection of the response header.See `header` for more details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionJsonArgs'] json: Configures inspection of the response JSON. See `json` for more details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionStatusCodeArgs'] status_code: Configures inspection of the response status code.See `status_code` for more details.
        """
        if body_contains is not None:
            pulumi.set(__self__, "body_contains", body_contains)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if json is not None:
            pulumi.set(__self__, "json", json)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)

    @property
    @pulumi.getter(name="bodyContains")
    def body_contains(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionBodyContainsArgs']]:
        """
        Configures inspection of the response body. See `body_contains` for more details.
        """
        return pulumi.get(self, "body_contains")

    @body_contains.setter
    def body_contains(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionBodyContainsArgs']]):
        pulumi.set(self, "body_contains", value)

    @property
    @pulumi.getter
    def header(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionHeaderArgs']]:
        """
        Configures inspection of the response header.See `header` for more details.
        """
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionHeaderArgs']]):
        pulumi.set(self, "header", value)

    @property
    @pulumi.getter
    def json(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionJsonArgs']]:
        """
        Configures inspection of the response JSON. See `json` for more details.
        """
        return pulumi.get(self, "json")

    @json.setter
    def json(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionJsonArgs']]):
        pulumi.set(self, "json", value)

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionStatusCodeArgs']]:
        """
        Configures inspection of the response status code.See `status_code` for more details.
        """
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionStatusCodeArgs']]):
        pulumi.set(self, "status_code", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionBodyContainsArgs:
    def __init__(__self__, *,
                 failure_strings: pulumi.Input[Sequence[pulumi.Input[str]]],
                 success_strings: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] failure_strings: Strings in the body of the response that indicate a failed login attempt.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] success_strings: Strings in the body of the response that indicate a successful login attempt.
        """
        pulumi.set(__self__, "failure_strings", failure_strings)
        pulumi.set(__self__, "success_strings", success_strings)

    @property
    @pulumi.getter(name="failureStrings")
    def failure_strings(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Strings in the body of the response that indicate a failed login attempt.
        """
        return pulumi.get(self, "failure_strings")

    @failure_strings.setter
    def failure_strings(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "failure_strings", value)

    @property
    @pulumi.getter(name="successStrings")
    def success_strings(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Strings in the body of the response that indicate a successful login attempt.
        """
        return pulumi.get(self, "success_strings")

    @success_strings.setter
    def success_strings(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "success_strings", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionHeaderArgs:
    def __init__(__self__, *,
                 failure_values: pulumi.Input[Sequence[pulumi.Input[str]]],
                 name: pulumi.Input[str],
                 success_values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] failure_values: Values in the response header with the specified name that indicate a failed login attempt.
        :param pulumi.Input[str] name: The name of the header to use.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] success_values: Values in the response header with the specified name that indicate a successful login attempt.
        """
        pulumi.set(__self__, "failure_values", failure_values)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "success_values", success_values)

    @property
    @pulumi.getter(name="failureValues")
    def failure_values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Values in the response header with the specified name that indicate a failed login attempt.
        """
        return pulumi.get(self, "failure_values")

    @failure_values.setter
    def failure_values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "failure_values", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the header to use.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="successValues")
    def success_values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Values in the response header with the specified name that indicate a successful login attempt.
        """
        return pulumi.get(self, "success_values")

    @success_values.setter
    def success_values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "success_values", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionJsonArgs:
    def __init__(__self__, *,
                 failure_values: pulumi.Input[Sequence[pulumi.Input[str]]],
                 identifier: pulumi.Input[str],
                 success_values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] failure_values: Values in the response header with the specified name that indicate a failed login attempt.
        :param pulumi.Input[str] identifier: The identifier for the value to match against in the JSON.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] success_values: Values in the response header with the specified name that indicate a successful login attempt.
        """
        pulumi.set(__self__, "failure_values", failure_values)
        pulumi.set(__self__, "identifier", identifier)
        pulumi.set(__self__, "success_values", success_values)

    @property
    @pulumi.getter(name="failureValues")
    def failure_values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Values in the response header with the specified name that indicate a failed login attempt.
        """
        return pulumi.get(self, "failure_values")

    @failure_values.setter
    def failure_values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "failure_values", value)

    @property
    @pulumi.getter
    def identifier(self) -> pulumi.Input[str]:
        """
        The identifier for the value to match against in the JSON.
        """
        return pulumi.get(self, "identifier")

    @identifier.setter
    def identifier(self, value: pulumi.Input[str]):
        pulumi.set(self, "identifier", value)

    @property
    @pulumi.getter(name="successValues")
    def success_values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Values in the response header with the specified name that indicate a successful login attempt.
        """
        return pulumi.get(self, "success_values")

    @success_values.setter
    def success_values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "success_values", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionStatusCodeArgs:
    def __init__(__self__, *,
                 failure_codes: pulumi.Input[Sequence[pulumi.Input[int]]],
                 success_codes: pulumi.Input[Sequence[pulumi.Input[int]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[int]]] failure_codes: Status codes in the response that indicate a failed login attempt.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] success_codes: Status codes in the response that indicate a successful login attempt.
        """
        pulumi.set(__self__, "failure_codes", failure_codes)
        pulumi.set(__self__, "success_codes", success_codes)

    @property
    @pulumi.getter(name="failureCodes")
    def failure_codes(self) -> pulumi.Input[Sequence[pulumi.Input[int]]]:
        """
        Status codes in the response that indicate a failed login attempt.
        """
        return pulumi.get(self, "failure_codes")

    @failure_codes.setter
    def failure_codes(self, value: pulumi.Input[Sequence[pulumi.Input[int]]]):
        pulumi.set(self, "failure_codes", value)

    @property
    @pulumi.getter(name="successCodes")
    def success_codes(self) -> pulumi.Input[Sequence[pulumi.Input[int]]]:
        """
        Status codes in the response that indicate a successful login attempt.
        """
        return pulumi.get(self, "success_codes")

    @success_codes.setter
    def success_codes(self, value: pulumi.Input[Sequence[pulumi.Input[int]]]):
        pulumi.set(self, "success_codes", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetArgs:
    def __init__(__self__, *,
                 login_path: pulumi.Input[str],
                 enable_regex_in_path: Optional[pulumi.Input[bool]] = None,
                 request_inspection: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionArgs']] = None,
                 response_inspection: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionArgs']] = None):
        """
        :param pulumi.Input[str] login_path: The path of the login endpoint for your application.
        :param pulumi.Input[bool] enable_regex_in_path: Whether or not to allow the use of regular expressions in the login page path.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionArgs'] request_inspection: The criteria for inspecting login requests, used by the ATP rule group to validate credentials usage. See `request_inspection` for more details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionArgs'] response_inspection: The criteria for inspecting responses to login requests, used by the ATP rule group to track login failure rates. Note that Response Inspection is available only on web ACLs that protect CloudFront distributions. See `response_inspection` for more details.
        """
        pulumi.set(__self__, "login_path", login_path)
        if enable_regex_in_path is not None:
            pulumi.set(__self__, "enable_regex_in_path", enable_regex_in_path)
        if request_inspection is not None:
            pulumi.set(__self__, "request_inspection", request_inspection)
        if response_inspection is not None:
            pulumi.set(__self__, "response_inspection", response_inspection)

    @property
    @pulumi.getter(name="loginPath")
    def login_path(self) -> pulumi.Input[str]:
        """
        The path of the login endpoint for your application.
        """
        return pulumi.get(self, "login_path")

    @login_path.setter
    def login_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "login_path", value)

    @property
    @pulumi.getter(name="enableRegexInPath")
    def enable_regex_in_path(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not to allow the use of regular expressions in the login page path.
        """
        return pulumi.get(self, "enable_regex_in_path")

    @enable_regex_in_path.setter
    def enable_regex_in_path(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_regex_in_path", value)

    @property
    @pulumi.getter(name="requestInspection")
    def request_inspection(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionArgs']]:
        """
        The criteria for inspecting login requests, used by the ATP rule group to validate credentials usage. See `request_inspection` for more details.
        """
        return pulumi.get(self, "request_inspection")

    @request_inspection.setter
    def request_inspection(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionArgs']]):
        pulumi.set(self, "request_inspection", value)

    @property
    @pulumi.getter(name="responseInspection")
    def response_inspection(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionArgs']]:
        """
        The criteria for inspecting responses to login requests, used by the ATP rule group to track login failure rates. Note that Response Inspection is available only on web ACLs that protect CloudFront distributions. See `response_inspection` for more details.
        """
        return pulumi.get(self, "response_inspection")

    @response_inspection.setter
    def response_inspection(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionArgs']]):
        pulumi.set(self, "response_inspection", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionArgs:
    def __init__(__self__, *,
                 password_field: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionPasswordFieldArgs'],
                 payload_type: pulumi.Input[str],
                 username_field: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionUsernameFieldArgs']):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionPasswordFieldArgs'] password_field: Details about your login page password field. See `password_field` for more details.
        :param pulumi.Input[str] payload_type: The payload type for your login endpoint, either JSON or form encoded.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionUsernameFieldArgs'] username_field: Details about your login page username field. See `username_field` for more details.
        """
        pulumi.set(__self__, "password_field", password_field)
        pulumi.set(__self__, "payload_type", payload_type)
        pulumi.set(__self__, "username_field", username_field)

    @property
    @pulumi.getter(name="passwordField")
    def password_field(self) -> pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionPasswordFieldArgs']:
        """
        Details about your login page password field. See `password_field` for more details.
        """
        return pulumi.get(self, "password_field")

    @password_field.setter
    def password_field(self, value: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionPasswordFieldArgs']):
        pulumi.set(self, "password_field", value)

    @property
    @pulumi.getter(name="payloadType")
    def payload_type(self) -> pulumi.Input[str]:
        """
        The payload type for your login endpoint, either JSON or form encoded.
        """
        return pulumi.get(self, "payload_type")

    @payload_type.setter
    def payload_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "payload_type", value)

    @property
    @pulumi.getter(name="usernameField")
    def username_field(self) -> pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionUsernameFieldArgs']:
        """
        Details about your login page username field. See `username_field` for more details.
        """
        return pulumi.get(self, "username_field")

    @username_field.setter
    def username_field(self, value: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionUsernameFieldArgs']):
        pulumi.set(self, "username_field", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionPasswordFieldArgs:
    def __init__(__self__, *,
                 identifier: pulumi.Input[str]):
        """
        :param pulumi.Input[str] identifier: The name of the password field.
        """
        pulumi.set(__self__, "identifier", identifier)

    @property
    @pulumi.getter
    def identifier(self) -> pulumi.Input[str]:
        """
        The name of the password field.
        """
        return pulumi.get(self, "identifier")

    @identifier.setter
    def identifier(self, value: pulumi.Input[str]):
        pulumi.set(self, "identifier", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionUsernameFieldArgs:
    def __init__(__self__, *,
                 identifier: pulumi.Input[str]):
        """
        :param pulumi.Input[str] identifier: The name of the username field.
        """
        pulumi.set(__self__, "identifier", identifier)

    @property
    @pulumi.getter
    def identifier(self) -> pulumi.Input[str]:
        """
        The name of the username field.
        """
        return pulumi.get(self, "identifier")

    @identifier.setter
    def identifier(self, value: pulumi.Input[str]):
        pulumi.set(self, "identifier", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionArgs:
    def __init__(__self__, *,
                 body_contains: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionBodyContainsArgs']] = None,
                 header: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionHeaderArgs']] = None,
                 json: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionJsonArgs']] = None,
                 status_code: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionStatusCodeArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionBodyContainsArgs'] body_contains: Configures inspection of the response body. See `body_contains` for more details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionHeaderArgs'] header: Configures inspection of the response header.See `header` for more details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionJsonArgs'] json: Configures inspection of the response JSON. See `json` for more details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionStatusCodeArgs'] status_code: Configures inspection of the response status code.See `status_code` for more details.
        """
        if body_contains is not None:
            pulumi.set(__self__, "body_contains", body_contains)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if json is not None:
            pulumi.set(__self__, "json", json)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)

    @property
    @pulumi.getter(name="bodyContains")
    def body_contains(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionBodyContainsArgs']]:
        """
        Configures inspection of the response body. See `body_contains` for more details.
        """
        return pulumi.get(self, "body_contains")

    @body_contains.setter
    def body_contains(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionBodyContainsArgs']]):
        pulumi.set(self, "body_contains", value)

    @property
    @pulumi.getter
    def header(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionHeaderArgs']]:
        """
        Configures inspection of the response header.See `header` for more details.
        """
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionHeaderArgs']]):
        pulumi.set(self, "header", value)

    @property
    @pulumi.getter
    def json(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionJsonArgs']]:
        """
        Configures inspection of the response JSON. See `json` for more details.
        """
        return pulumi.get(self, "json")

    @json.setter
    def json(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionJsonArgs']]):
        pulumi.set(self, "json", value)

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionStatusCodeArgs']]:
        """
        Configures inspection of the response status code.See `status_code` for more details.
        """
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionStatusCodeArgs']]):
        pulumi.set(self, "status_code", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionBodyContainsArgs:
    def __init__(__self__, *,
                 failure_strings: pulumi.Input[Sequence[pulumi.Input[str]]],
                 success_strings: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] failure_strings: Strings in the body of the response that indicate a failed login attempt.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] success_strings: Strings in the body of the response that indicate a successful login attempt.
        """
        pulumi.set(__self__, "failure_strings", failure_strings)
        pulumi.set(__self__, "success_strings", success_strings)

    @property
    @pulumi.getter(name="failureStrings")
    def failure_strings(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Strings in the body of the response that indicate a failed login attempt.
        """
        return pulumi.get(self, "failure_strings")

    @failure_strings.setter
    def failure_strings(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "failure_strings", value)

    @property
    @pulumi.getter(name="successStrings")
    def success_strings(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Strings in the body of the response that indicate a successful login attempt.
        """
        return pulumi.get(self, "success_strings")

    @success_strings.setter
    def success_strings(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "success_strings", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionHeaderArgs:
    def __init__(__self__, *,
                 failure_values: pulumi.Input[Sequence[pulumi.Input[str]]],
                 name: pulumi.Input[str],
                 success_values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] failure_values: Values in the response header with the specified name that indicate a failed login attempt.
        :param pulumi.Input[str] name: The name of the header to use.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] success_values: Values in the response header with the specified name that indicate a successful login attempt.
        """
        pulumi.set(__self__, "failure_values", failure_values)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "success_values", success_values)

    @property
    @pulumi.getter(name="failureValues")
    def failure_values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Values in the response header with the specified name that indicate a failed login attempt.
        """
        return pulumi.get(self, "failure_values")

    @failure_values.setter
    def failure_values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "failure_values", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the header to use.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="successValues")
    def success_values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Values in the response header with the specified name that indicate a successful login attempt.
        """
        return pulumi.get(self, "success_values")

    @success_values.setter
    def success_values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "success_values", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionJsonArgs:
    def __init__(__self__, *,
                 failure_values: pulumi.Input[Sequence[pulumi.Input[str]]],
                 identifier: pulumi.Input[str],
                 success_values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] failure_values: Values in the response header with the specified name that indicate a failed login attempt.
        :param pulumi.Input[str] identifier: The identifier for the value to match against in the JSON.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] success_values: Values in the response header with the specified name that indicate a successful login attempt.
        """
        pulumi.set(__self__, "failure_values", failure_values)
        pulumi.set(__self__, "identifier", identifier)
        pulumi.set(__self__, "success_values", success_values)

    @property
    @pulumi.getter(name="failureValues")
    def failure_values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Values in the response header with the specified name that indicate a failed login attempt.
        """
        return pulumi.get(self, "failure_values")

    @failure_values.setter
    def failure_values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "failure_values", value)

    @property
    @pulumi.getter
    def identifier(self) -> pulumi.Input[str]:
        """
        The identifier for the value to match against in the JSON.
        """
        return pulumi.get(self, "identifier")

    @identifier.setter
    def identifier(self, value: pulumi.Input[str]):
        pulumi.set(self, "identifier", value)

    @property
    @pulumi.getter(name="successValues")
    def success_values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Values in the response header with the specified name that indicate a successful login attempt.
        """
        return pulumi.get(self, "success_values")

    @success_values.setter
    def success_values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "success_values", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionStatusCodeArgs:
    def __init__(__self__, *,
                 failure_codes: pulumi.Input[Sequence[pulumi.Input[int]]],
                 success_codes: pulumi.Input[Sequence[pulumi.Input[int]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[int]]] failure_codes: Status codes in the response that indicate a failed login attempt.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] success_codes: Status codes in the response that indicate a successful login attempt.
        """
        pulumi.set(__self__, "failure_codes", failure_codes)
        pulumi.set(__self__, "success_codes", success_codes)

    @property
    @pulumi.getter(name="failureCodes")
    def failure_codes(self) -> pulumi.Input[Sequence[pulumi.Input[int]]]:
        """
        Status codes in the response that indicate a failed login attempt.
        """
        return pulumi.get(self, "failure_codes")

    @failure_codes.setter
    def failure_codes(self, value: pulumi.Input[Sequence[pulumi.Input[int]]]):
        pulumi.set(self, "failure_codes", value)

    @property
    @pulumi.getter(name="successCodes")
    def success_codes(self) -> pulumi.Input[Sequence[pulumi.Input[int]]]:
        """
        Status codes in the response that indicate a successful login attempt.
        """
        return pulumi.get(self, "success_codes")

    @success_codes.setter
    def success_codes(self, value: pulumi.Input[Sequence[pulumi.Input[int]]]):
        pulumi.set(self, "success_codes", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesBotControlRuleSetArgs:
    def __init__(__self__, *,
                 inspection_level: pulumi.Input[str]):
        """
        :param pulumi.Input[str] inspection_level: The inspection level to use for the Bot Control rule group.
        """
        pulumi.set(__self__, "inspection_level", inspection_level)

    @property
    @pulumi.getter(name="inspectionLevel")
    def inspection_level(self) -> pulumi.Input[str]:
        """
        The inspection level to use for the Bot Control rule group.
        """
        return pulumi.get(self, "inspection_level")

    @inspection_level.setter
    def inspection_level(self, value: pulumi.Input[str]):
        pulumi.set(self, "inspection_level", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigPasswordFieldArgs:
    def __init__(__self__, *,
                 identifier: pulumi.Input[str]):
        """
        :param pulumi.Input[str] identifier: The name of the password field.
        """
        pulumi.set(__self__, "identifier", identifier)

    @property
    @pulumi.getter
    def identifier(self) -> pulumi.Input[str]:
        """
        The name of the password field.
        """
        return pulumi.get(self, "identifier")

    @identifier.setter
    def identifier(self, value: pulumi.Input[str]):
        pulumi.set(self, "identifier", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigUsernameFieldArgs:
    def __init__(__self__, *,
                 identifier: pulumi.Input[str]):
        """
        :param pulumi.Input[str] identifier: The name of the username field.
        """
        pulumi.set(__self__, "identifier", identifier)

    @property
    @pulumi.getter
    def identifier(self) -> pulumi.Input[str]:
        """
        The name of the username field.
        """
        return pulumi.get(self, "identifier")

    @identifier.setter
    def identifier(self, value: pulumi.Input[str]):
        pulumi.set(self, "identifier", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideArgs:
    def __init__(__self__, *,
                 action_to_use: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseArgs'],
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseArgs'] action_to_use: Override action to use, in place of the configured action of the rule in the rule group. See `action` for details.
        :param pulumi.Input[str] name: Name of the rule to override. See the [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/aws-managed-rule-groups-list.html) for a list of names in the appropriate rule group in use.
        """
        pulumi.set(__self__, "action_to_use", action_to_use)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="actionToUse")
    def action_to_use(self) -> pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseArgs']:
        """
        Override action to use, in place of the configured action of the rule in the rule group. See `action` for details.
        """
        return pulumi.get(self, "action_to_use")

    @action_to_use.setter
    def action_to_use(self, value: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseArgs']):
        pulumi.set(self, "action_to_use", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the rule to override. See the [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/aws-managed-rule-groups-list.html) for a list of names in the appropriate rule group in use.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseArgs:
    def __init__(__self__, *,
                 allow: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowArgs']] = None,
                 block: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockArgs']] = None,
                 captcha: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaArgs']] = None,
                 challenge: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeArgs']] = None,
                 count: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowArgs'] allow: Instructs AWS WAF to allow the web request. See `allow` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockArgs'] block: Instructs AWS WAF to block the web request. See `block` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaArgs'] captcha: Instructs AWS WAF to run a Captcha check against the web request. See `captcha` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeArgs'] challenge: Instructs AWS WAF to run a check against the request to verify that the request is coming from a legitimate client session. See `challenge` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountArgs'] count: Instructs AWS WAF to count the web request and allow it. See `count` below for details.
        """
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if block is not None:
            pulumi.set(__self__, "block", block)
        if captcha is not None:
            pulumi.set(__self__, "captcha", captcha)
        if challenge is not None:
            pulumi.set(__self__, "challenge", challenge)
        if count is not None:
            pulumi.set(__self__, "count", count)

    @property
    @pulumi.getter
    def allow(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowArgs']]:
        """
        Instructs AWS WAF to allow the web request. See `allow` below for details.
        """
        return pulumi.get(self, "allow")

    @allow.setter
    def allow(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowArgs']]):
        pulumi.set(self, "allow", value)

    @property
    @pulumi.getter
    def block(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockArgs']]:
        """
        Instructs AWS WAF to block the web request. See `block` below for details.
        """
        return pulumi.get(self, "block")

    @block.setter
    def block(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockArgs']]):
        pulumi.set(self, "block", value)

    @property
    @pulumi.getter
    def captcha(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaArgs']]:
        """
        Instructs AWS WAF to run a Captcha check against the web request. See `captcha` below for details.
        """
        return pulumi.get(self, "captcha")

    @captcha.setter
    def captcha(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaArgs']]):
        pulumi.set(self, "captcha", value)

    @property
    @pulumi.getter
    def challenge(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeArgs']]:
        """
        Instructs AWS WAF to run a check against the request to verify that the request is coming from a legitimate client session. See `challenge` below for details.
        """
        return pulumi.get(self, "challenge")

    @challenge.setter
    def challenge(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeArgs']]):
        pulumi.set(self, "challenge", value)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountArgs']]:
        """
        Instructs AWS WAF to count the web request and allow it. See `count` below for details.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountArgs']]):
        pulumi.set(self, "count", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingArgs'] custom_request_handling: Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingArgs']]:
        """
        Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingArgs:
    def __init__(__self__, *,
                 insert_headers: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeaderArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeaderArgs']]] insert_headers: The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        pulumi.set(__self__, "insert_headers", insert_headers)

    @property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeaderArgs']]]:
        """
        The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        return pulumi.get(self, "insert_headers")

    @insert_headers.setter
    def insert_headers(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeaderArgs']]]):
        pulumi.set(self, "insert_headers", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        :param pulumi.Input[str] value: Value of the custom header.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value of the custom header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockArgs:
    def __init__(__self__, *,
                 custom_response: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponseArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponseArgs'] custom_response: Defines a custom response for the web request. See `custom_response` below for details.
        """
        if custom_response is not None:
            pulumi.set(__self__, "custom_response", custom_response)

    @property
    @pulumi.getter(name="customResponse")
    def custom_response(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponseArgs']]:
        """
        Defines a custom response for the web request. See `custom_response` below for details.
        """
        return pulumi.get(self, "custom_response")

    @custom_response.setter
    def custom_response(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponseArgs']]):
        pulumi.set(self, "custom_response", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponseArgs:
    def __init__(__self__, *,
                 response_code: pulumi.Input[int],
                 custom_response_body_key: Optional[pulumi.Input[str]] = None,
                 response_headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeaderArgs']]]] = None):
        """
        :param pulumi.Input[int] response_code: The HTTP status code to return to the client.
        :param pulumi.Input[str] custom_response_body_key: References the response body that you want AWS WAF to return to the web request client. This must reference a `key` defined in a `custom_response_body` block of this resource.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeaderArgs']]] response_headers: The `response_header` blocks used to define the HTTP response headers added to the response. See `response_header` below for details.
        """
        pulumi.set(__self__, "response_code", response_code)
        if custom_response_body_key is not None:
            pulumi.set(__self__, "custom_response_body_key", custom_response_body_key)
        if response_headers is not None:
            pulumi.set(__self__, "response_headers", response_headers)

    @property
    @pulumi.getter(name="responseCode")
    def response_code(self) -> pulumi.Input[int]:
        """
        The HTTP status code to return to the client.
        """
        return pulumi.get(self, "response_code")

    @response_code.setter
    def response_code(self, value: pulumi.Input[int]):
        pulumi.set(self, "response_code", value)

    @property
    @pulumi.getter(name="customResponseBodyKey")
    def custom_response_body_key(self) -> Optional[pulumi.Input[str]]:
        """
        References the response body that you want AWS WAF to return to the web request client. This must reference a `key` defined in a `custom_response_body` block of this resource.
        """
        return pulumi.get(self, "custom_response_body_key")

    @custom_response_body_key.setter
    def custom_response_body_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_response_body_key", value)

    @property
    @pulumi.getter(name="responseHeaders")
    def response_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeaderArgs']]]]:
        """
        The `response_header` blocks used to define the HTTP response headers added to the response. See `response_header` below for details.
        """
        return pulumi.get(self, "response_headers")

    @response_headers.setter
    def response_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeaderArgs']]]]):
        pulumi.set(self, "response_headers", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        :param pulumi.Input[str] value: Value of the custom header.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value of the custom header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingArgs'] custom_request_handling: Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingArgs']]:
        """
        Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingArgs:
    def __init__(__self__, *,
                 insert_headers: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeaderArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeaderArgs']]] insert_headers: The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        pulumi.set(__self__, "insert_headers", insert_headers)

    @property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeaderArgs']]]:
        """
        The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        return pulumi.get(self, "insert_headers")

    @insert_headers.setter
    def insert_headers(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeaderArgs']]]):
        pulumi.set(self, "insert_headers", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        :param pulumi.Input[str] value: Value of the custom header.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value of the custom header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingArgs'] custom_request_handling: Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingArgs']]:
        """
        Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingArgs:
    def __init__(__self__, *,
                 insert_headers: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeaderArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeaderArgs']]] insert_headers: The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        pulumi.set(__self__, "insert_headers", insert_headers)

    @property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeaderArgs']]]:
        """
        The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        return pulumi.get(self, "insert_headers")

    @insert_headers.setter
    def insert_headers(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeaderArgs']]]):
        pulumi.set(self, "insert_headers", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        :param pulumi.Input[str] value: Value of the custom header.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value of the custom header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandlingArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandlingArgs'] custom_request_handling: Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandlingArgs']]:
        """
        Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandlingArgs:
    def __init__(__self__, *,
                 insert_headers: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeaderArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeaderArgs']]] insert_headers: The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        pulumi.set(__self__, "insert_headers", insert_headers)

    @property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeaderArgs']]]:
        """
        The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        return pulumi.get(self, "insert_headers")

    @insert_headers.setter
    def insert_headers(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeaderArgs']]]):
        pulumi.set(self, "insert_headers", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        :param pulumi.Input[str] value: Value of the custom header.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value of the custom header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementArgs:
    def __init__(__self__, *,
                 and_statement: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAndStatementArgs']] = None,
                 byte_match_statement: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementArgs']] = None,
                 geo_match_statement: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementArgs']] = None,
                 ip_set_reference_statement: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementArgs']] = None,
                 label_match_statement: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementLabelMatchStatementArgs']] = None,
                 not_statement: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementNotStatementArgs']] = None,
                 or_statement: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementOrStatementArgs']] = None,
                 regex_match_statement: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementArgs']] = None,
                 regex_pattern_set_reference_statement: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementArgs']] = None,
                 size_constraint_statement: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementArgs']] = None,
                 sqli_match_statement: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementArgs']] = None,
                 xss_match_statement: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAndStatementArgs'] and_statement: Logical rule statement used to combine other rule statements with AND logic. See `and_statement` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementArgs'] byte_match_statement: Rule statement that defines a string match search for AWS WAF to apply to web requests. See `byte_match_statement` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementArgs'] geo_match_statement: Rule statement used to identify web requests based on country of origin. See `geo_match_statement` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementArgs'] ip_set_reference_statement: Rule statement used to detect web requests coming from particular IP addresses or address ranges. See `ip_set_reference_statement` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementLabelMatchStatementArgs'] label_match_statement: Rule statement that defines a string match search against labels that have been added to the web request by rules that have already run in the web ACL. See `label_match_statement` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementNotStatementArgs'] not_statement: Logical rule statement used to negate the results of another rule statement. See `not_statement` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementOrStatementArgs'] or_statement: Logical rule statement used to combine other rule statements with OR logic. See `or_statement` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementArgs'] regex_match_statement: Rule statement used to search web request components for a match against a single regular expression. See `regex_match_statement` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementArgs'] regex_pattern_set_reference_statement: Rule statement used to search web request components for matches with regular expressions. See `regex_pattern_set_reference_statement` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementArgs'] size_constraint_statement: Rule statement that compares a number of bytes against the size of a request component, using a comparison operator, such as greater than (>) or less than (<). See `size_constraint_statement` below for more details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementArgs'] sqli_match_statement: An SQL injection match condition identifies the part of web requests, such as the URI or the query string, that you want AWS WAF to inspect. See `sqli_match_statement` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementArgs'] xss_match_statement: Rule statement that defines a cross-site scripting (XSS) match search for AWS WAF to apply to web requests. See `xss_match_statement` below for details.
        """
        if and_statement is not None:
            pulumi.set(__self__, "and_statement", and_statement)
        if byte_match_statement is not None:
            pulumi.set(__self__, "byte_match_statement", byte_match_statement)
        if geo_match_statement is not None:
            pulumi.set(__self__, "geo_match_statement", geo_match_statement)
        if ip_set_reference_statement is not None:
            pulumi.set(__self__, "ip_set_reference_statement", ip_set_reference_statement)
        if label_match_statement is not None:
            pulumi.set(__self__, "label_match_statement", label_match_statement)
        if not_statement is not None:
            pulumi.set(__self__, "not_statement", not_statement)
        if or_statement is not None:
            pulumi.set(__self__, "or_statement", or_statement)
        if regex_match_statement is not None:
            pulumi.set(__self__, "regex_match_statement", regex_match_statement)
        if regex_pattern_set_reference_statement is not None:
            pulumi.set(__self__, "regex_pattern_set_reference_statement", regex_pattern_set_reference_statement)
        if size_constraint_statement is not None:
            pulumi.set(__self__, "size_constraint_statement", size_constraint_statement)
        if sqli_match_statement is not None:
            pulumi.set(__self__, "sqli_match_statement", sqli_match_statement)
        if xss_match_statement is not None:
            pulumi.set(__self__, "xss_match_statement", xss_match_statement)

    @property
    @pulumi.getter(name="andStatement")
    def and_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAndStatementArgs']]:
        """
        Logical rule statement used to combine other rule statements with AND logic. See `and_statement` below for details.
        """
        return pulumi.get(self, "and_statement")

    @and_statement.setter
    def and_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAndStatementArgs']]):
        pulumi.set(self, "and_statement", value)

    @property
    @pulumi.getter(name="byteMatchStatement")
    def byte_match_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementArgs']]:
        """
        Rule statement that defines a string match search for AWS WAF to apply to web requests. See `byte_match_statement` below for details.
        """
        return pulumi.get(self, "byte_match_statement")

    @byte_match_statement.setter
    def byte_match_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementArgs']]):
        pulumi.set(self, "byte_match_statement", value)

    @property
    @pulumi.getter(name="geoMatchStatement")
    def geo_match_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementArgs']]:
        """
        Rule statement used to identify web requests based on country of origin. See `geo_match_statement` below for details.
        """
        return pulumi.get(self, "geo_match_statement")

    @geo_match_statement.setter
    def geo_match_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementArgs']]):
        pulumi.set(self, "geo_match_statement", value)

    @property
    @pulumi.getter(name="ipSetReferenceStatement")
    def ip_set_reference_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementArgs']]:
        """
        Rule statement used to detect web requests coming from particular IP addresses or address ranges. See `ip_set_reference_statement` below for details.
        """
        return pulumi.get(self, "ip_set_reference_statement")

    @ip_set_reference_statement.setter
    def ip_set_reference_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementArgs']]):
        pulumi.set(self, "ip_set_reference_statement", value)

    @property
    @pulumi.getter(name="labelMatchStatement")
    def label_match_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementLabelMatchStatementArgs']]:
        """
        Rule statement that defines a string match search against labels that have been added to the web request by rules that have already run in the web ACL. See `label_match_statement` below for details.
        """
        return pulumi.get(self, "label_match_statement")

    @label_match_statement.setter
    def label_match_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementLabelMatchStatementArgs']]):
        pulumi.set(self, "label_match_statement", value)

    @property
    @pulumi.getter(name="notStatement")
    def not_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementNotStatementArgs']]:
        """
        Logical rule statement used to negate the results of another rule statement. See `not_statement` below for details.
        """
        return pulumi.get(self, "not_statement")

    @not_statement.setter
    def not_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementNotStatementArgs']]):
        pulumi.set(self, "not_statement", value)

    @property
    @pulumi.getter(name="orStatement")
    def or_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementOrStatementArgs']]:
        """
        Logical rule statement used to combine other rule statements with OR logic. See `or_statement` below for details.
        """
        return pulumi.get(self, "or_statement")

    @or_statement.setter
    def or_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementOrStatementArgs']]):
        pulumi.set(self, "or_statement", value)

    @property
    @pulumi.getter(name="regexMatchStatement")
    def regex_match_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementArgs']]:
        """
        Rule statement used to search web request components for a match against a single regular expression. See `regex_match_statement` below for details.
        """
        return pulumi.get(self, "regex_match_statement")

    @regex_match_statement.setter
    def regex_match_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementArgs']]):
        pulumi.set(self, "regex_match_statement", value)

    @property
    @pulumi.getter(name="regexPatternSetReferenceStatement")
    def regex_pattern_set_reference_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementArgs']]:
        """
        Rule statement used to search web request components for matches with regular expressions. See `regex_pattern_set_reference_statement` below for details.
        """
        return pulumi.get(self, "regex_pattern_set_reference_statement")

    @regex_pattern_set_reference_statement.setter
    def regex_pattern_set_reference_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementArgs']]):
        pulumi.set(self, "regex_pattern_set_reference_statement", value)

    @property
    @pulumi.getter(name="sizeConstraintStatement")
    def size_constraint_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementArgs']]:
        """
        Rule statement that compares a number of bytes against the size of a request component, using a comparison operator, such as greater than (>) or less than (<). See `size_constraint_statement` below for more details.
        """
        return pulumi.get(self, "size_constraint_statement")

    @size_constraint_statement.setter
    def size_constraint_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementArgs']]):
        pulumi.set(self, "size_constraint_statement", value)

    @property
    @pulumi.getter(name="sqliMatchStatement")
    def sqli_match_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementArgs']]:
        """
        An SQL injection match condition identifies the part of web requests, such as the URI or the query string, that you want AWS WAF to inspect. See `sqli_match_statement` below for details.
        """
        return pulumi.get(self, "sqli_match_statement")

    @sqli_match_statement.setter
    def sqli_match_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementArgs']]):
        pulumi.set(self, "sqli_match_statement", value)

    @property
    @pulumi.getter(name="xssMatchStatement")
    def xss_match_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementArgs']]:
        """
        Rule statement that defines a cross-site scripting (XSS) match search for AWS WAF to apply to web requests. See `xss_match_statement` below for details.
        """
        return pulumi.get(self, "xss_match_statement")

    @xss_match_statement.setter
    def xss_match_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementArgs']]):
        pulumi.set(self, "xss_match_statement", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAndStatementArgs:
    def __init__(__self__, *,
                 statements: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]] statements: The statements to combine.
        """
        pulumi.set(__self__, "statements", statements)

    @property
    @pulumi.getter
    def statements(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")

    @statements.setter
    def statements(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]):
        pulumi.set(self, "statements", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementArgs:
    def __init__(__self__, *,
                 positional_constraint: pulumi.Input[str],
                 search_string: pulumi.Input[str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchArgs']] = None):
        """
        :param pulumi.Input[str] positional_constraint: Area within the portion of a web request that you want AWS WAF to search for `search_string`. Valid values include the following: `EXACTLY`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CONTAINS_WORD`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_ByteMatchStatement.html) for more information.
        :param pulumi.Input[str] search_string: String value that you want AWS WAF to search for. AWS WAF searches only in the part of web requests that you designate for inspection in `field_to_match`. The maximum length of the value is 50 bytes.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchArgs'] field_to_match: Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        pulumi.set(__self__, "positional_constraint", positional_constraint)
        pulumi.set(__self__, "search_string", search_string)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @property
    @pulumi.getter(name="positionalConstraint")
    def positional_constraint(self) -> pulumi.Input[str]:
        """
        Area within the portion of a web request that you want AWS WAF to search for `search_string`. Valid values include the following: `EXACTLY`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CONTAINS_WORD`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_ByteMatchStatement.html) for more information.
        """
        return pulumi.get(self, "positional_constraint")

    @positional_constraint.setter
    def positional_constraint(self, value: pulumi.Input[str]):
        pulumi.set(self, "positional_constraint", value)

    @property
    @pulumi.getter(name="searchString")
    def search_string(self) -> pulumi.Input[str]:
        """
        String value that you want AWS WAF to search for. AWS WAF searches only in the part of web requests that you designate for inspection in `field_to_match`. The maximum length of the value is 50 bytes.
        """
        return pulumi.get(self, "search_string")

    @search_string.setter
    def search_string(self, value: pulumi.Input[str]):
        pulumi.set(self, "search_string", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchArgs']]:
        """
        Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_path: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs'] all_query_arguments: Inspect all query arguments.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgs'] body: Inspect the request body, which immediately follows the request headers. See `body` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgs'] cookies: Inspect the cookies in the web request. See `cookies` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgs']]] header_orders: Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgs']]] headers: Inspect the request headers. See `headers` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgs'] ja3_fingerprint: Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgs'] json_body: Inspect the request body as JSON. See `json_body` for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgs'] method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgs'] query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgs'] single_header: Inspect a single header. See `single_header` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs'] single_query_argument: Inspect a single query argument. See `single_query_argument` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgs'] uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs']]:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgs']]:
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgs']]:
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgs']]]]:
        """
        Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        """
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgs']]]]:
        """
        Inspect the request headers. See `headers` below for details.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgs']]:
        """
        Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        """
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgs']]:
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgs']]:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgs']]:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgs']]:
        """
        Inspect a single header. See `single_header` below for details.
        """
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs']]:
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgs']]:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] oversize_handling: What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs']]] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param pulumi.Input[str] match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs']]]:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_cookies", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs'] match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param pulumi.Input[str] match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs']:
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_headers", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 invalid_fallback_behavior: Optional[pulumi.Input[str]] = None,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs'] match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param pulumi.Input[str] match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param pulumi.Input[str] invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param pulumi.Input[str] oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs']:
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_paths", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementArgs:
    def __init__(__self__, *,
                 country_codes: pulumi.Input[Sequence[pulumi.Input[str]]],
                 forwarded_ip_config: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] country_codes: Array of two-character country codes, for example, [ "US", "CN" ], from the alpha-2 country ISO codes of the `ISO 3166` international standard. See the [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_GeoMatchStatement.html) for valid values.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgs'] forwarded_ip_config: Configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See `forwarded_ip_config` below for details.
        """
        pulumi.set(__self__, "country_codes", country_codes)
        if forwarded_ip_config is not None:
            pulumi.set(__self__, "forwarded_ip_config", forwarded_ip_config)

    @property
    @pulumi.getter(name="countryCodes")
    def country_codes(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Array of two-character country codes, for example, [ "US", "CN" ], from the alpha-2 country ISO codes of the `ISO 3166` international standard. See the [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_GeoMatchStatement.html) for valid values.
        """
        return pulumi.get(self, "country_codes")

    @country_codes.setter
    def country_codes(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "country_codes", value)

    @property
    @pulumi.getter(name="forwardedIpConfig")
    def forwarded_ip_config(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgs']]:
        """
        Configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See `forwarded_ip_config` below for details.
        """
        return pulumi.get(self, "forwarded_ip_config")

    @forwarded_ip_config.setter
    def forwarded_ip_config(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgs']]):
        pulumi.set(self, "forwarded_ip_config", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str],
                 header_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        :param pulumi.Input[str] header_name: Name of the HTTP header to use for the IP address.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> pulumi.Input[str]:
        """
        Name of the HTTP header to use for the IP address.
        """
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "header_name", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[str],
                 ip_set_forwarded_ip_config: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs']] = None):
        """
        :param pulumi.Input[str] arn: The Amazon Resource Name (ARN) of the IP Set that this statement references.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs'] ip_set_forwarded_ip_config: Configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See `ip_set_forwarded_ip_config` below for more details.
        """
        pulumi.set(__self__, "arn", arn)
        if ip_set_forwarded_ip_config is not None:
            pulumi.set(__self__, "ip_set_forwarded_ip_config", ip_set_forwarded_ip_config)

    @property
    @pulumi.getter
    def arn(self) -> pulumi.Input[str]:
        """
        The Amazon Resource Name (ARN) of the IP Set that this statement references.
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "arn", value)

    @property
    @pulumi.getter(name="ipSetForwardedIpConfig")
    def ip_set_forwarded_ip_config(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs']]:
        """
        Configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See `ip_set_forwarded_ip_config` below for more details.
        """
        return pulumi.get(self, "ip_set_forwarded_ip_config")

    @ip_set_forwarded_ip_config.setter
    def ip_set_forwarded_ip_config(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs']]):
        pulumi.set(self, "ip_set_forwarded_ip_config", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str],
                 header_name: pulumi.Input[str],
                 position: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        :param pulumi.Input[str] header_name: Name of the HTTP header to use for the IP address.
        :param pulumi.Input[str] position: Position in the header to search for the IP address. Valid values include: `FIRST`, `LAST`, or `ANY`. If `ANY` is specified and the header contains more than 10 IP addresses, AWS WAFv2 inspects the last 10.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "position", position)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> pulumi.Input[str]:
        """
        Name of the HTTP header to use for the IP address.
        """
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "header_name", value)

    @property
    @pulumi.getter
    def position(self) -> pulumi.Input[str]:
        """
        Position in the header to search for the IP address. Valid values include: `FIRST`, `LAST`, or `ANY`. If `ANY` is specified and the header contains more than 10 IP addresses, AWS WAFv2 inspects the last 10.
        """
        return pulumi.get(self, "position")

    @position.setter
    def position(self, value: pulumi.Input[str]):
        pulumi.set(self, "position", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementLabelMatchStatementArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 scope: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: String to match against.
        :param pulumi.Input[str] scope: Specify whether you want to match using the label name or just the namespace. Valid values are `LABEL` or `NAMESPACE`.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        String to match against.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def scope(self) -> pulumi.Input[str]:
        """
        Specify whether you want to match using the label name or just the namespace. Valid values are `LABEL` or `NAMESPACE`.
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "scope", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementNotStatementArgs:
    def __init__(__self__, *,
                 statements: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]] statements: The statements to combine.
        """
        pulumi.set(__self__, "statements", statements)

    @property
    @pulumi.getter
    def statements(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")

    @statements.setter
    def statements(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]):
        pulumi.set(self, "statements", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementOrStatementArgs:
    def __init__(__self__, *,
                 statements: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]] statements: The statements to combine.
        """
        pulumi.set(__self__, "statements", statements)

    @property
    @pulumi.getter
    def statements(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")

    @statements.setter
    def statements(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]):
        pulumi.set(self, "statements", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementArgs:
    def __init__(__self__, *,
                 regex_string: pulumi.Input[str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchArgs']] = None):
        """
        :param pulumi.Input[str] regex_string: String representing the regular expression. Minimum of `1` and maximum of `512` characters.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchArgs'] field_to_match: The part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        pulumi.set(__self__, "regex_string", regex_string)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @property
    @pulumi.getter(name="regexString")
    def regex_string(self) -> pulumi.Input[str]:
        """
        String representing the regular expression. Minimum of `1` and maximum of `512` characters.
        """
        return pulumi.get(self, "regex_string")

    @regex_string.setter
    def regex_string(self, value: pulumi.Input[str]):
        pulumi.set(self, "regex_string", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchArgs']]:
        """
        The part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_path: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs'] all_query_arguments: Inspect all query arguments.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgs'] body: Inspect the request body, which immediately follows the request headers. See `body` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgs'] cookies: Inspect the cookies in the web request. See `cookies` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgs']]] header_orders: Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgs']]] headers: Inspect the request headers. See `headers` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs'] ja3_fingerprint: Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgs'] json_body: Inspect the request body as JSON. See `json_body` for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgs'] method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgs'] query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgs'] single_header: Inspect a single header. See `single_header` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs'] single_query_argument: Inspect a single query argument. See `single_query_argument` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgs'] uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs']]:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgs']]:
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgs']]:
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgs']]]]:
        """
        Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        """
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgs']]]]:
        """
        Inspect the request headers. See `headers` below for details.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs']]:
        """
        Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        """
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgs']]:
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgs']]:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgs']]:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgs']]:
        """
        Inspect a single header. See `single_header` below for details.
        """
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs']]:
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgs']]:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] oversize_handling: What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs']]] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param pulumi.Input[str] match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs']]]:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_cookies", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs'] match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param pulumi.Input[str] match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs']:
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_headers", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 invalid_fallback_behavior: Optional[pulumi.Input[str]] = None,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs'] match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param pulumi.Input[str] match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param pulumi.Input[str] invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param pulumi.Input[str] oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs']:
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_paths", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgs']] = None):
        """
        :param pulumi.Input[str] arn: The Amazon Resource Name (ARN) of the Regex Pattern Set that this statement references.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgs'] field_to_match: Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @property
    @pulumi.getter
    def arn(self) -> pulumi.Input[str]:
        """
        The Amazon Resource Name (ARN) of the Regex Pattern Set that this statement references.
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "arn", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgs']]:
        """
        Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_path: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs'] all_query_arguments: Inspect all query arguments.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs'] body: Inspect the request body, which immediately follows the request headers. See `body` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs'] cookies: Inspect the cookies in the web request. See `cookies` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs']]] header_orders: Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs']]] headers: Inspect the request headers. See `headers` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs'] ja3_fingerprint: Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs'] json_body: Inspect the request body as JSON. See `json_body` for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs'] method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs'] query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs'] single_header: Inspect a single header. See `single_header` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs'] single_query_argument: Inspect a single query argument. See `single_query_argument` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs'] uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs']]:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs']]:
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs']]:
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs']]]]:
        """
        Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        """
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs']]]]:
        """
        Inspect the request headers. See `headers` below for details.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs']]:
        """
        Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        """
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs']]:
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs']]:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs']]:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs']]:
        """
        Inspect a single header. See `single_header` below for details.
        """
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs']]:
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs']]:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] oversize_handling: What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs']]] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param pulumi.Input[str] match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs']]]:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_cookies", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs'] match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param pulumi.Input[str] match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs']:
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_headers", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 invalid_fallback_behavior: Optional[pulumi.Input[str]] = None,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs'] match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param pulumi.Input[str] match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param pulumi.Input[str] invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param pulumi.Input[str] oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs']:
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_paths", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementArgs:
    def __init__(__self__, *,
                 comparison_operator: pulumi.Input[str],
                 size: pulumi.Input[int],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgs']] = None):
        """
        :param pulumi.Input[str] comparison_operator: Operator to use to compare the request part to the size setting. Valid values include: `EQ`, `NE`, `LE`, `LT`, `GE`, or `GT`.
        :param pulumi.Input[int] size: Size, in bytes, to compare to the request part, after any transformations. Valid values are integers between 0 and 21474836480, inclusive.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgs'] field_to_match: Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        pulumi.set(__self__, "comparison_operator", comparison_operator)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> pulumi.Input[str]:
        """
        Operator to use to compare the request part to the size setting. Valid values include: `EQ`, `NE`, `LE`, `LT`, `GE`, or `GT`.
        """
        return pulumi.get(self, "comparison_operator")

    @comparison_operator.setter
    def comparison_operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "comparison_operator", value)

    @property
    @pulumi.getter
    def size(self) -> pulumi.Input[int]:
        """
        Size, in bytes, to compare to the request part, after any transformations. Valid values are integers between 0 and 21474836480, inclusive.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[int]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgs']]:
        """
        Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_path: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs'] all_query_arguments: Inspect all query arguments.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgs'] body: Inspect the request body, which immediately follows the request headers. See `body` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgs'] cookies: Inspect the cookies in the web request. See `cookies` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs']]] header_orders: Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgs']]] headers: Inspect the request headers. See `headers` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs'] ja3_fingerprint: Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgs'] json_body: Inspect the request body as JSON. See `json_body` for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgs'] method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgs'] query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs'] single_header: Inspect a single header. See `single_header` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs'] single_query_argument: Inspect a single query argument. See `single_query_argument` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgs'] uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs']]:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgs']]:
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgs']]:
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs']]]]:
        """
        Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        """
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgs']]]]:
        """
        Inspect the request headers. See `headers` below for details.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs']]:
        """
        Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        """
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgs']]:
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgs']]:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgs']]:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs']]:
        """
        Inspect a single header. See `single_header` below for details.
        """
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs']]:
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgs']]:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] oversize_handling: What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs']]] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param pulumi.Input[str] match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs']]]:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_cookies", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs'] match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param pulumi.Input[str] match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs']:
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_headers", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 invalid_fallback_behavior: Optional[pulumi.Input[str]] = None,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs'] match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param pulumi.Input[str] match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param pulumi.Input[str] invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param pulumi.Input[str] oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs']:
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_paths", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementArgs:
    def __init__(__self__, *,
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchArgs'] field_to_match: Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchArgs']]:
        """
        Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_path: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs'] all_query_arguments: Inspect all query arguments.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgs'] body: Inspect the request body, which immediately follows the request headers. See `body` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgs'] cookies: Inspect the cookies in the web request. See `cookies` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgs']]] header_orders: Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgs']]] headers: Inspect the request headers. See `headers` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs'] ja3_fingerprint: Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgs'] json_body: Inspect the request body as JSON. See `json_body` for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgs'] method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgs'] query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgs'] single_header: Inspect a single header. See `single_header` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs'] single_query_argument: Inspect a single query argument. See `single_query_argument` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgs'] uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs']]:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgs']]:
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgs']]:
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgs']]]]:
        """
        Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        """
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgs']]]]:
        """
        Inspect the request headers. See `headers` below for details.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs']]:
        """
        Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        """
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgs']]:
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgs']]:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgs']]:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgs']]:
        """
        Inspect a single header. See `single_header` below for details.
        """
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs']]:
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgs']]:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] oversize_handling: What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs']]] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param pulumi.Input[str] match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs']]]:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_cookies", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs'] match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param pulumi.Input[str] match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs']:
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_headers", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 invalid_fallback_behavior: Optional[pulumi.Input[str]] = None,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs'] match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param pulumi.Input[str] match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param pulumi.Input[str] invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param pulumi.Input[str] oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs']:
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_paths", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementArgs:
    def __init__(__self__, *,
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchArgs'] field_to_match: Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchArgs']]:
        """
        Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_path: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs'] all_query_arguments: Inspect all query arguments.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgs'] body: Inspect the request body, which immediately follows the request headers. See `body` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgs'] cookies: Inspect the cookies in the web request. See `cookies` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgs']]] header_orders: Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgs']]] headers: Inspect the request headers. See `headers` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgs'] ja3_fingerprint: Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgs'] json_body: Inspect the request body as JSON. See `json_body` for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgs'] method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgs'] query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgs'] single_header: Inspect a single header. See `single_header` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs'] single_query_argument: Inspect a single query argument. See `single_query_argument` below for details.
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgs'] uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs']]:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgs']]:
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgs']]:
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgs']]]]:
        """
        Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        """
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgs']]]]:
        """
        Inspect the request headers. See `headers` below for details.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgs']]:
        """
        Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        """
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgs']]:
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgs']]:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgs']]:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgs']]:
        """
        Inspect a single header. See `single_header` below for details.
        """
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs']]:
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgs']]:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] oversize_handling: What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs']]] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param pulumi.Input[str] match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs']]]:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_cookies", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs'] match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param pulumi.Input[str] match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs']:
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_headers", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 invalid_fallback_behavior: Optional[pulumi.Input[str]] = None,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs'] match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param pulumi.Input[str] match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param pulumi.Input[str] invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param pulumi.Input[str] oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs']:
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_paths", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class WebAclRuleStatementNotStatementArgs:
    def __init__(__self__, *,
                 statements: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]] statements: The statements to combine.
        """
        pulumi.set(__self__, "statements", statements)

    @property
    @pulumi.getter
    def statements(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")

    @statements.setter
    def statements(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]):
        pulumi.set(self, "statements", value)


@pulumi.input_type
class WebAclRuleStatementOrStatementArgs:
    def __init__(__self__, *,
                 statements: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]] statements: The statements to combine.
        """
        pulumi.set(__self__, "statements", statements)

    @property
    @pulumi.getter
    def statements(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")

    @statements.setter
    def statements(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]):
        pulumi.set(self, "statements", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementArgs:
    def __init__(__self__, *,
                 limit: pulumi.Input[int],
                 aggregate_key_type: Optional[pulumi.Input[str]] = None,
                 custom_keys: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyArgs']]]] = None,
                 forwarded_ip_config: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementForwardedIpConfigArgs']] = None,
                 scope_down_statement: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementArgs']] = None):
        """
        :param pulumi.Input[int] limit: Limit on requests per 5-minute period for a single originating IP address.
        :param pulumi.Input[str] aggregate_key_type: Setting that indicates how to aggregate the request counts. Valid values include: `CONSTANT`, `CUSTOM_KEYS`, `FORWARDED_IP`, or `IP`. Default: `IP`.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyArgs']]] custom_keys: Aggregate the request counts using one or more web request components as the aggregate keys. See `custom_key` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementForwardedIpConfigArgs'] forwarded_ip_config: Configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. If `aggregate_key_type` is set to `FORWARDED_IP`, this block is required. See `forwarded_ip_config` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementArgs'] scope_down_statement: Optional nested statement that narrows the scope of the rate-based statement to matching web requests. This can be any nestable statement, and you can nest statements at any level below this scope-down statement. See `statement` above for details. If `aggregate_key_type` is set to `CONSTANT`, this block is required.
        """
        pulumi.set(__self__, "limit", limit)
        if aggregate_key_type is not None:
            pulumi.set(__self__, "aggregate_key_type", aggregate_key_type)
        if custom_keys is not None:
            pulumi.set(__self__, "custom_keys", custom_keys)
        if forwarded_ip_config is not None:
            pulumi.set(__self__, "forwarded_ip_config", forwarded_ip_config)
        if scope_down_statement is not None:
            pulumi.set(__self__, "scope_down_statement", scope_down_statement)

    @property
    @pulumi.getter
    def limit(self) -> pulumi.Input[int]:
        """
        Limit on requests per 5-minute period for a single originating IP address.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: pulumi.Input[int]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="aggregateKeyType")
    def aggregate_key_type(self) -> Optional[pulumi.Input[str]]:
        """
        Setting that indicates how to aggregate the request counts. Valid values include: `CONSTANT`, `CUSTOM_KEYS`, `FORWARDED_IP`, or `IP`. Default: `IP`.
        """
        return pulumi.get(self, "aggregate_key_type")

    @aggregate_key_type.setter
    def aggregate_key_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregate_key_type", value)

    @property
    @pulumi.getter(name="customKeys")
    def custom_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyArgs']]]]:
        """
        Aggregate the request counts using one or more web request components as the aggregate keys. See `custom_key` below for details.
        """
        return pulumi.get(self, "custom_keys")

    @custom_keys.setter
    def custom_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyArgs']]]]):
        pulumi.set(self, "custom_keys", value)

    @property
    @pulumi.getter(name="forwardedIpConfig")
    def forwarded_ip_config(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementForwardedIpConfigArgs']]:
        """
        Configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. If `aggregate_key_type` is set to `FORWARDED_IP`, this block is required. See `forwarded_ip_config` below for details.
        """
        return pulumi.get(self, "forwarded_ip_config")

    @forwarded_ip_config.setter
    def forwarded_ip_config(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementForwardedIpConfigArgs']]):
        pulumi.set(self, "forwarded_ip_config", value)

    @property
    @pulumi.getter(name="scopeDownStatement")
    def scope_down_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementArgs']]:
        """
        Optional nested statement that narrows the scope of the rate-based statement to matching web requests. This can be any nestable statement, and you can nest statements at any level below this scope-down statement. See `statement` above for details. If `aggregate_key_type` is set to `CONSTANT`, this block is required.
        """
        return pulumi.get(self, "scope_down_statement")

    @scope_down_statement.setter
    def scope_down_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementArgs']]):
        pulumi.set(self, "scope_down_statement", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementCustomKeyArgs:
    def __init__(__self__, *,
                 cookie: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyCookieArgs']] = None,
                 forwarded_ip: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyForwardedIpArgs']] = None,
                 header: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyHeaderArgs']] = None,
                 http_method: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyHttpMethodArgs']] = None,
                 ip: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyIpArgs']] = None,
                 label_namespace: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyLabelNamespaceArgs']] = None,
                 query_argument: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyQueryArgumentArgs']] = None,
                 query_string: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyQueryStringArgs']] = None,
                 uri_path: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyUriPathArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyCookieArgs'] cookie: Use the value of a cookie in the request as an aggregate key. See RateLimit `cookie` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyForwardedIpArgs'] forwarded_ip: Use the first IP address in an HTTP header as an aggregate key. See `forwarded_ip` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyHeaderArgs'] header: Use the value of a header in the request as an aggregate key. See RateLimit `header` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyHttpMethodArgs'] http_method: Use the request's HTTP method as an aggregate key. See RateLimit `http_method` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyIpArgs'] ip: Use the request's originating IP address as an aggregate key. See `RateLimit ip` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyLabelNamespaceArgs'] label_namespace: Use the specified label namespace as an aggregate key. See RateLimit `label_namespace` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyQueryArgumentArgs'] query_argument: Use the specified query argument as an aggregate key. See RateLimit `query_argument` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyQueryStringArgs'] query_string: Use the request's query string as an aggregate key. See RateLimit `query_string` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyUriPathArgs'] uri_path: Use the request's URI path as an aggregate key. See RateLimit `uri_path` below for details.
        """
        if cookie is not None:
            pulumi.set(__self__, "cookie", cookie)
        if forwarded_ip is not None:
            pulumi.set(__self__, "forwarded_ip", forwarded_ip)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if http_method is not None:
            pulumi.set(__self__, "http_method", http_method)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if label_namespace is not None:
            pulumi.set(__self__, "label_namespace", label_namespace)
        if query_argument is not None:
            pulumi.set(__self__, "query_argument", query_argument)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter
    def cookie(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyCookieArgs']]:
        """
        Use the value of a cookie in the request as an aggregate key. See RateLimit `cookie` below for details.
        """
        return pulumi.get(self, "cookie")

    @cookie.setter
    def cookie(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyCookieArgs']]):
        pulumi.set(self, "cookie", value)

    @property
    @pulumi.getter(name="forwardedIp")
    def forwarded_ip(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyForwardedIpArgs']]:
        """
        Use the first IP address in an HTTP header as an aggregate key. See `forwarded_ip` below for details.
        """
        return pulumi.get(self, "forwarded_ip")

    @forwarded_ip.setter
    def forwarded_ip(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyForwardedIpArgs']]):
        pulumi.set(self, "forwarded_ip", value)

    @property
    @pulumi.getter
    def header(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyHeaderArgs']]:
        """
        Use the value of a header in the request as an aggregate key. See RateLimit `header` below for details.
        """
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyHeaderArgs']]):
        pulumi.set(self, "header", value)

    @property
    @pulumi.getter(name="httpMethod")
    def http_method(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyHttpMethodArgs']]:
        """
        Use the request's HTTP method as an aggregate key. See RateLimit `http_method` below for details.
        """
        return pulumi.get(self, "http_method")

    @http_method.setter
    def http_method(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyHttpMethodArgs']]):
        pulumi.set(self, "http_method", value)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyIpArgs']]:
        """
        Use the request's originating IP address as an aggregate key. See `RateLimit ip` below for details.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyIpArgs']]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter(name="labelNamespace")
    def label_namespace(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyLabelNamespaceArgs']]:
        """
        Use the specified label namespace as an aggregate key. See RateLimit `label_namespace` below for details.
        """
        return pulumi.get(self, "label_namespace")

    @label_namespace.setter
    def label_namespace(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyLabelNamespaceArgs']]):
        pulumi.set(self, "label_namespace", value)

    @property
    @pulumi.getter(name="queryArgument")
    def query_argument(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyQueryArgumentArgs']]:
        """
        Use the specified query argument as an aggregate key. See RateLimit `query_argument` below for details.
        """
        return pulumi.get(self, "query_argument")

    @query_argument.setter
    def query_argument(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyQueryArgumentArgs']]):
        pulumi.set(self, "query_argument", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyQueryStringArgs']]:
        """
        Use the request's query string as an aggregate key. See RateLimit `query_string` below for details.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyUriPathArgs']]:
        """
        Use the request's URI path as an aggregate key. See RateLimit `uri_path` below for details.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementCustomKeyCookieArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyCookieTextTransformationArgs']]]):
        """
        :param pulumi.Input[str] name: The name of the cookie to use.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyCookieTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. They are used in rate-based rule statements, to transform request components before using them as custom aggregation keys. Atleast one transformation is required. See `text_transformation` above for details.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the cookie to use.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyCookieTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. They are used in rate-based rule statements, to transform request components before using them as custom aggregation keys. Atleast one transformation is required. See `text_transformation` above for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyCookieTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementCustomKeyCookieTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementCustomKeyForwardedIpArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementCustomKeyHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyHeaderTextTransformationArgs']]]):
        """
        :param pulumi.Input[str] name: The name of the header to use.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyHeaderTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. They are used in rate-based rule statements, to transform request components before using them as custom aggregation keys. Atleast one transformation is required. See `text_transformation` above for details.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the header to use.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyHeaderTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. They are used in rate-based rule statements, to transform request components before using them as custom aggregation keys. Atleast one transformation is required. See `text_transformation` above for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyHeaderTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementCustomKeyHeaderTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementCustomKeyHttpMethodArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementCustomKeyIpArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementCustomKeyLabelNamespaceArgs:
    def __init__(__self__, *,
                 namespace: pulumi.Input[str]):
        """
        :param pulumi.Input[str] namespace: The namespace to use for aggregation
        """
        pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[str]:
        """
        The namespace to use for aggregation
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[str]):
        pulumi.set(self, "namespace", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementCustomKeyQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformationArgs']]]):
        """
        :param pulumi.Input[str] name: The name of the query argument to use.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. They are used in rate-based rule statements, to transform request components before using them as custom aggregation keys. Atleast one transformation is required. See `text_transformation` above for details.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query argument to use.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. They are used in rate-based rule statements, to transform request components before using them as custom aggregation keys. Atleast one transformation is required. See `text_transformation` above for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementCustomKeyQueryStringArgs:
    def __init__(__self__, *,
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformationArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. They are used in rate-based rule statements, to transform request components before using them as custom aggregation keys. Atleast one transformation is required. See `text_transformation` above for details.
        """
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. They are used in rate-based rule statements, to transform request components before using them as custom aggregation keys. Atleast one transformation is required. See `text_transformation` above for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementCustomKeyUriPathArgs:
    def __init__(__self__, *,
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyUriPathTextTransformationArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyUriPathTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. They are used in rate-based rule statements, to transform request components before using them as custom aggregation keys. Atleast one transformation is required. See `text_transformation` above for details.
        """
        pulumi.set(__self__, "text_transformations", text_transformations)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyUriPathTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. They are used in rate-based rule statements, to transform request components before using them as custom aggregation keys. Atleast one transformation is required. See `text_transformation` above for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyUriPathTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementCustomKeyUriPathTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementForwardedIpConfigArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str],
                 header_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        :param pulumi.Input[str] header_name: Name of the HTTP header to use for the IP address.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> pulumi.Input[str]:
        """
        Name of the HTTP header to use for the IP address.
        """
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "header_name", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementArgs:
    def __init__(__self__, *,
                 and_statement: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementAndStatementArgs']] = None,
                 byte_match_statement: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementArgs']] = None,
                 geo_match_statement: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementArgs']] = None,
                 ip_set_reference_statement: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementArgs']] = None,
                 label_match_statement: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatementArgs']] = None,
                 not_statement: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementNotStatementArgs']] = None,
                 or_statement: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementOrStatementArgs']] = None,
                 regex_match_statement: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementArgs']] = None,
                 regex_pattern_set_reference_statement: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementArgs']] = None,
                 size_constraint_statement: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementArgs']] = None,
                 sqli_match_statement: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementArgs']] = None,
                 xss_match_statement: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementAndStatementArgs'] and_statement: Logical rule statement used to combine other rule statements with AND logic. See `and_statement` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementArgs'] byte_match_statement: Rule statement that defines a string match search for AWS WAF to apply to web requests. See `byte_match_statement` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementArgs'] geo_match_statement: Rule statement used to identify web requests based on country of origin. See `geo_match_statement` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementArgs'] ip_set_reference_statement: Rule statement used to detect web requests coming from particular IP addresses or address ranges. See `ip_set_reference_statement` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatementArgs'] label_match_statement: Rule statement that defines a string match search against labels that have been added to the web request by rules that have already run in the web ACL. See `label_match_statement` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementNotStatementArgs'] not_statement: Logical rule statement used to negate the results of another rule statement. See `not_statement` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementOrStatementArgs'] or_statement: Logical rule statement used to combine other rule statements with OR logic. See `or_statement` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementArgs'] regex_match_statement: Rule statement used to search web request components for a match against a single regular expression. See `regex_match_statement` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementArgs'] regex_pattern_set_reference_statement: Rule statement used to search web request components for matches with regular expressions. See `regex_pattern_set_reference_statement` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementArgs'] size_constraint_statement: Rule statement that compares a number of bytes against the size of a request component, using a comparison operator, such as greater than (>) or less than (<). See `size_constraint_statement` below for more details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementArgs'] sqli_match_statement: An SQL injection match condition identifies the part of web requests, such as the URI or the query string, that you want AWS WAF to inspect. See `sqli_match_statement` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementArgs'] xss_match_statement: Rule statement that defines a cross-site scripting (XSS) match search for AWS WAF to apply to web requests. See `xss_match_statement` below for details.
        """
        if and_statement is not None:
            pulumi.set(__self__, "and_statement", and_statement)
        if byte_match_statement is not None:
            pulumi.set(__self__, "byte_match_statement", byte_match_statement)
        if geo_match_statement is not None:
            pulumi.set(__self__, "geo_match_statement", geo_match_statement)
        if ip_set_reference_statement is not None:
            pulumi.set(__self__, "ip_set_reference_statement", ip_set_reference_statement)
        if label_match_statement is not None:
            pulumi.set(__self__, "label_match_statement", label_match_statement)
        if not_statement is not None:
            pulumi.set(__self__, "not_statement", not_statement)
        if or_statement is not None:
            pulumi.set(__self__, "or_statement", or_statement)
        if regex_match_statement is not None:
            pulumi.set(__self__, "regex_match_statement", regex_match_statement)
        if regex_pattern_set_reference_statement is not None:
            pulumi.set(__self__, "regex_pattern_set_reference_statement", regex_pattern_set_reference_statement)
        if size_constraint_statement is not None:
            pulumi.set(__self__, "size_constraint_statement", size_constraint_statement)
        if sqli_match_statement is not None:
            pulumi.set(__self__, "sqli_match_statement", sqli_match_statement)
        if xss_match_statement is not None:
            pulumi.set(__self__, "xss_match_statement", xss_match_statement)

    @property
    @pulumi.getter(name="andStatement")
    def and_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementAndStatementArgs']]:
        """
        Logical rule statement used to combine other rule statements with AND logic. See `and_statement` below for details.
        """
        return pulumi.get(self, "and_statement")

    @and_statement.setter
    def and_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementAndStatementArgs']]):
        pulumi.set(self, "and_statement", value)

    @property
    @pulumi.getter(name="byteMatchStatement")
    def byte_match_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementArgs']]:
        """
        Rule statement that defines a string match search for AWS WAF to apply to web requests. See `byte_match_statement` below for details.
        """
        return pulumi.get(self, "byte_match_statement")

    @byte_match_statement.setter
    def byte_match_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementArgs']]):
        pulumi.set(self, "byte_match_statement", value)

    @property
    @pulumi.getter(name="geoMatchStatement")
    def geo_match_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementArgs']]:
        """
        Rule statement used to identify web requests based on country of origin. See `geo_match_statement` below for details.
        """
        return pulumi.get(self, "geo_match_statement")

    @geo_match_statement.setter
    def geo_match_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementArgs']]):
        pulumi.set(self, "geo_match_statement", value)

    @property
    @pulumi.getter(name="ipSetReferenceStatement")
    def ip_set_reference_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementArgs']]:
        """
        Rule statement used to detect web requests coming from particular IP addresses or address ranges. See `ip_set_reference_statement` below for details.
        """
        return pulumi.get(self, "ip_set_reference_statement")

    @ip_set_reference_statement.setter
    def ip_set_reference_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementArgs']]):
        pulumi.set(self, "ip_set_reference_statement", value)

    @property
    @pulumi.getter(name="labelMatchStatement")
    def label_match_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatementArgs']]:
        """
        Rule statement that defines a string match search against labels that have been added to the web request by rules that have already run in the web ACL. See `label_match_statement` below for details.
        """
        return pulumi.get(self, "label_match_statement")

    @label_match_statement.setter
    def label_match_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatementArgs']]):
        pulumi.set(self, "label_match_statement", value)

    @property
    @pulumi.getter(name="notStatement")
    def not_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementNotStatementArgs']]:
        """
        Logical rule statement used to negate the results of another rule statement. See `not_statement` below for details.
        """
        return pulumi.get(self, "not_statement")

    @not_statement.setter
    def not_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementNotStatementArgs']]):
        pulumi.set(self, "not_statement", value)

    @property
    @pulumi.getter(name="orStatement")
    def or_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementOrStatementArgs']]:
        """
        Logical rule statement used to combine other rule statements with OR logic. See `or_statement` below for details.
        """
        return pulumi.get(self, "or_statement")

    @or_statement.setter
    def or_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementOrStatementArgs']]):
        pulumi.set(self, "or_statement", value)

    @property
    @pulumi.getter(name="regexMatchStatement")
    def regex_match_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementArgs']]:
        """
        Rule statement used to search web request components for a match against a single regular expression. See `regex_match_statement` below for details.
        """
        return pulumi.get(self, "regex_match_statement")

    @regex_match_statement.setter
    def regex_match_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementArgs']]):
        pulumi.set(self, "regex_match_statement", value)

    @property
    @pulumi.getter(name="regexPatternSetReferenceStatement")
    def regex_pattern_set_reference_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementArgs']]:
        """
        Rule statement used to search web request components for matches with regular expressions. See `regex_pattern_set_reference_statement` below for details.
        """
        return pulumi.get(self, "regex_pattern_set_reference_statement")

    @regex_pattern_set_reference_statement.setter
    def regex_pattern_set_reference_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementArgs']]):
        pulumi.set(self, "regex_pattern_set_reference_statement", value)

    @property
    @pulumi.getter(name="sizeConstraintStatement")
    def size_constraint_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementArgs']]:
        """
        Rule statement that compares a number of bytes against the size of a request component, using a comparison operator, such as greater than (>) or less than (<). See `size_constraint_statement` below for more details.
        """
        return pulumi.get(self, "size_constraint_statement")

    @size_constraint_statement.setter
    def size_constraint_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementArgs']]):
        pulumi.set(self, "size_constraint_statement", value)

    @property
    @pulumi.getter(name="sqliMatchStatement")
    def sqli_match_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementArgs']]:
        """
        An SQL injection match condition identifies the part of web requests, such as the URI or the query string, that you want AWS WAF to inspect. See `sqli_match_statement` below for details.
        """
        return pulumi.get(self, "sqli_match_statement")

    @sqli_match_statement.setter
    def sqli_match_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementArgs']]):
        pulumi.set(self, "sqli_match_statement", value)

    @property
    @pulumi.getter(name="xssMatchStatement")
    def xss_match_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementArgs']]:
        """
        Rule statement that defines a cross-site scripting (XSS) match search for AWS WAF to apply to web requests. See `xss_match_statement` below for details.
        """
        return pulumi.get(self, "xss_match_statement")

    @xss_match_statement.setter
    def xss_match_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementArgs']]):
        pulumi.set(self, "xss_match_statement", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementAndStatementArgs:
    def __init__(__self__, *,
                 statements: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]] statements: The statements to combine.
        """
        pulumi.set(__self__, "statements", statements)

    @property
    @pulumi.getter
    def statements(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")

    @statements.setter
    def statements(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]):
        pulumi.set(self, "statements", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementArgs:
    def __init__(__self__, *,
                 positional_constraint: pulumi.Input[str],
                 search_string: pulumi.Input[str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchArgs']] = None):
        """
        :param pulumi.Input[str] positional_constraint: Area within the portion of a web request that you want AWS WAF to search for `search_string`. Valid values include the following: `EXACTLY`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CONTAINS_WORD`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_ByteMatchStatement.html) for more information.
        :param pulumi.Input[str] search_string: String value that you want AWS WAF to search for. AWS WAF searches only in the part of web requests that you designate for inspection in `field_to_match`. The maximum length of the value is 50 bytes.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchArgs'] field_to_match: Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        pulumi.set(__self__, "positional_constraint", positional_constraint)
        pulumi.set(__self__, "search_string", search_string)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @property
    @pulumi.getter(name="positionalConstraint")
    def positional_constraint(self) -> pulumi.Input[str]:
        """
        Area within the portion of a web request that you want AWS WAF to search for `search_string`. Valid values include the following: `EXACTLY`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CONTAINS_WORD`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_ByteMatchStatement.html) for more information.
        """
        return pulumi.get(self, "positional_constraint")

    @positional_constraint.setter
    def positional_constraint(self, value: pulumi.Input[str]):
        pulumi.set(self, "positional_constraint", value)

    @property
    @pulumi.getter(name="searchString")
    def search_string(self) -> pulumi.Input[str]:
        """
        String value that you want AWS WAF to search for. AWS WAF searches only in the part of web requests that you designate for inspection in `field_to_match`. The maximum length of the value is 50 bytes.
        """
        return pulumi.get(self, "search_string")

    @search_string.setter
    def search_string(self, value: pulumi.Input[str]):
        pulumi.set(self, "search_string", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchArgs']]:
        """
        Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_path: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs'] all_query_arguments: Inspect all query arguments.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgs'] body: Inspect the request body, which immediately follows the request headers. See `body` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgs'] cookies: Inspect the cookies in the web request. See `cookies` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgs']]] header_orders: Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgs']]] headers: Inspect the request headers. See `headers` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgs'] ja3_fingerprint: Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgs'] json_body: Inspect the request body as JSON. See `json_body` for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgs'] method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgs'] query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgs'] single_header: Inspect a single header. See `single_header` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs'] single_query_argument: Inspect a single query argument. See `single_query_argument` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgs'] uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs']]:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgs']]:
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgs']]:
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgs']]]]:
        """
        Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        """
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgs']]]]:
        """
        Inspect the request headers. See `headers` below for details.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgs']]:
        """
        Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        """
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgs']]:
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgs']]:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgs']]:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgs']]:
        """
        Inspect a single header. See `single_header` below for details.
        """
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs']]:
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgs']]:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] oversize_handling: What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs']]] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param pulumi.Input[str] match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs']]]:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_cookies", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs'] match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param pulumi.Input[str] match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs']:
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_headers", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 invalid_fallback_behavior: Optional[pulumi.Input[str]] = None,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs'] match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param pulumi.Input[str] match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param pulumi.Input[str] invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param pulumi.Input[str] oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs']:
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_paths", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementArgs:
    def __init__(__self__, *,
                 country_codes: pulumi.Input[Sequence[pulumi.Input[str]]],
                 forwarded_ip_config: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] country_codes: Array of two-character country codes, for example, [ "US", "CN" ], from the alpha-2 country ISO codes of the `ISO 3166` international standard. See the [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_GeoMatchStatement.html) for valid values.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgs'] forwarded_ip_config: Configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See `forwarded_ip_config` below for details.
        """
        pulumi.set(__self__, "country_codes", country_codes)
        if forwarded_ip_config is not None:
            pulumi.set(__self__, "forwarded_ip_config", forwarded_ip_config)

    @property
    @pulumi.getter(name="countryCodes")
    def country_codes(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Array of two-character country codes, for example, [ "US", "CN" ], from the alpha-2 country ISO codes of the `ISO 3166` international standard. See the [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_GeoMatchStatement.html) for valid values.
        """
        return pulumi.get(self, "country_codes")

    @country_codes.setter
    def country_codes(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "country_codes", value)

    @property
    @pulumi.getter(name="forwardedIpConfig")
    def forwarded_ip_config(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgs']]:
        """
        Configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See `forwarded_ip_config` below for details.
        """
        return pulumi.get(self, "forwarded_ip_config")

    @forwarded_ip_config.setter
    def forwarded_ip_config(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgs']]):
        pulumi.set(self, "forwarded_ip_config", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str],
                 header_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        :param pulumi.Input[str] header_name: Name of the HTTP header to use for the IP address.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> pulumi.Input[str]:
        """
        Name of the HTTP header to use for the IP address.
        """
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "header_name", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[str],
                 ip_set_forwarded_ip_config: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs']] = None):
        """
        :param pulumi.Input[str] arn: The Amazon Resource Name (ARN) of the IP Set that this statement references.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs'] ip_set_forwarded_ip_config: Configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See `ip_set_forwarded_ip_config` below for more details.
        """
        pulumi.set(__self__, "arn", arn)
        if ip_set_forwarded_ip_config is not None:
            pulumi.set(__self__, "ip_set_forwarded_ip_config", ip_set_forwarded_ip_config)

    @property
    @pulumi.getter
    def arn(self) -> pulumi.Input[str]:
        """
        The Amazon Resource Name (ARN) of the IP Set that this statement references.
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "arn", value)

    @property
    @pulumi.getter(name="ipSetForwardedIpConfig")
    def ip_set_forwarded_ip_config(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs']]:
        """
        Configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See `ip_set_forwarded_ip_config` below for more details.
        """
        return pulumi.get(self, "ip_set_forwarded_ip_config")

    @ip_set_forwarded_ip_config.setter
    def ip_set_forwarded_ip_config(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs']]):
        pulumi.set(self, "ip_set_forwarded_ip_config", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str],
                 header_name: pulumi.Input[str],
                 position: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        :param pulumi.Input[str] header_name: Name of the HTTP header to use for the IP address.
        :param pulumi.Input[str] position: Position in the header to search for the IP address. Valid values include: `FIRST`, `LAST`, or `ANY`. If `ANY` is specified and the header contains more than 10 IP addresses, AWS WAFv2 inspects the last 10.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "position", position)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> pulumi.Input[str]:
        """
        Name of the HTTP header to use for the IP address.
        """
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "header_name", value)

    @property
    @pulumi.getter
    def position(self) -> pulumi.Input[str]:
        """
        Position in the header to search for the IP address. Valid values include: `FIRST`, `LAST`, or `ANY`. If `ANY` is specified and the header contains more than 10 IP addresses, AWS WAFv2 inspects the last 10.
        """
        return pulumi.get(self, "position")

    @position.setter
    def position(self, value: pulumi.Input[str]):
        pulumi.set(self, "position", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatementArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 scope: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: String to match against.
        :param pulumi.Input[str] scope: Specify whether you want to match using the label name or just the namespace. Valid values are `LABEL` or `NAMESPACE`.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        String to match against.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def scope(self) -> pulumi.Input[str]:
        """
        Specify whether you want to match using the label name or just the namespace. Valid values are `LABEL` or `NAMESPACE`.
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "scope", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementNotStatementArgs:
    def __init__(__self__, *,
                 statements: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]] statements: The statements to combine.
        """
        pulumi.set(__self__, "statements", statements)

    @property
    @pulumi.getter
    def statements(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")

    @statements.setter
    def statements(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]):
        pulumi.set(self, "statements", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementOrStatementArgs:
    def __init__(__self__, *,
                 statements: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]] statements: The statements to combine.
        """
        pulumi.set(__self__, "statements", statements)

    @property
    @pulumi.getter
    def statements(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")

    @statements.setter
    def statements(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]):
        pulumi.set(self, "statements", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementArgs:
    def __init__(__self__, *,
                 regex_string: pulumi.Input[str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchArgs']] = None):
        """
        :param pulumi.Input[str] regex_string: String representing the regular expression. Minimum of `1` and maximum of `512` characters.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchArgs'] field_to_match: The part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        pulumi.set(__self__, "regex_string", regex_string)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @property
    @pulumi.getter(name="regexString")
    def regex_string(self) -> pulumi.Input[str]:
        """
        String representing the regular expression. Minimum of `1` and maximum of `512` characters.
        """
        return pulumi.get(self, "regex_string")

    @regex_string.setter
    def regex_string(self, value: pulumi.Input[str]):
        pulumi.set(self, "regex_string", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchArgs']]:
        """
        The part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_path: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs'] all_query_arguments: Inspect all query arguments.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgs'] body: Inspect the request body, which immediately follows the request headers. See `body` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgs'] cookies: Inspect the cookies in the web request. See `cookies` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgs']]] header_orders: Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgs']]] headers: Inspect the request headers. See `headers` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs'] ja3_fingerprint: Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgs'] json_body: Inspect the request body as JSON. See `json_body` for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgs'] method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgs'] query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgs'] single_header: Inspect a single header. See `single_header` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs'] single_query_argument: Inspect a single query argument. See `single_query_argument` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgs'] uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs']]:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgs']]:
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgs']]:
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgs']]]]:
        """
        Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        """
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgs']]]]:
        """
        Inspect the request headers. See `headers` below for details.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs']]:
        """
        Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        """
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgs']]:
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgs']]:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgs']]:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgs']]:
        """
        Inspect a single header. See `single_header` below for details.
        """
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs']]:
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgs']]:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] oversize_handling: What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs']]] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param pulumi.Input[str] match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs']]]:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_cookies", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs'] match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param pulumi.Input[str] match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs']:
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_headers", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 invalid_fallback_behavior: Optional[pulumi.Input[str]] = None,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs'] match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param pulumi.Input[str] match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param pulumi.Input[str] invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param pulumi.Input[str] oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs']:
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_paths", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgs']] = None):
        """
        :param pulumi.Input[str] arn: The Amazon Resource Name (ARN) of the Regex Pattern Set that this statement references.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgs'] field_to_match: Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @property
    @pulumi.getter
    def arn(self) -> pulumi.Input[str]:
        """
        The Amazon Resource Name (ARN) of the Regex Pattern Set that this statement references.
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "arn", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgs']]:
        """
        Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_path: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs'] all_query_arguments: Inspect all query arguments.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs'] body: Inspect the request body, which immediately follows the request headers. See `body` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs'] cookies: Inspect the cookies in the web request. See `cookies` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs']]] header_orders: Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs']]] headers: Inspect the request headers. See `headers` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs'] ja3_fingerprint: Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs'] json_body: Inspect the request body as JSON. See `json_body` for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs'] method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs'] query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs'] single_header: Inspect a single header. See `single_header` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs'] single_query_argument: Inspect a single query argument. See `single_query_argument` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs'] uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs']]:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs']]:
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs']]:
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs']]]]:
        """
        Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        """
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs']]]]:
        """
        Inspect the request headers. See `headers` below for details.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs']]:
        """
        Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        """
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs']]:
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs']]:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs']]:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs']]:
        """
        Inspect a single header. See `single_header` below for details.
        """
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs']]:
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs']]:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] oversize_handling: What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs']]] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param pulumi.Input[str] match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs']]]:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_cookies", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs'] match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param pulumi.Input[str] match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs']:
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_headers", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 invalid_fallback_behavior: Optional[pulumi.Input[str]] = None,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs'] match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param pulumi.Input[str] match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param pulumi.Input[str] invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param pulumi.Input[str] oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs']:
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_paths", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementArgs:
    def __init__(__self__, *,
                 comparison_operator: pulumi.Input[str],
                 size: pulumi.Input[int],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgs']] = None):
        """
        :param pulumi.Input[str] comparison_operator: Operator to use to compare the request part to the size setting. Valid values include: `EQ`, `NE`, `LE`, `LT`, `GE`, or `GT`.
        :param pulumi.Input[int] size: Size, in bytes, to compare to the request part, after any transformations. Valid values are integers between 0 and 21474836480, inclusive.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgs'] field_to_match: Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        pulumi.set(__self__, "comparison_operator", comparison_operator)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> pulumi.Input[str]:
        """
        Operator to use to compare the request part to the size setting. Valid values include: `EQ`, `NE`, `LE`, `LT`, `GE`, or `GT`.
        """
        return pulumi.get(self, "comparison_operator")

    @comparison_operator.setter
    def comparison_operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "comparison_operator", value)

    @property
    @pulumi.getter
    def size(self) -> pulumi.Input[int]:
        """
        Size, in bytes, to compare to the request part, after any transformations. Valid values are integers between 0 and 21474836480, inclusive.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[int]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgs']]:
        """
        Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_path: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs'] all_query_arguments: Inspect all query arguments.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgs'] body: Inspect the request body, which immediately follows the request headers. See `body` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgs'] cookies: Inspect the cookies in the web request. See `cookies` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs']]] header_orders: Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgs']]] headers: Inspect the request headers. See `headers` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs'] ja3_fingerprint: Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgs'] json_body: Inspect the request body as JSON. See `json_body` for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgs'] method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgs'] query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs'] single_header: Inspect a single header. See `single_header` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs'] single_query_argument: Inspect a single query argument. See `single_query_argument` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgs'] uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs']]:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgs']]:
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgs']]:
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs']]]]:
        """
        Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        """
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgs']]]]:
        """
        Inspect the request headers. See `headers` below for details.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs']]:
        """
        Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        """
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgs']]:
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgs']]:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgs']]:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs']]:
        """
        Inspect a single header. See `single_header` below for details.
        """
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs']]:
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgs']]:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] oversize_handling: What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs']]] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param pulumi.Input[str] match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs']]]:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_cookies", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs'] match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param pulumi.Input[str] match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs']:
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_headers", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 invalid_fallback_behavior: Optional[pulumi.Input[str]] = None,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs'] match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param pulumi.Input[str] match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param pulumi.Input[str] invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param pulumi.Input[str] oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs']:
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_paths", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementArgs:
    def __init__(__self__, *,
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchArgs'] field_to_match: Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchArgs']]:
        """
        Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_path: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs'] all_query_arguments: Inspect all query arguments.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgs'] body: Inspect the request body, which immediately follows the request headers. See `body` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgs'] cookies: Inspect the cookies in the web request. See `cookies` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgs']]] header_orders: Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgs']]] headers: Inspect the request headers. See `headers` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs'] ja3_fingerprint: Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgs'] json_body: Inspect the request body as JSON. See `json_body` for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgs'] method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgs'] query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgs'] single_header: Inspect a single header. See `single_header` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs'] single_query_argument: Inspect a single query argument. See `single_query_argument` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgs'] uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs']]:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgs']]:
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgs']]:
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgs']]]]:
        """
        Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        """
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgs']]]]:
        """
        Inspect the request headers. See `headers` below for details.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs']]:
        """
        Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        """
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgs']]:
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgs']]:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgs']]:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgs']]:
        """
        Inspect a single header. See `single_header` below for details.
        """
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs']]:
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgs']]:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] oversize_handling: What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs']]] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param pulumi.Input[str] match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs']]]:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_cookies", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs'] match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param pulumi.Input[str] match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs']:
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_headers", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 invalid_fallback_behavior: Optional[pulumi.Input[str]] = None,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs'] match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param pulumi.Input[str] match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param pulumi.Input[str] invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param pulumi.Input[str] oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs']:
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_paths", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementArgs:
    def __init__(__self__, *,
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchArgs'] field_to_match: Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchArgs']]:
        """
        Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_path: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs'] all_query_arguments: Inspect all query arguments.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgs'] body: Inspect the request body, which immediately follows the request headers. See `body` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgs'] cookies: Inspect the cookies in the web request. See `cookies` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgs']]] header_orders: Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgs']]] headers: Inspect the request headers. See `headers` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgs'] ja3_fingerprint: Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgs'] json_body: Inspect the request body as JSON. See `json_body` for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgs'] method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgs'] query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgs'] single_header: Inspect a single header. See `single_header` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs'] single_query_argument: Inspect a single query argument. See `single_query_argument` below for details.
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgs'] uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs']]:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgs']]:
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgs']]:
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgs']]]]:
        """
        Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        """
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgs']]]]:
        """
        Inspect the request headers. See `headers` below for details.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgs']]:
        """
        Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        """
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgs']]:
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgs']]:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgs']]:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgs']]:
        """
        Inspect a single header. See `single_header` below for details.
        """
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs']]:
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgs']]:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] oversize_handling: What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs']]] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param pulumi.Input[str] match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs']]]:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_cookies", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs'] match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param pulumi.Input[str] match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs']:
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_headers", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 invalid_fallback_behavior: Optional[pulumi.Input[str]] = None,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs'] match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param pulumi.Input[str] match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param pulumi.Input[str] invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param pulumi.Input[str] oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs']:
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_paths", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class WebAclRuleStatementRegexMatchStatementArgs:
    def __init__(__self__, *,
                 regex_string: pulumi.Input[str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexMatchStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchArgs']] = None):
        """
        :param pulumi.Input[str] regex_string: String representing the regular expression. Minimum of `1` and maximum of `512` characters.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexMatchStatementTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        :param pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchArgs'] field_to_match: The part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        pulumi.set(__self__, "regex_string", regex_string)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @property
    @pulumi.getter(name="regexString")
    def regex_string(self) -> pulumi.Input[str]:
        """
        String representing the regular expression. Minimum of `1` and maximum of `512` characters.
        """
        return pulumi.get(self, "regex_string")

    @regex_string.setter
    def regex_string(self, value: pulumi.Input[str]):
        pulumi.set(self, "regex_string", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexMatchStatementTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexMatchStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchArgs']]:
        """
        The part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


@pulumi.input_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_path: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchUriPathArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs'] all_query_arguments: Inspect all query arguments.
        :param pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchBodyArgs'] body: Inspect the request body, which immediately follows the request headers. See `body` below for details.
        :param pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesArgs'] cookies: Inspect the cookies in the web request. See `cookies` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderOrderArgs']]] header_orders: Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderArgs']]] headers: Inspect the request headers. See `headers` below for details.
        :param pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs'] ja3_fingerprint: Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        :param pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyArgs'] json_body: Inspect the request body as JSON. See `json_body` for details.
        :param pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchMethodArgs'] method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchQueryStringArgs'] query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchSingleHeaderArgs'] single_header: Inspect a single header. See `single_header` below for details.
        :param pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs'] single_query_argument: Inspect a single query argument. See `single_query_argument` below for details.
        :param pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchUriPathArgs'] uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs']]:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchBodyArgs']]:
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesArgs']]:
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderOrderArgs']]]]:
        """
        Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        """
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderArgs']]]]:
        """
        Inspect the request headers. See `headers` below for details.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs']]:
        """
        Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        """
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyArgs']]:
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchMethodArgs']]:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchQueryStringArgs']]:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchSingleHeaderArgs']]:
        """
        Inspect a single header. See `single_header` below for details.
        """
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs']]:
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchUriPathArgs']]:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


@pulumi.input_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] oversize_handling: What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs']]] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param pulumi.Input[str] match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs']]]:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_cookies", value)


@pulumi.input_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs'] match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param pulumi.Input[str] match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs']:
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_headers", value)


@pulumi.input_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)


@pulumi.input_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 invalid_fallback_behavior: Optional[pulumi.Input[str]] = None,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs'] match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param pulumi.Input[str] match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param pulumi.Input[str] invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param pulumi.Input[str] oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs']:
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_paths", value)


@pulumi.input_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementRegexMatchStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class WebAclRuleStatementRegexPatternSetReferenceStatementArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchArgs']] = None):
        """
        :param pulumi.Input[str] arn: The Amazon Resource Name (ARN) of the Regex Pattern Set that this statement references.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        :param pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchArgs'] field_to_match: Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @property
    @pulumi.getter
    def arn(self) -> pulumi.Input[str]:
        """
        The Amazon Resource Name (ARN) of the Regex Pattern Set that this statement references.
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "arn", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchArgs']]:
        """
        Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


@pulumi.input_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_path: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs'] all_query_arguments: Inspect all query arguments.
        :param pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs'] body: Inspect the request body, which immediately follows the request headers. See `body` below for details.
        :param pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs'] cookies: Inspect the cookies in the web request. See `cookies` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs']]] header_orders: Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs']]] headers: Inspect the request headers. See `headers` below for details.
        :param pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs'] ja3_fingerprint: Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        :param pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs'] json_body: Inspect the request body as JSON. See `json_body` for details.
        :param pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs'] method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs'] query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs'] single_header: Inspect a single header. See `single_header` below for details.
        :param pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs'] single_query_argument: Inspect a single query argument. See `single_query_argument` below for details.
        :param pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs'] uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs']]:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs']]:
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs']]:
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs']]]]:
        """
        Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        """
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs']]]]:
        """
        Inspect the request headers. See `headers` below for details.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs']]:
        """
        Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        """
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs']]:
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs']]:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs']]:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs']]:
        """
        Inspect a single header. See `single_header` below for details.
        """
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs']]:
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs']]:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


@pulumi.input_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] oversize_handling: What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs']]] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param pulumi.Input[str] match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs']]]:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_cookies", value)


@pulumi.input_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs'] match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param pulumi.Input[str] match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs']:
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_headers", value)


@pulumi.input_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)


@pulumi.input_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 invalid_fallback_behavior: Optional[pulumi.Input[str]] = None,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs'] match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param pulumi.Input[str] match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param pulumi.Input[str] invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param pulumi.Input[str] oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs']:
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_paths", value)


@pulumi.input_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementRegexPatternSetReferenceStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class WebAclRuleStatementRuleGroupReferenceStatementArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[str],
                 rule_action_overrides: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideArgs']]]] = None):
        """
        :param pulumi.Input[str] arn: The Amazon Resource Name (ARN) of the `wafv2.RuleGroup` resource.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideArgs']]] rule_action_overrides: Action settings to use in the place of the rule actions that are configured inside the rule group. You specify one override for each rule whose action you want to change. See `rule_action_override` below for details.
        """
        pulumi.set(__self__, "arn", arn)
        if rule_action_overrides is not None:
            pulumi.set(__self__, "rule_action_overrides", rule_action_overrides)

    @property
    @pulumi.getter
    def arn(self) -> pulumi.Input[str]:
        """
        The Amazon Resource Name (ARN) of the `wafv2.RuleGroup` resource.
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "arn", value)

    @property
    @pulumi.getter(name="ruleActionOverrides")
    def rule_action_overrides(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideArgs']]]]:
        """
        Action settings to use in the place of the rule actions that are configured inside the rule group. You specify one override for each rule whose action you want to change. See `rule_action_override` below for details.
        """
        return pulumi.get(self, "rule_action_overrides")

    @rule_action_overrides.setter
    def rule_action_overrides(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideArgs']]]]):
        pulumi.set(self, "rule_action_overrides", value)


@pulumi.input_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideArgs:
    def __init__(__self__, *,
                 action_to_use: pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseArgs'],
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseArgs'] action_to_use: Override action to use, in place of the configured action of the rule in the rule group. See `action` for details.
        :param pulumi.Input[str] name: Name of the rule to override. See the [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/aws-managed-rule-groups-list.html) for a list of names in the appropriate rule group in use.
        """
        pulumi.set(__self__, "action_to_use", action_to_use)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="actionToUse")
    def action_to_use(self) -> pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseArgs']:
        """
        Override action to use, in place of the configured action of the rule in the rule group. See `action` for details.
        """
        return pulumi.get(self, "action_to_use")

    @action_to_use.setter
    def action_to_use(self, value: pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseArgs']):
        pulumi.set(self, "action_to_use", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the rule to override. See the [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/aws-managed-rule-groups-list.html) for a list of names in the appropriate rule group in use.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseArgs:
    def __init__(__self__, *,
                 allow: Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowArgs']] = None,
                 block: Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockArgs']] = None,
                 captcha: Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaArgs']] = None,
                 challenge: Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeArgs']] = None,
                 count: Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowArgs'] allow: Instructs AWS WAF to allow the web request. See `allow` below for details.
        :param pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockArgs'] block: Instructs AWS WAF to block the web request. See `block` below for details.
        :param pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaArgs'] captcha: Instructs AWS WAF to run a Captcha check against the web request. See `captcha` below for details.
        :param pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeArgs'] challenge: Instructs AWS WAF to run a check against the request to verify that the request is coming from a legitimate client session. See `challenge` below for details.
        :param pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountArgs'] count: Instructs AWS WAF to count the web request and allow it. See `count` below for details.
        """
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if block is not None:
            pulumi.set(__self__, "block", block)
        if captcha is not None:
            pulumi.set(__self__, "captcha", captcha)
        if challenge is not None:
            pulumi.set(__self__, "challenge", challenge)
        if count is not None:
            pulumi.set(__self__, "count", count)

    @property
    @pulumi.getter
    def allow(self) -> Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowArgs']]:
        """
        Instructs AWS WAF to allow the web request. See `allow` below for details.
        """
        return pulumi.get(self, "allow")

    @allow.setter
    def allow(self, value: Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowArgs']]):
        pulumi.set(self, "allow", value)

    @property
    @pulumi.getter
    def block(self) -> Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockArgs']]:
        """
        Instructs AWS WAF to block the web request. See `block` below for details.
        """
        return pulumi.get(self, "block")

    @block.setter
    def block(self, value: Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockArgs']]):
        pulumi.set(self, "block", value)

    @property
    @pulumi.getter
    def captcha(self) -> Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaArgs']]:
        """
        Instructs AWS WAF to run a Captcha check against the web request. See `captcha` below for details.
        """
        return pulumi.get(self, "captcha")

    @captcha.setter
    def captcha(self, value: Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaArgs']]):
        pulumi.set(self, "captcha", value)

    @property
    @pulumi.getter
    def challenge(self) -> Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeArgs']]:
        """
        Instructs AWS WAF to run a check against the request to verify that the request is coming from a legitimate client session. See `challenge` below for details.
        """
        return pulumi.get(self, "challenge")

    @challenge.setter
    def challenge(self, value: Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeArgs']]):
        pulumi.set(self, "challenge", value)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountArgs']]:
        """
        Instructs AWS WAF to count the web request and allow it. See `count` below for details.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountArgs']]):
        pulumi.set(self, "count", value)


@pulumi.input_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingArgs'] custom_request_handling: Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingArgs']]:
        """
        Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


@pulumi.input_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingArgs:
    def __init__(__self__, *,
                 insert_headers: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeaderArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeaderArgs']]] insert_headers: The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        pulumi.set(__self__, "insert_headers", insert_headers)

    @property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeaderArgs']]]:
        """
        The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        return pulumi.get(self, "insert_headers")

    @insert_headers.setter
    def insert_headers(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeaderArgs']]]):
        pulumi.set(self, "insert_headers", value)


@pulumi.input_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        :param pulumi.Input[str] value: Value of the custom header.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value of the custom header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockArgs:
    def __init__(__self__, *,
                 custom_response: Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponseArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponseArgs'] custom_response: Defines a custom response for the web request. See `custom_response` below for details.
        """
        if custom_response is not None:
            pulumi.set(__self__, "custom_response", custom_response)

    @property
    @pulumi.getter(name="customResponse")
    def custom_response(self) -> Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponseArgs']]:
        """
        Defines a custom response for the web request. See `custom_response` below for details.
        """
        return pulumi.get(self, "custom_response")

    @custom_response.setter
    def custom_response(self, value: Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponseArgs']]):
        pulumi.set(self, "custom_response", value)


@pulumi.input_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponseArgs:
    def __init__(__self__, *,
                 response_code: pulumi.Input[int],
                 custom_response_body_key: Optional[pulumi.Input[str]] = None,
                 response_headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeaderArgs']]]] = None):
        """
        :param pulumi.Input[int] response_code: The HTTP status code to return to the client.
        :param pulumi.Input[str] custom_response_body_key: References the response body that you want AWS WAF to return to the web request client. This must reference a `key` defined in a `custom_response_body` block of this resource.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeaderArgs']]] response_headers: The `response_header` blocks used to define the HTTP response headers added to the response. See `response_header` below for details.
        """
        pulumi.set(__self__, "response_code", response_code)
        if custom_response_body_key is not None:
            pulumi.set(__self__, "custom_response_body_key", custom_response_body_key)
        if response_headers is not None:
            pulumi.set(__self__, "response_headers", response_headers)

    @property
    @pulumi.getter(name="responseCode")
    def response_code(self) -> pulumi.Input[int]:
        """
        The HTTP status code to return to the client.
        """
        return pulumi.get(self, "response_code")

    @response_code.setter
    def response_code(self, value: pulumi.Input[int]):
        pulumi.set(self, "response_code", value)

    @property
    @pulumi.getter(name="customResponseBodyKey")
    def custom_response_body_key(self) -> Optional[pulumi.Input[str]]:
        """
        References the response body that you want AWS WAF to return to the web request client. This must reference a `key` defined in a `custom_response_body` block of this resource.
        """
        return pulumi.get(self, "custom_response_body_key")

    @custom_response_body_key.setter
    def custom_response_body_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_response_body_key", value)

    @property
    @pulumi.getter(name="responseHeaders")
    def response_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeaderArgs']]]]:
        """
        The `response_header` blocks used to define the HTTP response headers added to the response. See `response_header` below for details.
        """
        return pulumi.get(self, "response_headers")

    @response_headers.setter
    def response_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeaderArgs']]]]):
        pulumi.set(self, "response_headers", value)


@pulumi.input_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        :param pulumi.Input[str] value: Value of the custom header.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value of the custom header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingArgs'] custom_request_handling: Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingArgs']]:
        """
        Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


@pulumi.input_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingArgs:
    def __init__(__self__, *,
                 insert_headers: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeaderArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeaderArgs']]] insert_headers: The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        pulumi.set(__self__, "insert_headers", insert_headers)

    @property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeaderArgs']]]:
        """
        The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        return pulumi.get(self, "insert_headers")

    @insert_headers.setter
    def insert_headers(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeaderArgs']]]):
        pulumi.set(self, "insert_headers", value)


@pulumi.input_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        :param pulumi.Input[str] value: Value of the custom header.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value of the custom header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingArgs'] custom_request_handling: Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingArgs']]:
        """
        Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


@pulumi.input_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingArgs:
    def __init__(__self__, *,
                 insert_headers: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeaderArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeaderArgs']]] insert_headers: The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        pulumi.set(__self__, "insert_headers", insert_headers)

    @property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeaderArgs']]]:
        """
        The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        return pulumi.get(self, "insert_headers")

    @insert_headers.setter
    def insert_headers(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeaderArgs']]]):
        pulumi.set(self, "insert_headers", value)


@pulumi.input_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        :param pulumi.Input[str] value: Value of the custom header.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value of the custom header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandlingArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandlingArgs'] custom_request_handling: Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandlingArgs']]:
        """
        Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


@pulumi.input_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandlingArgs:
    def __init__(__self__, *,
                 insert_headers: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeaderArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeaderArgs']]] insert_headers: The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        pulumi.set(__self__, "insert_headers", insert_headers)

    @property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeaderArgs']]]:
        """
        The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        return pulumi.get(self, "insert_headers")

    @insert_headers.setter
    def insert_headers(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeaderArgs']]]):
        pulumi.set(self, "insert_headers", value)


@pulumi.input_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        :param pulumi.Input[str] value: Value of the custom header.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value of the custom header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class WebAclRuleStatementSizeConstraintStatementArgs:
    def __init__(__self__, *,
                 comparison_operator: pulumi.Input[str],
                 size: pulumi.Input[int],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSizeConstraintStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchArgs']] = None):
        """
        :param pulumi.Input[str] comparison_operator: Operator to use to compare the request part to the size setting. Valid values include: `EQ`, `NE`, `LE`, `LT`, `GE`, or `GT`.
        :param pulumi.Input[int] size: Size, in bytes, to compare to the request part, after any transformations. Valid values are integers between 0 and 21474836480, inclusive.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSizeConstraintStatementTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        :param pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchArgs'] field_to_match: Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        pulumi.set(__self__, "comparison_operator", comparison_operator)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> pulumi.Input[str]:
        """
        Operator to use to compare the request part to the size setting. Valid values include: `EQ`, `NE`, `LE`, `LT`, `GE`, or `GT`.
        """
        return pulumi.get(self, "comparison_operator")

    @comparison_operator.setter
    def comparison_operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "comparison_operator", value)

    @property
    @pulumi.getter
    def size(self) -> pulumi.Input[int]:
        """
        Size, in bytes, to compare to the request part, after any transformations. Valid values are integers between 0 and 21474836480, inclusive.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[int]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSizeConstraintStatementTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSizeConstraintStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchArgs']]:
        """
        Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


@pulumi.input_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_path: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchUriPathArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs'] all_query_arguments: Inspect all query arguments.
        :param pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchBodyArgs'] body: Inspect the request body, which immediately follows the request headers. See `body` below for details.
        :param pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesArgs'] cookies: Inspect the cookies in the web request. See `cookies` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs']]] header_orders: Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderArgs']]] headers: Inspect the request headers. See `headers` below for details.
        :param pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs'] ja3_fingerprint: Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        :param pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyArgs'] json_body: Inspect the request body as JSON. See `json_body` for details.
        :param pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchMethodArgs'] method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchQueryStringArgs'] query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs'] single_header: Inspect a single header. See `single_header` below for details.
        :param pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs'] single_query_argument: Inspect a single query argument. See `single_query_argument` below for details.
        :param pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchUriPathArgs'] uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs']]:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchBodyArgs']]:
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesArgs']]:
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs']]]]:
        """
        Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        """
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderArgs']]]]:
        """
        Inspect the request headers. See `headers` below for details.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs']]:
        """
        Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        """
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyArgs']]:
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchMethodArgs']]:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchQueryStringArgs']]:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs']]:
        """
        Inspect a single header. See `single_header` below for details.
        """
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs']]:
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchUriPathArgs']]:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


@pulumi.input_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] oversize_handling: What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs']]] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param pulumi.Input[str] match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs']]]:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_cookies", value)


@pulumi.input_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs'] match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param pulumi.Input[str] match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs']:
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_headers", value)


@pulumi.input_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)


@pulumi.input_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 invalid_fallback_behavior: Optional[pulumi.Input[str]] = None,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs'] match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param pulumi.Input[str] match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param pulumi.Input[str] invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param pulumi.Input[str] oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs']:
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_paths", value)


@pulumi.input_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementSizeConstraintStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class WebAclRuleStatementSqliMatchStatementArgs:
    def __init__(__self__, *,
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSqliMatchStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSqliMatchStatementTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        :param pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchArgs'] field_to_match: Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSqliMatchStatementTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSqliMatchStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchArgs']]:
        """
        Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


@pulumi.input_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_path: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchUriPathArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs'] all_query_arguments: Inspect all query arguments.
        :param pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchBodyArgs'] body: Inspect the request body, which immediately follows the request headers. See `body` below for details.
        :param pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesArgs'] cookies: Inspect the cookies in the web request. See `cookies` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderOrderArgs']]] header_orders: Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderArgs']]] headers: Inspect the request headers. See `headers` below for details.
        :param pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs'] ja3_fingerprint: Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        :param pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyArgs'] json_body: Inspect the request body as JSON. See `json_body` for details.
        :param pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchMethodArgs'] method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchQueryStringArgs'] query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchSingleHeaderArgs'] single_header: Inspect a single header. See `single_header` below for details.
        :param pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs'] single_query_argument: Inspect a single query argument. See `single_query_argument` below for details.
        :param pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchUriPathArgs'] uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs']]:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchBodyArgs']]:
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesArgs']]:
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderOrderArgs']]]]:
        """
        Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        """
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderArgs']]]]:
        """
        Inspect the request headers. See `headers` below for details.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs']]:
        """
        Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        """
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyArgs']]:
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchMethodArgs']]:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchQueryStringArgs']]:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchSingleHeaderArgs']]:
        """
        Inspect a single header. See `single_header` below for details.
        """
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs']]:
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchUriPathArgs']]:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


@pulumi.input_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] oversize_handling: What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs']]] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param pulumi.Input[str] match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs']]]:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_cookies", value)


@pulumi.input_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs'] match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param pulumi.Input[str] match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs']:
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_headers", value)


@pulumi.input_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)


@pulumi.input_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 invalid_fallback_behavior: Optional[pulumi.Input[str]] = None,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs'] match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param pulumi.Input[str] match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param pulumi.Input[str] invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param pulumi.Input[str] oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs']:
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_paths", value)


@pulumi.input_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementSqliMatchStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class WebAclRuleStatementXssMatchStatementArgs:
    def __init__(__self__, *,
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementXssMatchStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementXssMatchStatementTextTransformationArgs']]] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        :param pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchArgs'] field_to_match: Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementXssMatchStatementTextTransformationArgs']]]:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementXssMatchStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchArgs']]:
        """
        Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


@pulumi.input_type
class WebAclRuleStatementXssMatchStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchJa3FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_path: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchUriPathArgs']] = None):
        """
        :param pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs'] all_query_arguments: Inspect all query arguments.
        :param pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchBodyArgs'] body: Inspect the request body, which immediately follows the request headers. See `body` below for details.
        :param pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchCookiesArgs'] cookies: Inspect the cookies in the web request. See `cookies` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchHeaderOrderArgs']]] header_orders: Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchHeaderArgs']]] headers: Inspect the request headers. See `headers` below for details.
        :param pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchJa3FingerprintArgs'] ja3_fingerprint: Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        :param pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyArgs'] json_body: Inspect the request body as JSON. See `json_body` for details.
        :param pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchMethodArgs'] method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchQueryStringArgs'] query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchSingleHeaderArgs'] single_header: Inspect a single header. See `single_header` below for details.
        :param pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs'] single_query_argument: Inspect a single query argument. See `single_query_argument` below for details.
        :param pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchUriPathArgs'] uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs']]:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchBodyArgs']]:
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchCookiesArgs']]:
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchHeaderOrderArgs']]]]:
        """
        Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `header_order` below for details.
        """
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchHeaderArgs']]]]:
        """
        Inspect the request headers. See `headers` below for details.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchJa3FingerprintArgs']]:
        """
        Inspect the JA3 fingerprint. See `ja3_fingerprint` below for details.
        """
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyArgs']]:
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchMethodArgs']]:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchQueryStringArgs']]:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchSingleHeaderArgs']]:
        """
        Inspect a single header. See `single_header` below for details.
        """
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs']]:
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchUriPathArgs']]:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


@pulumi.input_type
class WebAclRuleStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementXssMatchStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] oversize_handling: What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementXssMatchStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs']]] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param pulumi.Input[str] match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param pulumi.Input[str] oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs']]]:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_cookies", value)


@pulumi.input_type
class WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementXssMatchStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs'] match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param pulumi.Input[str] match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs']:
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_headers", value)


@pulumi.input_type
class WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementXssMatchStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[str]):
        """
        :param pulumi.Input[str] oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[str]:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[str]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementXssMatchStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[str]):
        """
        :param pulumi.Input[str] fallback_behavior: Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[str]:
        """
        Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "fallback_behavior", value)


@pulumi.input_type
class WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[str],
                 invalid_fallback_behavior: Optional[pulumi.Input[str]] = None,
                 oversize_handling: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs'] match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param pulumi.Input[str] match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param pulumi.Input[str] invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param pulumi.Input[str] oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs']:
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[str]:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_scope", value)

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[str]]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oversize_handling", value)


@pulumi.input_type
class WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs'] all: An empty configuration block that is used for inspecting all headers.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_paths", value)


@pulumi.input_type
class WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementXssMatchStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementXssMatchStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementXssMatchStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class WebAclRuleStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class WebAclRuleStatementXssMatchStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class WebAclRuleStatementXssMatchStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param pulumi.Input[str] type: Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class WebAclRuleVisibilityConfigArgs:
    def __init__(__self__, *,
                 cloudwatch_metrics_enabled: pulumi.Input[bool],
                 metric_name: pulumi.Input[str],
                 sampled_requests_enabled: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] cloudwatch_metrics_enabled: Whether the associated resource sends metrics to CloudWatch. For the list of available metrics, see [AWS WAF Metrics](https://docs.aws.amazon.com/waf/latest/developerguide/monitoring-cloudwatch.html#waf-metrics).
        :param pulumi.Input[str] metric_name: A friendly name of the CloudWatch metric. The name can contain only alphanumeric characters (A-Z, a-z, 0-9) hyphen(-) and underscore (\\_), with length from one to 128 characters. It can't contain whitespace or metric names reserved for AWS WAF, for example `All` and `Default_Action`.
        :param pulumi.Input[bool] sampled_requests_enabled: Whether AWS WAF should store a sampling of the web requests that match the rules. You can view the sampled requests through the AWS WAF console.
        """
        pulumi.set(__self__, "cloudwatch_metrics_enabled", cloudwatch_metrics_enabled)
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "sampled_requests_enabled", sampled_requests_enabled)

    @property
    @pulumi.getter(name="cloudwatchMetricsEnabled")
    def cloudwatch_metrics_enabled(self) -> pulumi.Input[bool]:
        """
        Whether the associated resource sends metrics to CloudWatch. For the list of available metrics, see [AWS WAF Metrics](https://docs.aws.amazon.com/waf/latest/developerguide/monitoring-cloudwatch.html#waf-metrics).
        """
        return pulumi.get(self, "cloudwatch_metrics_enabled")

    @cloudwatch_metrics_enabled.setter
    def cloudwatch_metrics_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "cloudwatch_metrics_enabled", value)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> pulumi.Input[str]:
        """
        A friendly name of the CloudWatch metric. The name can contain only alphanumeric characters (A-Z, a-z, 0-9) hyphen(-) and underscore (\\_), with length from one to 128 characters. It can't contain whitespace or metric names reserved for AWS WAF, for example `All` and `Default_Action`.
        """
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric_name", value)

    @property
    @pulumi.getter(name="sampledRequestsEnabled")
    def sampled_requests_enabled(self) -> pulumi.Input[bool]:
        """
        Whether AWS WAF should store a sampling of the web requests that match the rules. You can view the sampled requests through the AWS WAF console.
        """
        return pulumi.get(self, "sampled_requests_enabled")

    @sampled_requests_enabled.setter
    def sampled_requests_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "sampled_requests_enabled", value)


@pulumi.input_type
class WebAclVisibilityConfigArgs:
    def __init__(__self__, *,
                 cloudwatch_metrics_enabled: pulumi.Input[bool],
                 metric_name: pulumi.Input[str],
                 sampled_requests_enabled: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] cloudwatch_metrics_enabled: Whether the associated resource sends metrics to CloudWatch. For the list of available metrics, see [AWS WAF Metrics](https://docs.aws.amazon.com/waf/latest/developerguide/monitoring-cloudwatch.html#waf-metrics).
        :param pulumi.Input[str] metric_name: A friendly name of the CloudWatch metric. The name can contain only alphanumeric characters (A-Z, a-z, 0-9) hyphen(-) and underscore (\\_), with length from one to 128 characters. It can't contain whitespace or metric names reserved for AWS WAF, for example `All` and `Default_Action`.
        :param pulumi.Input[bool] sampled_requests_enabled: Whether AWS WAF should store a sampling of the web requests that match the rules. You can view the sampled requests through the AWS WAF console.
        """
        pulumi.set(__self__, "cloudwatch_metrics_enabled", cloudwatch_metrics_enabled)
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "sampled_requests_enabled", sampled_requests_enabled)

    @property
    @pulumi.getter(name="cloudwatchMetricsEnabled")
    def cloudwatch_metrics_enabled(self) -> pulumi.Input[bool]:
        """
        Whether the associated resource sends metrics to CloudWatch. For the list of available metrics, see [AWS WAF Metrics](https://docs.aws.amazon.com/waf/latest/developerguide/monitoring-cloudwatch.html#waf-metrics).
        """
        return pulumi.get(self, "cloudwatch_metrics_enabled")

    @cloudwatch_metrics_enabled.setter
    def cloudwatch_metrics_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "cloudwatch_metrics_enabled", value)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> pulumi.Input[str]:
        """
        A friendly name of the CloudWatch metric. The name can contain only alphanumeric characters (A-Z, a-z, 0-9) hyphen(-) and underscore (\\_), with length from one to 128 characters. It can't contain whitespace or metric names reserved for AWS WAF, for example `All` and `Default_Action`.
        """
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric_name", value)

    @property
    @pulumi.getter(name="sampledRequestsEnabled")
    def sampled_requests_enabled(self) -> pulumi.Input[bool]:
        """
        Whether AWS WAF should store a sampling of the web requests that match the rules. You can view the sampled requests through the AWS WAF console.
        """
        return pulumi.get(self, "sampled_requests_enabled")

    @sampled_requests_enabled.setter
    def sampled_requests_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "sampled_requests_enabled", value)


