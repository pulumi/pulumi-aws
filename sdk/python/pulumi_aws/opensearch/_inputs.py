# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'AuthorizeVpcEndpointAccessAuthorizedPrincipalArgs',
    'AuthorizeVpcEndpointAccessAuthorizedPrincipalArgsDict',
    'DomainAdvancedSecurityOptionsArgs',
    'DomainAdvancedSecurityOptionsArgsDict',
    'DomainAdvancedSecurityOptionsMasterUserOptionsArgs',
    'DomainAdvancedSecurityOptionsMasterUserOptionsArgsDict',
    'DomainAimlOptionsArgs',
    'DomainAimlOptionsArgsDict',
    'DomainAimlOptionsNaturalLanguageQueryGenerationOptionsArgs',
    'DomainAimlOptionsNaturalLanguageQueryGenerationOptionsArgsDict',
    'DomainAimlOptionsS3VectorsEngineArgs',
    'DomainAimlOptionsS3VectorsEngineArgsDict',
    'DomainAutoTuneOptionsArgs',
    'DomainAutoTuneOptionsArgsDict',
    'DomainAutoTuneOptionsMaintenanceScheduleArgs',
    'DomainAutoTuneOptionsMaintenanceScheduleArgsDict',
    'DomainAutoTuneOptionsMaintenanceScheduleDurationArgs',
    'DomainAutoTuneOptionsMaintenanceScheduleDurationArgsDict',
    'DomainClusterConfigArgs',
    'DomainClusterConfigArgsDict',
    'DomainClusterConfigColdStorageOptionsArgs',
    'DomainClusterConfigColdStorageOptionsArgsDict',
    'DomainClusterConfigNodeOptionArgs',
    'DomainClusterConfigNodeOptionArgsDict',
    'DomainClusterConfigNodeOptionNodeConfigArgs',
    'DomainClusterConfigNodeOptionNodeConfigArgsDict',
    'DomainClusterConfigZoneAwarenessConfigArgs',
    'DomainClusterConfigZoneAwarenessConfigArgsDict',
    'DomainCognitoOptionsArgs',
    'DomainCognitoOptionsArgsDict',
    'DomainDomainEndpointOptionsArgs',
    'DomainDomainEndpointOptionsArgsDict',
    'DomainEbsOptionsArgs',
    'DomainEbsOptionsArgsDict',
    'DomainEncryptAtRestArgs',
    'DomainEncryptAtRestArgsDict',
    'DomainIdentityCenterOptionsArgs',
    'DomainIdentityCenterOptionsArgsDict',
    'DomainLogPublishingOptionArgs',
    'DomainLogPublishingOptionArgsDict',
    'DomainNodeToNodeEncryptionArgs',
    'DomainNodeToNodeEncryptionArgsDict',
    'DomainOffPeakWindowOptionsArgs',
    'DomainOffPeakWindowOptionsArgsDict',
    'DomainOffPeakWindowOptionsOffPeakWindowArgs',
    'DomainOffPeakWindowOptionsOffPeakWindowArgsDict',
    'DomainOffPeakWindowOptionsOffPeakWindowWindowStartTimeArgs',
    'DomainOffPeakWindowOptionsOffPeakWindowWindowStartTimeArgsDict',
    'DomainSamlOptionsSamlOptionsArgs',
    'DomainSamlOptionsSamlOptionsArgsDict',
    'DomainSamlOptionsSamlOptionsIdpArgs',
    'DomainSamlOptionsSamlOptionsIdpArgsDict',
    'DomainSnapshotOptionsArgs',
    'DomainSnapshotOptionsArgsDict',
    'DomainSoftwareUpdateOptionsArgs',
    'DomainSoftwareUpdateOptionsArgsDict',
    'DomainVpcOptionsArgs',
    'DomainVpcOptionsArgsDict',
    'OutboundConnectionConnectionPropertiesArgs',
    'OutboundConnectionConnectionPropertiesArgsDict',
    'OutboundConnectionConnectionPropertiesCrossClusterSearchArgs',
    'OutboundConnectionConnectionPropertiesCrossClusterSearchArgsDict',
    'OutboundConnectionLocalDomainInfoArgs',
    'OutboundConnectionLocalDomainInfoArgsDict',
    'OutboundConnectionRemoteDomainInfoArgs',
    'OutboundConnectionRemoteDomainInfoArgsDict',
    'PackagePackageSourceArgs',
    'PackagePackageSourceArgsDict',
    'ServerlessCollectionTimeoutsArgs',
    'ServerlessCollectionTimeoutsArgsDict',
    'ServerlessSecurityConfigSamlOptionsArgs',
    'ServerlessSecurityConfigSamlOptionsArgsDict',
    'ServerlessVpcEndpointTimeoutsArgs',
    'ServerlessVpcEndpointTimeoutsArgsDict',
    'VpcEndpointVpcOptionsArgs',
    'VpcEndpointVpcOptionsArgsDict',
    'GetServerlessSecurityConfigSamlOptionArgs',
    'GetServerlessSecurityConfigSamlOptionArgsDict',
]

MYPY = False

if not MYPY:
    class AuthorizeVpcEndpointAccessAuthorizedPrincipalArgsDict(TypedDict):
        principal: pulumi.Input[_builtins.str]
        principal_type: pulumi.Input[_builtins.str]
elif False:
    AuthorizeVpcEndpointAccessAuthorizedPrincipalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthorizeVpcEndpointAccessAuthorizedPrincipalArgs:
    def __init__(__self__, *,
                 principal: pulumi.Input[_builtins.str],
                 principal_type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "principal", principal)
        pulumi.set(__self__, "principal_type", principal_type)

    @_builtins.property
    @pulumi.getter
    def principal(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "principal")

    @principal.setter
    def principal(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "principal", value)

    @_builtins.property
    @pulumi.getter(name="principalType")
    def principal_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "principal_type")

    @principal_type.setter
    def principal_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "principal_type", value)


if not MYPY:
    class DomainAdvancedSecurityOptionsArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        anonymous_auth_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        internal_user_database_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        master_user_options: NotRequired[pulumi.Input['DomainAdvancedSecurityOptionsMasterUserOptionsArgsDict']]
elif False:
    DomainAdvancedSecurityOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainAdvancedSecurityOptionsArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 anonymous_auth_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 internal_user_database_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 master_user_options: Optional[pulumi.Input['DomainAdvancedSecurityOptionsMasterUserOptionsArgs']] = None):
        pulumi.set(__self__, "enabled", enabled)
        if anonymous_auth_enabled is not None:
            pulumi.set(__self__, "anonymous_auth_enabled", anonymous_auth_enabled)
        if internal_user_database_enabled is not None:
            pulumi.set(__self__, "internal_user_database_enabled", internal_user_database_enabled)
        if master_user_options is not None:
            pulumi.set(__self__, "master_user_options", master_user_options)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="anonymousAuthEnabled")
    def anonymous_auth_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "anonymous_auth_enabled")

    @anonymous_auth_enabled.setter
    def anonymous_auth_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "anonymous_auth_enabled", value)

    @_builtins.property
    @pulumi.getter(name="internalUserDatabaseEnabled")
    def internal_user_database_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "internal_user_database_enabled")

    @internal_user_database_enabled.setter
    def internal_user_database_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "internal_user_database_enabled", value)

    @_builtins.property
    @pulumi.getter(name="masterUserOptions")
    def master_user_options(self) -> Optional[pulumi.Input['DomainAdvancedSecurityOptionsMasterUserOptionsArgs']]:
        return pulumi.get(self, "master_user_options")

    @master_user_options.setter
    def master_user_options(self, value: Optional[pulumi.Input['DomainAdvancedSecurityOptionsMasterUserOptionsArgs']]):
        pulumi.set(self, "master_user_options", value)


if not MYPY:
    class DomainAdvancedSecurityOptionsMasterUserOptionsArgsDict(TypedDict):
        master_user_arn: NotRequired[pulumi.Input[_builtins.str]]
        master_user_name: NotRequired[pulumi.Input[_builtins.str]]
        master_user_password: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DomainAdvancedSecurityOptionsMasterUserOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainAdvancedSecurityOptionsMasterUserOptionsArgs:
    def __init__(__self__, *,
                 master_user_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 master_user_name: Optional[pulumi.Input[_builtins.str]] = None,
                 master_user_password: Optional[pulumi.Input[_builtins.str]] = None):
        if master_user_arn is not None:
            pulumi.set(__self__, "master_user_arn", master_user_arn)
        if master_user_name is not None:
            pulumi.set(__self__, "master_user_name", master_user_name)
        if master_user_password is not None:
            pulumi.set(__self__, "master_user_password", master_user_password)

    @_builtins.property
    @pulumi.getter(name="masterUserArn")
    def master_user_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "master_user_arn")

    @master_user_arn.setter
    def master_user_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "master_user_arn", value)

    @_builtins.property
    @pulumi.getter(name="masterUserName")
    def master_user_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "master_user_name")

    @master_user_name.setter
    def master_user_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "master_user_name", value)

    @_builtins.property
    @pulumi.getter(name="masterUserPassword")
    def master_user_password(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "master_user_password")

    @master_user_password.setter
    def master_user_password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "master_user_password", value)


if not MYPY:
    class DomainAimlOptionsArgsDict(TypedDict):
        natural_language_query_generation_options: NotRequired[pulumi.Input['DomainAimlOptionsNaturalLanguageQueryGenerationOptionsArgsDict']]
        s3_vectors_engine: NotRequired[pulumi.Input['DomainAimlOptionsS3VectorsEngineArgsDict']]
elif False:
    DomainAimlOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainAimlOptionsArgs:
    def __init__(__self__, *,
                 natural_language_query_generation_options: Optional[pulumi.Input['DomainAimlOptionsNaturalLanguageQueryGenerationOptionsArgs']] = None,
                 s3_vectors_engine: Optional[pulumi.Input['DomainAimlOptionsS3VectorsEngineArgs']] = None):
        if natural_language_query_generation_options is not None:
            pulumi.set(__self__, "natural_language_query_generation_options", natural_language_query_generation_options)
        if s3_vectors_engine is not None:
            pulumi.set(__self__, "s3_vectors_engine", s3_vectors_engine)

    @_builtins.property
    @pulumi.getter(name="naturalLanguageQueryGenerationOptions")
    def natural_language_query_generation_options(self) -> Optional[pulumi.Input['DomainAimlOptionsNaturalLanguageQueryGenerationOptionsArgs']]:
        return pulumi.get(self, "natural_language_query_generation_options")

    @natural_language_query_generation_options.setter
    def natural_language_query_generation_options(self, value: Optional[pulumi.Input['DomainAimlOptionsNaturalLanguageQueryGenerationOptionsArgs']]):
        pulumi.set(self, "natural_language_query_generation_options", value)

    @_builtins.property
    @pulumi.getter(name="s3VectorsEngine")
    def s3_vectors_engine(self) -> Optional[pulumi.Input['DomainAimlOptionsS3VectorsEngineArgs']]:
        return pulumi.get(self, "s3_vectors_engine")

    @s3_vectors_engine.setter
    def s3_vectors_engine(self, value: Optional[pulumi.Input['DomainAimlOptionsS3VectorsEngineArgs']]):
        pulumi.set(self, "s3_vectors_engine", value)


if not MYPY:
    class DomainAimlOptionsNaturalLanguageQueryGenerationOptionsArgsDict(TypedDict):
        desired_state: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DomainAimlOptionsNaturalLanguageQueryGenerationOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainAimlOptionsNaturalLanguageQueryGenerationOptionsArgs:
    def __init__(__self__, *,
                 desired_state: Optional[pulumi.Input[_builtins.str]] = None):
        if desired_state is not None:
            pulumi.set(__self__, "desired_state", desired_state)

    @_builtins.property
    @pulumi.getter(name="desiredState")
    def desired_state(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "desired_state")

    @desired_state.setter
    def desired_state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "desired_state", value)


if not MYPY:
    class DomainAimlOptionsS3VectorsEngineArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    DomainAimlOptionsS3VectorsEngineArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainAimlOptionsS3VectorsEngineArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class DomainAutoTuneOptionsArgsDict(TypedDict):
        desired_state: pulumi.Input[_builtins.str]
        maintenance_schedules: NotRequired[pulumi.Input[Sequence[pulumi.Input['DomainAutoTuneOptionsMaintenanceScheduleArgsDict']]]]
        rollback_on_disable: NotRequired[pulumi.Input[_builtins.str]]
        use_off_peak_window: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    DomainAutoTuneOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainAutoTuneOptionsArgs:
    def __init__(__self__, *,
                 desired_state: pulumi.Input[_builtins.str],
                 maintenance_schedules: Optional[pulumi.Input[Sequence[pulumi.Input['DomainAutoTuneOptionsMaintenanceScheduleArgs']]]] = None,
                 rollback_on_disable: Optional[pulumi.Input[_builtins.str]] = None,
                 use_off_peak_window: Optional[pulumi.Input[_builtins.bool]] = None):
        pulumi.set(__self__, "desired_state", desired_state)
        if maintenance_schedules is not None:
            pulumi.set(__self__, "maintenance_schedules", maintenance_schedules)
        if rollback_on_disable is not None:
            pulumi.set(__self__, "rollback_on_disable", rollback_on_disable)
        if use_off_peak_window is not None:
            pulumi.set(__self__, "use_off_peak_window", use_off_peak_window)

    @_builtins.property
    @pulumi.getter(name="desiredState")
    def desired_state(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "desired_state")

    @desired_state.setter
    def desired_state(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "desired_state", value)

    @_builtins.property
    @pulumi.getter(name="maintenanceSchedules")
    def maintenance_schedules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DomainAutoTuneOptionsMaintenanceScheduleArgs']]]]:
        return pulumi.get(self, "maintenance_schedules")

    @maintenance_schedules.setter
    def maintenance_schedules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DomainAutoTuneOptionsMaintenanceScheduleArgs']]]]):
        pulumi.set(self, "maintenance_schedules", value)

    @_builtins.property
    @pulumi.getter(name="rollbackOnDisable")
    def rollback_on_disable(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "rollback_on_disable")

    @rollback_on_disable.setter
    def rollback_on_disable(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "rollback_on_disable", value)

    @_builtins.property
    @pulumi.getter(name="useOffPeakWindow")
    def use_off_peak_window(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "use_off_peak_window")

    @use_off_peak_window.setter
    def use_off_peak_window(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_off_peak_window", value)


if not MYPY:
    class DomainAutoTuneOptionsMaintenanceScheduleArgsDict(TypedDict):
        cron_expression_for_recurrence: pulumi.Input[_builtins.str]
        duration: pulumi.Input['DomainAutoTuneOptionsMaintenanceScheduleDurationArgsDict']
        start_at: pulumi.Input[_builtins.str]
elif False:
    DomainAutoTuneOptionsMaintenanceScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainAutoTuneOptionsMaintenanceScheduleArgs:
    def __init__(__self__, *,
                 cron_expression_for_recurrence: pulumi.Input[_builtins.str],
                 duration: pulumi.Input['DomainAutoTuneOptionsMaintenanceScheduleDurationArgs'],
                 start_at: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "cron_expression_for_recurrence", cron_expression_for_recurrence)
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "start_at", start_at)

    @_builtins.property
    @pulumi.getter(name="cronExpressionForRecurrence")
    def cron_expression_for_recurrence(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "cron_expression_for_recurrence")

    @cron_expression_for_recurrence.setter
    def cron_expression_for_recurrence(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cron_expression_for_recurrence", value)

    @_builtins.property
    @pulumi.getter
    def duration(self) -> pulumi.Input['DomainAutoTuneOptionsMaintenanceScheduleDurationArgs']:
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: pulumi.Input['DomainAutoTuneOptionsMaintenanceScheduleDurationArgs']):
        pulumi.set(self, "duration", value)

    @_builtins.property
    @pulumi.getter(name="startAt")
    def start_at(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "start_at")

    @start_at.setter
    def start_at(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "start_at", value)


if not MYPY:
    class DomainAutoTuneOptionsMaintenanceScheduleDurationArgsDict(TypedDict):
        unit: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.int]
elif False:
    DomainAutoTuneOptionsMaintenanceScheduleDurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainAutoTuneOptionsMaintenanceScheduleDurationArgs:
    def __init__(__self__, *,
                 unit: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.int]):
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def unit(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "unit", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DomainClusterConfigArgsDict(TypedDict):
        cold_storage_options: NotRequired[pulumi.Input['DomainClusterConfigColdStorageOptionsArgsDict']]
        dedicated_master_count: NotRequired[pulumi.Input[_builtins.int]]
        dedicated_master_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        dedicated_master_type: NotRequired[pulumi.Input[_builtins.str]]
        instance_count: NotRequired[pulumi.Input[_builtins.int]]
        instance_type: NotRequired[pulumi.Input[_builtins.str]]
        multi_az_with_standby_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        node_options: NotRequired[pulumi.Input[Sequence[pulumi.Input['DomainClusterConfigNodeOptionArgsDict']]]]
        warm_count: NotRequired[pulumi.Input[_builtins.int]]
        warm_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        warm_type: NotRequired[pulumi.Input[_builtins.str]]
        zone_awareness_config: NotRequired[pulumi.Input['DomainClusterConfigZoneAwarenessConfigArgsDict']]
        zone_awareness_enabled: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    DomainClusterConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainClusterConfigArgs:
    def __init__(__self__, *,
                 cold_storage_options: Optional[pulumi.Input['DomainClusterConfigColdStorageOptionsArgs']] = None,
                 dedicated_master_count: Optional[pulumi.Input[_builtins.int]] = None,
                 dedicated_master_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 dedicated_master_type: Optional[pulumi.Input[_builtins.str]] = None,
                 instance_count: Optional[pulumi.Input[_builtins.int]] = None,
                 instance_type: Optional[pulumi.Input[_builtins.str]] = None,
                 multi_az_with_standby_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 node_options: Optional[pulumi.Input[Sequence[pulumi.Input['DomainClusterConfigNodeOptionArgs']]]] = None,
                 warm_count: Optional[pulumi.Input[_builtins.int]] = None,
                 warm_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 warm_type: Optional[pulumi.Input[_builtins.str]] = None,
                 zone_awareness_config: Optional[pulumi.Input['DomainClusterConfigZoneAwarenessConfigArgs']] = None,
                 zone_awareness_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        if cold_storage_options is not None:
            pulumi.set(__self__, "cold_storage_options", cold_storage_options)
        if dedicated_master_count is not None:
            pulumi.set(__self__, "dedicated_master_count", dedicated_master_count)
        if dedicated_master_enabled is not None:
            pulumi.set(__self__, "dedicated_master_enabled", dedicated_master_enabled)
        if dedicated_master_type is not None:
            pulumi.set(__self__, "dedicated_master_type", dedicated_master_type)
        if instance_count is not None:
            pulumi.set(__self__, "instance_count", instance_count)
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if multi_az_with_standby_enabled is not None:
            pulumi.set(__self__, "multi_az_with_standby_enabled", multi_az_with_standby_enabled)
        if node_options is not None:
            pulumi.set(__self__, "node_options", node_options)
        if warm_count is not None:
            pulumi.set(__self__, "warm_count", warm_count)
        if warm_enabled is not None:
            pulumi.set(__self__, "warm_enabled", warm_enabled)
        if warm_type is not None:
            pulumi.set(__self__, "warm_type", warm_type)
        if zone_awareness_config is not None:
            pulumi.set(__self__, "zone_awareness_config", zone_awareness_config)
        if zone_awareness_enabled is not None:
            pulumi.set(__self__, "zone_awareness_enabled", zone_awareness_enabled)

    @_builtins.property
    @pulumi.getter(name="coldStorageOptions")
    def cold_storage_options(self) -> Optional[pulumi.Input['DomainClusterConfigColdStorageOptionsArgs']]:
        return pulumi.get(self, "cold_storage_options")

    @cold_storage_options.setter
    def cold_storage_options(self, value: Optional[pulumi.Input['DomainClusterConfigColdStorageOptionsArgs']]):
        pulumi.set(self, "cold_storage_options", value)

    @_builtins.property
    @pulumi.getter(name="dedicatedMasterCount")
    def dedicated_master_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "dedicated_master_count")

    @dedicated_master_count.setter
    def dedicated_master_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "dedicated_master_count", value)

    @_builtins.property
    @pulumi.getter(name="dedicatedMasterEnabled")
    def dedicated_master_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "dedicated_master_enabled")

    @dedicated_master_enabled.setter
    def dedicated_master_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "dedicated_master_enabled", value)

    @_builtins.property
    @pulumi.getter(name="dedicatedMasterType")
    def dedicated_master_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "dedicated_master_type")

    @dedicated_master_type.setter
    def dedicated_master_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dedicated_master_type", value)

    @_builtins.property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "instance_count")

    @instance_count.setter
    def instance_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "instance_count", value)

    @_builtins.property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "instance_type")

    @instance_type.setter
    def instance_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "instance_type", value)

    @_builtins.property
    @pulumi.getter(name="multiAzWithStandbyEnabled")
    def multi_az_with_standby_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "multi_az_with_standby_enabled")

    @multi_az_with_standby_enabled.setter
    def multi_az_with_standby_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "multi_az_with_standby_enabled", value)

    @_builtins.property
    @pulumi.getter(name="nodeOptions")
    def node_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DomainClusterConfigNodeOptionArgs']]]]:
        return pulumi.get(self, "node_options")

    @node_options.setter
    def node_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DomainClusterConfigNodeOptionArgs']]]]):
        pulumi.set(self, "node_options", value)

    @_builtins.property
    @pulumi.getter(name="warmCount")
    def warm_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "warm_count")

    @warm_count.setter
    def warm_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "warm_count", value)

    @_builtins.property
    @pulumi.getter(name="warmEnabled")
    def warm_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "warm_enabled")

    @warm_enabled.setter
    def warm_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "warm_enabled", value)

    @_builtins.property
    @pulumi.getter(name="warmType")
    def warm_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "warm_type")

    @warm_type.setter
    def warm_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "warm_type", value)

    @_builtins.property
    @pulumi.getter(name="zoneAwarenessConfig")
    def zone_awareness_config(self) -> Optional[pulumi.Input['DomainClusterConfigZoneAwarenessConfigArgs']]:
        return pulumi.get(self, "zone_awareness_config")

    @zone_awareness_config.setter
    def zone_awareness_config(self, value: Optional[pulumi.Input['DomainClusterConfigZoneAwarenessConfigArgs']]):
        pulumi.set(self, "zone_awareness_config", value)

    @_builtins.property
    @pulumi.getter(name="zoneAwarenessEnabled")
    def zone_awareness_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "zone_awareness_enabled")

    @zone_awareness_enabled.setter
    def zone_awareness_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "zone_awareness_enabled", value)


if not MYPY:
    class DomainClusterConfigColdStorageOptionsArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    DomainClusterConfigColdStorageOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainClusterConfigColdStorageOptionsArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class DomainClusterConfigNodeOptionArgsDict(TypedDict):
        node_config: NotRequired[pulumi.Input['DomainClusterConfigNodeOptionNodeConfigArgsDict']]
        node_type: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DomainClusterConfigNodeOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainClusterConfigNodeOptionArgs:
    def __init__(__self__, *,
                 node_config: Optional[pulumi.Input['DomainClusterConfigNodeOptionNodeConfigArgs']] = None,
                 node_type: Optional[pulumi.Input[_builtins.str]] = None):
        if node_config is not None:
            pulumi.set(__self__, "node_config", node_config)
        if node_type is not None:
            pulumi.set(__self__, "node_type", node_type)

    @_builtins.property
    @pulumi.getter(name="nodeConfig")
    def node_config(self) -> Optional[pulumi.Input['DomainClusterConfigNodeOptionNodeConfigArgs']]:
        return pulumi.get(self, "node_config")

    @node_config.setter
    def node_config(self, value: Optional[pulumi.Input['DomainClusterConfigNodeOptionNodeConfigArgs']]):
        pulumi.set(self, "node_config", value)

    @_builtins.property
    @pulumi.getter(name="nodeType")
    def node_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "node_type")

    @node_type.setter
    def node_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "node_type", value)


if not MYPY:
    class DomainClusterConfigNodeOptionNodeConfigArgsDict(TypedDict):
        count: NotRequired[pulumi.Input[_builtins.int]]
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        type: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DomainClusterConfigNodeOptionNodeConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainClusterConfigNodeOptionNodeConfigArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[_builtins.int]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        if count is not None:
            pulumi.set(__self__, "count", count)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "count", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DomainClusterConfigZoneAwarenessConfigArgsDict(TypedDict):
        availability_zone_count: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    DomainClusterConfigZoneAwarenessConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainClusterConfigZoneAwarenessConfigArgs:
    def __init__(__self__, *,
                 availability_zone_count: Optional[pulumi.Input[_builtins.int]] = None):
        if availability_zone_count is not None:
            pulumi.set(__self__, "availability_zone_count", availability_zone_count)

    @_builtins.property
    @pulumi.getter(name="availabilityZoneCount")
    def availability_zone_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "availability_zone_count")

    @availability_zone_count.setter
    def availability_zone_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "availability_zone_count", value)


if not MYPY:
    class DomainCognitoOptionsArgsDict(TypedDict):
        identity_pool_id: pulumi.Input[_builtins.str]
        role_arn: pulumi.Input[_builtins.str]
        user_pool_id: pulumi.Input[_builtins.str]
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    DomainCognitoOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainCognitoOptionsArgs:
    def __init__(__self__, *,
                 identity_pool_id: pulumi.Input[_builtins.str],
                 role_arn: pulumi.Input[_builtins.str],
                 user_pool_id: pulumi.Input[_builtins.str],
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        pulumi.set(__self__, "identity_pool_id", identity_pool_id)
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "user_pool_id", user_pool_id)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter(name="identityPoolId")
    def identity_pool_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "identity_pool_id")

    @identity_pool_id.setter
    def identity_pool_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_pool_id", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="userPoolId")
    def user_pool_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "user_pool_id")

    @user_pool_id.setter
    def user_pool_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "user_pool_id", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class DomainDomainEndpointOptionsArgsDict(TypedDict):
        custom_endpoint: NotRequired[pulumi.Input[_builtins.str]]
        custom_endpoint_certificate_arn: NotRequired[pulumi.Input[_builtins.str]]
        custom_endpoint_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        enforce_https: NotRequired[pulumi.Input[_builtins.bool]]
        tls_security_policy: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DomainDomainEndpointOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainDomainEndpointOptionsArgs:
    def __init__(__self__, *,
                 custom_endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 custom_endpoint_certificate_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 custom_endpoint_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 enforce_https: Optional[pulumi.Input[_builtins.bool]] = None,
                 tls_security_policy: Optional[pulumi.Input[_builtins.str]] = None):
        if custom_endpoint is not None:
            pulumi.set(__self__, "custom_endpoint", custom_endpoint)
        if custom_endpoint_certificate_arn is not None:
            pulumi.set(__self__, "custom_endpoint_certificate_arn", custom_endpoint_certificate_arn)
        if custom_endpoint_enabled is not None:
            pulumi.set(__self__, "custom_endpoint_enabled", custom_endpoint_enabled)
        if enforce_https is not None:
            pulumi.set(__self__, "enforce_https", enforce_https)
        if tls_security_policy is not None:
            pulumi.set(__self__, "tls_security_policy", tls_security_policy)

    @_builtins.property
    @pulumi.getter(name="customEndpoint")
    def custom_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "custom_endpoint")

    @custom_endpoint.setter
    def custom_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "custom_endpoint", value)

    @_builtins.property
    @pulumi.getter(name="customEndpointCertificateArn")
    def custom_endpoint_certificate_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "custom_endpoint_certificate_arn")

    @custom_endpoint_certificate_arn.setter
    def custom_endpoint_certificate_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "custom_endpoint_certificate_arn", value)

    @_builtins.property
    @pulumi.getter(name="customEndpointEnabled")
    def custom_endpoint_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "custom_endpoint_enabled")

    @custom_endpoint_enabled.setter
    def custom_endpoint_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "custom_endpoint_enabled", value)

    @_builtins.property
    @pulumi.getter(name="enforceHttps")
    def enforce_https(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "enforce_https")

    @enforce_https.setter
    def enforce_https(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enforce_https", value)

    @_builtins.property
    @pulumi.getter(name="tlsSecurityPolicy")
    def tls_security_policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "tls_security_policy")

    @tls_security_policy.setter
    def tls_security_policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tls_security_policy", value)


if not MYPY:
    class DomainEbsOptionsArgsDict(TypedDict):
        ebs_enabled: pulumi.Input[_builtins.bool]
        iops: NotRequired[pulumi.Input[_builtins.int]]
        throughput: NotRequired[pulumi.Input[_builtins.int]]
        volume_size: NotRequired[pulumi.Input[_builtins.int]]
        volume_type: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DomainEbsOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainEbsOptionsArgs:
    def __init__(__self__, *,
                 ebs_enabled: pulumi.Input[_builtins.bool],
                 iops: Optional[pulumi.Input[_builtins.int]] = None,
                 throughput: Optional[pulumi.Input[_builtins.int]] = None,
                 volume_size: Optional[pulumi.Input[_builtins.int]] = None,
                 volume_type: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "ebs_enabled", ebs_enabled)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter(name="ebsEnabled")
    def ebs_enabled(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "ebs_enabled")

    @ebs_enabled.setter
    def ebs_enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "ebs_enabled", value)

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "iops", value)

    @_builtins.property
    @pulumi.getter
    def throughput(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "throughput")

    @throughput.setter
    def throughput(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "throughput", value)

    @_builtins.property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "volume_size")

    @volume_size.setter
    def volume_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "volume_size", value)

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "volume_type")

    @volume_type.setter
    def volume_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "volume_type", value)


if not MYPY:
    class DomainEncryptAtRestArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        kms_key_id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DomainEncryptAtRestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainEncryptAtRestArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 kms_key_id: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "enabled", enabled)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kms_key_id", value)


if not MYPY:
    class DomainIdentityCenterOptionsArgsDict(TypedDict):
        enabled_api_access: NotRequired[pulumi.Input[_builtins.bool]]
        identity_center_instance_arn: NotRequired[pulumi.Input[_builtins.str]]
        roles_key: NotRequired[pulumi.Input[_builtins.str]]
        subject_key: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DomainIdentityCenterOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainIdentityCenterOptionsArgs:
    def __init__(__self__, *,
                 enabled_api_access: Optional[pulumi.Input[_builtins.bool]] = None,
                 identity_center_instance_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 roles_key: Optional[pulumi.Input[_builtins.str]] = None,
                 subject_key: Optional[pulumi.Input[_builtins.str]] = None):
        if enabled_api_access is not None:
            pulumi.set(__self__, "enabled_api_access", enabled_api_access)
        if identity_center_instance_arn is not None:
            pulumi.set(__self__, "identity_center_instance_arn", identity_center_instance_arn)
        if roles_key is not None:
            pulumi.set(__self__, "roles_key", roles_key)
        if subject_key is not None:
            pulumi.set(__self__, "subject_key", subject_key)

    @_builtins.property
    @pulumi.getter(name="enabledApiAccess")
    def enabled_api_access(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "enabled_api_access")

    @enabled_api_access.setter
    def enabled_api_access(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled_api_access", value)

    @_builtins.property
    @pulumi.getter(name="identityCenterInstanceArn")
    def identity_center_instance_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "identity_center_instance_arn")

    @identity_center_instance_arn.setter
    def identity_center_instance_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "identity_center_instance_arn", value)

    @_builtins.property
    @pulumi.getter(name="rolesKey")
    def roles_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "roles_key")

    @roles_key.setter
    def roles_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "roles_key", value)

    @_builtins.property
    @pulumi.getter(name="subjectKey")
    def subject_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "subject_key")

    @subject_key.setter
    def subject_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subject_key", value)


if not MYPY:
    class DomainLogPublishingOptionArgsDict(TypedDict):
        cloudwatch_log_group_arn: pulumi.Input[_builtins.str]
        log_type: pulumi.Input[_builtins.str]
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    DomainLogPublishingOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainLogPublishingOptionArgs:
    def __init__(__self__, *,
                 cloudwatch_log_group_arn: pulumi.Input[_builtins.str],
                 log_type: pulumi.Input[_builtins.str],
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        pulumi.set(__self__, "cloudwatch_log_group_arn", cloudwatch_log_group_arn)
        pulumi.set(__self__, "log_type", log_type)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter(name="cloudwatchLogGroupArn")
    def cloudwatch_log_group_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "cloudwatch_log_group_arn")

    @cloudwatch_log_group_arn.setter
    def cloudwatch_log_group_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cloudwatch_log_group_arn", value)

    @_builtins.property
    @pulumi.getter(name="logType")
    def log_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "log_type")

    @log_type.setter
    def log_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "log_type", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class DomainNodeToNodeEncryptionArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
elif False:
    DomainNodeToNodeEncryptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainNodeToNodeEncryptionArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool]):
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class DomainOffPeakWindowOptionsArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        off_peak_window: NotRequired[pulumi.Input['DomainOffPeakWindowOptionsOffPeakWindowArgsDict']]
elif False:
    DomainOffPeakWindowOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainOffPeakWindowOptionsArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 off_peak_window: Optional[pulumi.Input['DomainOffPeakWindowOptionsOffPeakWindowArgs']] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if off_peak_window is not None:
            pulumi.set(__self__, "off_peak_window", off_peak_window)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="offPeakWindow")
    def off_peak_window(self) -> Optional[pulumi.Input['DomainOffPeakWindowOptionsOffPeakWindowArgs']]:
        return pulumi.get(self, "off_peak_window")

    @off_peak_window.setter
    def off_peak_window(self, value: Optional[pulumi.Input['DomainOffPeakWindowOptionsOffPeakWindowArgs']]):
        pulumi.set(self, "off_peak_window", value)


if not MYPY:
    class DomainOffPeakWindowOptionsOffPeakWindowArgsDict(TypedDict):
        window_start_time: NotRequired[pulumi.Input['DomainOffPeakWindowOptionsOffPeakWindowWindowStartTimeArgsDict']]
elif False:
    DomainOffPeakWindowOptionsOffPeakWindowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainOffPeakWindowOptionsOffPeakWindowArgs:
    def __init__(__self__, *,
                 window_start_time: Optional[pulumi.Input['DomainOffPeakWindowOptionsOffPeakWindowWindowStartTimeArgs']] = None):
        if window_start_time is not None:
            pulumi.set(__self__, "window_start_time", window_start_time)

    @_builtins.property
    @pulumi.getter(name="windowStartTime")
    def window_start_time(self) -> Optional[pulumi.Input['DomainOffPeakWindowOptionsOffPeakWindowWindowStartTimeArgs']]:
        return pulumi.get(self, "window_start_time")

    @window_start_time.setter
    def window_start_time(self, value: Optional[pulumi.Input['DomainOffPeakWindowOptionsOffPeakWindowWindowStartTimeArgs']]):
        pulumi.set(self, "window_start_time", value)


if not MYPY:
    class DomainOffPeakWindowOptionsOffPeakWindowWindowStartTimeArgsDict(TypedDict):
        hours: NotRequired[pulumi.Input[_builtins.int]]
        minutes: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    DomainOffPeakWindowOptionsOffPeakWindowWindowStartTimeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainOffPeakWindowOptionsOffPeakWindowWindowStartTimeArgs:
    def __init__(__self__, *,
                 hours: Optional[pulumi.Input[_builtins.int]] = None,
                 minutes: Optional[pulumi.Input[_builtins.int]] = None):
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)

    @_builtins.property
    @pulumi.getter
    def hours(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "hours", value)

    @_builtins.property
    @pulumi.getter
    def minutes(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "minutes", value)


if not MYPY:
    class DomainSamlOptionsSamlOptionsArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        idp: NotRequired[pulumi.Input['DomainSamlOptionsSamlOptionsIdpArgsDict']]
        master_backend_role: NotRequired[pulumi.Input[_builtins.str]]
        master_user_name: NotRequired[pulumi.Input[_builtins.str]]
        roles_key: NotRequired[pulumi.Input[_builtins.str]]
        session_timeout_minutes: NotRequired[pulumi.Input[_builtins.int]]
        subject_key: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DomainSamlOptionsSamlOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainSamlOptionsSamlOptionsArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 idp: Optional[pulumi.Input['DomainSamlOptionsSamlOptionsIdpArgs']] = None,
                 master_backend_role: Optional[pulumi.Input[_builtins.str]] = None,
                 master_user_name: Optional[pulumi.Input[_builtins.str]] = None,
                 roles_key: Optional[pulumi.Input[_builtins.str]] = None,
                 session_timeout_minutes: Optional[pulumi.Input[_builtins.int]] = None,
                 subject_key: Optional[pulumi.Input[_builtins.str]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if idp is not None:
            pulumi.set(__self__, "idp", idp)
        if master_backend_role is not None:
            pulumi.set(__self__, "master_backend_role", master_backend_role)
        if master_user_name is not None:
            pulumi.set(__self__, "master_user_name", master_user_name)
        if roles_key is not None:
            pulumi.set(__self__, "roles_key", roles_key)
        if session_timeout_minutes is not None:
            pulumi.set(__self__, "session_timeout_minutes", session_timeout_minutes)
        if subject_key is not None:
            pulumi.set(__self__, "subject_key", subject_key)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def idp(self) -> Optional[pulumi.Input['DomainSamlOptionsSamlOptionsIdpArgs']]:
        return pulumi.get(self, "idp")

    @idp.setter
    def idp(self, value: Optional[pulumi.Input['DomainSamlOptionsSamlOptionsIdpArgs']]):
        pulumi.set(self, "idp", value)

    @_builtins.property
    @pulumi.getter(name="masterBackendRole")
    def master_backend_role(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "master_backend_role")

    @master_backend_role.setter
    def master_backend_role(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "master_backend_role", value)

    @_builtins.property
    @pulumi.getter(name="masterUserName")
    def master_user_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "master_user_name")

    @master_user_name.setter
    def master_user_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "master_user_name", value)

    @_builtins.property
    @pulumi.getter(name="rolesKey")
    def roles_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "roles_key")

    @roles_key.setter
    def roles_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "roles_key", value)

    @_builtins.property
    @pulumi.getter(name="sessionTimeoutMinutes")
    def session_timeout_minutes(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "session_timeout_minutes")

    @session_timeout_minutes.setter
    def session_timeout_minutes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "session_timeout_minutes", value)

    @_builtins.property
    @pulumi.getter(name="subjectKey")
    def subject_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "subject_key")

    @subject_key.setter
    def subject_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subject_key", value)


if not MYPY:
    class DomainSamlOptionsSamlOptionsIdpArgsDict(TypedDict):
        entity_id: pulumi.Input[_builtins.str]
        metadata_content: pulumi.Input[_builtins.str]
elif False:
    DomainSamlOptionsSamlOptionsIdpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainSamlOptionsSamlOptionsIdpArgs:
    def __init__(__self__, *,
                 entity_id: pulumi.Input[_builtins.str],
                 metadata_content: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "entity_id", entity_id)
        pulumi.set(__self__, "metadata_content", metadata_content)

    @_builtins.property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "entity_id")

    @entity_id.setter
    def entity_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "entity_id", value)

    @_builtins.property
    @pulumi.getter(name="metadataContent")
    def metadata_content(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "metadata_content")

    @metadata_content.setter
    def metadata_content(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "metadata_content", value)


if not MYPY:
    class DomainSnapshotOptionsArgsDict(TypedDict):
        automated_snapshot_start_hour: pulumi.Input[_builtins.int]
elif False:
    DomainSnapshotOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainSnapshotOptionsArgs:
    def __init__(__self__, *,
                 automated_snapshot_start_hour: pulumi.Input[_builtins.int]):
        pulumi.set(__self__, "automated_snapshot_start_hour", automated_snapshot_start_hour)

    @_builtins.property
    @pulumi.getter(name="automatedSnapshotStartHour")
    def automated_snapshot_start_hour(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "automated_snapshot_start_hour")

    @automated_snapshot_start_hour.setter
    def automated_snapshot_start_hour(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "automated_snapshot_start_hour", value)


if not MYPY:
    class DomainSoftwareUpdateOptionsArgsDict(TypedDict):
        auto_software_update_enabled: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    DomainSoftwareUpdateOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainSoftwareUpdateOptionsArgs:
    def __init__(__self__, *,
                 auto_software_update_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        if auto_software_update_enabled is not None:
            pulumi.set(__self__, "auto_software_update_enabled", auto_software_update_enabled)

    @_builtins.property
    @pulumi.getter(name="autoSoftwareUpdateEnabled")
    def auto_software_update_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "auto_software_update_enabled")

    @auto_software_update_enabled.setter
    def auto_software_update_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "auto_software_update_enabled", value)


if not MYPY:
    class DomainVpcOptionsArgsDict(TypedDict):
        availability_zones: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        security_group_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        subnet_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        vpc_id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DomainVpcOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainVpcOptionsArgs:
    def __init__(__self__, *,
                 availability_zones: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 security_group_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 subnet_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 vpc_id: Optional[pulumi.Input[_builtins.str]] = None):
        if availability_zones is not None:
            pulumi.set(__self__, "availability_zones", availability_zones)
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)
        if subnet_ids is not None:
            pulumi.set(__self__, "subnet_ids", subnet_ids)
        if vpc_id is not None:
            pulumi.set(__self__, "vpc_id", vpc_id)

    @_builtins.property
    @pulumi.getter(name="availabilityZones")
    def availability_zones(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "availability_zones")

    @availability_zones.setter
    def availability_zones(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "availability_zones", value)

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "security_group_ids")

    @security_group_ids.setter
    def security_group_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "security_group_ids", value)

    @_builtins.property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "subnet_ids")

    @subnet_ids.setter
    def subnet_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "subnet_ids", value)

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "vpc_id")

    @vpc_id.setter
    def vpc_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vpc_id", value)


if not MYPY:
    class OutboundConnectionConnectionPropertiesArgsDict(TypedDict):
        cross_cluster_search: NotRequired[pulumi.Input['OutboundConnectionConnectionPropertiesCrossClusterSearchArgsDict']]
        endpoint: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    OutboundConnectionConnectionPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OutboundConnectionConnectionPropertiesArgs:
    def __init__(__self__, *,
                 cross_cluster_search: Optional[pulumi.Input['OutboundConnectionConnectionPropertiesCrossClusterSearchArgs']] = None,
                 endpoint: Optional[pulumi.Input[_builtins.str]] = None):
        if cross_cluster_search is not None:
            pulumi.set(__self__, "cross_cluster_search", cross_cluster_search)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)

    @_builtins.property
    @pulumi.getter(name="crossClusterSearch")
    def cross_cluster_search(self) -> Optional[pulumi.Input['OutboundConnectionConnectionPropertiesCrossClusterSearchArgs']]:
        return pulumi.get(self, "cross_cluster_search")

    @cross_cluster_search.setter
    def cross_cluster_search(self, value: Optional[pulumi.Input['OutboundConnectionConnectionPropertiesCrossClusterSearchArgs']]):
        pulumi.set(self, "cross_cluster_search", value)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "endpoint", value)


if not MYPY:
    class OutboundConnectionConnectionPropertiesCrossClusterSearchArgsDict(TypedDict):
        skip_unavailable: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    OutboundConnectionConnectionPropertiesCrossClusterSearchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OutboundConnectionConnectionPropertiesCrossClusterSearchArgs:
    def __init__(__self__, *,
                 skip_unavailable: Optional[pulumi.Input[_builtins.str]] = None):
        if skip_unavailable is not None:
            pulumi.set(__self__, "skip_unavailable", skip_unavailable)

    @_builtins.property
    @pulumi.getter(name="skipUnavailable")
    def skip_unavailable(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "skip_unavailable")

    @skip_unavailable.setter
    def skip_unavailable(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "skip_unavailable", value)


if not MYPY:
    class OutboundConnectionLocalDomainInfoArgsDict(TypedDict):
        domain_name: pulumi.Input[_builtins.str]
        owner_id: pulumi.Input[_builtins.str]
        region: pulumi.Input[_builtins.str]
elif False:
    OutboundConnectionLocalDomainInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OutboundConnectionLocalDomainInfoArgs:
    def __init__(__self__, *,
                 domain_name: pulumi.Input[_builtins.str],
                 owner_id: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "domain_name", domain_name)
        pulumi.set(__self__, "owner_id", owner_id)
        pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "domain_name")

    @domain_name.setter
    def domain_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "domain_name", value)

    @_builtins.property
    @pulumi.getter(name="ownerId")
    def owner_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "owner_id")

    @owner_id.setter
    def owner_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "owner_id", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)


if not MYPY:
    class OutboundConnectionRemoteDomainInfoArgsDict(TypedDict):
        domain_name: pulumi.Input[_builtins.str]
        owner_id: pulumi.Input[_builtins.str]
        region: pulumi.Input[_builtins.str]
elif False:
    OutboundConnectionRemoteDomainInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OutboundConnectionRemoteDomainInfoArgs:
    def __init__(__self__, *,
                 domain_name: pulumi.Input[_builtins.str],
                 owner_id: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "domain_name", domain_name)
        pulumi.set(__self__, "owner_id", owner_id)
        pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "domain_name")

    @domain_name.setter
    def domain_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "domain_name", value)

    @_builtins.property
    @pulumi.getter(name="ownerId")
    def owner_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "owner_id")

    @owner_id.setter
    def owner_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "owner_id", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)


if not MYPY:
    class PackagePackageSourceArgsDict(TypedDict):
        s3_bucket_name: pulumi.Input[_builtins.str]
        s3_key: pulumi.Input[_builtins.str]
elif False:
    PackagePackageSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PackagePackageSourceArgs:
    def __init__(__self__, *,
                 s3_bucket_name: pulumi.Input[_builtins.str],
                 s3_key: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "s3_bucket_name", s3_bucket_name)
        pulumi.set(__self__, "s3_key", s3_key)

    @_builtins.property
    @pulumi.getter(name="s3BucketName")
    def s3_bucket_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "s3_bucket_name")

    @s3_bucket_name.setter
    def s3_bucket_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "s3_bucket_name", value)

    @_builtins.property
    @pulumi.getter(name="s3Key")
    def s3_key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "s3_key")

    @s3_key.setter
    def s3_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "s3_key", value)


if not MYPY:
    class ServerlessCollectionTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
elif False:
    ServerlessCollectionTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerlessCollectionTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)


if not MYPY:
    class ServerlessSecurityConfigSamlOptionsArgsDict(TypedDict):
        metadata: pulumi.Input[_builtins.str]
        """
        The XML IdP metadata file generated from your identity provider.
        """
        group_attribute: NotRequired[pulumi.Input[_builtins.str]]
        """
        Group attribute for this SAML integration.
        """
        session_timeout: NotRequired[pulumi.Input[_builtins.int]]
        """
        Session timeout, in minutes. Minimum is 5 minutes and maximum is 720 minutes (12 hours). Default is 60 minutes.
        """
        user_attribute: NotRequired[pulumi.Input[_builtins.str]]
        """
        User attribute for this SAML integration.
        """
elif False:
    ServerlessSecurityConfigSamlOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerlessSecurityConfigSamlOptionsArgs:
    def __init__(__self__, *,
                 metadata: pulumi.Input[_builtins.str],
                 group_attribute: Optional[pulumi.Input[_builtins.str]] = None,
                 session_timeout: Optional[pulumi.Input[_builtins.int]] = None,
                 user_attribute: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] metadata: The XML IdP metadata file generated from your identity provider.
        :param pulumi.Input[_builtins.str] group_attribute: Group attribute for this SAML integration.
        :param pulumi.Input[_builtins.int] session_timeout: Session timeout, in minutes. Minimum is 5 minutes and maximum is 720 minutes (12 hours). Default is 60 minutes.
        :param pulumi.Input[_builtins.str] user_attribute: User attribute for this SAML integration.
        """
        pulumi.set(__self__, "metadata", metadata)
        if group_attribute is not None:
            pulumi.set(__self__, "group_attribute", group_attribute)
        if session_timeout is not None:
            pulumi.set(__self__, "session_timeout", session_timeout)
        if user_attribute is not None:
            pulumi.set(__self__, "user_attribute", user_attribute)

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> pulumi.Input[_builtins.str]:
        """
        The XML IdP metadata file generated from your identity provider.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "metadata", value)

    @_builtins.property
    @pulumi.getter(name="groupAttribute")
    def group_attribute(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Group attribute for this SAML integration.
        """
        return pulumi.get(self, "group_attribute")

    @group_attribute.setter
    def group_attribute(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_attribute", value)

    @_builtins.property
    @pulumi.getter(name="sessionTimeout")
    def session_timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Session timeout, in minutes. Minimum is 5 minutes and maximum is 720 minutes (12 hours). Default is 60 minutes.
        """
        return pulumi.get(self, "session_timeout")

    @session_timeout.setter
    def session_timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "session_timeout", value)

    @_builtins.property
    @pulumi.getter(name="userAttribute")
    def user_attribute(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        User attribute for this SAML integration.
        """
        return pulumi.get(self, "user_attribute")

    @user_attribute.setter
    def user_attribute(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user_attribute", value)


if not MYPY:
    class ServerlessVpcEndpointTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    ServerlessVpcEndpointTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerlessVpcEndpointTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class VpcEndpointVpcOptionsArgsDict(TypedDict):
        subnet_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        availability_zones: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        security_group_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        vpc_id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    VpcEndpointVpcOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcEndpointVpcOptionsArgs:
    def __init__(__self__, *,
                 subnet_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 availability_zones: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 security_group_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 vpc_id: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "subnet_ids", subnet_ids)
        if availability_zones is not None:
            pulumi.set(__self__, "availability_zones", availability_zones)
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)
        if vpc_id is not None:
            pulumi.set(__self__, "vpc_id", vpc_id)

    @_builtins.property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "subnet_ids")

    @subnet_ids.setter
    def subnet_ids(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "subnet_ids", value)

    @_builtins.property
    @pulumi.getter(name="availabilityZones")
    def availability_zones(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "availability_zones")

    @availability_zones.setter
    def availability_zones(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "availability_zones", value)

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "security_group_ids")

    @security_group_ids.setter
    def security_group_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "security_group_ids", value)

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "vpc_id")

    @vpc_id.setter
    def vpc_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vpc_id", value)


if not MYPY:
    class GetServerlessSecurityConfigSamlOptionArgsDict(TypedDict):
        group_attribute: _builtins.str
        """
        Group attribute for this SAML integration.
        """
        metadata: _builtins.str
        """
        The XML IdP metadata file generated from your identity provider.
        """
        session_timeout: _builtins.int
        """
        Session timeout, in minutes. Minimum is 5 minutes and maximum is 720 minutes (12 hours). Default is 60 minutes.
        """
        user_attribute: _builtins.str
        """
        User attribute for this SAML integration.
        """
elif False:
    GetServerlessSecurityConfigSamlOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetServerlessSecurityConfigSamlOptionArgs:
    def __init__(__self__, *,
                 group_attribute: _builtins.str,
                 metadata: _builtins.str,
                 session_timeout: _builtins.int,
                 user_attribute: _builtins.str):
        """
        :param _builtins.str group_attribute: Group attribute for this SAML integration.
        :param _builtins.str metadata: The XML IdP metadata file generated from your identity provider.
        :param _builtins.int session_timeout: Session timeout, in minutes. Minimum is 5 minutes and maximum is 720 minutes (12 hours). Default is 60 minutes.
        :param _builtins.str user_attribute: User attribute for this SAML integration.
        """
        pulumi.set(__self__, "group_attribute", group_attribute)
        pulumi.set(__self__, "metadata", metadata)
        pulumi.set(__self__, "session_timeout", session_timeout)
        pulumi.set(__self__, "user_attribute", user_attribute)

    @_builtins.property
    @pulumi.getter(name="groupAttribute")
    def group_attribute(self) -> _builtins.str:
        """
        Group attribute for this SAML integration.
        """
        return pulumi.get(self, "group_attribute")

    @group_attribute.setter
    def group_attribute(self, value: _builtins.str):
        pulumi.set(self, "group_attribute", value)

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> _builtins.str:
        """
        The XML IdP metadata file generated from your identity provider.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: _builtins.str):
        pulumi.set(self, "metadata", value)

    @_builtins.property
    @pulumi.getter(name="sessionTimeout")
    def session_timeout(self) -> _builtins.int:
        """
        Session timeout, in minutes. Minimum is 5 minutes and maximum is 720 minutes (12 hours). Default is 60 minutes.
        """
        return pulumi.get(self, "session_timeout")

    @session_timeout.setter
    def session_timeout(self, value: _builtins.int):
        pulumi.set(self, "session_timeout", value)

    @_builtins.property
    @pulumi.getter(name="userAttribute")
    def user_attribute(self) -> _builtins.str:
        """
        User attribute for this SAML integration.
        """
        return pulumi.get(self, "user_attribute")

    @user_attribute.setter
    def user_attribute(self, value: _builtins.str):
        pulumi.set(self, "user_attribute", value)


