# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = [
    'DomainAdvancedSecurityOptionsArgs',
    'DomainAdvancedSecurityOptionsMasterUserOptionsArgs',
    'DomainAutoTuneOptionsArgs',
    'DomainAutoTuneOptionsMaintenanceScheduleArgs',
    'DomainAutoTuneOptionsMaintenanceScheduleDurationArgs',
    'DomainClusterConfigArgs',
    'DomainClusterConfigColdStorageOptionsArgs',
    'DomainClusterConfigZoneAwarenessConfigArgs',
    'DomainCognitoOptionsArgs',
    'DomainDomainEndpointOptionsArgs',
    'DomainEbsOptionsArgs',
    'DomainEncryptAtRestArgs',
    'DomainLogPublishingOptionArgs',
    'DomainNodeToNodeEncryptionArgs',
    'DomainOffPeakWindowOptionsArgs',
    'DomainOffPeakWindowOptionsOffPeakWindowArgs',
    'DomainOffPeakWindowOptionsOffPeakWindowWindowStartTimeArgs',
    'DomainSamlOptionsSamlOptionsArgs',
    'DomainSamlOptionsSamlOptionsIdpArgs',
    'DomainSnapshotOptionsArgs',
    'DomainSoftwareUpdateOptionsArgs',
    'DomainVpcOptionsArgs',
    'OutboundConnectionConnectionPropertiesArgs',
    'OutboundConnectionConnectionPropertiesCrossClusterSearchArgs',
    'OutboundConnectionLocalDomainInfoArgs',
    'OutboundConnectionRemoteDomainInfoArgs',
    'PackagePackageSourceArgs',
    'ServerlessCollectionTimeoutsArgs',
    'ServerlessSecurityConfigSamlOptionsArgs',
    'ServerlessVpcEndpointTimeoutsArgs',
    'VpcEndpointVpcOptionsArgs',
    'GetDomainOffPeakWindowOptionsArgs',
    'GetDomainOffPeakWindowOptionsOffPeakWindowArgs',
    'GetDomainOffPeakWindowOptionsOffPeakWindowWindowStartTimeArgs',
    'GetServerlessSecurityConfigSamlOptionsArgs',
]

@pulumi.input_type
class DomainAdvancedSecurityOptionsArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 anonymous_auth_enabled: Optional[pulumi.Input[bool]] = None,
                 internal_user_database_enabled: Optional[pulumi.Input[bool]] = None,
                 master_user_options: Optional[pulumi.Input['DomainAdvancedSecurityOptionsMasterUserOptionsArgs']] = None):
        """
        :param pulumi.Input[bool] enabled: Whether advanced security is enabled.
        :param pulumi.Input[bool] anonymous_auth_enabled: Whether Anonymous auth is enabled. Enables fine-grained access control on an existing domain. Ignored unless `advanced_security_options` are enabled. _Can only be enabled on an existing domain._
        :param pulumi.Input[bool] internal_user_database_enabled: Whether the internal user database is enabled. Default is `false`.
        :param pulumi.Input['DomainAdvancedSecurityOptionsMasterUserOptionsArgs'] master_user_options: Configuration block for the main user. Detailed below.
        """
        DomainAdvancedSecurityOptionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            anonymous_auth_enabled=anonymous_auth_enabled,
            internal_user_database_enabled=internal_user_database_enabled,
            master_user_options=master_user_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[pulumi.Input[bool]] = None,
             anonymous_auth_enabled: Optional[pulumi.Input[bool]] = None,
             internal_user_database_enabled: Optional[pulumi.Input[bool]] = None,
             master_user_options: Optional[pulumi.Input['DomainAdvancedSecurityOptionsMasterUserOptionsArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if enabled is None:
            raise TypeError("Missing 'enabled' argument")
        if anonymous_auth_enabled is None and 'anonymousAuthEnabled' in kwargs:
            anonymous_auth_enabled = kwargs['anonymousAuthEnabled']
        if internal_user_database_enabled is None and 'internalUserDatabaseEnabled' in kwargs:
            internal_user_database_enabled = kwargs['internalUserDatabaseEnabled']
        if master_user_options is None and 'masterUserOptions' in kwargs:
            master_user_options = kwargs['masterUserOptions']

        _setter("enabled", enabled)
        if anonymous_auth_enabled is not None:
            _setter("anonymous_auth_enabled", anonymous_auth_enabled)
        if internal_user_database_enabled is not None:
            _setter("internal_user_database_enabled", internal_user_database_enabled)
        if master_user_options is not None:
            _setter("master_user_options", master_user_options)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Whether advanced security is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="anonymousAuthEnabled")
    def anonymous_auth_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether Anonymous auth is enabled. Enables fine-grained access control on an existing domain. Ignored unless `advanced_security_options` are enabled. _Can only be enabled on an existing domain._
        """
        return pulumi.get(self, "anonymous_auth_enabled")

    @anonymous_auth_enabled.setter
    def anonymous_auth_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "anonymous_auth_enabled", value)

    @property
    @pulumi.getter(name="internalUserDatabaseEnabled")
    def internal_user_database_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the internal user database is enabled. Default is `false`.
        """
        return pulumi.get(self, "internal_user_database_enabled")

    @internal_user_database_enabled.setter
    def internal_user_database_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "internal_user_database_enabled", value)

    @property
    @pulumi.getter(name="masterUserOptions")
    def master_user_options(self) -> Optional[pulumi.Input['DomainAdvancedSecurityOptionsMasterUserOptionsArgs']]:
        """
        Configuration block for the main user. Detailed below.
        """
        return pulumi.get(self, "master_user_options")

    @master_user_options.setter
    def master_user_options(self, value: Optional[pulumi.Input['DomainAdvancedSecurityOptionsMasterUserOptionsArgs']]):
        pulumi.set(self, "master_user_options", value)


@pulumi.input_type
class DomainAdvancedSecurityOptionsMasterUserOptionsArgs:
    def __init__(__self__, *,
                 master_user_arn: Optional[pulumi.Input[str]] = None,
                 master_user_name: Optional[pulumi.Input[str]] = None,
                 master_user_password: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] master_user_arn: ARN for the main user. Only specify if `internal_user_database_enabled` is not set or set to `false`.
        :param pulumi.Input[str] master_user_name: Main user's username, which is stored in the Amazon OpenSearch Service domain's internal database. Only specify if `internal_user_database_enabled` is set to `true`.
        :param pulumi.Input[str] master_user_password: Main user's password, which is stored in the Amazon OpenSearch Service domain's internal database. Only specify if `internal_user_database_enabled` is set to `true`.
        """
        DomainAdvancedSecurityOptionsMasterUserOptionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            master_user_arn=master_user_arn,
            master_user_name=master_user_name,
            master_user_password=master_user_password,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             master_user_arn: Optional[pulumi.Input[str]] = None,
             master_user_name: Optional[pulumi.Input[str]] = None,
             master_user_password: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if master_user_arn is None and 'masterUserArn' in kwargs:
            master_user_arn = kwargs['masterUserArn']
        if master_user_name is None and 'masterUserName' in kwargs:
            master_user_name = kwargs['masterUserName']
        if master_user_password is None and 'masterUserPassword' in kwargs:
            master_user_password = kwargs['masterUserPassword']

        if master_user_arn is not None:
            _setter("master_user_arn", master_user_arn)
        if master_user_name is not None:
            _setter("master_user_name", master_user_name)
        if master_user_password is not None:
            _setter("master_user_password", master_user_password)

    @property
    @pulumi.getter(name="masterUserArn")
    def master_user_arn(self) -> Optional[pulumi.Input[str]]:
        """
        ARN for the main user. Only specify if `internal_user_database_enabled` is not set or set to `false`.
        """
        return pulumi.get(self, "master_user_arn")

    @master_user_arn.setter
    def master_user_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "master_user_arn", value)

    @property
    @pulumi.getter(name="masterUserName")
    def master_user_name(self) -> Optional[pulumi.Input[str]]:
        """
        Main user's username, which is stored in the Amazon OpenSearch Service domain's internal database. Only specify if `internal_user_database_enabled` is set to `true`.
        """
        return pulumi.get(self, "master_user_name")

    @master_user_name.setter
    def master_user_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "master_user_name", value)

    @property
    @pulumi.getter(name="masterUserPassword")
    def master_user_password(self) -> Optional[pulumi.Input[str]]:
        """
        Main user's password, which is stored in the Amazon OpenSearch Service domain's internal database. Only specify if `internal_user_database_enabled` is set to `true`.
        """
        return pulumi.get(self, "master_user_password")

    @master_user_password.setter
    def master_user_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "master_user_password", value)


@pulumi.input_type
class DomainAutoTuneOptionsArgs:
    def __init__(__self__, *,
                 desired_state: pulumi.Input[str],
                 maintenance_schedules: Optional[pulumi.Input[Sequence[pulumi.Input['DomainAutoTuneOptionsMaintenanceScheduleArgs']]]] = None,
                 rollback_on_disable: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] desired_state: Auto-Tune desired state for the domain. Valid values: `ENABLED` or `DISABLED`.
        :param pulumi.Input[Sequence[pulumi.Input['DomainAutoTuneOptionsMaintenanceScheduleArgs']]] maintenance_schedules: Configuration block for Auto-Tune maintenance windows. Can be specified multiple times for each maintenance window. Detailed below.
        :param pulumi.Input[str] rollback_on_disable: Whether to roll back to default Auto-Tune settings when disabling Auto-Tune. Valid values: `DEFAULT_ROLLBACK` or `NO_ROLLBACK`.
        """
        DomainAutoTuneOptionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            desired_state=desired_state,
            maintenance_schedules=maintenance_schedules,
            rollback_on_disable=rollback_on_disable,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             desired_state: Optional[pulumi.Input[str]] = None,
             maintenance_schedules: Optional[pulumi.Input[Sequence[pulumi.Input['DomainAutoTuneOptionsMaintenanceScheduleArgs']]]] = None,
             rollback_on_disable: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if desired_state is None and 'desiredState' in kwargs:
            desired_state = kwargs['desiredState']
        if desired_state is None:
            raise TypeError("Missing 'desired_state' argument")
        if maintenance_schedules is None and 'maintenanceSchedules' in kwargs:
            maintenance_schedules = kwargs['maintenanceSchedules']
        if rollback_on_disable is None and 'rollbackOnDisable' in kwargs:
            rollback_on_disable = kwargs['rollbackOnDisable']

        _setter("desired_state", desired_state)
        if maintenance_schedules is not None:
            _setter("maintenance_schedules", maintenance_schedules)
        if rollback_on_disable is not None:
            _setter("rollback_on_disable", rollback_on_disable)

    @property
    @pulumi.getter(name="desiredState")
    def desired_state(self) -> pulumi.Input[str]:
        """
        Auto-Tune desired state for the domain. Valid values: `ENABLED` or `DISABLED`.
        """
        return pulumi.get(self, "desired_state")

    @desired_state.setter
    def desired_state(self, value: pulumi.Input[str]):
        pulumi.set(self, "desired_state", value)

    @property
    @pulumi.getter(name="maintenanceSchedules")
    def maintenance_schedules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DomainAutoTuneOptionsMaintenanceScheduleArgs']]]]:
        """
        Configuration block for Auto-Tune maintenance windows. Can be specified multiple times for each maintenance window. Detailed below.
        """
        return pulumi.get(self, "maintenance_schedules")

    @maintenance_schedules.setter
    def maintenance_schedules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DomainAutoTuneOptionsMaintenanceScheduleArgs']]]]):
        pulumi.set(self, "maintenance_schedules", value)

    @property
    @pulumi.getter(name="rollbackOnDisable")
    def rollback_on_disable(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to roll back to default Auto-Tune settings when disabling Auto-Tune. Valid values: `DEFAULT_ROLLBACK` or `NO_ROLLBACK`.
        """
        return pulumi.get(self, "rollback_on_disable")

    @rollback_on_disable.setter
    def rollback_on_disable(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rollback_on_disable", value)


@pulumi.input_type
class DomainAutoTuneOptionsMaintenanceScheduleArgs:
    def __init__(__self__, *,
                 cron_expression_for_recurrence: pulumi.Input[str],
                 duration: pulumi.Input['DomainAutoTuneOptionsMaintenanceScheduleDurationArgs'],
                 start_at: pulumi.Input[str]):
        """
        :param pulumi.Input[str] cron_expression_for_recurrence: A cron expression specifying the recurrence pattern for an Auto-Tune maintenance schedule.
        :param pulumi.Input['DomainAutoTuneOptionsMaintenanceScheduleDurationArgs'] duration: Configuration block for the duration of the Auto-Tune maintenance window. Detailed below.
        :param pulumi.Input[str] start_at: Date and time at which to start the Auto-Tune maintenance schedule in [RFC3339 format](https://tools.ietf.org/html/rfc3339#section-5.8).
        """
        DomainAutoTuneOptionsMaintenanceScheduleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cron_expression_for_recurrence=cron_expression_for_recurrence,
            duration=duration,
            start_at=start_at,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cron_expression_for_recurrence: Optional[pulumi.Input[str]] = None,
             duration: Optional[pulumi.Input['DomainAutoTuneOptionsMaintenanceScheduleDurationArgs']] = None,
             start_at: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cron_expression_for_recurrence is None and 'cronExpressionForRecurrence' in kwargs:
            cron_expression_for_recurrence = kwargs['cronExpressionForRecurrence']
        if cron_expression_for_recurrence is None:
            raise TypeError("Missing 'cron_expression_for_recurrence' argument")
        if duration is None:
            raise TypeError("Missing 'duration' argument")
        if start_at is None and 'startAt' in kwargs:
            start_at = kwargs['startAt']
        if start_at is None:
            raise TypeError("Missing 'start_at' argument")

        _setter("cron_expression_for_recurrence", cron_expression_for_recurrence)
        _setter("duration", duration)
        _setter("start_at", start_at)

    @property
    @pulumi.getter(name="cronExpressionForRecurrence")
    def cron_expression_for_recurrence(self) -> pulumi.Input[str]:
        """
        A cron expression specifying the recurrence pattern for an Auto-Tune maintenance schedule.
        """
        return pulumi.get(self, "cron_expression_for_recurrence")

    @cron_expression_for_recurrence.setter
    def cron_expression_for_recurrence(self, value: pulumi.Input[str]):
        pulumi.set(self, "cron_expression_for_recurrence", value)

    @property
    @pulumi.getter
    def duration(self) -> pulumi.Input['DomainAutoTuneOptionsMaintenanceScheduleDurationArgs']:
        """
        Configuration block for the duration of the Auto-Tune maintenance window. Detailed below.
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: pulumi.Input['DomainAutoTuneOptionsMaintenanceScheduleDurationArgs']):
        pulumi.set(self, "duration", value)

    @property
    @pulumi.getter(name="startAt")
    def start_at(self) -> pulumi.Input[str]:
        """
        Date and time at which to start the Auto-Tune maintenance schedule in [RFC3339 format](https://tools.ietf.org/html/rfc3339#section-5.8).
        """
        return pulumi.get(self, "start_at")

    @start_at.setter
    def start_at(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_at", value)


@pulumi.input_type
class DomainAutoTuneOptionsMaintenanceScheduleDurationArgs:
    def __init__(__self__, *,
                 unit: pulumi.Input[str],
                 value: pulumi.Input[int]):
        """
        :param pulumi.Input[str] unit: Unit of time specifying the duration of an Auto-Tune maintenance window. Valid values: `HOURS`.
        :param pulumi.Input[int] value: An integer specifying the value of the duration of an Auto-Tune maintenance window.
        """
        DomainAutoTuneOptionsMaintenanceScheduleDurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            unit=unit,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             unit: Optional[pulumi.Input[str]] = None,
             value: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if unit is None:
            raise TypeError("Missing 'unit' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("unit", unit)
        _setter("value", value)

    @property
    @pulumi.getter
    def unit(self) -> pulumi.Input[str]:
        """
        Unit of time specifying the duration of an Auto-Tune maintenance window. Valid values: `HOURS`.
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "unit", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[int]:
        """
        An integer specifying the value of the duration of an Auto-Tune maintenance window.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[int]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class DomainClusterConfigArgs:
    def __init__(__self__, *,
                 cold_storage_options: Optional[pulumi.Input['DomainClusterConfigColdStorageOptionsArgs']] = None,
                 dedicated_master_count: Optional[pulumi.Input[int]] = None,
                 dedicated_master_enabled: Optional[pulumi.Input[bool]] = None,
                 dedicated_master_type: Optional[pulumi.Input[str]] = None,
                 instance_count: Optional[pulumi.Input[int]] = None,
                 instance_type: Optional[pulumi.Input[str]] = None,
                 multi_az_with_standby_enabled: Optional[pulumi.Input[bool]] = None,
                 warm_count: Optional[pulumi.Input[int]] = None,
                 warm_enabled: Optional[pulumi.Input[bool]] = None,
                 warm_type: Optional[pulumi.Input[str]] = None,
                 zone_awareness_config: Optional[pulumi.Input['DomainClusterConfigZoneAwarenessConfigArgs']] = None,
                 zone_awareness_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input['DomainClusterConfigColdStorageOptionsArgs'] cold_storage_options: Configuration block containing cold storage configuration. Detailed below.
        :param pulumi.Input[int] dedicated_master_count: Number of dedicated main nodes in the cluster.
        :param pulumi.Input[bool] dedicated_master_enabled: Whether dedicated main nodes are enabled for the cluster.
        :param pulumi.Input[str] dedicated_master_type: Instance type of the dedicated main nodes in the cluster.
        :param pulumi.Input[int] instance_count: Number of instances in the cluster.
        :param pulumi.Input[str] instance_type: Instance type of data nodes in the cluster.
        :param pulumi.Input[int] warm_count: Number of warm nodes in the cluster. Valid values are between `2` and `150`. `warm_count` can be only and must be set when `warm_enabled` is set to `true`.
        :param pulumi.Input[bool] warm_enabled: Whether to enable warm storage.
        :param pulumi.Input[str] warm_type: Instance type for the OpenSearch cluster's warm nodes. Valid values are `ultrawarm1.medium.search`, `ultrawarm1.large.search` and `ultrawarm1.xlarge.search`. `warm_type` can be only and must be set when `warm_enabled` is set to `true`.
        :param pulumi.Input['DomainClusterConfigZoneAwarenessConfigArgs'] zone_awareness_config: Configuration block containing zone awareness settings. Detailed below.
        :param pulumi.Input[bool] zone_awareness_enabled: Whether zone awareness is enabled, set to `true` for multi-az deployment. To enable awareness with three Availability Zones, the `availability_zone_count` within the `zone_awareness_config` must be set to `3`.
        """
        DomainClusterConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cold_storage_options=cold_storage_options,
            dedicated_master_count=dedicated_master_count,
            dedicated_master_enabled=dedicated_master_enabled,
            dedicated_master_type=dedicated_master_type,
            instance_count=instance_count,
            instance_type=instance_type,
            multi_az_with_standby_enabled=multi_az_with_standby_enabled,
            warm_count=warm_count,
            warm_enabled=warm_enabled,
            warm_type=warm_type,
            zone_awareness_config=zone_awareness_config,
            zone_awareness_enabled=zone_awareness_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cold_storage_options: Optional[pulumi.Input['DomainClusterConfigColdStorageOptionsArgs']] = None,
             dedicated_master_count: Optional[pulumi.Input[int]] = None,
             dedicated_master_enabled: Optional[pulumi.Input[bool]] = None,
             dedicated_master_type: Optional[pulumi.Input[str]] = None,
             instance_count: Optional[pulumi.Input[int]] = None,
             instance_type: Optional[pulumi.Input[str]] = None,
             multi_az_with_standby_enabled: Optional[pulumi.Input[bool]] = None,
             warm_count: Optional[pulumi.Input[int]] = None,
             warm_enabled: Optional[pulumi.Input[bool]] = None,
             warm_type: Optional[pulumi.Input[str]] = None,
             zone_awareness_config: Optional[pulumi.Input['DomainClusterConfigZoneAwarenessConfigArgs']] = None,
             zone_awareness_enabled: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cold_storage_options is None and 'coldStorageOptions' in kwargs:
            cold_storage_options = kwargs['coldStorageOptions']
        if dedicated_master_count is None and 'dedicatedMasterCount' in kwargs:
            dedicated_master_count = kwargs['dedicatedMasterCount']
        if dedicated_master_enabled is None and 'dedicatedMasterEnabled' in kwargs:
            dedicated_master_enabled = kwargs['dedicatedMasterEnabled']
        if dedicated_master_type is None and 'dedicatedMasterType' in kwargs:
            dedicated_master_type = kwargs['dedicatedMasterType']
        if instance_count is None and 'instanceCount' in kwargs:
            instance_count = kwargs['instanceCount']
        if instance_type is None and 'instanceType' in kwargs:
            instance_type = kwargs['instanceType']
        if multi_az_with_standby_enabled is None and 'multiAzWithStandbyEnabled' in kwargs:
            multi_az_with_standby_enabled = kwargs['multiAzWithStandbyEnabled']
        if warm_count is None and 'warmCount' in kwargs:
            warm_count = kwargs['warmCount']
        if warm_enabled is None and 'warmEnabled' in kwargs:
            warm_enabled = kwargs['warmEnabled']
        if warm_type is None and 'warmType' in kwargs:
            warm_type = kwargs['warmType']
        if zone_awareness_config is None and 'zoneAwarenessConfig' in kwargs:
            zone_awareness_config = kwargs['zoneAwarenessConfig']
        if zone_awareness_enabled is None and 'zoneAwarenessEnabled' in kwargs:
            zone_awareness_enabled = kwargs['zoneAwarenessEnabled']

        if cold_storage_options is not None:
            _setter("cold_storage_options", cold_storage_options)
        if dedicated_master_count is not None:
            _setter("dedicated_master_count", dedicated_master_count)
        if dedicated_master_enabled is not None:
            _setter("dedicated_master_enabled", dedicated_master_enabled)
        if dedicated_master_type is not None:
            _setter("dedicated_master_type", dedicated_master_type)
        if instance_count is not None:
            _setter("instance_count", instance_count)
        if instance_type is not None:
            _setter("instance_type", instance_type)
        if multi_az_with_standby_enabled is not None:
            _setter("multi_az_with_standby_enabled", multi_az_with_standby_enabled)
        if warm_count is not None:
            _setter("warm_count", warm_count)
        if warm_enabled is not None:
            _setter("warm_enabled", warm_enabled)
        if warm_type is not None:
            _setter("warm_type", warm_type)
        if zone_awareness_config is not None:
            _setter("zone_awareness_config", zone_awareness_config)
        if zone_awareness_enabled is not None:
            _setter("zone_awareness_enabled", zone_awareness_enabled)

    @property
    @pulumi.getter(name="coldStorageOptions")
    def cold_storage_options(self) -> Optional[pulumi.Input['DomainClusterConfigColdStorageOptionsArgs']]:
        """
        Configuration block containing cold storage configuration. Detailed below.
        """
        return pulumi.get(self, "cold_storage_options")

    @cold_storage_options.setter
    def cold_storage_options(self, value: Optional[pulumi.Input['DomainClusterConfigColdStorageOptionsArgs']]):
        pulumi.set(self, "cold_storage_options", value)

    @property
    @pulumi.getter(name="dedicatedMasterCount")
    def dedicated_master_count(self) -> Optional[pulumi.Input[int]]:
        """
        Number of dedicated main nodes in the cluster.
        """
        return pulumi.get(self, "dedicated_master_count")

    @dedicated_master_count.setter
    def dedicated_master_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "dedicated_master_count", value)

    @property
    @pulumi.getter(name="dedicatedMasterEnabled")
    def dedicated_master_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether dedicated main nodes are enabled for the cluster.
        """
        return pulumi.get(self, "dedicated_master_enabled")

    @dedicated_master_enabled.setter
    def dedicated_master_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dedicated_master_enabled", value)

    @property
    @pulumi.getter(name="dedicatedMasterType")
    def dedicated_master_type(self) -> Optional[pulumi.Input[str]]:
        """
        Instance type of the dedicated main nodes in the cluster.
        """
        return pulumi.get(self, "dedicated_master_type")

    @dedicated_master_type.setter
    def dedicated_master_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dedicated_master_type", value)

    @property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> Optional[pulumi.Input[int]]:
        """
        Number of instances in the cluster.
        """
        return pulumi.get(self, "instance_count")

    @instance_count.setter
    def instance_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "instance_count", value)

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[pulumi.Input[str]]:
        """
        Instance type of data nodes in the cluster.
        """
        return pulumi.get(self, "instance_type")

    @instance_type.setter
    def instance_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance_type", value)

    @property
    @pulumi.getter(name="multiAzWithStandbyEnabled")
    def multi_az_with_standby_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "multi_az_with_standby_enabled")

    @multi_az_with_standby_enabled.setter
    def multi_az_with_standby_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "multi_az_with_standby_enabled", value)

    @property
    @pulumi.getter(name="warmCount")
    def warm_count(self) -> Optional[pulumi.Input[int]]:
        """
        Number of warm nodes in the cluster. Valid values are between `2` and `150`. `warm_count` can be only and must be set when `warm_enabled` is set to `true`.
        """
        return pulumi.get(self, "warm_count")

    @warm_count.setter
    def warm_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "warm_count", value)

    @property
    @pulumi.getter(name="warmEnabled")
    def warm_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to enable warm storage.
        """
        return pulumi.get(self, "warm_enabled")

    @warm_enabled.setter
    def warm_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "warm_enabled", value)

    @property
    @pulumi.getter(name="warmType")
    def warm_type(self) -> Optional[pulumi.Input[str]]:
        """
        Instance type for the OpenSearch cluster's warm nodes. Valid values are `ultrawarm1.medium.search`, `ultrawarm1.large.search` and `ultrawarm1.xlarge.search`. `warm_type` can be only and must be set when `warm_enabled` is set to `true`.
        """
        return pulumi.get(self, "warm_type")

    @warm_type.setter
    def warm_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "warm_type", value)

    @property
    @pulumi.getter(name="zoneAwarenessConfig")
    def zone_awareness_config(self) -> Optional[pulumi.Input['DomainClusterConfigZoneAwarenessConfigArgs']]:
        """
        Configuration block containing zone awareness settings. Detailed below.
        """
        return pulumi.get(self, "zone_awareness_config")

    @zone_awareness_config.setter
    def zone_awareness_config(self, value: Optional[pulumi.Input['DomainClusterConfigZoneAwarenessConfigArgs']]):
        pulumi.set(self, "zone_awareness_config", value)

    @property
    @pulumi.getter(name="zoneAwarenessEnabled")
    def zone_awareness_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether zone awareness is enabled, set to `true` for multi-az deployment. To enable awareness with three Availability Zones, the `availability_zone_count` within the `zone_awareness_config` must be set to `3`.
        """
        return pulumi.get(self, "zone_awareness_enabled")

    @zone_awareness_enabled.setter
    def zone_awareness_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "zone_awareness_enabled", value)


@pulumi.input_type
class DomainClusterConfigColdStorageOptionsArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: Boolean to enable cold storage for an OpenSearch domain. Defaults to `false`. Master and ultrawarm nodes must be enabled for cold storage.
        """
        DomainClusterConfigColdStorageOptionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if enabled is not None:
            _setter("enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean to enable cold storage for an OpenSearch domain. Defaults to `false`. Master and ultrawarm nodes must be enabled for cold storage.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class DomainClusterConfigZoneAwarenessConfigArgs:
    def __init__(__self__, *,
                 availability_zone_count: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] availability_zone_count: Number of Availability Zones for the domain to use with `zone_awareness_enabled`. Defaults to `2`. Valid values: `2` or `3`.
        """
        DomainClusterConfigZoneAwarenessConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability_zone_count=availability_zone_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability_zone_count: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if availability_zone_count is None and 'availabilityZoneCount' in kwargs:
            availability_zone_count = kwargs['availabilityZoneCount']

        if availability_zone_count is not None:
            _setter("availability_zone_count", availability_zone_count)

    @property
    @pulumi.getter(name="availabilityZoneCount")
    def availability_zone_count(self) -> Optional[pulumi.Input[int]]:
        """
        Number of Availability Zones for the domain to use with `zone_awareness_enabled`. Defaults to `2`. Valid values: `2` or `3`.
        """
        return pulumi.get(self, "availability_zone_count")

    @availability_zone_count.setter
    def availability_zone_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "availability_zone_count", value)


@pulumi.input_type
class DomainCognitoOptionsArgs:
    def __init__(__self__, *,
                 identity_pool_id: pulumi.Input[str],
                 role_arn: pulumi.Input[str],
                 user_pool_id: pulumi.Input[str],
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] identity_pool_id: ID of the Cognito Identity Pool to use.
        :param pulumi.Input[str] role_arn: ARN of the IAM role that has the AmazonOpenSearchServiceCognitoAccess policy attached.
        :param pulumi.Input[str] user_pool_id: ID of the Cognito User Pool to use.
        :param pulumi.Input[bool] enabled: Whether Amazon Cognito authentication with Dashboard is enabled or not. Default is `false`.
        """
        DomainCognitoOptionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            identity_pool_id=identity_pool_id,
            role_arn=role_arn,
            user_pool_id=user_pool_id,
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             identity_pool_id: Optional[pulumi.Input[str]] = None,
             role_arn: Optional[pulumi.Input[str]] = None,
             user_pool_id: Optional[pulumi.Input[str]] = None,
             enabled: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if identity_pool_id is None and 'identityPoolId' in kwargs:
            identity_pool_id = kwargs['identityPoolId']
        if identity_pool_id is None:
            raise TypeError("Missing 'identity_pool_id' argument")
        if role_arn is None and 'roleArn' in kwargs:
            role_arn = kwargs['roleArn']
        if role_arn is None:
            raise TypeError("Missing 'role_arn' argument")
        if user_pool_id is None and 'userPoolId' in kwargs:
            user_pool_id = kwargs['userPoolId']
        if user_pool_id is None:
            raise TypeError("Missing 'user_pool_id' argument")

        _setter("identity_pool_id", identity_pool_id)
        _setter("role_arn", role_arn)
        _setter("user_pool_id", user_pool_id)
        if enabled is not None:
            _setter("enabled", enabled)

    @property
    @pulumi.getter(name="identityPoolId")
    def identity_pool_id(self) -> pulumi.Input[str]:
        """
        ID of the Cognito Identity Pool to use.
        """
        return pulumi.get(self, "identity_pool_id")

    @identity_pool_id.setter
    def identity_pool_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_pool_id", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[str]:
        """
        ARN of the IAM role that has the AmazonOpenSearchServiceCognitoAccess policy attached.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="userPoolId")
    def user_pool_id(self) -> pulumi.Input[str]:
        """
        ID of the Cognito User Pool to use.
        """
        return pulumi.get(self, "user_pool_id")

    @user_pool_id.setter
    def user_pool_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "user_pool_id", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether Amazon Cognito authentication with Dashboard is enabled or not. Default is `false`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class DomainDomainEndpointOptionsArgs:
    def __init__(__self__, *,
                 custom_endpoint: Optional[pulumi.Input[str]] = None,
                 custom_endpoint_certificate_arn: Optional[pulumi.Input[str]] = None,
                 custom_endpoint_enabled: Optional[pulumi.Input[bool]] = None,
                 enforce_https: Optional[pulumi.Input[bool]] = None,
                 tls_security_policy: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] custom_endpoint: Fully qualified domain for your custom endpoint.
        :param pulumi.Input[str] custom_endpoint_certificate_arn: ACM certificate ARN for your custom endpoint.
        :param pulumi.Input[bool] custom_endpoint_enabled: Whether to enable custom endpoint for the OpenSearch domain.
        :param pulumi.Input[bool] enforce_https: Whether or not to require HTTPS. Defaults to `true`.
        :param pulumi.Input[str] tls_security_policy: Name of the TLS security policy that needs to be applied to the HTTPS endpoint. Valid values:  `Policy-Min-TLS-1-0-2019-07` and `Policy-Min-TLS-1-2-2019-07`. The provider will only perform drift detection if a configuration value is provided.
        """
        DomainDomainEndpointOptionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_endpoint=custom_endpoint,
            custom_endpoint_certificate_arn=custom_endpoint_certificate_arn,
            custom_endpoint_enabled=custom_endpoint_enabled,
            enforce_https=enforce_https,
            tls_security_policy=tls_security_policy,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_endpoint: Optional[pulumi.Input[str]] = None,
             custom_endpoint_certificate_arn: Optional[pulumi.Input[str]] = None,
             custom_endpoint_enabled: Optional[pulumi.Input[bool]] = None,
             enforce_https: Optional[pulumi.Input[bool]] = None,
             tls_security_policy: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if custom_endpoint is None and 'customEndpoint' in kwargs:
            custom_endpoint = kwargs['customEndpoint']
        if custom_endpoint_certificate_arn is None and 'customEndpointCertificateArn' in kwargs:
            custom_endpoint_certificate_arn = kwargs['customEndpointCertificateArn']
        if custom_endpoint_enabled is None and 'customEndpointEnabled' in kwargs:
            custom_endpoint_enabled = kwargs['customEndpointEnabled']
        if enforce_https is None and 'enforceHttps' in kwargs:
            enforce_https = kwargs['enforceHttps']
        if tls_security_policy is None and 'tlsSecurityPolicy' in kwargs:
            tls_security_policy = kwargs['tlsSecurityPolicy']

        if custom_endpoint is not None:
            _setter("custom_endpoint", custom_endpoint)
        if custom_endpoint_certificate_arn is not None:
            _setter("custom_endpoint_certificate_arn", custom_endpoint_certificate_arn)
        if custom_endpoint_enabled is not None:
            _setter("custom_endpoint_enabled", custom_endpoint_enabled)
        if enforce_https is not None:
            _setter("enforce_https", enforce_https)
        if tls_security_policy is not None:
            _setter("tls_security_policy", tls_security_policy)

    @property
    @pulumi.getter(name="customEndpoint")
    def custom_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        Fully qualified domain for your custom endpoint.
        """
        return pulumi.get(self, "custom_endpoint")

    @custom_endpoint.setter
    def custom_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_endpoint", value)

    @property
    @pulumi.getter(name="customEndpointCertificateArn")
    def custom_endpoint_certificate_arn(self) -> Optional[pulumi.Input[str]]:
        """
        ACM certificate ARN for your custom endpoint.
        """
        return pulumi.get(self, "custom_endpoint_certificate_arn")

    @custom_endpoint_certificate_arn.setter
    def custom_endpoint_certificate_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_endpoint_certificate_arn", value)

    @property
    @pulumi.getter(name="customEndpointEnabled")
    def custom_endpoint_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to enable custom endpoint for the OpenSearch domain.
        """
        return pulumi.get(self, "custom_endpoint_enabled")

    @custom_endpoint_enabled.setter
    def custom_endpoint_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "custom_endpoint_enabled", value)

    @property
    @pulumi.getter(name="enforceHttps")
    def enforce_https(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not to require HTTPS. Defaults to `true`.
        """
        return pulumi.get(self, "enforce_https")

    @enforce_https.setter
    def enforce_https(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enforce_https", value)

    @property
    @pulumi.getter(name="tlsSecurityPolicy")
    def tls_security_policy(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the TLS security policy that needs to be applied to the HTTPS endpoint. Valid values:  `Policy-Min-TLS-1-0-2019-07` and `Policy-Min-TLS-1-2-2019-07`. The provider will only perform drift detection if a configuration value is provided.
        """
        return pulumi.get(self, "tls_security_policy")

    @tls_security_policy.setter
    def tls_security_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tls_security_policy", value)


@pulumi.input_type
class DomainEbsOptionsArgs:
    def __init__(__self__, *,
                 ebs_enabled: pulumi.Input[bool],
                 iops: Optional[pulumi.Input[int]] = None,
                 throughput: Optional[pulumi.Input[int]] = None,
                 volume_size: Optional[pulumi.Input[int]] = None,
                 volume_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] ebs_enabled: Whether EBS volumes are attached to data nodes in the domain.
        :param pulumi.Input[int] iops: Baseline input/output (I/O) performance of EBS volumes attached to data nodes. Applicable only for the GP3 and Provisioned IOPS EBS volume types.
        :param pulumi.Input[int] throughput: Specifies the throughput (in MiB/s) of the EBS volumes attached to data nodes. Applicable only for the gp3 volume type.
        :param pulumi.Input[int] volume_size: Size of EBS volumes attached to data nodes (in GiB).
        :param pulumi.Input[str] volume_type: Type of EBS volumes attached to data nodes.
        """
        DomainEbsOptionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ebs_enabled=ebs_enabled,
            iops=iops,
            throughput=throughput,
            volume_size=volume_size,
            volume_type=volume_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ebs_enabled: Optional[pulumi.Input[bool]] = None,
             iops: Optional[pulumi.Input[int]] = None,
             throughput: Optional[pulumi.Input[int]] = None,
             volume_size: Optional[pulumi.Input[int]] = None,
             volume_type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ebs_enabled is None and 'ebsEnabled' in kwargs:
            ebs_enabled = kwargs['ebsEnabled']
        if ebs_enabled is None:
            raise TypeError("Missing 'ebs_enabled' argument")
        if volume_size is None and 'volumeSize' in kwargs:
            volume_size = kwargs['volumeSize']
        if volume_type is None and 'volumeType' in kwargs:
            volume_type = kwargs['volumeType']

        _setter("ebs_enabled", ebs_enabled)
        if iops is not None:
            _setter("iops", iops)
        if throughput is not None:
            _setter("throughput", throughput)
        if volume_size is not None:
            _setter("volume_size", volume_size)
        if volume_type is not None:
            _setter("volume_type", volume_type)

    @property
    @pulumi.getter(name="ebsEnabled")
    def ebs_enabled(self) -> pulumi.Input[bool]:
        """
        Whether EBS volumes are attached to data nodes in the domain.
        """
        return pulumi.get(self, "ebs_enabled")

    @ebs_enabled.setter
    def ebs_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "ebs_enabled", value)

    @property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[int]]:
        """
        Baseline input/output (I/O) performance of EBS volumes attached to data nodes. Applicable only for the GP3 and Provisioned IOPS EBS volume types.
        """
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "iops", value)

    @property
    @pulumi.getter
    def throughput(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the throughput (in MiB/s) of the EBS volumes attached to data nodes. Applicable only for the gp3 volume type.
        """
        return pulumi.get(self, "throughput")

    @throughput.setter
    def throughput(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "throughput", value)

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[pulumi.Input[int]]:
        """
        Size of EBS volumes attached to data nodes (in GiB).
        """
        return pulumi.get(self, "volume_size")

    @volume_size.setter
    def volume_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "volume_size", value)

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of EBS volumes attached to data nodes.
        """
        return pulumi.get(self, "volume_type")

    @volume_type.setter
    def volume_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volume_type", value)


@pulumi.input_type
class DomainEncryptAtRestArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 kms_key_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Whether to enable encryption at rest. If the `encrypt_at_rest` block is not provided then this defaults to `false`. Enabling encryption on new domains requires an `engine_version` of `OpenSearch_X.Y` or `Elasticsearch_5.1` or greater.
        :param pulumi.Input[str] kms_key_id: KMS key ARN to encrypt the Elasticsearch domain with. If not specified then it defaults to using the `aws/es` service KMS key. Note that KMS will accept a KMS key ID but will return the key ARN. To prevent the provider detecting unwanted changes, use the key ARN instead.
        """
        DomainEncryptAtRestArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            kms_key_id=kms_key_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[pulumi.Input[bool]] = None,
             kms_key_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if enabled is None:
            raise TypeError("Missing 'enabled' argument")
        if kms_key_id is None and 'kmsKeyId' in kwargs:
            kms_key_id = kwargs['kmsKeyId']

        _setter("enabled", enabled)
        if kms_key_id is not None:
            _setter("kms_key_id", kms_key_id)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Whether to enable encryption at rest. If the `encrypt_at_rest` block is not provided then this defaults to `false`. Enabling encryption on new domains requires an `engine_version` of `OpenSearch_X.Y` or `Elasticsearch_5.1` or greater.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        KMS key ARN to encrypt the Elasticsearch domain with. If not specified then it defaults to using the `aws/es` service KMS key. Note that KMS will accept a KMS key ID but will return the key ARN. To prevent the provider detecting unwanted changes, use the key ARN instead.
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_id", value)


@pulumi.input_type
class DomainLogPublishingOptionArgs:
    def __init__(__self__, *,
                 cloudwatch_log_group_arn: pulumi.Input[str],
                 log_type: pulumi.Input[str],
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] cloudwatch_log_group_arn: ARN of the Cloudwatch log group to which log needs to be published.
        :param pulumi.Input[str] log_type: Type of OpenSearch log. Valid values: `INDEX_SLOW_LOGS`, `SEARCH_SLOW_LOGS`, `ES_APPLICATION_LOGS`, `AUDIT_LOGS`.
        :param pulumi.Input[bool] enabled: Whether given log publishing option is enabled or not.
        """
        DomainLogPublishingOptionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloudwatch_log_group_arn=cloudwatch_log_group_arn,
            log_type=log_type,
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloudwatch_log_group_arn: Optional[pulumi.Input[str]] = None,
             log_type: Optional[pulumi.Input[str]] = None,
             enabled: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cloudwatch_log_group_arn is None and 'cloudwatchLogGroupArn' in kwargs:
            cloudwatch_log_group_arn = kwargs['cloudwatchLogGroupArn']
        if cloudwatch_log_group_arn is None:
            raise TypeError("Missing 'cloudwatch_log_group_arn' argument")
        if log_type is None and 'logType' in kwargs:
            log_type = kwargs['logType']
        if log_type is None:
            raise TypeError("Missing 'log_type' argument")

        _setter("cloudwatch_log_group_arn", cloudwatch_log_group_arn)
        _setter("log_type", log_type)
        if enabled is not None:
            _setter("enabled", enabled)

    @property
    @pulumi.getter(name="cloudwatchLogGroupArn")
    def cloudwatch_log_group_arn(self) -> pulumi.Input[str]:
        """
        ARN of the Cloudwatch log group to which log needs to be published.
        """
        return pulumi.get(self, "cloudwatch_log_group_arn")

    @cloudwatch_log_group_arn.setter
    def cloudwatch_log_group_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "cloudwatch_log_group_arn", value)

    @property
    @pulumi.getter(name="logType")
    def log_type(self) -> pulumi.Input[str]:
        """
        Type of OpenSearch log. Valid values: `INDEX_SLOW_LOGS`, `SEARCH_SLOW_LOGS`, `ES_APPLICATION_LOGS`, `AUDIT_LOGS`.
        """
        return pulumi.get(self, "log_type")

    @log_type.setter
    def log_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "log_type", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether given log publishing option is enabled or not.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class DomainNodeToNodeEncryptionArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] enabled: Whether to enable node-to-node encryption. If the `node_to_node_encryption` block is not provided then this defaults to `false`. Enabling node-to-node encryption of a new domain requires an `engine_version` of `OpenSearch_X.Y` or `Elasticsearch_6.0` or greater.
        """
        DomainNodeToNodeEncryptionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if enabled is None:
            raise TypeError("Missing 'enabled' argument")

        _setter("enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Whether to enable node-to-node encryption. If the `node_to_node_encryption` block is not provided then this defaults to `false`. Enabling node-to-node encryption of a new domain requires an `engine_version` of `OpenSearch_X.Y` or `Elasticsearch_6.0` or greater.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class DomainOffPeakWindowOptionsArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 off_peak_window: Optional[pulumi.Input['DomainOffPeakWindowOptionsOffPeakWindowArgs']] = None):
        """
        :param pulumi.Input[bool] enabled: Enabled disabled toggle for off-peak update window.
        """
        DomainOffPeakWindowOptionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            off_peak_window=off_peak_window,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[pulumi.Input[bool]] = None,
             off_peak_window: Optional[pulumi.Input['DomainOffPeakWindowOptionsOffPeakWindowArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if off_peak_window is None and 'offPeakWindow' in kwargs:
            off_peak_window = kwargs['offPeakWindow']

        if enabled is not None:
            _setter("enabled", enabled)
        if off_peak_window is not None:
            _setter("off_peak_window", off_peak_window)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enabled disabled toggle for off-peak update window.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="offPeakWindow")
    def off_peak_window(self) -> Optional[pulumi.Input['DomainOffPeakWindowOptionsOffPeakWindowArgs']]:
        return pulumi.get(self, "off_peak_window")

    @off_peak_window.setter
    def off_peak_window(self, value: Optional[pulumi.Input['DomainOffPeakWindowOptionsOffPeakWindowArgs']]):
        pulumi.set(self, "off_peak_window", value)


@pulumi.input_type
class DomainOffPeakWindowOptionsOffPeakWindowArgs:
    def __init__(__self__, *,
                 window_start_time: Optional[pulumi.Input['DomainOffPeakWindowOptionsOffPeakWindowWindowStartTimeArgs']] = None):
        """
        :param pulumi.Input['DomainOffPeakWindowOptionsOffPeakWindowWindowStartTimeArgs'] window_start_time: 10h window for updates
        """
        DomainOffPeakWindowOptionsOffPeakWindowArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            window_start_time=window_start_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             window_start_time: Optional[pulumi.Input['DomainOffPeakWindowOptionsOffPeakWindowWindowStartTimeArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if window_start_time is None and 'windowStartTime' in kwargs:
            window_start_time = kwargs['windowStartTime']

        if window_start_time is not None:
            _setter("window_start_time", window_start_time)

    @property
    @pulumi.getter(name="windowStartTime")
    def window_start_time(self) -> Optional[pulumi.Input['DomainOffPeakWindowOptionsOffPeakWindowWindowStartTimeArgs']]:
        """
        10h window for updates
        """
        return pulumi.get(self, "window_start_time")

    @window_start_time.setter
    def window_start_time(self, value: Optional[pulumi.Input['DomainOffPeakWindowOptionsOffPeakWindowWindowStartTimeArgs']]):
        pulumi.set(self, "window_start_time", value)


@pulumi.input_type
class DomainOffPeakWindowOptionsOffPeakWindowWindowStartTimeArgs:
    def __init__(__self__, *,
                 hours: Optional[pulumi.Input[int]] = None,
                 minutes: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] hours: Starting hour of the 10-hour window for updates
        :param pulumi.Input[int] minutes: Starting minute of the 10-hour window for updates
        """
        DomainOffPeakWindowOptionsOffPeakWindowWindowStartTimeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            hours=hours,
            minutes=minutes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             hours: Optional[pulumi.Input[int]] = None,
             minutes: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if hours is not None:
            _setter("hours", hours)
        if minutes is not None:
            _setter("minutes", minutes)

    @property
    @pulumi.getter
    def hours(self) -> Optional[pulumi.Input[int]]:
        """
        Starting hour of the 10-hour window for updates
        """
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "hours", value)

    @property
    @pulumi.getter
    def minutes(self) -> Optional[pulumi.Input[int]]:
        """
        Starting minute of the 10-hour window for updates
        """
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "minutes", value)


@pulumi.input_type
class DomainSamlOptionsSamlOptionsArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 idp: Optional[pulumi.Input['DomainSamlOptionsSamlOptionsIdpArgs']] = None,
                 master_backend_role: Optional[pulumi.Input[str]] = None,
                 master_user_name: Optional[pulumi.Input[str]] = None,
                 roles_key: Optional[pulumi.Input[str]] = None,
                 session_timeout_minutes: Optional[pulumi.Input[int]] = None,
                 subject_key: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Whether SAML authentication is enabled.
        :param pulumi.Input['DomainSamlOptionsSamlOptionsIdpArgs'] idp: Information from your identity provider.
        :param pulumi.Input[str] master_backend_role: This backend role from the SAML IdP receives full permissions to the cluster, equivalent to a new master user.
        :param pulumi.Input[str] master_user_name: This username from the SAML IdP receives full permissions to the cluster, equivalent to a new master user.
        :param pulumi.Input[str] roles_key: Element of the SAML assertion to use for backend roles. Default is roles.
        :param pulumi.Input[int] session_timeout_minutes: Duration of a session in minutes after a user logs in. Default is 60. Maximum value is 1,440.
        :param pulumi.Input[str] subject_key: Element of the SAML assertion to use for username. Default is NameID.
        """
        DomainSamlOptionsSamlOptionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            idp=idp,
            master_backend_role=master_backend_role,
            master_user_name=master_user_name,
            roles_key=roles_key,
            session_timeout_minutes=session_timeout_minutes,
            subject_key=subject_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[pulumi.Input[bool]] = None,
             idp: Optional[pulumi.Input['DomainSamlOptionsSamlOptionsIdpArgs']] = None,
             master_backend_role: Optional[pulumi.Input[str]] = None,
             master_user_name: Optional[pulumi.Input[str]] = None,
             roles_key: Optional[pulumi.Input[str]] = None,
             session_timeout_minutes: Optional[pulumi.Input[int]] = None,
             subject_key: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if master_backend_role is None and 'masterBackendRole' in kwargs:
            master_backend_role = kwargs['masterBackendRole']
        if master_user_name is None and 'masterUserName' in kwargs:
            master_user_name = kwargs['masterUserName']
        if roles_key is None and 'rolesKey' in kwargs:
            roles_key = kwargs['rolesKey']
        if session_timeout_minutes is None and 'sessionTimeoutMinutes' in kwargs:
            session_timeout_minutes = kwargs['sessionTimeoutMinutes']
        if subject_key is None and 'subjectKey' in kwargs:
            subject_key = kwargs['subjectKey']

        if enabled is not None:
            _setter("enabled", enabled)
        if idp is not None:
            _setter("idp", idp)
        if master_backend_role is not None:
            _setter("master_backend_role", master_backend_role)
        if master_user_name is not None:
            _setter("master_user_name", master_user_name)
        if roles_key is not None:
            _setter("roles_key", roles_key)
        if session_timeout_minutes is not None:
            _setter("session_timeout_minutes", session_timeout_minutes)
        if subject_key is not None:
            _setter("subject_key", subject_key)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether SAML authentication is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def idp(self) -> Optional[pulumi.Input['DomainSamlOptionsSamlOptionsIdpArgs']]:
        """
        Information from your identity provider.
        """
        return pulumi.get(self, "idp")

    @idp.setter
    def idp(self, value: Optional[pulumi.Input['DomainSamlOptionsSamlOptionsIdpArgs']]):
        pulumi.set(self, "idp", value)

    @property
    @pulumi.getter(name="masterBackendRole")
    def master_backend_role(self) -> Optional[pulumi.Input[str]]:
        """
        This backend role from the SAML IdP receives full permissions to the cluster, equivalent to a new master user.
        """
        return pulumi.get(self, "master_backend_role")

    @master_backend_role.setter
    def master_backend_role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "master_backend_role", value)

    @property
    @pulumi.getter(name="masterUserName")
    def master_user_name(self) -> Optional[pulumi.Input[str]]:
        """
        This username from the SAML IdP receives full permissions to the cluster, equivalent to a new master user.
        """
        return pulumi.get(self, "master_user_name")

    @master_user_name.setter
    def master_user_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "master_user_name", value)

    @property
    @pulumi.getter(name="rolesKey")
    def roles_key(self) -> Optional[pulumi.Input[str]]:
        """
        Element of the SAML assertion to use for backend roles. Default is roles.
        """
        return pulumi.get(self, "roles_key")

    @roles_key.setter
    def roles_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "roles_key", value)

    @property
    @pulumi.getter(name="sessionTimeoutMinutes")
    def session_timeout_minutes(self) -> Optional[pulumi.Input[int]]:
        """
        Duration of a session in minutes after a user logs in. Default is 60. Maximum value is 1,440.
        """
        return pulumi.get(self, "session_timeout_minutes")

    @session_timeout_minutes.setter
    def session_timeout_minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "session_timeout_minutes", value)

    @property
    @pulumi.getter(name="subjectKey")
    def subject_key(self) -> Optional[pulumi.Input[str]]:
        """
        Element of the SAML assertion to use for username. Default is NameID.
        """
        return pulumi.get(self, "subject_key")

    @subject_key.setter
    def subject_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subject_key", value)


@pulumi.input_type
class DomainSamlOptionsSamlOptionsIdpArgs:
    def __init__(__self__, *,
                 entity_id: pulumi.Input[str],
                 metadata_content: pulumi.Input[str]):
        """
        :param pulumi.Input[str] entity_id: Unique Entity ID of the application in SAML Identity Provider.
        :param pulumi.Input[str] metadata_content: Metadata of the SAML application in xml format.
        """
        DomainSamlOptionsSamlOptionsIdpArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            entity_id=entity_id,
            metadata_content=metadata_content,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             entity_id: Optional[pulumi.Input[str]] = None,
             metadata_content: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if entity_id is None and 'entityId' in kwargs:
            entity_id = kwargs['entityId']
        if entity_id is None:
            raise TypeError("Missing 'entity_id' argument")
        if metadata_content is None and 'metadataContent' in kwargs:
            metadata_content = kwargs['metadataContent']
        if metadata_content is None:
            raise TypeError("Missing 'metadata_content' argument")

        _setter("entity_id", entity_id)
        _setter("metadata_content", metadata_content)

    @property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> pulumi.Input[str]:
        """
        Unique Entity ID of the application in SAML Identity Provider.
        """
        return pulumi.get(self, "entity_id")

    @entity_id.setter
    def entity_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_id", value)

    @property
    @pulumi.getter(name="metadataContent")
    def metadata_content(self) -> pulumi.Input[str]:
        """
        Metadata of the SAML application in xml format.
        """
        return pulumi.get(self, "metadata_content")

    @metadata_content.setter
    def metadata_content(self, value: pulumi.Input[str]):
        pulumi.set(self, "metadata_content", value)


@pulumi.input_type
class DomainSnapshotOptionsArgs:
    def __init__(__self__, *,
                 automated_snapshot_start_hour: pulumi.Input[int]):
        """
        :param pulumi.Input[int] automated_snapshot_start_hour: Hour during which the service takes an automated daily snapshot of the indices in the domain.
        """
        DomainSnapshotOptionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            automated_snapshot_start_hour=automated_snapshot_start_hour,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             automated_snapshot_start_hour: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if automated_snapshot_start_hour is None and 'automatedSnapshotStartHour' in kwargs:
            automated_snapshot_start_hour = kwargs['automatedSnapshotStartHour']
        if automated_snapshot_start_hour is None:
            raise TypeError("Missing 'automated_snapshot_start_hour' argument")

        _setter("automated_snapshot_start_hour", automated_snapshot_start_hour)

    @property
    @pulumi.getter(name="automatedSnapshotStartHour")
    def automated_snapshot_start_hour(self) -> pulumi.Input[int]:
        """
        Hour during which the service takes an automated daily snapshot of the indices in the domain.
        """
        return pulumi.get(self, "automated_snapshot_start_hour")

    @automated_snapshot_start_hour.setter
    def automated_snapshot_start_hour(self, value: pulumi.Input[int]):
        pulumi.set(self, "automated_snapshot_start_hour", value)


@pulumi.input_type
class DomainSoftwareUpdateOptionsArgs:
    def __init__(__self__, *,
                 auto_software_update_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] auto_software_update_enabled: Whether automatic service software updates are enabled for the domain. Defaults to `false`.
        """
        DomainSoftwareUpdateOptionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auto_software_update_enabled=auto_software_update_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auto_software_update_enabled: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if auto_software_update_enabled is None and 'autoSoftwareUpdateEnabled' in kwargs:
            auto_software_update_enabled = kwargs['autoSoftwareUpdateEnabled']

        if auto_software_update_enabled is not None:
            _setter("auto_software_update_enabled", auto_software_update_enabled)

    @property
    @pulumi.getter(name="autoSoftwareUpdateEnabled")
    def auto_software_update_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether automatic service software updates are enabled for the domain. Defaults to `false`.
        """
        return pulumi.get(self, "auto_software_update_enabled")

    @auto_software_update_enabled.setter
    def auto_software_update_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_software_update_enabled", value)


@pulumi.input_type
class DomainVpcOptionsArgs:
    def __init__(__self__, *,
                 availability_zones: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 security_group_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 subnet_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 vpc_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_group_ids: List of VPC Security Group IDs to be applied to the OpenSearch domain endpoints. If omitted, the default Security Group for the VPC will be used.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] subnet_ids: List of VPC Subnet IDs for the OpenSearch domain endpoints to be created in.
        """
        DomainVpcOptionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability_zones=availability_zones,
            security_group_ids=security_group_ids,
            subnet_ids=subnet_ids,
            vpc_id=vpc_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability_zones: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             security_group_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             subnet_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             vpc_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if availability_zones is None and 'availabilityZones' in kwargs:
            availability_zones = kwargs['availabilityZones']
        if security_group_ids is None and 'securityGroupIds' in kwargs:
            security_group_ids = kwargs['securityGroupIds']
        if subnet_ids is None and 'subnetIds' in kwargs:
            subnet_ids = kwargs['subnetIds']
        if vpc_id is None and 'vpcId' in kwargs:
            vpc_id = kwargs['vpcId']

        if availability_zones is not None:
            _setter("availability_zones", availability_zones)
        if security_group_ids is not None:
            _setter("security_group_ids", security_group_ids)
        if subnet_ids is not None:
            _setter("subnet_ids", subnet_ids)
        if vpc_id is not None:
            _setter("vpc_id", vpc_id)

    @property
    @pulumi.getter(name="availabilityZones")
    def availability_zones(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "availability_zones")

    @availability_zones.setter
    def availability_zones(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "availability_zones", value)

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of VPC Security Group IDs to be applied to the OpenSearch domain endpoints. If omitted, the default Security Group for the VPC will be used.
        """
        return pulumi.get(self, "security_group_ids")

    @security_group_ids.setter
    def security_group_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "security_group_ids", value)

    @property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of VPC Subnet IDs for the OpenSearch domain endpoints to be created in.
        """
        return pulumi.get(self, "subnet_ids")

    @subnet_ids.setter
    def subnet_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "subnet_ids", value)

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "vpc_id")

    @vpc_id.setter
    def vpc_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vpc_id", value)


@pulumi.input_type
class OutboundConnectionConnectionPropertiesArgs:
    def __init__(__self__, *,
                 cross_cluster_search: Optional[pulumi.Input['OutboundConnectionConnectionPropertiesCrossClusterSearchArgs']] = None,
                 endpoint: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['OutboundConnectionConnectionPropertiesCrossClusterSearchArgs'] cross_cluster_search: Configuration block for cross cluster search.
        :param pulumi.Input[str] endpoint: The endpoint of the remote domain, is only set when `connection_mode` is `VPC_ENDPOINT` and `accept_connection` is `TRUE`.
        """
        OutboundConnectionConnectionPropertiesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cross_cluster_search=cross_cluster_search,
            endpoint=endpoint,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cross_cluster_search: Optional[pulumi.Input['OutboundConnectionConnectionPropertiesCrossClusterSearchArgs']] = None,
             endpoint: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cross_cluster_search is None and 'crossClusterSearch' in kwargs:
            cross_cluster_search = kwargs['crossClusterSearch']

        if cross_cluster_search is not None:
            _setter("cross_cluster_search", cross_cluster_search)
        if endpoint is not None:
            _setter("endpoint", endpoint)

    @property
    @pulumi.getter(name="crossClusterSearch")
    def cross_cluster_search(self) -> Optional[pulumi.Input['OutboundConnectionConnectionPropertiesCrossClusterSearchArgs']]:
        """
        Configuration block for cross cluster search.
        """
        return pulumi.get(self, "cross_cluster_search")

    @cross_cluster_search.setter
    def cross_cluster_search(self, value: Optional[pulumi.Input['OutboundConnectionConnectionPropertiesCrossClusterSearchArgs']]):
        pulumi.set(self, "cross_cluster_search", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        The endpoint of the remote domain, is only set when `connection_mode` is `VPC_ENDPOINT` and `accept_connection` is `TRUE`.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint", value)


@pulumi.input_type
class OutboundConnectionConnectionPropertiesCrossClusterSearchArgs:
    def __init__(__self__, *,
                 skip_unavailable: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] skip_unavailable: Skips unavailable clusters and can only be used for cross-cluster searches. Accepted values are `ENABLED` or `DISABLED`.
        """
        OutboundConnectionConnectionPropertiesCrossClusterSearchArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            skip_unavailable=skip_unavailable,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             skip_unavailable: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if skip_unavailable is None and 'skipUnavailable' in kwargs:
            skip_unavailable = kwargs['skipUnavailable']

        if skip_unavailable is not None:
            _setter("skip_unavailable", skip_unavailable)

    @property
    @pulumi.getter(name="skipUnavailable")
    def skip_unavailable(self) -> Optional[pulumi.Input[str]]:
        """
        Skips unavailable clusters and can only be used for cross-cluster searches. Accepted values are `ENABLED` or `DISABLED`.
        """
        return pulumi.get(self, "skip_unavailable")

    @skip_unavailable.setter
    def skip_unavailable(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "skip_unavailable", value)


@pulumi.input_type
class OutboundConnectionLocalDomainInfoArgs:
    def __init__(__self__, *,
                 domain_name: pulumi.Input[str],
                 owner_id: pulumi.Input[str],
                 region: pulumi.Input[str]):
        """
        :param pulumi.Input[str] domain_name: The name of the local domain.
        :param pulumi.Input[str] owner_id: The Account ID of the owner of the local domain.
        :param pulumi.Input[str] region: The region of the local domain.
        """
        OutboundConnectionLocalDomainInfoArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            domain_name=domain_name,
            owner_id=owner_id,
            region=region,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             domain_name: Optional[pulumi.Input[str]] = None,
             owner_id: Optional[pulumi.Input[str]] = None,
             region: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if domain_name is None and 'domainName' in kwargs:
            domain_name = kwargs['domainName']
        if domain_name is None:
            raise TypeError("Missing 'domain_name' argument")
        if owner_id is None and 'ownerId' in kwargs:
            owner_id = kwargs['ownerId']
        if owner_id is None:
            raise TypeError("Missing 'owner_id' argument")
        if region is None:
            raise TypeError("Missing 'region' argument")

        _setter("domain_name", domain_name)
        _setter("owner_id", owner_id)
        _setter("region", region)

    @property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> pulumi.Input[str]:
        """
        The name of the local domain.
        """
        return pulumi.get(self, "domain_name")

    @domain_name.setter
    def domain_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "domain_name", value)

    @property
    @pulumi.getter(name="ownerId")
    def owner_id(self) -> pulumi.Input[str]:
        """
        The Account ID of the owner of the local domain.
        """
        return pulumi.get(self, "owner_id")

    @owner_id.setter
    def owner_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "owner_id", value)

    @property
    @pulumi.getter
    def region(self) -> pulumi.Input[str]:
        """
        The region of the local domain.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[str]):
        pulumi.set(self, "region", value)


@pulumi.input_type
class OutboundConnectionRemoteDomainInfoArgs:
    def __init__(__self__, *,
                 domain_name: pulumi.Input[str],
                 owner_id: pulumi.Input[str],
                 region: pulumi.Input[str]):
        """
        :param pulumi.Input[str] domain_name: The name of the remote domain.
        :param pulumi.Input[str] owner_id: The Account ID of the owner of the remote domain.
        :param pulumi.Input[str] region: The region of the remote domain.
        """
        OutboundConnectionRemoteDomainInfoArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            domain_name=domain_name,
            owner_id=owner_id,
            region=region,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             domain_name: Optional[pulumi.Input[str]] = None,
             owner_id: Optional[pulumi.Input[str]] = None,
             region: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if domain_name is None and 'domainName' in kwargs:
            domain_name = kwargs['domainName']
        if domain_name is None:
            raise TypeError("Missing 'domain_name' argument")
        if owner_id is None and 'ownerId' in kwargs:
            owner_id = kwargs['ownerId']
        if owner_id is None:
            raise TypeError("Missing 'owner_id' argument")
        if region is None:
            raise TypeError("Missing 'region' argument")

        _setter("domain_name", domain_name)
        _setter("owner_id", owner_id)
        _setter("region", region)

    @property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> pulumi.Input[str]:
        """
        The name of the remote domain.
        """
        return pulumi.get(self, "domain_name")

    @domain_name.setter
    def domain_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "domain_name", value)

    @property
    @pulumi.getter(name="ownerId")
    def owner_id(self) -> pulumi.Input[str]:
        """
        The Account ID of the owner of the remote domain.
        """
        return pulumi.get(self, "owner_id")

    @owner_id.setter
    def owner_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "owner_id", value)

    @property
    @pulumi.getter
    def region(self) -> pulumi.Input[str]:
        """
        The region of the remote domain.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[str]):
        pulumi.set(self, "region", value)


@pulumi.input_type
class PackagePackageSourceArgs:
    def __init__(__self__, *,
                 s3_bucket_name: pulumi.Input[str],
                 s3_key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] s3_bucket_name: The name of the Amazon S3 bucket containing the package.
        :param pulumi.Input[str] s3_key: Key (file name) of the package.
        """
        PackagePackageSourceArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            s3_bucket_name=s3_bucket_name,
            s3_key=s3_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             s3_bucket_name: Optional[pulumi.Input[str]] = None,
             s3_key: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if s3_bucket_name is None and 's3BucketName' in kwargs:
            s3_bucket_name = kwargs['s3BucketName']
        if s3_bucket_name is None:
            raise TypeError("Missing 's3_bucket_name' argument")
        if s3_key is None and 's3Key' in kwargs:
            s3_key = kwargs['s3Key']
        if s3_key is None:
            raise TypeError("Missing 's3_key' argument")

        _setter("s3_bucket_name", s3_bucket_name)
        _setter("s3_key", s3_key)

    @property
    @pulumi.getter(name="s3BucketName")
    def s3_bucket_name(self) -> pulumi.Input[str]:
        """
        The name of the Amazon S3 bucket containing the package.
        """
        return pulumi.get(self, "s3_bucket_name")

    @s3_bucket_name.setter
    def s3_bucket_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "s3_bucket_name", value)

    @property
    @pulumi.getter(name="s3Key")
    def s3_key(self) -> pulumi.Input[str]:
        """
        Key (file name) of the package.
        """
        return pulumi.get(self, "s3_key")

    @s3_key.setter
    def s3_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "s3_key", value)


@pulumi.input_type
class ServerlessCollectionTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[str]] = None,
                 delete: Optional[pulumi.Input[str]] = None):
        ServerlessCollectionTimeoutsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            create=create,
            delete=delete,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             create: Optional[pulumi.Input[str]] = None,
             delete: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if create is not None:
            _setter("create", create)
        if delete is not None:
            _setter("delete", delete)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "create", value)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delete", value)


@pulumi.input_type
class ServerlessSecurityConfigSamlOptionsArgs:
    def __init__(__self__, *,
                 metadata: pulumi.Input[str],
                 group_attribute: Optional[pulumi.Input[str]] = None,
                 session_timeout: Optional[pulumi.Input[int]] = None,
                 user_attribute: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] metadata: The XML IdP metadata file generated from your identity provider.
        :param pulumi.Input[str] group_attribute: Group attribute for this SAML integration.
        :param pulumi.Input[int] session_timeout: Session timeout, in minutes. Minimum is 5 minutes and maximum is 720 minutes (12 hours). Default is 60 minutes.
        :param pulumi.Input[str] user_attribute: User attribute for this SAML integration.
        """
        ServerlessSecurityConfigSamlOptionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            metadata=metadata,
            group_attribute=group_attribute,
            session_timeout=session_timeout,
            user_attribute=user_attribute,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             metadata: Optional[pulumi.Input[str]] = None,
             group_attribute: Optional[pulumi.Input[str]] = None,
             session_timeout: Optional[pulumi.Input[int]] = None,
             user_attribute: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if metadata is None:
            raise TypeError("Missing 'metadata' argument")
        if group_attribute is None and 'groupAttribute' in kwargs:
            group_attribute = kwargs['groupAttribute']
        if session_timeout is None and 'sessionTimeout' in kwargs:
            session_timeout = kwargs['sessionTimeout']
        if user_attribute is None and 'userAttribute' in kwargs:
            user_attribute = kwargs['userAttribute']

        _setter("metadata", metadata)
        if group_attribute is not None:
            _setter("group_attribute", group_attribute)
        if session_timeout is not None:
            _setter("session_timeout", session_timeout)
        if user_attribute is not None:
            _setter("user_attribute", user_attribute)

    @property
    @pulumi.getter
    def metadata(self) -> pulumi.Input[str]:
        """
        The XML IdP metadata file generated from your identity provider.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: pulumi.Input[str]):
        pulumi.set(self, "metadata", value)

    @property
    @pulumi.getter(name="groupAttribute")
    def group_attribute(self) -> Optional[pulumi.Input[str]]:
        """
        Group attribute for this SAML integration.
        """
        return pulumi.get(self, "group_attribute")

    @group_attribute.setter
    def group_attribute(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_attribute", value)

    @property
    @pulumi.getter(name="sessionTimeout")
    def session_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        Session timeout, in minutes. Minimum is 5 minutes and maximum is 720 minutes (12 hours). Default is 60 minutes.
        """
        return pulumi.get(self, "session_timeout")

    @session_timeout.setter
    def session_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "session_timeout", value)

    @property
    @pulumi.getter(name="userAttribute")
    def user_attribute(self) -> Optional[pulumi.Input[str]]:
        """
        User attribute for this SAML integration.
        """
        return pulumi.get(self, "user_attribute")

    @user_attribute.setter
    def user_attribute(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_attribute", value)


@pulumi.input_type
class ServerlessVpcEndpointTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[str]] = None,
                 delete: Optional[pulumi.Input[str]] = None,
                 update: Optional[pulumi.Input[str]] = None):
        ServerlessVpcEndpointTimeoutsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            create=create,
            delete=delete,
            update=update,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             create: Optional[pulumi.Input[str]] = None,
             delete: Optional[pulumi.Input[str]] = None,
             update: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if create is not None:
            _setter("create", create)
        if delete is not None:
            _setter("delete", delete)
        if update is not None:
            _setter("update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "create", value)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delete", value)

    @property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "update", value)


@pulumi.input_type
class VpcEndpointVpcOptionsArgs:
    def __init__(__self__, *,
                 subnet_ids: pulumi.Input[Sequence[pulumi.Input[str]]],
                 availability_zones: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 security_group_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 vpc_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] subnet_ids: A list of subnet IDs associated with the VPC endpoints for the domain. If your domain uses multiple Availability Zones, you need to provide two subnet IDs, one per zone. Otherwise, provide only one.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_group_ids: The list of security group IDs associated with the VPC endpoints for the domain. If you do not provide a security group ID, OpenSearch Service uses the default security group for the VPC.
        """
        VpcEndpointVpcOptionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            subnet_ids=subnet_ids,
            availability_zones=availability_zones,
            security_group_ids=security_group_ids,
            vpc_id=vpc_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             subnet_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             availability_zones: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             security_group_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             vpc_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if subnet_ids is None and 'subnetIds' in kwargs:
            subnet_ids = kwargs['subnetIds']
        if subnet_ids is None:
            raise TypeError("Missing 'subnet_ids' argument")
        if availability_zones is None and 'availabilityZones' in kwargs:
            availability_zones = kwargs['availabilityZones']
        if security_group_ids is None and 'securityGroupIds' in kwargs:
            security_group_ids = kwargs['securityGroupIds']
        if vpc_id is None and 'vpcId' in kwargs:
            vpc_id = kwargs['vpcId']

        _setter("subnet_ids", subnet_ids)
        if availability_zones is not None:
            _setter("availability_zones", availability_zones)
        if security_group_ids is not None:
            _setter("security_group_ids", security_group_ids)
        if vpc_id is not None:
            _setter("vpc_id", vpc_id)

    @property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of subnet IDs associated with the VPC endpoints for the domain. If your domain uses multiple Availability Zones, you need to provide two subnet IDs, one per zone. Otherwise, provide only one.
        """
        return pulumi.get(self, "subnet_ids")

    @subnet_ids.setter
    def subnet_ids(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "subnet_ids", value)

    @property
    @pulumi.getter(name="availabilityZones")
    def availability_zones(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "availability_zones")

    @availability_zones.setter
    def availability_zones(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "availability_zones", value)

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of security group IDs associated with the VPC endpoints for the domain. If you do not provide a security group ID, OpenSearch Service uses the default security group for the VPC.
        """
        return pulumi.get(self, "security_group_ids")

    @security_group_ids.setter
    def security_group_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "security_group_ids", value)

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "vpc_id")

    @vpc_id.setter
    def vpc_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vpc_id", value)


@pulumi.input_type
class GetDomainOffPeakWindowOptionsArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 off_peak_windows: Sequence['GetDomainOffPeakWindowOptionsOffPeakWindowArgs']):
        """
        :param bool enabled: Enabled disabled toggle for off-peak update window
        """
        GetDomainOffPeakWindowOptionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            off_peak_windows=off_peak_windows,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[bool] = None,
             off_peak_windows: Optional[Sequence['GetDomainOffPeakWindowOptionsOffPeakWindowArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if enabled is None:
            raise TypeError("Missing 'enabled' argument")
        if off_peak_windows is None and 'offPeakWindows' in kwargs:
            off_peak_windows = kwargs['offPeakWindows']
        if off_peak_windows is None:
            raise TypeError("Missing 'off_peak_windows' argument")

        _setter("enabled", enabled)
        _setter("off_peak_windows", off_peak_windows)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Enabled disabled toggle for off-peak update window
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="offPeakWindows")
    def off_peak_windows(self) -> Sequence['GetDomainOffPeakWindowOptionsOffPeakWindowArgs']:
        return pulumi.get(self, "off_peak_windows")

    @off_peak_windows.setter
    def off_peak_windows(self, value: Sequence['GetDomainOffPeakWindowOptionsOffPeakWindowArgs']):
        pulumi.set(self, "off_peak_windows", value)


@pulumi.input_type
class GetDomainOffPeakWindowOptionsOffPeakWindowArgs:
    def __init__(__self__, *,
                 window_start_times: Sequence['GetDomainOffPeakWindowOptionsOffPeakWindowWindowStartTimeArgs']):
        """
        :param Sequence['GetDomainOffPeakWindowOptionsOffPeakWindowWindowStartTimeArgs'] window_start_times: 10h window for updates
        """
        GetDomainOffPeakWindowOptionsOffPeakWindowArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            window_start_times=window_start_times,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             window_start_times: Optional[Sequence['GetDomainOffPeakWindowOptionsOffPeakWindowWindowStartTimeArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if window_start_times is None and 'windowStartTimes' in kwargs:
            window_start_times = kwargs['windowStartTimes']
        if window_start_times is None:
            raise TypeError("Missing 'window_start_times' argument")

        _setter("window_start_times", window_start_times)

    @property
    @pulumi.getter(name="windowStartTimes")
    def window_start_times(self) -> Sequence['GetDomainOffPeakWindowOptionsOffPeakWindowWindowStartTimeArgs']:
        """
        10h window for updates
        """
        return pulumi.get(self, "window_start_times")

    @window_start_times.setter
    def window_start_times(self, value: Sequence['GetDomainOffPeakWindowOptionsOffPeakWindowWindowStartTimeArgs']):
        pulumi.set(self, "window_start_times", value)


@pulumi.input_type
class GetDomainOffPeakWindowOptionsOffPeakWindowWindowStartTimeArgs:
    def __init__(__self__, *,
                 hours: int,
                 minutes: int):
        """
        :param int hours: Starting hour of the 10-hour window for updates
        :param int minutes: Starting minute of the 10-hour window for updates
        """
        GetDomainOffPeakWindowOptionsOffPeakWindowWindowStartTimeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            hours=hours,
            minutes=minutes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             hours: Optional[int] = None,
             minutes: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if hours is None:
            raise TypeError("Missing 'hours' argument")
        if minutes is None:
            raise TypeError("Missing 'minutes' argument")

        _setter("hours", hours)
        _setter("minutes", minutes)

    @property
    @pulumi.getter
    def hours(self) -> int:
        """
        Starting hour of the 10-hour window for updates
        """
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: int):
        pulumi.set(self, "hours", value)

    @property
    @pulumi.getter
    def minutes(self) -> int:
        """
        Starting minute of the 10-hour window for updates
        """
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: int):
        pulumi.set(self, "minutes", value)


@pulumi.input_type
class GetServerlessSecurityConfigSamlOptionsArgs:
    def __init__(__self__, *,
                 group_attribute: str,
                 metadata: str,
                 session_timeout: int,
                 user_attribute: str):
        """
        :param str group_attribute: Group attribute for this SAML integration.
        :param str metadata: The XML IdP metadata file generated from your identity provider.
        :param int session_timeout: Session timeout, in minutes. Minimum is 5 minutes and maximum is 720 minutes (12 hours). Default is 60 minutes.
        :param str user_attribute: User attribute for this SAML integration.
        """
        GetServerlessSecurityConfigSamlOptionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            group_attribute=group_attribute,
            metadata=metadata,
            session_timeout=session_timeout,
            user_attribute=user_attribute,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             group_attribute: Optional[str] = None,
             metadata: Optional[str] = None,
             session_timeout: Optional[int] = None,
             user_attribute: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if group_attribute is None and 'groupAttribute' in kwargs:
            group_attribute = kwargs['groupAttribute']
        if group_attribute is None:
            raise TypeError("Missing 'group_attribute' argument")
        if metadata is None:
            raise TypeError("Missing 'metadata' argument")
        if session_timeout is None and 'sessionTimeout' in kwargs:
            session_timeout = kwargs['sessionTimeout']
        if session_timeout is None:
            raise TypeError("Missing 'session_timeout' argument")
        if user_attribute is None and 'userAttribute' in kwargs:
            user_attribute = kwargs['userAttribute']
        if user_attribute is None:
            raise TypeError("Missing 'user_attribute' argument")

        _setter("group_attribute", group_attribute)
        _setter("metadata", metadata)
        _setter("session_timeout", session_timeout)
        _setter("user_attribute", user_attribute)

    @property
    @pulumi.getter(name="groupAttribute")
    def group_attribute(self) -> str:
        """
        Group attribute for this SAML integration.
        """
        return pulumi.get(self, "group_attribute")

    @group_attribute.setter
    def group_attribute(self, value: str):
        pulumi.set(self, "group_attribute", value)

    @property
    @pulumi.getter
    def metadata(self) -> str:
        """
        The XML IdP metadata file generated from your identity provider.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: str):
        pulumi.set(self, "metadata", value)

    @property
    @pulumi.getter(name="sessionTimeout")
    def session_timeout(self) -> int:
        """
        Session timeout, in minutes. Minimum is 5 minutes and maximum is 720 minutes (12 hours). Default is 60 minutes.
        """
        return pulumi.get(self, "session_timeout")

    @session_timeout.setter
    def session_timeout(self, value: int):
        pulumi.set(self, "session_timeout", value)

    @property
    @pulumi.getter(name="userAttribute")
    def user_attribute(self) -> str:
        """
        User attribute for this SAML integration.
        """
        return pulumi.get(self, "user_attribute")

    @user_attribute.setter
    def user_attribute(self, value: str):
        pulumi.set(self, "user_attribute", value)


