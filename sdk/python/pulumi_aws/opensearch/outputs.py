# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'AuthorizeVpcEndpointAccessAuthorizedPrincipal',
    'DomainAdvancedSecurityOptions',
    'DomainAdvancedSecurityOptionsMasterUserOptions',
    'DomainAimlOptions',
    'DomainAimlOptionsNaturalLanguageQueryGenerationOptions',
    'DomainAimlOptionsS3VectorsEngine',
    'DomainAutoTuneOptions',
    'DomainAutoTuneOptionsMaintenanceSchedule',
    'DomainAutoTuneOptionsMaintenanceScheduleDuration',
    'DomainClusterConfig',
    'DomainClusterConfigColdStorageOptions',
    'DomainClusterConfigNodeOption',
    'DomainClusterConfigNodeOptionNodeConfig',
    'DomainClusterConfigZoneAwarenessConfig',
    'DomainCognitoOptions',
    'DomainDomainEndpointOptions',
    'DomainEbsOptions',
    'DomainEncryptAtRest',
    'DomainIdentityCenterOptions',
    'DomainLogPublishingOption',
    'DomainNodeToNodeEncryption',
    'DomainOffPeakWindowOptions',
    'DomainOffPeakWindowOptionsOffPeakWindow',
    'DomainOffPeakWindowOptionsOffPeakWindowWindowStartTime',
    'DomainSamlOptionsSamlOptions',
    'DomainSamlOptionsSamlOptionsIdp',
    'DomainSnapshotOptions',
    'DomainSoftwareUpdateOptions',
    'DomainVpcOptions',
    'OutboundConnectionConnectionProperties',
    'OutboundConnectionConnectionPropertiesCrossClusterSearch',
    'OutboundConnectionLocalDomainInfo',
    'OutboundConnectionRemoteDomainInfo',
    'PackagePackageSource',
    'ServerlessCollectionTimeouts',
    'ServerlessSecurityConfigSamlOptions',
    'ServerlessVpcEndpointTimeouts',
    'VpcEndpointVpcOptions',
    'GetDomainAdvancedSecurityOptionResult',
    'GetDomainAutoTuneOptionResult',
    'GetDomainAutoTuneOptionMaintenanceScheduleResult',
    'GetDomainAutoTuneOptionMaintenanceScheduleDurationResult',
    'GetDomainClusterConfigResult',
    'GetDomainClusterConfigColdStorageOptionResult',
    'GetDomainClusterConfigNodeOptionResult',
    'GetDomainClusterConfigNodeOptionNodeConfigResult',
    'GetDomainClusterConfigZoneAwarenessConfigResult',
    'GetDomainCognitoOptionResult',
    'GetDomainEbsOptionResult',
    'GetDomainEncryptionAtRestResult',
    'GetDomainIdentityCenterOptionResult',
    'GetDomainLogPublishingOptionResult',
    'GetDomainNodeToNodeEncryptionResult',
    'GetDomainOffPeakWindowOptionsResult',
    'GetDomainOffPeakWindowOptionsOffPeakWindowResult',
    'GetDomainOffPeakWindowOptionsOffPeakWindowWindowStartTimeResult',
    'GetDomainSnapshotOptionResult',
    'GetDomainSoftwareUpdateOptionResult',
    'GetDomainVpcOptionResult',
    'GetServerlessSecurityConfigSamlOptionResult',
]

@pulumi.output_type
class AuthorizeVpcEndpointAccessAuthorizedPrincipal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalType":
            suggest = "principal_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AuthorizeVpcEndpointAccessAuthorizedPrincipal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AuthorizeVpcEndpointAccessAuthorizedPrincipal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AuthorizeVpcEndpointAccessAuthorizedPrincipal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 principal: _builtins.str,
                 principal_type: _builtins.str):
        pulumi.set(__self__, "principal", principal)
        pulumi.set(__self__, "principal_type", principal_type)

    @_builtins.property
    @pulumi.getter
    def principal(self) -> _builtins.str:
        return pulumi.get(self, "principal")

    @_builtins.property
    @pulumi.getter(name="principalType")
    def principal_type(self) -> _builtins.str:
        return pulumi.get(self, "principal_type")


@pulumi.output_type
class DomainAdvancedSecurityOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anonymousAuthEnabled":
            suggest = "anonymous_auth_enabled"
        elif key == "internalUserDatabaseEnabled":
            suggest = "internal_user_database_enabled"
        elif key == "masterUserOptions":
            suggest = "master_user_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainAdvancedSecurityOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainAdvancedSecurityOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainAdvancedSecurityOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 anonymous_auth_enabled: Optional[_builtins.bool] = None,
                 internal_user_database_enabled: Optional[_builtins.bool] = None,
                 master_user_options: Optional['outputs.DomainAdvancedSecurityOptionsMasterUserOptions'] = None):
        pulumi.set(__self__, "enabled", enabled)
        if anonymous_auth_enabled is not None:
            pulumi.set(__self__, "anonymous_auth_enabled", anonymous_auth_enabled)
        if internal_user_database_enabled is not None:
            pulumi.set(__self__, "internal_user_database_enabled", internal_user_database_enabled)
        if master_user_options is not None:
            pulumi.set(__self__, "master_user_options", master_user_options)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="anonymousAuthEnabled")
    def anonymous_auth_enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "anonymous_auth_enabled")

    @_builtins.property
    @pulumi.getter(name="internalUserDatabaseEnabled")
    def internal_user_database_enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "internal_user_database_enabled")

    @_builtins.property
    @pulumi.getter(name="masterUserOptions")
    def master_user_options(self) -> Optional['outputs.DomainAdvancedSecurityOptionsMasterUserOptions']:
        return pulumi.get(self, "master_user_options")


@pulumi.output_type
class DomainAdvancedSecurityOptionsMasterUserOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "masterUserArn":
            suggest = "master_user_arn"
        elif key == "masterUserName":
            suggest = "master_user_name"
        elif key == "masterUserPassword":
            suggest = "master_user_password"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainAdvancedSecurityOptionsMasterUserOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainAdvancedSecurityOptionsMasterUserOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainAdvancedSecurityOptionsMasterUserOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 master_user_arn: Optional[_builtins.str] = None,
                 master_user_name: Optional[_builtins.str] = None,
                 master_user_password: Optional[_builtins.str] = None):
        if master_user_arn is not None:
            pulumi.set(__self__, "master_user_arn", master_user_arn)
        if master_user_name is not None:
            pulumi.set(__self__, "master_user_name", master_user_name)
        if master_user_password is not None:
            pulumi.set(__self__, "master_user_password", master_user_password)

    @_builtins.property
    @pulumi.getter(name="masterUserArn")
    def master_user_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "master_user_arn")

    @_builtins.property
    @pulumi.getter(name="masterUserName")
    def master_user_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "master_user_name")

    @_builtins.property
    @pulumi.getter(name="masterUserPassword")
    def master_user_password(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "master_user_password")


@pulumi.output_type
class DomainAimlOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "naturalLanguageQueryGenerationOptions":
            suggest = "natural_language_query_generation_options"
        elif key == "s3VectorsEngine":
            suggest = "s3_vectors_engine"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainAimlOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainAimlOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainAimlOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 natural_language_query_generation_options: Optional['outputs.DomainAimlOptionsNaturalLanguageQueryGenerationOptions'] = None,
                 s3_vectors_engine: Optional['outputs.DomainAimlOptionsS3VectorsEngine'] = None):
        if natural_language_query_generation_options is not None:
            pulumi.set(__self__, "natural_language_query_generation_options", natural_language_query_generation_options)
        if s3_vectors_engine is not None:
            pulumi.set(__self__, "s3_vectors_engine", s3_vectors_engine)

    @_builtins.property
    @pulumi.getter(name="naturalLanguageQueryGenerationOptions")
    def natural_language_query_generation_options(self) -> Optional['outputs.DomainAimlOptionsNaturalLanguageQueryGenerationOptions']:
        return pulumi.get(self, "natural_language_query_generation_options")

    @_builtins.property
    @pulumi.getter(name="s3VectorsEngine")
    def s3_vectors_engine(self) -> Optional['outputs.DomainAimlOptionsS3VectorsEngine']:
        return pulumi.get(self, "s3_vectors_engine")


@pulumi.output_type
class DomainAimlOptionsNaturalLanguageQueryGenerationOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "desiredState":
            suggest = "desired_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainAimlOptionsNaturalLanguageQueryGenerationOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainAimlOptionsNaturalLanguageQueryGenerationOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainAimlOptionsNaturalLanguageQueryGenerationOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 desired_state: Optional[_builtins.str] = None):
        if desired_state is not None:
            pulumi.set(__self__, "desired_state", desired_state)

    @_builtins.property
    @pulumi.getter(name="desiredState")
    def desired_state(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "desired_state")


@pulumi.output_type
class DomainAimlOptionsS3VectorsEngine(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class DomainAutoTuneOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "desiredState":
            suggest = "desired_state"
        elif key == "maintenanceSchedules":
            suggest = "maintenance_schedules"
        elif key == "rollbackOnDisable":
            suggest = "rollback_on_disable"
        elif key == "useOffPeakWindow":
            suggest = "use_off_peak_window"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainAutoTuneOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainAutoTuneOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainAutoTuneOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 desired_state: _builtins.str,
                 maintenance_schedules: Optional[Sequence['outputs.DomainAutoTuneOptionsMaintenanceSchedule']] = None,
                 rollback_on_disable: Optional[_builtins.str] = None,
                 use_off_peak_window: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "desired_state", desired_state)
        if maintenance_schedules is not None:
            pulumi.set(__self__, "maintenance_schedules", maintenance_schedules)
        if rollback_on_disable is not None:
            pulumi.set(__self__, "rollback_on_disable", rollback_on_disable)
        if use_off_peak_window is not None:
            pulumi.set(__self__, "use_off_peak_window", use_off_peak_window)

    @_builtins.property
    @pulumi.getter(name="desiredState")
    def desired_state(self) -> _builtins.str:
        return pulumi.get(self, "desired_state")

    @_builtins.property
    @pulumi.getter(name="maintenanceSchedules")
    def maintenance_schedules(self) -> Optional[Sequence['outputs.DomainAutoTuneOptionsMaintenanceSchedule']]:
        return pulumi.get(self, "maintenance_schedules")

    @_builtins.property
    @pulumi.getter(name="rollbackOnDisable")
    def rollback_on_disable(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "rollback_on_disable")

    @_builtins.property
    @pulumi.getter(name="useOffPeakWindow")
    def use_off_peak_window(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "use_off_peak_window")


@pulumi.output_type
class DomainAutoTuneOptionsMaintenanceSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cronExpressionForRecurrence":
            suggest = "cron_expression_for_recurrence"
        elif key == "startAt":
            suggest = "start_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainAutoTuneOptionsMaintenanceSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainAutoTuneOptionsMaintenanceSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainAutoTuneOptionsMaintenanceSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cron_expression_for_recurrence: _builtins.str,
                 duration: 'outputs.DomainAutoTuneOptionsMaintenanceScheduleDuration',
                 start_at: _builtins.str):
        pulumi.set(__self__, "cron_expression_for_recurrence", cron_expression_for_recurrence)
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "start_at", start_at)

    @_builtins.property
    @pulumi.getter(name="cronExpressionForRecurrence")
    def cron_expression_for_recurrence(self) -> _builtins.str:
        return pulumi.get(self, "cron_expression_for_recurrence")

    @_builtins.property
    @pulumi.getter
    def duration(self) -> 'outputs.DomainAutoTuneOptionsMaintenanceScheduleDuration':
        return pulumi.get(self, "duration")

    @_builtins.property
    @pulumi.getter(name="startAt")
    def start_at(self) -> _builtins.str:
        return pulumi.get(self, "start_at")


@pulumi.output_type
class DomainAutoTuneOptionsMaintenanceScheduleDuration(dict):
    def __init__(__self__, *,
                 unit: _builtins.str,
                 value: _builtins.int):
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def unit(self) -> _builtins.str:
        return pulumi.get(self, "unit")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.int:
        return pulumi.get(self, "value")


@pulumi.output_type
class DomainClusterConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "coldStorageOptions":
            suggest = "cold_storage_options"
        elif key == "dedicatedMasterCount":
            suggest = "dedicated_master_count"
        elif key == "dedicatedMasterEnabled":
            suggest = "dedicated_master_enabled"
        elif key == "dedicatedMasterType":
            suggest = "dedicated_master_type"
        elif key == "instanceCount":
            suggest = "instance_count"
        elif key == "instanceType":
            suggest = "instance_type"
        elif key == "multiAzWithStandbyEnabled":
            suggest = "multi_az_with_standby_enabled"
        elif key == "nodeOptions":
            suggest = "node_options"
        elif key == "warmCount":
            suggest = "warm_count"
        elif key == "warmEnabled":
            suggest = "warm_enabled"
        elif key == "warmType":
            suggest = "warm_type"
        elif key == "zoneAwarenessConfig":
            suggest = "zone_awareness_config"
        elif key == "zoneAwarenessEnabled":
            suggest = "zone_awareness_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainClusterConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainClusterConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainClusterConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cold_storage_options: Optional['outputs.DomainClusterConfigColdStorageOptions'] = None,
                 dedicated_master_count: Optional[_builtins.int] = None,
                 dedicated_master_enabled: Optional[_builtins.bool] = None,
                 dedicated_master_type: Optional[_builtins.str] = None,
                 instance_count: Optional[_builtins.int] = None,
                 instance_type: Optional[_builtins.str] = None,
                 multi_az_with_standby_enabled: Optional[_builtins.bool] = None,
                 node_options: Optional[Sequence['outputs.DomainClusterConfigNodeOption']] = None,
                 warm_count: Optional[_builtins.int] = None,
                 warm_enabled: Optional[_builtins.bool] = None,
                 warm_type: Optional[_builtins.str] = None,
                 zone_awareness_config: Optional['outputs.DomainClusterConfigZoneAwarenessConfig'] = None,
                 zone_awareness_enabled: Optional[_builtins.bool] = None):
        if cold_storage_options is not None:
            pulumi.set(__self__, "cold_storage_options", cold_storage_options)
        if dedicated_master_count is not None:
            pulumi.set(__self__, "dedicated_master_count", dedicated_master_count)
        if dedicated_master_enabled is not None:
            pulumi.set(__self__, "dedicated_master_enabled", dedicated_master_enabled)
        if dedicated_master_type is not None:
            pulumi.set(__self__, "dedicated_master_type", dedicated_master_type)
        if instance_count is not None:
            pulumi.set(__self__, "instance_count", instance_count)
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if multi_az_with_standby_enabled is not None:
            pulumi.set(__self__, "multi_az_with_standby_enabled", multi_az_with_standby_enabled)
        if node_options is not None:
            pulumi.set(__self__, "node_options", node_options)
        if warm_count is not None:
            pulumi.set(__self__, "warm_count", warm_count)
        if warm_enabled is not None:
            pulumi.set(__self__, "warm_enabled", warm_enabled)
        if warm_type is not None:
            pulumi.set(__self__, "warm_type", warm_type)
        if zone_awareness_config is not None:
            pulumi.set(__self__, "zone_awareness_config", zone_awareness_config)
        if zone_awareness_enabled is not None:
            pulumi.set(__self__, "zone_awareness_enabled", zone_awareness_enabled)

    @_builtins.property
    @pulumi.getter(name="coldStorageOptions")
    def cold_storage_options(self) -> Optional['outputs.DomainClusterConfigColdStorageOptions']:
        return pulumi.get(self, "cold_storage_options")

    @_builtins.property
    @pulumi.getter(name="dedicatedMasterCount")
    def dedicated_master_count(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "dedicated_master_count")

    @_builtins.property
    @pulumi.getter(name="dedicatedMasterEnabled")
    def dedicated_master_enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "dedicated_master_enabled")

    @_builtins.property
    @pulumi.getter(name="dedicatedMasterType")
    def dedicated_master_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "dedicated_master_type")

    @_builtins.property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "instance_count")

    @_builtins.property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "instance_type")

    @_builtins.property
    @pulumi.getter(name="multiAzWithStandbyEnabled")
    def multi_az_with_standby_enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "multi_az_with_standby_enabled")

    @_builtins.property
    @pulumi.getter(name="nodeOptions")
    def node_options(self) -> Optional[Sequence['outputs.DomainClusterConfigNodeOption']]:
        return pulumi.get(self, "node_options")

    @_builtins.property
    @pulumi.getter(name="warmCount")
    def warm_count(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "warm_count")

    @_builtins.property
    @pulumi.getter(name="warmEnabled")
    def warm_enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "warm_enabled")

    @_builtins.property
    @pulumi.getter(name="warmType")
    def warm_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "warm_type")

    @_builtins.property
    @pulumi.getter(name="zoneAwarenessConfig")
    def zone_awareness_config(self) -> Optional['outputs.DomainClusterConfigZoneAwarenessConfig']:
        return pulumi.get(self, "zone_awareness_config")

    @_builtins.property
    @pulumi.getter(name="zoneAwarenessEnabled")
    def zone_awareness_enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "zone_awareness_enabled")


@pulumi.output_type
class DomainClusterConfigColdStorageOptions(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class DomainClusterConfigNodeOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeConfig":
            suggest = "node_config"
        elif key == "nodeType":
            suggest = "node_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainClusterConfigNodeOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainClusterConfigNodeOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainClusterConfigNodeOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 node_config: Optional['outputs.DomainClusterConfigNodeOptionNodeConfig'] = None,
                 node_type: Optional[_builtins.str] = None):
        if node_config is not None:
            pulumi.set(__self__, "node_config", node_config)
        if node_type is not None:
            pulumi.set(__self__, "node_type", node_type)

    @_builtins.property
    @pulumi.getter(name="nodeConfig")
    def node_config(self) -> Optional['outputs.DomainClusterConfigNodeOptionNodeConfig']:
        return pulumi.get(self, "node_config")

    @_builtins.property
    @pulumi.getter(name="nodeType")
    def node_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "node_type")


@pulumi.output_type
class DomainClusterConfigNodeOptionNodeConfig(dict):
    def __init__(__self__, *,
                 count: Optional[_builtins.int] = None,
                 enabled: Optional[_builtins.bool] = None,
                 type: Optional[_builtins.str] = None):
        if count is not None:
            pulumi.set(__self__, "count", count)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def count(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "count")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class DomainClusterConfigZoneAwarenessConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZoneCount":
            suggest = "availability_zone_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainClusterConfigZoneAwarenessConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainClusterConfigZoneAwarenessConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainClusterConfigZoneAwarenessConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_zone_count: Optional[_builtins.int] = None):
        if availability_zone_count is not None:
            pulumi.set(__self__, "availability_zone_count", availability_zone_count)

    @_builtins.property
    @pulumi.getter(name="availabilityZoneCount")
    def availability_zone_count(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "availability_zone_count")


@pulumi.output_type
class DomainCognitoOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityPoolId":
            suggest = "identity_pool_id"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "userPoolId":
            suggest = "user_pool_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainCognitoOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainCognitoOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainCognitoOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_pool_id: _builtins.str,
                 role_arn: _builtins.str,
                 user_pool_id: _builtins.str,
                 enabled: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "identity_pool_id", identity_pool_id)
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "user_pool_id", user_pool_id)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter(name="identityPoolId")
    def identity_pool_id(self) -> _builtins.str:
        return pulumi.get(self, "identity_pool_id")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> _builtins.str:
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="userPoolId")
    def user_pool_id(self) -> _builtins.str:
        return pulumi.get(self, "user_pool_id")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class DomainDomainEndpointOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customEndpoint":
            suggest = "custom_endpoint"
        elif key == "customEndpointCertificateArn":
            suggest = "custom_endpoint_certificate_arn"
        elif key == "customEndpointEnabled":
            suggest = "custom_endpoint_enabled"
        elif key == "enforceHttps":
            suggest = "enforce_https"
        elif key == "tlsSecurityPolicy":
            suggest = "tls_security_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDomainEndpointOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDomainEndpointOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDomainEndpointOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_endpoint: Optional[_builtins.str] = None,
                 custom_endpoint_certificate_arn: Optional[_builtins.str] = None,
                 custom_endpoint_enabled: Optional[_builtins.bool] = None,
                 enforce_https: Optional[_builtins.bool] = None,
                 tls_security_policy: Optional[_builtins.str] = None):
        if custom_endpoint is not None:
            pulumi.set(__self__, "custom_endpoint", custom_endpoint)
        if custom_endpoint_certificate_arn is not None:
            pulumi.set(__self__, "custom_endpoint_certificate_arn", custom_endpoint_certificate_arn)
        if custom_endpoint_enabled is not None:
            pulumi.set(__self__, "custom_endpoint_enabled", custom_endpoint_enabled)
        if enforce_https is not None:
            pulumi.set(__self__, "enforce_https", enforce_https)
        if tls_security_policy is not None:
            pulumi.set(__self__, "tls_security_policy", tls_security_policy)

    @_builtins.property
    @pulumi.getter(name="customEndpoint")
    def custom_endpoint(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "custom_endpoint")

    @_builtins.property
    @pulumi.getter(name="customEndpointCertificateArn")
    def custom_endpoint_certificate_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "custom_endpoint_certificate_arn")

    @_builtins.property
    @pulumi.getter(name="customEndpointEnabled")
    def custom_endpoint_enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "custom_endpoint_enabled")

    @_builtins.property
    @pulumi.getter(name="enforceHttps")
    def enforce_https(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enforce_https")

    @_builtins.property
    @pulumi.getter(name="tlsSecurityPolicy")
    def tls_security_policy(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "tls_security_policy")


@pulumi.output_type
class DomainEbsOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ebsEnabled":
            suggest = "ebs_enabled"
        elif key == "volumeSize":
            suggest = "volume_size"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainEbsOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainEbsOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainEbsOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ebs_enabled: _builtins.bool,
                 iops: Optional[_builtins.int] = None,
                 throughput: Optional[_builtins.int] = None,
                 volume_size: Optional[_builtins.int] = None,
                 volume_type: Optional[_builtins.str] = None):
        pulumi.set(__self__, "ebs_enabled", ebs_enabled)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter(name="ebsEnabled")
    def ebs_enabled(self) -> _builtins.bool:
        return pulumi.get(self, "ebs_enabled")

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "iops")

    @_builtins.property
    @pulumi.getter
    def throughput(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "throughput")

    @_builtins.property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "volume_size")

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class DomainEncryptAtRest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kmsKeyId":
            suggest = "kms_key_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainEncryptAtRest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainEncryptAtRest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainEncryptAtRest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 kms_key_id: Optional[_builtins.str] = None):
        pulumi.set(__self__, "enabled", enabled)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "kms_key_id")


@pulumi.output_type
class DomainIdentityCenterOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enabledApiAccess":
            suggest = "enabled_api_access"
        elif key == "identityCenterInstanceArn":
            suggest = "identity_center_instance_arn"
        elif key == "rolesKey":
            suggest = "roles_key"
        elif key == "subjectKey":
            suggest = "subject_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainIdentityCenterOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainIdentityCenterOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainIdentityCenterOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled_api_access: Optional[_builtins.bool] = None,
                 identity_center_instance_arn: Optional[_builtins.str] = None,
                 roles_key: Optional[_builtins.str] = None,
                 subject_key: Optional[_builtins.str] = None):
        if enabled_api_access is not None:
            pulumi.set(__self__, "enabled_api_access", enabled_api_access)
        if identity_center_instance_arn is not None:
            pulumi.set(__self__, "identity_center_instance_arn", identity_center_instance_arn)
        if roles_key is not None:
            pulumi.set(__self__, "roles_key", roles_key)
        if subject_key is not None:
            pulumi.set(__self__, "subject_key", subject_key)

    @_builtins.property
    @pulumi.getter(name="enabledApiAccess")
    def enabled_api_access(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled_api_access")

    @_builtins.property
    @pulumi.getter(name="identityCenterInstanceArn")
    def identity_center_instance_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "identity_center_instance_arn")

    @_builtins.property
    @pulumi.getter(name="rolesKey")
    def roles_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "roles_key")

    @_builtins.property
    @pulumi.getter(name="subjectKey")
    def subject_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "subject_key")


@pulumi.output_type
class DomainLogPublishingOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudwatchLogGroupArn":
            suggest = "cloudwatch_log_group_arn"
        elif key == "logType":
            suggest = "log_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainLogPublishingOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainLogPublishingOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainLogPublishingOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloudwatch_log_group_arn: _builtins.str,
                 log_type: _builtins.str,
                 enabled: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "cloudwatch_log_group_arn", cloudwatch_log_group_arn)
        pulumi.set(__self__, "log_type", log_type)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter(name="cloudwatchLogGroupArn")
    def cloudwatch_log_group_arn(self) -> _builtins.str:
        return pulumi.get(self, "cloudwatch_log_group_arn")

    @_builtins.property
    @pulumi.getter(name="logType")
    def log_type(self) -> _builtins.str:
        return pulumi.get(self, "log_type")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class DomainNodeToNodeEncryption(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool):
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class DomainOffPeakWindowOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "offPeakWindow":
            suggest = "off_peak_window"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainOffPeakWindowOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainOffPeakWindowOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainOffPeakWindowOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 off_peak_window: Optional['outputs.DomainOffPeakWindowOptionsOffPeakWindow'] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if off_peak_window is not None:
            pulumi.set(__self__, "off_peak_window", off_peak_window)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="offPeakWindow")
    def off_peak_window(self) -> Optional['outputs.DomainOffPeakWindowOptionsOffPeakWindow']:
        return pulumi.get(self, "off_peak_window")


@pulumi.output_type
class DomainOffPeakWindowOptionsOffPeakWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "windowStartTime":
            suggest = "window_start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainOffPeakWindowOptionsOffPeakWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainOffPeakWindowOptionsOffPeakWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainOffPeakWindowOptionsOffPeakWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 window_start_time: Optional['outputs.DomainOffPeakWindowOptionsOffPeakWindowWindowStartTime'] = None):
        if window_start_time is not None:
            pulumi.set(__self__, "window_start_time", window_start_time)

    @_builtins.property
    @pulumi.getter(name="windowStartTime")
    def window_start_time(self) -> Optional['outputs.DomainOffPeakWindowOptionsOffPeakWindowWindowStartTime']:
        return pulumi.get(self, "window_start_time")


@pulumi.output_type
class DomainOffPeakWindowOptionsOffPeakWindowWindowStartTime(dict):
    def __init__(__self__, *,
                 hours: Optional[_builtins.int] = None,
                 minutes: Optional[_builtins.int] = None):
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)

    @_builtins.property
    @pulumi.getter
    def hours(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "hours")

    @_builtins.property
    @pulumi.getter
    def minutes(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "minutes")


@pulumi.output_type
class DomainSamlOptionsSamlOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "masterBackendRole":
            suggest = "master_backend_role"
        elif key == "masterUserName":
            suggest = "master_user_name"
        elif key == "rolesKey":
            suggest = "roles_key"
        elif key == "sessionTimeoutMinutes":
            suggest = "session_timeout_minutes"
        elif key == "subjectKey":
            suggest = "subject_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainSamlOptionsSamlOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainSamlOptionsSamlOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainSamlOptionsSamlOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 idp: Optional['outputs.DomainSamlOptionsSamlOptionsIdp'] = None,
                 master_backend_role: Optional[_builtins.str] = None,
                 master_user_name: Optional[_builtins.str] = None,
                 roles_key: Optional[_builtins.str] = None,
                 session_timeout_minutes: Optional[_builtins.int] = None,
                 subject_key: Optional[_builtins.str] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if idp is not None:
            pulumi.set(__self__, "idp", idp)
        if master_backend_role is not None:
            pulumi.set(__self__, "master_backend_role", master_backend_role)
        if master_user_name is not None:
            pulumi.set(__self__, "master_user_name", master_user_name)
        if roles_key is not None:
            pulumi.set(__self__, "roles_key", roles_key)
        if session_timeout_minutes is not None:
            pulumi.set(__self__, "session_timeout_minutes", session_timeout_minutes)
        if subject_key is not None:
            pulumi.set(__self__, "subject_key", subject_key)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def idp(self) -> Optional['outputs.DomainSamlOptionsSamlOptionsIdp']:
        return pulumi.get(self, "idp")

    @_builtins.property
    @pulumi.getter(name="masterBackendRole")
    def master_backend_role(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "master_backend_role")

    @_builtins.property
    @pulumi.getter(name="masterUserName")
    def master_user_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "master_user_name")

    @_builtins.property
    @pulumi.getter(name="rolesKey")
    def roles_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "roles_key")

    @_builtins.property
    @pulumi.getter(name="sessionTimeoutMinutes")
    def session_timeout_minutes(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "session_timeout_minutes")

    @_builtins.property
    @pulumi.getter(name="subjectKey")
    def subject_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "subject_key")


@pulumi.output_type
class DomainSamlOptionsSamlOptionsIdp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityId":
            suggest = "entity_id"
        elif key == "metadataContent":
            suggest = "metadata_content"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainSamlOptionsSamlOptionsIdp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainSamlOptionsSamlOptionsIdp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainSamlOptionsSamlOptionsIdp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_id: _builtins.str,
                 metadata_content: _builtins.str):
        pulumi.set(__self__, "entity_id", entity_id)
        pulumi.set(__self__, "metadata_content", metadata_content)

    @_builtins.property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> _builtins.str:
        return pulumi.get(self, "entity_id")

    @_builtins.property
    @pulumi.getter(name="metadataContent")
    def metadata_content(self) -> _builtins.str:
        return pulumi.get(self, "metadata_content")


@pulumi.output_type
class DomainSnapshotOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "automatedSnapshotStartHour":
            suggest = "automated_snapshot_start_hour"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainSnapshotOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainSnapshotOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainSnapshotOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 automated_snapshot_start_hour: _builtins.int):
        pulumi.set(__self__, "automated_snapshot_start_hour", automated_snapshot_start_hour)

    @_builtins.property
    @pulumi.getter(name="automatedSnapshotStartHour")
    def automated_snapshot_start_hour(self) -> _builtins.int:
        return pulumi.get(self, "automated_snapshot_start_hour")


@pulumi.output_type
class DomainSoftwareUpdateOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoSoftwareUpdateEnabled":
            suggest = "auto_software_update_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainSoftwareUpdateOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainSoftwareUpdateOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainSoftwareUpdateOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_software_update_enabled: Optional[_builtins.bool] = None):
        if auto_software_update_enabled is not None:
            pulumi.set(__self__, "auto_software_update_enabled", auto_software_update_enabled)

    @_builtins.property
    @pulumi.getter(name="autoSoftwareUpdateEnabled")
    def auto_software_update_enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "auto_software_update_enabled")


@pulumi.output_type
class DomainVpcOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZones":
            suggest = "availability_zones"
        elif key == "securityGroupIds":
            suggest = "security_group_ids"
        elif key == "subnetIds":
            suggest = "subnet_ids"
        elif key == "vpcId":
            suggest = "vpc_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainVpcOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainVpcOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainVpcOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_zones: Optional[Sequence[_builtins.str]] = None,
                 security_group_ids: Optional[Sequence[_builtins.str]] = None,
                 subnet_ids: Optional[Sequence[_builtins.str]] = None,
                 vpc_id: Optional[_builtins.str] = None):
        if availability_zones is not None:
            pulumi.set(__self__, "availability_zones", availability_zones)
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)
        if subnet_ids is not None:
            pulumi.set(__self__, "subnet_ids", subnet_ids)
        if vpc_id is not None:
            pulumi.set(__self__, "vpc_id", vpc_id)

    @_builtins.property
    @pulumi.getter(name="availabilityZones")
    def availability_zones(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "availability_zones")

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "security_group_ids")

    @_builtins.property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "subnet_ids")

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class OutboundConnectionConnectionProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "crossClusterSearch":
            suggest = "cross_cluster_search"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OutboundConnectionConnectionProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OutboundConnectionConnectionProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OutboundConnectionConnectionProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cross_cluster_search: Optional['outputs.OutboundConnectionConnectionPropertiesCrossClusterSearch'] = None,
                 endpoint: Optional[_builtins.str] = None):
        if cross_cluster_search is not None:
            pulumi.set(__self__, "cross_cluster_search", cross_cluster_search)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)

    @_builtins.property
    @pulumi.getter(name="crossClusterSearch")
    def cross_cluster_search(self) -> Optional['outputs.OutboundConnectionConnectionPropertiesCrossClusterSearch']:
        return pulumi.get(self, "cross_cluster_search")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "endpoint")


@pulumi.output_type
class OutboundConnectionConnectionPropertiesCrossClusterSearch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "skipUnavailable":
            suggest = "skip_unavailable"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OutboundConnectionConnectionPropertiesCrossClusterSearch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OutboundConnectionConnectionPropertiesCrossClusterSearch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OutboundConnectionConnectionPropertiesCrossClusterSearch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 skip_unavailable: Optional[_builtins.str] = None):
        if skip_unavailable is not None:
            pulumi.set(__self__, "skip_unavailable", skip_unavailable)

    @_builtins.property
    @pulumi.getter(name="skipUnavailable")
    def skip_unavailable(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "skip_unavailable")


@pulumi.output_type
class OutboundConnectionLocalDomainInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "domainName":
            suggest = "domain_name"
        elif key == "ownerId":
            suggest = "owner_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OutboundConnectionLocalDomainInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OutboundConnectionLocalDomainInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OutboundConnectionLocalDomainInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 domain_name: _builtins.str,
                 owner_id: _builtins.str,
                 region: _builtins.str):
        pulumi.set(__self__, "domain_name", domain_name)
        pulumi.set(__self__, "owner_id", owner_id)
        pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> _builtins.str:
        return pulumi.get(self, "domain_name")

    @_builtins.property
    @pulumi.getter(name="ownerId")
    def owner_id(self) -> _builtins.str:
        return pulumi.get(self, "owner_id")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        return pulumi.get(self, "region")


@pulumi.output_type
class OutboundConnectionRemoteDomainInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "domainName":
            suggest = "domain_name"
        elif key == "ownerId":
            suggest = "owner_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OutboundConnectionRemoteDomainInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OutboundConnectionRemoteDomainInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OutboundConnectionRemoteDomainInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 domain_name: _builtins.str,
                 owner_id: _builtins.str,
                 region: _builtins.str):
        pulumi.set(__self__, "domain_name", domain_name)
        pulumi.set(__self__, "owner_id", owner_id)
        pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> _builtins.str:
        return pulumi.get(self, "domain_name")

    @_builtins.property
    @pulumi.getter(name="ownerId")
    def owner_id(self) -> _builtins.str:
        return pulumi.get(self, "owner_id")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        return pulumi.get(self, "region")


@pulumi.output_type
class PackagePackageSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "s3BucketName":
            suggest = "s3_bucket_name"
        elif key == "s3Key":
            suggest = "s3_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PackagePackageSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PackagePackageSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PackagePackageSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 s3_bucket_name: _builtins.str,
                 s3_key: _builtins.str):
        pulumi.set(__self__, "s3_bucket_name", s3_bucket_name)
        pulumi.set(__self__, "s3_key", s3_key)

    @_builtins.property
    @pulumi.getter(name="s3BucketName")
    def s3_bucket_name(self) -> _builtins.str:
        return pulumi.get(self, "s3_bucket_name")

    @_builtins.property
    @pulumi.getter(name="s3Key")
    def s3_key(self) -> _builtins.str:
        return pulumi.get(self, "s3_key")


@pulumi.output_type
class ServerlessCollectionTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[_builtins.str] = None,
                 delete: Optional[_builtins.str] = None):
        """
        :param _builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param _builtins.str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")


@pulumi.output_type
class ServerlessSecurityConfigSamlOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupAttribute":
            suggest = "group_attribute"
        elif key == "sessionTimeout":
            suggest = "session_timeout"
        elif key == "userAttribute":
            suggest = "user_attribute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerlessSecurityConfigSamlOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerlessSecurityConfigSamlOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerlessSecurityConfigSamlOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metadata: _builtins.str,
                 group_attribute: Optional[_builtins.str] = None,
                 session_timeout: Optional[_builtins.int] = None,
                 user_attribute: Optional[_builtins.str] = None):
        """
        :param _builtins.str metadata: The XML IdP metadata file generated from your identity provider.
        :param _builtins.str group_attribute: Group attribute for this SAML integration.
        :param _builtins.int session_timeout: Session timeout, in minutes. Minimum is 5 minutes and maximum is 720 minutes (12 hours). Default is 60 minutes.
        :param _builtins.str user_attribute: User attribute for this SAML integration.
        """
        pulumi.set(__self__, "metadata", metadata)
        if group_attribute is not None:
            pulumi.set(__self__, "group_attribute", group_attribute)
        if session_timeout is not None:
            pulumi.set(__self__, "session_timeout", session_timeout)
        if user_attribute is not None:
            pulumi.set(__self__, "user_attribute", user_attribute)

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> _builtins.str:
        """
        The XML IdP metadata file generated from your identity provider.
        """
        return pulumi.get(self, "metadata")

    @_builtins.property
    @pulumi.getter(name="groupAttribute")
    def group_attribute(self) -> Optional[_builtins.str]:
        """
        Group attribute for this SAML integration.
        """
        return pulumi.get(self, "group_attribute")

    @_builtins.property
    @pulumi.getter(name="sessionTimeout")
    def session_timeout(self) -> Optional[_builtins.int]:
        """
        Session timeout, in minutes. Minimum is 5 minutes and maximum is 720 minutes (12 hours). Default is 60 minutes.
        """
        return pulumi.get(self, "session_timeout")

    @_builtins.property
    @pulumi.getter(name="userAttribute")
    def user_attribute(self) -> Optional[_builtins.str]:
        """
        User attribute for this SAML integration.
        """
        return pulumi.get(self, "user_attribute")


@pulumi.output_type
class ServerlessVpcEndpointTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[_builtins.str] = None,
                 delete: Optional[_builtins.str] = None,
                 update: Optional[_builtins.str] = None):
        """
        :param _builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param _builtins.str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param _builtins.str update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")


@pulumi.output_type
class VpcEndpointVpcOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetIds":
            suggest = "subnet_ids"
        elif key == "availabilityZones":
            suggest = "availability_zones"
        elif key == "securityGroupIds":
            suggest = "security_group_ids"
        elif key == "vpcId":
            suggest = "vpc_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcEndpointVpcOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcEndpointVpcOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcEndpointVpcOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subnet_ids: Sequence[_builtins.str],
                 availability_zones: Optional[Sequence[_builtins.str]] = None,
                 security_group_ids: Optional[Sequence[_builtins.str]] = None,
                 vpc_id: Optional[_builtins.str] = None):
        pulumi.set(__self__, "subnet_ids", subnet_ids)
        if availability_zones is not None:
            pulumi.set(__self__, "availability_zones", availability_zones)
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)
        if vpc_id is not None:
            pulumi.set(__self__, "vpc_id", vpc_id)

    @_builtins.property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "subnet_ids")

    @_builtins.property
    @pulumi.getter(name="availabilityZones")
    def availability_zones(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "availability_zones")

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "security_group_ids")

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class GetDomainAdvancedSecurityOptionResult(dict):
    def __init__(__self__, *,
                 anonymous_auth_enabled: _builtins.bool,
                 enabled: _builtins.bool,
                 internal_user_database_enabled: _builtins.bool):
        pulumi.set(__self__, "anonymous_auth_enabled", anonymous_auth_enabled)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "internal_user_database_enabled", internal_user_database_enabled)

    @_builtins.property
    @pulumi.getter(name="anonymousAuthEnabled")
    def anonymous_auth_enabled(self) -> _builtins.bool:
        return pulumi.get(self, "anonymous_auth_enabled")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="internalUserDatabaseEnabled")
    def internal_user_database_enabled(self) -> _builtins.bool:
        return pulumi.get(self, "internal_user_database_enabled")


@pulumi.output_type
class GetDomainAutoTuneOptionResult(dict):
    def __init__(__self__, *,
                 desired_state: _builtins.str,
                 maintenance_schedules: Sequence['outputs.GetDomainAutoTuneOptionMaintenanceScheduleResult'],
                 rollback_on_disable: _builtins.str,
                 use_off_peak_window: _builtins.bool):
        pulumi.set(__self__, "desired_state", desired_state)
        pulumi.set(__self__, "maintenance_schedules", maintenance_schedules)
        pulumi.set(__self__, "rollback_on_disable", rollback_on_disable)
        pulumi.set(__self__, "use_off_peak_window", use_off_peak_window)

    @_builtins.property
    @pulumi.getter(name="desiredState")
    def desired_state(self) -> _builtins.str:
        return pulumi.get(self, "desired_state")

    @_builtins.property
    @pulumi.getter(name="maintenanceSchedules")
    def maintenance_schedules(self) -> Sequence['outputs.GetDomainAutoTuneOptionMaintenanceScheduleResult']:
        return pulumi.get(self, "maintenance_schedules")

    @_builtins.property
    @pulumi.getter(name="rollbackOnDisable")
    def rollback_on_disable(self) -> _builtins.str:
        return pulumi.get(self, "rollback_on_disable")

    @_builtins.property
    @pulumi.getter(name="useOffPeakWindow")
    def use_off_peak_window(self) -> _builtins.bool:
        return pulumi.get(self, "use_off_peak_window")


@pulumi.output_type
class GetDomainAutoTuneOptionMaintenanceScheduleResult(dict):
    def __init__(__self__, *,
                 cron_expression_for_recurrence: _builtins.str,
                 durations: Sequence['outputs.GetDomainAutoTuneOptionMaintenanceScheduleDurationResult'],
                 start_at: _builtins.str):
        pulumi.set(__self__, "cron_expression_for_recurrence", cron_expression_for_recurrence)
        pulumi.set(__self__, "durations", durations)
        pulumi.set(__self__, "start_at", start_at)

    @_builtins.property
    @pulumi.getter(name="cronExpressionForRecurrence")
    def cron_expression_for_recurrence(self) -> _builtins.str:
        return pulumi.get(self, "cron_expression_for_recurrence")

    @_builtins.property
    @pulumi.getter
    def durations(self) -> Sequence['outputs.GetDomainAutoTuneOptionMaintenanceScheduleDurationResult']:
        return pulumi.get(self, "durations")

    @_builtins.property
    @pulumi.getter(name="startAt")
    def start_at(self) -> _builtins.str:
        return pulumi.get(self, "start_at")


@pulumi.output_type
class GetDomainAutoTuneOptionMaintenanceScheduleDurationResult(dict):
    def __init__(__self__, *,
                 unit: _builtins.str,
                 value: _builtins.int):
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def unit(self) -> _builtins.str:
        return pulumi.get(self, "unit")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.int:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetDomainClusterConfigResult(dict):
    def __init__(__self__, *,
                 cold_storage_options: Sequence['outputs.GetDomainClusterConfigColdStorageOptionResult'],
                 dedicated_master_count: _builtins.int,
                 dedicated_master_enabled: _builtins.bool,
                 dedicated_master_type: _builtins.str,
                 instance_count: _builtins.int,
                 instance_type: _builtins.str,
                 multi_az_with_standby_enabled: _builtins.bool,
                 node_options: Sequence['outputs.GetDomainClusterConfigNodeOptionResult'],
                 warm_count: _builtins.int,
                 warm_type: _builtins.str,
                 zone_awareness_configs: Sequence['outputs.GetDomainClusterConfigZoneAwarenessConfigResult'],
                 zone_awareness_enabled: _builtins.bool,
                 warm_enabled: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "cold_storage_options", cold_storage_options)
        pulumi.set(__self__, "dedicated_master_count", dedicated_master_count)
        pulumi.set(__self__, "dedicated_master_enabled", dedicated_master_enabled)
        pulumi.set(__self__, "dedicated_master_type", dedicated_master_type)
        pulumi.set(__self__, "instance_count", instance_count)
        pulumi.set(__self__, "instance_type", instance_type)
        pulumi.set(__self__, "multi_az_with_standby_enabled", multi_az_with_standby_enabled)
        pulumi.set(__self__, "node_options", node_options)
        pulumi.set(__self__, "warm_count", warm_count)
        pulumi.set(__self__, "warm_type", warm_type)
        pulumi.set(__self__, "zone_awareness_configs", zone_awareness_configs)
        pulumi.set(__self__, "zone_awareness_enabled", zone_awareness_enabled)
        if warm_enabled is not None:
            pulumi.set(__self__, "warm_enabled", warm_enabled)

    @_builtins.property
    @pulumi.getter(name="coldStorageOptions")
    def cold_storage_options(self) -> Sequence['outputs.GetDomainClusterConfigColdStorageOptionResult']:
        return pulumi.get(self, "cold_storage_options")

    @_builtins.property
    @pulumi.getter(name="dedicatedMasterCount")
    def dedicated_master_count(self) -> _builtins.int:
        return pulumi.get(self, "dedicated_master_count")

    @_builtins.property
    @pulumi.getter(name="dedicatedMasterEnabled")
    def dedicated_master_enabled(self) -> _builtins.bool:
        return pulumi.get(self, "dedicated_master_enabled")

    @_builtins.property
    @pulumi.getter(name="dedicatedMasterType")
    def dedicated_master_type(self) -> _builtins.str:
        return pulumi.get(self, "dedicated_master_type")

    @_builtins.property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> _builtins.int:
        return pulumi.get(self, "instance_count")

    @_builtins.property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> _builtins.str:
        return pulumi.get(self, "instance_type")

    @_builtins.property
    @pulumi.getter(name="multiAzWithStandbyEnabled")
    def multi_az_with_standby_enabled(self) -> _builtins.bool:
        return pulumi.get(self, "multi_az_with_standby_enabled")

    @_builtins.property
    @pulumi.getter(name="nodeOptions")
    def node_options(self) -> Sequence['outputs.GetDomainClusterConfigNodeOptionResult']:
        return pulumi.get(self, "node_options")

    @_builtins.property
    @pulumi.getter(name="warmCount")
    def warm_count(self) -> _builtins.int:
        return pulumi.get(self, "warm_count")

    @_builtins.property
    @pulumi.getter(name="warmType")
    def warm_type(self) -> _builtins.str:
        return pulumi.get(self, "warm_type")

    @_builtins.property
    @pulumi.getter(name="zoneAwarenessConfigs")
    def zone_awareness_configs(self) -> Sequence['outputs.GetDomainClusterConfigZoneAwarenessConfigResult']:
        return pulumi.get(self, "zone_awareness_configs")

    @_builtins.property
    @pulumi.getter(name="zoneAwarenessEnabled")
    def zone_awareness_enabled(self) -> _builtins.bool:
        return pulumi.get(self, "zone_awareness_enabled")

    @_builtins.property
    @pulumi.getter(name="warmEnabled")
    def warm_enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "warm_enabled")


@pulumi.output_type
class GetDomainClusterConfigColdStorageOptionResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool):
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetDomainClusterConfigNodeOptionResult(dict):
    def __init__(__self__, *,
                 node_configs: Sequence['outputs.GetDomainClusterConfigNodeOptionNodeConfigResult'],
                 node_type: _builtins.str):
        pulumi.set(__self__, "node_configs", node_configs)
        pulumi.set(__self__, "node_type", node_type)

    @_builtins.property
    @pulumi.getter(name="nodeConfigs")
    def node_configs(self) -> Sequence['outputs.GetDomainClusterConfigNodeOptionNodeConfigResult']:
        return pulumi.get(self, "node_configs")

    @_builtins.property
    @pulumi.getter(name="nodeType")
    def node_type(self) -> _builtins.str:
        return pulumi.get(self, "node_type")


@pulumi.output_type
class GetDomainClusterConfigNodeOptionNodeConfigResult(dict):
    def __init__(__self__, *,
                 count: _builtins.int,
                 enabled: _builtins.bool,
                 type: _builtins.str):
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def count(self) -> _builtins.int:
        return pulumi.get(self, "count")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetDomainClusterConfigZoneAwarenessConfigResult(dict):
    def __init__(__self__, *,
                 availability_zone_count: _builtins.int):
        pulumi.set(__self__, "availability_zone_count", availability_zone_count)

    @_builtins.property
    @pulumi.getter(name="availabilityZoneCount")
    def availability_zone_count(self) -> _builtins.int:
        return pulumi.get(self, "availability_zone_count")


@pulumi.output_type
class GetDomainCognitoOptionResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 identity_pool_id: _builtins.str,
                 role_arn: _builtins.str,
                 user_pool_id: _builtins.str):
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "identity_pool_id", identity_pool_id)
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "user_pool_id", user_pool_id)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="identityPoolId")
    def identity_pool_id(self) -> _builtins.str:
        return pulumi.get(self, "identity_pool_id")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> _builtins.str:
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="userPoolId")
    def user_pool_id(self) -> _builtins.str:
        return pulumi.get(self, "user_pool_id")


@pulumi.output_type
class GetDomainEbsOptionResult(dict):
    def __init__(__self__, *,
                 ebs_enabled: _builtins.bool,
                 iops: _builtins.int,
                 throughput: _builtins.int,
                 volume_size: _builtins.int,
                 volume_type: _builtins.str):
        pulumi.set(__self__, "ebs_enabled", ebs_enabled)
        pulumi.set(__self__, "iops", iops)
        pulumi.set(__self__, "throughput", throughput)
        pulumi.set(__self__, "volume_size", volume_size)
        pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter(name="ebsEnabled")
    def ebs_enabled(self) -> _builtins.bool:
        return pulumi.get(self, "ebs_enabled")

    @_builtins.property
    @pulumi.getter
    def iops(self) -> _builtins.int:
        return pulumi.get(self, "iops")

    @_builtins.property
    @pulumi.getter
    def throughput(self) -> _builtins.int:
        return pulumi.get(self, "throughput")

    @_builtins.property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> _builtins.int:
        return pulumi.get(self, "volume_size")

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> _builtins.str:
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class GetDomainEncryptionAtRestResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 kms_key_id: _builtins.str):
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "kms_key_id", kms_key_id)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> _builtins.str:
        return pulumi.get(self, "kms_key_id")


@pulumi.output_type
class GetDomainIdentityCenterOptionResult(dict):
    def __init__(__self__, *,
                 enabled_api_access: _builtins.bool,
                 identity_center_instance_arn: _builtins.str,
                 roles_key: _builtins.str,
                 subject_key: _builtins.str):
        pulumi.set(__self__, "enabled_api_access", enabled_api_access)
        pulumi.set(__self__, "identity_center_instance_arn", identity_center_instance_arn)
        pulumi.set(__self__, "roles_key", roles_key)
        pulumi.set(__self__, "subject_key", subject_key)

    @_builtins.property
    @pulumi.getter(name="enabledApiAccess")
    def enabled_api_access(self) -> _builtins.bool:
        return pulumi.get(self, "enabled_api_access")

    @_builtins.property
    @pulumi.getter(name="identityCenterInstanceArn")
    def identity_center_instance_arn(self) -> _builtins.str:
        return pulumi.get(self, "identity_center_instance_arn")

    @_builtins.property
    @pulumi.getter(name="rolesKey")
    def roles_key(self) -> _builtins.str:
        return pulumi.get(self, "roles_key")

    @_builtins.property
    @pulumi.getter(name="subjectKey")
    def subject_key(self) -> _builtins.str:
        return pulumi.get(self, "subject_key")


@pulumi.output_type
class GetDomainLogPublishingOptionResult(dict):
    def __init__(__self__, *,
                 cloudwatch_log_group_arn: _builtins.str,
                 enabled: _builtins.bool,
                 log_type: _builtins.str):
        pulumi.set(__self__, "cloudwatch_log_group_arn", cloudwatch_log_group_arn)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "log_type", log_type)

    @_builtins.property
    @pulumi.getter(name="cloudwatchLogGroupArn")
    def cloudwatch_log_group_arn(self) -> _builtins.str:
        return pulumi.get(self, "cloudwatch_log_group_arn")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="logType")
    def log_type(self) -> _builtins.str:
        return pulumi.get(self, "log_type")


@pulumi.output_type
class GetDomainNodeToNodeEncryptionResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool):
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetDomainOffPeakWindowOptionsResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 off_peak_windows: Sequence['outputs.GetDomainOffPeakWindowOptionsOffPeakWindowResult']):
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "off_peak_windows", off_peak_windows)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="offPeakWindows")
    def off_peak_windows(self) -> Sequence['outputs.GetDomainOffPeakWindowOptionsOffPeakWindowResult']:
        return pulumi.get(self, "off_peak_windows")


@pulumi.output_type
class GetDomainOffPeakWindowOptionsOffPeakWindowResult(dict):
    def __init__(__self__, *,
                 window_start_times: Sequence['outputs.GetDomainOffPeakWindowOptionsOffPeakWindowWindowStartTimeResult']):
        pulumi.set(__self__, "window_start_times", window_start_times)

    @_builtins.property
    @pulumi.getter(name="windowStartTimes")
    def window_start_times(self) -> Sequence['outputs.GetDomainOffPeakWindowOptionsOffPeakWindowWindowStartTimeResult']:
        return pulumi.get(self, "window_start_times")


@pulumi.output_type
class GetDomainOffPeakWindowOptionsOffPeakWindowWindowStartTimeResult(dict):
    def __init__(__self__, *,
                 hours: _builtins.int,
                 minutes: _builtins.int):
        pulumi.set(__self__, "hours", hours)
        pulumi.set(__self__, "minutes", minutes)

    @_builtins.property
    @pulumi.getter
    def hours(self) -> _builtins.int:
        return pulumi.get(self, "hours")

    @_builtins.property
    @pulumi.getter
    def minutes(self) -> _builtins.int:
        return pulumi.get(self, "minutes")


@pulumi.output_type
class GetDomainSnapshotOptionResult(dict):
    def __init__(__self__, *,
                 automated_snapshot_start_hour: _builtins.int):
        pulumi.set(__self__, "automated_snapshot_start_hour", automated_snapshot_start_hour)

    @_builtins.property
    @pulumi.getter(name="automatedSnapshotStartHour")
    def automated_snapshot_start_hour(self) -> _builtins.int:
        return pulumi.get(self, "automated_snapshot_start_hour")


@pulumi.output_type
class GetDomainSoftwareUpdateOptionResult(dict):
    def __init__(__self__, *,
                 auto_software_update_enabled: _builtins.bool):
        pulumi.set(__self__, "auto_software_update_enabled", auto_software_update_enabled)

    @_builtins.property
    @pulumi.getter(name="autoSoftwareUpdateEnabled")
    def auto_software_update_enabled(self) -> _builtins.bool:
        return pulumi.get(self, "auto_software_update_enabled")


@pulumi.output_type
class GetDomainVpcOptionResult(dict):
    def __init__(__self__, *,
                 availability_zones: Sequence[_builtins.str],
                 security_group_ids: Sequence[_builtins.str],
                 subnet_ids: Sequence[_builtins.str],
                 vpc_id: _builtins.str):
        pulumi.set(__self__, "availability_zones", availability_zones)
        pulumi.set(__self__, "security_group_ids", security_group_ids)
        pulumi.set(__self__, "subnet_ids", subnet_ids)
        pulumi.set(__self__, "vpc_id", vpc_id)

    @_builtins.property
    @pulumi.getter(name="availabilityZones")
    def availability_zones(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "availability_zones")

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "security_group_ids")

    @_builtins.property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "subnet_ids")

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> _builtins.str:
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class GetServerlessSecurityConfigSamlOptionResult(dict):
    def __init__(__self__, *,
                 group_attribute: _builtins.str,
                 metadata: _builtins.str,
                 session_timeout: _builtins.int,
                 user_attribute: _builtins.str):
        """
        :param _builtins.str group_attribute: Group attribute for this SAML integration.
        :param _builtins.str metadata: The XML IdP metadata file generated from your identity provider.
        :param _builtins.int session_timeout: Session timeout, in minutes. Minimum is 5 minutes and maximum is 720 minutes (12 hours). Default is 60 minutes.
        :param _builtins.str user_attribute: User attribute for this SAML integration.
        """
        pulumi.set(__self__, "group_attribute", group_attribute)
        pulumi.set(__self__, "metadata", metadata)
        pulumi.set(__self__, "session_timeout", session_timeout)
        pulumi.set(__self__, "user_attribute", user_attribute)

    @_builtins.property
    @pulumi.getter(name="groupAttribute")
    def group_attribute(self) -> _builtins.str:
        """
        Group attribute for this SAML integration.
        """
        return pulumi.get(self, "group_attribute")

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> _builtins.str:
        """
        The XML IdP metadata file generated from your identity provider.
        """
        return pulumi.get(self, "metadata")

    @_builtins.property
    @pulumi.getter(name="sessionTimeout")
    def session_timeout(self) -> _builtins.int:
        """
        Session timeout, in minutes. Minimum is 5 minutes and maximum is 720 minutes (12 hours). Default is 60 minutes.
        """
        return pulumi.get(self, "session_timeout")

    @_builtins.property
    @pulumi.getter(name="userAttribute")
    def user_attribute(self) -> _builtins.str:
        """
        User attribute for this SAML integration.
        """
        return pulumi.get(self, "user_attribute")


