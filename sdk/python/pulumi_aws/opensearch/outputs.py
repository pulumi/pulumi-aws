# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'DomainAdvancedSecurityOptions',
    'DomainAdvancedSecurityOptionsMasterUserOptions',
    'DomainAutoTuneOptions',
    'DomainAutoTuneOptionsMaintenanceSchedule',
    'DomainAutoTuneOptionsMaintenanceScheduleDuration',
    'DomainClusterConfig',
    'DomainClusterConfigColdStorageOptions',
    'DomainClusterConfigZoneAwarenessConfig',
    'DomainCognitoOptions',
    'DomainDomainEndpointOptions',
    'DomainEbsOptions',
    'DomainEncryptAtRest',
    'DomainLogPublishingOption',
    'DomainNodeToNodeEncryption',
    'DomainOffPeakWindowOptions',
    'DomainOffPeakWindowOptionsOffPeakWindow',
    'DomainOffPeakWindowOptionsOffPeakWindowWindowStartTime',
    'DomainSamlOptionsSamlOptions',
    'DomainSamlOptionsSamlOptionsIdp',
    'DomainSnapshotOptions',
    'DomainSoftwareUpdateOptions',
    'DomainVpcOptions',
    'OutboundConnectionConnectionProperties',
    'OutboundConnectionConnectionPropertiesCrossClusterSearch',
    'OutboundConnectionLocalDomainInfo',
    'OutboundConnectionRemoteDomainInfo',
    'PackagePackageSource',
    'ServerlessCollectionTimeouts',
    'ServerlessSecurityConfigSamlOptions',
    'ServerlessVpcEndpointTimeouts',
    'VpcEndpointVpcOptions',
    'GetDomainAdvancedSecurityOptionResult',
    'GetDomainAutoTuneOptionResult',
    'GetDomainAutoTuneOptionMaintenanceScheduleResult',
    'GetDomainAutoTuneOptionMaintenanceScheduleDurationResult',
    'GetDomainClusterConfigResult',
    'GetDomainClusterConfigColdStorageOptionResult',
    'GetDomainClusterConfigZoneAwarenessConfigResult',
    'GetDomainCognitoOptionResult',
    'GetDomainEbsOptionResult',
    'GetDomainEncryptionAtRestResult',
    'GetDomainLogPublishingOptionResult',
    'GetDomainNodeToNodeEncryptionResult',
    'GetDomainOffPeakWindowOptionsResult',
    'GetDomainOffPeakWindowOptionsOffPeakWindowResult',
    'GetDomainOffPeakWindowOptionsOffPeakWindowWindowStartTimeResult',
    'GetDomainSnapshotOptionResult',
    'GetDomainSoftwareUpdateOptionResult',
    'GetDomainVpcOptionResult',
    'GetServerlessSecurityConfigSamlOptionsResult',
]

@pulumi.output_type
class DomainAdvancedSecurityOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anonymousAuthEnabled":
            suggest = "anonymous_auth_enabled"
        elif key == "internalUserDatabaseEnabled":
            suggest = "internal_user_database_enabled"
        elif key == "masterUserOptions":
            suggest = "master_user_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainAdvancedSecurityOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainAdvancedSecurityOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainAdvancedSecurityOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 anonymous_auth_enabled: Optional[bool] = None,
                 internal_user_database_enabled: Optional[bool] = None,
                 master_user_options: Optional['outputs.DomainAdvancedSecurityOptionsMasterUserOptions'] = None):
        """
        :param bool enabled: Whether advanced security is enabled.
        :param bool anonymous_auth_enabled: Whether Anonymous auth is enabled. Enables fine-grained access control on an existing domain. Ignored unless `advanced_security_options` are enabled. _Can only be enabled on an existing domain._
        :param bool internal_user_database_enabled: Whether the internal user database is enabled. Default is `false`.
        :param 'DomainAdvancedSecurityOptionsMasterUserOptionsArgs' master_user_options: Configuration block for the main user. Detailed below.
        """
        DomainAdvancedSecurityOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            anonymous_auth_enabled=anonymous_auth_enabled,
            internal_user_database_enabled=internal_user_database_enabled,
            master_user_options=master_user_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[bool] = None,
             anonymous_auth_enabled: Optional[bool] = None,
             internal_user_database_enabled: Optional[bool] = None,
             master_user_options: Optional['outputs.DomainAdvancedSecurityOptionsMasterUserOptions'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if enabled is None:
            raise TypeError("Missing 'enabled' argument")
        if anonymous_auth_enabled is None and 'anonymousAuthEnabled' in kwargs:
            anonymous_auth_enabled = kwargs['anonymousAuthEnabled']
        if internal_user_database_enabled is None and 'internalUserDatabaseEnabled' in kwargs:
            internal_user_database_enabled = kwargs['internalUserDatabaseEnabled']
        if master_user_options is None and 'masterUserOptions' in kwargs:
            master_user_options = kwargs['masterUserOptions']

        _setter("enabled", enabled)
        if anonymous_auth_enabled is not None:
            _setter("anonymous_auth_enabled", anonymous_auth_enabled)
        if internal_user_database_enabled is not None:
            _setter("internal_user_database_enabled", internal_user_database_enabled)
        if master_user_options is not None:
            _setter("master_user_options", master_user_options)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Whether advanced security is enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="anonymousAuthEnabled")
    def anonymous_auth_enabled(self) -> Optional[bool]:
        """
        Whether Anonymous auth is enabled. Enables fine-grained access control on an existing domain. Ignored unless `advanced_security_options` are enabled. _Can only be enabled on an existing domain._
        """
        return pulumi.get(self, "anonymous_auth_enabled")

    @property
    @pulumi.getter(name="internalUserDatabaseEnabled")
    def internal_user_database_enabled(self) -> Optional[bool]:
        """
        Whether the internal user database is enabled. Default is `false`.
        """
        return pulumi.get(self, "internal_user_database_enabled")

    @property
    @pulumi.getter(name="masterUserOptions")
    def master_user_options(self) -> Optional['outputs.DomainAdvancedSecurityOptionsMasterUserOptions']:
        """
        Configuration block for the main user. Detailed below.
        """
        return pulumi.get(self, "master_user_options")


@pulumi.output_type
class DomainAdvancedSecurityOptionsMasterUserOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "masterUserArn":
            suggest = "master_user_arn"
        elif key == "masterUserName":
            suggest = "master_user_name"
        elif key == "masterUserPassword":
            suggest = "master_user_password"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainAdvancedSecurityOptionsMasterUserOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainAdvancedSecurityOptionsMasterUserOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainAdvancedSecurityOptionsMasterUserOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 master_user_arn: Optional[str] = None,
                 master_user_name: Optional[str] = None,
                 master_user_password: Optional[str] = None):
        """
        :param str master_user_arn: ARN for the main user. Only specify if `internal_user_database_enabled` is not set or set to `false`.
        :param str master_user_name: Main user's username, which is stored in the Amazon OpenSearch Service domain's internal database. Only specify if `internal_user_database_enabled` is set to `true`.
        :param str master_user_password: Main user's password, which is stored in the Amazon OpenSearch Service domain's internal database. Only specify if `internal_user_database_enabled` is set to `true`.
        """
        DomainAdvancedSecurityOptionsMasterUserOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            master_user_arn=master_user_arn,
            master_user_name=master_user_name,
            master_user_password=master_user_password,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             master_user_arn: Optional[str] = None,
             master_user_name: Optional[str] = None,
             master_user_password: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if master_user_arn is None and 'masterUserArn' in kwargs:
            master_user_arn = kwargs['masterUserArn']
        if master_user_name is None and 'masterUserName' in kwargs:
            master_user_name = kwargs['masterUserName']
        if master_user_password is None and 'masterUserPassword' in kwargs:
            master_user_password = kwargs['masterUserPassword']

        if master_user_arn is not None:
            _setter("master_user_arn", master_user_arn)
        if master_user_name is not None:
            _setter("master_user_name", master_user_name)
        if master_user_password is not None:
            _setter("master_user_password", master_user_password)

    @property
    @pulumi.getter(name="masterUserArn")
    def master_user_arn(self) -> Optional[str]:
        """
        ARN for the main user. Only specify if `internal_user_database_enabled` is not set or set to `false`.
        """
        return pulumi.get(self, "master_user_arn")

    @property
    @pulumi.getter(name="masterUserName")
    def master_user_name(self) -> Optional[str]:
        """
        Main user's username, which is stored in the Amazon OpenSearch Service domain's internal database. Only specify if `internal_user_database_enabled` is set to `true`.
        """
        return pulumi.get(self, "master_user_name")

    @property
    @pulumi.getter(name="masterUserPassword")
    def master_user_password(self) -> Optional[str]:
        """
        Main user's password, which is stored in the Amazon OpenSearch Service domain's internal database. Only specify if `internal_user_database_enabled` is set to `true`.
        """
        return pulumi.get(self, "master_user_password")


@pulumi.output_type
class DomainAutoTuneOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "desiredState":
            suggest = "desired_state"
        elif key == "maintenanceSchedules":
            suggest = "maintenance_schedules"
        elif key == "rollbackOnDisable":
            suggest = "rollback_on_disable"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainAutoTuneOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainAutoTuneOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainAutoTuneOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 desired_state: str,
                 maintenance_schedules: Optional[Sequence['outputs.DomainAutoTuneOptionsMaintenanceSchedule']] = None,
                 rollback_on_disable: Optional[str] = None):
        """
        :param str desired_state: Auto-Tune desired state for the domain. Valid values: `ENABLED` or `DISABLED`.
        :param Sequence['DomainAutoTuneOptionsMaintenanceScheduleArgs'] maintenance_schedules: Configuration block for Auto-Tune maintenance windows. Can be specified multiple times for each maintenance window. Detailed below.
        :param str rollback_on_disable: Whether to roll back to default Auto-Tune settings when disabling Auto-Tune. Valid values: `DEFAULT_ROLLBACK` or `NO_ROLLBACK`.
        """
        DomainAutoTuneOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            desired_state=desired_state,
            maintenance_schedules=maintenance_schedules,
            rollback_on_disable=rollback_on_disable,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             desired_state: Optional[str] = None,
             maintenance_schedules: Optional[Sequence['outputs.DomainAutoTuneOptionsMaintenanceSchedule']] = None,
             rollback_on_disable: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if desired_state is None and 'desiredState' in kwargs:
            desired_state = kwargs['desiredState']
        if desired_state is None:
            raise TypeError("Missing 'desired_state' argument")
        if maintenance_schedules is None and 'maintenanceSchedules' in kwargs:
            maintenance_schedules = kwargs['maintenanceSchedules']
        if rollback_on_disable is None and 'rollbackOnDisable' in kwargs:
            rollback_on_disable = kwargs['rollbackOnDisable']

        _setter("desired_state", desired_state)
        if maintenance_schedules is not None:
            _setter("maintenance_schedules", maintenance_schedules)
        if rollback_on_disable is not None:
            _setter("rollback_on_disable", rollback_on_disable)

    @property
    @pulumi.getter(name="desiredState")
    def desired_state(self) -> str:
        """
        Auto-Tune desired state for the domain. Valid values: `ENABLED` or `DISABLED`.
        """
        return pulumi.get(self, "desired_state")

    @property
    @pulumi.getter(name="maintenanceSchedules")
    def maintenance_schedules(self) -> Optional[Sequence['outputs.DomainAutoTuneOptionsMaintenanceSchedule']]:
        """
        Configuration block for Auto-Tune maintenance windows. Can be specified multiple times for each maintenance window. Detailed below.
        """
        return pulumi.get(self, "maintenance_schedules")

    @property
    @pulumi.getter(name="rollbackOnDisable")
    def rollback_on_disable(self) -> Optional[str]:
        """
        Whether to roll back to default Auto-Tune settings when disabling Auto-Tune. Valid values: `DEFAULT_ROLLBACK` or `NO_ROLLBACK`.
        """
        return pulumi.get(self, "rollback_on_disable")


@pulumi.output_type
class DomainAutoTuneOptionsMaintenanceSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cronExpressionForRecurrence":
            suggest = "cron_expression_for_recurrence"
        elif key == "startAt":
            suggest = "start_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainAutoTuneOptionsMaintenanceSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainAutoTuneOptionsMaintenanceSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainAutoTuneOptionsMaintenanceSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cron_expression_for_recurrence: str,
                 duration: 'outputs.DomainAutoTuneOptionsMaintenanceScheduleDuration',
                 start_at: str):
        """
        :param str cron_expression_for_recurrence: A cron expression specifying the recurrence pattern for an Auto-Tune maintenance schedule.
        :param 'DomainAutoTuneOptionsMaintenanceScheduleDurationArgs' duration: Configuration block for the duration of the Auto-Tune maintenance window. Detailed below.
        :param str start_at: Date and time at which to start the Auto-Tune maintenance schedule in [RFC3339 format](https://tools.ietf.org/html/rfc3339#section-5.8).
        """
        DomainAutoTuneOptionsMaintenanceSchedule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cron_expression_for_recurrence=cron_expression_for_recurrence,
            duration=duration,
            start_at=start_at,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cron_expression_for_recurrence: Optional[str] = None,
             duration: Optional['outputs.DomainAutoTuneOptionsMaintenanceScheduleDuration'] = None,
             start_at: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cron_expression_for_recurrence is None and 'cronExpressionForRecurrence' in kwargs:
            cron_expression_for_recurrence = kwargs['cronExpressionForRecurrence']
        if cron_expression_for_recurrence is None:
            raise TypeError("Missing 'cron_expression_for_recurrence' argument")
        if duration is None:
            raise TypeError("Missing 'duration' argument")
        if start_at is None and 'startAt' in kwargs:
            start_at = kwargs['startAt']
        if start_at is None:
            raise TypeError("Missing 'start_at' argument")

        _setter("cron_expression_for_recurrence", cron_expression_for_recurrence)
        _setter("duration", duration)
        _setter("start_at", start_at)

    @property
    @pulumi.getter(name="cronExpressionForRecurrence")
    def cron_expression_for_recurrence(self) -> str:
        """
        A cron expression specifying the recurrence pattern for an Auto-Tune maintenance schedule.
        """
        return pulumi.get(self, "cron_expression_for_recurrence")

    @property
    @pulumi.getter
    def duration(self) -> 'outputs.DomainAutoTuneOptionsMaintenanceScheduleDuration':
        """
        Configuration block for the duration of the Auto-Tune maintenance window. Detailed below.
        """
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter(name="startAt")
    def start_at(self) -> str:
        """
        Date and time at which to start the Auto-Tune maintenance schedule in [RFC3339 format](https://tools.ietf.org/html/rfc3339#section-5.8).
        """
        return pulumi.get(self, "start_at")


@pulumi.output_type
class DomainAutoTuneOptionsMaintenanceScheduleDuration(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Unit of time specifying the duration of an Auto-Tune maintenance window. Valid values: `HOURS`.
        :param int value: An integer specifying the value of the duration of an Auto-Tune maintenance window.
        """
        DomainAutoTuneOptionsMaintenanceScheduleDuration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            unit=unit,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             unit: Optional[str] = None,
             value: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if unit is None:
            raise TypeError("Missing 'unit' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("unit", unit)
        _setter("value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Unit of time specifying the duration of an Auto-Tune maintenance window. Valid values: `HOURS`.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        An integer specifying the value of the duration of an Auto-Tune maintenance window.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DomainClusterConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "coldStorageOptions":
            suggest = "cold_storage_options"
        elif key == "dedicatedMasterCount":
            suggest = "dedicated_master_count"
        elif key == "dedicatedMasterEnabled":
            suggest = "dedicated_master_enabled"
        elif key == "dedicatedMasterType":
            suggest = "dedicated_master_type"
        elif key == "instanceCount":
            suggest = "instance_count"
        elif key == "instanceType":
            suggest = "instance_type"
        elif key == "multiAzWithStandbyEnabled":
            suggest = "multi_az_with_standby_enabled"
        elif key == "warmCount":
            suggest = "warm_count"
        elif key == "warmEnabled":
            suggest = "warm_enabled"
        elif key == "warmType":
            suggest = "warm_type"
        elif key == "zoneAwarenessConfig":
            suggest = "zone_awareness_config"
        elif key == "zoneAwarenessEnabled":
            suggest = "zone_awareness_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainClusterConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainClusterConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainClusterConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cold_storage_options: Optional['outputs.DomainClusterConfigColdStorageOptions'] = None,
                 dedicated_master_count: Optional[int] = None,
                 dedicated_master_enabled: Optional[bool] = None,
                 dedicated_master_type: Optional[str] = None,
                 instance_count: Optional[int] = None,
                 instance_type: Optional[str] = None,
                 multi_az_with_standby_enabled: Optional[bool] = None,
                 warm_count: Optional[int] = None,
                 warm_enabled: Optional[bool] = None,
                 warm_type: Optional[str] = None,
                 zone_awareness_config: Optional['outputs.DomainClusterConfigZoneAwarenessConfig'] = None,
                 zone_awareness_enabled: Optional[bool] = None):
        """
        :param 'DomainClusterConfigColdStorageOptionsArgs' cold_storage_options: Configuration block containing cold storage configuration. Detailed below.
        :param int dedicated_master_count: Number of dedicated main nodes in the cluster.
        :param bool dedicated_master_enabled: Whether dedicated main nodes are enabled for the cluster.
        :param str dedicated_master_type: Instance type of the dedicated main nodes in the cluster.
        :param int instance_count: Number of instances in the cluster.
        :param str instance_type: Instance type of data nodes in the cluster.
        :param int warm_count: Number of warm nodes in the cluster. Valid values are between `2` and `150`. `warm_count` can be only and must be set when `warm_enabled` is set to `true`.
        :param bool warm_enabled: Whether to enable warm storage.
        :param str warm_type: Instance type for the OpenSearch cluster's warm nodes. Valid values are `ultrawarm1.medium.search`, `ultrawarm1.large.search` and `ultrawarm1.xlarge.search`. `warm_type` can be only and must be set when `warm_enabled` is set to `true`.
        :param 'DomainClusterConfigZoneAwarenessConfigArgs' zone_awareness_config: Configuration block containing zone awareness settings. Detailed below.
        :param bool zone_awareness_enabled: Whether zone awareness is enabled, set to `true` for multi-az deployment. To enable awareness with three Availability Zones, the `availability_zone_count` within the `zone_awareness_config` must be set to `3`.
        """
        DomainClusterConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cold_storage_options=cold_storage_options,
            dedicated_master_count=dedicated_master_count,
            dedicated_master_enabled=dedicated_master_enabled,
            dedicated_master_type=dedicated_master_type,
            instance_count=instance_count,
            instance_type=instance_type,
            multi_az_with_standby_enabled=multi_az_with_standby_enabled,
            warm_count=warm_count,
            warm_enabled=warm_enabled,
            warm_type=warm_type,
            zone_awareness_config=zone_awareness_config,
            zone_awareness_enabled=zone_awareness_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cold_storage_options: Optional['outputs.DomainClusterConfigColdStorageOptions'] = None,
             dedicated_master_count: Optional[int] = None,
             dedicated_master_enabled: Optional[bool] = None,
             dedicated_master_type: Optional[str] = None,
             instance_count: Optional[int] = None,
             instance_type: Optional[str] = None,
             multi_az_with_standby_enabled: Optional[bool] = None,
             warm_count: Optional[int] = None,
             warm_enabled: Optional[bool] = None,
             warm_type: Optional[str] = None,
             zone_awareness_config: Optional['outputs.DomainClusterConfigZoneAwarenessConfig'] = None,
             zone_awareness_enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cold_storage_options is None and 'coldStorageOptions' in kwargs:
            cold_storage_options = kwargs['coldStorageOptions']
        if dedicated_master_count is None and 'dedicatedMasterCount' in kwargs:
            dedicated_master_count = kwargs['dedicatedMasterCount']
        if dedicated_master_enabled is None and 'dedicatedMasterEnabled' in kwargs:
            dedicated_master_enabled = kwargs['dedicatedMasterEnabled']
        if dedicated_master_type is None and 'dedicatedMasterType' in kwargs:
            dedicated_master_type = kwargs['dedicatedMasterType']
        if instance_count is None and 'instanceCount' in kwargs:
            instance_count = kwargs['instanceCount']
        if instance_type is None and 'instanceType' in kwargs:
            instance_type = kwargs['instanceType']
        if multi_az_with_standby_enabled is None and 'multiAzWithStandbyEnabled' in kwargs:
            multi_az_with_standby_enabled = kwargs['multiAzWithStandbyEnabled']
        if warm_count is None and 'warmCount' in kwargs:
            warm_count = kwargs['warmCount']
        if warm_enabled is None and 'warmEnabled' in kwargs:
            warm_enabled = kwargs['warmEnabled']
        if warm_type is None and 'warmType' in kwargs:
            warm_type = kwargs['warmType']
        if zone_awareness_config is None and 'zoneAwarenessConfig' in kwargs:
            zone_awareness_config = kwargs['zoneAwarenessConfig']
        if zone_awareness_enabled is None and 'zoneAwarenessEnabled' in kwargs:
            zone_awareness_enabled = kwargs['zoneAwarenessEnabled']

        if cold_storage_options is not None:
            _setter("cold_storage_options", cold_storage_options)
        if dedicated_master_count is not None:
            _setter("dedicated_master_count", dedicated_master_count)
        if dedicated_master_enabled is not None:
            _setter("dedicated_master_enabled", dedicated_master_enabled)
        if dedicated_master_type is not None:
            _setter("dedicated_master_type", dedicated_master_type)
        if instance_count is not None:
            _setter("instance_count", instance_count)
        if instance_type is not None:
            _setter("instance_type", instance_type)
        if multi_az_with_standby_enabled is not None:
            _setter("multi_az_with_standby_enabled", multi_az_with_standby_enabled)
        if warm_count is not None:
            _setter("warm_count", warm_count)
        if warm_enabled is not None:
            _setter("warm_enabled", warm_enabled)
        if warm_type is not None:
            _setter("warm_type", warm_type)
        if zone_awareness_config is not None:
            _setter("zone_awareness_config", zone_awareness_config)
        if zone_awareness_enabled is not None:
            _setter("zone_awareness_enabled", zone_awareness_enabled)

    @property
    @pulumi.getter(name="coldStorageOptions")
    def cold_storage_options(self) -> Optional['outputs.DomainClusterConfigColdStorageOptions']:
        """
        Configuration block containing cold storage configuration. Detailed below.
        """
        return pulumi.get(self, "cold_storage_options")

    @property
    @pulumi.getter(name="dedicatedMasterCount")
    def dedicated_master_count(self) -> Optional[int]:
        """
        Number of dedicated main nodes in the cluster.
        """
        return pulumi.get(self, "dedicated_master_count")

    @property
    @pulumi.getter(name="dedicatedMasterEnabled")
    def dedicated_master_enabled(self) -> Optional[bool]:
        """
        Whether dedicated main nodes are enabled for the cluster.
        """
        return pulumi.get(self, "dedicated_master_enabled")

    @property
    @pulumi.getter(name="dedicatedMasterType")
    def dedicated_master_type(self) -> Optional[str]:
        """
        Instance type of the dedicated main nodes in the cluster.
        """
        return pulumi.get(self, "dedicated_master_type")

    @property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> Optional[int]:
        """
        Number of instances in the cluster.
        """
        return pulumi.get(self, "instance_count")

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[str]:
        """
        Instance type of data nodes in the cluster.
        """
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter(name="multiAzWithStandbyEnabled")
    def multi_az_with_standby_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "multi_az_with_standby_enabled")

    @property
    @pulumi.getter(name="warmCount")
    def warm_count(self) -> Optional[int]:
        """
        Number of warm nodes in the cluster. Valid values are between `2` and `150`. `warm_count` can be only and must be set when `warm_enabled` is set to `true`.
        """
        return pulumi.get(self, "warm_count")

    @property
    @pulumi.getter(name="warmEnabled")
    def warm_enabled(self) -> Optional[bool]:
        """
        Whether to enable warm storage.
        """
        return pulumi.get(self, "warm_enabled")

    @property
    @pulumi.getter(name="warmType")
    def warm_type(self) -> Optional[str]:
        """
        Instance type for the OpenSearch cluster's warm nodes. Valid values are `ultrawarm1.medium.search`, `ultrawarm1.large.search` and `ultrawarm1.xlarge.search`. `warm_type` can be only and must be set when `warm_enabled` is set to `true`.
        """
        return pulumi.get(self, "warm_type")

    @property
    @pulumi.getter(name="zoneAwarenessConfig")
    def zone_awareness_config(self) -> Optional['outputs.DomainClusterConfigZoneAwarenessConfig']:
        """
        Configuration block containing zone awareness settings. Detailed below.
        """
        return pulumi.get(self, "zone_awareness_config")

    @property
    @pulumi.getter(name="zoneAwarenessEnabled")
    def zone_awareness_enabled(self) -> Optional[bool]:
        """
        Whether zone awareness is enabled, set to `true` for multi-az deployment. To enable awareness with three Availability Zones, the `availability_zone_count` within the `zone_awareness_config` must be set to `3`.
        """
        return pulumi.get(self, "zone_awareness_enabled")


@pulumi.output_type
class DomainClusterConfigColdStorageOptions(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        """
        :param bool enabled: Boolean to enable cold storage for an OpenSearch domain. Defaults to `false`. Master and ultrawarm nodes must be enabled for cold storage.
        """
        DomainClusterConfigColdStorageOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if enabled is not None:
            _setter("enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Boolean to enable cold storage for an OpenSearch domain. Defaults to `false`. Master and ultrawarm nodes must be enabled for cold storage.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class DomainClusterConfigZoneAwarenessConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZoneCount":
            suggest = "availability_zone_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainClusterConfigZoneAwarenessConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainClusterConfigZoneAwarenessConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainClusterConfigZoneAwarenessConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_zone_count: Optional[int] = None):
        """
        :param int availability_zone_count: Number of Availability Zones for the domain to use with `zone_awareness_enabled`. Defaults to `2`. Valid values: `2` or `3`.
        """
        DomainClusterConfigZoneAwarenessConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability_zone_count=availability_zone_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability_zone_count: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if availability_zone_count is None and 'availabilityZoneCount' in kwargs:
            availability_zone_count = kwargs['availabilityZoneCount']

        if availability_zone_count is not None:
            _setter("availability_zone_count", availability_zone_count)

    @property
    @pulumi.getter(name="availabilityZoneCount")
    def availability_zone_count(self) -> Optional[int]:
        """
        Number of Availability Zones for the domain to use with `zone_awareness_enabled`. Defaults to `2`. Valid values: `2` or `3`.
        """
        return pulumi.get(self, "availability_zone_count")


@pulumi.output_type
class DomainCognitoOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityPoolId":
            suggest = "identity_pool_id"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "userPoolId":
            suggest = "user_pool_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainCognitoOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainCognitoOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainCognitoOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_pool_id: str,
                 role_arn: str,
                 user_pool_id: str,
                 enabled: Optional[bool] = None):
        """
        :param str identity_pool_id: ID of the Cognito Identity Pool to use.
        :param str role_arn: ARN of the IAM role that has the AmazonOpenSearchServiceCognitoAccess policy attached.
        :param str user_pool_id: ID of the Cognito User Pool to use.
        :param bool enabled: Whether Amazon Cognito authentication with Dashboard is enabled or not. Default is `false`.
        """
        DomainCognitoOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            identity_pool_id=identity_pool_id,
            role_arn=role_arn,
            user_pool_id=user_pool_id,
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             identity_pool_id: Optional[str] = None,
             role_arn: Optional[str] = None,
             user_pool_id: Optional[str] = None,
             enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if identity_pool_id is None and 'identityPoolId' in kwargs:
            identity_pool_id = kwargs['identityPoolId']
        if identity_pool_id is None:
            raise TypeError("Missing 'identity_pool_id' argument")
        if role_arn is None and 'roleArn' in kwargs:
            role_arn = kwargs['roleArn']
        if role_arn is None:
            raise TypeError("Missing 'role_arn' argument")
        if user_pool_id is None and 'userPoolId' in kwargs:
            user_pool_id = kwargs['userPoolId']
        if user_pool_id is None:
            raise TypeError("Missing 'user_pool_id' argument")

        _setter("identity_pool_id", identity_pool_id)
        _setter("role_arn", role_arn)
        _setter("user_pool_id", user_pool_id)
        if enabled is not None:
            _setter("enabled", enabled)

    @property
    @pulumi.getter(name="identityPoolId")
    def identity_pool_id(self) -> str:
        """
        ID of the Cognito Identity Pool to use.
        """
        return pulumi.get(self, "identity_pool_id")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> str:
        """
        ARN of the IAM role that has the AmazonOpenSearchServiceCognitoAccess policy attached.
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="userPoolId")
    def user_pool_id(self) -> str:
        """
        ID of the Cognito User Pool to use.
        """
        return pulumi.get(self, "user_pool_id")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Whether Amazon Cognito authentication with Dashboard is enabled or not. Default is `false`.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class DomainDomainEndpointOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customEndpoint":
            suggest = "custom_endpoint"
        elif key == "customEndpointCertificateArn":
            suggest = "custom_endpoint_certificate_arn"
        elif key == "customEndpointEnabled":
            suggest = "custom_endpoint_enabled"
        elif key == "enforceHttps":
            suggest = "enforce_https"
        elif key == "tlsSecurityPolicy":
            suggest = "tls_security_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDomainEndpointOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDomainEndpointOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDomainEndpointOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_endpoint: Optional[str] = None,
                 custom_endpoint_certificate_arn: Optional[str] = None,
                 custom_endpoint_enabled: Optional[bool] = None,
                 enforce_https: Optional[bool] = None,
                 tls_security_policy: Optional[str] = None):
        """
        :param str custom_endpoint: Fully qualified domain for your custom endpoint.
        :param str custom_endpoint_certificate_arn: ACM certificate ARN for your custom endpoint.
        :param bool custom_endpoint_enabled: Whether to enable custom endpoint for the OpenSearch domain.
        :param bool enforce_https: Whether or not to require HTTPS. Defaults to `true`.
        :param str tls_security_policy: Name of the TLS security policy that needs to be applied to the HTTPS endpoint. Valid values:  `Policy-Min-TLS-1-0-2019-07` and `Policy-Min-TLS-1-2-2019-07`. The provider will only perform drift detection if a configuration value is provided.
        """
        DomainDomainEndpointOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_endpoint=custom_endpoint,
            custom_endpoint_certificate_arn=custom_endpoint_certificate_arn,
            custom_endpoint_enabled=custom_endpoint_enabled,
            enforce_https=enforce_https,
            tls_security_policy=tls_security_policy,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_endpoint: Optional[str] = None,
             custom_endpoint_certificate_arn: Optional[str] = None,
             custom_endpoint_enabled: Optional[bool] = None,
             enforce_https: Optional[bool] = None,
             tls_security_policy: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if custom_endpoint is None and 'customEndpoint' in kwargs:
            custom_endpoint = kwargs['customEndpoint']
        if custom_endpoint_certificate_arn is None and 'customEndpointCertificateArn' in kwargs:
            custom_endpoint_certificate_arn = kwargs['customEndpointCertificateArn']
        if custom_endpoint_enabled is None and 'customEndpointEnabled' in kwargs:
            custom_endpoint_enabled = kwargs['customEndpointEnabled']
        if enforce_https is None and 'enforceHttps' in kwargs:
            enforce_https = kwargs['enforceHttps']
        if tls_security_policy is None and 'tlsSecurityPolicy' in kwargs:
            tls_security_policy = kwargs['tlsSecurityPolicy']

        if custom_endpoint is not None:
            _setter("custom_endpoint", custom_endpoint)
        if custom_endpoint_certificate_arn is not None:
            _setter("custom_endpoint_certificate_arn", custom_endpoint_certificate_arn)
        if custom_endpoint_enabled is not None:
            _setter("custom_endpoint_enabled", custom_endpoint_enabled)
        if enforce_https is not None:
            _setter("enforce_https", enforce_https)
        if tls_security_policy is not None:
            _setter("tls_security_policy", tls_security_policy)

    @property
    @pulumi.getter(name="customEndpoint")
    def custom_endpoint(self) -> Optional[str]:
        """
        Fully qualified domain for your custom endpoint.
        """
        return pulumi.get(self, "custom_endpoint")

    @property
    @pulumi.getter(name="customEndpointCertificateArn")
    def custom_endpoint_certificate_arn(self) -> Optional[str]:
        """
        ACM certificate ARN for your custom endpoint.
        """
        return pulumi.get(self, "custom_endpoint_certificate_arn")

    @property
    @pulumi.getter(name="customEndpointEnabled")
    def custom_endpoint_enabled(self) -> Optional[bool]:
        """
        Whether to enable custom endpoint for the OpenSearch domain.
        """
        return pulumi.get(self, "custom_endpoint_enabled")

    @property
    @pulumi.getter(name="enforceHttps")
    def enforce_https(self) -> Optional[bool]:
        """
        Whether or not to require HTTPS. Defaults to `true`.
        """
        return pulumi.get(self, "enforce_https")

    @property
    @pulumi.getter(name="tlsSecurityPolicy")
    def tls_security_policy(self) -> Optional[str]:
        """
        Name of the TLS security policy that needs to be applied to the HTTPS endpoint. Valid values:  `Policy-Min-TLS-1-0-2019-07` and `Policy-Min-TLS-1-2-2019-07`. The provider will only perform drift detection if a configuration value is provided.
        """
        return pulumi.get(self, "tls_security_policy")


@pulumi.output_type
class DomainEbsOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ebsEnabled":
            suggest = "ebs_enabled"
        elif key == "volumeSize":
            suggest = "volume_size"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainEbsOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainEbsOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainEbsOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ebs_enabled: bool,
                 iops: Optional[int] = None,
                 throughput: Optional[int] = None,
                 volume_size: Optional[int] = None,
                 volume_type: Optional[str] = None):
        """
        :param bool ebs_enabled: Whether EBS volumes are attached to data nodes in the domain.
        :param int iops: Baseline input/output (I/O) performance of EBS volumes attached to data nodes. Applicable only for the GP3 and Provisioned IOPS EBS volume types.
        :param int throughput: Specifies the throughput (in MiB/s) of the EBS volumes attached to data nodes. Applicable only for the gp3 volume type.
        :param int volume_size: Size of EBS volumes attached to data nodes (in GiB).
        :param str volume_type: Type of EBS volumes attached to data nodes.
        """
        DomainEbsOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ebs_enabled=ebs_enabled,
            iops=iops,
            throughput=throughput,
            volume_size=volume_size,
            volume_type=volume_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ebs_enabled: Optional[bool] = None,
             iops: Optional[int] = None,
             throughput: Optional[int] = None,
             volume_size: Optional[int] = None,
             volume_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ebs_enabled is None and 'ebsEnabled' in kwargs:
            ebs_enabled = kwargs['ebsEnabled']
        if ebs_enabled is None:
            raise TypeError("Missing 'ebs_enabled' argument")
        if volume_size is None and 'volumeSize' in kwargs:
            volume_size = kwargs['volumeSize']
        if volume_type is None and 'volumeType' in kwargs:
            volume_type = kwargs['volumeType']

        _setter("ebs_enabled", ebs_enabled)
        if iops is not None:
            _setter("iops", iops)
        if throughput is not None:
            _setter("throughput", throughput)
        if volume_size is not None:
            _setter("volume_size", volume_size)
        if volume_type is not None:
            _setter("volume_type", volume_type)

    @property
    @pulumi.getter(name="ebsEnabled")
    def ebs_enabled(self) -> bool:
        """
        Whether EBS volumes are attached to data nodes in the domain.
        """
        return pulumi.get(self, "ebs_enabled")

    @property
    @pulumi.getter
    def iops(self) -> Optional[int]:
        """
        Baseline input/output (I/O) performance of EBS volumes attached to data nodes. Applicable only for the GP3 and Provisioned IOPS EBS volume types.
        """
        return pulumi.get(self, "iops")

    @property
    @pulumi.getter
    def throughput(self) -> Optional[int]:
        """
        Specifies the throughput (in MiB/s) of the EBS volumes attached to data nodes. Applicable only for the gp3 volume type.
        """
        return pulumi.get(self, "throughput")

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[int]:
        """
        Size of EBS volumes attached to data nodes (in GiB).
        """
        return pulumi.get(self, "volume_size")

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[str]:
        """
        Type of EBS volumes attached to data nodes.
        """
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class DomainEncryptAtRest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kmsKeyId":
            suggest = "kms_key_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainEncryptAtRest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainEncryptAtRest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainEncryptAtRest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 kms_key_id: Optional[str] = None):
        """
        :param bool enabled: Whether to enable encryption at rest. If the `encrypt_at_rest` block is not provided then this defaults to `false`. Enabling encryption on new domains requires an `engine_version` of `OpenSearch_X.Y` or `Elasticsearch_5.1` or greater.
        :param str kms_key_id: KMS key ARN to encrypt the Elasticsearch domain with. If not specified then it defaults to using the `aws/es` service KMS key. Note that KMS will accept a KMS key ID but will return the key ARN. To prevent the provider detecting unwanted changes, use the key ARN instead.
        """
        DomainEncryptAtRest._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            kms_key_id=kms_key_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[bool] = None,
             kms_key_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if enabled is None:
            raise TypeError("Missing 'enabled' argument")
        if kms_key_id is None and 'kmsKeyId' in kwargs:
            kms_key_id = kwargs['kmsKeyId']

        _setter("enabled", enabled)
        if kms_key_id is not None:
            _setter("kms_key_id", kms_key_id)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Whether to enable encryption at rest. If the `encrypt_at_rest` block is not provided then this defaults to `false`. Enabling encryption on new domains requires an `engine_version` of `OpenSearch_X.Y` or `Elasticsearch_5.1` or greater.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[str]:
        """
        KMS key ARN to encrypt the Elasticsearch domain with. If not specified then it defaults to using the `aws/es` service KMS key. Note that KMS will accept a KMS key ID but will return the key ARN. To prevent the provider detecting unwanted changes, use the key ARN instead.
        """
        return pulumi.get(self, "kms_key_id")


@pulumi.output_type
class DomainLogPublishingOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudwatchLogGroupArn":
            suggest = "cloudwatch_log_group_arn"
        elif key == "logType":
            suggest = "log_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainLogPublishingOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainLogPublishingOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainLogPublishingOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloudwatch_log_group_arn: str,
                 log_type: str,
                 enabled: Optional[bool] = None):
        """
        :param str cloudwatch_log_group_arn: ARN of the Cloudwatch log group to which log needs to be published.
        :param str log_type: Type of OpenSearch log. Valid values: `INDEX_SLOW_LOGS`, `SEARCH_SLOW_LOGS`, `ES_APPLICATION_LOGS`, `AUDIT_LOGS`.
        :param bool enabled: Whether given log publishing option is enabled or not.
        """
        DomainLogPublishingOption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloudwatch_log_group_arn=cloudwatch_log_group_arn,
            log_type=log_type,
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloudwatch_log_group_arn: Optional[str] = None,
             log_type: Optional[str] = None,
             enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cloudwatch_log_group_arn is None and 'cloudwatchLogGroupArn' in kwargs:
            cloudwatch_log_group_arn = kwargs['cloudwatchLogGroupArn']
        if cloudwatch_log_group_arn is None:
            raise TypeError("Missing 'cloudwatch_log_group_arn' argument")
        if log_type is None and 'logType' in kwargs:
            log_type = kwargs['logType']
        if log_type is None:
            raise TypeError("Missing 'log_type' argument")

        _setter("cloudwatch_log_group_arn", cloudwatch_log_group_arn)
        _setter("log_type", log_type)
        if enabled is not None:
            _setter("enabled", enabled)

    @property
    @pulumi.getter(name="cloudwatchLogGroupArn")
    def cloudwatch_log_group_arn(self) -> str:
        """
        ARN of the Cloudwatch log group to which log needs to be published.
        """
        return pulumi.get(self, "cloudwatch_log_group_arn")

    @property
    @pulumi.getter(name="logType")
    def log_type(self) -> str:
        """
        Type of OpenSearch log. Valid values: `INDEX_SLOW_LOGS`, `SEARCH_SLOW_LOGS`, `ES_APPLICATION_LOGS`, `AUDIT_LOGS`.
        """
        return pulumi.get(self, "log_type")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Whether given log publishing option is enabled or not.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class DomainNodeToNodeEncryption(dict):
    def __init__(__self__, *,
                 enabled: bool):
        """
        :param bool enabled: Whether to enable node-to-node encryption. If the `node_to_node_encryption` block is not provided then this defaults to `false`. Enabling node-to-node encryption of a new domain requires an `engine_version` of `OpenSearch_X.Y` or `Elasticsearch_6.0` or greater.
        """
        DomainNodeToNodeEncryption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if enabled is None:
            raise TypeError("Missing 'enabled' argument")

        _setter("enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Whether to enable node-to-node encryption. If the `node_to_node_encryption` block is not provided then this defaults to `false`. Enabling node-to-node encryption of a new domain requires an `engine_version` of `OpenSearch_X.Y` or `Elasticsearch_6.0` or greater.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class DomainOffPeakWindowOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "offPeakWindow":
            suggest = "off_peak_window"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainOffPeakWindowOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainOffPeakWindowOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainOffPeakWindowOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 off_peak_window: Optional['outputs.DomainOffPeakWindowOptionsOffPeakWindow'] = None):
        """
        :param bool enabled: Enabled disabled toggle for off-peak update window.
        """
        DomainOffPeakWindowOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            off_peak_window=off_peak_window,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[bool] = None,
             off_peak_window: Optional['outputs.DomainOffPeakWindowOptionsOffPeakWindow'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if off_peak_window is None and 'offPeakWindow' in kwargs:
            off_peak_window = kwargs['offPeakWindow']

        if enabled is not None:
            _setter("enabled", enabled)
        if off_peak_window is not None:
            _setter("off_peak_window", off_peak_window)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Enabled disabled toggle for off-peak update window.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="offPeakWindow")
    def off_peak_window(self) -> Optional['outputs.DomainOffPeakWindowOptionsOffPeakWindow']:
        return pulumi.get(self, "off_peak_window")


@pulumi.output_type
class DomainOffPeakWindowOptionsOffPeakWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "windowStartTime":
            suggest = "window_start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainOffPeakWindowOptionsOffPeakWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainOffPeakWindowOptionsOffPeakWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainOffPeakWindowOptionsOffPeakWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 window_start_time: Optional['outputs.DomainOffPeakWindowOptionsOffPeakWindowWindowStartTime'] = None):
        """
        :param 'DomainOffPeakWindowOptionsOffPeakWindowWindowStartTimeArgs' window_start_time: 10h window for updates
        """
        DomainOffPeakWindowOptionsOffPeakWindow._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            window_start_time=window_start_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             window_start_time: Optional['outputs.DomainOffPeakWindowOptionsOffPeakWindowWindowStartTime'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if window_start_time is None and 'windowStartTime' in kwargs:
            window_start_time = kwargs['windowStartTime']

        if window_start_time is not None:
            _setter("window_start_time", window_start_time)

    @property
    @pulumi.getter(name="windowStartTime")
    def window_start_time(self) -> Optional['outputs.DomainOffPeakWindowOptionsOffPeakWindowWindowStartTime']:
        """
        10h window for updates
        """
        return pulumi.get(self, "window_start_time")


@pulumi.output_type
class DomainOffPeakWindowOptionsOffPeakWindowWindowStartTime(dict):
    def __init__(__self__, *,
                 hours: Optional[int] = None,
                 minutes: Optional[int] = None):
        """
        :param int hours: Starting hour of the 10-hour window for updates
        :param int minutes: Starting minute of the 10-hour window for updates
        """
        DomainOffPeakWindowOptionsOffPeakWindowWindowStartTime._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            hours=hours,
            minutes=minutes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             hours: Optional[int] = None,
             minutes: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if hours is not None:
            _setter("hours", hours)
        if minutes is not None:
            _setter("minutes", minutes)

    @property
    @pulumi.getter
    def hours(self) -> Optional[int]:
        """
        Starting hour of the 10-hour window for updates
        """
        return pulumi.get(self, "hours")

    @property
    @pulumi.getter
    def minutes(self) -> Optional[int]:
        """
        Starting minute of the 10-hour window for updates
        """
        return pulumi.get(self, "minutes")


@pulumi.output_type
class DomainSamlOptionsSamlOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "masterBackendRole":
            suggest = "master_backend_role"
        elif key == "masterUserName":
            suggest = "master_user_name"
        elif key == "rolesKey":
            suggest = "roles_key"
        elif key == "sessionTimeoutMinutes":
            suggest = "session_timeout_minutes"
        elif key == "subjectKey":
            suggest = "subject_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainSamlOptionsSamlOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainSamlOptionsSamlOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainSamlOptionsSamlOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 idp: Optional['outputs.DomainSamlOptionsSamlOptionsIdp'] = None,
                 master_backend_role: Optional[str] = None,
                 master_user_name: Optional[str] = None,
                 roles_key: Optional[str] = None,
                 session_timeout_minutes: Optional[int] = None,
                 subject_key: Optional[str] = None):
        """
        :param bool enabled: Whether SAML authentication is enabled.
        :param 'DomainSamlOptionsSamlOptionsIdpArgs' idp: Information from your identity provider.
        :param str master_backend_role: This backend role from the SAML IdP receives full permissions to the cluster, equivalent to a new master user.
        :param str master_user_name: This username from the SAML IdP receives full permissions to the cluster, equivalent to a new master user.
        :param str roles_key: Element of the SAML assertion to use for backend roles. Default is roles.
        :param int session_timeout_minutes: Duration of a session in minutes after a user logs in. Default is 60. Maximum value is 1,440.
        :param str subject_key: Element of the SAML assertion to use for username. Default is NameID.
        """
        DomainSamlOptionsSamlOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            idp=idp,
            master_backend_role=master_backend_role,
            master_user_name=master_user_name,
            roles_key=roles_key,
            session_timeout_minutes=session_timeout_minutes,
            subject_key=subject_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[bool] = None,
             idp: Optional['outputs.DomainSamlOptionsSamlOptionsIdp'] = None,
             master_backend_role: Optional[str] = None,
             master_user_name: Optional[str] = None,
             roles_key: Optional[str] = None,
             session_timeout_minutes: Optional[int] = None,
             subject_key: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if master_backend_role is None and 'masterBackendRole' in kwargs:
            master_backend_role = kwargs['masterBackendRole']
        if master_user_name is None and 'masterUserName' in kwargs:
            master_user_name = kwargs['masterUserName']
        if roles_key is None and 'rolesKey' in kwargs:
            roles_key = kwargs['rolesKey']
        if session_timeout_minutes is None and 'sessionTimeoutMinutes' in kwargs:
            session_timeout_minutes = kwargs['sessionTimeoutMinutes']
        if subject_key is None and 'subjectKey' in kwargs:
            subject_key = kwargs['subjectKey']

        if enabled is not None:
            _setter("enabled", enabled)
        if idp is not None:
            _setter("idp", idp)
        if master_backend_role is not None:
            _setter("master_backend_role", master_backend_role)
        if master_user_name is not None:
            _setter("master_user_name", master_user_name)
        if roles_key is not None:
            _setter("roles_key", roles_key)
        if session_timeout_minutes is not None:
            _setter("session_timeout_minutes", session_timeout_minutes)
        if subject_key is not None:
            _setter("subject_key", subject_key)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Whether SAML authentication is enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def idp(self) -> Optional['outputs.DomainSamlOptionsSamlOptionsIdp']:
        """
        Information from your identity provider.
        """
        return pulumi.get(self, "idp")

    @property
    @pulumi.getter(name="masterBackendRole")
    def master_backend_role(self) -> Optional[str]:
        """
        This backend role from the SAML IdP receives full permissions to the cluster, equivalent to a new master user.
        """
        return pulumi.get(self, "master_backend_role")

    @property
    @pulumi.getter(name="masterUserName")
    def master_user_name(self) -> Optional[str]:
        """
        This username from the SAML IdP receives full permissions to the cluster, equivalent to a new master user.
        """
        return pulumi.get(self, "master_user_name")

    @property
    @pulumi.getter(name="rolesKey")
    def roles_key(self) -> Optional[str]:
        """
        Element of the SAML assertion to use for backend roles. Default is roles.
        """
        return pulumi.get(self, "roles_key")

    @property
    @pulumi.getter(name="sessionTimeoutMinutes")
    def session_timeout_minutes(self) -> Optional[int]:
        """
        Duration of a session in minutes after a user logs in. Default is 60. Maximum value is 1,440.
        """
        return pulumi.get(self, "session_timeout_minutes")

    @property
    @pulumi.getter(name="subjectKey")
    def subject_key(self) -> Optional[str]:
        """
        Element of the SAML assertion to use for username. Default is NameID.
        """
        return pulumi.get(self, "subject_key")


@pulumi.output_type
class DomainSamlOptionsSamlOptionsIdp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityId":
            suggest = "entity_id"
        elif key == "metadataContent":
            suggest = "metadata_content"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainSamlOptionsSamlOptionsIdp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainSamlOptionsSamlOptionsIdp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainSamlOptionsSamlOptionsIdp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_id: str,
                 metadata_content: str):
        """
        :param str entity_id: Unique Entity ID of the application in SAML Identity Provider.
        :param str metadata_content: Metadata of the SAML application in xml format.
        """
        DomainSamlOptionsSamlOptionsIdp._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            entity_id=entity_id,
            metadata_content=metadata_content,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             entity_id: Optional[str] = None,
             metadata_content: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if entity_id is None and 'entityId' in kwargs:
            entity_id = kwargs['entityId']
        if entity_id is None:
            raise TypeError("Missing 'entity_id' argument")
        if metadata_content is None and 'metadataContent' in kwargs:
            metadata_content = kwargs['metadataContent']
        if metadata_content is None:
            raise TypeError("Missing 'metadata_content' argument")

        _setter("entity_id", entity_id)
        _setter("metadata_content", metadata_content)

    @property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> str:
        """
        Unique Entity ID of the application in SAML Identity Provider.
        """
        return pulumi.get(self, "entity_id")

    @property
    @pulumi.getter(name="metadataContent")
    def metadata_content(self) -> str:
        """
        Metadata of the SAML application in xml format.
        """
        return pulumi.get(self, "metadata_content")


@pulumi.output_type
class DomainSnapshotOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "automatedSnapshotStartHour":
            suggest = "automated_snapshot_start_hour"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainSnapshotOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainSnapshotOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainSnapshotOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 automated_snapshot_start_hour: int):
        """
        :param int automated_snapshot_start_hour: Hour during which the service takes an automated daily snapshot of the indices in the domain.
        """
        DomainSnapshotOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            automated_snapshot_start_hour=automated_snapshot_start_hour,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             automated_snapshot_start_hour: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if automated_snapshot_start_hour is None and 'automatedSnapshotStartHour' in kwargs:
            automated_snapshot_start_hour = kwargs['automatedSnapshotStartHour']
        if automated_snapshot_start_hour is None:
            raise TypeError("Missing 'automated_snapshot_start_hour' argument")

        _setter("automated_snapshot_start_hour", automated_snapshot_start_hour)

    @property
    @pulumi.getter(name="automatedSnapshotStartHour")
    def automated_snapshot_start_hour(self) -> int:
        """
        Hour during which the service takes an automated daily snapshot of the indices in the domain.
        """
        return pulumi.get(self, "automated_snapshot_start_hour")


@pulumi.output_type
class DomainSoftwareUpdateOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoSoftwareUpdateEnabled":
            suggest = "auto_software_update_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainSoftwareUpdateOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainSoftwareUpdateOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainSoftwareUpdateOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_software_update_enabled: Optional[bool] = None):
        """
        :param bool auto_software_update_enabled: Whether automatic service software updates are enabled for the domain. Defaults to `false`.
        """
        DomainSoftwareUpdateOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auto_software_update_enabled=auto_software_update_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auto_software_update_enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if auto_software_update_enabled is None and 'autoSoftwareUpdateEnabled' in kwargs:
            auto_software_update_enabled = kwargs['autoSoftwareUpdateEnabled']

        if auto_software_update_enabled is not None:
            _setter("auto_software_update_enabled", auto_software_update_enabled)

    @property
    @pulumi.getter(name="autoSoftwareUpdateEnabled")
    def auto_software_update_enabled(self) -> Optional[bool]:
        """
        Whether automatic service software updates are enabled for the domain. Defaults to `false`.
        """
        return pulumi.get(self, "auto_software_update_enabled")


@pulumi.output_type
class DomainVpcOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZones":
            suggest = "availability_zones"
        elif key == "securityGroupIds":
            suggest = "security_group_ids"
        elif key == "subnetIds":
            suggest = "subnet_ids"
        elif key == "vpcId":
            suggest = "vpc_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainVpcOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainVpcOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainVpcOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_zones: Optional[Sequence[str]] = None,
                 security_group_ids: Optional[Sequence[str]] = None,
                 subnet_ids: Optional[Sequence[str]] = None,
                 vpc_id: Optional[str] = None):
        """
        :param Sequence[str] security_group_ids: List of VPC Security Group IDs to be applied to the OpenSearch domain endpoints. If omitted, the default Security Group for the VPC will be used.
        :param Sequence[str] subnet_ids: List of VPC Subnet IDs for the OpenSearch domain endpoints to be created in.
        """
        DomainVpcOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability_zones=availability_zones,
            security_group_ids=security_group_ids,
            subnet_ids=subnet_ids,
            vpc_id=vpc_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability_zones: Optional[Sequence[str]] = None,
             security_group_ids: Optional[Sequence[str]] = None,
             subnet_ids: Optional[Sequence[str]] = None,
             vpc_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if availability_zones is None and 'availabilityZones' in kwargs:
            availability_zones = kwargs['availabilityZones']
        if security_group_ids is None and 'securityGroupIds' in kwargs:
            security_group_ids = kwargs['securityGroupIds']
        if subnet_ids is None and 'subnetIds' in kwargs:
            subnet_ids = kwargs['subnetIds']
        if vpc_id is None and 'vpcId' in kwargs:
            vpc_id = kwargs['vpcId']

        if availability_zones is not None:
            _setter("availability_zones", availability_zones)
        if security_group_ids is not None:
            _setter("security_group_ids", security_group_ids)
        if subnet_ids is not None:
            _setter("subnet_ids", subnet_ids)
        if vpc_id is not None:
            _setter("vpc_id", vpc_id)

    @property
    @pulumi.getter(name="availabilityZones")
    def availability_zones(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "availability_zones")

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[Sequence[str]]:
        """
        List of VPC Security Group IDs to be applied to the OpenSearch domain endpoints. If omitted, the default Security Group for the VPC will be used.
        """
        return pulumi.get(self, "security_group_ids")

    @property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Optional[Sequence[str]]:
        """
        List of VPC Subnet IDs for the OpenSearch domain endpoints to be created in.
        """
        return pulumi.get(self, "subnet_ids")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[str]:
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class OutboundConnectionConnectionProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "crossClusterSearch":
            suggest = "cross_cluster_search"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OutboundConnectionConnectionProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OutboundConnectionConnectionProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OutboundConnectionConnectionProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cross_cluster_search: Optional['outputs.OutboundConnectionConnectionPropertiesCrossClusterSearch'] = None,
                 endpoint: Optional[str] = None):
        """
        :param 'OutboundConnectionConnectionPropertiesCrossClusterSearchArgs' cross_cluster_search: Configuration block for cross cluster search.
        :param str endpoint: The endpoint of the remote domain, is only set when `connection_mode` is `VPC_ENDPOINT` and `accept_connection` is `TRUE`.
        """
        OutboundConnectionConnectionProperties._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cross_cluster_search=cross_cluster_search,
            endpoint=endpoint,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cross_cluster_search: Optional['outputs.OutboundConnectionConnectionPropertiesCrossClusterSearch'] = None,
             endpoint: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cross_cluster_search is None and 'crossClusterSearch' in kwargs:
            cross_cluster_search = kwargs['crossClusterSearch']

        if cross_cluster_search is not None:
            _setter("cross_cluster_search", cross_cluster_search)
        if endpoint is not None:
            _setter("endpoint", endpoint)

    @property
    @pulumi.getter(name="crossClusterSearch")
    def cross_cluster_search(self) -> Optional['outputs.OutboundConnectionConnectionPropertiesCrossClusterSearch']:
        """
        Configuration block for cross cluster search.
        """
        return pulumi.get(self, "cross_cluster_search")

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        """
        The endpoint of the remote domain, is only set when `connection_mode` is `VPC_ENDPOINT` and `accept_connection` is `TRUE`.
        """
        return pulumi.get(self, "endpoint")


@pulumi.output_type
class OutboundConnectionConnectionPropertiesCrossClusterSearch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "skipUnavailable":
            suggest = "skip_unavailable"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OutboundConnectionConnectionPropertiesCrossClusterSearch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OutboundConnectionConnectionPropertiesCrossClusterSearch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OutboundConnectionConnectionPropertiesCrossClusterSearch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 skip_unavailable: Optional[str] = None):
        """
        :param str skip_unavailable: Skips unavailable clusters and can only be used for cross-cluster searches. Accepted values are `ENABLED` or `DISABLED`.
        """
        OutboundConnectionConnectionPropertiesCrossClusterSearch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            skip_unavailable=skip_unavailable,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             skip_unavailable: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if skip_unavailable is None and 'skipUnavailable' in kwargs:
            skip_unavailable = kwargs['skipUnavailable']

        if skip_unavailable is not None:
            _setter("skip_unavailable", skip_unavailable)

    @property
    @pulumi.getter(name="skipUnavailable")
    def skip_unavailable(self) -> Optional[str]:
        """
        Skips unavailable clusters and can only be used for cross-cluster searches. Accepted values are `ENABLED` or `DISABLED`.
        """
        return pulumi.get(self, "skip_unavailable")


@pulumi.output_type
class OutboundConnectionLocalDomainInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "domainName":
            suggest = "domain_name"
        elif key == "ownerId":
            suggest = "owner_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OutboundConnectionLocalDomainInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OutboundConnectionLocalDomainInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OutboundConnectionLocalDomainInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 domain_name: str,
                 owner_id: str,
                 region: str):
        """
        :param str domain_name: The name of the local domain.
        :param str owner_id: The Account ID of the owner of the local domain.
        :param str region: The region of the local domain.
        """
        OutboundConnectionLocalDomainInfo._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            domain_name=domain_name,
            owner_id=owner_id,
            region=region,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             domain_name: Optional[str] = None,
             owner_id: Optional[str] = None,
             region: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if domain_name is None and 'domainName' in kwargs:
            domain_name = kwargs['domainName']
        if domain_name is None:
            raise TypeError("Missing 'domain_name' argument")
        if owner_id is None and 'ownerId' in kwargs:
            owner_id = kwargs['ownerId']
        if owner_id is None:
            raise TypeError("Missing 'owner_id' argument")
        if region is None:
            raise TypeError("Missing 'region' argument")

        _setter("domain_name", domain_name)
        _setter("owner_id", owner_id)
        _setter("region", region)

    @property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> str:
        """
        The name of the local domain.
        """
        return pulumi.get(self, "domain_name")

    @property
    @pulumi.getter(name="ownerId")
    def owner_id(self) -> str:
        """
        The Account ID of the owner of the local domain.
        """
        return pulumi.get(self, "owner_id")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        The region of the local domain.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class OutboundConnectionRemoteDomainInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "domainName":
            suggest = "domain_name"
        elif key == "ownerId":
            suggest = "owner_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OutboundConnectionRemoteDomainInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OutboundConnectionRemoteDomainInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OutboundConnectionRemoteDomainInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 domain_name: str,
                 owner_id: str,
                 region: str):
        """
        :param str domain_name: The name of the remote domain.
        :param str owner_id: The Account ID of the owner of the remote domain.
        :param str region: The region of the remote domain.
        """
        OutboundConnectionRemoteDomainInfo._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            domain_name=domain_name,
            owner_id=owner_id,
            region=region,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             domain_name: Optional[str] = None,
             owner_id: Optional[str] = None,
             region: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if domain_name is None and 'domainName' in kwargs:
            domain_name = kwargs['domainName']
        if domain_name is None:
            raise TypeError("Missing 'domain_name' argument")
        if owner_id is None and 'ownerId' in kwargs:
            owner_id = kwargs['ownerId']
        if owner_id is None:
            raise TypeError("Missing 'owner_id' argument")
        if region is None:
            raise TypeError("Missing 'region' argument")

        _setter("domain_name", domain_name)
        _setter("owner_id", owner_id)
        _setter("region", region)

    @property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> str:
        """
        The name of the remote domain.
        """
        return pulumi.get(self, "domain_name")

    @property
    @pulumi.getter(name="ownerId")
    def owner_id(self) -> str:
        """
        The Account ID of the owner of the remote domain.
        """
        return pulumi.get(self, "owner_id")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        The region of the remote domain.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class PackagePackageSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "s3BucketName":
            suggest = "s3_bucket_name"
        elif key == "s3Key":
            suggest = "s3_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PackagePackageSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PackagePackageSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PackagePackageSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 s3_bucket_name: str,
                 s3_key: str):
        """
        :param str s3_bucket_name: The name of the Amazon S3 bucket containing the package.
        :param str s3_key: Key (file name) of the package.
        """
        PackagePackageSource._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            s3_bucket_name=s3_bucket_name,
            s3_key=s3_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             s3_bucket_name: Optional[str] = None,
             s3_key: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if s3_bucket_name is None and 's3BucketName' in kwargs:
            s3_bucket_name = kwargs['s3BucketName']
        if s3_bucket_name is None:
            raise TypeError("Missing 's3_bucket_name' argument")
        if s3_key is None and 's3Key' in kwargs:
            s3_key = kwargs['s3Key']
        if s3_key is None:
            raise TypeError("Missing 's3_key' argument")

        _setter("s3_bucket_name", s3_bucket_name)
        _setter("s3_key", s3_key)

    @property
    @pulumi.getter(name="s3BucketName")
    def s3_bucket_name(self) -> str:
        """
        The name of the Amazon S3 bucket containing the package.
        """
        return pulumi.get(self, "s3_bucket_name")

    @property
    @pulumi.getter(name="s3Key")
    def s3_key(self) -> str:
        """
        Key (file name) of the package.
        """
        return pulumi.get(self, "s3_key")


@pulumi.output_type
class ServerlessCollectionTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[str] = None,
                 delete: Optional[str] = None):
        ServerlessCollectionTimeouts._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            create=create,
            delete=delete,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             create: Optional[str] = None,
             delete: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if create is not None:
            _setter("create", create)
        if delete is not None:
            _setter("delete", delete)

    @property
    @pulumi.getter
    def create(self) -> Optional[str]:
        return pulumi.get(self, "create")

    @property
    @pulumi.getter
    def delete(self) -> Optional[str]:
        return pulumi.get(self, "delete")


@pulumi.output_type
class ServerlessSecurityConfigSamlOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupAttribute":
            suggest = "group_attribute"
        elif key == "sessionTimeout":
            suggest = "session_timeout"
        elif key == "userAttribute":
            suggest = "user_attribute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerlessSecurityConfigSamlOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerlessSecurityConfigSamlOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerlessSecurityConfigSamlOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metadata: str,
                 group_attribute: Optional[str] = None,
                 session_timeout: Optional[int] = None,
                 user_attribute: Optional[str] = None):
        """
        :param str metadata: The XML IdP metadata file generated from your identity provider.
        :param str group_attribute: Group attribute for this SAML integration.
        :param int session_timeout: Session timeout, in minutes. Minimum is 5 minutes and maximum is 720 minutes (12 hours). Default is 60 minutes.
        :param str user_attribute: User attribute for this SAML integration.
        """
        ServerlessSecurityConfigSamlOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            metadata=metadata,
            group_attribute=group_attribute,
            session_timeout=session_timeout,
            user_attribute=user_attribute,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             metadata: Optional[str] = None,
             group_attribute: Optional[str] = None,
             session_timeout: Optional[int] = None,
             user_attribute: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if metadata is None:
            raise TypeError("Missing 'metadata' argument")
        if group_attribute is None and 'groupAttribute' in kwargs:
            group_attribute = kwargs['groupAttribute']
        if session_timeout is None and 'sessionTimeout' in kwargs:
            session_timeout = kwargs['sessionTimeout']
        if user_attribute is None and 'userAttribute' in kwargs:
            user_attribute = kwargs['userAttribute']

        _setter("metadata", metadata)
        if group_attribute is not None:
            _setter("group_attribute", group_attribute)
        if session_timeout is not None:
            _setter("session_timeout", session_timeout)
        if user_attribute is not None:
            _setter("user_attribute", user_attribute)

    @property
    @pulumi.getter
    def metadata(self) -> str:
        """
        The XML IdP metadata file generated from your identity provider.
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter(name="groupAttribute")
    def group_attribute(self) -> Optional[str]:
        """
        Group attribute for this SAML integration.
        """
        return pulumi.get(self, "group_attribute")

    @property
    @pulumi.getter(name="sessionTimeout")
    def session_timeout(self) -> Optional[int]:
        """
        Session timeout, in minutes. Minimum is 5 minutes and maximum is 720 minutes (12 hours). Default is 60 minutes.
        """
        return pulumi.get(self, "session_timeout")

    @property
    @pulumi.getter(name="userAttribute")
    def user_attribute(self) -> Optional[str]:
        """
        User attribute for this SAML integration.
        """
        return pulumi.get(self, "user_attribute")


@pulumi.output_type
class ServerlessVpcEndpointTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[str] = None,
                 delete: Optional[str] = None,
                 update: Optional[str] = None):
        ServerlessVpcEndpointTimeouts._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            create=create,
            delete=delete,
            update=update,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             create: Optional[str] = None,
             delete: Optional[str] = None,
             update: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if create is not None:
            _setter("create", create)
        if delete is not None:
            _setter("delete", delete)
        if update is not None:
            _setter("update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[str]:
        return pulumi.get(self, "create")

    @property
    @pulumi.getter
    def delete(self) -> Optional[str]:
        return pulumi.get(self, "delete")

    @property
    @pulumi.getter
    def update(self) -> Optional[str]:
        return pulumi.get(self, "update")


@pulumi.output_type
class VpcEndpointVpcOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetIds":
            suggest = "subnet_ids"
        elif key == "availabilityZones":
            suggest = "availability_zones"
        elif key == "securityGroupIds":
            suggest = "security_group_ids"
        elif key == "vpcId":
            suggest = "vpc_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcEndpointVpcOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcEndpointVpcOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcEndpointVpcOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subnet_ids: Sequence[str],
                 availability_zones: Optional[Sequence[str]] = None,
                 security_group_ids: Optional[Sequence[str]] = None,
                 vpc_id: Optional[str] = None):
        """
        :param Sequence[str] subnet_ids: A list of subnet IDs associated with the VPC endpoints for the domain. If your domain uses multiple Availability Zones, you need to provide two subnet IDs, one per zone. Otherwise, provide only one.
        :param Sequence[str] security_group_ids: The list of security group IDs associated with the VPC endpoints for the domain. If you do not provide a security group ID, OpenSearch Service uses the default security group for the VPC.
        """
        VpcEndpointVpcOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            subnet_ids=subnet_ids,
            availability_zones=availability_zones,
            security_group_ids=security_group_ids,
            vpc_id=vpc_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             subnet_ids: Optional[Sequence[str]] = None,
             availability_zones: Optional[Sequence[str]] = None,
             security_group_ids: Optional[Sequence[str]] = None,
             vpc_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if subnet_ids is None and 'subnetIds' in kwargs:
            subnet_ids = kwargs['subnetIds']
        if subnet_ids is None:
            raise TypeError("Missing 'subnet_ids' argument")
        if availability_zones is None and 'availabilityZones' in kwargs:
            availability_zones = kwargs['availabilityZones']
        if security_group_ids is None and 'securityGroupIds' in kwargs:
            security_group_ids = kwargs['securityGroupIds']
        if vpc_id is None and 'vpcId' in kwargs:
            vpc_id = kwargs['vpcId']

        _setter("subnet_ids", subnet_ids)
        if availability_zones is not None:
            _setter("availability_zones", availability_zones)
        if security_group_ids is not None:
            _setter("security_group_ids", security_group_ids)
        if vpc_id is not None:
            _setter("vpc_id", vpc_id)

    @property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Sequence[str]:
        """
        A list of subnet IDs associated with the VPC endpoints for the domain. If your domain uses multiple Availability Zones, you need to provide two subnet IDs, one per zone. Otherwise, provide only one.
        """
        return pulumi.get(self, "subnet_ids")

    @property
    @pulumi.getter(name="availabilityZones")
    def availability_zones(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "availability_zones")

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[Sequence[str]]:
        """
        The list of security group IDs associated with the VPC endpoints for the domain. If you do not provide a security group ID, OpenSearch Service uses the default security group for the VPC.
        """
        return pulumi.get(self, "security_group_ids")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[str]:
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class GetDomainAdvancedSecurityOptionResult(dict):
    def __init__(__self__, *,
                 anonymous_auth_enabled: bool,
                 enabled: bool,
                 internal_user_database_enabled: bool):
        """
        :param bool enabled: Enabled disabled toggle for off-peak update window
        :param bool internal_user_database_enabled: Whether the internal user database is enabled.
        """
        GetDomainAdvancedSecurityOptionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            anonymous_auth_enabled=anonymous_auth_enabled,
            enabled=enabled,
            internal_user_database_enabled=internal_user_database_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             anonymous_auth_enabled: Optional[bool] = None,
             enabled: Optional[bool] = None,
             internal_user_database_enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if anonymous_auth_enabled is None and 'anonymousAuthEnabled' in kwargs:
            anonymous_auth_enabled = kwargs['anonymousAuthEnabled']
        if anonymous_auth_enabled is None:
            raise TypeError("Missing 'anonymous_auth_enabled' argument")
        if enabled is None:
            raise TypeError("Missing 'enabled' argument")
        if internal_user_database_enabled is None and 'internalUserDatabaseEnabled' in kwargs:
            internal_user_database_enabled = kwargs['internalUserDatabaseEnabled']
        if internal_user_database_enabled is None:
            raise TypeError("Missing 'internal_user_database_enabled' argument")

        _setter("anonymous_auth_enabled", anonymous_auth_enabled)
        _setter("enabled", enabled)
        _setter("internal_user_database_enabled", internal_user_database_enabled)

    @property
    @pulumi.getter(name="anonymousAuthEnabled")
    def anonymous_auth_enabled(self) -> bool:
        return pulumi.get(self, "anonymous_auth_enabled")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Enabled disabled toggle for off-peak update window
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="internalUserDatabaseEnabled")
    def internal_user_database_enabled(self) -> bool:
        """
        Whether the internal user database is enabled.
        """
        return pulumi.get(self, "internal_user_database_enabled")


@pulumi.output_type
class GetDomainAutoTuneOptionResult(dict):
    def __init__(__self__, *,
                 desired_state: str,
                 maintenance_schedules: Sequence['outputs.GetDomainAutoTuneOptionMaintenanceScheduleResult'],
                 rollback_on_disable: str):
        """
        :param str desired_state: Auto-Tune desired state for the domain.
        :param Sequence['GetDomainAutoTuneOptionMaintenanceScheduleArgs'] maintenance_schedules: A list of the nested configurations for the Auto-Tune maintenance windows of the domain.
        :param str rollback_on_disable: Whether the domain is set to roll back to default Auto-Tune settings when disabling Auto-Tune.
        """
        GetDomainAutoTuneOptionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            desired_state=desired_state,
            maintenance_schedules=maintenance_schedules,
            rollback_on_disable=rollback_on_disable,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             desired_state: Optional[str] = None,
             maintenance_schedules: Optional[Sequence['outputs.GetDomainAutoTuneOptionMaintenanceScheduleResult']] = None,
             rollback_on_disable: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if desired_state is None and 'desiredState' in kwargs:
            desired_state = kwargs['desiredState']
        if desired_state is None:
            raise TypeError("Missing 'desired_state' argument")
        if maintenance_schedules is None and 'maintenanceSchedules' in kwargs:
            maintenance_schedules = kwargs['maintenanceSchedules']
        if maintenance_schedules is None:
            raise TypeError("Missing 'maintenance_schedules' argument")
        if rollback_on_disable is None and 'rollbackOnDisable' in kwargs:
            rollback_on_disable = kwargs['rollbackOnDisable']
        if rollback_on_disable is None:
            raise TypeError("Missing 'rollback_on_disable' argument")

        _setter("desired_state", desired_state)
        _setter("maintenance_schedules", maintenance_schedules)
        _setter("rollback_on_disable", rollback_on_disable)

    @property
    @pulumi.getter(name="desiredState")
    def desired_state(self) -> str:
        """
        Auto-Tune desired state for the domain.
        """
        return pulumi.get(self, "desired_state")

    @property
    @pulumi.getter(name="maintenanceSchedules")
    def maintenance_schedules(self) -> Sequence['outputs.GetDomainAutoTuneOptionMaintenanceScheduleResult']:
        """
        A list of the nested configurations for the Auto-Tune maintenance windows of the domain.
        """
        return pulumi.get(self, "maintenance_schedules")

    @property
    @pulumi.getter(name="rollbackOnDisable")
    def rollback_on_disable(self) -> str:
        """
        Whether the domain is set to roll back to default Auto-Tune settings when disabling Auto-Tune.
        """
        return pulumi.get(self, "rollback_on_disable")


@pulumi.output_type
class GetDomainAutoTuneOptionMaintenanceScheduleResult(dict):
    def __init__(__self__, *,
                 cron_expression_for_recurrence: str,
                 durations: Sequence['outputs.GetDomainAutoTuneOptionMaintenanceScheduleDurationResult'],
                 start_at: str):
        """
        :param str cron_expression_for_recurrence: Cron expression for an Auto-Tune maintenance schedule.
        :param Sequence['GetDomainAutoTuneOptionMaintenanceScheduleDurationArgs'] durations: Configuration block for the duration of the Auto-Tune maintenance window.
        :param str start_at: Date and time at which the Auto-Tune maintenance schedule starts in [RFC3339 format](https://tools.ietf.org/html/rfc3339#section-5.8).
        """
        GetDomainAutoTuneOptionMaintenanceScheduleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cron_expression_for_recurrence=cron_expression_for_recurrence,
            durations=durations,
            start_at=start_at,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cron_expression_for_recurrence: Optional[str] = None,
             durations: Optional[Sequence['outputs.GetDomainAutoTuneOptionMaintenanceScheduleDurationResult']] = None,
             start_at: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cron_expression_for_recurrence is None and 'cronExpressionForRecurrence' in kwargs:
            cron_expression_for_recurrence = kwargs['cronExpressionForRecurrence']
        if cron_expression_for_recurrence is None:
            raise TypeError("Missing 'cron_expression_for_recurrence' argument")
        if durations is None:
            raise TypeError("Missing 'durations' argument")
        if start_at is None and 'startAt' in kwargs:
            start_at = kwargs['startAt']
        if start_at is None:
            raise TypeError("Missing 'start_at' argument")

        _setter("cron_expression_for_recurrence", cron_expression_for_recurrence)
        _setter("durations", durations)
        _setter("start_at", start_at)

    @property
    @pulumi.getter(name="cronExpressionForRecurrence")
    def cron_expression_for_recurrence(self) -> str:
        """
        Cron expression for an Auto-Tune maintenance schedule.
        """
        return pulumi.get(self, "cron_expression_for_recurrence")

    @property
    @pulumi.getter
    def durations(self) -> Sequence['outputs.GetDomainAutoTuneOptionMaintenanceScheduleDurationResult']:
        """
        Configuration block for the duration of the Auto-Tune maintenance window.
        """
        return pulumi.get(self, "durations")

    @property
    @pulumi.getter(name="startAt")
    def start_at(self) -> str:
        """
        Date and time at which the Auto-Tune maintenance schedule starts in [RFC3339 format](https://tools.ietf.org/html/rfc3339#section-5.8).
        """
        return pulumi.get(self, "start_at")


@pulumi.output_type
class GetDomainAutoTuneOptionMaintenanceScheduleDurationResult(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: Unit of time.
        :param int value: Duration of an Auto-Tune maintenance window.
        """
        GetDomainAutoTuneOptionMaintenanceScheduleDurationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            unit=unit,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             unit: Optional[str] = None,
             value: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if unit is None:
            raise TypeError("Missing 'unit' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("unit", unit)
        _setter("value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Unit of time.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Duration of an Auto-Tune maintenance window.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetDomainClusterConfigResult(dict):
    def __init__(__self__, *,
                 cold_storage_options: Sequence['outputs.GetDomainClusterConfigColdStorageOptionResult'],
                 dedicated_master_count: int,
                 dedicated_master_enabled: bool,
                 dedicated_master_type: str,
                 instance_count: int,
                 instance_type: str,
                 multi_az_with_standby_enabled: bool,
                 warm_count: int,
                 warm_type: str,
                 zone_awareness_configs: Sequence['outputs.GetDomainClusterConfigZoneAwarenessConfigResult'],
                 zone_awareness_enabled: bool,
                 warm_enabled: Optional[bool] = None):
        """
        :param Sequence['GetDomainClusterConfigColdStorageOptionArgs'] cold_storage_options: Configuration block containing cold storage configuration.
        :param int dedicated_master_count: Number of dedicated master nodes in the cluster.
        :param bool dedicated_master_enabled: Indicates whether dedicated master nodes are enabled for the cluster.
        :param str dedicated_master_type: Instance type of the dedicated master nodes in the cluster.
        :param int instance_count: Number of instances in the cluster.
        :param str instance_type: Instance type of data nodes in the cluster.
        :param int warm_count: Number of warm nodes in the cluster.
        :param str warm_type: Instance type for the OpenSearch cluster's warm nodes.
        :param Sequence['GetDomainClusterConfigZoneAwarenessConfigArgs'] zone_awareness_configs: Configuration block containing zone awareness settings.
        :param bool zone_awareness_enabled: Indicates whether zone awareness is enabled.
        :param bool warm_enabled: Warm storage is enabled.
        """
        GetDomainClusterConfigResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cold_storage_options=cold_storage_options,
            dedicated_master_count=dedicated_master_count,
            dedicated_master_enabled=dedicated_master_enabled,
            dedicated_master_type=dedicated_master_type,
            instance_count=instance_count,
            instance_type=instance_type,
            multi_az_with_standby_enabled=multi_az_with_standby_enabled,
            warm_count=warm_count,
            warm_type=warm_type,
            zone_awareness_configs=zone_awareness_configs,
            zone_awareness_enabled=zone_awareness_enabled,
            warm_enabled=warm_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cold_storage_options: Optional[Sequence['outputs.GetDomainClusterConfigColdStorageOptionResult']] = None,
             dedicated_master_count: Optional[int] = None,
             dedicated_master_enabled: Optional[bool] = None,
             dedicated_master_type: Optional[str] = None,
             instance_count: Optional[int] = None,
             instance_type: Optional[str] = None,
             multi_az_with_standby_enabled: Optional[bool] = None,
             warm_count: Optional[int] = None,
             warm_type: Optional[str] = None,
             zone_awareness_configs: Optional[Sequence['outputs.GetDomainClusterConfigZoneAwarenessConfigResult']] = None,
             zone_awareness_enabled: Optional[bool] = None,
             warm_enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cold_storage_options is None and 'coldStorageOptions' in kwargs:
            cold_storage_options = kwargs['coldStorageOptions']
        if cold_storage_options is None:
            raise TypeError("Missing 'cold_storage_options' argument")
        if dedicated_master_count is None and 'dedicatedMasterCount' in kwargs:
            dedicated_master_count = kwargs['dedicatedMasterCount']
        if dedicated_master_count is None:
            raise TypeError("Missing 'dedicated_master_count' argument")
        if dedicated_master_enabled is None and 'dedicatedMasterEnabled' in kwargs:
            dedicated_master_enabled = kwargs['dedicatedMasterEnabled']
        if dedicated_master_enabled is None:
            raise TypeError("Missing 'dedicated_master_enabled' argument")
        if dedicated_master_type is None and 'dedicatedMasterType' in kwargs:
            dedicated_master_type = kwargs['dedicatedMasterType']
        if dedicated_master_type is None:
            raise TypeError("Missing 'dedicated_master_type' argument")
        if instance_count is None and 'instanceCount' in kwargs:
            instance_count = kwargs['instanceCount']
        if instance_count is None:
            raise TypeError("Missing 'instance_count' argument")
        if instance_type is None and 'instanceType' in kwargs:
            instance_type = kwargs['instanceType']
        if instance_type is None:
            raise TypeError("Missing 'instance_type' argument")
        if multi_az_with_standby_enabled is None and 'multiAzWithStandbyEnabled' in kwargs:
            multi_az_with_standby_enabled = kwargs['multiAzWithStandbyEnabled']
        if multi_az_with_standby_enabled is None:
            raise TypeError("Missing 'multi_az_with_standby_enabled' argument")
        if warm_count is None and 'warmCount' in kwargs:
            warm_count = kwargs['warmCount']
        if warm_count is None:
            raise TypeError("Missing 'warm_count' argument")
        if warm_type is None and 'warmType' in kwargs:
            warm_type = kwargs['warmType']
        if warm_type is None:
            raise TypeError("Missing 'warm_type' argument")
        if zone_awareness_configs is None and 'zoneAwarenessConfigs' in kwargs:
            zone_awareness_configs = kwargs['zoneAwarenessConfigs']
        if zone_awareness_configs is None:
            raise TypeError("Missing 'zone_awareness_configs' argument")
        if zone_awareness_enabled is None and 'zoneAwarenessEnabled' in kwargs:
            zone_awareness_enabled = kwargs['zoneAwarenessEnabled']
        if zone_awareness_enabled is None:
            raise TypeError("Missing 'zone_awareness_enabled' argument")
        if warm_enabled is None and 'warmEnabled' in kwargs:
            warm_enabled = kwargs['warmEnabled']

        _setter("cold_storage_options", cold_storage_options)
        _setter("dedicated_master_count", dedicated_master_count)
        _setter("dedicated_master_enabled", dedicated_master_enabled)
        _setter("dedicated_master_type", dedicated_master_type)
        _setter("instance_count", instance_count)
        _setter("instance_type", instance_type)
        _setter("multi_az_with_standby_enabled", multi_az_with_standby_enabled)
        _setter("warm_count", warm_count)
        _setter("warm_type", warm_type)
        _setter("zone_awareness_configs", zone_awareness_configs)
        _setter("zone_awareness_enabled", zone_awareness_enabled)
        if warm_enabled is not None:
            _setter("warm_enabled", warm_enabled)

    @property
    @pulumi.getter(name="coldStorageOptions")
    def cold_storage_options(self) -> Sequence['outputs.GetDomainClusterConfigColdStorageOptionResult']:
        """
        Configuration block containing cold storage configuration.
        """
        return pulumi.get(self, "cold_storage_options")

    @property
    @pulumi.getter(name="dedicatedMasterCount")
    def dedicated_master_count(self) -> int:
        """
        Number of dedicated master nodes in the cluster.
        """
        return pulumi.get(self, "dedicated_master_count")

    @property
    @pulumi.getter(name="dedicatedMasterEnabled")
    def dedicated_master_enabled(self) -> bool:
        """
        Indicates whether dedicated master nodes are enabled for the cluster.
        """
        return pulumi.get(self, "dedicated_master_enabled")

    @property
    @pulumi.getter(name="dedicatedMasterType")
    def dedicated_master_type(self) -> str:
        """
        Instance type of the dedicated master nodes in the cluster.
        """
        return pulumi.get(self, "dedicated_master_type")

    @property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> int:
        """
        Number of instances in the cluster.
        """
        return pulumi.get(self, "instance_count")

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> str:
        """
        Instance type of data nodes in the cluster.
        """
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter(name="multiAzWithStandbyEnabled")
    def multi_az_with_standby_enabled(self) -> bool:
        return pulumi.get(self, "multi_az_with_standby_enabled")

    @property
    @pulumi.getter(name="warmCount")
    def warm_count(self) -> int:
        """
        Number of warm nodes in the cluster.
        """
        return pulumi.get(self, "warm_count")

    @property
    @pulumi.getter(name="warmType")
    def warm_type(self) -> str:
        """
        Instance type for the OpenSearch cluster's warm nodes.
        """
        return pulumi.get(self, "warm_type")

    @property
    @pulumi.getter(name="zoneAwarenessConfigs")
    def zone_awareness_configs(self) -> Sequence['outputs.GetDomainClusterConfigZoneAwarenessConfigResult']:
        """
        Configuration block containing zone awareness settings.
        """
        return pulumi.get(self, "zone_awareness_configs")

    @property
    @pulumi.getter(name="zoneAwarenessEnabled")
    def zone_awareness_enabled(self) -> bool:
        """
        Indicates whether zone awareness is enabled.
        """
        return pulumi.get(self, "zone_awareness_enabled")

    @property
    @pulumi.getter(name="warmEnabled")
    def warm_enabled(self) -> Optional[bool]:
        """
        Warm storage is enabled.
        """
        return pulumi.get(self, "warm_enabled")


@pulumi.output_type
class GetDomainClusterConfigColdStorageOptionResult(dict):
    def __init__(__self__, *,
                 enabled: bool):
        """
        :param bool enabled: Enabled disabled toggle for off-peak update window
        """
        GetDomainClusterConfigColdStorageOptionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if enabled is None:
            raise TypeError("Missing 'enabled' argument")

        _setter("enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Enabled disabled toggle for off-peak update window
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetDomainClusterConfigZoneAwarenessConfigResult(dict):
    def __init__(__self__, *,
                 availability_zone_count: int):
        """
        :param int availability_zone_count: Number of availability zones used.
        """
        GetDomainClusterConfigZoneAwarenessConfigResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability_zone_count=availability_zone_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability_zone_count: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if availability_zone_count is None and 'availabilityZoneCount' in kwargs:
            availability_zone_count = kwargs['availabilityZoneCount']
        if availability_zone_count is None:
            raise TypeError("Missing 'availability_zone_count' argument")

        _setter("availability_zone_count", availability_zone_count)

    @property
    @pulumi.getter(name="availabilityZoneCount")
    def availability_zone_count(self) -> int:
        """
        Number of availability zones used.
        """
        return pulumi.get(self, "availability_zone_count")


@pulumi.output_type
class GetDomainCognitoOptionResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 identity_pool_id: str,
                 role_arn: str,
                 user_pool_id: str):
        """
        :param bool enabled: Enabled disabled toggle for off-peak update window
        :param str identity_pool_id: Cognito Identity pool used by the domain.
        :param str role_arn: IAM Role with the AmazonOpenSearchServiceCognitoAccess policy attached.
        :param str user_pool_id: Cognito User pool used by the domain.
        """
        GetDomainCognitoOptionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            identity_pool_id=identity_pool_id,
            role_arn=role_arn,
            user_pool_id=user_pool_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[bool] = None,
             identity_pool_id: Optional[str] = None,
             role_arn: Optional[str] = None,
             user_pool_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if enabled is None:
            raise TypeError("Missing 'enabled' argument")
        if identity_pool_id is None and 'identityPoolId' in kwargs:
            identity_pool_id = kwargs['identityPoolId']
        if identity_pool_id is None:
            raise TypeError("Missing 'identity_pool_id' argument")
        if role_arn is None and 'roleArn' in kwargs:
            role_arn = kwargs['roleArn']
        if role_arn is None:
            raise TypeError("Missing 'role_arn' argument")
        if user_pool_id is None and 'userPoolId' in kwargs:
            user_pool_id = kwargs['userPoolId']
        if user_pool_id is None:
            raise TypeError("Missing 'user_pool_id' argument")

        _setter("enabled", enabled)
        _setter("identity_pool_id", identity_pool_id)
        _setter("role_arn", role_arn)
        _setter("user_pool_id", user_pool_id)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Enabled disabled toggle for off-peak update window
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="identityPoolId")
    def identity_pool_id(self) -> str:
        """
        Cognito Identity pool used by the domain.
        """
        return pulumi.get(self, "identity_pool_id")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> str:
        """
        IAM Role with the AmazonOpenSearchServiceCognitoAccess policy attached.
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="userPoolId")
    def user_pool_id(self) -> str:
        """
        Cognito User pool used by the domain.
        """
        return pulumi.get(self, "user_pool_id")


@pulumi.output_type
class GetDomainEbsOptionResult(dict):
    def __init__(__self__, *,
                 ebs_enabled: bool,
                 iops: int,
                 throughput: int,
                 volume_size: int,
                 volume_type: str):
        """
        :param bool ebs_enabled: Whether EBS volumes are attached to data nodes in the domain.
        :param int iops: Baseline input/output (I/O) performance of EBS volumes attached to data nodes.
        :param int throughput: The throughput (in MiB/s) of the EBS volumes attached to data nodes.
        :param int volume_size: Size of EBS volumes attached to data nodes (in GB).
        :param str volume_type: Type of EBS volumes attached to data nodes.
        """
        GetDomainEbsOptionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ebs_enabled=ebs_enabled,
            iops=iops,
            throughput=throughput,
            volume_size=volume_size,
            volume_type=volume_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ebs_enabled: Optional[bool] = None,
             iops: Optional[int] = None,
             throughput: Optional[int] = None,
             volume_size: Optional[int] = None,
             volume_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ebs_enabled is None and 'ebsEnabled' in kwargs:
            ebs_enabled = kwargs['ebsEnabled']
        if ebs_enabled is None:
            raise TypeError("Missing 'ebs_enabled' argument")
        if iops is None:
            raise TypeError("Missing 'iops' argument")
        if throughput is None:
            raise TypeError("Missing 'throughput' argument")
        if volume_size is None and 'volumeSize' in kwargs:
            volume_size = kwargs['volumeSize']
        if volume_size is None:
            raise TypeError("Missing 'volume_size' argument")
        if volume_type is None and 'volumeType' in kwargs:
            volume_type = kwargs['volumeType']
        if volume_type is None:
            raise TypeError("Missing 'volume_type' argument")

        _setter("ebs_enabled", ebs_enabled)
        _setter("iops", iops)
        _setter("throughput", throughput)
        _setter("volume_size", volume_size)
        _setter("volume_type", volume_type)

    @property
    @pulumi.getter(name="ebsEnabled")
    def ebs_enabled(self) -> bool:
        """
        Whether EBS volumes are attached to data nodes in the domain.
        """
        return pulumi.get(self, "ebs_enabled")

    @property
    @pulumi.getter
    def iops(self) -> int:
        """
        Baseline input/output (I/O) performance of EBS volumes attached to data nodes.
        """
        return pulumi.get(self, "iops")

    @property
    @pulumi.getter
    def throughput(self) -> int:
        """
        The throughput (in MiB/s) of the EBS volumes attached to data nodes.
        """
        return pulumi.get(self, "throughput")

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> int:
        """
        Size of EBS volumes attached to data nodes (in GB).
        """
        return pulumi.get(self, "volume_size")

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> str:
        """
        Type of EBS volumes attached to data nodes.
        """
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class GetDomainEncryptionAtRestResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 kms_key_id: str):
        """
        :param bool enabled: Enabled disabled toggle for off-peak update window
        :param str kms_key_id: KMS key id used to encrypt data at rest.
        """
        GetDomainEncryptionAtRestResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            kms_key_id=kms_key_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[bool] = None,
             kms_key_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if enabled is None:
            raise TypeError("Missing 'enabled' argument")
        if kms_key_id is None and 'kmsKeyId' in kwargs:
            kms_key_id = kwargs['kmsKeyId']
        if kms_key_id is None:
            raise TypeError("Missing 'kms_key_id' argument")

        _setter("enabled", enabled)
        _setter("kms_key_id", kms_key_id)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Enabled disabled toggle for off-peak update window
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> str:
        """
        KMS key id used to encrypt data at rest.
        """
        return pulumi.get(self, "kms_key_id")


@pulumi.output_type
class GetDomainLogPublishingOptionResult(dict):
    def __init__(__self__, *,
                 cloudwatch_log_group_arn: str,
                 enabled: bool,
                 log_type: str):
        """
        :param str cloudwatch_log_group_arn: CloudWatch Log Group where the logs are published.
        :param bool enabled: Enabled disabled toggle for off-peak update window
        :param str log_type: Type of OpenSearch log being published.
        """
        GetDomainLogPublishingOptionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloudwatch_log_group_arn=cloudwatch_log_group_arn,
            enabled=enabled,
            log_type=log_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloudwatch_log_group_arn: Optional[str] = None,
             enabled: Optional[bool] = None,
             log_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cloudwatch_log_group_arn is None and 'cloudwatchLogGroupArn' in kwargs:
            cloudwatch_log_group_arn = kwargs['cloudwatchLogGroupArn']
        if cloudwatch_log_group_arn is None:
            raise TypeError("Missing 'cloudwatch_log_group_arn' argument")
        if enabled is None:
            raise TypeError("Missing 'enabled' argument")
        if log_type is None and 'logType' in kwargs:
            log_type = kwargs['logType']
        if log_type is None:
            raise TypeError("Missing 'log_type' argument")

        _setter("cloudwatch_log_group_arn", cloudwatch_log_group_arn)
        _setter("enabled", enabled)
        _setter("log_type", log_type)

    @property
    @pulumi.getter(name="cloudwatchLogGroupArn")
    def cloudwatch_log_group_arn(self) -> str:
        """
        CloudWatch Log Group where the logs are published.
        """
        return pulumi.get(self, "cloudwatch_log_group_arn")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Enabled disabled toggle for off-peak update window
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="logType")
    def log_type(self) -> str:
        """
        Type of OpenSearch log being published.
        """
        return pulumi.get(self, "log_type")


@pulumi.output_type
class GetDomainNodeToNodeEncryptionResult(dict):
    def __init__(__self__, *,
                 enabled: bool):
        """
        :param bool enabled: Enabled disabled toggle for off-peak update window
        """
        GetDomainNodeToNodeEncryptionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if enabled is None:
            raise TypeError("Missing 'enabled' argument")

        _setter("enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Enabled disabled toggle for off-peak update window
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetDomainOffPeakWindowOptionsResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 off_peak_windows: Sequence['outputs.GetDomainOffPeakWindowOptionsOffPeakWindowResult']):
        """
        :param bool enabled: Enabled disabled toggle for off-peak update window
        """
        GetDomainOffPeakWindowOptionsResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            off_peak_windows=off_peak_windows,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[bool] = None,
             off_peak_windows: Optional[Sequence['outputs.GetDomainOffPeakWindowOptionsOffPeakWindowResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if enabled is None:
            raise TypeError("Missing 'enabled' argument")
        if off_peak_windows is None and 'offPeakWindows' in kwargs:
            off_peak_windows = kwargs['offPeakWindows']
        if off_peak_windows is None:
            raise TypeError("Missing 'off_peak_windows' argument")

        _setter("enabled", enabled)
        _setter("off_peak_windows", off_peak_windows)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Enabled disabled toggle for off-peak update window
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="offPeakWindows")
    def off_peak_windows(self) -> Sequence['outputs.GetDomainOffPeakWindowOptionsOffPeakWindowResult']:
        return pulumi.get(self, "off_peak_windows")


@pulumi.output_type
class GetDomainOffPeakWindowOptionsOffPeakWindowResult(dict):
    def __init__(__self__, *,
                 window_start_times: Sequence['outputs.GetDomainOffPeakWindowOptionsOffPeakWindowWindowStartTimeResult']):
        """
        :param Sequence['GetDomainOffPeakWindowOptionsOffPeakWindowWindowStartTimeArgs'] window_start_times: 10h window for updates
        """
        GetDomainOffPeakWindowOptionsOffPeakWindowResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            window_start_times=window_start_times,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             window_start_times: Optional[Sequence['outputs.GetDomainOffPeakWindowOptionsOffPeakWindowWindowStartTimeResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if window_start_times is None and 'windowStartTimes' in kwargs:
            window_start_times = kwargs['windowStartTimes']
        if window_start_times is None:
            raise TypeError("Missing 'window_start_times' argument")

        _setter("window_start_times", window_start_times)

    @property
    @pulumi.getter(name="windowStartTimes")
    def window_start_times(self) -> Sequence['outputs.GetDomainOffPeakWindowOptionsOffPeakWindowWindowStartTimeResult']:
        """
        10h window for updates
        """
        return pulumi.get(self, "window_start_times")


@pulumi.output_type
class GetDomainOffPeakWindowOptionsOffPeakWindowWindowStartTimeResult(dict):
    def __init__(__self__, *,
                 hours: int,
                 minutes: int):
        """
        :param int hours: Starting hour of the 10-hour window for updates
        :param int minutes: Starting minute of the 10-hour window for updates
        """
        GetDomainOffPeakWindowOptionsOffPeakWindowWindowStartTimeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            hours=hours,
            minutes=minutes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             hours: Optional[int] = None,
             minutes: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if hours is None:
            raise TypeError("Missing 'hours' argument")
        if minutes is None:
            raise TypeError("Missing 'minutes' argument")

        _setter("hours", hours)
        _setter("minutes", minutes)

    @property
    @pulumi.getter
    def hours(self) -> int:
        """
        Starting hour of the 10-hour window for updates
        """
        return pulumi.get(self, "hours")

    @property
    @pulumi.getter
    def minutes(self) -> int:
        """
        Starting minute of the 10-hour window for updates
        """
        return pulumi.get(self, "minutes")


@pulumi.output_type
class GetDomainSnapshotOptionResult(dict):
    def __init__(__self__, *,
                 automated_snapshot_start_hour: int):
        """
        :param int automated_snapshot_start_hour: Hour during which the service takes an automated daily snapshot of the indices in the domain.
        """
        GetDomainSnapshotOptionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            automated_snapshot_start_hour=automated_snapshot_start_hour,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             automated_snapshot_start_hour: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if automated_snapshot_start_hour is None and 'automatedSnapshotStartHour' in kwargs:
            automated_snapshot_start_hour = kwargs['automatedSnapshotStartHour']
        if automated_snapshot_start_hour is None:
            raise TypeError("Missing 'automated_snapshot_start_hour' argument")

        _setter("automated_snapshot_start_hour", automated_snapshot_start_hour)

    @property
    @pulumi.getter(name="automatedSnapshotStartHour")
    def automated_snapshot_start_hour(self) -> int:
        """
        Hour during which the service takes an automated daily snapshot of the indices in the domain.
        """
        return pulumi.get(self, "automated_snapshot_start_hour")


@pulumi.output_type
class GetDomainSoftwareUpdateOptionResult(dict):
    def __init__(__self__, *,
                 auto_software_update_enabled: bool):
        """
        :param bool auto_software_update_enabled: Enabled or disabled.
        """
        GetDomainSoftwareUpdateOptionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auto_software_update_enabled=auto_software_update_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auto_software_update_enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if auto_software_update_enabled is None and 'autoSoftwareUpdateEnabled' in kwargs:
            auto_software_update_enabled = kwargs['autoSoftwareUpdateEnabled']
        if auto_software_update_enabled is None:
            raise TypeError("Missing 'auto_software_update_enabled' argument")

        _setter("auto_software_update_enabled", auto_software_update_enabled)

    @property
    @pulumi.getter(name="autoSoftwareUpdateEnabled")
    def auto_software_update_enabled(self) -> bool:
        """
        Enabled or disabled.
        """
        return pulumi.get(self, "auto_software_update_enabled")


@pulumi.output_type
class GetDomainVpcOptionResult(dict):
    def __init__(__self__, *,
                 availability_zones: Sequence[str],
                 security_group_ids: Sequence[str],
                 subnet_ids: Sequence[str],
                 vpc_id: str):
        """
        :param Sequence[str] availability_zones: Availability zones used by the domain.
        :param Sequence[str] security_group_ids: Security groups used by the domain.
        :param Sequence[str] subnet_ids: Subnets used by the domain.
        :param str vpc_id: VPC used by the domain.
        """
        GetDomainVpcOptionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability_zones=availability_zones,
            security_group_ids=security_group_ids,
            subnet_ids=subnet_ids,
            vpc_id=vpc_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability_zones: Optional[Sequence[str]] = None,
             security_group_ids: Optional[Sequence[str]] = None,
             subnet_ids: Optional[Sequence[str]] = None,
             vpc_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if availability_zones is None and 'availabilityZones' in kwargs:
            availability_zones = kwargs['availabilityZones']
        if availability_zones is None:
            raise TypeError("Missing 'availability_zones' argument")
        if security_group_ids is None and 'securityGroupIds' in kwargs:
            security_group_ids = kwargs['securityGroupIds']
        if security_group_ids is None:
            raise TypeError("Missing 'security_group_ids' argument")
        if subnet_ids is None and 'subnetIds' in kwargs:
            subnet_ids = kwargs['subnetIds']
        if subnet_ids is None:
            raise TypeError("Missing 'subnet_ids' argument")
        if vpc_id is None and 'vpcId' in kwargs:
            vpc_id = kwargs['vpcId']
        if vpc_id is None:
            raise TypeError("Missing 'vpc_id' argument")

        _setter("availability_zones", availability_zones)
        _setter("security_group_ids", security_group_ids)
        _setter("subnet_ids", subnet_ids)
        _setter("vpc_id", vpc_id)

    @property
    @pulumi.getter(name="availabilityZones")
    def availability_zones(self) -> Sequence[str]:
        """
        Availability zones used by the domain.
        """
        return pulumi.get(self, "availability_zones")

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Sequence[str]:
        """
        Security groups used by the domain.
        """
        return pulumi.get(self, "security_group_ids")

    @property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Sequence[str]:
        """
        Subnets used by the domain.
        """
        return pulumi.get(self, "subnet_ids")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> str:
        """
        VPC used by the domain.
        """
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class GetServerlessSecurityConfigSamlOptionsResult(dict):
    def __init__(__self__, *,
                 group_attribute: str,
                 metadata: str,
                 session_timeout: int,
                 user_attribute: str):
        """
        :param str group_attribute: Group attribute for this SAML integration.
        :param str metadata: The XML IdP metadata file generated from your identity provider.
        :param int session_timeout: Session timeout, in minutes. Minimum is 5 minutes and maximum is 720 minutes (12 hours). Default is 60 minutes.
        :param str user_attribute: User attribute for this SAML integration.
        """
        GetServerlessSecurityConfigSamlOptionsResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            group_attribute=group_attribute,
            metadata=metadata,
            session_timeout=session_timeout,
            user_attribute=user_attribute,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             group_attribute: Optional[str] = None,
             metadata: Optional[str] = None,
             session_timeout: Optional[int] = None,
             user_attribute: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if group_attribute is None and 'groupAttribute' in kwargs:
            group_attribute = kwargs['groupAttribute']
        if group_attribute is None:
            raise TypeError("Missing 'group_attribute' argument")
        if metadata is None:
            raise TypeError("Missing 'metadata' argument")
        if session_timeout is None and 'sessionTimeout' in kwargs:
            session_timeout = kwargs['sessionTimeout']
        if session_timeout is None:
            raise TypeError("Missing 'session_timeout' argument")
        if user_attribute is None and 'userAttribute' in kwargs:
            user_attribute = kwargs['userAttribute']
        if user_attribute is None:
            raise TypeError("Missing 'user_attribute' argument")

        _setter("group_attribute", group_attribute)
        _setter("metadata", metadata)
        _setter("session_timeout", session_timeout)
        _setter("user_attribute", user_attribute)

    @property
    @pulumi.getter(name="groupAttribute")
    def group_attribute(self) -> str:
        """
        Group attribute for this SAML integration.
        """
        return pulumi.get(self, "group_attribute")

    @property
    @pulumi.getter
    def metadata(self) -> str:
        """
        The XML IdP metadata file generated from your identity provider.
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter(name="sessionTimeout")
    def session_timeout(self) -> int:
        """
        Session timeout, in minutes. Minimum is 5 minutes and maximum is 720 minutes (12 hours). Default is 60 minutes.
        """
        return pulumi.get(self, "session_timeout")

    @property
    @pulumi.getter(name="userAttribute")
    def user_attribute(self) -> str:
        """
        User attribute for this SAML integration.
        """
        return pulumi.get(self, "user_attribute")


