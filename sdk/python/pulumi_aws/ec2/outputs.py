# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AmiCopyEbsBlockDevice',
    'AmiCopyEphemeralBlockDevice',
    'AmiEbsBlockDevice',
    'AmiEphemeralBlockDevice',
    'AmiFromInstanceEbsBlockDevice',
    'AmiFromInstanceEphemeralBlockDevice',
    'CapacityBlockReservationTimeouts',
    'DefaultCreditSpecificationTimeouts',
    'DefaultNetworkAclEgress',
    'DefaultNetworkAclIngress',
    'DefaultRouteTableRoute',
    'DefaultSecurityGroupEgress',
    'DefaultSecurityGroupIngress',
    'EipDomainNameTimeouts',
    'FleetFleetInstanceSet',
    'FleetLaunchTemplateConfig',
    'FleetLaunchTemplateConfigLaunchTemplateSpecification',
    'FleetLaunchTemplateConfigOverride',
    'FleetLaunchTemplateConfigOverrideInstanceRequirements',
    'FleetLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorCount',
    'FleetLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorTotalMemoryMib',
    'FleetLaunchTemplateConfigOverrideInstanceRequirementsBaselineEbsBandwidthMbps',
    'FleetLaunchTemplateConfigOverrideInstanceRequirementsMemoryGibPerVcpu',
    'FleetLaunchTemplateConfigOverrideInstanceRequirementsMemoryMib',
    'FleetLaunchTemplateConfigOverrideInstanceRequirementsNetworkBandwidthGbps',
    'FleetLaunchTemplateConfigOverrideInstanceRequirementsNetworkInterfaceCount',
    'FleetLaunchTemplateConfigOverrideInstanceRequirementsTotalLocalStorageGb',
    'FleetLaunchTemplateConfigOverrideInstanceRequirementsVcpuCount',
    'FleetOnDemandOptions',
    'FleetOnDemandOptionsCapacityReservationOptions',
    'FleetSpotOptions',
    'FleetSpotOptionsMaintenanceStrategies',
    'FleetSpotOptionsMaintenanceStrategiesCapacityRebalance',
    'FleetTargetCapacitySpecification',
    'FlowLogDestinationOptions',
    'InstanceCapacityReservationSpecification',
    'InstanceCapacityReservationSpecificationCapacityReservationTarget',
    'InstanceCpuOptions',
    'InstanceCreditSpecification',
    'InstanceEbsBlockDevice',
    'InstanceEnclaveOptions',
    'InstanceEphemeralBlockDevice',
    'InstanceInstanceMarketOptions',
    'InstanceInstanceMarketOptionsSpotOptions',
    'InstanceLaunchTemplate',
    'InstanceMaintenanceOptions',
    'InstanceMetadataOptions',
    'InstanceNetworkInterface',
    'InstancePrivateDnsNameOptions',
    'InstanceRootBlockDevice',
    'LaunchConfigurationEbsBlockDevice',
    'LaunchConfigurationEphemeralBlockDevice',
    'LaunchConfigurationMetadataOptions',
    'LaunchConfigurationRootBlockDevice',
    'LaunchTemplateBlockDeviceMapping',
    'LaunchTemplateBlockDeviceMappingEbs',
    'LaunchTemplateCapacityReservationSpecification',
    'LaunchTemplateCapacityReservationSpecificationCapacityReservationTarget',
    'LaunchTemplateCpuOptions',
    'LaunchTemplateCreditSpecification',
    'LaunchTemplateEnclaveOptions',
    'LaunchTemplateHibernationOptions',
    'LaunchTemplateIamInstanceProfile',
    'LaunchTemplateInstanceMarketOptions',
    'LaunchTemplateInstanceMarketOptionsSpotOptions',
    'LaunchTemplateInstanceRequirements',
    'LaunchTemplateInstanceRequirementsAcceleratorCount',
    'LaunchTemplateInstanceRequirementsAcceleratorTotalMemoryMib',
    'LaunchTemplateInstanceRequirementsBaselineEbsBandwidthMbps',
    'LaunchTemplateInstanceRequirementsMemoryGibPerVcpu',
    'LaunchTemplateInstanceRequirementsMemoryMib',
    'LaunchTemplateInstanceRequirementsNetworkBandwidthGbps',
    'LaunchTemplateInstanceRequirementsNetworkInterfaceCount',
    'LaunchTemplateInstanceRequirementsTotalLocalStorageGb',
    'LaunchTemplateInstanceRequirementsVcpuCount',
    'LaunchTemplateLicenseSpecification',
    'LaunchTemplateMaintenanceOptions',
    'LaunchTemplateMetadataOptions',
    'LaunchTemplateMonitoring',
    'LaunchTemplateNetworkInterface',
    'LaunchTemplateNetworkInterfaceConnectionTrackingSpecification',
    'LaunchTemplateNetworkInterfaceEnaSrdSpecification',
    'LaunchTemplateNetworkInterfaceEnaSrdSpecificationEnaSrdUdpSpecification',
    'LaunchTemplatePlacement',
    'LaunchTemplatePrivateDnsNameOptions',
    'LaunchTemplateTagSpecification',
    'ManagedPrefixListEntry',
    'NatGatewayEipAssociationTimeouts',
    'NetworkAclEgress',
    'NetworkAclIngress',
    'NetworkInsightsAnalysisAlternatePathHint',
    'NetworkInsightsAnalysisExplanation',
    'NetworkInsightsAnalysisExplanationAcl',
    'NetworkInsightsAnalysisExplanationAclRule',
    'NetworkInsightsAnalysisExplanationAclRulePortRange',
    'NetworkInsightsAnalysisExplanationAttachedTo',
    'NetworkInsightsAnalysisExplanationClassicLoadBalancerListener',
    'NetworkInsightsAnalysisExplanationComponent',
    'NetworkInsightsAnalysisExplanationCustomerGateway',
    'NetworkInsightsAnalysisExplanationDestination',
    'NetworkInsightsAnalysisExplanationDestinationVpc',
    'NetworkInsightsAnalysisExplanationElasticLoadBalancerListener',
    'NetworkInsightsAnalysisExplanationIngressRouteTable',
    'NetworkInsightsAnalysisExplanationInternetGateway',
    'NetworkInsightsAnalysisExplanationLoadBalancerTargetGroup',
    'NetworkInsightsAnalysisExplanationNatGateway',
    'NetworkInsightsAnalysisExplanationNetworkInterface',
    'NetworkInsightsAnalysisExplanationPortRange',
    'NetworkInsightsAnalysisExplanationPrefixList',
    'NetworkInsightsAnalysisExplanationRouteTable',
    'NetworkInsightsAnalysisExplanationRouteTableRoute',
    'NetworkInsightsAnalysisExplanationSecurityGroup',
    'NetworkInsightsAnalysisExplanationSecurityGroupRule',
    'NetworkInsightsAnalysisExplanationSecurityGroupRulePortRange',
    'NetworkInsightsAnalysisExplanationSourceVpc',
    'NetworkInsightsAnalysisExplanationSubnet',
    'NetworkInsightsAnalysisExplanationSubnetRouteTable',
    'NetworkInsightsAnalysisExplanationTransitGateway',
    'NetworkInsightsAnalysisExplanationTransitGatewayAttachment',
    'NetworkInsightsAnalysisExplanationTransitGatewayRouteTable',
    'NetworkInsightsAnalysisExplanationTransitGatewayRouteTableRoute',
    'NetworkInsightsAnalysisExplanationVpc',
    'NetworkInsightsAnalysisExplanationVpcEndpoint',
    'NetworkInsightsAnalysisExplanationVpcPeeringConnection',
    'NetworkInsightsAnalysisExplanationVpnConnection',
    'NetworkInsightsAnalysisExplanationVpnGateway',
    'NetworkInsightsAnalysisForwardPathComponent',
    'NetworkInsightsAnalysisForwardPathComponentAclRule',
    'NetworkInsightsAnalysisForwardPathComponentAclRulePortRange',
    'NetworkInsightsAnalysisForwardPathComponentAdditionalDetail',
    'NetworkInsightsAnalysisForwardPathComponentAdditionalDetailComponent',
    'NetworkInsightsAnalysisForwardPathComponentAttachedTo',
    'NetworkInsightsAnalysisForwardPathComponentComponent',
    'NetworkInsightsAnalysisForwardPathComponentDestinationVpc',
    'NetworkInsightsAnalysisForwardPathComponentInboundHeader',
    'NetworkInsightsAnalysisForwardPathComponentInboundHeaderDestinationPortRange',
    'NetworkInsightsAnalysisForwardPathComponentInboundHeaderSourcePortRange',
    'NetworkInsightsAnalysisForwardPathComponentOutboundHeader',
    'NetworkInsightsAnalysisForwardPathComponentOutboundHeaderDestinationPortRange',
    'NetworkInsightsAnalysisForwardPathComponentOutboundHeaderSourcePortRange',
    'NetworkInsightsAnalysisForwardPathComponentRouteTableRoute',
    'NetworkInsightsAnalysisForwardPathComponentSecurityGroupRule',
    'NetworkInsightsAnalysisForwardPathComponentSecurityGroupRulePortRange',
    'NetworkInsightsAnalysisForwardPathComponentSourceVpc',
    'NetworkInsightsAnalysisForwardPathComponentSubnet',
    'NetworkInsightsAnalysisForwardPathComponentTransitGateway',
    'NetworkInsightsAnalysisForwardPathComponentTransitGatewayRouteTableRoute',
    'NetworkInsightsAnalysisForwardPathComponentVpc',
    'NetworkInsightsAnalysisReturnPathComponent',
    'NetworkInsightsAnalysisReturnPathComponentAclRule',
    'NetworkInsightsAnalysisReturnPathComponentAclRulePortRange',
    'NetworkInsightsAnalysisReturnPathComponentAdditionalDetail',
    'NetworkInsightsAnalysisReturnPathComponentAdditionalDetailComponent',
    'NetworkInsightsAnalysisReturnPathComponentAttachedTo',
    'NetworkInsightsAnalysisReturnPathComponentComponent',
    'NetworkInsightsAnalysisReturnPathComponentDestinationVpc',
    'NetworkInsightsAnalysisReturnPathComponentInboundHeader',
    'NetworkInsightsAnalysisReturnPathComponentInboundHeaderDestinationPortRange',
    'NetworkInsightsAnalysisReturnPathComponentInboundHeaderSourcePortRange',
    'NetworkInsightsAnalysisReturnPathComponentOutboundHeader',
    'NetworkInsightsAnalysisReturnPathComponentOutboundHeaderDestinationPortRange',
    'NetworkInsightsAnalysisReturnPathComponentOutboundHeaderSourcePortRange',
    'NetworkInsightsAnalysisReturnPathComponentRouteTableRoute',
    'NetworkInsightsAnalysisReturnPathComponentSecurityGroupRule',
    'NetworkInsightsAnalysisReturnPathComponentSecurityGroupRulePortRange',
    'NetworkInsightsAnalysisReturnPathComponentSourceVpc',
    'NetworkInsightsAnalysisReturnPathComponentSubnet',
    'NetworkInsightsAnalysisReturnPathComponentTransitGateway',
    'NetworkInsightsAnalysisReturnPathComponentTransitGatewayRouteTableRoute',
    'NetworkInsightsAnalysisReturnPathComponentVpc',
    'NetworkInsightsPathFilterAtDestination',
    'NetworkInsightsPathFilterAtDestinationDestinationPortRange',
    'NetworkInsightsPathFilterAtDestinationSourcePortRange',
    'NetworkInsightsPathFilterAtSource',
    'NetworkInsightsPathFilterAtSourceDestinationPortRange',
    'NetworkInsightsPathFilterAtSourceSourcePortRange',
    'NetworkInterfaceAttachment',
    'NetworkInterfacePermissionTimeouts',
    'PeeringConnectionOptionsAccepter',
    'PeeringConnectionOptionsRequester',
    'RouteTableRoute',
    'SecurityGroupEgress',
    'SecurityGroupIngress',
    'SpotFleetRequestLaunchSpecification',
    'SpotFleetRequestLaunchSpecificationEbsBlockDevice',
    'SpotFleetRequestLaunchSpecificationEphemeralBlockDevice',
    'SpotFleetRequestLaunchSpecificationRootBlockDevice',
    'SpotFleetRequestLaunchTemplateConfig',
    'SpotFleetRequestLaunchTemplateConfigLaunchTemplateSpecification',
    'SpotFleetRequestLaunchTemplateConfigOverride',
    'SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirements',
    'SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorCount',
    'SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorTotalMemoryMib',
    'SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsBaselineEbsBandwidthMbps',
    'SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsMemoryGibPerVcpu',
    'SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsMemoryMib',
    'SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsNetworkBandwidthGbps',
    'SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsNetworkInterfaceCount',
    'SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsTotalLocalStorageGb',
    'SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsVcpuCount',
    'SpotFleetRequestSpotMaintenanceStrategies',
    'SpotFleetRequestSpotMaintenanceStrategiesCapacityRebalance',
    'SpotInstanceRequestCapacityReservationSpecification',
    'SpotInstanceRequestCapacityReservationSpecificationCapacityReservationTarget',
    'SpotInstanceRequestCpuOptions',
    'SpotInstanceRequestCreditSpecification',
    'SpotInstanceRequestEbsBlockDevice',
    'SpotInstanceRequestEnclaveOptions',
    'SpotInstanceRequestEphemeralBlockDevice',
    'SpotInstanceRequestLaunchTemplate',
    'SpotInstanceRequestMaintenanceOptions',
    'SpotInstanceRequestMetadataOptions',
    'SpotInstanceRequestNetworkInterface',
    'SpotInstanceRequestPrivateDnsNameOptions',
    'SpotInstanceRequestRootBlockDevice',
    'TrafficMirrorFilterRuleDestinationPortRange',
    'TrafficMirrorFilterRuleSourcePortRange',
    'VpcBlockPublicAccessExclusionTimeouts',
    'VpcBlockPublicAccessOptionsTimeouts',
    'VpcEndpointDnsEntry',
    'VpcEndpointDnsOptions',
    'VpcEndpointServicePrivateDnsNameConfiguration',
    'VpcEndpointSubnetConfiguration',
    'VpcIpamOperatingRegion',
    'VpcIpamPoolCidrCidrAuthorizationContext',
    'VpcIpamResourceDiscoveryOperatingRegion',
    'VpcPeeringConnectionAccepter',
    'VpcPeeringConnectionAccepterAccepter',
    'VpcPeeringConnectionAccepterRequester',
    'VpcPeeringConnectionRequester',
    'VpnConnectionRoute',
    'VpnConnectionTunnel1LogOptions',
    'VpnConnectionTunnel1LogOptionsCloudwatchLogOptions',
    'VpnConnectionTunnel2LogOptions',
    'VpnConnectionTunnel2LogOptionsCloudwatchLogOptions',
    'VpnConnectionVgwTelemetry',
    'GetAmiBlockDeviceMappingResult',
    'GetAmiFilterResult',
    'GetAmiIdsFilterResult',
    'GetAmiProductCodeResult',
    'GetCoipPoolFilterResult',
    'GetCoipPoolsFilterResult',
    'GetCustomerGatewayFilterResult',
    'GetDedicatedHostFilterResult',
    'GetEipsFilterResult',
    'GetElasticIpFilterResult',
    'GetInstanceCreditSpecificationResult',
    'GetInstanceEbsBlockDeviceResult',
    'GetInstanceEnclaveOptionResult',
    'GetInstanceEphemeralBlockDeviceResult',
    'GetInstanceFilterResult',
    'GetInstanceMaintenanceOptionResult',
    'GetInstanceMetadataOptionResult',
    'GetInstancePrivateDnsNameOptionResult',
    'GetInstanceRootBlockDeviceResult',
    'GetInstanceTypeFpgaResult',
    'GetInstanceTypeGpusResult',
    'GetInstanceTypeInferenceAcceleratorResult',
    'GetInstanceTypeInstanceDiskResult',
    'GetInstanceTypeMediaAcceleratorResult',
    'GetInstanceTypeNetworkCardResult',
    'GetInstanceTypeNeuronDeviceResult',
    'GetInstanceTypeOfferingFilterResult',
    'GetInstanceTypeOfferingsFilterResult',
    'GetInstanceTypesFilterResult',
    'GetInstancesFilterResult',
    'GetInternetGatewayAttachmentResult',
    'GetInternetGatewayFilterResult',
    'GetKeyPairFilterResult',
    'GetLaunchConfigurationEbsBlockDeviceResult',
    'GetLaunchConfigurationEphemeralBlockDeviceResult',
    'GetLaunchConfigurationMetadataOptionResult',
    'GetLaunchConfigurationRootBlockDeviceResult',
    'GetLaunchTemplateBlockDeviceMappingResult',
    'GetLaunchTemplateBlockDeviceMappingEbResult',
    'GetLaunchTemplateCapacityReservationSpecificationResult',
    'GetLaunchTemplateCapacityReservationSpecificationCapacityReservationTargetResult',
    'GetLaunchTemplateCpuOptionResult',
    'GetLaunchTemplateCreditSpecificationResult',
    'GetLaunchTemplateEnclaveOptionResult',
    'GetLaunchTemplateFilterResult',
    'GetLaunchTemplateHibernationOptionResult',
    'GetLaunchTemplateIamInstanceProfileResult',
    'GetLaunchTemplateInstanceMarketOptionResult',
    'GetLaunchTemplateInstanceMarketOptionSpotOptionResult',
    'GetLaunchTemplateInstanceRequirementResult',
    'GetLaunchTemplateInstanceRequirementAcceleratorCountResult',
    'GetLaunchTemplateInstanceRequirementAcceleratorTotalMemoryMibResult',
    'GetLaunchTemplateInstanceRequirementBaselineEbsBandwidthMbpResult',
    'GetLaunchTemplateInstanceRequirementMemoryGibPerVcpusResult',
    'GetLaunchTemplateInstanceRequirementMemoryMibResult',
    'GetLaunchTemplateInstanceRequirementNetworkBandwidthGbpResult',
    'GetLaunchTemplateInstanceRequirementNetworkInterfaceCountResult',
    'GetLaunchTemplateInstanceRequirementTotalLocalStorageGbResult',
    'GetLaunchTemplateInstanceRequirementVcpuCountResult',
    'GetLaunchTemplateLicenseSpecificationResult',
    'GetLaunchTemplateMaintenanceOptionResult',
    'GetLaunchTemplateMetadataOptionResult',
    'GetLaunchTemplateMonitoringResult',
    'GetLaunchTemplateNetworkInterfaceResult',
    'GetLaunchTemplateNetworkInterfaceConnectionTrackingSpecificationResult',
    'GetLaunchTemplatePlacementResult',
    'GetLaunchTemplatePrivateDnsNameOptionResult',
    'GetLaunchTemplateTagSpecificationResult',
    'GetLocalGatewayFilterResult',
    'GetLocalGatewayRouteTableFilterResult',
    'GetLocalGatewayRouteTablesFilterResult',
    'GetLocalGatewayVirtualInterfaceFilterResult',
    'GetLocalGatewayVirtualInterfaceGroupFilterResult',
    'GetLocalGatewayVirtualInterfaceGroupsFilterResult',
    'GetLocalGatewaysFilterResult',
    'GetManagedPrefixListEntryResult',
    'GetManagedPrefixListFilterResult',
    'GetManagedPrefixListsFilterResult',
    'GetNatGatewayFilterResult',
    'GetNatGatewaysFilterResult',
    'GetNetworkAclsFilterResult',
    'GetNetworkInsightsAnalysisAlternatePathHintResult',
    'GetNetworkInsightsAnalysisExplanationResult',
    'GetNetworkInsightsAnalysisExplanationAclResult',
    'GetNetworkInsightsAnalysisExplanationAclRuleResult',
    'GetNetworkInsightsAnalysisExplanationAclRulePortRangeResult',
    'GetNetworkInsightsAnalysisExplanationAttachedToResult',
    'GetNetworkInsightsAnalysisExplanationClassicLoadBalancerListenerResult',
    'GetNetworkInsightsAnalysisExplanationComponentResult',
    'GetNetworkInsightsAnalysisExplanationCustomerGatewayResult',
    'GetNetworkInsightsAnalysisExplanationDestinationResult',
    'GetNetworkInsightsAnalysisExplanationDestinationVpcResult',
    'GetNetworkInsightsAnalysisExplanationElasticLoadBalancerListenerResult',
    'GetNetworkInsightsAnalysisExplanationIngressRouteTableResult',
    'GetNetworkInsightsAnalysisExplanationInternetGatewayResult',
    'GetNetworkInsightsAnalysisExplanationLoadBalancerTargetGroupResult',
    'GetNetworkInsightsAnalysisExplanationNatGatewayResult',
    'GetNetworkInsightsAnalysisExplanationNetworkInterfaceResult',
    'GetNetworkInsightsAnalysisExplanationPortRangeResult',
    'GetNetworkInsightsAnalysisExplanationPrefixListResult',
    'GetNetworkInsightsAnalysisExplanationRouteTableResult',
    'GetNetworkInsightsAnalysisExplanationRouteTableRouteResult',
    'GetNetworkInsightsAnalysisExplanationSecurityGroupResult',
    'GetNetworkInsightsAnalysisExplanationSecurityGroupRuleResult',
    'GetNetworkInsightsAnalysisExplanationSecurityGroupRulePortRangeResult',
    'GetNetworkInsightsAnalysisExplanationSourceVpcResult',
    'GetNetworkInsightsAnalysisExplanationSubnetResult',
    'GetNetworkInsightsAnalysisExplanationSubnetRouteTableResult',
    'GetNetworkInsightsAnalysisExplanationTransitGatewayResult',
    'GetNetworkInsightsAnalysisExplanationTransitGatewayAttachmentResult',
    'GetNetworkInsightsAnalysisExplanationTransitGatewayRouteTableResult',
    'GetNetworkInsightsAnalysisExplanationTransitGatewayRouteTableRouteResult',
    'GetNetworkInsightsAnalysisExplanationVpcResult',
    'GetNetworkInsightsAnalysisExplanationVpcEndpointResult',
    'GetNetworkInsightsAnalysisExplanationVpcPeeringConnectionResult',
    'GetNetworkInsightsAnalysisExplanationVpnConnectionResult',
    'GetNetworkInsightsAnalysisExplanationVpnGatewayResult',
    'GetNetworkInsightsAnalysisFilterResult',
    'GetNetworkInsightsAnalysisForwardPathComponentResult',
    'GetNetworkInsightsAnalysisForwardPathComponentAclRuleResult',
    'GetNetworkInsightsAnalysisForwardPathComponentAclRulePortRangeResult',
    'GetNetworkInsightsAnalysisForwardPathComponentAdditionalDetailResult',
    'GetNetworkInsightsAnalysisForwardPathComponentAdditionalDetailComponentResult',
    'GetNetworkInsightsAnalysisForwardPathComponentAttachedToResult',
    'GetNetworkInsightsAnalysisForwardPathComponentComponentResult',
    'GetNetworkInsightsAnalysisForwardPathComponentDestinationVpcResult',
    'GetNetworkInsightsAnalysisForwardPathComponentInboundHeaderResult',
    'GetNetworkInsightsAnalysisForwardPathComponentInboundHeaderDestinationPortRangeResult',
    'GetNetworkInsightsAnalysisForwardPathComponentInboundHeaderSourcePortRangeResult',
    'GetNetworkInsightsAnalysisForwardPathComponentOutboundHeaderResult',
    'GetNetworkInsightsAnalysisForwardPathComponentOutboundHeaderDestinationPortRangeResult',
    'GetNetworkInsightsAnalysisForwardPathComponentOutboundHeaderSourcePortRangeResult',
    'GetNetworkInsightsAnalysisForwardPathComponentRouteTableRouteResult',
    'GetNetworkInsightsAnalysisForwardPathComponentSecurityGroupRuleResult',
    'GetNetworkInsightsAnalysisForwardPathComponentSecurityGroupRulePortRangeResult',
    'GetNetworkInsightsAnalysisForwardPathComponentSourceVpcResult',
    'GetNetworkInsightsAnalysisForwardPathComponentSubnetResult',
    'GetNetworkInsightsAnalysisForwardPathComponentTransitGatewayResult',
    'GetNetworkInsightsAnalysisForwardPathComponentTransitGatewayRouteTableRouteResult',
    'GetNetworkInsightsAnalysisForwardPathComponentVpcResult',
    'GetNetworkInsightsAnalysisReturnPathComponentResult',
    'GetNetworkInsightsAnalysisReturnPathComponentAclRuleResult',
    'GetNetworkInsightsAnalysisReturnPathComponentAclRulePortRangeResult',
    'GetNetworkInsightsAnalysisReturnPathComponentAdditionalDetailResult',
    'GetNetworkInsightsAnalysisReturnPathComponentAdditionalDetailComponentResult',
    'GetNetworkInsightsAnalysisReturnPathComponentAttachedToResult',
    'GetNetworkInsightsAnalysisReturnPathComponentComponentResult',
    'GetNetworkInsightsAnalysisReturnPathComponentDestinationVpcResult',
    'GetNetworkInsightsAnalysisReturnPathComponentInboundHeaderResult',
    'GetNetworkInsightsAnalysisReturnPathComponentInboundHeaderDestinationPortRangeResult',
    'GetNetworkInsightsAnalysisReturnPathComponentInboundHeaderSourcePortRangeResult',
    'GetNetworkInsightsAnalysisReturnPathComponentOutboundHeaderResult',
    'GetNetworkInsightsAnalysisReturnPathComponentOutboundHeaderDestinationPortRangeResult',
    'GetNetworkInsightsAnalysisReturnPathComponentOutboundHeaderSourcePortRangeResult',
    'GetNetworkInsightsAnalysisReturnPathComponentRouteTableRouteResult',
    'GetNetworkInsightsAnalysisReturnPathComponentSecurityGroupRuleResult',
    'GetNetworkInsightsAnalysisReturnPathComponentSecurityGroupRulePortRangeResult',
    'GetNetworkInsightsAnalysisReturnPathComponentSourceVpcResult',
    'GetNetworkInsightsAnalysisReturnPathComponentSubnetResult',
    'GetNetworkInsightsAnalysisReturnPathComponentTransitGatewayResult',
    'GetNetworkInsightsAnalysisReturnPathComponentTransitGatewayRouteTableRouteResult',
    'GetNetworkInsightsAnalysisReturnPathComponentVpcResult',
    'GetNetworkInsightsPathFilterResult',
    'GetNetworkInsightsPathFilterAtDestinationResult',
    'GetNetworkInsightsPathFilterAtDestinationDestinationPortRangeResult',
    'GetNetworkInsightsPathFilterAtDestinationSourcePortRangeResult',
    'GetNetworkInsightsPathFilterAtSourceResult',
    'GetNetworkInsightsPathFilterAtSourceDestinationPortRangeResult',
    'GetNetworkInsightsPathFilterAtSourceSourcePortRangeResult',
    'GetNetworkInterfaceAssociationResult',
    'GetNetworkInterfaceAttachmentResult',
    'GetNetworkInterfaceFilterResult',
    'GetNetworkInterfacesFilterResult',
    'GetPrefixListFilterResult',
    'GetPublicIpv4PoolPoolAddressRangeResult',
    'GetPublicIpv4PoolsFilterResult',
    'GetRouteTableAssociationResult',
    'GetRouteTableFilterResult',
    'GetRouteTableRouteResult',
    'GetRouteTablesFilterResult',
    'GetSecurityGroupFilterResult',
    'GetSecurityGroupsFilterResult',
    'GetSpotPriceFilterResult',
    'GetSubnetFilterResult',
    'GetSubnetsFilterResult',
    'GetTransitGatewayRouteTablesFilterResult',
    'GetVpcCidrBlockAssociationResult',
    'GetVpcDhcpOptionsFilterResult',
    'GetVpcEndpointDnsEntryResult',
    'GetVpcEndpointDnsOptionResult',
    'GetVpcEndpointFilterResult',
    'GetVpcEndpointServiceFilterResult',
    'GetVpcFilterResult',
    'GetVpcIpamOperatingRegionResult',
    'GetVpcIpamPoolCidrsFilterResult',
    'GetVpcIpamPoolCidrsIpamPoolCidrResult',
    'GetVpcIpamPoolFilterResult',
    'GetVpcIpamPoolsFilterResult',
    'GetVpcIpamPoolsIpamPoolResult',
    'GetVpcIpamsFilterResult',
    'GetVpcIpamsIpamResult',
    'GetVpcIpamsIpamOperatingRegionResult',
    'GetVpcPeeringConnectionCidrBlockSetResult',
    'GetVpcPeeringConnectionFilterResult',
    'GetVpcPeeringConnectionIpv6CidrBlockSetResult',
    'GetVpcPeeringConnectionPeerCidrBlockSetResult',
    'GetVpcPeeringConnectionPeerIpv6CidrBlockSetResult',
    'GetVpcPeeringConnectionsFilterResult',
    'GetVpcsFilterResult',
    'GetVpnGatewayFilterResult',
]

@pulumi.output_type
class AmiCopyEbsBlockDevice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "deviceName":
            suggest = "device_name"
        elif key == "outpostArn":
            suggest = "outpost_arn"
        elif key == "snapshotId":
            suggest = "snapshot_id"
        elif key == "volumeSize":
            suggest = "volume_size"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AmiCopyEbsBlockDevice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AmiCopyEbsBlockDevice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AmiCopyEbsBlockDevice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delete_on_termination: Optional[_builtins.bool] = None,
                 device_name: Optional[_builtins.str] = None,
                 encrypted: Optional[_builtins.bool] = None,
                 iops: Optional[_builtins.int] = None,
                 outpost_arn: Optional[_builtins.str] = None,
                 snapshot_id: Optional[_builtins.str] = None,
                 throughput: Optional[_builtins.int] = None,
                 volume_size: Optional[_builtins.int] = None,
                 volume_type: Optional[_builtins.str] = None):
        """
        :param _builtins.bool delete_on_termination: Boolean controlling whether the EBS volumes created to
               support each created instance will be deleted once that instance is terminated.
        :param _builtins.str device_name: Path at which the device is exposed to created instances.
        :param _builtins.bool encrypted: Boolean controlling whether the created EBS volumes will be encrypted. Can't be used with `snapshot_id`.
        :param _builtins.int iops: Number of I/O operations per second the
               created volumes will support.
        :param _builtins.str outpost_arn: ARN of the Outpost on which the snapshot is stored.
               
               > **Note:** You can specify `encrypted` or `snapshot_id` but not both.
        :param _builtins.str snapshot_id: ID of an EBS snapshot that will be used to initialize the created
               EBS volumes. If set, the `volume_size` attribute must be at least as large as the referenced
               snapshot.
        :param _builtins.int throughput: Throughput that the EBS volume supports, in MiB/s. Only valid for `volume_type` of `gp3`.
        :param _builtins.int volume_size: Size of created volumes in GiB.
               If `snapshot_id` is set and `volume_size` is omitted then the volume will have the same size
               as the selected snapshot.
        :param _builtins.str volume_type: Type of EBS volume to create. Can be `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1` or `st1` (Default: `standard`).
        """
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if outpost_arn is not None:
            pulumi.set(__self__, "outpost_arn", outpost_arn)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[_builtins.bool]:
        """
        Boolean controlling whether the EBS volumes created to
        support each created instance will be deleted once that instance is terminated.
        """
        return pulumi.get(self, "delete_on_termination")

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[_builtins.str]:
        """
        Path at which the device is exposed to created instances.
        """
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter
    def encrypted(self) -> Optional[_builtins.bool]:
        """
        Boolean controlling whether the created EBS volumes will be encrypted. Can't be used with `snapshot_id`.
        """
        return pulumi.get(self, "encrypted")

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[_builtins.int]:
        """
        Number of I/O operations per second the
        created volumes will support.
        """
        return pulumi.get(self, "iops")

    @_builtins.property
    @pulumi.getter(name="outpostArn")
    def outpost_arn(self) -> Optional[_builtins.str]:
        """
        ARN of the Outpost on which the snapshot is stored.

        > **Note:** You can specify `encrypted` or `snapshot_id` but not both.
        """
        return pulumi.get(self, "outpost_arn")

    @_builtins.property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[_builtins.str]:
        """
        ID of an EBS snapshot that will be used to initialize the created
        EBS volumes. If set, the `volume_size` attribute must be at least as large as the referenced
        snapshot.
        """
        return pulumi.get(self, "snapshot_id")

    @_builtins.property
    @pulumi.getter
    def throughput(self) -> Optional[_builtins.int]:
        """
        Throughput that the EBS volume supports, in MiB/s. Only valid for `volume_type` of `gp3`.
        """
        return pulumi.get(self, "throughput")

    @_builtins.property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[_builtins.int]:
        """
        Size of created volumes in GiB.
        If `snapshot_id` is set and `volume_size` is omitted then the volume will have the same size
        as the selected snapshot.
        """
        return pulumi.get(self, "volume_size")

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[_builtins.str]:
        """
        Type of EBS volume to create. Can be `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1` or `st1` (Default: `standard`).
        """
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class AmiCopyEphemeralBlockDevice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "virtualName":
            suggest = "virtual_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AmiCopyEphemeralBlockDevice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AmiCopyEphemeralBlockDevice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AmiCopyEphemeralBlockDevice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_name: Optional[_builtins.str] = None,
                 virtual_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str device_name: Path at which the device is exposed to created instances.
        :param _builtins.str virtual_name: Name for the ephemeral device, of the form "ephemeralN" where
               *N* is a volume number starting from zero.
        """
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if virtual_name is not None:
            pulumi.set(__self__, "virtual_name", virtual_name)

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[_builtins.str]:
        """
        Path at which the device is exposed to created instances.
        """
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> Optional[_builtins.str]:
        """
        Name for the ephemeral device, of the form "ephemeralN" where
        *N* is a volume number starting from zero.
        """
        return pulumi.get(self, "virtual_name")


@pulumi.output_type
class AmiEbsBlockDevice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "outpostArn":
            suggest = "outpost_arn"
        elif key == "snapshotId":
            suggest = "snapshot_id"
        elif key == "volumeSize":
            suggest = "volume_size"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AmiEbsBlockDevice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AmiEbsBlockDevice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AmiEbsBlockDevice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_name: _builtins.str,
                 delete_on_termination: Optional[_builtins.bool] = None,
                 encrypted: Optional[_builtins.bool] = None,
                 iops: Optional[_builtins.int] = None,
                 outpost_arn: Optional[_builtins.str] = None,
                 snapshot_id: Optional[_builtins.str] = None,
                 throughput: Optional[_builtins.int] = None,
                 volume_size: Optional[_builtins.int] = None,
                 volume_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str device_name: Path at which the device is exposed to created instances.
        :param _builtins.bool delete_on_termination: Boolean controlling whether the EBS volumes created to
               support each created instance will be deleted once that instance is terminated.
        :param _builtins.bool encrypted: Boolean controlling whether the created EBS volumes will be encrypted. Can't be used with `snapshot_id`.
        :param _builtins.int iops: Number of I/O operations per second the
               created volumes will support.
        :param _builtins.str outpost_arn: ARN of the Outpost on which the snapshot is stored.
               
               > **Note:** You can specify `encrypted` or `snapshot_id` but not both.
        :param _builtins.str snapshot_id: ID of an EBS snapshot that will be used to initialize the created
               EBS volumes. If set, the `volume_size` attribute must be at least as large as the referenced
               snapshot.
        :param _builtins.int throughput: Throughput that the EBS volume supports, in MiB/s. Only valid for `volume_type` of `gp3`.
        :param _builtins.int volume_size: Size of created volumes in GiB.
               If `snapshot_id` is set and `volume_size` is omitted then the volume will have the same size
               as the selected snapshot.
        :param _builtins.str volume_type: Type of EBS volume to create. Can be `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1` or `st1` (Default: `standard`).
        """
        pulumi.set(__self__, "device_name", device_name)
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if outpost_arn is not None:
            pulumi.set(__self__, "outpost_arn", outpost_arn)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> _builtins.str:
        """
        Path at which the device is exposed to created instances.
        """
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[_builtins.bool]:
        """
        Boolean controlling whether the EBS volumes created to
        support each created instance will be deleted once that instance is terminated.
        """
        return pulumi.get(self, "delete_on_termination")

    @_builtins.property
    @pulumi.getter
    def encrypted(self) -> Optional[_builtins.bool]:
        """
        Boolean controlling whether the created EBS volumes will be encrypted. Can't be used with `snapshot_id`.
        """
        return pulumi.get(self, "encrypted")

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[_builtins.int]:
        """
        Number of I/O operations per second the
        created volumes will support.
        """
        return pulumi.get(self, "iops")

    @_builtins.property
    @pulumi.getter(name="outpostArn")
    def outpost_arn(self) -> Optional[_builtins.str]:
        """
        ARN of the Outpost on which the snapshot is stored.

        > **Note:** You can specify `encrypted` or `snapshot_id` but not both.
        """
        return pulumi.get(self, "outpost_arn")

    @_builtins.property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[_builtins.str]:
        """
        ID of an EBS snapshot that will be used to initialize the created
        EBS volumes. If set, the `volume_size` attribute must be at least as large as the referenced
        snapshot.
        """
        return pulumi.get(self, "snapshot_id")

    @_builtins.property
    @pulumi.getter
    def throughput(self) -> Optional[_builtins.int]:
        """
        Throughput that the EBS volume supports, in MiB/s. Only valid for `volume_type` of `gp3`.
        """
        return pulumi.get(self, "throughput")

    @_builtins.property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[_builtins.int]:
        """
        Size of created volumes in GiB.
        If `snapshot_id` is set and `volume_size` is omitted then the volume will have the same size
        as the selected snapshot.
        """
        return pulumi.get(self, "volume_size")

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[_builtins.str]:
        """
        Type of EBS volume to create. Can be `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1` or `st1` (Default: `standard`).
        """
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class AmiEphemeralBlockDevice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "virtualName":
            suggest = "virtual_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AmiEphemeralBlockDevice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AmiEphemeralBlockDevice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AmiEphemeralBlockDevice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_name: _builtins.str,
                 virtual_name: _builtins.str):
        """
        :param _builtins.str device_name: Path at which the device is exposed to created instances.
        :param _builtins.str virtual_name: Name for the ephemeral device, of the form "ephemeralN" where
               *N* is a volume number starting from zero.
        """
        pulumi.set(__self__, "device_name", device_name)
        pulumi.set(__self__, "virtual_name", virtual_name)

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> _builtins.str:
        """
        Path at which the device is exposed to created instances.
        """
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> _builtins.str:
        """
        Name for the ephemeral device, of the form "ephemeralN" where
        *N* is a volume number starting from zero.
        """
        return pulumi.get(self, "virtual_name")


@pulumi.output_type
class AmiFromInstanceEbsBlockDevice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "deviceName":
            suggest = "device_name"
        elif key == "outpostArn":
            suggest = "outpost_arn"
        elif key == "snapshotId":
            suggest = "snapshot_id"
        elif key == "volumeSize":
            suggest = "volume_size"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AmiFromInstanceEbsBlockDevice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AmiFromInstanceEbsBlockDevice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AmiFromInstanceEbsBlockDevice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delete_on_termination: Optional[_builtins.bool] = None,
                 device_name: Optional[_builtins.str] = None,
                 encrypted: Optional[_builtins.bool] = None,
                 iops: Optional[_builtins.int] = None,
                 outpost_arn: Optional[_builtins.str] = None,
                 snapshot_id: Optional[_builtins.str] = None,
                 throughput: Optional[_builtins.int] = None,
                 volume_size: Optional[_builtins.int] = None,
                 volume_type: Optional[_builtins.str] = None):
        """
        :param _builtins.bool delete_on_termination: Boolean controlling whether the EBS volumes created to
               support each created instance will be deleted once that instance is terminated.
        :param _builtins.str device_name: Path at which the device is exposed to created instances.
        :param _builtins.bool encrypted: Boolean controlling whether the created EBS volumes will be encrypted. Can't be used with `snapshot_id`.
        :param _builtins.int iops: Number of I/O operations per second the
               created volumes will support.
        :param _builtins.str outpost_arn: ARN of the Outpost on which the snapshot is stored.
               
               > **Note:** You can specify `encrypted` or `snapshot_id` but not both.
        :param _builtins.str snapshot_id: ID of an EBS snapshot that will be used to initialize the created
               EBS volumes. If set, the `volume_size` attribute must be at least as large as the referenced
               snapshot.
        :param _builtins.int throughput: Throughput that the EBS volume supports, in MiB/s. Only valid for `volume_type` of `gp3`.
        :param _builtins.int volume_size: Size of created volumes in GiB.
               If `snapshot_id` is set and `volume_size` is omitted then the volume will have the same size
               as the selected snapshot.
        :param _builtins.str volume_type: Type of EBS volume to create. Can be `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1` or `st1` (Default: `standard`).
        """
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if outpost_arn is not None:
            pulumi.set(__self__, "outpost_arn", outpost_arn)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[_builtins.bool]:
        """
        Boolean controlling whether the EBS volumes created to
        support each created instance will be deleted once that instance is terminated.
        """
        return pulumi.get(self, "delete_on_termination")

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[_builtins.str]:
        """
        Path at which the device is exposed to created instances.
        """
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter
    def encrypted(self) -> Optional[_builtins.bool]:
        """
        Boolean controlling whether the created EBS volumes will be encrypted. Can't be used with `snapshot_id`.
        """
        return pulumi.get(self, "encrypted")

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[_builtins.int]:
        """
        Number of I/O operations per second the
        created volumes will support.
        """
        return pulumi.get(self, "iops")

    @_builtins.property
    @pulumi.getter(name="outpostArn")
    def outpost_arn(self) -> Optional[_builtins.str]:
        """
        ARN of the Outpost on which the snapshot is stored.

        > **Note:** You can specify `encrypted` or `snapshot_id` but not both.
        """
        return pulumi.get(self, "outpost_arn")

    @_builtins.property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[_builtins.str]:
        """
        ID of an EBS snapshot that will be used to initialize the created
        EBS volumes. If set, the `volume_size` attribute must be at least as large as the referenced
        snapshot.
        """
        return pulumi.get(self, "snapshot_id")

    @_builtins.property
    @pulumi.getter
    def throughput(self) -> Optional[_builtins.int]:
        """
        Throughput that the EBS volume supports, in MiB/s. Only valid for `volume_type` of `gp3`.
        """
        return pulumi.get(self, "throughput")

    @_builtins.property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[_builtins.int]:
        """
        Size of created volumes in GiB.
        If `snapshot_id` is set and `volume_size` is omitted then the volume will have the same size
        as the selected snapshot.
        """
        return pulumi.get(self, "volume_size")

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[_builtins.str]:
        """
        Type of EBS volume to create. Can be `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1` or `st1` (Default: `standard`).
        """
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class AmiFromInstanceEphemeralBlockDevice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "virtualName":
            suggest = "virtual_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AmiFromInstanceEphemeralBlockDevice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AmiFromInstanceEphemeralBlockDevice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AmiFromInstanceEphemeralBlockDevice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_name: Optional[_builtins.str] = None,
                 virtual_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str device_name: Path at which the device is exposed to created instances.
        :param _builtins.str virtual_name: Name for the ephemeral device, of the form "ephemeralN" where
               *N* is a volume number starting from zero.
        """
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if virtual_name is not None:
            pulumi.set(__self__, "virtual_name", virtual_name)

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[_builtins.str]:
        """
        Path at which the device is exposed to created instances.
        """
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> Optional[_builtins.str]:
        """
        Name for the ephemeral device, of the form "ephemeralN" where
        *N* is a volume number starting from zero.
        """
        return pulumi.get(self, "virtual_name")


@pulumi.output_type
class CapacityBlockReservationTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[_builtins.str] = None):
        """
        :param _builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")


@pulumi.output_type
class DefaultCreditSpecificationTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[_builtins.str] = None,
                 update: Optional[_builtins.str] = None):
        """
        :param _builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param _builtins.str update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")


@pulumi.output_type
class DefaultNetworkAclEgress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromPort":
            suggest = "from_port"
        elif key == "ruleNo":
            suggest = "rule_no"
        elif key == "toPort":
            suggest = "to_port"
        elif key == "cidrBlock":
            suggest = "cidr_block"
        elif key == "icmpCode":
            suggest = "icmp_code"
        elif key == "icmpType":
            suggest = "icmp_type"
        elif key == "ipv6CidrBlock":
            suggest = "ipv6_cidr_block"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DefaultNetworkAclEgress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DefaultNetworkAclEgress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DefaultNetworkAclEgress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: _builtins.str,
                 from_port: _builtins.int,
                 protocol: _builtins.str,
                 rule_no: _builtins.int,
                 to_port: _builtins.int,
                 cidr_block: Optional[_builtins.str] = None,
                 icmp_code: Optional[_builtins.int] = None,
                 icmp_type: Optional[_builtins.int] = None,
                 ipv6_cidr_block: Optional[_builtins.str] = None):
        """
        :param _builtins.str action: The action to take.
        :param _builtins.int from_port: The from port to match.
        :param _builtins.str protocol: The protocol to match. If using the -1 'all' protocol, you must specify a from and to port of 0.
        :param _builtins.int rule_no: The rule number. Used for ordering.
        :param _builtins.int to_port: The to port to match.
               
               The following arguments are optional:
        :param _builtins.str cidr_block: The CIDR block to match. This must be a valid network mask.
        :param _builtins.int icmp_code: The ICMP type code to be used. Default 0.
        :param _builtins.int icmp_type: The ICMP type to be used. Default 0.
        :param _builtins.str ipv6_cidr_block: The IPv6 CIDR block.
               
               > For more information on ICMP types and codes, see [Internet Control Message Protocol (ICMP) Parameters](https://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml).
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "from_port", from_port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "rule_no", rule_no)
        pulumi.set(__self__, "to_port", to_port)
        if cidr_block is not None:
            pulumi.set(__self__, "cidr_block", cidr_block)
        if icmp_code is not None:
            pulumi.set(__self__, "icmp_code", icmp_code)
        if icmp_type is not None:
            pulumi.set(__self__, "icmp_type", icmp_type)
        if ipv6_cidr_block is not None:
            pulumi.set(__self__, "ipv6_cidr_block", ipv6_cidr_block)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        """
        The action to take.
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> _builtins.int:
        """
        The from port to match.
        """
        return pulumi.get(self, "from_port")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        """
        The protocol to match. If using the -1 'all' protocol, you must specify a from and to port of 0.
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="ruleNo")
    def rule_no(self) -> _builtins.int:
        """
        The rule number. Used for ordering.
        """
        return pulumi.get(self, "rule_no")

    @_builtins.property
    @pulumi.getter(name="toPort")
    def to_port(self) -> _builtins.int:
        """
        The to port to match.

        The following arguments are optional:
        """
        return pulumi.get(self, "to_port")

    @_builtins.property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> Optional[_builtins.str]:
        """
        The CIDR block to match. This must be a valid network mask.
        """
        return pulumi.get(self, "cidr_block")

    @_builtins.property
    @pulumi.getter(name="icmpCode")
    def icmp_code(self) -> Optional[_builtins.int]:
        """
        The ICMP type code to be used. Default 0.
        """
        return pulumi.get(self, "icmp_code")

    @_builtins.property
    @pulumi.getter(name="icmpType")
    def icmp_type(self) -> Optional[_builtins.int]:
        """
        The ICMP type to be used. Default 0.
        """
        return pulumi.get(self, "icmp_type")

    @_builtins.property
    @pulumi.getter(name="ipv6CidrBlock")
    def ipv6_cidr_block(self) -> Optional[_builtins.str]:
        """
        The IPv6 CIDR block.

        > For more information on ICMP types and codes, see [Internet Control Message Protocol (ICMP) Parameters](https://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml).
        """
        return pulumi.get(self, "ipv6_cidr_block")


@pulumi.output_type
class DefaultNetworkAclIngress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromPort":
            suggest = "from_port"
        elif key == "ruleNo":
            suggest = "rule_no"
        elif key == "toPort":
            suggest = "to_port"
        elif key == "cidrBlock":
            suggest = "cidr_block"
        elif key == "icmpCode":
            suggest = "icmp_code"
        elif key == "icmpType":
            suggest = "icmp_type"
        elif key == "ipv6CidrBlock":
            suggest = "ipv6_cidr_block"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DefaultNetworkAclIngress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DefaultNetworkAclIngress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DefaultNetworkAclIngress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: _builtins.str,
                 from_port: _builtins.int,
                 protocol: _builtins.str,
                 rule_no: _builtins.int,
                 to_port: _builtins.int,
                 cidr_block: Optional[_builtins.str] = None,
                 icmp_code: Optional[_builtins.int] = None,
                 icmp_type: Optional[_builtins.int] = None,
                 ipv6_cidr_block: Optional[_builtins.str] = None):
        """
        :param _builtins.str action: The action to take.
        :param _builtins.int from_port: The from port to match.
        :param _builtins.str protocol: The protocol to match. If using the -1 'all' protocol, you must specify a from and to port of 0.
        :param _builtins.int rule_no: The rule number. Used for ordering.
        :param _builtins.int to_port: The to port to match.
               
               The following arguments are optional:
        :param _builtins.str cidr_block: The CIDR block to match. This must be a valid network mask.
        :param _builtins.int icmp_code: The ICMP type code to be used. Default 0.
        :param _builtins.int icmp_type: The ICMP type to be used. Default 0.
        :param _builtins.str ipv6_cidr_block: The IPv6 CIDR block.
               
               > For more information on ICMP types and codes, see [Internet Control Message Protocol (ICMP) Parameters](https://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml).
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "from_port", from_port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "rule_no", rule_no)
        pulumi.set(__self__, "to_port", to_port)
        if cidr_block is not None:
            pulumi.set(__self__, "cidr_block", cidr_block)
        if icmp_code is not None:
            pulumi.set(__self__, "icmp_code", icmp_code)
        if icmp_type is not None:
            pulumi.set(__self__, "icmp_type", icmp_type)
        if ipv6_cidr_block is not None:
            pulumi.set(__self__, "ipv6_cidr_block", ipv6_cidr_block)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        """
        The action to take.
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> _builtins.int:
        """
        The from port to match.
        """
        return pulumi.get(self, "from_port")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        """
        The protocol to match. If using the -1 'all' protocol, you must specify a from and to port of 0.
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="ruleNo")
    def rule_no(self) -> _builtins.int:
        """
        The rule number. Used for ordering.
        """
        return pulumi.get(self, "rule_no")

    @_builtins.property
    @pulumi.getter(name="toPort")
    def to_port(self) -> _builtins.int:
        """
        The to port to match.

        The following arguments are optional:
        """
        return pulumi.get(self, "to_port")

    @_builtins.property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> Optional[_builtins.str]:
        """
        The CIDR block to match. This must be a valid network mask.
        """
        return pulumi.get(self, "cidr_block")

    @_builtins.property
    @pulumi.getter(name="icmpCode")
    def icmp_code(self) -> Optional[_builtins.int]:
        """
        The ICMP type code to be used. Default 0.
        """
        return pulumi.get(self, "icmp_code")

    @_builtins.property
    @pulumi.getter(name="icmpType")
    def icmp_type(self) -> Optional[_builtins.int]:
        """
        The ICMP type to be used. Default 0.
        """
        return pulumi.get(self, "icmp_type")

    @_builtins.property
    @pulumi.getter(name="ipv6CidrBlock")
    def ipv6_cidr_block(self) -> Optional[_builtins.str]:
        """
        The IPv6 CIDR block.

        > For more information on ICMP types and codes, see [Internet Control Message Protocol (ICMP) Parameters](https://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml).
        """
        return pulumi.get(self, "ipv6_cidr_block")


@pulumi.output_type
class DefaultRouteTableRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cidrBlock":
            suggest = "cidr_block"
        elif key == "coreNetworkArn":
            suggest = "core_network_arn"
        elif key == "destinationPrefixListId":
            suggest = "destination_prefix_list_id"
        elif key == "egressOnlyGatewayId":
            suggest = "egress_only_gateway_id"
        elif key == "gatewayId":
            suggest = "gateway_id"
        elif key == "instanceId":
            suggest = "instance_id"
        elif key == "ipv6CidrBlock":
            suggest = "ipv6_cidr_block"
        elif key == "natGatewayId":
            suggest = "nat_gateway_id"
        elif key == "networkInterfaceId":
            suggest = "network_interface_id"
        elif key == "transitGatewayId":
            suggest = "transit_gateway_id"
        elif key == "vpcEndpointId":
            suggest = "vpc_endpoint_id"
        elif key == "vpcPeeringConnectionId":
            suggest = "vpc_peering_connection_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DefaultRouteTableRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DefaultRouteTableRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DefaultRouteTableRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cidr_block: Optional[_builtins.str] = None,
                 core_network_arn: Optional[_builtins.str] = None,
                 destination_prefix_list_id: Optional[_builtins.str] = None,
                 egress_only_gateway_id: Optional[_builtins.str] = None,
                 gateway_id: Optional[_builtins.str] = None,
                 instance_id: Optional[_builtins.str] = None,
                 ipv6_cidr_block: Optional[_builtins.str] = None,
                 nat_gateway_id: Optional[_builtins.str] = None,
                 network_interface_id: Optional[_builtins.str] = None,
                 transit_gateway_id: Optional[_builtins.str] = None,
                 vpc_endpoint_id: Optional[_builtins.str] = None,
                 vpc_peering_connection_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str cidr_block: The CIDR block of the route.
        :param _builtins.str core_network_arn: The Amazon Resource Name (ARN) of a core network.
        :param _builtins.str destination_prefix_list_id: The ID of a managed prefix list destination of the route.
               
               One of the following target arguments must be supplied:
        :param _builtins.str egress_only_gateway_id: Identifier of a VPC Egress Only Internet Gateway.
        :param _builtins.str gateway_id: Identifier of a VPC internet gateway or a virtual private gateway.
        :param _builtins.str instance_id: Identifier of an EC2 instance.
        :param _builtins.str ipv6_cidr_block: The Ipv6 CIDR block of the route
        :param _builtins.str nat_gateway_id: Identifier of a VPC NAT gateway.
        :param _builtins.str network_interface_id: Identifier of an EC2 network interface.
        :param _builtins.str transit_gateway_id: Identifier of an EC2 Transit Gateway.
        :param _builtins.str vpc_endpoint_id: Identifier of a VPC Endpoint. This route must be removed prior to VPC Endpoint deletion.
        :param _builtins.str vpc_peering_connection_id: Identifier of a VPC peering connection.
               
               Note that the default route, mapping the VPC's CIDR block to "local", is created implicitly and cannot be specified.
        """
        if cidr_block is not None:
            pulumi.set(__self__, "cidr_block", cidr_block)
        if core_network_arn is not None:
            pulumi.set(__self__, "core_network_arn", core_network_arn)
        if destination_prefix_list_id is not None:
            pulumi.set(__self__, "destination_prefix_list_id", destination_prefix_list_id)
        if egress_only_gateway_id is not None:
            pulumi.set(__self__, "egress_only_gateway_id", egress_only_gateway_id)
        if gateway_id is not None:
            pulumi.set(__self__, "gateway_id", gateway_id)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if ipv6_cidr_block is not None:
            pulumi.set(__self__, "ipv6_cidr_block", ipv6_cidr_block)
        if nat_gateway_id is not None:
            pulumi.set(__self__, "nat_gateway_id", nat_gateway_id)
        if network_interface_id is not None:
            pulumi.set(__self__, "network_interface_id", network_interface_id)
        if transit_gateway_id is not None:
            pulumi.set(__self__, "transit_gateway_id", transit_gateway_id)
        if vpc_endpoint_id is not None:
            pulumi.set(__self__, "vpc_endpoint_id", vpc_endpoint_id)
        if vpc_peering_connection_id is not None:
            pulumi.set(__self__, "vpc_peering_connection_id", vpc_peering_connection_id)

    @_builtins.property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> Optional[_builtins.str]:
        """
        The CIDR block of the route.
        """
        return pulumi.get(self, "cidr_block")

    @_builtins.property
    @pulumi.getter(name="coreNetworkArn")
    def core_network_arn(self) -> Optional[_builtins.str]:
        """
        The Amazon Resource Name (ARN) of a core network.
        """
        return pulumi.get(self, "core_network_arn")

    @_builtins.property
    @pulumi.getter(name="destinationPrefixListId")
    def destination_prefix_list_id(self) -> Optional[_builtins.str]:
        """
        The ID of a managed prefix list destination of the route.

        One of the following target arguments must be supplied:
        """
        return pulumi.get(self, "destination_prefix_list_id")

    @_builtins.property
    @pulumi.getter(name="egressOnlyGatewayId")
    def egress_only_gateway_id(self) -> Optional[_builtins.str]:
        """
        Identifier of a VPC Egress Only Internet Gateway.
        """
        return pulumi.get(self, "egress_only_gateway_id")

    @_builtins.property
    @pulumi.getter(name="gatewayId")
    def gateway_id(self) -> Optional[_builtins.str]:
        """
        Identifier of a VPC internet gateway or a virtual private gateway.
        """
        return pulumi.get(self, "gateway_id")

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[_builtins.str]:
        """
        Identifier of an EC2 instance.
        """
        return pulumi.get(self, "instance_id")

    @_builtins.property
    @pulumi.getter(name="ipv6CidrBlock")
    def ipv6_cidr_block(self) -> Optional[_builtins.str]:
        """
        The Ipv6 CIDR block of the route
        """
        return pulumi.get(self, "ipv6_cidr_block")

    @_builtins.property
    @pulumi.getter(name="natGatewayId")
    def nat_gateway_id(self) -> Optional[_builtins.str]:
        """
        Identifier of a VPC NAT gateway.
        """
        return pulumi.get(self, "nat_gateway_id")

    @_builtins.property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> Optional[_builtins.str]:
        """
        Identifier of an EC2 network interface.
        """
        return pulumi.get(self, "network_interface_id")

    @_builtins.property
    @pulumi.getter(name="transitGatewayId")
    def transit_gateway_id(self) -> Optional[_builtins.str]:
        """
        Identifier of an EC2 Transit Gateway.
        """
        return pulumi.get(self, "transit_gateway_id")

    @_builtins.property
    @pulumi.getter(name="vpcEndpointId")
    def vpc_endpoint_id(self) -> Optional[_builtins.str]:
        """
        Identifier of a VPC Endpoint. This route must be removed prior to VPC Endpoint deletion.
        """
        return pulumi.get(self, "vpc_endpoint_id")

    @_builtins.property
    @pulumi.getter(name="vpcPeeringConnectionId")
    def vpc_peering_connection_id(self) -> Optional[_builtins.str]:
        """
        Identifier of a VPC peering connection.

        Note that the default route, mapping the VPC's CIDR block to "local", is created implicitly and cannot be specified.
        """
        return pulumi.get(self, "vpc_peering_connection_id")


@pulumi.output_type
class DefaultSecurityGroupEgress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromPort":
            suggest = "from_port"
        elif key == "toPort":
            suggest = "to_port"
        elif key == "cidrBlocks":
            suggest = "cidr_blocks"
        elif key == "ipv6CidrBlocks":
            suggest = "ipv6_cidr_blocks"
        elif key == "prefixListIds":
            suggest = "prefix_list_ids"
        elif key == "securityGroups":
            suggest = "security_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DefaultSecurityGroupEgress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DefaultSecurityGroupEgress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DefaultSecurityGroupEgress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_port: _builtins.int,
                 protocol: _builtins.str,
                 to_port: _builtins.int,
                 cidr_blocks: Optional[Sequence[_builtins.str]] = None,
                 description: Optional[_builtins.str] = None,
                 ipv6_cidr_blocks: Optional[Sequence[_builtins.str]] = None,
                 prefix_list_ids: Optional[Sequence[_builtins.str]] = None,
                 security_groups: Optional[Sequence[_builtins.str]] = None,
                 self: Optional[_builtins.bool] = None):
        """
        :param _builtins.int from_port: Start port (or ICMP type number if protocol is `icmp`)
        :param _builtins.str protocol: Protocol. If you select a protocol of "-1" (semantically equivalent to `all`, which is not a valid value here), you must specify a `from_port` and `to_port` equal to `0`. If not `icmp`, `tcp`, `udp`, or `-1` use the [protocol number](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml).
        :param _builtins.int to_port: End range port (or ICMP code if protocol is `icmp`).
        :param Sequence[_builtins.str] cidr_blocks: List of CIDR blocks.
        :param _builtins.str description: Description of this rule.
        :param Sequence[_builtins.str] ipv6_cidr_blocks: List of IPv6 CIDR blocks.
        :param Sequence[_builtins.str] prefix_list_ids: List of prefix list IDs (for allowing access to VPC endpoints)
        :param Sequence[_builtins.str] security_groups: List of security groups. A group name can be used relative to the default VPC. Otherwise, group ID.
        :param _builtins.bool self: Whether the security group itself will be added as a source to this egress rule.
        """
        pulumi.set(__self__, "from_port", from_port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "to_port", to_port)
        if cidr_blocks is not None:
            pulumi.set(__self__, "cidr_blocks", cidr_blocks)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if ipv6_cidr_blocks is not None:
            pulumi.set(__self__, "ipv6_cidr_blocks", ipv6_cidr_blocks)
        if prefix_list_ids is not None:
            pulumi.set(__self__, "prefix_list_ids", prefix_list_ids)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if self is not None:
            pulumi.set(__self__, "self", self)

    @_builtins.property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> _builtins.int:
        """
        Start port (or ICMP type number if protocol is `icmp`)
        """
        return pulumi.get(self, "from_port")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        """
        Protocol. If you select a protocol of "-1" (semantically equivalent to `all`, which is not a valid value here), you must specify a `from_port` and `to_port` equal to `0`. If not `icmp`, `tcp`, `udp`, or `-1` use the [protocol number](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml).
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="toPort")
    def to_port(self) -> _builtins.int:
        """
        End range port (or ICMP code if protocol is `icmp`).
        """
        return pulumi.get(self, "to_port")

    @_builtins.property
    @pulumi.getter(name="cidrBlocks")
    def cidr_blocks(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of CIDR blocks.
        """
        return pulumi.get(self, "cidr_blocks")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of this rule.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="ipv6CidrBlocks")
    def ipv6_cidr_blocks(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of IPv6 CIDR blocks.
        """
        return pulumi.get(self, "ipv6_cidr_blocks")

    @_builtins.property
    @pulumi.getter(name="prefixListIds")
    def prefix_list_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of prefix list IDs (for allowing access to VPC endpoints)
        """
        return pulumi.get(self, "prefix_list_ids")

    @_builtins.property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of security groups. A group name can be used relative to the default VPC. Otherwise, group ID.
        """
        return pulumi.get(self, "security_groups")

    @_builtins.property
    @pulumi.getter
    def self(self) -> Optional[_builtins.bool]:
        """
        Whether the security group itself will be added as a source to this egress rule.
        """
        return pulumi.get(self, "self")


@pulumi.output_type
class DefaultSecurityGroupIngress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromPort":
            suggest = "from_port"
        elif key == "toPort":
            suggest = "to_port"
        elif key == "cidrBlocks":
            suggest = "cidr_blocks"
        elif key == "ipv6CidrBlocks":
            suggest = "ipv6_cidr_blocks"
        elif key == "prefixListIds":
            suggest = "prefix_list_ids"
        elif key == "securityGroups":
            suggest = "security_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DefaultSecurityGroupIngress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DefaultSecurityGroupIngress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DefaultSecurityGroupIngress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_port: _builtins.int,
                 protocol: _builtins.str,
                 to_port: _builtins.int,
                 cidr_blocks: Optional[Sequence[_builtins.str]] = None,
                 description: Optional[_builtins.str] = None,
                 ipv6_cidr_blocks: Optional[Sequence[_builtins.str]] = None,
                 prefix_list_ids: Optional[Sequence[_builtins.str]] = None,
                 security_groups: Optional[Sequence[_builtins.str]] = None,
                 self: Optional[_builtins.bool] = None):
        """
        :param _builtins.int from_port: Start port (or ICMP type number if protocol is `icmp`)
        :param _builtins.str protocol: Protocol. If you select a protocol of "-1" (semantically equivalent to `all`, which is not a valid value here), you must specify a `from_port` and `to_port` equal to `0`. If not `icmp`, `tcp`, `udp`, or `-1` use the [protocol number](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml).
        :param _builtins.int to_port: End range port (or ICMP code if protocol is `icmp`).
        :param Sequence[_builtins.str] cidr_blocks: List of CIDR blocks.
        :param _builtins.str description: Description of the security group.
        :param Sequence[_builtins.str] ipv6_cidr_blocks: List of IPv6 CIDR blocks.
        :param Sequence[_builtins.str] prefix_list_ids: List of prefix list IDs (for allowing access to VPC endpoints)
        :param Sequence[_builtins.str] security_groups: List of security groups. A group name can be used relative to the default VPC. Otherwise, group ID.
        :param _builtins.bool self: Whether the security group itself will be added as a source to this egress rule.
        """
        pulumi.set(__self__, "from_port", from_port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "to_port", to_port)
        if cidr_blocks is not None:
            pulumi.set(__self__, "cidr_blocks", cidr_blocks)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if ipv6_cidr_blocks is not None:
            pulumi.set(__self__, "ipv6_cidr_blocks", ipv6_cidr_blocks)
        if prefix_list_ids is not None:
            pulumi.set(__self__, "prefix_list_ids", prefix_list_ids)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if self is not None:
            pulumi.set(__self__, "self", self)

    @_builtins.property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> _builtins.int:
        """
        Start port (or ICMP type number if protocol is `icmp`)
        """
        return pulumi.get(self, "from_port")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        """
        Protocol. If you select a protocol of "-1" (semantically equivalent to `all`, which is not a valid value here), you must specify a `from_port` and `to_port` equal to `0`. If not `icmp`, `tcp`, `udp`, or `-1` use the [protocol number](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml).
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="toPort")
    def to_port(self) -> _builtins.int:
        """
        End range port (or ICMP code if protocol is `icmp`).
        """
        return pulumi.get(self, "to_port")

    @_builtins.property
    @pulumi.getter(name="cidrBlocks")
    def cidr_blocks(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of CIDR blocks.
        """
        return pulumi.get(self, "cidr_blocks")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of the security group.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="ipv6CidrBlocks")
    def ipv6_cidr_blocks(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of IPv6 CIDR blocks.
        """
        return pulumi.get(self, "ipv6_cidr_blocks")

    @_builtins.property
    @pulumi.getter(name="prefixListIds")
    def prefix_list_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of prefix list IDs (for allowing access to VPC endpoints)
        """
        return pulumi.get(self, "prefix_list_ids")

    @_builtins.property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of security groups. A group name can be used relative to the default VPC. Otherwise, group ID.
        """
        return pulumi.get(self, "security_groups")

    @_builtins.property
    @pulumi.getter
    def self(self) -> Optional[_builtins.bool]:
        """
        Whether the security group itself will be added as a source to this egress rule.
        """
        return pulumi.get(self, "self")


@pulumi.output_type
class EipDomainNameTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[_builtins.str] = None,
                 delete: Optional[_builtins.str] = None,
                 update: Optional[_builtins.str] = None):
        """
        :param _builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param _builtins.str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param _builtins.str update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")


@pulumi.output_type
class FleetFleetInstanceSet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceIds":
            suggest = "instance_ids"
        elif key == "instanceType":
            suggest = "instance_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FleetFleetInstanceSet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FleetFleetInstanceSet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FleetFleetInstanceSet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_ids: Optional[Sequence[_builtins.str]] = None,
                 instance_type: Optional[_builtins.str] = None,
                 lifecycle: Optional[_builtins.str] = None,
                 platform: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] instance_ids: The IDs of the instances.
        :param _builtins.str instance_type: The instance type.
        :param _builtins.str lifecycle: Indicates if the instance that was launched is a Spot Instance or On-Demand Instance.
        :param _builtins.str platform: The value is `Windows` for Windows instances. Otherwise, the value is blank.
        """
        if instance_ids is not None:
            pulumi.set(__self__, "instance_ids", instance_ids)
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if lifecycle is not None:
            pulumi.set(__self__, "lifecycle", lifecycle)
        if platform is not None:
            pulumi.set(__self__, "platform", platform)

    @_builtins.property
    @pulumi.getter(name="instanceIds")
    def instance_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        The IDs of the instances.
        """
        return pulumi.get(self, "instance_ids")

    @_builtins.property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[_builtins.str]:
        """
        The instance type.
        """
        return pulumi.get(self, "instance_type")

    @_builtins.property
    @pulumi.getter
    def lifecycle(self) -> Optional[_builtins.str]:
        """
        Indicates if the instance that was launched is a Spot Instance or On-Demand Instance.
        """
        return pulumi.get(self, "lifecycle")

    @_builtins.property
    @pulumi.getter
    def platform(self) -> Optional[_builtins.str]:
        """
        The value is `Windows` for Windows instances. Otherwise, the value is blank.
        """
        return pulumi.get(self, "platform")


@pulumi.output_type
class FleetLaunchTemplateConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "launchTemplateSpecification":
            suggest = "launch_template_specification"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FleetLaunchTemplateConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FleetLaunchTemplateConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FleetLaunchTemplateConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 launch_template_specification: Optional['outputs.FleetLaunchTemplateConfigLaunchTemplateSpecification'] = None,
                 overrides: Optional[Sequence['outputs.FleetLaunchTemplateConfigOverride']] = None):
        """
        :param 'FleetLaunchTemplateConfigLaunchTemplateSpecificationArgs' launch_template_specification: Nested argument containing EC2 Launch Template to use. Defined below.
        :param Sequence['FleetLaunchTemplateConfigOverrideArgs'] overrides: Nested argument(s) containing parameters to override the same parameters in the Launch Template. Defined below.
        """
        if launch_template_specification is not None:
            pulumi.set(__self__, "launch_template_specification", launch_template_specification)
        if overrides is not None:
            pulumi.set(__self__, "overrides", overrides)

    @_builtins.property
    @pulumi.getter(name="launchTemplateSpecification")
    def launch_template_specification(self) -> Optional['outputs.FleetLaunchTemplateConfigLaunchTemplateSpecification']:
        """
        Nested argument containing EC2 Launch Template to use. Defined below.
        """
        return pulumi.get(self, "launch_template_specification")

    @_builtins.property
    @pulumi.getter
    def overrides(self) -> Optional[Sequence['outputs.FleetLaunchTemplateConfigOverride']]:
        """
        Nested argument(s) containing parameters to override the same parameters in the Launch Template. Defined below.
        """
        return pulumi.get(self, "overrides")


@pulumi.output_type
class FleetLaunchTemplateConfigLaunchTemplateSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "launchTemplateId":
            suggest = "launch_template_id"
        elif key == "launchTemplateName":
            suggest = "launch_template_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FleetLaunchTemplateConfigLaunchTemplateSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FleetLaunchTemplateConfigLaunchTemplateSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FleetLaunchTemplateConfigLaunchTemplateSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 version: _builtins.str,
                 launch_template_id: Optional[_builtins.str] = None,
                 launch_template_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str version: The launch template version number, `$Latest`, or `$Default.`
        :param _builtins.str launch_template_id: The ID of the launch template.
        :param _builtins.str launch_template_name: The name of the launch template.
        """
        pulumi.set(__self__, "version", version)
        if launch_template_id is not None:
            pulumi.set(__self__, "launch_template_id", launch_template_id)
        if launch_template_name is not None:
            pulumi.set(__self__, "launch_template_name", launch_template_name)

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        The launch template version number, `$Latest`, or `$Default.`
        """
        return pulumi.get(self, "version")

    @_builtins.property
    @pulumi.getter(name="launchTemplateId")
    def launch_template_id(self) -> Optional[_builtins.str]:
        """
        The ID of the launch template.
        """
        return pulumi.get(self, "launch_template_id")

    @_builtins.property
    @pulumi.getter(name="launchTemplateName")
    def launch_template_name(self) -> Optional[_builtins.str]:
        """
        The name of the launch template.
        """
        return pulumi.get(self, "launch_template_name")


@pulumi.output_type
class FleetLaunchTemplateConfigOverride(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "instanceRequirements":
            suggest = "instance_requirements"
        elif key == "instanceType":
            suggest = "instance_type"
        elif key == "maxPrice":
            suggest = "max_price"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "weightedCapacity":
            suggest = "weighted_capacity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FleetLaunchTemplateConfigOverride. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FleetLaunchTemplateConfigOverride.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FleetLaunchTemplateConfigOverride.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_zone: Optional[_builtins.str] = None,
                 instance_requirements: Optional['outputs.FleetLaunchTemplateConfigOverrideInstanceRequirements'] = None,
                 instance_type: Optional[_builtins.str] = None,
                 max_price: Optional[_builtins.str] = None,
                 priority: Optional[_builtins.float] = None,
                 subnet_id: Optional[_builtins.str] = None,
                 weighted_capacity: Optional[_builtins.float] = None):
        """
        :param _builtins.str availability_zone: Availability Zone in which to launch the instances.
        :param 'FleetLaunchTemplateConfigOverrideInstanceRequirementsArgs' instance_requirements: Override the instance type in the Launch Template with instance types that satisfy the requirements.
        :param _builtins.str instance_type: Instance type.
        :param _builtins.str max_price: Maximum price per unit hour that you are willing to pay for a Spot Instance.
        :param _builtins.float priority: Priority for the launch template override. If `on_demand_options` `allocation_strategy` is set to `prioritized`, EC2 Fleet uses priority to determine which launch template override to use first in fulfilling On-Demand capacity. The highest priority is launched first. The lower the number, the higher the priority. If no number is set, the launch template override has the lowest priority. Valid values are whole numbers starting at 0.
        :param _builtins.str subnet_id: ID of the subnet in which to launch the instances.
        :param _builtins.float weighted_capacity: Number of units provided by the specified instance type.
        """
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if instance_requirements is not None:
            pulumi.set(__self__, "instance_requirements", instance_requirements)
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if max_price is not None:
            pulumi.set(__self__, "max_price", max_price)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if weighted_capacity is not None:
            pulumi.set(__self__, "weighted_capacity", weighted_capacity)

    @_builtins.property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[_builtins.str]:
        """
        Availability Zone in which to launch the instances.
        """
        return pulumi.get(self, "availability_zone")

    @_builtins.property
    @pulumi.getter(name="instanceRequirements")
    def instance_requirements(self) -> Optional['outputs.FleetLaunchTemplateConfigOverrideInstanceRequirements']:
        """
        Override the instance type in the Launch Template with instance types that satisfy the requirements.
        """
        return pulumi.get(self, "instance_requirements")

    @_builtins.property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[_builtins.str]:
        """
        Instance type.
        """
        return pulumi.get(self, "instance_type")

    @_builtins.property
    @pulumi.getter(name="maxPrice")
    def max_price(self) -> Optional[_builtins.str]:
        """
        Maximum price per unit hour that you are willing to pay for a Spot Instance.
        """
        return pulumi.get(self, "max_price")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[_builtins.float]:
        """
        Priority for the launch template override. If `on_demand_options` `allocation_strategy` is set to `prioritized`, EC2 Fleet uses priority to determine which launch template override to use first in fulfilling On-Demand capacity. The highest priority is launched first. The lower the number, the higher the priority. If no number is set, the launch template override has the lowest priority. Valid values are whole numbers starting at 0.
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[_builtins.str]:
        """
        ID of the subnet in which to launch the instances.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter(name="weightedCapacity")
    def weighted_capacity(self) -> Optional[_builtins.float]:
        """
        Number of units provided by the specified instance type.
        """
        return pulumi.get(self, "weighted_capacity")


@pulumi.output_type
class FleetLaunchTemplateConfigOverrideInstanceRequirements(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "memoryMib":
            suggest = "memory_mib"
        elif key == "vcpuCount":
            suggest = "vcpu_count"
        elif key == "acceleratorCount":
            suggest = "accelerator_count"
        elif key == "acceleratorManufacturers":
            suggest = "accelerator_manufacturers"
        elif key == "acceleratorNames":
            suggest = "accelerator_names"
        elif key == "acceleratorTotalMemoryMib":
            suggest = "accelerator_total_memory_mib"
        elif key == "acceleratorTypes":
            suggest = "accelerator_types"
        elif key == "allowedInstanceTypes":
            suggest = "allowed_instance_types"
        elif key == "bareMetal":
            suggest = "bare_metal"
        elif key == "baselineEbsBandwidthMbps":
            suggest = "baseline_ebs_bandwidth_mbps"
        elif key == "burstablePerformance":
            suggest = "burstable_performance"
        elif key == "cpuManufacturers":
            suggest = "cpu_manufacturers"
        elif key == "excludedInstanceTypes":
            suggest = "excluded_instance_types"
        elif key == "instanceGenerations":
            suggest = "instance_generations"
        elif key == "localStorage":
            suggest = "local_storage"
        elif key == "localStorageTypes":
            suggest = "local_storage_types"
        elif key == "maxSpotPriceAsPercentageOfOptimalOnDemandPrice":
            suggest = "max_spot_price_as_percentage_of_optimal_on_demand_price"
        elif key == "memoryGibPerVcpu":
            suggest = "memory_gib_per_vcpu"
        elif key == "networkBandwidthGbps":
            suggest = "network_bandwidth_gbps"
        elif key == "networkInterfaceCount":
            suggest = "network_interface_count"
        elif key == "onDemandMaxPricePercentageOverLowestPrice":
            suggest = "on_demand_max_price_percentage_over_lowest_price"
        elif key == "requireHibernateSupport":
            suggest = "require_hibernate_support"
        elif key == "spotMaxPricePercentageOverLowestPrice":
            suggest = "spot_max_price_percentage_over_lowest_price"
        elif key == "totalLocalStorageGb":
            suggest = "total_local_storage_gb"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FleetLaunchTemplateConfigOverrideInstanceRequirements. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FleetLaunchTemplateConfigOverrideInstanceRequirements.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FleetLaunchTemplateConfigOverrideInstanceRequirements.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 memory_mib: 'outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsMemoryMib',
                 vcpu_count: 'outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsVcpuCount',
                 accelerator_count: Optional['outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorCount'] = None,
                 accelerator_manufacturers: Optional[Sequence[_builtins.str]] = None,
                 accelerator_names: Optional[Sequence[_builtins.str]] = None,
                 accelerator_total_memory_mib: Optional['outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorTotalMemoryMib'] = None,
                 accelerator_types: Optional[Sequence[_builtins.str]] = None,
                 allowed_instance_types: Optional[Sequence[_builtins.str]] = None,
                 bare_metal: Optional[_builtins.str] = None,
                 baseline_ebs_bandwidth_mbps: Optional['outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsBaselineEbsBandwidthMbps'] = None,
                 burstable_performance: Optional[_builtins.str] = None,
                 cpu_manufacturers: Optional[Sequence[_builtins.str]] = None,
                 excluded_instance_types: Optional[Sequence[_builtins.str]] = None,
                 instance_generations: Optional[Sequence[_builtins.str]] = None,
                 local_storage: Optional[_builtins.str] = None,
                 local_storage_types: Optional[Sequence[_builtins.str]] = None,
                 max_spot_price_as_percentage_of_optimal_on_demand_price: Optional[_builtins.int] = None,
                 memory_gib_per_vcpu: Optional['outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsMemoryGibPerVcpu'] = None,
                 network_bandwidth_gbps: Optional['outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsNetworkBandwidthGbps'] = None,
                 network_interface_count: Optional['outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsNetworkInterfaceCount'] = None,
                 on_demand_max_price_percentage_over_lowest_price: Optional[_builtins.int] = None,
                 require_hibernate_support: Optional[_builtins.bool] = None,
                 spot_max_price_percentage_over_lowest_price: Optional[_builtins.int] = None,
                 total_local_storage_gb: Optional['outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsTotalLocalStorageGb'] = None):
        """
        :param 'FleetLaunchTemplateConfigOverrideInstanceRequirementsMemoryMibArgs' memory_mib: The minimum and maximum amount of memory per vCPU, in GiB. Default is no minimum or maximum limits.
        :param 'FleetLaunchTemplateConfigOverrideInstanceRequirementsVcpuCountArgs' vcpu_count: Block describing the minimum and maximum number of vCPUs. Default is no maximum.
        :param 'FleetLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorCountArgs' accelerator_count: Block describing the minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips). Default is no minimum or maximum limits.
        :param Sequence[_builtins.str] accelerator_manufacturers: List of accelerator manufacturer names. Default is any manufacturer.
        :param Sequence[_builtins.str] accelerator_names: List of accelerator names. Default is any acclerator.
        :param 'FleetLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorTotalMemoryMibArgs' accelerator_total_memory_mib: Block describing the minimum and maximum total memory of the accelerators. Default is no minimum or maximum.
        :param Sequence[_builtins.str] accelerator_types: The accelerator types that must be on the instance type. Default is any accelerator type.
        :param Sequence[_builtins.str] allowed_instance_types: The instance types to apply your specified attributes against. All other instance types are ignored, even if they match your specified attributes. You can use strings with one or more wild cards,represented by an asterisk (\\*). The following are examples: `c5*`, `m5a.*`, `r*`, `*3*`. For example, if you specify `c5*`, you are excluding the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*`, you are excluding all the M5a instance types, but not the M5n instance types. Maximum of 400 entries in the list; each entry is limited to 30 characters. Default is no excluded instance types. Default is any instance type.
               
               If you specify `AllowedInstanceTypes`, you can't specify `ExcludedInstanceTypes`.
        :param _builtins.str bare_metal: Indicate whether bare metal instace types should be `included`, `excluded`, or `required`. Default is `excluded`.
        :param 'FleetLaunchTemplateConfigOverrideInstanceRequirementsBaselineEbsBandwidthMbpsArgs' baseline_ebs_bandwidth_mbps: Block describing the minimum and maximum baseline EBS bandwidth, in Mbps. Default is no minimum or maximum.
        :param _builtins.str burstable_performance: Indicates whether burstable performance T instance types are `included`, `excluded`, or `required`. Default is `excluded`.
        :param Sequence[_builtins.str] cpu_manufacturers: The CPU manufacturers to include. Default is any manufacturer.
               > **NOTE:** Don't confuse the CPU hardware manufacturer with the CPU hardware architecture. Instances will be launched with a compatible CPU architecture based on the Amazon Machine Image (AMI) that you specify in your launch template.
        :param Sequence[_builtins.str] excluded_instance_types: The instance types to exclude. You can use strings with one or more wild cards, represented by an asterisk (\\*). The following are examples: `c5*`, `m5a.*`, `r*`, `*3*`. For example, if you specify `c5*`, you are excluding the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*`, you are excluding all the M5a instance types, but not the M5n instance types. Maximum of 400 entries in the list; each entry is limited to 30 characters. Default is no excluded instance types.
               
               If you specify `AllowedInstanceTypes`, you can't specify `ExcludedInstanceTypes`.
        :param Sequence[_builtins.str] instance_generations: Indicates whether current or previous generation instance types are included. The current generation instance types are recommended for use. Valid values are `current` and `previous`. Default is `current` and `previous` generation instance types.
        :param _builtins.str local_storage: Indicate whether instance types with local storage volumes are `included`, `excluded`, or `required`. Default is `included`.
        :param Sequence[_builtins.str] local_storage_types: List of local storage type names. Valid values are `hdd` and `ssd`. Default any storage type.
        :param _builtins.int max_spot_price_as_percentage_of_optimal_on_demand_price: The price protection threshold for Spot Instances. This is the maximum you’ll pay for a Spot Instance, expressed as a percentage higher than the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price is higher than your threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as 999999. Conflicts with `spot_max_price_percentage_over_lowest_price`
        :param 'FleetLaunchTemplateConfigOverrideInstanceRequirementsMemoryGibPerVcpuArgs' memory_gib_per_vcpu: Block describing the minimum and maximum amount of memory (GiB) per vCPU. Default is no minimum or maximum.
        :param 'FleetLaunchTemplateConfigOverrideInstanceRequirementsNetworkBandwidthGbpsArgs' network_bandwidth_gbps: The minimum and maximum amount of network bandwidth, in gigabits per second (Gbps). Default is No minimum or maximum.
        :param 'FleetLaunchTemplateConfigOverrideInstanceRequirementsNetworkInterfaceCountArgs' network_interface_count: Block describing the minimum and maximum number of network interfaces. Default is no minimum or maximum.
        :param _builtins.int on_demand_max_price_percentage_over_lowest_price: The price protection threshold for On-Demand Instances. This is the maximum you’ll pay for an On-Demand Instance, expressed as a percentage higher than the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price is higher than your threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as 999999. Default is 20.
               
               If you set `target_capacity_unit_type` to `vcpu` or `memory-mib`, the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price.
        :param _builtins.bool require_hibernate_support: Indicate whether instance types must support On-Demand Instance Hibernation, either `true` or `false`. Default is `false`.
        :param _builtins.int spot_max_price_percentage_over_lowest_price: The price protection threshold for Spot Instances. This is the maximum you’ll pay for a Spot Instance, expressed as a percentage higher than the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price is higher than your threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as 999999. Default is 100. Conflicts with `max_spot_price_as_percentage_of_optimal_on_demand_price`
               
               If you set DesiredCapacityType to vcpu or memory-mib, the price protection threshold is applied based on the per vCPU or per memory price instead of the per instance price.
        :param 'FleetLaunchTemplateConfigOverrideInstanceRequirementsTotalLocalStorageGbArgs' total_local_storage_gb: Block describing the minimum and maximum total local storage (GB). Default is no minimum or maximum.
        """
        pulumi.set(__self__, "memory_mib", memory_mib)
        pulumi.set(__self__, "vcpu_count", vcpu_count)
        if accelerator_count is not None:
            pulumi.set(__self__, "accelerator_count", accelerator_count)
        if accelerator_manufacturers is not None:
            pulumi.set(__self__, "accelerator_manufacturers", accelerator_manufacturers)
        if accelerator_names is not None:
            pulumi.set(__self__, "accelerator_names", accelerator_names)
        if accelerator_total_memory_mib is not None:
            pulumi.set(__self__, "accelerator_total_memory_mib", accelerator_total_memory_mib)
        if accelerator_types is not None:
            pulumi.set(__self__, "accelerator_types", accelerator_types)
        if allowed_instance_types is not None:
            pulumi.set(__self__, "allowed_instance_types", allowed_instance_types)
        if bare_metal is not None:
            pulumi.set(__self__, "bare_metal", bare_metal)
        if baseline_ebs_bandwidth_mbps is not None:
            pulumi.set(__self__, "baseline_ebs_bandwidth_mbps", baseline_ebs_bandwidth_mbps)
        if burstable_performance is not None:
            pulumi.set(__self__, "burstable_performance", burstable_performance)
        if cpu_manufacturers is not None:
            pulumi.set(__self__, "cpu_manufacturers", cpu_manufacturers)
        if excluded_instance_types is not None:
            pulumi.set(__self__, "excluded_instance_types", excluded_instance_types)
        if instance_generations is not None:
            pulumi.set(__self__, "instance_generations", instance_generations)
        if local_storage is not None:
            pulumi.set(__self__, "local_storage", local_storage)
        if local_storage_types is not None:
            pulumi.set(__self__, "local_storage_types", local_storage_types)
        if max_spot_price_as_percentage_of_optimal_on_demand_price is not None:
            pulumi.set(__self__, "max_spot_price_as_percentage_of_optimal_on_demand_price", max_spot_price_as_percentage_of_optimal_on_demand_price)
        if memory_gib_per_vcpu is not None:
            pulumi.set(__self__, "memory_gib_per_vcpu", memory_gib_per_vcpu)
        if network_bandwidth_gbps is not None:
            pulumi.set(__self__, "network_bandwidth_gbps", network_bandwidth_gbps)
        if network_interface_count is not None:
            pulumi.set(__self__, "network_interface_count", network_interface_count)
        if on_demand_max_price_percentage_over_lowest_price is not None:
            pulumi.set(__self__, "on_demand_max_price_percentage_over_lowest_price", on_demand_max_price_percentage_over_lowest_price)
        if require_hibernate_support is not None:
            pulumi.set(__self__, "require_hibernate_support", require_hibernate_support)
        if spot_max_price_percentage_over_lowest_price is not None:
            pulumi.set(__self__, "spot_max_price_percentage_over_lowest_price", spot_max_price_percentage_over_lowest_price)
        if total_local_storage_gb is not None:
            pulumi.set(__self__, "total_local_storage_gb", total_local_storage_gb)

    @_builtins.property
    @pulumi.getter(name="memoryMib")
    def memory_mib(self) -> 'outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsMemoryMib':
        """
        The minimum and maximum amount of memory per vCPU, in GiB. Default is no minimum or maximum limits.
        """
        return pulumi.get(self, "memory_mib")

    @_builtins.property
    @pulumi.getter(name="vcpuCount")
    def vcpu_count(self) -> 'outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsVcpuCount':
        """
        Block describing the minimum and maximum number of vCPUs. Default is no maximum.
        """
        return pulumi.get(self, "vcpu_count")

    @_builtins.property
    @pulumi.getter(name="acceleratorCount")
    def accelerator_count(self) -> Optional['outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorCount']:
        """
        Block describing the minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips). Default is no minimum or maximum limits.
        """
        return pulumi.get(self, "accelerator_count")

    @_builtins.property
    @pulumi.getter(name="acceleratorManufacturers")
    def accelerator_manufacturers(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of accelerator manufacturer names. Default is any manufacturer.
        """
        return pulumi.get(self, "accelerator_manufacturers")

    @_builtins.property
    @pulumi.getter(name="acceleratorNames")
    def accelerator_names(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of accelerator names. Default is any acclerator.
        """
        return pulumi.get(self, "accelerator_names")

    @_builtins.property
    @pulumi.getter(name="acceleratorTotalMemoryMib")
    def accelerator_total_memory_mib(self) -> Optional['outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorTotalMemoryMib']:
        """
        Block describing the minimum and maximum total memory of the accelerators. Default is no minimum or maximum.
        """
        return pulumi.get(self, "accelerator_total_memory_mib")

    @_builtins.property
    @pulumi.getter(name="acceleratorTypes")
    def accelerator_types(self) -> Optional[Sequence[_builtins.str]]:
        """
        The accelerator types that must be on the instance type. Default is any accelerator type.
        """
        return pulumi.get(self, "accelerator_types")

    @_builtins.property
    @pulumi.getter(name="allowedInstanceTypes")
    def allowed_instance_types(self) -> Optional[Sequence[_builtins.str]]:
        """
        The instance types to apply your specified attributes against. All other instance types are ignored, even if they match your specified attributes. You can use strings with one or more wild cards,represented by an asterisk (\\*). The following are examples: `c5*`, `m5a.*`, `r*`, `*3*`. For example, if you specify `c5*`, you are excluding the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*`, you are excluding all the M5a instance types, but not the M5n instance types. Maximum of 400 entries in the list; each entry is limited to 30 characters. Default is no excluded instance types. Default is any instance type.

        If you specify `AllowedInstanceTypes`, you can't specify `ExcludedInstanceTypes`.
        """
        return pulumi.get(self, "allowed_instance_types")

    @_builtins.property
    @pulumi.getter(name="bareMetal")
    def bare_metal(self) -> Optional[_builtins.str]:
        """
        Indicate whether bare metal instace types should be `included`, `excluded`, or `required`. Default is `excluded`.
        """
        return pulumi.get(self, "bare_metal")

    @_builtins.property
    @pulumi.getter(name="baselineEbsBandwidthMbps")
    def baseline_ebs_bandwidth_mbps(self) -> Optional['outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsBaselineEbsBandwidthMbps']:
        """
        Block describing the minimum and maximum baseline EBS bandwidth, in Mbps. Default is no minimum or maximum.
        """
        return pulumi.get(self, "baseline_ebs_bandwidth_mbps")

    @_builtins.property
    @pulumi.getter(name="burstablePerformance")
    def burstable_performance(self) -> Optional[_builtins.str]:
        """
        Indicates whether burstable performance T instance types are `included`, `excluded`, or `required`. Default is `excluded`.
        """
        return pulumi.get(self, "burstable_performance")

    @_builtins.property
    @pulumi.getter(name="cpuManufacturers")
    def cpu_manufacturers(self) -> Optional[Sequence[_builtins.str]]:
        """
        The CPU manufacturers to include. Default is any manufacturer.
        > **NOTE:** Don't confuse the CPU hardware manufacturer with the CPU hardware architecture. Instances will be launched with a compatible CPU architecture based on the Amazon Machine Image (AMI) that you specify in your launch template.
        """
        return pulumi.get(self, "cpu_manufacturers")

    @_builtins.property
    @pulumi.getter(name="excludedInstanceTypes")
    def excluded_instance_types(self) -> Optional[Sequence[_builtins.str]]:
        """
        The instance types to exclude. You can use strings with one or more wild cards, represented by an asterisk (\\*). The following are examples: `c5*`, `m5a.*`, `r*`, `*3*`. For example, if you specify `c5*`, you are excluding the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*`, you are excluding all the M5a instance types, but not the M5n instance types. Maximum of 400 entries in the list; each entry is limited to 30 characters. Default is no excluded instance types.

        If you specify `AllowedInstanceTypes`, you can't specify `ExcludedInstanceTypes`.
        """
        return pulumi.get(self, "excluded_instance_types")

    @_builtins.property
    @pulumi.getter(name="instanceGenerations")
    def instance_generations(self) -> Optional[Sequence[_builtins.str]]:
        """
        Indicates whether current or previous generation instance types are included. The current generation instance types are recommended for use. Valid values are `current` and `previous`. Default is `current` and `previous` generation instance types.
        """
        return pulumi.get(self, "instance_generations")

    @_builtins.property
    @pulumi.getter(name="localStorage")
    def local_storage(self) -> Optional[_builtins.str]:
        """
        Indicate whether instance types with local storage volumes are `included`, `excluded`, or `required`. Default is `included`.
        """
        return pulumi.get(self, "local_storage")

    @_builtins.property
    @pulumi.getter(name="localStorageTypes")
    def local_storage_types(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of local storage type names. Valid values are `hdd` and `ssd`. Default any storage type.
        """
        return pulumi.get(self, "local_storage_types")

    @_builtins.property
    @pulumi.getter(name="maxSpotPriceAsPercentageOfOptimalOnDemandPrice")
    def max_spot_price_as_percentage_of_optimal_on_demand_price(self) -> Optional[_builtins.int]:
        """
        The price protection threshold for Spot Instances. This is the maximum you’ll pay for a Spot Instance, expressed as a percentage higher than the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price is higher than your threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as 999999. Conflicts with `spot_max_price_percentage_over_lowest_price`
        """
        return pulumi.get(self, "max_spot_price_as_percentage_of_optimal_on_demand_price")

    @_builtins.property
    @pulumi.getter(name="memoryGibPerVcpu")
    def memory_gib_per_vcpu(self) -> Optional['outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsMemoryGibPerVcpu']:
        """
        Block describing the minimum and maximum amount of memory (GiB) per vCPU. Default is no minimum or maximum.
        """
        return pulumi.get(self, "memory_gib_per_vcpu")

    @_builtins.property
    @pulumi.getter(name="networkBandwidthGbps")
    def network_bandwidth_gbps(self) -> Optional['outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsNetworkBandwidthGbps']:
        """
        The minimum and maximum amount of network bandwidth, in gigabits per second (Gbps). Default is No minimum or maximum.
        """
        return pulumi.get(self, "network_bandwidth_gbps")

    @_builtins.property
    @pulumi.getter(name="networkInterfaceCount")
    def network_interface_count(self) -> Optional['outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsNetworkInterfaceCount']:
        """
        Block describing the minimum and maximum number of network interfaces. Default is no minimum or maximum.
        """
        return pulumi.get(self, "network_interface_count")

    @_builtins.property
    @pulumi.getter(name="onDemandMaxPricePercentageOverLowestPrice")
    def on_demand_max_price_percentage_over_lowest_price(self) -> Optional[_builtins.int]:
        """
        The price protection threshold for On-Demand Instances. This is the maximum you’ll pay for an On-Demand Instance, expressed as a percentage higher than the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price is higher than your threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as 999999. Default is 20.

        If you set `target_capacity_unit_type` to `vcpu` or `memory-mib`, the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price.
        """
        return pulumi.get(self, "on_demand_max_price_percentage_over_lowest_price")

    @_builtins.property
    @pulumi.getter(name="requireHibernateSupport")
    def require_hibernate_support(self) -> Optional[_builtins.bool]:
        """
        Indicate whether instance types must support On-Demand Instance Hibernation, either `true` or `false`. Default is `false`.
        """
        return pulumi.get(self, "require_hibernate_support")

    @_builtins.property
    @pulumi.getter(name="spotMaxPricePercentageOverLowestPrice")
    def spot_max_price_percentage_over_lowest_price(self) -> Optional[_builtins.int]:
        """
        The price protection threshold for Spot Instances. This is the maximum you’ll pay for a Spot Instance, expressed as a percentage higher than the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price is higher than your threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as 999999. Default is 100. Conflicts with `max_spot_price_as_percentage_of_optimal_on_demand_price`

        If you set DesiredCapacityType to vcpu or memory-mib, the price protection threshold is applied based on the per vCPU or per memory price instead of the per instance price.
        """
        return pulumi.get(self, "spot_max_price_percentage_over_lowest_price")

    @_builtins.property
    @pulumi.getter(name="totalLocalStorageGb")
    def total_local_storage_gb(self) -> Optional['outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsTotalLocalStorageGb']:
        """
        Block describing the minimum and maximum total local storage (GB). Default is no minimum or maximum.
        """
        return pulumi.get(self, "total_local_storage_gb")


@pulumi.output_type
class FleetLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorCount(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.int] = None,
                 min: Optional[_builtins.int] = None):
        """
        :param _builtins.int max: Maximum. Set to `0` to exclude instance types with accelerators.
        :param _builtins.int min: Minimum.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.int]:
        """
        Maximum. Set to `0` to exclude instance types with accelerators.
        """
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.int]:
        """
        Minimum.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class FleetLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorTotalMemoryMib(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.int] = None,
                 min: Optional[_builtins.int] = None):
        """
        :param _builtins.int max: The maximum amount of accelerator memory, in MiB. To specify no maximum limit, omit this parameter.
        :param _builtins.int min: The minimum amount of accelerator memory, in MiB. To specify no minimum limit, omit this parameter.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.int]:
        """
        The maximum amount of accelerator memory, in MiB. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.int]:
        """
        The minimum amount of accelerator memory, in MiB. To specify no minimum limit, omit this parameter.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class FleetLaunchTemplateConfigOverrideInstanceRequirementsBaselineEbsBandwidthMbps(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.int] = None,
                 min: Optional[_builtins.int] = None):
        """
        :param _builtins.int max: The maximum baseline bandwidth, in Mbps. To specify no maximum limit, omit this parameter..
        :param _builtins.int min: The minimum baseline bandwidth, in Mbps. To specify no minimum limit, omit this parameter..
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.int]:
        """
        The maximum baseline bandwidth, in Mbps. To specify no maximum limit, omit this parameter..
        """
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.int]:
        """
        The minimum baseline bandwidth, in Mbps. To specify no minimum limit, omit this parameter..
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class FleetLaunchTemplateConfigOverrideInstanceRequirementsMemoryGibPerVcpu(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.float] = None,
                 min: Optional[_builtins.float] = None):
        """
        :param _builtins.float max: The maximum amount of memory per vCPU, in GiB. To specify no maximum limit, omit this parameter.
        :param _builtins.float min: The minimum amount of memory per vCPU, in GiB. To specify no minimum limit, omit this parameter.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.float]:
        """
        The maximum amount of memory per vCPU, in GiB. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.float]:
        """
        The minimum amount of memory per vCPU, in GiB. To specify no minimum limit, omit this parameter.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class FleetLaunchTemplateConfigOverrideInstanceRequirementsMemoryMib(dict):
    def __init__(__self__, *,
                 min: _builtins.int,
                 max: Optional[_builtins.int] = None):
        """
        :param _builtins.int min: The minimum amount of memory, in MiB. To specify no minimum limit, specify `0`.
        :param _builtins.int max: The maximum amount of memory, in MiB. To specify no maximum limit, omit this parameter.
        """
        pulumi.set(__self__, "min", min)
        if max is not None:
            pulumi.set(__self__, "max", max)

    @_builtins.property
    @pulumi.getter
    def min(self) -> _builtins.int:
        """
        The minimum amount of memory, in MiB. To specify no minimum limit, specify `0`.
        """
        return pulumi.get(self, "min")

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.int]:
        """
        The maximum amount of memory, in MiB. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")


@pulumi.output_type
class FleetLaunchTemplateConfigOverrideInstanceRequirementsNetworkBandwidthGbps(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.float] = None,
                 min: Optional[_builtins.float] = None):
        """
        :param _builtins.float max: The maximum amount of network bandwidth, in Gbps. To specify no maximum limit, omit this parameter.
        :param _builtins.float min: The minimum amount of network bandwidth, in Gbps. To specify no minimum limit, omit this parameter.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.float]:
        """
        The maximum amount of network bandwidth, in Gbps. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.float]:
        """
        The minimum amount of network bandwidth, in Gbps. To specify no minimum limit, omit this parameter.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class FleetLaunchTemplateConfigOverrideInstanceRequirementsNetworkInterfaceCount(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.int] = None,
                 min: Optional[_builtins.int] = None):
        """
        :param _builtins.int max: The maximum number of network interfaces. To specify no maximum limit, omit this parameter.
        :param _builtins.int min: The minimum number of network interfaces. To specify no minimum limit, omit this parameter.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.int]:
        """
        The maximum number of network interfaces. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.int]:
        """
        The minimum number of network interfaces. To specify no minimum limit, omit this parameter.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class FleetLaunchTemplateConfigOverrideInstanceRequirementsTotalLocalStorageGb(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.float] = None,
                 min: Optional[_builtins.float] = None):
        """
        :param _builtins.float max: The maximum amount of total local storage, in GB. To specify no maximum limit, omit this parameter.
        :param _builtins.float min: The minimum amount of total local storage, in GB. To specify no minimum limit, omit this parameter.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.float]:
        """
        The maximum amount of total local storage, in GB. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.float]:
        """
        The minimum amount of total local storage, in GB. To specify no minimum limit, omit this parameter.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class FleetLaunchTemplateConfigOverrideInstanceRequirementsVcpuCount(dict):
    def __init__(__self__, *,
                 min: _builtins.int,
                 max: Optional[_builtins.int] = None):
        """
        :param _builtins.int min: The minimum number of vCPUs. To specify no minimum limit, specify `0`.
        :param _builtins.int max: The maximum number of vCPUs. To specify no maximum limit, omit this parameter.
        """
        pulumi.set(__self__, "min", min)
        if max is not None:
            pulumi.set(__self__, "max", max)

    @_builtins.property
    @pulumi.getter
    def min(self) -> _builtins.int:
        """
        The minimum number of vCPUs. To specify no minimum limit, specify `0`.
        """
        return pulumi.get(self, "min")

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.int]:
        """
        The maximum number of vCPUs. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")


@pulumi.output_type
class FleetOnDemandOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allocationStrategy":
            suggest = "allocation_strategy"
        elif key == "capacityReservationOptions":
            suggest = "capacity_reservation_options"
        elif key == "maxTotalPrice":
            suggest = "max_total_price"
        elif key == "minTargetCapacity":
            suggest = "min_target_capacity"
        elif key == "singleAvailabilityZone":
            suggest = "single_availability_zone"
        elif key == "singleInstanceType":
            suggest = "single_instance_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FleetOnDemandOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FleetOnDemandOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FleetOnDemandOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allocation_strategy: Optional[_builtins.str] = None,
                 capacity_reservation_options: Optional['outputs.FleetOnDemandOptionsCapacityReservationOptions'] = None,
                 max_total_price: Optional[_builtins.str] = None,
                 min_target_capacity: Optional[_builtins.int] = None,
                 single_availability_zone: Optional[_builtins.bool] = None,
                 single_instance_type: Optional[_builtins.bool] = None):
        """
        :param _builtins.str allocation_strategy: The order of the launch template overrides to use in fulfilling On-Demand capacity. Valid values: `lowestPrice`, `prioritized`. Default: `lowestPrice`.
        :param 'FleetOnDemandOptionsCapacityReservationOptionsArgs' capacity_reservation_options: The strategy for using unused Capacity Reservations for fulfilling On-Demand capacity. Supported only for fleets of type `instant`.
        :param _builtins.str max_total_price: The maximum amount per hour for On-Demand Instances that you're willing to pay.
        :param _builtins.int min_target_capacity: The minimum target capacity for On-Demand Instances in the fleet. If the minimum target capacity is not reached, the fleet launches no instances. Supported only for fleets of type `instant`.
               If you specify `min_target_capacity`, at least one of the following must be specified: `single_availability_zone` or `single_instance_type`.
        :param _builtins.bool single_availability_zone: Indicates that the fleet launches all On-Demand Instances into a single Availability Zone. Supported only for fleets of type `instant`.
        :param _builtins.bool single_instance_type: Indicates that the fleet uses a single instance type to launch all On-Demand Instances in the fleet. Supported only for fleets of type `instant`.
        """
        if allocation_strategy is not None:
            pulumi.set(__self__, "allocation_strategy", allocation_strategy)
        if capacity_reservation_options is not None:
            pulumi.set(__self__, "capacity_reservation_options", capacity_reservation_options)
        if max_total_price is not None:
            pulumi.set(__self__, "max_total_price", max_total_price)
        if min_target_capacity is not None:
            pulumi.set(__self__, "min_target_capacity", min_target_capacity)
        if single_availability_zone is not None:
            pulumi.set(__self__, "single_availability_zone", single_availability_zone)
        if single_instance_type is not None:
            pulumi.set(__self__, "single_instance_type", single_instance_type)

    @_builtins.property
    @pulumi.getter(name="allocationStrategy")
    def allocation_strategy(self) -> Optional[_builtins.str]:
        """
        The order of the launch template overrides to use in fulfilling On-Demand capacity. Valid values: `lowestPrice`, `prioritized`. Default: `lowestPrice`.
        """
        return pulumi.get(self, "allocation_strategy")

    @_builtins.property
    @pulumi.getter(name="capacityReservationOptions")
    def capacity_reservation_options(self) -> Optional['outputs.FleetOnDemandOptionsCapacityReservationOptions']:
        """
        The strategy for using unused Capacity Reservations for fulfilling On-Demand capacity. Supported only for fleets of type `instant`.
        """
        return pulumi.get(self, "capacity_reservation_options")

    @_builtins.property
    @pulumi.getter(name="maxTotalPrice")
    def max_total_price(self) -> Optional[_builtins.str]:
        """
        The maximum amount per hour for On-Demand Instances that you're willing to pay.
        """
        return pulumi.get(self, "max_total_price")

    @_builtins.property
    @pulumi.getter(name="minTargetCapacity")
    def min_target_capacity(self) -> Optional[_builtins.int]:
        """
        The minimum target capacity for On-Demand Instances in the fleet. If the minimum target capacity is not reached, the fleet launches no instances. Supported only for fleets of type `instant`.
        If you specify `min_target_capacity`, at least one of the following must be specified: `single_availability_zone` or `single_instance_type`.
        """
        return pulumi.get(self, "min_target_capacity")

    @_builtins.property
    @pulumi.getter(name="singleAvailabilityZone")
    def single_availability_zone(self) -> Optional[_builtins.bool]:
        """
        Indicates that the fleet launches all On-Demand Instances into a single Availability Zone. Supported only for fleets of type `instant`.
        """
        return pulumi.get(self, "single_availability_zone")

    @_builtins.property
    @pulumi.getter(name="singleInstanceType")
    def single_instance_type(self) -> Optional[_builtins.bool]:
        """
        Indicates that the fleet uses a single instance type to launch all On-Demand Instances in the fleet. Supported only for fleets of type `instant`.
        """
        return pulumi.get(self, "single_instance_type")


@pulumi.output_type
class FleetOnDemandOptionsCapacityReservationOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "usageStrategy":
            suggest = "usage_strategy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FleetOnDemandOptionsCapacityReservationOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FleetOnDemandOptionsCapacityReservationOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FleetOnDemandOptionsCapacityReservationOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 usage_strategy: Optional[_builtins.str] = None):
        """
        :param _builtins.str usage_strategy: Indicates whether to use unused Capacity Reservations for fulfilling On-Demand capacity. Valid values: `use-capacity-reservations-first`.
        """
        if usage_strategy is not None:
            pulumi.set(__self__, "usage_strategy", usage_strategy)

    @_builtins.property
    @pulumi.getter(name="usageStrategy")
    def usage_strategy(self) -> Optional[_builtins.str]:
        """
        Indicates whether to use unused Capacity Reservations for fulfilling On-Demand capacity. Valid values: `use-capacity-reservations-first`.
        """
        return pulumi.get(self, "usage_strategy")


@pulumi.output_type
class FleetSpotOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allocationStrategy":
            suggest = "allocation_strategy"
        elif key == "instanceInterruptionBehavior":
            suggest = "instance_interruption_behavior"
        elif key == "instancePoolsToUseCount":
            suggest = "instance_pools_to_use_count"
        elif key == "maintenanceStrategies":
            suggest = "maintenance_strategies"
        elif key == "maxTotalPrice":
            suggest = "max_total_price"
        elif key == "minTargetCapacity":
            suggest = "min_target_capacity"
        elif key == "singleAvailabilityZone":
            suggest = "single_availability_zone"
        elif key == "singleInstanceType":
            suggest = "single_instance_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FleetSpotOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FleetSpotOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FleetSpotOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allocation_strategy: Optional[_builtins.str] = None,
                 instance_interruption_behavior: Optional[_builtins.str] = None,
                 instance_pools_to_use_count: Optional[_builtins.int] = None,
                 maintenance_strategies: Optional['outputs.FleetSpotOptionsMaintenanceStrategies'] = None,
                 max_total_price: Optional[_builtins.str] = None,
                 min_target_capacity: Optional[_builtins.int] = None,
                 single_availability_zone: Optional[_builtins.bool] = None,
                 single_instance_type: Optional[_builtins.bool] = None):
        """
        :param _builtins.str allocation_strategy: How to allocate the target capacity across the Spot pools. Valid values: `diversified`, `lowestPrice`, `capacity-optimized`, `capacity-optimized-prioritized` and `price-capacity-optimized`. Default: `lowestPrice`.
        :param _builtins.str instance_interruption_behavior: Behavior when a Spot Instance is interrupted. Valid values: `hibernate`, `stop`, `terminate`. Default: `terminate`.
        :param _builtins.int instance_pools_to_use_count: Number of Spot pools across which to allocate your target Spot capacity. Valid only when Spot `allocation_strategy` is set to `lowestPrice`. Default: `1`.
        :param 'FleetSpotOptionsMaintenanceStrategiesArgs' maintenance_strategies: Nested argument containing maintenance strategies for managing your Spot Instances that are at an elevated risk of being interrupted. Defined below.
        :param _builtins.str max_total_price: The maximum amount per hour for Spot Instances that you're willing to pay.
        :param _builtins.int min_target_capacity: The minimum target capacity for Spot Instances in the fleet. If the minimum target capacity is not reached, the fleet launches no instances. Supported only for fleets of type `instant`.
        :param _builtins.bool single_availability_zone: Indicates that the fleet launches all Spot Instances into a single Availability Zone. Supported only for fleets of type `instant`.
        :param _builtins.bool single_instance_type: Indicates that the fleet uses a single instance type to launch all Spot Instances in the fleet. Supported only for fleets of type `instant`.
        """
        if allocation_strategy is not None:
            pulumi.set(__self__, "allocation_strategy", allocation_strategy)
        if instance_interruption_behavior is not None:
            pulumi.set(__self__, "instance_interruption_behavior", instance_interruption_behavior)
        if instance_pools_to_use_count is not None:
            pulumi.set(__self__, "instance_pools_to_use_count", instance_pools_to_use_count)
        if maintenance_strategies is not None:
            pulumi.set(__self__, "maintenance_strategies", maintenance_strategies)
        if max_total_price is not None:
            pulumi.set(__self__, "max_total_price", max_total_price)
        if min_target_capacity is not None:
            pulumi.set(__self__, "min_target_capacity", min_target_capacity)
        if single_availability_zone is not None:
            pulumi.set(__self__, "single_availability_zone", single_availability_zone)
        if single_instance_type is not None:
            pulumi.set(__self__, "single_instance_type", single_instance_type)

    @_builtins.property
    @pulumi.getter(name="allocationStrategy")
    def allocation_strategy(self) -> Optional[_builtins.str]:
        """
        How to allocate the target capacity across the Spot pools. Valid values: `diversified`, `lowestPrice`, `capacity-optimized`, `capacity-optimized-prioritized` and `price-capacity-optimized`. Default: `lowestPrice`.
        """
        return pulumi.get(self, "allocation_strategy")

    @_builtins.property
    @pulumi.getter(name="instanceInterruptionBehavior")
    def instance_interruption_behavior(self) -> Optional[_builtins.str]:
        """
        Behavior when a Spot Instance is interrupted. Valid values: `hibernate`, `stop`, `terminate`. Default: `terminate`.
        """
        return pulumi.get(self, "instance_interruption_behavior")

    @_builtins.property
    @pulumi.getter(name="instancePoolsToUseCount")
    def instance_pools_to_use_count(self) -> Optional[_builtins.int]:
        """
        Number of Spot pools across which to allocate your target Spot capacity. Valid only when Spot `allocation_strategy` is set to `lowestPrice`. Default: `1`.
        """
        return pulumi.get(self, "instance_pools_to_use_count")

    @_builtins.property
    @pulumi.getter(name="maintenanceStrategies")
    def maintenance_strategies(self) -> Optional['outputs.FleetSpotOptionsMaintenanceStrategies']:
        """
        Nested argument containing maintenance strategies for managing your Spot Instances that are at an elevated risk of being interrupted. Defined below.
        """
        return pulumi.get(self, "maintenance_strategies")

    @_builtins.property
    @pulumi.getter(name="maxTotalPrice")
    def max_total_price(self) -> Optional[_builtins.str]:
        """
        The maximum amount per hour for Spot Instances that you're willing to pay.
        """
        return pulumi.get(self, "max_total_price")

    @_builtins.property
    @pulumi.getter(name="minTargetCapacity")
    def min_target_capacity(self) -> Optional[_builtins.int]:
        """
        The minimum target capacity for Spot Instances in the fleet. If the minimum target capacity is not reached, the fleet launches no instances. Supported only for fleets of type `instant`.
        """
        return pulumi.get(self, "min_target_capacity")

    @_builtins.property
    @pulumi.getter(name="singleAvailabilityZone")
    def single_availability_zone(self) -> Optional[_builtins.bool]:
        """
        Indicates that the fleet launches all Spot Instances into a single Availability Zone. Supported only for fleets of type `instant`.
        """
        return pulumi.get(self, "single_availability_zone")

    @_builtins.property
    @pulumi.getter(name="singleInstanceType")
    def single_instance_type(self) -> Optional[_builtins.bool]:
        """
        Indicates that the fleet uses a single instance type to launch all Spot Instances in the fleet. Supported only for fleets of type `instant`.
        """
        return pulumi.get(self, "single_instance_type")


@pulumi.output_type
class FleetSpotOptionsMaintenanceStrategies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capacityRebalance":
            suggest = "capacity_rebalance"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FleetSpotOptionsMaintenanceStrategies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FleetSpotOptionsMaintenanceStrategies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FleetSpotOptionsMaintenanceStrategies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capacity_rebalance: Optional['outputs.FleetSpotOptionsMaintenanceStrategiesCapacityRebalance'] = None):
        """
        :param 'FleetSpotOptionsMaintenanceStrategiesCapacityRebalanceArgs' capacity_rebalance: Nested argument containing the capacity rebalance for your fleet request. Defined below.
        """
        if capacity_rebalance is not None:
            pulumi.set(__self__, "capacity_rebalance", capacity_rebalance)

    @_builtins.property
    @pulumi.getter(name="capacityRebalance")
    def capacity_rebalance(self) -> Optional['outputs.FleetSpotOptionsMaintenanceStrategiesCapacityRebalance']:
        """
        Nested argument containing the capacity rebalance for your fleet request. Defined below.
        """
        return pulumi.get(self, "capacity_rebalance")


@pulumi.output_type
class FleetSpotOptionsMaintenanceStrategiesCapacityRebalance(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "replacementStrategy":
            suggest = "replacement_strategy"
        elif key == "terminationDelay":
            suggest = "termination_delay"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FleetSpotOptionsMaintenanceStrategiesCapacityRebalance. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FleetSpotOptionsMaintenanceStrategiesCapacityRebalance.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FleetSpotOptionsMaintenanceStrategiesCapacityRebalance.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 replacement_strategy: Optional[_builtins.str] = None,
                 termination_delay: Optional[_builtins.int] = None):
        """
        :param _builtins.str replacement_strategy: The replacement strategy to use. Only available for fleets of `type` set to `maintain`. Valid values: `launch`.
        """
        if replacement_strategy is not None:
            pulumi.set(__self__, "replacement_strategy", replacement_strategy)
        if termination_delay is not None:
            pulumi.set(__self__, "termination_delay", termination_delay)

    @_builtins.property
    @pulumi.getter(name="replacementStrategy")
    def replacement_strategy(self) -> Optional[_builtins.str]:
        """
        The replacement strategy to use. Only available for fleets of `type` set to `maintain`. Valid values: `launch`.
        """
        return pulumi.get(self, "replacement_strategy")

    @_builtins.property
    @pulumi.getter(name="terminationDelay")
    def termination_delay(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "termination_delay")


@pulumi.output_type
class FleetTargetCapacitySpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultTargetCapacityType":
            suggest = "default_target_capacity_type"
        elif key == "totalTargetCapacity":
            suggest = "total_target_capacity"
        elif key == "onDemandTargetCapacity":
            suggest = "on_demand_target_capacity"
        elif key == "spotTargetCapacity":
            suggest = "spot_target_capacity"
        elif key == "targetCapacityUnitType":
            suggest = "target_capacity_unit_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FleetTargetCapacitySpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FleetTargetCapacitySpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FleetTargetCapacitySpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_target_capacity_type: _builtins.str,
                 total_target_capacity: _builtins.int,
                 on_demand_target_capacity: Optional[_builtins.int] = None,
                 spot_target_capacity: Optional[_builtins.int] = None,
                 target_capacity_unit_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str default_target_capacity_type: Default target capacity type. Valid values: `on-demand`, `spot`.
        :param _builtins.int total_target_capacity: The number of units to request, filled using `default_target_capacity_type`.
        :param _builtins.int on_demand_target_capacity: The number of On-Demand units to request.
        :param _builtins.int spot_target_capacity: The number of Spot units to request.
        :param _builtins.str target_capacity_unit_type: The unit for the target capacity.
               If you specify `target_capacity_unit_type`, `instance_requirements` must be specified.
        """
        pulumi.set(__self__, "default_target_capacity_type", default_target_capacity_type)
        pulumi.set(__self__, "total_target_capacity", total_target_capacity)
        if on_demand_target_capacity is not None:
            pulumi.set(__self__, "on_demand_target_capacity", on_demand_target_capacity)
        if spot_target_capacity is not None:
            pulumi.set(__self__, "spot_target_capacity", spot_target_capacity)
        if target_capacity_unit_type is not None:
            pulumi.set(__self__, "target_capacity_unit_type", target_capacity_unit_type)

    @_builtins.property
    @pulumi.getter(name="defaultTargetCapacityType")
    def default_target_capacity_type(self) -> _builtins.str:
        """
        Default target capacity type. Valid values: `on-demand`, `spot`.
        """
        return pulumi.get(self, "default_target_capacity_type")

    @_builtins.property
    @pulumi.getter(name="totalTargetCapacity")
    def total_target_capacity(self) -> _builtins.int:
        """
        The number of units to request, filled using `default_target_capacity_type`.
        """
        return pulumi.get(self, "total_target_capacity")

    @_builtins.property
    @pulumi.getter(name="onDemandTargetCapacity")
    def on_demand_target_capacity(self) -> Optional[_builtins.int]:
        """
        The number of On-Demand units to request.
        """
        return pulumi.get(self, "on_demand_target_capacity")

    @_builtins.property
    @pulumi.getter(name="spotTargetCapacity")
    def spot_target_capacity(self) -> Optional[_builtins.int]:
        """
        The number of Spot units to request.
        """
        return pulumi.get(self, "spot_target_capacity")

    @_builtins.property
    @pulumi.getter(name="targetCapacityUnitType")
    def target_capacity_unit_type(self) -> Optional[_builtins.str]:
        """
        The unit for the target capacity.
        If you specify `target_capacity_unit_type`, `instance_requirements` must be specified.
        """
        return pulumi.get(self, "target_capacity_unit_type")


@pulumi.output_type
class FlowLogDestinationOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fileFormat":
            suggest = "file_format"
        elif key == "hiveCompatiblePartitions":
            suggest = "hive_compatible_partitions"
        elif key == "perHourPartition":
            suggest = "per_hour_partition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowLogDestinationOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowLogDestinationOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowLogDestinationOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 file_format: Optional[_builtins.str] = None,
                 hive_compatible_partitions: Optional[_builtins.bool] = None,
                 per_hour_partition: Optional[_builtins.bool] = None):
        """
        :param _builtins.str file_format: File format for the flow log. Default value: `plain-text`. Valid values: `plain-text`, `parquet`.
        :param _builtins.bool hive_compatible_partitions: Indicates whether to use Hive-compatible prefixes for flow logs stored in Amazon S3. Default value: `false`.
        :param _builtins.bool per_hour_partition: Indicates whether to partition the flow log per hour. This reduces the cost and response time for queries. Default value: `false`.
        """
        if file_format is not None:
            pulumi.set(__self__, "file_format", file_format)
        if hive_compatible_partitions is not None:
            pulumi.set(__self__, "hive_compatible_partitions", hive_compatible_partitions)
        if per_hour_partition is not None:
            pulumi.set(__self__, "per_hour_partition", per_hour_partition)

    @_builtins.property
    @pulumi.getter(name="fileFormat")
    def file_format(self) -> Optional[_builtins.str]:
        """
        File format for the flow log. Default value: `plain-text`. Valid values: `plain-text`, `parquet`.
        """
        return pulumi.get(self, "file_format")

    @_builtins.property
    @pulumi.getter(name="hiveCompatiblePartitions")
    def hive_compatible_partitions(self) -> Optional[_builtins.bool]:
        """
        Indicates whether to use Hive-compatible prefixes for flow logs stored in Amazon S3. Default value: `false`.
        """
        return pulumi.get(self, "hive_compatible_partitions")

    @_builtins.property
    @pulumi.getter(name="perHourPartition")
    def per_hour_partition(self) -> Optional[_builtins.bool]:
        """
        Indicates whether to partition the flow log per hour. This reduces the cost and response time for queries. Default value: `false`.
        """
        return pulumi.get(self, "per_hour_partition")


@pulumi.output_type
class InstanceCapacityReservationSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capacityReservationPreference":
            suggest = "capacity_reservation_preference"
        elif key == "capacityReservationTarget":
            suggest = "capacity_reservation_target"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceCapacityReservationSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceCapacityReservationSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceCapacityReservationSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capacity_reservation_preference: Optional[_builtins.str] = None,
                 capacity_reservation_target: Optional['outputs.InstanceCapacityReservationSpecificationCapacityReservationTarget'] = None):
        """
        :param _builtins.str capacity_reservation_preference: Indicates the instance's Capacity Reservation preferences. Can be `"open"` or `"none"`. (Default: `"open"`).
        :param 'InstanceCapacityReservationSpecificationCapacityReservationTargetArgs' capacity_reservation_target: Information about the target Capacity Reservation. See Capacity Reservation Target below for more details.
               
               For more information, see the documentation on [Capacity Reservations](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/capacity-reservations-using.html).
        """
        if capacity_reservation_preference is not None:
            pulumi.set(__self__, "capacity_reservation_preference", capacity_reservation_preference)
        if capacity_reservation_target is not None:
            pulumi.set(__self__, "capacity_reservation_target", capacity_reservation_target)

    @_builtins.property
    @pulumi.getter(name="capacityReservationPreference")
    def capacity_reservation_preference(self) -> Optional[_builtins.str]:
        """
        Indicates the instance's Capacity Reservation preferences. Can be `"open"` or `"none"`. (Default: `"open"`).
        """
        return pulumi.get(self, "capacity_reservation_preference")

    @_builtins.property
    @pulumi.getter(name="capacityReservationTarget")
    def capacity_reservation_target(self) -> Optional['outputs.InstanceCapacityReservationSpecificationCapacityReservationTarget']:
        """
        Information about the target Capacity Reservation. See Capacity Reservation Target below for more details.

        For more information, see the documentation on [Capacity Reservations](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/capacity-reservations-using.html).
        """
        return pulumi.get(self, "capacity_reservation_target")


@pulumi.output_type
class InstanceCapacityReservationSpecificationCapacityReservationTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capacityReservationId":
            suggest = "capacity_reservation_id"
        elif key == "capacityReservationResourceGroupArn":
            suggest = "capacity_reservation_resource_group_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceCapacityReservationSpecificationCapacityReservationTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceCapacityReservationSpecificationCapacityReservationTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceCapacityReservationSpecificationCapacityReservationTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capacity_reservation_id: Optional[_builtins.str] = None,
                 capacity_reservation_resource_group_arn: Optional[_builtins.str] = None):
        """
        :param _builtins.str capacity_reservation_id: ID of the Capacity Reservation in which to run the instance.
        :param _builtins.str capacity_reservation_resource_group_arn: ARN of the Capacity Reservation resource group in which to run the instance.
        """
        if capacity_reservation_id is not None:
            pulumi.set(__self__, "capacity_reservation_id", capacity_reservation_id)
        if capacity_reservation_resource_group_arn is not None:
            pulumi.set(__self__, "capacity_reservation_resource_group_arn", capacity_reservation_resource_group_arn)

    @_builtins.property
    @pulumi.getter(name="capacityReservationId")
    def capacity_reservation_id(self) -> Optional[_builtins.str]:
        """
        ID of the Capacity Reservation in which to run the instance.
        """
        return pulumi.get(self, "capacity_reservation_id")

    @_builtins.property
    @pulumi.getter(name="capacityReservationResourceGroupArn")
    def capacity_reservation_resource_group_arn(self) -> Optional[_builtins.str]:
        """
        ARN of the Capacity Reservation resource group in which to run the instance.
        """
        return pulumi.get(self, "capacity_reservation_resource_group_arn")


@pulumi.output_type
class InstanceCpuOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "amdSevSnp":
            suggest = "amd_sev_snp"
        elif key == "coreCount":
            suggest = "core_count"
        elif key == "threadsPerCore":
            suggest = "threads_per_core"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceCpuOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceCpuOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceCpuOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 amd_sev_snp: Optional[_builtins.str] = None,
                 core_count: Optional[_builtins.int] = None,
                 threads_per_core: Optional[_builtins.int] = None):
        """
        :param _builtins.str amd_sev_snp: Indicates whether to enable the instance for AMD SEV-SNP. AMD SEV-SNP is supported with M6a, R6a, and C6a instance types only. Valid values are `enabled` and `disabled`.
        :param _builtins.int core_count: Sets the number of CPU cores for an instance. This option is only supported on creation of instance type that support CPU Options [CPU Cores and Threads Per CPU Core Per Instance Type](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html#cpu-options-supported-instances-values) - specifying this option for unsupported instance types will return an error from the EC2 API.
        :param _builtins.int threads_per_core: If set to 1, hyperthreading is disabled on the launched instance. Defaults to 2 if not set. See [Optimizing CPU Options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html) for more information.
               
               For more information, see the documentation on [Optimizing CPU options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html).
        """
        if amd_sev_snp is not None:
            pulumi.set(__self__, "amd_sev_snp", amd_sev_snp)
        if core_count is not None:
            pulumi.set(__self__, "core_count", core_count)
        if threads_per_core is not None:
            pulumi.set(__self__, "threads_per_core", threads_per_core)

    @_builtins.property
    @pulumi.getter(name="amdSevSnp")
    def amd_sev_snp(self) -> Optional[_builtins.str]:
        """
        Indicates whether to enable the instance for AMD SEV-SNP. AMD SEV-SNP is supported with M6a, R6a, and C6a instance types only. Valid values are `enabled` and `disabled`.
        """
        return pulumi.get(self, "amd_sev_snp")

    @_builtins.property
    @pulumi.getter(name="coreCount")
    def core_count(self) -> Optional[_builtins.int]:
        """
        Sets the number of CPU cores for an instance. This option is only supported on creation of instance type that support CPU Options [CPU Cores and Threads Per CPU Core Per Instance Type](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html#cpu-options-supported-instances-values) - specifying this option for unsupported instance types will return an error from the EC2 API.
        """
        return pulumi.get(self, "core_count")

    @_builtins.property
    @pulumi.getter(name="threadsPerCore")
    def threads_per_core(self) -> Optional[_builtins.int]:
        """
        If set to 1, hyperthreading is disabled on the launched instance. Defaults to 2 if not set. See [Optimizing CPU Options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html) for more information.

        For more information, see the documentation on [Optimizing CPU options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html).
        """
        return pulumi.get(self, "threads_per_core")


@pulumi.output_type
class InstanceCreditSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cpuCredits":
            suggest = "cpu_credits"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceCreditSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceCreditSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceCreditSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu_credits: Optional[_builtins.str] = None):
        """
        :param _builtins.str cpu_credits: Credit option for CPU usage. Valid values include `standard` or `unlimited`. T3 instances are launched as unlimited by default. T2 instances are launched as standard by default.
        """
        if cpu_credits is not None:
            pulumi.set(__self__, "cpu_credits", cpu_credits)

    @_builtins.property
    @pulumi.getter(name="cpuCredits")
    def cpu_credits(self) -> Optional[_builtins.str]:
        """
        Credit option for CPU usage. Valid values include `standard` or `unlimited`. T3 instances are launched as unlimited by default. T2 instances are launched as standard by default.
        """
        return pulumi.get(self, "cpu_credits")


@pulumi.output_type
class InstanceEbsBlockDevice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "snapshotId":
            suggest = "snapshot_id"
        elif key == "tagsAll":
            suggest = "tags_all"
        elif key == "volumeId":
            suggest = "volume_id"
        elif key == "volumeSize":
            suggest = "volume_size"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceEbsBlockDevice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceEbsBlockDevice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceEbsBlockDevice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_name: _builtins.str,
                 delete_on_termination: Optional[_builtins.bool] = None,
                 encrypted: Optional[_builtins.bool] = None,
                 iops: Optional[_builtins.int] = None,
                 kms_key_id: Optional[_builtins.str] = None,
                 snapshot_id: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 tags_all: Optional[Mapping[str, _builtins.str]] = None,
                 throughput: Optional[_builtins.int] = None,
                 volume_id: Optional[_builtins.str] = None,
                 volume_size: Optional[_builtins.int] = None,
                 volume_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str device_name: Name of the device to mount.
        :param _builtins.bool delete_on_termination: Whether the volume should be destroyed on instance termination. Defaults to `true`.
        :param _builtins.bool encrypted: Enables [EBS encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html) on the volume. Defaults to `false`. Cannot be used with `snapshot_id`. Must be configured to perform drift detection.
        :param _builtins.int iops: Amount of provisioned [IOPS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-io-characteristics.html). Only valid for volume_type of `io1`, `io2` or `gp3`.
        :param _builtins.str kms_key_id: Amazon Resource Name (ARN) of the KMS Key to use when encrypting the volume. Must be configured to perform drift detection.
        :param _builtins.str snapshot_id: Snapshot ID to mount.
        :param Mapping[str, _builtins.str] tags: Map of tags to assign to the device.
        :param Mapping[str, _builtins.str] tags_all: Map of tags assigned to the resource, including those inherited from the provider `default_tags` configuration block.
        :param _builtins.int throughput: Throughput to provision for a volume in mebibytes per second (MiB/s). This is only valid for `volume_type` of `gp3`.
        :param _builtins.str volume_id: ID of the volume. For example, the ID can be accessed like this, `aws_instance.web.root_block_device.0.volume_id`.
        :param _builtins.int volume_size: Size of the volume in gibibytes (GiB).
        :param _builtins.str volume_type: Type of volume. Valid values include `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1`, or `st1`. Defaults to `gp2`.
               
               > **NOTE:** Currently, changes to the `ebs_block_device` configuration of _existing_ resources cannot be automatically detected by this provider. To manage changes and attachments of an EBS block to an instance, use the `ebs.Volume` and `ec2.VolumeAttachment` resources instead. If you use `ebs_block_device` on an `ec2.Instance`, this provider will assume management over the full set of non-root EBS block devices for the instance, treating additional block devices as drift. For this reason, `ebs_block_device` cannot be mixed with external `ebs.Volume` and `ec2.VolumeAttachment` resources for a given instance.
        """
        pulumi.set(__self__, "device_name", device_name)
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tags_all is not None:
            pulumi.set(__self__, "tags_all", tags_all)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)
        if volume_id is not None:
            pulumi.set(__self__, "volume_id", volume_id)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> _builtins.str:
        """
        Name of the device to mount.
        """
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[_builtins.bool]:
        """
        Whether the volume should be destroyed on instance termination. Defaults to `true`.
        """
        return pulumi.get(self, "delete_on_termination")

    @_builtins.property
    @pulumi.getter
    def encrypted(self) -> Optional[_builtins.bool]:
        """
        Enables [EBS encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html) on the volume. Defaults to `false`. Cannot be used with `snapshot_id`. Must be configured to perform drift detection.
        """
        return pulumi.get(self, "encrypted")

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[_builtins.int]:
        """
        Amount of provisioned [IOPS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-io-characteristics.html). Only valid for volume_type of `io1`, `io2` or `gp3`.
        """
        return pulumi.get(self, "iops")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[_builtins.str]:
        """
        Amazon Resource Name (ARN) of the KMS Key to use when encrypting the volume. Must be configured to perform drift detection.
        """
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[_builtins.str]:
        """
        Snapshot ID to mount.
        """
        return pulumi.get(self, "snapshot_id")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Map of tags to assign to the device.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="tagsAll")
    def tags_all(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Map of tags assigned to the resource, including those inherited from the provider `default_tags` configuration block.
        """
        return pulumi.get(self, "tags_all")

    @_builtins.property
    @pulumi.getter
    def throughput(self) -> Optional[_builtins.int]:
        """
        Throughput to provision for a volume in mebibytes per second (MiB/s). This is only valid for `volume_type` of `gp3`.
        """
        return pulumi.get(self, "throughput")

    @_builtins.property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> Optional[_builtins.str]:
        """
        ID of the volume. For example, the ID can be accessed like this, `aws_instance.web.root_block_device.0.volume_id`.
        """
        return pulumi.get(self, "volume_id")

    @_builtins.property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[_builtins.int]:
        """
        Size of the volume in gibibytes (GiB).
        """
        return pulumi.get(self, "volume_size")

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[_builtins.str]:
        """
        Type of volume. Valid values include `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1`, or `st1`. Defaults to `gp2`.

        > **NOTE:** Currently, changes to the `ebs_block_device` configuration of _existing_ resources cannot be automatically detected by this provider. To manage changes and attachments of an EBS block to an instance, use the `ebs.Volume` and `ec2.VolumeAttachment` resources instead. If you use `ebs_block_device` on an `ec2.Instance`, this provider will assume management over the full set of non-root EBS block devices for the instance, treating additional block devices as drift. For this reason, `ebs_block_device` cannot be mixed with external `ebs.Volume` and `ec2.VolumeAttachment` resources for a given instance.
        """
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class InstanceEnclaveOptions(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: Whether Nitro Enclaves will be enabled on the instance. Defaults to `false`.
               
               For more information, see the documentation on [Nitro Enclaves](https://docs.aws.amazon.com/enclaves/latest/user/nitro-enclave.html).
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Whether Nitro Enclaves will be enabled on the instance. Defaults to `false`.

        For more information, see the documentation on [Nitro Enclaves](https://docs.aws.amazon.com/enclaves/latest/user/nitro-enclave.html).
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class InstanceEphemeralBlockDevice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "noDevice":
            suggest = "no_device"
        elif key == "virtualName":
            suggest = "virtual_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceEphemeralBlockDevice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceEphemeralBlockDevice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceEphemeralBlockDevice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_name: _builtins.str,
                 no_device: Optional[_builtins.bool] = None,
                 virtual_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str device_name: Name of the block device to mount on the instance.
        :param _builtins.bool no_device: Suppresses the specified device included in the AMI's block device mapping.
        :param _builtins.str virtual_name: [Instance Store Device Name](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#InstanceStoreDeviceNames) (e.g., `ephemeral0`).
               
               Each AWS Instance type has a different set of Instance Store block devices available for attachment. AWS [publishes a list](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#StorageOnInstanceTypes) of which ephemeral devices are available on each type. The devices are always identified by the `virtual_name` in the format `ephemeral{0..N}`.
        """
        pulumi.set(__self__, "device_name", device_name)
        if no_device is not None:
            pulumi.set(__self__, "no_device", no_device)
        if virtual_name is not None:
            pulumi.set(__self__, "virtual_name", virtual_name)

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> _builtins.str:
        """
        Name of the block device to mount on the instance.
        """
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter(name="noDevice")
    def no_device(self) -> Optional[_builtins.bool]:
        """
        Suppresses the specified device included in the AMI's block device mapping.
        """
        return pulumi.get(self, "no_device")

    @_builtins.property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> Optional[_builtins.str]:
        """
        [Instance Store Device Name](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#InstanceStoreDeviceNames) (e.g., `ephemeral0`).

        Each AWS Instance type has a different set of Instance Store block devices available for attachment. AWS [publishes a list](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#StorageOnInstanceTypes) of which ephemeral devices are available on each type. The devices are always identified by the `virtual_name` in the format `ephemeral{0..N}`.
        """
        return pulumi.get(self, "virtual_name")


@pulumi.output_type
class InstanceInstanceMarketOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "marketType":
            suggest = "market_type"
        elif key == "spotOptions":
            suggest = "spot_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceInstanceMarketOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceInstanceMarketOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceInstanceMarketOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 market_type: Optional[_builtins.str] = None,
                 spot_options: Optional['outputs.InstanceInstanceMarketOptionsSpotOptions'] = None):
        """
        :param _builtins.str market_type: Type of market for the instance. Valid values are `spot` and `capacity-block`. Defaults to `spot`. Required if `spot_options` is specified.
        :param 'InstanceInstanceMarketOptionsSpotOptionsArgs' spot_options: Block to configure the options for Spot Instances. See Spot Options below for details on attributes.
        """
        if market_type is not None:
            pulumi.set(__self__, "market_type", market_type)
        if spot_options is not None:
            pulumi.set(__self__, "spot_options", spot_options)

    @_builtins.property
    @pulumi.getter(name="marketType")
    def market_type(self) -> Optional[_builtins.str]:
        """
        Type of market for the instance. Valid values are `spot` and `capacity-block`. Defaults to `spot`. Required if `spot_options` is specified.
        """
        return pulumi.get(self, "market_type")

    @_builtins.property
    @pulumi.getter(name="spotOptions")
    def spot_options(self) -> Optional['outputs.InstanceInstanceMarketOptionsSpotOptions']:
        """
        Block to configure the options for Spot Instances. See Spot Options below for details on attributes.
        """
        return pulumi.get(self, "spot_options")


@pulumi.output_type
class InstanceInstanceMarketOptionsSpotOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceInterruptionBehavior":
            suggest = "instance_interruption_behavior"
        elif key == "maxPrice":
            suggest = "max_price"
        elif key == "spotInstanceType":
            suggest = "spot_instance_type"
        elif key == "validUntil":
            suggest = "valid_until"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceInstanceMarketOptionsSpotOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceInstanceMarketOptionsSpotOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceInstanceMarketOptionsSpotOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_interruption_behavior: Optional[_builtins.str] = None,
                 max_price: Optional[_builtins.str] = None,
                 spot_instance_type: Optional[_builtins.str] = None,
                 valid_until: Optional[_builtins.str] = None):
        """
        :param _builtins.str instance_interruption_behavior: The behavior when a Spot Instance is interrupted. Valid values include `hibernate`, `stop`, `terminate` . The default is `terminate`.
        :param _builtins.str max_price: The maximum hourly price that you're willing to pay for a Spot Instance.
        :param _builtins.str spot_instance_type: The Spot Instance request type. Valid values include `one-time`, `persistent`. Persistent Spot Instance requests are only supported when the instance interruption behavior is either hibernate or stop. The default is `one-time`.
        :param _builtins.str valid_until: The end date of the request, in UTC format (YYYY-MM-DDTHH:MM:SSZ). Supported only for persistent requests.
        """
        if instance_interruption_behavior is not None:
            pulumi.set(__self__, "instance_interruption_behavior", instance_interruption_behavior)
        if max_price is not None:
            pulumi.set(__self__, "max_price", max_price)
        if spot_instance_type is not None:
            pulumi.set(__self__, "spot_instance_type", spot_instance_type)
        if valid_until is not None:
            pulumi.set(__self__, "valid_until", valid_until)

    @_builtins.property
    @pulumi.getter(name="instanceInterruptionBehavior")
    def instance_interruption_behavior(self) -> Optional[_builtins.str]:
        """
        The behavior when a Spot Instance is interrupted. Valid values include `hibernate`, `stop`, `terminate` . The default is `terminate`.
        """
        return pulumi.get(self, "instance_interruption_behavior")

    @_builtins.property
    @pulumi.getter(name="maxPrice")
    def max_price(self) -> Optional[_builtins.str]:
        """
        The maximum hourly price that you're willing to pay for a Spot Instance.
        """
        return pulumi.get(self, "max_price")

    @_builtins.property
    @pulumi.getter(name="spotInstanceType")
    def spot_instance_type(self) -> Optional[_builtins.str]:
        """
        The Spot Instance request type. Valid values include `one-time`, `persistent`. Persistent Spot Instance requests are only supported when the instance interruption behavior is either hibernate or stop. The default is `one-time`.
        """
        return pulumi.get(self, "spot_instance_type")

    @_builtins.property
    @pulumi.getter(name="validUntil")
    def valid_until(self) -> Optional[_builtins.str]:
        """
        The end date of the request, in UTC format (YYYY-MM-DDTHH:MM:SSZ). Supported only for persistent requests.
        """
        return pulumi.get(self, "valid_until")


@pulumi.output_type
class InstanceLaunchTemplate(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 version: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: ID of the launch template. Conflicts with `name`.
        :param _builtins.str name: Name of the launch template. Conflicts with `id`.
        :param _builtins.str version: Template version. Can be a specific version number, `$Latest` or `$Default`. The default value is `$Default`.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        ID of the launch template. Conflicts with `name`.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the launch template. Conflicts with `id`.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.str]:
        """
        Template version. Can be a specific version number, `$Latest` or `$Default`. The default value is `$Default`.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class InstanceMaintenanceOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoRecovery":
            suggest = "auto_recovery"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceMaintenanceOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceMaintenanceOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceMaintenanceOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_recovery: Optional[_builtins.str] = None):
        """
        :param _builtins.str auto_recovery: Automatic recovery behavior of the Instance. Can be `"default"` or `"disabled"`. See [Recover your instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-recover.html) for more details.
        """
        if auto_recovery is not None:
            pulumi.set(__self__, "auto_recovery", auto_recovery)

    @_builtins.property
    @pulumi.getter(name="autoRecovery")
    def auto_recovery(self) -> Optional[_builtins.str]:
        """
        Automatic recovery behavior of the Instance. Can be `"default"` or `"disabled"`. See [Recover your instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-recover.html) for more details.
        """
        return pulumi.get(self, "auto_recovery")


@pulumi.output_type
class InstanceMetadataOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpEndpoint":
            suggest = "http_endpoint"
        elif key == "httpProtocolIpv6":
            suggest = "http_protocol_ipv6"
        elif key == "httpPutResponseHopLimit":
            suggest = "http_put_response_hop_limit"
        elif key == "httpTokens":
            suggest = "http_tokens"
        elif key == "instanceMetadataTags":
            suggest = "instance_metadata_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceMetadataOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceMetadataOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceMetadataOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_endpoint: Optional[_builtins.str] = None,
                 http_protocol_ipv6: Optional[_builtins.str] = None,
                 http_put_response_hop_limit: Optional[_builtins.int] = None,
                 http_tokens: Optional[_builtins.str] = None,
                 instance_metadata_tags: Optional[_builtins.str] = None):
        """
        :param _builtins.str http_endpoint: Whether the metadata service is available. Valid values include `enabled` or `disabled`. Defaults to `enabled`.
        :param _builtins.str http_protocol_ipv6: Whether the IPv6 endpoint for the instance metadata service is enabled. Defaults to `disabled`.
        :param _builtins.int http_put_response_hop_limit: Desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel. Valid values are integer from `1` to `64`. Defaults to `1`.
        :param _builtins.str http_tokens: Whether or not the metadata service requires session tokens, also referred to as _Instance Metadata Service Version 2 (IMDSv2)_. Valid values include `optional` or `required`.
        :param _builtins.str instance_metadata_tags: Enables or disables access to instance tags from the instance metadata service. Valid values include `enabled` or `disabled`. Defaults to `disabled`.
               
               For more information, see the documentation on the [Instance Metadata Service](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html).
        """
        if http_endpoint is not None:
            pulumi.set(__self__, "http_endpoint", http_endpoint)
        if http_protocol_ipv6 is not None:
            pulumi.set(__self__, "http_protocol_ipv6", http_protocol_ipv6)
        if http_put_response_hop_limit is not None:
            pulumi.set(__self__, "http_put_response_hop_limit", http_put_response_hop_limit)
        if http_tokens is not None:
            pulumi.set(__self__, "http_tokens", http_tokens)
        if instance_metadata_tags is not None:
            pulumi.set(__self__, "instance_metadata_tags", instance_metadata_tags)

    @_builtins.property
    @pulumi.getter(name="httpEndpoint")
    def http_endpoint(self) -> Optional[_builtins.str]:
        """
        Whether the metadata service is available. Valid values include `enabled` or `disabled`. Defaults to `enabled`.
        """
        return pulumi.get(self, "http_endpoint")

    @_builtins.property
    @pulumi.getter(name="httpProtocolIpv6")
    def http_protocol_ipv6(self) -> Optional[_builtins.str]:
        """
        Whether the IPv6 endpoint for the instance metadata service is enabled. Defaults to `disabled`.
        """
        return pulumi.get(self, "http_protocol_ipv6")

    @_builtins.property
    @pulumi.getter(name="httpPutResponseHopLimit")
    def http_put_response_hop_limit(self) -> Optional[_builtins.int]:
        """
        Desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel. Valid values are integer from `1` to `64`. Defaults to `1`.
        """
        return pulumi.get(self, "http_put_response_hop_limit")

    @_builtins.property
    @pulumi.getter(name="httpTokens")
    def http_tokens(self) -> Optional[_builtins.str]:
        """
        Whether or not the metadata service requires session tokens, also referred to as _Instance Metadata Service Version 2 (IMDSv2)_. Valid values include `optional` or `required`.
        """
        return pulumi.get(self, "http_tokens")

    @_builtins.property
    @pulumi.getter(name="instanceMetadataTags")
    def instance_metadata_tags(self) -> Optional[_builtins.str]:
        """
        Enables or disables access to instance tags from the instance metadata service. Valid values include `enabled` or `disabled`. Defaults to `disabled`.

        For more information, see the documentation on the [Instance Metadata Service](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html).
        """
        return pulumi.get(self, "instance_metadata_tags")


@pulumi.output_type
class InstanceNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceIndex":
            suggest = "device_index"
        elif key == "networkInterfaceId":
            suggest = "network_interface_id"
        elif key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "networkCardIndex":
            suggest = "network_card_index"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_index: _builtins.int,
                 network_interface_id: _builtins.str,
                 delete_on_termination: Optional[_builtins.bool] = None,
                 network_card_index: Optional[_builtins.int] = None):
        """
        :param _builtins.int device_index: Integer index of the network interface attachment. Limited by instance type.
        :param _builtins.str network_interface_id: ID of the network interface to attach.
        :param _builtins.bool delete_on_termination: Whether or not to delete the network interface on instance termination. Defaults to `false`. Currently, the only valid value is `false`, as this is only supported when creating new network interfaces when launching an instance.
        :param _builtins.int network_card_index: Integer index of the network card. Limited by instance type. The default index is `0`.
        """
        pulumi.set(__self__, "device_index", device_index)
        pulumi.set(__self__, "network_interface_id", network_interface_id)
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if network_card_index is not None:
            pulumi.set(__self__, "network_card_index", network_card_index)

    @_builtins.property
    @pulumi.getter(name="deviceIndex")
    def device_index(self) -> _builtins.int:
        """
        Integer index of the network interface attachment. Limited by instance type.
        """
        return pulumi.get(self, "device_index")

    @_builtins.property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> _builtins.str:
        """
        ID of the network interface to attach.
        """
        return pulumi.get(self, "network_interface_id")

    @_builtins.property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[_builtins.bool]:
        """
        Whether or not to delete the network interface on instance termination. Defaults to `false`. Currently, the only valid value is `false`, as this is only supported when creating new network interfaces when launching an instance.
        """
        return pulumi.get(self, "delete_on_termination")

    @_builtins.property
    @pulumi.getter(name="networkCardIndex")
    def network_card_index(self) -> Optional[_builtins.int]:
        """
        Integer index of the network card. Limited by instance type. The default index is `0`.
        """
        return pulumi.get(self, "network_card_index")


@pulumi.output_type
class InstancePrivateDnsNameOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableResourceNameDnsARecord":
            suggest = "enable_resource_name_dns_a_record"
        elif key == "enableResourceNameDnsAaaaRecord":
            suggest = "enable_resource_name_dns_aaaa_record"
        elif key == "hostnameType":
            suggest = "hostname_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstancePrivateDnsNameOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstancePrivateDnsNameOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstancePrivateDnsNameOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_resource_name_dns_a_record: Optional[_builtins.bool] = None,
                 enable_resource_name_dns_aaaa_record: Optional[_builtins.bool] = None,
                 hostname_type: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enable_resource_name_dns_a_record: Indicates whether to respond to DNS queries for instance hostnames with DNS A records.
        :param _builtins.bool enable_resource_name_dns_aaaa_record: Indicates whether to respond to DNS queries for instance hostnames with DNS AAAA records.
        :param _builtins.str hostname_type: Type of hostname for Amazon EC2 instances. For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 native subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID. Valid values: `ip-name` and `resource-name`.
        """
        if enable_resource_name_dns_a_record is not None:
            pulumi.set(__self__, "enable_resource_name_dns_a_record", enable_resource_name_dns_a_record)
        if enable_resource_name_dns_aaaa_record is not None:
            pulumi.set(__self__, "enable_resource_name_dns_aaaa_record", enable_resource_name_dns_aaaa_record)
        if hostname_type is not None:
            pulumi.set(__self__, "hostname_type", hostname_type)

    @_builtins.property
    @pulumi.getter(name="enableResourceNameDnsARecord")
    def enable_resource_name_dns_a_record(self) -> Optional[_builtins.bool]:
        """
        Indicates whether to respond to DNS queries for instance hostnames with DNS A records.
        """
        return pulumi.get(self, "enable_resource_name_dns_a_record")

    @_builtins.property
    @pulumi.getter(name="enableResourceNameDnsAaaaRecord")
    def enable_resource_name_dns_aaaa_record(self) -> Optional[_builtins.bool]:
        """
        Indicates whether to respond to DNS queries for instance hostnames with DNS AAAA records.
        """
        return pulumi.get(self, "enable_resource_name_dns_aaaa_record")

    @_builtins.property
    @pulumi.getter(name="hostnameType")
    def hostname_type(self) -> Optional[_builtins.str]:
        """
        Type of hostname for Amazon EC2 instances. For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 native subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID. Valid values: `ip-name` and `resource-name`.
        """
        return pulumi.get(self, "hostname_type")


@pulumi.output_type
class InstanceRootBlockDevice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "deviceName":
            suggest = "device_name"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "tagsAll":
            suggest = "tags_all"
        elif key == "volumeId":
            suggest = "volume_id"
        elif key == "volumeSize":
            suggest = "volume_size"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceRootBlockDevice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceRootBlockDevice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceRootBlockDevice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delete_on_termination: Optional[_builtins.bool] = None,
                 device_name: Optional[_builtins.str] = None,
                 encrypted: Optional[_builtins.bool] = None,
                 iops: Optional[_builtins.int] = None,
                 kms_key_id: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 tags_all: Optional[Mapping[str, _builtins.str]] = None,
                 throughput: Optional[_builtins.int] = None,
                 volume_id: Optional[_builtins.str] = None,
                 volume_size: Optional[_builtins.int] = None,
                 volume_type: Optional[_builtins.str] = None):
        """
        :param _builtins.bool delete_on_termination: Whether the volume should be destroyed on instance termination. Defaults to `true`.
        :param _builtins.str device_name: Device name, e.g., `/dev/sdh` or `xvdh`.
        :param _builtins.bool encrypted: Whether to enable volume encryption. Defaults to `false`. Must be configured to perform drift detection.
        :param _builtins.int iops: Amount of provisioned [IOPS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-io-characteristics.html). Only valid for volume_type of `io1`, `io2` or `gp3`.
        :param _builtins.str kms_key_id: Amazon Resource Name (ARN) of the KMS Key to use when encrypting the volume. Must be configured to perform drift detection.
        :param Mapping[str, _builtins.str] tags: Map of tags to assign to the device.
        :param Mapping[str, _builtins.str] tags_all: Map of tags assigned to the resource, including those inherited from the provider `default_tags` configuration block.
        :param _builtins.int throughput: Throughput to provision for a volume in mebibytes per second (MiB/s). This is only valid for `volume_type` of `gp3`.
        :param _builtins.str volume_id: ID of the volume. For example, the ID can be accessed like this, `aws_instance.web.root_block_device.0.volume_id`.
        :param _builtins.int volume_size: Size of the volume in gibibytes (GiB).
        :param _builtins.str volume_type: Type of volume. Valid values include `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1`, or `st1`. Defaults to the volume type that the AMI uses.
               
               Modifying the `encrypted` or `kms_key_id` settings of the `root_block_device` requires resource replacement.
        """
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tags_all is not None:
            pulumi.set(__self__, "tags_all", tags_all)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)
        if volume_id is not None:
            pulumi.set(__self__, "volume_id", volume_id)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[_builtins.bool]:
        """
        Whether the volume should be destroyed on instance termination. Defaults to `true`.
        """
        return pulumi.get(self, "delete_on_termination")

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[_builtins.str]:
        """
        Device name, e.g., `/dev/sdh` or `xvdh`.
        """
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter
    def encrypted(self) -> Optional[_builtins.bool]:
        """
        Whether to enable volume encryption. Defaults to `false`. Must be configured to perform drift detection.
        """
        return pulumi.get(self, "encrypted")

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[_builtins.int]:
        """
        Amount of provisioned [IOPS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-io-characteristics.html). Only valid for volume_type of `io1`, `io2` or `gp3`.
        """
        return pulumi.get(self, "iops")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[_builtins.str]:
        """
        Amazon Resource Name (ARN) of the KMS Key to use when encrypting the volume. Must be configured to perform drift detection.
        """
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Map of tags to assign to the device.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="tagsAll")
    def tags_all(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Map of tags assigned to the resource, including those inherited from the provider `default_tags` configuration block.
        """
        return pulumi.get(self, "tags_all")

    @_builtins.property
    @pulumi.getter
    def throughput(self) -> Optional[_builtins.int]:
        """
        Throughput to provision for a volume in mebibytes per second (MiB/s). This is only valid for `volume_type` of `gp3`.
        """
        return pulumi.get(self, "throughput")

    @_builtins.property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> Optional[_builtins.str]:
        """
        ID of the volume. For example, the ID can be accessed like this, `aws_instance.web.root_block_device.0.volume_id`.
        """
        return pulumi.get(self, "volume_id")

    @_builtins.property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[_builtins.int]:
        """
        Size of the volume in gibibytes (GiB).
        """
        return pulumi.get(self, "volume_size")

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[_builtins.str]:
        """
        Type of volume. Valid values include `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1`, or `st1`. Defaults to the volume type that the AMI uses.

        Modifying the `encrypted` or `kms_key_id` settings of the `root_block_device` requires resource replacement.
        """
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class LaunchConfigurationEbsBlockDevice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "noDevice":
            suggest = "no_device"
        elif key == "snapshotId":
            suggest = "snapshot_id"
        elif key == "volumeSize":
            suggest = "volume_size"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchConfigurationEbsBlockDevice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchConfigurationEbsBlockDevice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchConfigurationEbsBlockDevice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_name: _builtins.str,
                 delete_on_termination: Optional[_builtins.bool] = None,
                 encrypted: Optional[_builtins.bool] = None,
                 iops: Optional[_builtins.int] = None,
                 no_device: Optional[_builtins.bool] = None,
                 snapshot_id: Optional[_builtins.str] = None,
                 throughput: Optional[_builtins.int] = None,
                 volume_size: Optional[_builtins.int] = None,
                 volume_type: Optional[_builtins.str] = None):
        pulumi.set(__self__, "device_name", device_name)
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if no_device is not None:
            pulumi.set(__self__, "no_device", no_device)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> _builtins.str:
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "delete_on_termination")

    @_builtins.property
    @pulumi.getter
    def encrypted(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "encrypted")

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "iops")

    @_builtins.property
    @pulumi.getter(name="noDevice")
    def no_device(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "no_device")

    @_builtins.property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "snapshot_id")

    @_builtins.property
    @pulumi.getter
    def throughput(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "throughput")

    @_builtins.property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "volume_size")

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class LaunchConfigurationEphemeralBlockDevice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "noDevice":
            suggest = "no_device"
        elif key == "virtualName":
            suggest = "virtual_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchConfigurationEphemeralBlockDevice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchConfigurationEphemeralBlockDevice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchConfigurationEphemeralBlockDevice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_name: _builtins.str,
                 no_device: Optional[_builtins.bool] = None,
                 virtual_name: Optional[_builtins.str] = None):
        pulumi.set(__self__, "device_name", device_name)
        if no_device is not None:
            pulumi.set(__self__, "no_device", no_device)
        if virtual_name is not None:
            pulumi.set(__self__, "virtual_name", virtual_name)

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> _builtins.str:
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter(name="noDevice")
    def no_device(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "no_device")

    @_builtins.property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "virtual_name")


@pulumi.output_type
class LaunchConfigurationMetadataOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpEndpoint":
            suggest = "http_endpoint"
        elif key == "httpPutResponseHopLimit":
            suggest = "http_put_response_hop_limit"
        elif key == "httpTokens":
            suggest = "http_tokens"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchConfigurationMetadataOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchConfigurationMetadataOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchConfigurationMetadataOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_endpoint: Optional[_builtins.str] = None,
                 http_put_response_hop_limit: Optional[_builtins.int] = None,
                 http_tokens: Optional[_builtins.str] = None):
        """
        :param _builtins.str http_endpoint: The state of the metadata service: `enabled`, `disabled`.
        :param _builtins.int http_put_response_hop_limit: The desired HTTP PUT response hop limit for instance metadata requests.
        :param _builtins.str http_tokens: If session tokens are required: `optional`, `required`.
        """
        if http_endpoint is not None:
            pulumi.set(__self__, "http_endpoint", http_endpoint)
        if http_put_response_hop_limit is not None:
            pulumi.set(__self__, "http_put_response_hop_limit", http_put_response_hop_limit)
        if http_tokens is not None:
            pulumi.set(__self__, "http_tokens", http_tokens)

    @_builtins.property
    @pulumi.getter(name="httpEndpoint")
    def http_endpoint(self) -> Optional[_builtins.str]:
        """
        The state of the metadata service: `enabled`, `disabled`.
        """
        return pulumi.get(self, "http_endpoint")

    @_builtins.property
    @pulumi.getter(name="httpPutResponseHopLimit")
    def http_put_response_hop_limit(self) -> Optional[_builtins.int]:
        """
        The desired HTTP PUT response hop limit for instance metadata requests.
        """
        return pulumi.get(self, "http_put_response_hop_limit")

    @_builtins.property
    @pulumi.getter(name="httpTokens")
    def http_tokens(self) -> Optional[_builtins.str]:
        """
        If session tokens are required: `optional`, `required`.
        """
        return pulumi.get(self, "http_tokens")


@pulumi.output_type
class LaunchConfigurationRootBlockDevice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "volumeSize":
            suggest = "volume_size"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchConfigurationRootBlockDevice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchConfigurationRootBlockDevice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchConfigurationRootBlockDevice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delete_on_termination: Optional[_builtins.bool] = None,
                 encrypted: Optional[_builtins.bool] = None,
                 iops: Optional[_builtins.int] = None,
                 throughput: Optional[_builtins.int] = None,
                 volume_size: Optional[_builtins.int] = None,
                 volume_type: Optional[_builtins.str] = None):
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "delete_on_termination")

    @_builtins.property
    @pulumi.getter
    def encrypted(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "encrypted")

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "iops")

    @_builtins.property
    @pulumi.getter
    def throughput(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "throughput")

    @_builtins.property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "volume_size")

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class LaunchTemplateBlockDeviceMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "noDevice":
            suggest = "no_device"
        elif key == "virtualName":
            suggest = "virtual_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateBlockDeviceMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateBlockDeviceMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateBlockDeviceMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_name: Optional[_builtins.str] = None,
                 ebs: Optional['outputs.LaunchTemplateBlockDeviceMappingEbs'] = None,
                 no_device: Optional[_builtins.str] = None,
                 virtual_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str device_name: The name of the device to mount.
        :param 'LaunchTemplateBlockDeviceMappingEbsArgs' ebs: Configure EBS volume properties.
        :param _builtins.str no_device: Suppresses the specified device included in the AMI's block device mapping.
        :param _builtins.str virtual_name: The [Instance Store Device
               Name](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#InstanceStoreDeviceNames)
               (e.g., `"ephemeral0"`).
        """
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if ebs is not None:
            pulumi.set(__self__, "ebs", ebs)
        if no_device is not None:
            pulumi.set(__self__, "no_device", no_device)
        if virtual_name is not None:
            pulumi.set(__self__, "virtual_name", virtual_name)

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[_builtins.str]:
        """
        The name of the device to mount.
        """
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter
    def ebs(self) -> Optional['outputs.LaunchTemplateBlockDeviceMappingEbs']:
        """
        Configure EBS volume properties.
        """
        return pulumi.get(self, "ebs")

    @_builtins.property
    @pulumi.getter(name="noDevice")
    def no_device(self) -> Optional[_builtins.str]:
        """
        Suppresses the specified device included in the AMI's block device mapping.
        """
        return pulumi.get(self, "no_device")

    @_builtins.property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> Optional[_builtins.str]:
        """
        The [Instance Store Device
        Name](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#InstanceStoreDeviceNames)
        (e.g., `"ephemeral0"`).
        """
        return pulumi.get(self, "virtual_name")


@pulumi.output_type
class LaunchTemplateBlockDeviceMappingEbs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "snapshotId":
            suggest = "snapshot_id"
        elif key == "volumeInitializationRate":
            suggest = "volume_initialization_rate"
        elif key == "volumeSize":
            suggest = "volume_size"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateBlockDeviceMappingEbs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateBlockDeviceMappingEbs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateBlockDeviceMappingEbs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delete_on_termination: Optional[_builtins.str] = None,
                 encrypted: Optional[_builtins.str] = None,
                 iops: Optional[_builtins.int] = None,
                 kms_key_id: Optional[_builtins.str] = None,
                 snapshot_id: Optional[_builtins.str] = None,
                 throughput: Optional[_builtins.int] = None,
                 volume_initialization_rate: Optional[_builtins.int] = None,
                 volume_size: Optional[_builtins.int] = None,
                 volume_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str delete_on_termination: Whether the volume should be destroyed on instance termination.
               See [Preserving Amazon EBS Volumes on Instance Termination](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/preserving-volumes-on-termination.html) for more information.
        :param _builtins.str encrypted: Enables [EBS encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html) on the volume.
               Cannot be used with `snapshot_id`.
        :param _builtins.int iops: The amount of provisioned [IOPS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-io-characteristics.html).
               This must be set with a `volume_type` of `"io1/io2/gp3"`.
        :param _builtins.str kms_key_id: The ARN of the AWS Key Management Service (AWS KMS) customer master key (CMK) to use when creating the encrypted volume.
               `encrypted` must be set to `true` when this is set.
        :param _builtins.str snapshot_id: The Snapshot ID to mount.
        :param _builtins.int throughput: The throughput to provision for a `gp3` volume in MiB/s (specified as an integer, e.g., 500), with a maximum of 1,000 MiB/s.
        :param _builtins.int volume_initialization_rate: The volume initialization rate in MiB/s (specified as an integer, e.g. 100), with a minimum of 100 MiB/s and maximum of 300 MiB/s.
        :param _builtins.int volume_size: The size of the volume in gigabytes.
        :param _builtins.str volume_type: The volume type.
               Can be one of `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1` or `st1`.
        """
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)
        if volume_initialization_rate is not None:
            pulumi.set(__self__, "volume_initialization_rate", volume_initialization_rate)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[_builtins.str]:
        """
        Whether the volume should be destroyed on instance termination.
        See [Preserving Amazon EBS Volumes on Instance Termination](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/preserving-volumes-on-termination.html) for more information.
        """
        return pulumi.get(self, "delete_on_termination")

    @_builtins.property
    @pulumi.getter
    def encrypted(self) -> Optional[_builtins.str]:
        """
        Enables [EBS encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html) on the volume.
        Cannot be used with `snapshot_id`.
        """
        return pulumi.get(self, "encrypted")

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[_builtins.int]:
        """
        The amount of provisioned [IOPS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-io-characteristics.html).
        This must be set with a `volume_type` of `"io1/io2/gp3"`.
        """
        return pulumi.get(self, "iops")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[_builtins.str]:
        """
        The ARN of the AWS Key Management Service (AWS KMS) customer master key (CMK) to use when creating the encrypted volume.
        `encrypted` must be set to `true` when this is set.
        """
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[_builtins.str]:
        """
        The Snapshot ID to mount.
        """
        return pulumi.get(self, "snapshot_id")

    @_builtins.property
    @pulumi.getter
    def throughput(self) -> Optional[_builtins.int]:
        """
        The throughput to provision for a `gp3` volume in MiB/s (specified as an integer, e.g., 500), with a maximum of 1,000 MiB/s.
        """
        return pulumi.get(self, "throughput")

    @_builtins.property
    @pulumi.getter(name="volumeInitializationRate")
    def volume_initialization_rate(self) -> Optional[_builtins.int]:
        """
        The volume initialization rate in MiB/s (specified as an integer, e.g. 100), with a minimum of 100 MiB/s and maximum of 300 MiB/s.
        """
        return pulumi.get(self, "volume_initialization_rate")

    @_builtins.property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[_builtins.int]:
        """
        The size of the volume in gigabytes.
        """
        return pulumi.get(self, "volume_size")

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[_builtins.str]:
        """
        The volume type.
        Can be one of `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1` or `st1`.
        """
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class LaunchTemplateCapacityReservationSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capacityReservationPreference":
            suggest = "capacity_reservation_preference"
        elif key == "capacityReservationTarget":
            suggest = "capacity_reservation_target"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateCapacityReservationSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateCapacityReservationSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateCapacityReservationSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capacity_reservation_preference: Optional[_builtins.str] = None,
                 capacity_reservation_target: Optional['outputs.LaunchTemplateCapacityReservationSpecificationCapacityReservationTarget'] = None):
        """
        :param _builtins.str capacity_reservation_preference: Indicates the instance's Capacity Reservation preferences. Can be `open` or `none`. (Default `none`).
        :param 'LaunchTemplateCapacityReservationSpecificationCapacityReservationTargetArgs' capacity_reservation_target: Used to target a specific Capacity Reservation:
        """
        if capacity_reservation_preference is not None:
            pulumi.set(__self__, "capacity_reservation_preference", capacity_reservation_preference)
        if capacity_reservation_target is not None:
            pulumi.set(__self__, "capacity_reservation_target", capacity_reservation_target)

    @_builtins.property
    @pulumi.getter(name="capacityReservationPreference")
    def capacity_reservation_preference(self) -> Optional[_builtins.str]:
        """
        Indicates the instance's Capacity Reservation preferences. Can be `open` or `none`. (Default `none`).
        """
        return pulumi.get(self, "capacity_reservation_preference")

    @_builtins.property
    @pulumi.getter(name="capacityReservationTarget")
    def capacity_reservation_target(self) -> Optional['outputs.LaunchTemplateCapacityReservationSpecificationCapacityReservationTarget']:
        """
        Used to target a specific Capacity Reservation:
        """
        return pulumi.get(self, "capacity_reservation_target")


@pulumi.output_type
class LaunchTemplateCapacityReservationSpecificationCapacityReservationTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capacityReservationId":
            suggest = "capacity_reservation_id"
        elif key == "capacityReservationResourceGroupArn":
            suggest = "capacity_reservation_resource_group_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateCapacityReservationSpecificationCapacityReservationTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateCapacityReservationSpecificationCapacityReservationTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateCapacityReservationSpecificationCapacityReservationTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capacity_reservation_id: Optional[_builtins.str] = None,
                 capacity_reservation_resource_group_arn: Optional[_builtins.str] = None):
        """
        :param _builtins.str capacity_reservation_id: The ID of the Capacity Reservation in which to run the instance.
        :param _builtins.str capacity_reservation_resource_group_arn: The ARN of the Capacity Reservation resource group in which to run the instance.
        """
        if capacity_reservation_id is not None:
            pulumi.set(__self__, "capacity_reservation_id", capacity_reservation_id)
        if capacity_reservation_resource_group_arn is not None:
            pulumi.set(__self__, "capacity_reservation_resource_group_arn", capacity_reservation_resource_group_arn)

    @_builtins.property
    @pulumi.getter(name="capacityReservationId")
    def capacity_reservation_id(self) -> Optional[_builtins.str]:
        """
        The ID of the Capacity Reservation in which to run the instance.
        """
        return pulumi.get(self, "capacity_reservation_id")

    @_builtins.property
    @pulumi.getter(name="capacityReservationResourceGroupArn")
    def capacity_reservation_resource_group_arn(self) -> Optional[_builtins.str]:
        """
        The ARN of the Capacity Reservation resource group in which to run the instance.
        """
        return pulumi.get(self, "capacity_reservation_resource_group_arn")


@pulumi.output_type
class LaunchTemplateCpuOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "amdSevSnp":
            suggest = "amd_sev_snp"
        elif key == "coreCount":
            suggest = "core_count"
        elif key == "threadsPerCore":
            suggest = "threads_per_core"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateCpuOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateCpuOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateCpuOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 amd_sev_snp: Optional[_builtins.str] = None,
                 core_count: Optional[_builtins.int] = None,
                 threads_per_core: Optional[_builtins.int] = None):
        """
        :param _builtins.str amd_sev_snp: Indicates whether to enable the instance for AMD SEV-SNP. AMD SEV-SNP is supported with M6a, R6a, and C6a instance types only. Valid values are `enabled` and `disabled`.
        :param _builtins.int core_count: The number of CPU cores for the instance.
        :param _builtins.int threads_per_core: The number of threads per CPU core.
               To disable Intel Hyper-Threading Technology for the instance, specify a value of 1.
               Otherwise, specify the default value of 2.
               
               Both number of CPU cores and threads per core must be specified. Valid number of CPU cores and threads per core for the instance type can be found in the [CPU Options Documentation](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html?shortFooter=true#cpu-options-supported-instances-values)
        """
        if amd_sev_snp is not None:
            pulumi.set(__self__, "amd_sev_snp", amd_sev_snp)
        if core_count is not None:
            pulumi.set(__self__, "core_count", core_count)
        if threads_per_core is not None:
            pulumi.set(__self__, "threads_per_core", threads_per_core)

    @_builtins.property
    @pulumi.getter(name="amdSevSnp")
    def amd_sev_snp(self) -> Optional[_builtins.str]:
        """
        Indicates whether to enable the instance for AMD SEV-SNP. AMD SEV-SNP is supported with M6a, R6a, and C6a instance types only. Valid values are `enabled` and `disabled`.
        """
        return pulumi.get(self, "amd_sev_snp")

    @_builtins.property
    @pulumi.getter(name="coreCount")
    def core_count(self) -> Optional[_builtins.int]:
        """
        The number of CPU cores for the instance.
        """
        return pulumi.get(self, "core_count")

    @_builtins.property
    @pulumi.getter(name="threadsPerCore")
    def threads_per_core(self) -> Optional[_builtins.int]:
        """
        The number of threads per CPU core.
        To disable Intel Hyper-Threading Technology for the instance, specify a value of 1.
        Otherwise, specify the default value of 2.

        Both number of CPU cores and threads per core must be specified. Valid number of CPU cores and threads per core for the instance type can be found in the [CPU Options Documentation](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html?shortFooter=true#cpu-options-supported-instances-values)
        """
        return pulumi.get(self, "threads_per_core")


@pulumi.output_type
class LaunchTemplateCreditSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cpuCredits":
            suggest = "cpu_credits"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateCreditSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateCreditSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateCreditSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu_credits: Optional[_builtins.str] = None):
        """
        :param _builtins.str cpu_credits: The credit option for CPU usage.
               Can be `standard` or `unlimited`.
               T3 instances are launched as `unlimited` by default.
               T2 instances are launched as `standard` by default.
        """
        if cpu_credits is not None:
            pulumi.set(__self__, "cpu_credits", cpu_credits)

    @_builtins.property
    @pulumi.getter(name="cpuCredits")
    def cpu_credits(self) -> Optional[_builtins.str]:
        """
        The credit option for CPU usage.
        Can be `standard` or `unlimited`.
        T3 instances are launched as `unlimited` by default.
        T2 instances are launched as `standard` by default.
        """
        return pulumi.get(self, "cpu_credits")


@pulumi.output_type
class LaunchTemplateEnclaveOptions(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set to `true`, Nitro Enclaves will be enabled on the instance.
               
               For more information, see the documentation on [Nitro Enclaves](https://docs.aws.amazon.com/enclaves/latest/user/nitro-enclave.html).
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set to `true`, Nitro Enclaves will be enabled on the instance.

        For more information, see the documentation on [Nitro Enclaves](https://docs.aws.amazon.com/enclaves/latest/user/nitro-enclave.html).
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class LaunchTemplateHibernationOptions(dict):
    def __init__(__self__, *,
                 configured: _builtins.bool):
        """
        :param _builtins.bool configured: If set to `true`, the launched EC2 instance will hibernation enabled.
        """
        pulumi.set(__self__, "configured", configured)

    @_builtins.property
    @pulumi.getter
    def configured(self) -> _builtins.bool:
        """
        If set to `true`, the launched EC2 instance will hibernation enabled.
        """
        return pulumi.get(self, "configured")


@pulumi.output_type
class LaunchTemplateIamInstanceProfile(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str arn: The Amazon Resource Name (ARN) of the instance profile. Conflicts with `name`.
        :param _builtins.str name: The name of the instance profile.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        """
        The Amazon Resource Name (ARN) of the instance profile. Conflicts with `name`.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the instance profile.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class LaunchTemplateInstanceMarketOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "marketType":
            suggest = "market_type"
        elif key == "spotOptions":
            suggest = "spot_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateInstanceMarketOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateInstanceMarketOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateInstanceMarketOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 market_type: Optional[_builtins.str] = None,
                 spot_options: Optional['outputs.LaunchTemplateInstanceMarketOptionsSpotOptions'] = None):
        """
        :param _builtins.str market_type: The market type. Can be `spot`.
        :param 'LaunchTemplateInstanceMarketOptionsSpotOptionsArgs' spot_options: The options for [Spot Instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-spot-instances.html)
        """
        if market_type is not None:
            pulumi.set(__self__, "market_type", market_type)
        if spot_options is not None:
            pulumi.set(__self__, "spot_options", spot_options)

    @_builtins.property
    @pulumi.getter(name="marketType")
    def market_type(self) -> Optional[_builtins.str]:
        """
        The market type. Can be `spot`.
        """
        return pulumi.get(self, "market_type")

    @_builtins.property
    @pulumi.getter(name="spotOptions")
    def spot_options(self) -> Optional['outputs.LaunchTemplateInstanceMarketOptionsSpotOptions']:
        """
        The options for [Spot Instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-spot-instances.html)
        """
        return pulumi.get(self, "spot_options")


@pulumi.output_type
class LaunchTemplateInstanceMarketOptionsSpotOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blockDurationMinutes":
            suggest = "block_duration_minutes"
        elif key == "instanceInterruptionBehavior":
            suggest = "instance_interruption_behavior"
        elif key == "maxPrice":
            suggest = "max_price"
        elif key == "spotInstanceType":
            suggest = "spot_instance_type"
        elif key == "validUntil":
            suggest = "valid_until"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateInstanceMarketOptionsSpotOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateInstanceMarketOptionsSpotOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateInstanceMarketOptionsSpotOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 block_duration_minutes: Optional[_builtins.int] = None,
                 instance_interruption_behavior: Optional[_builtins.str] = None,
                 max_price: Optional[_builtins.str] = None,
                 spot_instance_type: Optional[_builtins.str] = None,
                 valid_until: Optional[_builtins.str] = None):
        """
        :param _builtins.int block_duration_minutes: The required duration in minutes. This value must be a multiple of 60.
        :param _builtins.str instance_interruption_behavior: The behavior when a Spot Instance is interrupted. Can be `hibernate`,
               `stop`, or `terminate`. (Default: `terminate`).
        :param _builtins.str max_price: The maximum hourly price you're willing to pay for the Spot Instances.
        :param _builtins.str spot_instance_type: The Spot Instance request type. Can be `one-time`, or `persistent`.
        :param _builtins.str valid_until: The end date of the request.
        """
        if block_duration_minutes is not None:
            pulumi.set(__self__, "block_duration_minutes", block_duration_minutes)
        if instance_interruption_behavior is not None:
            pulumi.set(__self__, "instance_interruption_behavior", instance_interruption_behavior)
        if max_price is not None:
            pulumi.set(__self__, "max_price", max_price)
        if spot_instance_type is not None:
            pulumi.set(__self__, "spot_instance_type", spot_instance_type)
        if valid_until is not None:
            pulumi.set(__self__, "valid_until", valid_until)

    @_builtins.property
    @pulumi.getter(name="blockDurationMinutes")
    def block_duration_minutes(self) -> Optional[_builtins.int]:
        """
        The required duration in minutes. This value must be a multiple of 60.
        """
        return pulumi.get(self, "block_duration_minutes")

    @_builtins.property
    @pulumi.getter(name="instanceInterruptionBehavior")
    def instance_interruption_behavior(self) -> Optional[_builtins.str]:
        """
        The behavior when a Spot Instance is interrupted. Can be `hibernate`,
        `stop`, or `terminate`. (Default: `terminate`).
        """
        return pulumi.get(self, "instance_interruption_behavior")

    @_builtins.property
    @pulumi.getter(name="maxPrice")
    def max_price(self) -> Optional[_builtins.str]:
        """
        The maximum hourly price you're willing to pay for the Spot Instances.
        """
        return pulumi.get(self, "max_price")

    @_builtins.property
    @pulumi.getter(name="spotInstanceType")
    def spot_instance_type(self) -> Optional[_builtins.str]:
        """
        The Spot Instance request type. Can be `one-time`, or `persistent`.
        """
        return pulumi.get(self, "spot_instance_type")

    @_builtins.property
    @pulumi.getter(name="validUntil")
    def valid_until(self) -> Optional[_builtins.str]:
        """
        The end date of the request.
        """
        return pulumi.get(self, "valid_until")


@pulumi.output_type
class LaunchTemplateInstanceRequirements(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "memoryMib":
            suggest = "memory_mib"
        elif key == "vcpuCount":
            suggest = "vcpu_count"
        elif key == "acceleratorCount":
            suggest = "accelerator_count"
        elif key == "acceleratorManufacturers":
            suggest = "accelerator_manufacturers"
        elif key == "acceleratorNames":
            suggest = "accelerator_names"
        elif key == "acceleratorTotalMemoryMib":
            suggest = "accelerator_total_memory_mib"
        elif key == "acceleratorTypes":
            suggest = "accelerator_types"
        elif key == "allowedInstanceTypes":
            suggest = "allowed_instance_types"
        elif key == "bareMetal":
            suggest = "bare_metal"
        elif key == "baselineEbsBandwidthMbps":
            suggest = "baseline_ebs_bandwidth_mbps"
        elif key == "burstablePerformance":
            suggest = "burstable_performance"
        elif key == "cpuManufacturers":
            suggest = "cpu_manufacturers"
        elif key == "excludedInstanceTypes":
            suggest = "excluded_instance_types"
        elif key == "instanceGenerations":
            suggest = "instance_generations"
        elif key == "localStorage":
            suggest = "local_storage"
        elif key == "localStorageTypes":
            suggest = "local_storage_types"
        elif key == "maxSpotPriceAsPercentageOfOptimalOnDemandPrice":
            suggest = "max_spot_price_as_percentage_of_optimal_on_demand_price"
        elif key == "memoryGibPerVcpu":
            suggest = "memory_gib_per_vcpu"
        elif key == "networkBandwidthGbps":
            suggest = "network_bandwidth_gbps"
        elif key == "networkInterfaceCount":
            suggest = "network_interface_count"
        elif key == "onDemandMaxPricePercentageOverLowestPrice":
            suggest = "on_demand_max_price_percentage_over_lowest_price"
        elif key == "requireHibernateSupport":
            suggest = "require_hibernate_support"
        elif key == "spotMaxPricePercentageOverLowestPrice":
            suggest = "spot_max_price_percentage_over_lowest_price"
        elif key == "totalLocalStorageGb":
            suggest = "total_local_storage_gb"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateInstanceRequirements. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateInstanceRequirements.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateInstanceRequirements.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 memory_mib: 'outputs.LaunchTemplateInstanceRequirementsMemoryMib',
                 vcpu_count: 'outputs.LaunchTemplateInstanceRequirementsVcpuCount',
                 accelerator_count: Optional['outputs.LaunchTemplateInstanceRequirementsAcceleratorCount'] = None,
                 accelerator_manufacturers: Optional[Sequence[_builtins.str]] = None,
                 accelerator_names: Optional[Sequence[_builtins.str]] = None,
                 accelerator_total_memory_mib: Optional['outputs.LaunchTemplateInstanceRequirementsAcceleratorTotalMemoryMib'] = None,
                 accelerator_types: Optional[Sequence[_builtins.str]] = None,
                 allowed_instance_types: Optional[Sequence[_builtins.str]] = None,
                 bare_metal: Optional[_builtins.str] = None,
                 baseline_ebs_bandwidth_mbps: Optional['outputs.LaunchTemplateInstanceRequirementsBaselineEbsBandwidthMbps'] = None,
                 burstable_performance: Optional[_builtins.str] = None,
                 cpu_manufacturers: Optional[Sequence[_builtins.str]] = None,
                 excluded_instance_types: Optional[Sequence[_builtins.str]] = None,
                 instance_generations: Optional[Sequence[_builtins.str]] = None,
                 local_storage: Optional[_builtins.str] = None,
                 local_storage_types: Optional[Sequence[_builtins.str]] = None,
                 max_spot_price_as_percentage_of_optimal_on_demand_price: Optional[_builtins.int] = None,
                 memory_gib_per_vcpu: Optional['outputs.LaunchTemplateInstanceRequirementsMemoryGibPerVcpu'] = None,
                 network_bandwidth_gbps: Optional['outputs.LaunchTemplateInstanceRequirementsNetworkBandwidthGbps'] = None,
                 network_interface_count: Optional['outputs.LaunchTemplateInstanceRequirementsNetworkInterfaceCount'] = None,
                 on_demand_max_price_percentage_over_lowest_price: Optional[_builtins.int] = None,
                 require_hibernate_support: Optional[_builtins.bool] = None,
                 spot_max_price_percentage_over_lowest_price: Optional[_builtins.int] = None,
                 total_local_storage_gb: Optional['outputs.LaunchTemplateInstanceRequirementsTotalLocalStorageGb'] = None):
        """
        :param 'LaunchTemplateInstanceRequirementsMemoryMibArgs' memory_mib: Block describing the minimum and maximum amount of memory (MiB). Default is no maximum.
        :param 'LaunchTemplateInstanceRequirementsVcpuCountArgs' vcpu_count: Block describing the minimum and maximum number of vCPUs. Default is no maximum.
        :param 'LaunchTemplateInstanceRequirementsAcceleratorCountArgs' accelerator_count: Block describing the minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips). Default is no minimum or maximum.
        :param Sequence[_builtins.str] accelerator_manufacturers: List of accelerator manufacturer names. Default is any manufacturer.
               
               ```
               Valid names:
               * amazon-web-services
               * amd
               * nvidia
               * xilinx
               ```
        :param Sequence[_builtins.str] accelerator_names: List of accelerator names. Default is any acclerator.
               
               ```
               Valid names:
               * a100            - NVIDIA A100 GPUs
               * v100            - NVIDIA V100 GPUs
               * k80             - NVIDIA K80 GPUs
               * t4              - NVIDIA T4 GPUs
               * m60             - NVIDIA M60 GPUs
               * radeon-pro-v520 - AMD Radeon Pro V520 GPUs
               * vu9p            - Xilinx VU9P FPGAs
               ```
        :param 'LaunchTemplateInstanceRequirementsAcceleratorTotalMemoryMibArgs' accelerator_total_memory_mib: Block describing the minimum and maximum total memory of the accelerators. Default is no minimum or maximum.
        :param Sequence[_builtins.str] accelerator_types: List of accelerator types. Default is any accelerator type.
               
               ```
               Valid types:
               * fpga
               * gpu
               * inference
               ```
        :param Sequence[_builtins.str] allowed_instance_types: List of instance types to apply your specified attributes against. All other instance types are ignored, even if they match your specified attributes. You can use strings with one or more wild cards, represented by an asterisk (\\*), to allow an instance type, size, or generation. The following are examples: `m5.8xlarge`, `c5*.*`, `m5a.*`, `r*`, `*3*`. For example, if you specify `c5*`, you are allowing the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*`, you are allowing all the M5a instance types, but not the M5n instance types. Maximum of 400 entries in the list; each entry is limited to 30 characters. Default is all instance types.
               
               > **NOTE:** If you specify `allowed_instance_types`, you can't specify `excluded_instance_types`.
        :param _builtins.str bare_metal: Indicate whether bare metal instace types should be `included`, `excluded`, or `required`. Default is `excluded`.
        :param 'LaunchTemplateInstanceRequirementsBaselineEbsBandwidthMbpsArgs' baseline_ebs_bandwidth_mbps: Block describing the minimum and maximum baseline EBS bandwidth, in Mbps. Default is no minimum or maximum.
        :param _builtins.str burstable_performance: Indicate whether burstable performance instance types should be `included`, `excluded`, or `required`. Default is `excluded`.
        :param Sequence[_builtins.str] cpu_manufacturers: List of CPU manufacturer names. Default is any manufacturer.
               
               > **NOTE:** Don't confuse the CPU hardware manufacturer with the CPU hardware architecture. Instances will be launched with a compatible CPU architecture based on the Amazon Machine Image (AMI) that you specify in your launch template.
               
               ```
               Valid names:
               * amazon-web-services
               * amd
               * intel
               ```
        :param Sequence[_builtins.str] excluded_instance_types: List of instance types to exclude. You can use strings with one or more wild cards, represented by an asterisk (\\*), to exclude an instance type, size, or generation. The following are examples: `m5.8xlarge`, `c5*.*`, `m5a.*`, `r*`, `*3*`. For example, if you specify `c5*`, you are excluding the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*`, you are excluding all the M5a instance types, but not the M5n instance types. Maximum of 400 entries in the list; each entry is limited to 30 characters. Default is no excluded instance types.
               
               > **NOTE:** If you specify `excluded_instance_types`, you can't specify `allowed_instance_types`.
        :param Sequence[_builtins.str] instance_generations: List of instance generation names. Default is any generation.
               
               ```
               Valid names:
               * current  - Recommended for best performance.
               * previous - For existing applications optimized for older instance types.
               ```
        :param _builtins.str local_storage: Indicate whether instance types with local storage volumes are `included`, `excluded`, or `required`. Default is `included`.
        :param Sequence[_builtins.str] local_storage_types: List of local storage type names. Default any storage type.
               
               ```
               Value names:
               * hdd - hard disk drive
               * ssd - solid state drive
               ```
        :param _builtins.int max_spot_price_as_percentage_of_optimal_on_demand_price: The price protection threshold for Spot Instances. This is the maximum you’ll pay for a Spot Instance, expressed as a percentage higher than the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price is higher than your threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as 999999. Conflicts with `spot_max_price_percentage_over_lowest_price`
        :param 'LaunchTemplateInstanceRequirementsMemoryGibPerVcpuArgs' memory_gib_per_vcpu: Block describing the minimum and maximum amount of memory (GiB) per vCPU. Default is no minimum or maximum.
        :param 'LaunchTemplateInstanceRequirementsNetworkBandwidthGbpsArgs' network_bandwidth_gbps: Block describing the minimum and maximum amount of network bandwidth, in gigabits per second (Gbps). Default is no minimum or maximum.
        :param 'LaunchTemplateInstanceRequirementsNetworkInterfaceCountArgs' network_interface_count: Block describing the minimum and maximum number of network interfaces. Default is no minimum or maximum.
        :param _builtins.int on_demand_max_price_percentage_over_lowest_price: The price protection threshold for On-Demand Instances. This is the maximum you’ll pay for an On-Demand Instance, expressed as a percentage higher than the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price is higher than your threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as 999999. Default is 20.
               
               If you set DesiredCapacityType to vcpu or memory-mib, the price protection threshold is applied based on the per vCPU or per memory price instead of the per instance price.
        :param _builtins.bool require_hibernate_support: Indicate whether instance types must support On-Demand Instance Hibernation, either `true` or `false`. Default is `false`.
        :param _builtins.int spot_max_price_percentage_over_lowest_price: The price protection threshold for Spot Instances. This is the maximum you’ll pay for a Spot Instance, expressed as a percentage higher than the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price is higher than your threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as 999999. Default is 100. Conflicts with `max_spot_price_as_percentage_of_optimal_on_demand_price`
               
               If you set DesiredCapacityType to vcpu or memory-mib, the price protection threshold is applied based on the per vCPU or per memory price instead of the per instance price.
        :param 'LaunchTemplateInstanceRequirementsTotalLocalStorageGbArgs' total_local_storage_gb: Block describing the minimum and maximum total local storage (GB). Default is no minimum or maximum.
        """
        pulumi.set(__self__, "memory_mib", memory_mib)
        pulumi.set(__self__, "vcpu_count", vcpu_count)
        if accelerator_count is not None:
            pulumi.set(__self__, "accelerator_count", accelerator_count)
        if accelerator_manufacturers is not None:
            pulumi.set(__self__, "accelerator_manufacturers", accelerator_manufacturers)
        if accelerator_names is not None:
            pulumi.set(__self__, "accelerator_names", accelerator_names)
        if accelerator_total_memory_mib is not None:
            pulumi.set(__self__, "accelerator_total_memory_mib", accelerator_total_memory_mib)
        if accelerator_types is not None:
            pulumi.set(__self__, "accelerator_types", accelerator_types)
        if allowed_instance_types is not None:
            pulumi.set(__self__, "allowed_instance_types", allowed_instance_types)
        if bare_metal is not None:
            pulumi.set(__self__, "bare_metal", bare_metal)
        if baseline_ebs_bandwidth_mbps is not None:
            pulumi.set(__self__, "baseline_ebs_bandwidth_mbps", baseline_ebs_bandwidth_mbps)
        if burstable_performance is not None:
            pulumi.set(__self__, "burstable_performance", burstable_performance)
        if cpu_manufacturers is not None:
            pulumi.set(__self__, "cpu_manufacturers", cpu_manufacturers)
        if excluded_instance_types is not None:
            pulumi.set(__self__, "excluded_instance_types", excluded_instance_types)
        if instance_generations is not None:
            pulumi.set(__self__, "instance_generations", instance_generations)
        if local_storage is not None:
            pulumi.set(__self__, "local_storage", local_storage)
        if local_storage_types is not None:
            pulumi.set(__self__, "local_storage_types", local_storage_types)
        if max_spot_price_as_percentage_of_optimal_on_demand_price is not None:
            pulumi.set(__self__, "max_spot_price_as_percentage_of_optimal_on_demand_price", max_spot_price_as_percentage_of_optimal_on_demand_price)
        if memory_gib_per_vcpu is not None:
            pulumi.set(__self__, "memory_gib_per_vcpu", memory_gib_per_vcpu)
        if network_bandwidth_gbps is not None:
            pulumi.set(__self__, "network_bandwidth_gbps", network_bandwidth_gbps)
        if network_interface_count is not None:
            pulumi.set(__self__, "network_interface_count", network_interface_count)
        if on_demand_max_price_percentage_over_lowest_price is not None:
            pulumi.set(__self__, "on_demand_max_price_percentage_over_lowest_price", on_demand_max_price_percentage_over_lowest_price)
        if require_hibernate_support is not None:
            pulumi.set(__self__, "require_hibernate_support", require_hibernate_support)
        if spot_max_price_percentage_over_lowest_price is not None:
            pulumi.set(__self__, "spot_max_price_percentage_over_lowest_price", spot_max_price_percentage_over_lowest_price)
        if total_local_storage_gb is not None:
            pulumi.set(__self__, "total_local_storage_gb", total_local_storage_gb)

    @_builtins.property
    @pulumi.getter(name="memoryMib")
    def memory_mib(self) -> 'outputs.LaunchTemplateInstanceRequirementsMemoryMib':
        """
        Block describing the minimum and maximum amount of memory (MiB). Default is no maximum.
        """
        return pulumi.get(self, "memory_mib")

    @_builtins.property
    @pulumi.getter(name="vcpuCount")
    def vcpu_count(self) -> 'outputs.LaunchTemplateInstanceRequirementsVcpuCount':
        """
        Block describing the minimum and maximum number of vCPUs. Default is no maximum.
        """
        return pulumi.get(self, "vcpu_count")

    @_builtins.property
    @pulumi.getter(name="acceleratorCount")
    def accelerator_count(self) -> Optional['outputs.LaunchTemplateInstanceRequirementsAcceleratorCount']:
        """
        Block describing the minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips). Default is no minimum or maximum.
        """
        return pulumi.get(self, "accelerator_count")

    @_builtins.property
    @pulumi.getter(name="acceleratorManufacturers")
    def accelerator_manufacturers(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of accelerator manufacturer names. Default is any manufacturer.

        ```
        Valid names:
        * amazon-web-services
        * amd
        * nvidia
        * xilinx
        ```
        """
        return pulumi.get(self, "accelerator_manufacturers")

    @_builtins.property
    @pulumi.getter(name="acceleratorNames")
    def accelerator_names(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of accelerator names. Default is any acclerator.

        ```
        Valid names:
        * a100            - NVIDIA A100 GPUs
        * v100            - NVIDIA V100 GPUs
        * k80             - NVIDIA K80 GPUs
        * t4              - NVIDIA T4 GPUs
        * m60             - NVIDIA M60 GPUs
        * radeon-pro-v520 - AMD Radeon Pro V520 GPUs
        * vu9p            - Xilinx VU9P FPGAs
        ```
        """
        return pulumi.get(self, "accelerator_names")

    @_builtins.property
    @pulumi.getter(name="acceleratorTotalMemoryMib")
    def accelerator_total_memory_mib(self) -> Optional['outputs.LaunchTemplateInstanceRequirementsAcceleratorTotalMemoryMib']:
        """
        Block describing the minimum and maximum total memory of the accelerators. Default is no minimum or maximum.
        """
        return pulumi.get(self, "accelerator_total_memory_mib")

    @_builtins.property
    @pulumi.getter(name="acceleratorTypes")
    def accelerator_types(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of accelerator types. Default is any accelerator type.

        ```
        Valid types:
        * fpga
        * gpu
        * inference
        ```
        """
        return pulumi.get(self, "accelerator_types")

    @_builtins.property
    @pulumi.getter(name="allowedInstanceTypes")
    def allowed_instance_types(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of instance types to apply your specified attributes against. All other instance types are ignored, even if they match your specified attributes. You can use strings with one or more wild cards, represented by an asterisk (\\*), to allow an instance type, size, or generation. The following are examples: `m5.8xlarge`, `c5*.*`, `m5a.*`, `r*`, `*3*`. For example, if you specify `c5*`, you are allowing the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*`, you are allowing all the M5a instance types, but not the M5n instance types. Maximum of 400 entries in the list; each entry is limited to 30 characters. Default is all instance types.

        > **NOTE:** If you specify `allowed_instance_types`, you can't specify `excluded_instance_types`.
        """
        return pulumi.get(self, "allowed_instance_types")

    @_builtins.property
    @pulumi.getter(name="bareMetal")
    def bare_metal(self) -> Optional[_builtins.str]:
        """
        Indicate whether bare metal instace types should be `included`, `excluded`, or `required`. Default is `excluded`.
        """
        return pulumi.get(self, "bare_metal")

    @_builtins.property
    @pulumi.getter(name="baselineEbsBandwidthMbps")
    def baseline_ebs_bandwidth_mbps(self) -> Optional['outputs.LaunchTemplateInstanceRequirementsBaselineEbsBandwidthMbps']:
        """
        Block describing the minimum and maximum baseline EBS bandwidth, in Mbps. Default is no minimum or maximum.
        """
        return pulumi.get(self, "baseline_ebs_bandwidth_mbps")

    @_builtins.property
    @pulumi.getter(name="burstablePerformance")
    def burstable_performance(self) -> Optional[_builtins.str]:
        """
        Indicate whether burstable performance instance types should be `included`, `excluded`, or `required`. Default is `excluded`.
        """
        return pulumi.get(self, "burstable_performance")

    @_builtins.property
    @pulumi.getter(name="cpuManufacturers")
    def cpu_manufacturers(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of CPU manufacturer names. Default is any manufacturer.

        > **NOTE:** Don't confuse the CPU hardware manufacturer with the CPU hardware architecture. Instances will be launched with a compatible CPU architecture based on the Amazon Machine Image (AMI) that you specify in your launch template.

        ```
        Valid names:
        * amazon-web-services
        * amd
        * intel
        ```
        """
        return pulumi.get(self, "cpu_manufacturers")

    @_builtins.property
    @pulumi.getter(name="excludedInstanceTypes")
    def excluded_instance_types(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of instance types to exclude. You can use strings with one or more wild cards, represented by an asterisk (\\*), to exclude an instance type, size, or generation. The following are examples: `m5.8xlarge`, `c5*.*`, `m5a.*`, `r*`, `*3*`. For example, if you specify `c5*`, you are excluding the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*`, you are excluding all the M5a instance types, but not the M5n instance types. Maximum of 400 entries in the list; each entry is limited to 30 characters. Default is no excluded instance types.

        > **NOTE:** If you specify `excluded_instance_types`, you can't specify `allowed_instance_types`.
        """
        return pulumi.get(self, "excluded_instance_types")

    @_builtins.property
    @pulumi.getter(name="instanceGenerations")
    def instance_generations(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of instance generation names. Default is any generation.

        ```
        Valid names:
        * current  - Recommended for best performance.
        * previous - For existing applications optimized for older instance types.
        ```
        """
        return pulumi.get(self, "instance_generations")

    @_builtins.property
    @pulumi.getter(name="localStorage")
    def local_storage(self) -> Optional[_builtins.str]:
        """
        Indicate whether instance types with local storage volumes are `included`, `excluded`, or `required`. Default is `included`.
        """
        return pulumi.get(self, "local_storage")

    @_builtins.property
    @pulumi.getter(name="localStorageTypes")
    def local_storage_types(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of local storage type names. Default any storage type.

        ```
        Value names:
        * hdd - hard disk drive
        * ssd - solid state drive
        ```
        """
        return pulumi.get(self, "local_storage_types")

    @_builtins.property
    @pulumi.getter(name="maxSpotPriceAsPercentageOfOptimalOnDemandPrice")
    def max_spot_price_as_percentage_of_optimal_on_demand_price(self) -> Optional[_builtins.int]:
        """
        The price protection threshold for Spot Instances. This is the maximum you’ll pay for a Spot Instance, expressed as a percentage higher than the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price is higher than your threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as 999999. Conflicts with `spot_max_price_percentage_over_lowest_price`
        """
        return pulumi.get(self, "max_spot_price_as_percentage_of_optimal_on_demand_price")

    @_builtins.property
    @pulumi.getter(name="memoryGibPerVcpu")
    def memory_gib_per_vcpu(self) -> Optional['outputs.LaunchTemplateInstanceRequirementsMemoryGibPerVcpu']:
        """
        Block describing the minimum and maximum amount of memory (GiB) per vCPU. Default is no minimum or maximum.
        """
        return pulumi.get(self, "memory_gib_per_vcpu")

    @_builtins.property
    @pulumi.getter(name="networkBandwidthGbps")
    def network_bandwidth_gbps(self) -> Optional['outputs.LaunchTemplateInstanceRequirementsNetworkBandwidthGbps']:
        """
        Block describing the minimum and maximum amount of network bandwidth, in gigabits per second (Gbps). Default is no minimum or maximum.
        """
        return pulumi.get(self, "network_bandwidth_gbps")

    @_builtins.property
    @pulumi.getter(name="networkInterfaceCount")
    def network_interface_count(self) -> Optional['outputs.LaunchTemplateInstanceRequirementsNetworkInterfaceCount']:
        """
        Block describing the minimum and maximum number of network interfaces. Default is no minimum or maximum.
        """
        return pulumi.get(self, "network_interface_count")

    @_builtins.property
    @pulumi.getter(name="onDemandMaxPricePercentageOverLowestPrice")
    def on_demand_max_price_percentage_over_lowest_price(self) -> Optional[_builtins.int]:
        """
        The price protection threshold for On-Demand Instances. This is the maximum you’ll pay for an On-Demand Instance, expressed as a percentage higher than the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price is higher than your threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as 999999. Default is 20.

        If you set DesiredCapacityType to vcpu or memory-mib, the price protection threshold is applied based on the per vCPU or per memory price instead of the per instance price.
        """
        return pulumi.get(self, "on_demand_max_price_percentage_over_lowest_price")

    @_builtins.property
    @pulumi.getter(name="requireHibernateSupport")
    def require_hibernate_support(self) -> Optional[_builtins.bool]:
        """
        Indicate whether instance types must support On-Demand Instance Hibernation, either `true` or `false`. Default is `false`.
        """
        return pulumi.get(self, "require_hibernate_support")

    @_builtins.property
    @pulumi.getter(name="spotMaxPricePercentageOverLowestPrice")
    def spot_max_price_percentage_over_lowest_price(self) -> Optional[_builtins.int]:
        """
        The price protection threshold for Spot Instances. This is the maximum you’ll pay for a Spot Instance, expressed as a percentage higher than the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price is higher than your threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as 999999. Default is 100. Conflicts with `max_spot_price_as_percentage_of_optimal_on_demand_price`

        If you set DesiredCapacityType to vcpu or memory-mib, the price protection threshold is applied based on the per vCPU or per memory price instead of the per instance price.
        """
        return pulumi.get(self, "spot_max_price_percentage_over_lowest_price")

    @_builtins.property
    @pulumi.getter(name="totalLocalStorageGb")
    def total_local_storage_gb(self) -> Optional['outputs.LaunchTemplateInstanceRequirementsTotalLocalStorageGb']:
        """
        Block describing the minimum and maximum total local storage (GB). Default is no minimum or maximum.
        """
        return pulumi.get(self, "total_local_storage_gb")


@pulumi.output_type
class LaunchTemplateInstanceRequirementsAcceleratorCount(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.int] = None,
                 min: Optional[_builtins.int] = None):
        """
        :param _builtins.int max: Maximum. Set to `0` to exclude instance types with accelerators.
        :param _builtins.int min: Minimum.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.int]:
        """
        Maximum. Set to `0` to exclude instance types with accelerators.
        """
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.int]:
        """
        Minimum.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class LaunchTemplateInstanceRequirementsAcceleratorTotalMemoryMib(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.int] = None,
                 min: Optional[_builtins.int] = None):
        """
        :param _builtins.int max: Maximum.
        :param _builtins.int min: Minimum.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.int]:
        """
        Maximum.
        """
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.int]:
        """
        Minimum.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class LaunchTemplateInstanceRequirementsBaselineEbsBandwidthMbps(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.int] = None,
                 min: Optional[_builtins.int] = None):
        """
        :param _builtins.int max: Maximum.
        :param _builtins.int min: Minimum.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.int]:
        """
        Maximum.
        """
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.int]:
        """
        Minimum.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class LaunchTemplateInstanceRequirementsMemoryGibPerVcpu(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.float] = None,
                 min: Optional[_builtins.float] = None):
        """
        :param _builtins.float max: Maximum. May be a decimal number, e.g. `0.5`.
        :param _builtins.float min: Minimum. May be a decimal number, e.g. `0.5`.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.float]:
        """
        Maximum. May be a decimal number, e.g. `0.5`.
        """
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.float]:
        """
        Minimum. May be a decimal number, e.g. `0.5`.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class LaunchTemplateInstanceRequirementsMemoryMib(dict):
    def __init__(__self__, *,
                 min: _builtins.int,
                 max: Optional[_builtins.int] = None):
        """
        :param _builtins.int min: Minimum.
        :param _builtins.int max: Maximum.
        """
        pulumi.set(__self__, "min", min)
        if max is not None:
            pulumi.set(__self__, "max", max)

    @_builtins.property
    @pulumi.getter
    def min(self) -> _builtins.int:
        """
        Minimum.
        """
        return pulumi.get(self, "min")

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.int]:
        """
        Maximum.
        """
        return pulumi.get(self, "max")


@pulumi.output_type
class LaunchTemplateInstanceRequirementsNetworkBandwidthGbps(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.float] = None,
                 min: Optional[_builtins.float] = None):
        """
        :param _builtins.float max: Maximum.
        :param _builtins.float min: Minimum.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.float]:
        """
        Maximum.
        """
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.float]:
        """
        Minimum.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class LaunchTemplateInstanceRequirementsNetworkInterfaceCount(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.int] = None,
                 min: Optional[_builtins.int] = None):
        """
        :param _builtins.int max: Maximum.
        :param _builtins.int min: Minimum.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.int]:
        """
        Maximum.
        """
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.int]:
        """
        Minimum.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class LaunchTemplateInstanceRequirementsTotalLocalStorageGb(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.float] = None,
                 min: Optional[_builtins.float] = None):
        """
        :param _builtins.float max: Maximum. May be a decimal number, e.g. `0.5`.
        :param _builtins.float min: Minimum. May be a decimal number, e.g. `0.5`.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.float]:
        """
        Maximum. May be a decimal number, e.g. `0.5`.
        """
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.float]:
        """
        Minimum. May be a decimal number, e.g. `0.5`.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class LaunchTemplateInstanceRequirementsVcpuCount(dict):
    def __init__(__self__, *,
                 min: _builtins.int,
                 max: Optional[_builtins.int] = None):
        """
        :param _builtins.int min: Minimum.
        :param _builtins.int max: Maximum.
        """
        pulumi.set(__self__, "min", min)
        if max is not None:
            pulumi.set(__self__, "max", max)

    @_builtins.property
    @pulumi.getter
    def min(self) -> _builtins.int:
        """
        Minimum.
        """
        return pulumi.get(self, "min")

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.int]:
        """
        Maximum.
        """
        return pulumi.get(self, "max")


@pulumi.output_type
class LaunchTemplateLicenseSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "licenseConfigurationArn":
            suggest = "license_configuration_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateLicenseSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateLicenseSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateLicenseSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 license_configuration_arn: _builtins.str):
        """
        :param _builtins.str license_configuration_arn: ARN of the license configuration.
        """
        pulumi.set(__self__, "license_configuration_arn", license_configuration_arn)

    @_builtins.property
    @pulumi.getter(name="licenseConfigurationArn")
    def license_configuration_arn(self) -> _builtins.str:
        """
        ARN of the license configuration.
        """
        return pulumi.get(self, "license_configuration_arn")


@pulumi.output_type
class LaunchTemplateMaintenanceOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoRecovery":
            suggest = "auto_recovery"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateMaintenanceOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateMaintenanceOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateMaintenanceOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_recovery: Optional[_builtins.str] = None):
        """
        :param _builtins.str auto_recovery: Disables the automatic recovery behavior of your instance or sets it to default. Can be `"default"` or `"disabled"`. See [Recover your instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-recover.html) for more details.
        """
        if auto_recovery is not None:
            pulumi.set(__self__, "auto_recovery", auto_recovery)

    @_builtins.property
    @pulumi.getter(name="autoRecovery")
    def auto_recovery(self) -> Optional[_builtins.str]:
        """
        Disables the automatic recovery behavior of your instance or sets it to default. Can be `"default"` or `"disabled"`. See [Recover your instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-recover.html) for more details.
        """
        return pulumi.get(self, "auto_recovery")


@pulumi.output_type
class LaunchTemplateMetadataOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpEndpoint":
            suggest = "http_endpoint"
        elif key == "httpProtocolIpv6":
            suggest = "http_protocol_ipv6"
        elif key == "httpPutResponseHopLimit":
            suggest = "http_put_response_hop_limit"
        elif key == "httpTokens":
            suggest = "http_tokens"
        elif key == "instanceMetadataTags":
            suggest = "instance_metadata_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateMetadataOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateMetadataOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateMetadataOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_endpoint: Optional[_builtins.str] = None,
                 http_protocol_ipv6: Optional[_builtins.str] = None,
                 http_put_response_hop_limit: Optional[_builtins.int] = None,
                 http_tokens: Optional[_builtins.str] = None,
                 instance_metadata_tags: Optional[_builtins.str] = None):
        """
        :param _builtins.str http_endpoint: Whether the metadata service is available. Can be `"enabled"` or `"disabled"`. (Default: `"enabled"`).
        :param _builtins.str http_protocol_ipv6: Enables or disables the IPv6 endpoint for the instance metadata service. Can be `"enabled"` or `"disabled"`.
        :param _builtins.int http_put_response_hop_limit: The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel. Can be an integer from `1` to `64`. (Default: `1`).
        :param _builtins.str http_tokens: Whether or not the metadata service requires session tokens, also referred to as _Instance Metadata Service Version 2 (IMDSv2)_. Can be `"optional"` or `"required"`. (Default: `"optional"`).
        :param _builtins.str instance_metadata_tags: Enables or disables access to instance tags from the instance metadata service. Can be `"enabled"` or `"disabled"`.
               
               For more information, see the documentation on the [Instance Metadata Service](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html).
        """
        if http_endpoint is not None:
            pulumi.set(__self__, "http_endpoint", http_endpoint)
        if http_protocol_ipv6 is not None:
            pulumi.set(__self__, "http_protocol_ipv6", http_protocol_ipv6)
        if http_put_response_hop_limit is not None:
            pulumi.set(__self__, "http_put_response_hop_limit", http_put_response_hop_limit)
        if http_tokens is not None:
            pulumi.set(__self__, "http_tokens", http_tokens)
        if instance_metadata_tags is not None:
            pulumi.set(__self__, "instance_metadata_tags", instance_metadata_tags)

    @_builtins.property
    @pulumi.getter(name="httpEndpoint")
    def http_endpoint(self) -> Optional[_builtins.str]:
        """
        Whether the metadata service is available. Can be `"enabled"` or `"disabled"`. (Default: `"enabled"`).
        """
        return pulumi.get(self, "http_endpoint")

    @_builtins.property
    @pulumi.getter(name="httpProtocolIpv6")
    def http_protocol_ipv6(self) -> Optional[_builtins.str]:
        """
        Enables or disables the IPv6 endpoint for the instance metadata service. Can be `"enabled"` or `"disabled"`.
        """
        return pulumi.get(self, "http_protocol_ipv6")

    @_builtins.property
    @pulumi.getter(name="httpPutResponseHopLimit")
    def http_put_response_hop_limit(self) -> Optional[_builtins.int]:
        """
        The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel. Can be an integer from `1` to `64`. (Default: `1`).
        """
        return pulumi.get(self, "http_put_response_hop_limit")

    @_builtins.property
    @pulumi.getter(name="httpTokens")
    def http_tokens(self) -> Optional[_builtins.str]:
        """
        Whether or not the metadata service requires session tokens, also referred to as _Instance Metadata Service Version 2 (IMDSv2)_. Can be `"optional"` or `"required"`. (Default: `"optional"`).
        """
        return pulumi.get(self, "http_tokens")

    @_builtins.property
    @pulumi.getter(name="instanceMetadataTags")
    def instance_metadata_tags(self) -> Optional[_builtins.str]:
        """
        Enables or disables access to instance tags from the instance metadata service. Can be `"enabled"` or `"disabled"`.

        For more information, see the documentation on the [Instance Metadata Service](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html).
        """
        return pulumi.get(self, "instance_metadata_tags")


@pulumi.output_type
class LaunchTemplateMonitoring(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If `true`, the launched EC2 instance will have detailed monitoring enabled.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If `true`, the launched EC2 instance will have detailed monitoring enabled.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class LaunchTemplateNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "associateCarrierIpAddress":
            suggest = "associate_carrier_ip_address"
        elif key == "associatePublicIpAddress":
            suggest = "associate_public_ip_address"
        elif key == "connectionTrackingSpecification":
            suggest = "connection_tracking_specification"
        elif key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "deviceIndex":
            suggest = "device_index"
        elif key == "enaSrdSpecification":
            suggest = "ena_srd_specification"
        elif key == "interfaceType":
            suggest = "interface_type"
        elif key == "ipv4AddressCount":
            suggest = "ipv4_address_count"
        elif key == "ipv4Addresses":
            suggest = "ipv4_addresses"
        elif key == "ipv4PrefixCount":
            suggest = "ipv4_prefix_count"
        elif key == "ipv4Prefixes":
            suggest = "ipv4_prefixes"
        elif key == "ipv6AddressCount":
            suggest = "ipv6_address_count"
        elif key == "ipv6Addresses":
            suggest = "ipv6_addresses"
        elif key == "ipv6PrefixCount":
            suggest = "ipv6_prefix_count"
        elif key == "ipv6Prefixes":
            suggest = "ipv6_prefixes"
        elif key == "networkCardIndex":
            suggest = "network_card_index"
        elif key == "networkInterfaceId":
            suggest = "network_interface_id"
        elif key == "primaryIpv6":
            suggest = "primary_ipv6"
        elif key == "privateIpAddress":
            suggest = "private_ip_address"
        elif key == "securityGroups":
            suggest = "security_groups"
        elif key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 associate_carrier_ip_address: Optional[_builtins.str] = None,
                 associate_public_ip_address: Optional[_builtins.str] = None,
                 connection_tracking_specification: Optional['outputs.LaunchTemplateNetworkInterfaceConnectionTrackingSpecification'] = None,
                 delete_on_termination: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 device_index: Optional[_builtins.int] = None,
                 ena_srd_specification: Optional['outputs.LaunchTemplateNetworkInterfaceEnaSrdSpecification'] = None,
                 interface_type: Optional[_builtins.str] = None,
                 ipv4_address_count: Optional[_builtins.int] = None,
                 ipv4_addresses: Optional[Sequence[_builtins.str]] = None,
                 ipv4_prefix_count: Optional[_builtins.int] = None,
                 ipv4_prefixes: Optional[Sequence[_builtins.str]] = None,
                 ipv6_address_count: Optional[_builtins.int] = None,
                 ipv6_addresses: Optional[Sequence[_builtins.str]] = None,
                 ipv6_prefix_count: Optional[_builtins.int] = None,
                 ipv6_prefixes: Optional[Sequence[_builtins.str]] = None,
                 network_card_index: Optional[_builtins.int] = None,
                 network_interface_id: Optional[_builtins.str] = None,
                 primary_ipv6: Optional[_builtins.str] = None,
                 private_ip_address: Optional[_builtins.str] = None,
                 security_groups: Optional[Sequence[_builtins.str]] = None,
                 subnet_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str associate_carrier_ip_address: Associate a Carrier IP address with `eth0` for a new network interface. Use this option when you launch an instance in a Wavelength Zone and want to associate a Carrier IP address with the network interface. Boolean value, can be left unset.
        :param _builtins.str associate_public_ip_address: Associate a public ip address with the network interface. Boolean value, can be left unset.
        :param 'LaunchTemplateNetworkInterfaceConnectionTrackingSpecificationArgs' connection_tracking_specification: The Connection Tracking Configuration for the network interface. See [Amazon EC2 security group connection tracking](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-connection-tracking.html#connection-tracking-timeouts)
        :param _builtins.str delete_on_termination: Whether the network interface should be destroyed on instance termination.
        :param _builtins.str description: Description of the network interface.
        :param _builtins.int device_index: The integer index of the network interface attachment.
        :param 'LaunchTemplateNetworkInterfaceEnaSrdSpecificationArgs' ena_srd_specification: Configuration for Elastic Network Adapter (ENA) Express settings. Applies to network interfaces that use the [ena Express](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/enhanced-networking-ena-express.html) feature. See details below.
        :param _builtins.str interface_type: The type of network interface. To create an Elastic Fabric Adapter (EFA), specify `efa`.
        :param _builtins.int ipv4_address_count: The number of secondary private IPv4 addresses to assign to a network interface. Conflicts with `ipv4_addresses`
        :param Sequence[_builtins.str] ipv4_addresses: One or more private IPv4 addresses to associate. Conflicts with `ipv4_address_count`
        :param _builtins.int ipv4_prefix_count: The number of IPv4 prefixes to be automatically assigned to the network interface. Conflicts with `ipv4_prefixes`
        :param Sequence[_builtins.str] ipv4_prefixes: One or more IPv4 prefixes to be assigned to the network interface. Conflicts with `ipv4_prefix_count`
        :param _builtins.int ipv6_address_count: The number of IPv6 addresses to assign to a network interface. Conflicts with `ipv6_addresses`
        :param Sequence[_builtins.str] ipv6_addresses: One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet. Conflicts with `ipv6_address_count`
        :param _builtins.int ipv6_prefix_count: The number of IPv6 prefixes to be automatically assigned to the network interface. Conflicts with `ipv6_prefixes`
        :param Sequence[_builtins.str] ipv6_prefixes: One or more IPv6 prefixes to be assigned to the network interface. Conflicts with `ipv6_prefix_count`
        :param _builtins.int network_card_index: The index of the network card. Some instance types support multiple network cards. The primary network interface must be assigned to network card index 0. The default is network card index 0.
        :param _builtins.str network_interface_id: The ID of the network interface to attach.
        :param _builtins.str primary_ipv6: Whether the first IPv6 GUA will be made the primary IPv6 address.
        :param _builtins.str private_ip_address: The primary private IPv4 address.
        :param Sequence[_builtins.str] security_groups: A list of security group IDs to associate.
        :param _builtins.str subnet_id: The VPC Subnet ID to associate.
        """
        if associate_carrier_ip_address is not None:
            pulumi.set(__self__, "associate_carrier_ip_address", associate_carrier_ip_address)
        if associate_public_ip_address is not None:
            pulumi.set(__self__, "associate_public_ip_address", associate_public_ip_address)
        if connection_tracking_specification is not None:
            pulumi.set(__self__, "connection_tracking_specification", connection_tracking_specification)
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if device_index is not None:
            pulumi.set(__self__, "device_index", device_index)
        if ena_srd_specification is not None:
            pulumi.set(__self__, "ena_srd_specification", ena_srd_specification)
        if interface_type is not None:
            pulumi.set(__self__, "interface_type", interface_type)
        if ipv4_address_count is not None:
            pulumi.set(__self__, "ipv4_address_count", ipv4_address_count)
        if ipv4_addresses is not None:
            pulumi.set(__self__, "ipv4_addresses", ipv4_addresses)
        if ipv4_prefix_count is not None:
            pulumi.set(__self__, "ipv4_prefix_count", ipv4_prefix_count)
        if ipv4_prefixes is not None:
            pulumi.set(__self__, "ipv4_prefixes", ipv4_prefixes)
        if ipv6_address_count is not None:
            pulumi.set(__self__, "ipv6_address_count", ipv6_address_count)
        if ipv6_addresses is not None:
            pulumi.set(__self__, "ipv6_addresses", ipv6_addresses)
        if ipv6_prefix_count is not None:
            pulumi.set(__self__, "ipv6_prefix_count", ipv6_prefix_count)
        if ipv6_prefixes is not None:
            pulumi.set(__self__, "ipv6_prefixes", ipv6_prefixes)
        if network_card_index is not None:
            pulumi.set(__self__, "network_card_index", network_card_index)
        if network_interface_id is not None:
            pulumi.set(__self__, "network_interface_id", network_interface_id)
        if primary_ipv6 is not None:
            pulumi.set(__self__, "primary_ipv6", primary_ipv6)
        if private_ip_address is not None:
            pulumi.set(__self__, "private_ip_address", private_ip_address)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="associateCarrierIpAddress")
    def associate_carrier_ip_address(self) -> Optional[_builtins.str]:
        """
        Associate a Carrier IP address with `eth0` for a new network interface. Use this option when you launch an instance in a Wavelength Zone and want to associate a Carrier IP address with the network interface. Boolean value, can be left unset.
        """
        return pulumi.get(self, "associate_carrier_ip_address")

    @_builtins.property
    @pulumi.getter(name="associatePublicIpAddress")
    def associate_public_ip_address(self) -> Optional[_builtins.str]:
        """
        Associate a public ip address with the network interface. Boolean value, can be left unset.
        """
        return pulumi.get(self, "associate_public_ip_address")

    @_builtins.property
    @pulumi.getter(name="connectionTrackingSpecification")
    def connection_tracking_specification(self) -> Optional['outputs.LaunchTemplateNetworkInterfaceConnectionTrackingSpecification']:
        """
        The Connection Tracking Configuration for the network interface. See [Amazon EC2 security group connection tracking](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-connection-tracking.html#connection-tracking-timeouts)
        """
        return pulumi.get(self, "connection_tracking_specification")

    @_builtins.property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[_builtins.str]:
        """
        Whether the network interface should be destroyed on instance termination.
        """
        return pulumi.get(self, "delete_on_termination")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of the network interface.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="deviceIndex")
    def device_index(self) -> Optional[_builtins.int]:
        """
        The integer index of the network interface attachment.
        """
        return pulumi.get(self, "device_index")

    @_builtins.property
    @pulumi.getter(name="enaSrdSpecification")
    def ena_srd_specification(self) -> Optional['outputs.LaunchTemplateNetworkInterfaceEnaSrdSpecification']:
        """
        Configuration for Elastic Network Adapter (ENA) Express settings. Applies to network interfaces that use the [ena Express](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/enhanced-networking-ena-express.html) feature. See details below.
        """
        return pulumi.get(self, "ena_srd_specification")

    @_builtins.property
    @pulumi.getter(name="interfaceType")
    def interface_type(self) -> Optional[_builtins.str]:
        """
        The type of network interface. To create an Elastic Fabric Adapter (EFA), specify `efa`.
        """
        return pulumi.get(self, "interface_type")

    @_builtins.property
    @pulumi.getter(name="ipv4AddressCount")
    def ipv4_address_count(self) -> Optional[_builtins.int]:
        """
        The number of secondary private IPv4 addresses to assign to a network interface. Conflicts with `ipv4_addresses`
        """
        return pulumi.get(self, "ipv4_address_count")

    @_builtins.property
    @pulumi.getter(name="ipv4Addresses")
    def ipv4_addresses(self) -> Optional[Sequence[_builtins.str]]:
        """
        One or more private IPv4 addresses to associate. Conflicts with `ipv4_address_count`
        """
        return pulumi.get(self, "ipv4_addresses")

    @_builtins.property
    @pulumi.getter(name="ipv4PrefixCount")
    def ipv4_prefix_count(self) -> Optional[_builtins.int]:
        """
        The number of IPv4 prefixes to be automatically assigned to the network interface. Conflicts with `ipv4_prefixes`
        """
        return pulumi.get(self, "ipv4_prefix_count")

    @_builtins.property
    @pulumi.getter(name="ipv4Prefixes")
    def ipv4_prefixes(self) -> Optional[Sequence[_builtins.str]]:
        """
        One or more IPv4 prefixes to be assigned to the network interface. Conflicts with `ipv4_prefix_count`
        """
        return pulumi.get(self, "ipv4_prefixes")

    @_builtins.property
    @pulumi.getter(name="ipv6AddressCount")
    def ipv6_address_count(self) -> Optional[_builtins.int]:
        """
        The number of IPv6 addresses to assign to a network interface. Conflicts with `ipv6_addresses`
        """
        return pulumi.get(self, "ipv6_address_count")

    @_builtins.property
    @pulumi.getter(name="ipv6Addresses")
    def ipv6_addresses(self) -> Optional[Sequence[_builtins.str]]:
        """
        One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet. Conflicts with `ipv6_address_count`
        """
        return pulumi.get(self, "ipv6_addresses")

    @_builtins.property
    @pulumi.getter(name="ipv6PrefixCount")
    def ipv6_prefix_count(self) -> Optional[_builtins.int]:
        """
        The number of IPv6 prefixes to be automatically assigned to the network interface. Conflicts with `ipv6_prefixes`
        """
        return pulumi.get(self, "ipv6_prefix_count")

    @_builtins.property
    @pulumi.getter(name="ipv6Prefixes")
    def ipv6_prefixes(self) -> Optional[Sequence[_builtins.str]]:
        """
        One or more IPv6 prefixes to be assigned to the network interface. Conflicts with `ipv6_prefix_count`
        """
        return pulumi.get(self, "ipv6_prefixes")

    @_builtins.property
    @pulumi.getter(name="networkCardIndex")
    def network_card_index(self) -> Optional[_builtins.int]:
        """
        The index of the network card. Some instance types support multiple network cards. The primary network interface must be assigned to network card index 0. The default is network card index 0.
        """
        return pulumi.get(self, "network_card_index")

    @_builtins.property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> Optional[_builtins.str]:
        """
        The ID of the network interface to attach.
        """
        return pulumi.get(self, "network_interface_id")

    @_builtins.property
    @pulumi.getter(name="primaryIpv6")
    def primary_ipv6(self) -> Optional[_builtins.str]:
        """
        Whether the first IPv6 GUA will be made the primary IPv6 address.
        """
        return pulumi.get(self, "primary_ipv6")

    @_builtins.property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> Optional[_builtins.str]:
        """
        The primary private IPv4 address.
        """
        return pulumi.get(self, "private_ip_address")

    @_builtins.property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of security group IDs to associate.
        """
        return pulumi.get(self, "security_groups")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[_builtins.str]:
        """
        The VPC Subnet ID to associate.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class LaunchTemplateNetworkInterfaceConnectionTrackingSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tcpEstablishedTimeout":
            suggest = "tcp_established_timeout"
        elif key == "udpStreamTimeout":
            suggest = "udp_stream_timeout"
        elif key == "udpTimeout":
            suggest = "udp_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateNetworkInterfaceConnectionTrackingSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateNetworkInterfaceConnectionTrackingSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateNetworkInterfaceConnectionTrackingSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tcp_established_timeout: Optional[_builtins.int] = None,
                 udp_stream_timeout: Optional[_builtins.int] = None,
                 udp_timeout: Optional[_builtins.int] = None):
        """
        :param _builtins.int tcp_established_timeout: Timeout (in seconds) for idle TCP connections in an established state. Min: 60 seconds. Max: 432000 seconds (5 days). Default: 432000 seconds. Recommended: Less than 432000 seconds.
        :param _builtins.int udp_stream_timeout: Timeout (in seconds) for idle UDP flows that have seen traffic only in a single direction or a single request-response transaction. Min: 30 seconds. Max: 60 seconds. Default: 30 seconds.
        :param _builtins.int udp_timeout: Timeout (in seconds) for idle UDP flows classified as streams which have seen more than one request-response transaction. Min: 60 seconds. Max: 180 seconds (3 minutes). Default: 180 seconds.
        """
        if tcp_established_timeout is not None:
            pulumi.set(__self__, "tcp_established_timeout", tcp_established_timeout)
        if udp_stream_timeout is not None:
            pulumi.set(__self__, "udp_stream_timeout", udp_stream_timeout)
        if udp_timeout is not None:
            pulumi.set(__self__, "udp_timeout", udp_timeout)

    @_builtins.property
    @pulumi.getter(name="tcpEstablishedTimeout")
    def tcp_established_timeout(self) -> Optional[_builtins.int]:
        """
        Timeout (in seconds) for idle TCP connections in an established state. Min: 60 seconds. Max: 432000 seconds (5 days). Default: 432000 seconds. Recommended: Less than 432000 seconds.
        """
        return pulumi.get(self, "tcp_established_timeout")

    @_builtins.property
    @pulumi.getter(name="udpStreamTimeout")
    def udp_stream_timeout(self) -> Optional[_builtins.int]:
        """
        Timeout (in seconds) for idle UDP flows that have seen traffic only in a single direction or a single request-response transaction. Min: 30 seconds. Max: 60 seconds. Default: 30 seconds.
        """
        return pulumi.get(self, "udp_stream_timeout")

    @_builtins.property
    @pulumi.getter(name="udpTimeout")
    def udp_timeout(self) -> Optional[_builtins.int]:
        """
        Timeout (in seconds) for idle UDP flows classified as streams which have seen more than one request-response transaction. Min: 60 seconds. Max: 180 seconds (3 minutes). Default: 180 seconds.
        """
        return pulumi.get(self, "udp_timeout")


@pulumi.output_type
class LaunchTemplateNetworkInterfaceEnaSrdSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enaSrdEnabled":
            suggest = "ena_srd_enabled"
        elif key == "enaSrdUdpSpecification":
            suggest = "ena_srd_udp_specification"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateNetworkInterfaceEnaSrdSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateNetworkInterfaceEnaSrdSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateNetworkInterfaceEnaSrdSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ena_srd_enabled: Optional[_builtins.bool] = None,
                 ena_srd_udp_specification: Optional['outputs.LaunchTemplateNetworkInterfaceEnaSrdSpecificationEnaSrdUdpSpecification'] = None):
        """
        :param _builtins.bool ena_srd_enabled: Whether to enable ENA Express. ENA Express uses AWS Scalable Reliable Datagram (SRD) technology to improve the performance of TCP traffic.
        :param 'LaunchTemplateNetworkInterfaceEnaSrdSpecificationEnaSrdUdpSpecificationArgs' ena_srd_udp_specification: Configuration for ENA Express UDP optimization. See details below.
        """
        if ena_srd_enabled is not None:
            pulumi.set(__self__, "ena_srd_enabled", ena_srd_enabled)
        if ena_srd_udp_specification is not None:
            pulumi.set(__self__, "ena_srd_udp_specification", ena_srd_udp_specification)

    @_builtins.property
    @pulumi.getter(name="enaSrdEnabled")
    def ena_srd_enabled(self) -> Optional[_builtins.bool]:
        """
        Whether to enable ENA Express. ENA Express uses AWS Scalable Reliable Datagram (SRD) technology to improve the performance of TCP traffic.
        """
        return pulumi.get(self, "ena_srd_enabled")

    @_builtins.property
    @pulumi.getter(name="enaSrdUdpSpecification")
    def ena_srd_udp_specification(self) -> Optional['outputs.LaunchTemplateNetworkInterfaceEnaSrdSpecificationEnaSrdUdpSpecification']:
        """
        Configuration for ENA Express UDP optimization. See details below.
        """
        return pulumi.get(self, "ena_srd_udp_specification")


@pulumi.output_type
class LaunchTemplateNetworkInterfaceEnaSrdSpecificationEnaSrdUdpSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enaSrdUdpEnabled":
            suggest = "ena_srd_udp_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateNetworkInterfaceEnaSrdSpecificationEnaSrdUdpSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateNetworkInterfaceEnaSrdSpecificationEnaSrdUdpSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateNetworkInterfaceEnaSrdSpecificationEnaSrdUdpSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ena_srd_udp_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool ena_srd_udp_enabled: Whether to enable UDP traffic optimization through ENA Express. Requires `ena_srd_enabled` to be `true`.
               
               NOTE: ENA Express requires [specific instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/enhanced-networking-ena-express.html#ena-express-requirements) and minimum bandwidth of 25 Gbps.
        """
        if ena_srd_udp_enabled is not None:
            pulumi.set(__self__, "ena_srd_udp_enabled", ena_srd_udp_enabled)

    @_builtins.property
    @pulumi.getter(name="enaSrdUdpEnabled")
    def ena_srd_udp_enabled(self) -> Optional[_builtins.bool]:
        """
        Whether to enable UDP traffic optimization through ENA Express. Requires `ena_srd_enabled` to be `true`.

        NOTE: ENA Express requires [specific instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/enhanced-networking-ena-express.html#ena-express-requirements) and minimum bandwidth of 25 Gbps.
        """
        return pulumi.get(self, "ena_srd_udp_enabled")


@pulumi.output_type
class LaunchTemplatePlacement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "groupName":
            suggest = "group_name"
        elif key == "hostId":
            suggest = "host_id"
        elif key == "hostResourceGroupArn":
            suggest = "host_resource_group_arn"
        elif key == "partitionNumber":
            suggest = "partition_number"
        elif key == "spreadDomain":
            suggest = "spread_domain"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplatePlacement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplatePlacement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplatePlacement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 affinity: Optional[_builtins.str] = None,
                 availability_zone: Optional[_builtins.str] = None,
                 group_name: Optional[_builtins.str] = None,
                 host_id: Optional[_builtins.str] = None,
                 host_resource_group_arn: Optional[_builtins.str] = None,
                 partition_number: Optional[_builtins.int] = None,
                 spread_domain: Optional[_builtins.str] = None,
                 tenancy: Optional[_builtins.str] = None):
        """
        :param _builtins.str affinity: The affinity setting for an instance on a Dedicated Host.
        :param _builtins.str availability_zone: The Availability Zone for the instance.
        :param _builtins.str group_name: The name of the placement group for the instance.
        :param _builtins.str host_id: The ID of the Dedicated Host for the instance.
        :param _builtins.str host_resource_group_arn: The ARN of the Host Resource Group in which to launch instances.
        :param _builtins.int partition_number: The number of the partition the instance should launch in. Valid only if the placement group strategy is set to partition.
        :param _builtins.str spread_domain: Reserved for future use.
        :param _builtins.str tenancy: The tenancy of the instance (if the instance is running in a VPC). Can be `default`, `dedicated`, or `host`.
        """
        if affinity is not None:
            pulumi.set(__self__, "affinity", affinity)
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if group_name is not None:
            pulumi.set(__self__, "group_name", group_name)
        if host_id is not None:
            pulumi.set(__self__, "host_id", host_id)
        if host_resource_group_arn is not None:
            pulumi.set(__self__, "host_resource_group_arn", host_resource_group_arn)
        if partition_number is not None:
            pulumi.set(__self__, "partition_number", partition_number)
        if spread_domain is not None:
            pulumi.set(__self__, "spread_domain", spread_domain)
        if tenancy is not None:
            pulumi.set(__self__, "tenancy", tenancy)

    @_builtins.property
    @pulumi.getter
    def affinity(self) -> Optional[_builtins.str]:
        """
        The affinity setting for an instance on a Dedicated Host.
        """
        return pulumi.get(self, "affinity")

    @_builtins.property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[_builtins.str]:
        """
        The Availability Zone for the instance.
        """
        return pulumi.get(self, "availability_zone")

    @_builtins.property
    @pulumi.getter(name="groupName")
    def group_name(self) -> Optional[_builtins.str]:
        """
        The name of the placement group for the instance.
        """
        return pulumi.get(self, "group_name")

    @_builtins.property
    @pulumi.getter(name="hostId")
    def host_id(self) -> Optional[_builtins.str]:
        """
        The ID of the Dedicated Host for the instance.
        """
        return pulumi.get(self, "host_id")

    @_builtins.property
    @pulumi.getter(name="hostResourceGroupArn")
    def host_resource_group_arn(self) -> Optional[_builtins.str]:
        """
        The ARN of the Host Resource Group in which to launch instances.
        """
        return pulumi.get(self, "host_resource_group_arn")

    @_builtins.property
    @pulumi.getter(name="partitionNumber")
    def partition_number(self) -> Optional[_builtins.int]:
        """
        The number of the partition the instance should launch in. Valid only if the placement group strategy is set to partition.
        """
        return pulumi.get(self, "partition_number")

    @_builtins.property
    @pulumi.getter(name="spreadDomain")
    def spread_domain(self) -> Optional[_builtins.str]:
        """
        Reserved for future use.
        """
        return pulumi.get(self, "spread_domain")

    @_builtins.property
    @pulumi.getter
    def tenancy(self) -> Optional[_builtins.str]:
        """
        The tenancy of the instance (if the instance is running in a VPC). Can be `default`, `dedicated`, or `host`.
        """
        return pulumi.get(self, "tenancy")


@pulumi.output_type
class LaunchTemplatePrivateDnsNameOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableResourceNameDnsARecord":
            suggest = "enable_resource_name_dns_a_record"
        elif key == "enableResourceNameDnsAaaaRecord":
            suggest = "enable_resource_name_dns_aaaa_record"
        elif key == "hostnameType":
            suggest = "hostname_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplatePrivateDnsNameOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplatePrivateDnsNameOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplatePrivateDnsNameOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_resource_name_dns_a_record: Optional[_builtins.bool] = None,
                 enable_resource_name_dns_aaaa_record: Optional[_builtins.bool] = None,
                 hostname_type: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enable_resource_name_dns_a_record: Indicates whether to respond to DNS queries for instance hostnames with DNS A records.
        :param _builtins.bool enable_resource_name_dns_aaaa_record: Indicates whether to respond to DNS queries for instance hostnames with DNS AAAA records.
        :param _builtins.str hostname_type: The type of hostname for Amazon EC2 instances. For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 native subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID. Valid values: `ip-name` and `resource-name`.
        """
        if enable_resource_name_dns_a_record is not None:
            pulumi.set(__self__, "enable_resource_name_dns_a_record", enable_resource_name_dns_a_record)
        if enable_resource_name_dns_aaaa_record is not None:
            pulumi.set(__self__, "enable_resource_name_dns_aaaa_record", enable_resource_name_dns_aaaa_record)
        if hostname_type is not None:
            pulumi.set(__self__, "hostname_type", hostname_type)

    @_builtins.property
    @pulumi.getter(name="enableResourceNameDnsARecord")
    def enable_resource_name_dns_a_record(self) -> Optional[_builtins.bool]:
        """
        Indicates whether to respond to DNS queries for instance hostnames with DNS A records.
        """
        return pulumi.get(self, "enable_resource_name_dns_a_record")

    @_builtins.property
    @pulumi.getter(name="enableResourceNameDnsAaaaRecord")
    def enable_resource_name_dns_aaaa_record(self) -> Optional[_builtins.bool]:
        """
        Indicates whether to respond to DNS queries for instance hostnames with DNS AAAA records.
        """
        return pulumi.get(self, "enable_resource_name_dns_aaaa_record")

    @_builtins.property
    @pulumi.getter(name="hostnameType")
    def hostname_type(self) -> Optional[_builtins.str]:
        """
        The type of hostname for Amazon EC2 instances. For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 native subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID. Valid values: `ip-name` and `resource-name`.
        """
        return pulumi.get(self, "hostname_type")


@pulumi.output_type
class LaunchTemplateTagSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceType":
            suggest = "resource_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateTagSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateTagSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateTagSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_type: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str resource_type: The type of resource to tag.
        :param Mapping[str, _builtins.str] tags: A map of tags to assign to the resource.
        """
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[_builtins.str]:
        """
        The type of resource to tag.
        """
        return pulumi.get(self, "resource_type")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        A map of tags to assign to the resource.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ManagedPrefixListEntry(dict):
    def __init__(__self__, *,
                 cidr: _builtins.str,
                 description: Optional[_builtins.str] = None):
        """
        :param _builtins.str cidr: CIDR block of this entry.
        :param _builtins.str description: Description of this entry. Due to API limitations, updating only the description of an existing entry requires temporarily removing and re-adding the entry.
        """
        pulumi.set(__self__, "cidr", cidr)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def cidr(self) -> _builtins.str:
        """
        CIDR block of this entry.
        """
        return pulumi.get(self, "cidr")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of this entry. Due to API limitations, updating only the description of an existing entry requires temporarily removing and re-adding the entry.
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class NatGatewayEipAssociationTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[_builtins.str] = None,
                 delete: Optional[_builtins.str] = None):
        """
        :param _builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param _builtins.str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")


@pulumi.output_type
class NetworkAclEgress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromPort":
            suggest = "from_port"
        elif key == "ruleNo":
            suggest = "rule_no"
        elif key == "toPort":
            suggest = "to_port"
        elif key == "cidrBlock":
            suggest = "cidr_block"
        elif key == "icmpCode":
            suggest = "icmp_code"
        elif key == "icmpType":
            suggest = "icmp_type"
        elif key == "ipv6CidrBlock":
            suggest = "ipv6_cidr_block"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkAclEgress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkAclEgress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkAclEgress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: _builtins.str,
                 from_port: _builtins.int,
                 protocol: _builtins.str,
                 rule_no: _builtins.int,
                 to_port: _builtins.int,
                 cidr_block: Optional[_builtins.str] = None,
                 icmp_code: Optional[_builtins.int] = None,
                 icmp_type: Optional[_builtins.int] = None,
                 ipv6_cidr_block: Optional[_builtins.str] = None):
        """
        :param _builtins.str action: The action to take.
        :param _builtins.int from_port: The from port to match.
        :param _builtins.str protocol: The protocol to match. If using the -1 'all'
               protocol, you must specify a from and to port of 0.
        :param _builtins.int rule_no: The rule number. Used for ordering.
        :param _builtins.int to_port: The to port to match.
        :param _builtins.str cidr_block: The CIDR block to match. This must be a
               valid network mask.
        :param _builtins.int icmp_code: The ICMP type code to be used. Default 0.
               
               > Note: For more information on ICMP types and codes, see here: https://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml
        :param _builtins.int icmp_type: The ICMP type to be used. Default 0.
        :param _builtins.str ipv6_cidr_block: The IPv6 CIDR block.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "from_port", from_port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "rule_no", rule_no)
        pulumi.set(__self__, "to_port", to_port)
        if cidr_block is not None:
            pulumi.set(__self__, "cidr_block", cidr_block)
        if icmp_code is not None:
            pulumi.set(__self__, "icmp_code", icmp_code)
        if icmp_type is not None:
            pulumi.set(__self__, "icmp_type", icmp_type)
        if ipv6_cidr_block is not None:
            pulumi.set(__self__, "ipv6_cidr_block", ipv6_cidr_block)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        """
        The action to take.
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> _builtins.int:
        """
        The from port to match.
        """
        return pulumi.get(self, "from_port")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        """
        The protocol to match. If using the -1 'all'
        protocol, you must specify a from and to port of 0.
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="ruleNo")
    def rule_no(self) -> _builtins.int:
        """
        The rule number. Used for ordering.
        """
        return pulumi.get(self, "rule_no")

    @_builtins.property
    @pulumi.getter(name="toPort")
    def to_port(self) -> _builtins.int:
        """
        The to port to match.
        """
        return pulumi.get(self, "to_port")

    @_builtins.property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> Optional[_builtins.str]:
        """
        The CIDR block to match. This must be a
        valid network mask.
        """
        return pulumi.get(self, "cidr_block")

    @_builtins.property
    @pulumi.getter(name="icmpCode")
    def icmp_code(self) -> Optional[_builtins.int]:
        """
        The ICMP type code to be used. Default 0.

        > Note: For more information on ICMP types and codes, see here: https://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml
        """
        return pulumi.get(self, "icmp_code")

    @_builtins.property
    @pulumi.getter(name="icmpType")
    def icmp_type(self) -> Optional[_builtins.int]:
        """
        The ICMP type to be used. Default 0.
        """
        return pulumi.get(self, "icmp_type")

    @_builtins.property
    @pulumi.getter(name="ipv6CidrBlock")
    def ipv6_cidr_block(self) -> Optional[_builtins.str]:
        """
        The IPv6 CIDR block.
        """
        return pulumi.get(self, "ipv6_cidr_block")


@pulumi.output_type
class NetworkAclIngress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromPort":
            suggest = "from_port"
        elif key == "ruleNo":
            suggest = "rule_no"
        elif key == "toPort":
            suggest = "to_port"
        elif key == "cidrBlock":
            suggest = "cidr_block"
        elif key == "icmpCode":
            suggest = "icmp_code"
        elif key == "icmpType":
            suggest = "icmp_type"
        elif key == "ipv6CidrBlock":
            suggest = "ipv6_cidr_block"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkAclIngress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkAclIngress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkAclIngress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: _builtins.str,
                 from_port: _builtins.int,
                 protocol: _builtins.str,
                 rule_no: _builtins.int,
                 to_port: _builtins.int,
                 cidr_block: Optional[_builtins.str] = None,
                 icmp_code: Optional[_builtins.int] = None,
                 icmp_type: Optional[_builtins.int] = None,
                 ipv6_cidr_block: Optional[_builtins.str] = None):
        """
        :param _builtins.str action: The action to take.
        :param _builtins.int from_port: The from port to match.
        :param _builtins.str protocol: The protocol to match. If using the -1 'all'
               protocol, you must specify a from and to port of 0.
        :param _builtins.int rule_no: The rule number. Used for ordering.
        :param _builtins.int to_port: The to port to match.
        :param _builtins.str cidr_block: The CIDR block to match. This must be a
               valid network mask.
        :param _builtins.int icmp_code: The ICMP type code to be used. Default 0.
               
               > Note: For more information on ICMP types and codes, see here: https://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml
        :param _builtins.int icmp_type: The ICMP type to be used. Default 0.
        :param _builtins.str ipv6_cidr_block: The IPv6 CIDR block.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "from_port", from_port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "rule_no", rule_no)
        pulumi.set(__self__, "to_port", to_port)
        if cidr_block is not None:
            pulumi.set(__self__, "cidr_block", cidr_block)
        if icmp_code is not None:
            pulumi.set(__self__, "icmp_code", icmp_code)
        if icmp_type is not None:
            pulumi.set(__self__, "icmp_type", icmp_type)
        if ipv6_cidr_block is not None:
            pulumi.set(__self__, "ipv6_cidr_block", ipv6_cidr_block)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        """
        The action to take.
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> _builtins.int:
        """
        The from port to match.
        """
        return pulumi.get(self, "from_port")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        """
        The protocol to match. If using the -1 'all'
        protocol, you must specify a from and to port of 0.
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="ruleNo")
    def rule_no(self) -> _builtins.int:
        """
        The rule number. Used for ordering.
        """
        return pulumi.get(self, "rule_no")

    @_builtins.property
    @pulumi.getter(name="toPort")
    def to_port(self) -> _builtins.int:
        """
        The to port to match.
        """
        return pulumi.get(self, "to_port")

    @_builtins.property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> Optional[_builtins.str]:
        """
        The CIDR block to match. This must be a
        valid network mask.
        """
        return pulumi.get(self, "cidr_block")

    @_builtins.property
    @pulumi.getter(name="icmpCode")
    def icmp_code(self) -> Optional[_builtins.int]:
        """
        The ICMP type code to be used. Default 0.

        > Note: For more information on ICMP types and codes, see here: https://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml
        """
        return pulumi.get(self, "icmp_code")

    @_builtins.property
    @pulumi.getter(name="icmpType")
    def icmp_type(self) -> Optional[_builtins.int]:
        """
        The ICMP type to be used. Default 0.
        """
        return pulumi.get(self, "icmp_type")

    @_builtins.property
    @pulumi.getter(name="ipv6CidrBlock")
    def ipv6_cidr_block(self) -> Optional[_builtins.str]:
        """
        The IPv6 CIDR block.
        """
        return pulumi.get(self, "ipv6_cidr_block")


@pulumi.output_type
class NetworkInsightsAnalysisAlternatePathHint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "componentArn":
            suggest = "component_arn"
        elif key == "componentId":
            suggest = "component_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisAlternatePathHint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisAlternatePathHint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisAlternatePathHint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 component_arn: Optional[_builtins.str] = None,
                 component_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str component_arn: The Amazon Resource Name (ARN) of the component.
        :param _builtins.str component_id: The ID of the component.
        """
        if component_arn is not None:
            pulumi.set(__self__, "component_arn", component_arn)
        if component_id is not None:
            pulumi.set(__self__, "component_id", component_id)

    @_builtins.property
    @pulumi.getter(name="componentArn")
    def component_arn(self) -> Optional[_builtins.str]:
        """
        The Amazon Resource Name (ARN) of the component.
        """
        return pulumi.get(self, "component_arn")

    @_builtins.property
    @pulumi.getter(name="componentId")
    def component_id(self) -> Optional[_builtins.str]:
        """
        The ID of the component.
        """
        return pulumi.get(self, "component_id")


@pulumi.output_type
class NetworkInsightsAnalysisExplanation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aclRules":
            suggest = "acl_rules"
        elif key == "attachedTos":
            suggest = "attached_tos"
        elif key == "availabilityZones":
            suggest = "availability_zones"
        elif key == "classicLoadBalancerListeners":
            suggest = "classic_load_balancer_listeners"
        elif key == "customerGateways":
            suggest = "customer_gateways"
        elif key == "destinationVpcs":
            suggest = "destination_vpcs"
        elif key == "elasticLoadBalancerListeners":
            suggest = "elastic_load_balancer_listeners"
        elif key == "explanationCode":
            suggest = "explanation_code"
        elif key == "ingressRouteTables":
            suggest = "ingress_route_tables"
        elif key == "internetGateways":
            suggest = "internet_gateways"
        elif key == "loadBalancerArn":
            suggest = "load_balancer_arn"
        elif key == "loadBalancerListenerPort":
            suggest = "load_balancer_listener_port"
        elif key == "loadBalancerTargetGroup":
            suggest = "load_balancer_target_group"
        elif key == "loadBalancerTargetGroups":
            suggest = "load_balancer_target_groups"
        elif key == "loadBalancerTargetPort":
            suggest = "load_balancer_target_port"
        elif key == "missingComponent":
            suggest = "missing_component"
        elif key == "natGateways":
            suggest = "nat_gateways"
        elif key == "networkInterfaces":
            suggest = "network_interfaces"
        elif key == "packetField":
            suggest = "packet_field"
        elif key == "portRanges":
            suggest = "port_ranges"
        elif key == "prefixLists":
            suggest = "prefix_lists"
        elif key == "routeTableRoutes":
            suggest = "route_table_routes"
        elif key == "routeTables":
            suggest = "route_tables"
        elif key == "securityGroup":
            suggest = "security_group"
        elif key == "securityGroupRules":
            suggest = "security_group_rules"
        elif key == "securityGroups":
            suggest = "security_groups"
        elif key == "sourceVpcs":
            suggest = "source_vpcs"
        elif key == "subnetRouteTables":
            suggest = "subnet_route_tables"
        elif key == "transitGatewayAttachments":
            suggest = "transit_gateway_attachments"
        elif key == "transitGatewayRouteTableRoutes":
            suggest = "transit_gateway_route_table_routes"
        elif key == "transitGatewayRouteTables":
            suggest = "transit_gateway_route_tables"
        elif key == "transitGateways":
            suggest = "transit_gateways"
        elif key == "vpcEndpoints":
            suggest = "vpc_endpoints"
        elif key == "vpcPeeringConnections":
            suggest = "vpc_peering_connections"
        elif key == "vpnConnections":
            suggest = "vpn_connections"
        elif key == "vpnGateways":
            suggest = "vpn_gateways"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisExplanation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisExplanation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisExplanation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 acl_rules: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationAclRule']] = None,
                 acls: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationAcl']] = None,
                 address: Optional[_builtins.str] = None,
                 addresses: Optional[Sequence[_builtins.str]] = None,
                 attached_tos: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationAttachedTo']] = None,
                 availability_zones: Optional[Sequence[_builtins.str]] = None,
                 cidrs: Optional[Sequence[_builtins.str]] = None,
                 classic_load_balancer_listeners: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationClassicLoadBalancerListener']] = None,
                 components: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationComponent']] = None,
                 customer_gateways: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationCustomerGateway']] = None,
                 destination_vpcs: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationDestinationVpc']] = None,
                 destinations: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationDestination']] = None,
                 direction: Optional[_builtins.str] = None,
                 elastic_load_balancer_listeners: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationElasticLoadBalancerListener']] = None,
                 explanation_code: Optional[_builtins.str] = None,
                 ingress_route_tables: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationIngressRouteTable']] = None,
                 internet_gateways: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationInternetGateway']] = None,
                 load_balancer_arn: Optional[_builtins.str] = None,
                 load_balancer_listener_port: Optional[_builtins.int] = None,
                 load_balancer_target_group: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationLoadBalancerTargetGroup']] = None,
                 load_balancer_target_groups: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationLoadBalancerTargetGroup']] = None,
                 load_balancer_target_port: Optional[_builtins.int] = None,
                 missing_component: Optional[_builtins.str] = None,
                 nat_gateways: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationNatGateway']] = None,
                 network_interfaces: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationNetworkInterface']] = None,
                 packet_field: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_ranges: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationPortRange']] = None,
                 prefix_lists: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationPrefixList']] = None,
                 protocols: Optional[Sequence[_builtins.str]] = None,
                 route_table_routes: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationRouteTableRoute']] = None,
                 route_tables: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationRouteTable']] = None,
                 security_group: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationSecurityGroup']] = None,
                 security_group_rules: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationSecurityGroupRule']] = None,
                 security_groups: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationSecurityGroup']] = None,
                 source_vpcs: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationSourceVpc']] = None,
                 state: Optional[_builtins.str] = None,
                 subnet_route_tables: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationSubnetRouteTable']] = None,
                 subnets: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationSubnet']] = None,
                 transit_gateway_attachments: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationTransitGatewayAttachment']] = None,
                 transit_gateway_route_table_routes: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationTransitGatewayRouteTableRoute']] = None,
                 transit_gateway_route_tables: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationTransitGatewayRouteTable']] = None,
                 transit_gateways: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationTransitGateway']] = None,
                 vpc_endpoints: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationVpcEndpoint']] = None,
                 vpc_peering_connections: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationVpcPeeringConnection']] = None,
                 vpcs: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationVpc']] = None,
                 vpn_connections: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationVpnConnection']] = None,
                 vpn_gateways: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationVpnGateway']] = None):
        if acl_rules is not None:
            pulumi.set(__self__, "acl_rules", acl_rules)
        if acls is not None:
            pulumi.set(__self__, "acls", acls)
        if address is not None:
            pulumi.set(__self__, "address", address)
        if addresses is not None:
            pulumi.set(__self__, "addresses", addresses)
        if attached_tos is not None:
            pulumi.set(__self__, "attached_tos", attached_tos)
        if availability_zones is not None:
            pulumi.set(__self__, "availability_zones", availability_zones)
        if cidrs is not None:
            pulumi.set(__self__, "cidrs", cidrs)
        if classic_load_balancer_listeners is not None:
            pulumi.set(__self__, "classic_load_balancer_listeners", classic_load_balancer_listeners)
        if components is not None:
            pulumi.set(__self__, "components", components)
        if customer_gateways is not None:
            pulumi.set(__self__, "customer_gateways", customer_gateways)
        if destination_vpcs is not None:
            pulumi.set(__self__, "destination_vpcs", destination_vpcs)
        if destinations is not None:
            pulumi.set(__self__, "destinations", destinations)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if elastic_load_balancer_listeners is not None:
            pulumi.set(__self__, "elastic_load_balancer_listeners", elastic_load_balancer_listeners)
        if explanation_code is not None:
            pulumi.set(__self__, "explanation_code", explanation_code)
        if ingress_route_tables is not None:
            pulumi.set(__self__, "ingress_route_tables", ingress_route_tables)
        if internet_gateways is not None:
            pulumi.set(__self__, "internet_gateways", internet_gateways)
        if load_balancer_arn is not None:
            pulumi.set(__self__, "load_balancer_arn", load_balancer_arn)
        if load_balancer_listener_port is not None:
            pulumi.set(__self__, "load_balancer_listener_port", load_balancer_listener_port)
        if load_balancer_target_group is not None:
            pulumi.set(__self__, "load_balancer_target_group", load_balancer_target_group)
        if load_balancer_target_groups is not None:
            pulumi.set(__self__, "load_balancer_target_groups", load_balancer_target_groups)
        if load_balancer_target_port is not None:
            pulumi.set(__self__, "load_balancer_target_port", load_balancer_target_port)
        if missing_component is not None:
            pulumi.set(__self__, "missing_component", missing_component)
        if nat_gateways is not None:
            pulumi.set(__self__, "nat_gateways", nat_gateways)
        if network_interfaces is not None:
            pulumi.set(__self__, "network_interfaces", network_interfaces)
        if packet_field is not None:
            pulumi.set(__self__, "packet_field", packet_field)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_ranges is not None:
            pulumi.set(__self__, "port_ranges", port_ranges)
        if prefix_lists is not None:
            pulumi.set(__self__, "prefix_lists", prefix_lists)
        if protocols is not None:
            pulumi.set(__self__, "protocols", protocols)
        if route_table_routes is not None:
            pulumi.set(__self__, "route_table_routes", route_table_routes)
        if route_tables is not None:
            pulumi.set(__self__, "route_tables", route_tables)
        if security_group is not None:
            pulumi.set(__self__, "security_group", security_group)
        if security_group_rules is not None:
            pulumi.set(__self__, "security_group_rules", security_group_rules)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if source_vpcs is not None:
            pulumi.set(__self__, "source_vpcs", source_vpcs)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if subnet_route_tables is not None:
            pulumi.set(__self__, "subnet_route_tables", subnet_route_tables)
        if subnets is not None:
            pulumi.set(__self__, "subnets", subnets)
        if transit_gateway_attachments is not None:
            pulumi.set(__self__, "transit_gateway_attachments", transit_gateway_attachments)
        if transit_gateway_route_table_routes is not None:
            pulumi.set(__self__, "transit_gateway_route_table_routes", transit_gateway_route_table_routes)
        if transit_gateway_route_tables is not None:
            pulumi.set(__self__, "transit_gateway_route_tables", transit_gateway_route_tables)
        if transit_gateways is not None:
            pulumi.set(__self__, "transit_gateways", transit_gateways)
        if vpc_endpoints is not None:
            pulumi.set(__self__, "vpc_endpoints", vpc_endpoints)
        if vpc_peering_connections is not None:
            pulumi.set(__self__, "vpc_peering_connections", vpc_peering_connections)
        if vpcs is not None:
            pulumi.set(__self__, "vpcs", vpcs)
        if vpn_connections is not None:
            pulumi.set(__self__, "vpn_connections", vpn_connections)
        if vpn_gateways is not None:
            pulumi.set(__self__, "vpn_gateways", vpn_gateways)

    @_builtins.property
    @pulumi.getter(name="aclRules")
    def acl_rules(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationAclRule']]:
        return pulumi.get(self, "acl_rules")

    @_builtins.property
    @pulumi.getter
    def acls(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationAcl']]:
        return pulumi.get(self, "acls")

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def addresses(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "addresses")

    @_builtins.property
    @pulumi.getter(name="attachedTos")
    def attached_tos(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationAttachedTo']]:
        return pulumi.get(self, "attached_tos")

    @_builtins.property
    @pulumi.getter(name="availabilityZones")
    def availability_zones(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "availability_zones")

    @_builtins.property
    @pulumi.getter
    def cidrs(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "cidrs")

    @_builtins.property
    @pulumi.getter(name="classicLoadBalancerListeners")
    def classic_load_balancer_listeners(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationClassicLoadBalancerListener']]:
        return pulumi.get(self, "classic_load_balancer_listeners")

    @_builtins.property
    @pulumi.getter
    def components(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationComponent']]:
        return pulumi.get(self, "components")

    @_builtins.property
    @pulumi.getter(name="customerGateways")
    def customer_gateways(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationCustomerGateway']]:
        return pulumi.get(self, "customer_gateways")

    @_builtins.property
    @pulumi.getter(name="destinationVpcs")
    def destination_vpcs(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationDestinationVpc']]:
        return pulumi.get(self, "destination_vpcs")

    @_builtins.property
    @pulumi.getter
    def destinations(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationDestination']]:
        return pulumi.get(self, "destinations")

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "direction")

    @_builtins.property
    @pulumi.getter(name="elasticLoadBalancerListeners")
    def elastic_load_balancer_listeners(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationElasticLoadBalancerListener']]:
        return pulumi.get(self, "elastic_load_balancer_listeners")

    @_builtins.property
    @pulumi.getter(name="explanationCode")
    def explanation_code(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "explanation_code")

    @_builtins.property
    @pulumi.getter(name="ingressRouteTables")
    def ingress_route_tables(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationIngressRouteTable']]:
        return pulumi.get(self, "ingress_route_tables")

    @_builtins.property
    @pulumi.getter(name="internetGateways")
    def internet_gateways(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationInternetGateway']]:
        return pulumi.get(self, "internet_gateways")

    @_builtins.property
    @pulumi.getter(name="loadBalancerArn")
    def load_balancer_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "load_balancer_arn")

    @_builtins.property
    @pulumi.getter(name="loadBalancerListenerPort")
    def load_balancer_listener_port(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "load_balancer_listener_port")

    @_builtins.property
    @pulumi.getter(name="loadBalancerTargetGroup")
    def load_balancer_target_group(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationLoadBalancerTargetGroup']]:
        return pulumi.get(self, "load_balancer_target_group")

    @_builtins.property
    @pulumi.getter(name="loadBalancerTargetGroups")
    def load_balancer_target_groups(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationLoadBalancerTargetGroup']]:
        return pulumi.get(self, "load_balancer_target_groups")

    @_builtins.property
    @pulumi.getter(name="loadBalancerTargetPort")
    def load_balancer_target_port(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "load_balancer_target_port")

    @_builtins.property
    @pulumi.getter(name="missingComponent")
    def missing_component(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "missing_component")

    @_builtins.property
    @pulumi.getter(name="natGateways")
    def nat_gateways(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationNatGateway']]:
        return pulumi.get(self, "nat_gateways")

    @_builtins.property
    @pulumi.getter(name="networkInterfaces")
    def network_interfaces(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationNetworkInterface']]:
        return pulumi.get(self, "network_interfaces")

    @_builtins.property
    @pulumi.getter(name="packetField")
    def packet_field(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "packet_field")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationPortRange']]:
        return pulumi.get(self, "port_ranges")

    @_builtins.property
    @pulumi.getter(name="prefixLists")
    def prefix_lists(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationPrefixList']]:
        return pulumi.get(self, "prefix_lists")

    @_builtins.property
    @pulumi.getter
    def protocols(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "protocols")

    @_builtins.property
    @pulumi.getter(name="routeTableRoutes")
    def route_table_routes(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationRouteTableRoute']]:
        return pulumi.get(self, "route_table_routes")

    @_builtins.property
    @pulumi.getter(name="routeTables")
    def route_tables(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationRouteTable']]:
        return pulumi.get(self, "route_tables")

    @_builtins.property
    @pulumi.getter(name="securityGroup")
    def security_group(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationSecurityGroup']]:
        return pulumi.get(self, "security_group")

    @_builtins.property
    @pulumi.getter(name="securityGroupRules")
    def security_group_rules(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationSecurityGroupRule']]:
        return pulumi.get(self, "security_group_rules")

    @_builtins.property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationSecurityGroup']]:
        return pulumi.get(self, "security_groups")

    @_builtins.property
    @pulumi.getter(name="sourceVpcs")
    def source_vpcs(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationSourceVpc']]:
        return pulumi.get(self, "source_vpcs")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="subnetRouteTables")
    def subnet_route_tables(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationSubnetRouteTable']]:
        return pulumi.get(self, "subnet_route_tables")

    @_builtins.property
    @pulumi.getter
    def subnets(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationSubnet']]:
        return pulumi.get(self, "subnets")

    @_builtins.property
    @pulumi.getter(name="transitGatewayAttachments")
    def transit_gateway_attachments(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationTransitGatewayAttachment']]:
        return pulumi.get(self, "transit_gateway_attachments")

    @_builtins.property
    @pulumi.getter(name="transitGatewayRouteTableRoutes")
    def transit_gateway_route_table_routes(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationTransitGatewayRouteTableRoute']]:
        return pulumi.get(self, "transit_gateway_route_table_routes")

    @_builtins.property
    @pulumi.getter(name="transitGatewayRouteTables")
    def transit_gateway_route_tables(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationTransitGatewayRouteTable']]:
        return pulumi.get(self, "transit_gateway_route_tables")

    @_builtins.property
    @pulumi.getter(name="transitGateways")
    def transit_gateways(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationTransitGateway']]:
        return pulumi.get(self, "transit_gateways")

    @_builtins.property
    @pulumi.getter(name="vpcEndpoints")
    def vpc_endpoints(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationVpcEndpoint']]:
        return pulumi.get(self, "vpc_endpoints")

    @_builtins.property
    @pulumi.getter(name="vpcPeeringConnections")
    def vpc_peering_connections(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationVpcPeeringConnection']]:
        return pulumi.get(self, "vpc_peering_connections")

    @_builtins.property
    @pulumi.getter
    def vpcs(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationVpc']]:
        return pulumi.get(self, "vpcs")

    @_builtins.property
    @pulumi.getter(name="vpnConnections")
    def vpn_connections(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationVpnConnection']]:
        return pulumi.get(self, "vpn_connections")

    @_builtins.property
    @pulumi.getter(name="vpnGateways")
    def vpn_gateways(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationVpnGateway']]:
        return pulumi.get(self, "vpn_gateways")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationAcl(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str arn: ARN of the Network Insights Analysis.
        :param _builtins.str id: ID of the Network Insights Analysis.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationAclRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portRanges":
            suggest = "port_ranges"
        elif key == "ruleAction":
            suggest = "rule_action"
        elif key == "ruleNumber":
            suggest = "rule_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisExplanationAclRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisExplanationAclRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisExplanationAclRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cidr: Optional[_builtins.str] = None,
                 egress: Optional[_builtins.bool] = None,
                 port_ranges: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationAclRulePortRange']] = None,
                 protocol: Optional[_builtins.str] = None,
                 rule_action: Optional[_builtins.str] = None,
                 rule_number: Optional[_builtins.int] = None):
        if cidr is not None:
            pulumi.set(__self__, "cidr", cidr)
        if egress is not None:
            pulumi.set(__self__, "egress", egress)
        if port_ranges is not None:
            pulumi.set(__self__, "port_ranges", port_ranges)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if rule_action is not None:
            pulumi.set(__self__, "rule_action", rule_action)
        if rule_number is not None:
            pulumi.set(__self__, "rule_number", rule_number)

    @_builtins.property
    @pulumi.getter
    def cidr(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cidr")

    @_builtins.property
    @pulumi.getter
    def egress(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "egress")

    @_builtins.property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationAclRulePortRange']]:
        return pulumi.get(self, "port_ranges")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="ruleAction")
    def rule_action(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "rule_action")

    @_builtins.property
    @pulumi.getter(name="ruleNumber")
    def rule_number(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "rule_number")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationAclRulePortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisExplanationAclRulePortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisExplanationAclRulePortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisExplanationAclRulePortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: Optional[_builtins.int] = None,
                 to: Optional[_builtins.int] = None):
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "to")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationAttachedTo(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str arn: ARN of the Network Insights Analysis.
        :param _builtins.str id: ID of the Network Insights Analysis.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationClassicLoadBalancerListener(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instancePort":
            suggest = "instance_port"
        elif key == "loadBalancerPort":
            suggest = "load_balancer_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisExplanationClassicLoadBalancerListener. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisExplanationClassicLoadBalancerListener.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisExplanationClassicLoadBalancerListener.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_port: Optional[_builtins.int] = None,
                 load_balancer_port: Optional[_builtins.int] = None):
        if instance_port is not None:
            pulumi.set(__self__, "instance_port", instance_port)
        if load_balancer_port is not None:
            pulumi.set(__self__, "load_balancer_port", load_balancer_port)

    @_builtins.property
    @pulumi.getter(name="instancePort")
    def instance_port(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "instance_port")

    @_builtins.property
    @pulumi.getter(name="loadBalancerPort")
    def load_balancer_port(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "load_balancer_port")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationComponent(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str arn: ARN of the Network Insights Analysis.
        :param _builtins.str id: ID of the Network Insights Analysis.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationCustomerGateway(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str arn: ARN of the Network Insights Analysis.
        :param _builtins.str id: ID of the Network Insights Analysis.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationDestination(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str arn: ARN of the Network Insights Analysis.
        :param _builtins.str id: ID of the Network Insights Analysis.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationDestinationVpc(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str arn: ARN of the Network Insights Analysis.
        :param _builtins.str id: ID of the Network Insights Analysis.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationElasticLoadBalancerListener(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str arn: ARN of the Network Insights Analysis.
        :param _builtins.str id: ID of the Network Insights Analysis.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationIngressRouteTable(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str arn: ARN of the Network Insights Analysis.
        :param _builtins.str id: ID of the Network Insights Analysis.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationInternetGateway(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str arn: ARN of the Network Insights Analysis.
        :param _builtins.str id: ID of the Network Insights Analysis.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationLoadBalancerTargetGroup(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str arn: ARN of the Network Insights Analysis.
        :param _builtins.str id: ID of the Network Insights Analysis.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationNatGateway(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str arn: ARN of the Network Insights Analysis.
        :param _builtins.str id: ID of the Network Insights Analysis.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationNetworkInterface(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str arn: ARN of the Network Insights Analysis.
        :param _builtins.str id: ID of the Network Insights Analysis.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationPortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisExplanationPortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisExplanationPortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisExplanationPortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: Optional[_builtins.int] = None,
                 to: Optional[_builtins.int] = None):
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "to")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationPrefixList(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str arn: ARN of the Network Insights Analysis.
        :param _builtins.str id: ID of the Network Insights Analysis.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationRouteTable(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str arn: ARN of the Network Insights Analysis.
        :param _builtins.str id: ID of the Network Insights Analysis.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationRouteTableRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationCidr":
            suggest = "destination_cidr"
        elif key == "destinationPrefixListId":
            suggest = "destination_prefix_list_id"
        elif key == "egressOnlyInternetGatewayId":
            suggest = "egress_only_internet_gateway_id"
        elif key == "gatewayId":
            suggest = "gateway_id"
        elif key == "instanceId":
            suggest = "instance_id"
        elif key == "natGatewayId":
            suggest = "nat_gateway_id"
        elif key == "networkInterfaceId":
            suggest = "network_interface_id"
        elif key == "transitGatewayId":
            suggest = "transit_gateway_id"
        elif key == "vpcPeeringConnectionId":
            suggest = "vpc_peering_connection_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisExplanationRouteTableRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisExplanationRouteTableRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisExplanationRouteTableRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_cidr: Optional[_builtins.str] = None,
                 destination_prefix_list_id: Optional[_builtins.str] = None,
                 egress_only_internet_gateway_id: Optional[_builtins.str] = None,
                 gateway_id: Optional[_builtins.str] = None,
                 instance_id: Optional[_builtins.str] = None,
                 nat_gateway_id: Optional[_builtins.str] = None,
                 network_interface_id: Optional[_builtins.str] = None,
                 origin: Optional[_builtins.str] = None,
                 transit_gateway_id: Optional[_builtins.str] = None,
                 vpc_peering_connection_id: Optional[_builtins.str] = None):
        if destination_cidr is not None:
            pulumi.set(__self__, "destination_cidr", destination_cidr)
        if destination_prefix_list_id is not None:
            pulumi.set(__self__, "destination_prefix_list_id", destination_prefix_list_id)
        if egress_only_internet_gateway_id is not None:
            pulumi.set(__self__, "egress_only_internet_gateway_id", egress_only_internet_gateway_id)
        if gateway_id is not None:
            pulumi.set(__self__, "gateway_id", gateway_id)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if nat_gateway_id is not None:
            pulumi.set(__self__, "nat_gateway_id", nat_gateway_id)
        if network_interface_id is not None:
            pulumi.set(__self__, "network_interface_id", network_interface_id)
        if origin is not None:
            pulumi.set(__self__, "origin", origin)
        if transit_gateway_id is not None:
            pulumi.set(__self__, "transit_gateway_id", transit_gateway_id)
        if vpc_peering_connection_id is not None:
            pulumi.set(__self__, "vpc_peering_connection_id", vpc_peering_connection_id)

    @_builtins.property
    @pulumi.getter(name="destinationCidr")
    def destination_cidr(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "destination_cidr")

    @_builtins.property
    @pulumi.getter(name="destinationPrefixListId")
    def destination_prefix_list_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "destination_prefix_list_id")

    @_builtins.property
    @pulumi.getter(name="egressOnlyInternetGatewayId")
    def egress_only_internet_gateway_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "egress_only_internet_gateway_id")

    @_builtins.property
    @pulumi.getter(name="gatewayId")
    def gateway_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "gateway_id")

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "instance_id")

    @_builtins.property
    @pulumi.getter(name="natGatewayId")
    def nat_gateway_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "nat_gateway_id")

    @_builtins.property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "network_interface_id")

    @_builtins.property
    @pulumi.getter
    def origin(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "origin")

    @_builtins.property
    @pulumi.getter(name="transitGatewayId")
    def transit_gateway_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "transit_gateway_id")

    @_builtins.property
    @pulumi.getter(name="vpcPeeringConnectionId")
    def vpc_peering_connection_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "vpc_peering_connection_id")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationSecurityGroup(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str arn: ARN of the Network Insights Analysis.
        :param _builtins.str id: ID of the Network Insights Analysis.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationSecurityGroupRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portRanges":
            suggest = "port_ranges"
        elif key == "prefixListId":
            suggest = "prefix_list_id"
        elif key == "securityGroupId":
            suggest = "security_group_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisExplanationSecurityGroupRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisExplanationSecurityGroupRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisExplanationSecurityGroupRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cidr: Optional[_builtins.str] = None,
                 direction: Optional[_builtins.str] = None,
                 port_ranges: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationSecurityGroupRulePortRange']] = None,
                 prefix_list_id: Optional[_builtins.str] = None,
                 protocol: Optional[_builtins.str] = None,
                 security_group_id: Optional[_builtins.str] = None):
        if cidr is not None:
            pulumi.set(__self__, "cidr", cidr)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if port_ranges is not None:
            pulumi.set(__self__, "port_ranges", port_ranges)
        if prefix_list_id is not None:
            pulumi.set(__self__, "prefix_list_id", prefix_list_id)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if security_group_id is not None:
            pulumi.set(__self__, "security_group_id", security_group_id)

    @_builtins.property
    @pulumi.getter
    def cidr(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cidr")

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "direction")

    @_builtins.property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationSecurityGroupRulePortRange']]:
        return pulumi.get(self, "port_ranges")

    @_builtins.property
    @pulumi.getter(name="prefixListId")
    def prefix_list_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_list_id")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "security_group_id")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationSecurityGroupRulePortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisExplanationSecurityGroupRulePortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisExplanationSecurityGroupRulePortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisExplanationSecurityGroupRulePortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: Optional[_builtins.int] = None,
                 to: Optional[_builtins.int] = None):
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "to")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationSourceVpc(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str arn: ARN of the Network Insights Analysis.
        :param _builtins.str id: ID of the Network Insights Analysis.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationSubnet(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str arn: ARN of the Network Insights Analysis.
        :param _builtins.str id: ID of the Network Insights Analysis.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationSubnetRouteTable(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str arn: ARN of the Network Insights Analysis.
        :param _builtins.str id: ID of the Network Insights Analysis.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationTransitGateway(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str arn: ARN of the Network Insights Analysis.
        :param _builtins.str id: ID of the Network Insights Analysis.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationTransitGatewayAttachment(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str arn: ARN of the Network Insights Analysis.
        :param _builtins.str id: ID of the Network Insights Analysis.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationTransitGatewayRouteTable(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str arn: ARN of the Network Insights Analysis.
        :param _builtins.str id: ID of the Network Insights Analysis.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationTransitGatewayRouteTableRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attachmentId":
            suggest = "attachment_id"
        elif key == "destinationCidr":
            suggest = "destination_cidr"
        elif key == "prefixListId":
            suggest = "prefix_list_id"
        elif key == "resourceId":
            suggest = "resource_id"
        elif key == "resourceType":
            suggest = "resource_type"
        elif key == "routeOrigin":
            suggest = "route_origin"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisExplanationTransitGatewayRouteTableRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisExplanationTransitGatewayRouteTableRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisExplanationTransitGatewayRouteTableRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attachment_id: Optional[_builtins.str] = None,
                 destination_cidr: Optional[_builtins.str] = None,
                 prefix_list_id: Optional[_builtins.str] = None,
                 resource_id: Optional[_builtins.str] = None,
                 resource_type: Optional[_builtins.str] = None,
                 route_origin: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None):
        if attachment_id is not None:
            pulumi.set(__self__, "attachment_id", attachment_id)
        if destination_cidr is not None:
            pulumi.set(__self__, "destination_cidr", destination_cidr)
        if prefix_list_id is not None:
            pulumi.set(__self__, "prefix_list_id", prefix_list_id)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)
        if route_origin is not None:
            pulumi.set(__self__, "route_origin", route_origin)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="attachmentId")
    def attachment_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "attachment_id")

    @_builtins.property
    @pulumi.getter(name="destinationCidr")
    def destination_cidr(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "destination_cidr")

    @_builtins.property
    @pulumi.getter(name="prefixListId")
    def prefix_list_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_list_id")

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "resource_id")

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "resource_type")

    @_builtins.property
    @pulumi.getter(name="routeOrigin")
    def route_origin(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "route_origin")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "state")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationVpc(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str arn: ARN of the Network Insights Analysis.
        :param _builtins.str id: ID of the Network Insights Analysis.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationVpcEndpoint(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str arn: ARN of the Network Insights Analysis.
        :param _builtins.str id: ID of the Network Insights Analysis.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationVpcPeeringConnection(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str arn: ARN of the Network Insights Analysis.
        :param _builtins.str id: ID of the Network Insights Analysis.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationVpnConnection(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str arn: ARN of the Network Insights Analysis.
        :param _builtins.str id: ID of the Network Insights Analysis.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationVpnGateway(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str arn: ARN of the Network Insights Analysis.
        :param _builtins.str id: ID of the Network Insights Analysis.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisForwardPathComponent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aclRules":
            suggest = "acl_rules"
        elif key == "additionalDetails":
            suggest = "additional_details"
        elif key == "attachedTos":
            suggest = "attached_tos"
        elif key == "destinationVpcs":
            suggest = "destination_vpcs"
        elif key == "inboundHeaders":
            suggest = "inbound_headers"
        elif key == "outboundHeaders":
            suggest = "outbound_headers"
        elif key == "routeTableRoutes":
            suggest = "route_table_routes"
        elif key == "securityGroupRules":
            suggest = "security_group_rules"
        elif key == "sequenceNumber":
            suggest = "sequence_number"
        elif key == "sourceVpcs":
            suggest = "source_vpcs"
        elif key == "transitGatewayRouteTableRoutes":
            suggest = "transit_gateway_route_table_routes"
        elif key == "transitGateways":
            suggest = "transit_gateways"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisForwardPathComponent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisForwardPathComponent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisForwardPathComponent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 acl_rules: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentAclRule']] = None,
                 additional_details: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentAdditionalDetail']] = None,
                 attached_tos: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentAttachedTo']] = None,
                 components: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentComponent']] = None,
                 destination_vpcs: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentDestinationVpc']] = None,
                 inbound_headers: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentInboundHeader']] = None,
                 outbound_headers: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentOutboundHeader']] = None,
                 route_table_routes: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentRouteTableRoute']] = None,
                 security_group_rules: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentSecurityGroupRule']] = None,
                 sequence_number: Optional[_builtins.int] = None,
                 source_vpcs: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentSourceVpc']] = None,
                 subnets: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentSubnet']] = None,
                 transit_gateway_route_table_routes: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentTransitGatewayRouteTableRoute']] = None,
                 transit_gateways: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentTransitGateway']] = None,
                 vpcs: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentVpc']] = None):
        if acl_rules is not None:
            pulumi.set(__self__, "acl_rules", acl_rules)
        if additional_details is not None:
            pulumi.set(__self__, "additional_details", additional_details)
        if attached_tos is not None:
            pulumi.set(__self__, "attached_tos", attached_tos)
        if components is not None:
            pulumi.set(__self__, "components", components)
        if destination_vpcs is not None:
            pulumi.set(__self__, "destination_vpcs", destination_vpcs)
        if inbound_headers is not None:
            pulumi.set(__self__, "inbound_headers", inbound_headers)
        if outbound_headers is not None:
            pulumi.set(__self__, "outbound_headers", outbound_headers)
        if route_table_routes is not None:
            pulumi.set(__self__, "route_table_routes", route_table_routes)
        if security_group_rules is not None:
            pulumi.set(__self__, "security_group_rules", security_group_rules)
        if sequence_number is not None:
            pulumi.set(__self__, "sequence_number", sequence_number)
        if source_vpcs is not None:
            pulumi.set(__self__, "source_vpcs", source_vpcs)
        if subnets is not None:
            pulumi.set(__self__, "subnets", subnets)
        if transit_gateway_route_table_routes is not None:
            pulumi.set(__self__, "transit_gateway_route_table_routes", transit_gateway_route_table_routes)
        if transit_gateways is not None:
            pulumi.set(__self__, "transit_gateways", transit_gateways)
        if vpcs is not None:
            pulumi.set(__self__, "vpcs", vpcs)

    @_builtins.property
    @pulumi.getter(name="aclRules")
    def acl_rules(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentAclRule']]:
        return pulumi.get(self, "acl_rules")

    @_builtins.property
    @pulumi.getter(name="additionalDetails")
    def additional_details(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentAdditionalDetail']]:
        return pulumi.get(self, "additional_details")

    @_builtins.property
    @pulumi.getter(name="attachedTos")
    def attached_tos(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentAttachedTo']]:
        return pulumi.get(self, "attached_tos")

    @_builtins.property
    @pulumi.getter
    def components(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentComponent']]:
        return pulumi.get(self, "components")

    @_builtins.property
    @pulumi.getter(name="destinationVpcs")
    def destination_vpcs(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentDestinationVpc']]:
        return pulumi.get(self, "destination_vpcs")

    @_builtins.property
    @pulumi.getter(name="inboundHeaders")
    def inbound_headers(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentInboundHeader']]:
        return pulumi.get(self, "inbound_headers")

    @_builtins.property
    @pulumi.getter(name="outboundHeaders")
    def outbound_headers(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentOutboundHeader']]:
        return pulumi.get(self, "outbound_headers")

    @_builtins.property
    @pulumi.getter(name="routeTableRoutes")
    def route_table_routes(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentRouteTableRoute']]:
        return pulumi.get(self, "route_table_routes")

    @_builtins.property
    @pulumi.getter(name="securityGroupRules")
    def security_group_rules(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentSecurityGroupRule']]:
        return pulumi.get(self, "security_group_rules")

    @_builtins.property
    @pulumi.getter(name="sequenceNumber")
    def sequence_number(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "sequence_number")

    @_builtins.property
    @pulumi.getter(name="sourceVpcs")
    def source_vpcs(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentSourceVpc']]:
        return pulumi.get(self, "source_vpcs")

    @_builtins.property
    @pulumi.getter
    def subnets(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentSubnet']]:
        return pulumi.get(self, "subnets")

    @_builtins.property
    @pulumi.getter(name="transitGatewayRouteTableRoutes")
    def transit_gateway_route_table_routes(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentTransitGatewayRouteTableRoute']]:
        return pulumi.get(self, "transit_gateway_route_table_routes")

    @_builtins.property
    @pulumi.getter(name="transitGateways")
    def transit_gateways(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentTransitGateway']]:
        return pulumi.get(self, "transit_gateways")

    @_builtins.property
    @pulumi.getter
    def vpcs(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentVpc']]:
        return pulumi.get(self, "vpcs")


@pulumi.output_type
class NetworkInsightsAnalysisForwardPathComponentAclRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portRanges":
            suggest = "port_ranges"
        elif key == "ruleAction":
            suggest = "rule_action"
        elif key == "ruleNumber":
            suggest = "rule_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisForwardPathComponentAclRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisForwardPathComponentAclRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisForwardPathComponentAclRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cidr: Optional[_builtins.str] = None,
                 egress: Optional[_builtins.bool] = None,
                 port_ranges: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentAclRulePortRange']] = None,
                 protocol: Optional[_builtins.str] = None,
                 rule_action: Optional[_builtins.str] = None,
                 rule_number: Optional[_builtins.int] = None):
        if cidr is not None:
            pulumi.set(__self__, "cidr", cidr)
        if egress is not None:
            pulumi.set(__self__, "egress", egress)
        if port_ranges is not None:
            pulumi.set(__self__, "port_ranges", port_ranges)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if rule_action is not None:
            pulumi.set(__self__, "rule_action", rule_action)
        if rule_number is not None:
            pulumi.set(__self__, "rule_number", rule_number)

    @_builtins.property
    @pulumi.getter
    def cidr(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cidr")

    @_builtins.property
    @pulumi.getter
    def egress(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "egress")

    @_builtins.property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentAclRulePortRange']]:
        return pulumi.get(self, "port_ranges")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="ruleAction")
    def rule_action(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "rule_action")

    @_builtins.property
    @pulumi.getter(name="ruleNumber")
    def rule_number(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "rule_number")


@pulumi.output_type
class NetworkInsightsAnalysisForwardPathComponentAclRulePortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisForwardPathComponentAclRulePortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisForwardPathComponentAclRulePortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisForwardPathComponentAclRulePortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: Optional[_builtins.int] = None,
                 to: Optional[_builtins.int] = None):
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "to")


@pulumi.output_type
class NetworkInsightsAnalysisForwardPathComponentAdditionalDetail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalDetailType":
            suggest = "additional_detail_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisForwardPathComponentAdditionalDetail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisForwardPathComponentAdditionalDetail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisForwardPathComponentAdditionalDetail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_detail_type: Optional[_builtins.str] = None,
                 components: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentAdditionalDetailComponent']] = None):
        if additional_detail_type is not None:
            pulumi.set(__self__, "additional_detail_type", additional_detail_type)
        if components is not None:
            pulumi.set(__self__, "components", components)

    @_builtins.property
    @pulumi.getter(name="additionalDetailType")
    def additional_detail_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "additional_detail_type")

    @_builtins.property
    @pulumi.getter
    def components(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentAdditionalDetailComponent']]:
        return pulumi.get(self, "components")


@pulumi.output_type
class NetworkInsightsAnalysisForwardPathComponentAdditionalDetailComponent(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str arn: ARN of the Network Insights Analysis.
        :param _builtins.str id: ID of the Network Insights Analysis.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisForwardPathComponentAttachedTo(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str arn: ARN of the Network Insights Analysis.
        :param _builtins.str id: ID of the Network Insights Analysis.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisForwardPathComponentComponent(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str arn: ARN of the Network Insights Analysis.
        :param _builtins.str id: ID of the Network Insights Analysis.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisForwardPathComponentDestinationVpc(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str arn: ARN of the Network Insights Analysis.
        :param _builtins.str id: ID of the Network Insights Analysis.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisForwardPathComponentInboundHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationAddresses":
            suggest = "destination_addresses"
        elif key == "destinationPortRanges":
            suggest = "destination_port_ranges"
        elif key == "sourceAddresses":
            suggest = "source_addresses"
        elif key == "sourcePortRanges":
            suggest = "source_port_ranges"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisForwardPathComponentInboundHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisForwardPathComponentInboundHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisForwardPathComponentInboundHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_addresses: Optional[Sequence[_builtins.str]] = None,
                 destination_port_ranges: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentInboundHeaderDestinationPortRange']] = None,
                 protocol: Optional[_builtins.str] = None,
                 source_addresses: Optional[Sequence[_builtins.str]] = None,
                 source_port_ranges: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentInboundHeaderSourcePortRange']] = None):
        if destination_addresses is not None:
            pulumi.set(__self__, "destination_addresses", destination_addresses)
        if destination_port_ranges is not None:
            pulumi.set(__self__, "destination_port_ranges", destination_port_ranges)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if source_addresses is not None:
            pulumi.set(__self__, "source_addresses", source_addresses)
        if source_port_ranges is not None:
            pulumi.set(__self__, "source_port_ranges", source_port_ranges)

    @_builtins.property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "destination_addresses")

    @_builtins.property
    @pulumi.getter(name="destinationPortRanges")
    def destination_port_ranges(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentInboundHeaderDestinationPortRange']]:
        return pulumi.get(self, "destination_port_ranges")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "source_addresses")

    @_builtins.property
    @pulumi.getter(name="sourcePortRanges")
    def source_port_ranges(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentInboundHeaderSourcePortRange']]:
        return pulumi.get(self, "source_port_ranges")


@pulumi.output_type
class NetworkInsightsAnalysisForwardPathComponentInboundHeaderDestinationPortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisForwardPathComponentInboundHeaderDestinationPortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisForwardPathComponentInboundHeaderDestinationPortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisForwardPathComponentInboundHeaderDestinationPortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: Optional[_builtins.int] = None,
                 to: Optional[_builtins.int] = None):
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "to")


@pulumi.output_type
class NetworkInsightsAnalysisForwardPathComponentInboundHeaderSourcePortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisForwardPathComponentInboundHeaderSourcePortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisForwardPathComponentInboundHeaderSourcePortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisForwardPathComponentInboundHeaderSourcePortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: Optional[_builtins.int] = None,
                 to: Optional[_builtins.int] = None):
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "to")


@pulumi.output_type
class NetworkInsightsAnalysisForwardPathComponentOutboundHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationAddresses":
            suggest = "destination_addresses"
        elif key == "destinationPortRanges":
            suggest = "destination_port_ranges"
        elif key == "sourceAddresses":
            suggest = "source_addresses"
        elif key == "sourcePortRanges":
            suggest = "source_port_ranges"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisForwardPathComponentOutboundHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisForwardPathComponentOutboundHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisForwardPathComponentOutboundHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_addresses: Optional[Sequence[_builtins.str]] = None,
                 destination_port_ranges: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentOutboundHeaderDestinationPortRange']] = None,
                 protocol: Optional[_builtins.str] = None,
                 source_addresses: Optional[Sequence[_builtins.str]] = None,
                 source_port_ranges: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentOutboundHeaderSourcePortRange']] = None):
        if destination_addresses is not None:
            pulumi.set(__self__, "destination_addresses", destination_addresses)
        if destination_port_ranges is not None:
            pulumi.set(__self__, "destination_port_ranges", destination_port_ranges)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if source_addresses is not None:
            pulumi.set(__self__, "source_addresses", source_addresses)
        if source_port_ranges is not None:
            pulumi.set(__self__, "source_port_ranges", source_port_ranges)

    @_builtins.property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "destination_addresses")

    @_builtins.property
    @pulumi.getter(name="destinationPortRanges")
    def destination_port_ranges(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentOutboundHeaderDestinationPortRange']]:
        return pulumi.get(self, "destination_port_ranges")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "source_addresses")

    @_builtins.property
    @pulumi.getter(name="sourcePortRanges")
    def source_port_ranges(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentOutboundHeaderSourcePortRange']]:
        return pulumi.get(self, "source_port_ranges")


@pulumi.output_type
class NetworkInsightsAnalysisForwardPathComponentOutboundHeaderDestinationPortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisForwardPathComponentOutboundHeaderDestinationPortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisForwardPathComponentOutboundHeaderDestinationPortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisForwardPathComponentOutboundHeaderDestinationPortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: Optional[_builtins.int] = None,
                 to: Optional[_builtins.int] = None):
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "to")


@pulumi.output_type
class NetworkInsightsAnalysisForwardPathComponentOutboundHeaderSourcePortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisForwardPathComponentOutboundHeaderSourcePortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisForwardPathComponentOutboundHeaderSourcePortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisForwardPathComponentOutboundHeaderSourcePortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: Optional[_builtins.int] = None,
                 to: Optional[_builtins.int] = None):
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "to")


@pulumi.output_type
class NetworkInsightsAnalysisForwardPathComponentRouteTableRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationCidr":
            suggest = "destination_cidr"
        elif key == "destinationPrefixListId":
            suggest = "destination_prefix_list_id"
        elif key == "egressOnlyInternetGatewayId":
            suggest = "egress_only_internet_gateway_id"
        elif key == "gatewayId":
            suggest = "gateway_id"
        elif key == "instanceId":
            suggest = "instance_id"
        elif key == "natGatewayId":
            suggest = "nat_gateway_id"
        elif key == "networkInterfaceId":
            suggest = "network_interface_id"
        elif key == "transitGatewayId":
            suggest = "transit_gateway_id"
        elif key == "vpcPeeringConnectionId":
            suggest = "vpc_peering_connection_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisForwardPathComponentRouteTableRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisForwardPathComponentRouteTableRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisForwardPathComponentRouteTableRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_cidr: Optional[_builtins.str] = None,
                 destination_prefix_list_id: Optional[_builtins.str] = None,
                 egress_only_internet_gateway_id: Optional[_builtins.str] = None,
                 gateway_id: Optional[_builtins.str] = None,
                 instance_id: Optional[_builtins.str] = None,
                 nat_gateway_id: Optional[_builtins.str] = None,
                 network_interface_id: Optional[_builtins.str] = None,
                 origin: Optional[_builtins.str] = None,
                 transit_gateway_id: Optional[_builtins.str] = None,
                 vpc_peering_connection_id: Optional[_builtins.str] = None):
        if destination_cidr is not None:
            pulumi.set(__self__, "destination_cidr", destination_cidr)
        if destination_prefix_list_id is not None:
            pulumi.set(__self__, "destination_prefix_list_id", destination_prefix_list_id)
        if egress_only_internet_gateway_id is not None:
            pulumi.set(__self__, "egress_only_internet_gateway_id", egress_only_internet_gateway_id)
        if gateway_id is not None:
            pulumi.set(__self__, "gateway_id", gateway_id)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if nat_gateway_id is not None:
            pulumi.set(__self__, "nat_gateway_id", nat_gateway_id)
        if network_interface_id is not None:
            pulumi.set(__self__, "network_interface_id", network_interface_id)
        if origin is not None:
            pulumi.set(__self__, "origin", origin)
        if transit_gateway_id is not None:
            pulumi.set(__self__, "transit_gateway_id", transit_gateway_id)
        if vpc_peering_connection_id is not None:
            pulumi.set(__self__, "vpc_peering_connection_id", vpc_peering_connection_id)

    @_builtins.property
    @pulumi.getter(name="destinationCidr")
    def destination_cidr(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "destination_cidr")

    @_builtins.property
    @pulumi.getter(name="destinationPrefixListId")
    def destination_prefix_list_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "destination_prefix_list_id")

    @_builtins.property
    @pulumi.getter(name="egressOnlyInternetGatewayId")
    def egress_only_internet_gateway_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "egress_only_internet_gateway_id")

    @_builtins.property
    @pulumi.getter(name="gatewayId")
    def gateway_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "gateway_id")

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "instance_id")

    @_builtins.property
    @pulumi.getter(name="natGatewayId")
    def nat_gateway_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "nat_gateway_id")

    @_builtins.property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "network_interface_id")

    @_builtins.property
    @pulumi.getter
    def origin(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "origin")

    @_builtins.property
    @pulumi.getter(name="transitGatewayId")
    def transit_gateway_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "transit_gateway_id")

    @_builtins.property
    @pulumi.getter(name="vpcPeeringConnectionId")
    def vpc_peering_connection_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "vpc_peering_connection_id")


@pulumi.output_type
class NetworkInsightsAnalysisForwardPathComponentSecurityGroupRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portRanges":
            suggest = "port_ranges"
        elif key == "prefixListId":
            suggest = "prefix_list_id"
        elif key == "securityGroupId":
            suggest = "security_group_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisForwardPathComponentSecurityGroupRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisForwardPathComponentSecurityGroupRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisForwardPathComponentSecurityGroupRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cidr: Optional[_builtins.str] = None,
                 direction: Optional[_builtins.str] = None,
                 port_ranges: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentSecurityGroupRulePortRange']] = None,
                 prefix_list_id: Optional[_builtins.str] = None,
                 protocol: Optional[_builtins.str] = None,
                 security_group_id: Optional[_builtins.str] = None):
        if cidr is not None:
            pulumi.set(__self__, "cidr", cidr)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if port_ranges is not None:
            pulumi.set(__self__, "port_ranges", port_ranges)
        if prefix_list_id is not None:
            pulumi.set(__self__, "prefix_list_id", prefix_list_id)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if security_group_id is not None:
            pulumi.set(__self__, "security_group_id", security_group_id)

    @_builtins.property
    @pulumi.getter
    def cidr(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cidr")

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "direction")

    @_builtins.property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentSecurityGroupRulePortRange']]:
        return pulumi.get(self, "port_ranges")

    @_builtins.property
    @pulumi.getter(name="prefixListId")
    def prefix_list_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_list_id")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "security_group_id")


@pulumi.output_type
class NetworkInsightsAnalysisForwardPathComponentSecurityGroupRulePortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisForwardPathComponentSecurityGroupRulePortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisForwardPathComponentSecurityGroupRulePortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisForwardPathComponentSecurityGroupRulePortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: Optional[_builtins.int] = None,
                 to: Optional[_builtins.int] = None):
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "to")


@pulumi.output_type
class NetworkInsightsAnalysisForwardPathComponentSourceVpc(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str arn: ARN of the Network Insights Analysis.
        :param _builtins.str id: ID of the Network Insights Analysis.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisForwardPathComponentSubnet(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str arn: ARN of the Network Insights Analysis.
        :param _builtins.str id: ID of the Network Insights Analysis.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisForwardPathComponentTransitGateway(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str arn: ARN of the Network Insights Analysis.
        :param _builtins.str id: ID of the Network Insights Analysis.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisForwardPathComponentTransitGatewayRouteTableRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attachmentId":
            suggest = "attachment_id"
        elif key == "destinationCidr":
            suggest = "destination_cidr"
        elif key == "prefixListId":
            suggest = "prefix_list_id"
        elif key == "resourceId":
            suggest = "resource_id"
        elif key == "resourceType":
            suggest = "resource_type"
        elif key == "routeOrigin":
            suggest = "route_origin"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisForwardPathComponentTransitGatewayRouteTableRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisForwardPathComponentTransitGatewayRouteTableRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisForwardPathComponentTransitGatewayRouteTableRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attachment_id: Optional[_builtins.str] = None,
                 destination_cidr: Optional[_builtins.str] = None,
                 prefix_list_id: Optional[_builtins.str] = None,
                 resource_id: Optional[_builtins.str] = None,
                 resource_type: Optional[_builtins.str] = None,
                 route_origin: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None):
        if attachment_id is not None:
            pulumi.set(__self__, "attachment_id", attachment_id)
        if destination_cidr is not None:
            pulumi.set(__self__, "destination_cidr", destination_cidr)
        if prefix_list_id is not None:
            pulumi.set(__self__, "prefix_list_id", prefix_list_id)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)
        if route_origin is not None:
            pulumi.set(__self__, "route_origin", route_origin)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="attachmentId")
    def attachment_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "attachment_id")

    @_builtins.property
    @pulumi.getter(name="destinationCidr")
    def destination_cidr(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "destination_cidr")

    @_builtins.property
    @pulumi.getter(name="prefixListId")
    def prefix_list_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_list_id")

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "resource_id")

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "resource_type")

    @_builtins.property
    @pulumi.getter(name="routeOrigin")
    def route_origin(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "route_origin")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "state")


@pulumi.output_type
class NetworkInsightsAnalysisForwardPathComponentVpc(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str arn: ARN of the Network Insights Analysis.
        :param _builtins.str id: ID of the Network Insights Analysis.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisReturnPathComponent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aclRules":
            suggest = "acl_rules"
        elif key == "additionalDetails":
            suggest = "additional_details"
        elif key == "attachedTos":
            suggest = "attached_tos"
        elif key == "destinationVpcs":
            suggest = "destination_vpcs"
        elif key == "inboundHeaders":
            suggest = "inbound_headers"
        elif key == "outboundHeaders":
            suggest = "outbound_headers"
        elif key == "routeTableRoutes":
            suggest = "route_table_routes"
        elif key == "securityGroupRules":
            suggest = "security_group_rules"
        elif key == "sequenceNumber":
            suggest = "sequence_number"
        elif key == "sourceVpcs":
            suggest = "source_vpcs"
        elif key == "transitGatewayRouteTableRoutes":
            suggest = "transit_gateway_route_table_routes"
        elif key == "transitGateways":
            suggest = "transit_gateways"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisReturnPathComponent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisReturnPathComponent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisReturnPathComponent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 acl_rules: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentAclRule']] = None,
                 additional_details: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentAdditionalDetail']] = None,
                 attached_tos: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentAttachedTo']] = None,
                 components: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentComponent']] = None,
                 destination_vpcs: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentDestinationVpc']] = None,
                 inbound_headers: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentInboundHeader']] = None,
                 outbound_headers: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentOutboundHeader']] = None,
                 route_table_routes: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentRouteTableRoute']] = None,
                 security_group_rules: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentSecurityGroupRule']] = None,
                 sequence_number: Optional[_builtins.int] = None,
                 source_vpcs: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentSourceVpc']] = None,
                 subnets: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentSubnet']] = None,
                 transit_gateway_route_table_routes: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentTransitGatewayRouteTableRoute']] = None,
                 transit_gateways: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentTransitGateway']] = None,
                 vpcs: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentVpc']] = None):
        if acl_rules is not None:
            pulumi.set(__self__, "acl_rules", acl_rules)
        if additional_details is not None:
            pulumi.set(__self__, "additional_details", additional_details)
        if attached_tos is not None:
            pulumi.set(__self__, "attached_tos", attached_tos)
        if components is not None:
            pulumi.set(__self__, "components", components)
        if destination_vpcs is not None:
            pulumi.set(__self__, "destination_vpcs", destination_vpcs)
        if inbound_headers is not None:
            pulumi.set(__self__, "inbound_headers", inbound_headers)
        if outbound_headers is not None:
            pulumi.set(__self__, "outbound_headers", outbound_headers)
        if route_table_routes is not None:
            pulumi.set(__self__, "route_table_routes", route_table_routes)
        if security_group_rules is not None:
            pulumi.set(__self__, "security_group_rules", security_group_rules)
        if sequence_number is not None:
            pulumi.set(__self__, "sequence_number", sequence_number)
        if source_vpcs is not None:
            pulumi.set(__self__, "source_vpcs", source_vpcs)
        if subnets is not None:
            pulumi.set(__self__, "subnets", subnets)
        if transit_gateway_route_table_routes is not None:
            pulumi.set(__self__, "transit_gateway_route_table_routes", transit_gateway_route_table_routes)
        if transit_gateways is not None:
            pulumi.set(__self__, "transit_gateways", transit_gateways)
        if vpcs is not None:
            pulumi.set(__self__, "vpcs", vpcs)

    @_builtins.property
    @pulumi.getter(name="aclRules")
    def acl_rules(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentAclRule']]:
        return pulumi.get(self, "acl_rules")

    @_builtins.property
    @pulumi.getter(name="additionalDetails")
    def additional_details(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentAdditionalDetail']]:
        return pulumi.get(self, "additional_details")

    @_builtins.property
    @pulumi.getter(name="attachedTos")
    def attached_tos(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentAttachedTo']]:
        return pulumi.get(self, "attached_tos")

    @_builtins.property
    @pulumi.getter
    def components(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentComponent']]:
        return pulumi.get(self, "components")

    @_builtins.property
    @pulumi.getter(name="destinationVpcs")
    def destination_vpcs(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentDestinationVpc']]:
        return pulumi.get(self, "destination_vpcs")

    @_builtins.property
    @pulumi.getter(name="inboundHeaders")
    def inbound_headers(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentInboundHeader']]:
        return pulumi.get(self, "inbound_headers")

    @_builtins.property
    @pulumi.getter(name="outboundHeaders")
    def outbound_headers(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentOutboundHeader']]:
        return pulumi.get(self, "outbound_headers")

    @_builtins.property
    @pulumi.getter(name="routeTableRoutes")
    def route_table_routes(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentRouteTableRoute']]:
        return pulumi.get(self, "route_table_routes")

    @_builtins.property
    @pulumi.getter(name="securityGroupRules")
    def security_group_rules(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentSecurityGroupRule']]:
        return pulumi.get(self, "security_group_rules")

    @_builtins.property
    @pulumi.getter(name="sequenceNumber")
    def sequence_number(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "sequence_number")

    @_builtins.property
    @pulumi.getter(name="sourceVpcs")
    def source_vpcs(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentSourceVpc']]:
        return pulumi.get(self, "source_vpcs")

    @_builtins.property
    @pulumi.getter
    def subnets(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentSubnet']]:
        return pulumi.get(self, "subnets")

    @_builtins.property
    @pulumi.getter(name="transitGatewayRouteTableRoutes")
    def transit_gateway_route_table_routes(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentTransitGatewayRouteTableRoute']]:
        return pulumi.get(self, "transit_gateway_route_table_routes")

    @_builtins.property
    @pulumi.getter(name="transitGateways")
    def transit_gateways(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentTransitGateway']]:
        return pulumi.get(self, "transit_gateways")

    @_builtins.property
    @pulumi.getter
    def vpcs(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentVpc']]:
        return pulumi.get(self, "vpcs")


@pulumi.output_type
class NetworkInsightsAnalysisReturnPathComponentAclRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portRanges":
            suggest = "port_ranges"
        elif key == "ruleAction":
            suggest = "rule_action"
        elif key == "ruleNumber":
            suggest = "rule_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisReturnPathComponentAclRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisReturnPathComponentAclRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisReturnPathComponentAclRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cidr: Optional[_builtins.str] = None,
                 egress: Optional[_builtins.bool] = None,
                 port_ranges: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentAclRulePortRange']] = None,
                 protocol: Optional[_builtins.str] = None,
                 rule_action: Optional[_builtins.str] = None,
                 rule_number: Optional[_builtins.int] = None):
        if cidr is not None:
            pulumi.set(__self__, "cidr", cidr)
        if egress is not None:
            pulumi.set(__self__, "egress", egress)
        if port_ranges is not None:
            pulumi.set(__self__, "port_ranges", port_ranges)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if rule_action is not None:
            pulumi.set(__self__, "rule_action", rule_action)
        if rule_number is not None:
            pulumi.set(__self__, "rule_number", rule_number)

    @_builtins.property
    @pulumi.getter
    def cidr(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cidr")

    @_builtins.property
    @pulumi.getter
    def egress(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "egress")

    @_builtins.property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentAclRulePortRange']]:
        return pulumi.get(self, "port_ranges")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="ruleAction")
    def rule_action(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "rule_action")

    @_builtins.property
    @pulumi.getter(name="ruleNumber")
    def rule_number(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "rule_number")


@pulumi.output_type
class NetworkInsightsAnalysisReturnPathComponentAclRulePortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisReturnPathComponentAclRulePortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisReturnPathComponentAclRulePortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisReturnPathComponentAclRulePortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: Optional[_builtins.int] = None,
                 to: Optional[_builtins.int] = None):
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "to")


@pulumi.output_type
class NetworkInsightsAnalysisReturnPathComponentAdditionalDetail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalDetailType":
            suggest = "additional_detail_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisReturnPathComponentAdditionalDetail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisReturnPathComponentAdditionalDetail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisReturnPathComponentAdditionalDetail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_detail_type: Optional[_builtins.str] = None,
                 components: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentAdditionalDetailComponent']] = None):
        if additional_detail_type is not None:
            pulumi.set(__self__, "additional_detail_type", additional_detail_type)
        if components is not None:
            pulumi.set(__self__, "components", components)

    @_builtins.property
    @pulumi.getter(name="additionalDetailType")
    def additional_detail_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "additional_detail_type")

    @_builtins.property
    @pulumi.getter
    def components(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentAdditionalDetailComponent']]:
        return pulumi.get(self, "components")


@pulumi.output_type
class NetworkInsightsAnalysisReturnPathComponentAdditionalDetailComponent(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str arn: ARN of the Network Insights Analysis.
        :param _builtins.str id: ID of the Network Insights Analysis.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisReturnPathComponentAttachedTo(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str arn: ARN of the Network Insights Analysis.
        :param _builtins.str id: ID of the Network Insights Analysis.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisReturnPathComponentComponent(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str arn: ARN of the Network Insights Analysis.
        :param _builtins.str id: ID of the Network Insights Analysis.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisReturnPathComponentDestinationVpc(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str arn: ARN of the Network Insights Analysis.
        :param _builtins.str id: ID of the Network Insights Analysis.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisReturnPathComponentInboundHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationAddresses":
            suggest = "destination_addresses"
        elif key == "destinationPortRanges":
            suggest = "destination_port_ranges"
        elif key == "sourceAddresses":
            suggest = "source_addresses"
        elif key == "sourcePortRanges":
            suggest = "source_port_ranges"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisReturnPathComponentInboundHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisReturnPathComponentInboundHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisReturnPathComponentInboundHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_addresses: Optional[Sequence[_builtins.str]] = None,
                 destination_port_ranges: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentInboundHeaderDestinationPortRange']] = None,
                 protocol: Optional[_builtins.str] = None,
                 source_addresses: Optional[Sequence[_builtins.str]] = None,
                 source_port_ranges: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentInboundHeaderSourcePortRange']] = None):
        if destination_addresses is not None:
            pulumi.set(__self__, "destination_addresses", destination_addresses)
        if destination_port_ranges is not None:
            pulumi.set(__self__, "destination_port_ranges", destination_port_ranges)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if source_addresses is not None:
            pulumi.set(__self__, "source_addresses", source_addresses)
        if source_port_ranges is not None:
            pulumi.set(__self__, "source_port_ranges", source_port_ranges)

    @_builtins.property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "destination_addresses")

    @_builtins.property
    @pulumi.getter(name="destinationPortRanges")
    def destination_port_ranges(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentInboundHeaderDestinationPortRange']]:
        return pulumi.get(self, "destination_port_ranges")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "source_addresses")

    @_builtins.property
    @pulumi.getter(name="sourcePortRanges")
    def source_port_ranges(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentInboundHeaderSourcePortRange']]:
        return pulumi.get(self, "source_port_ranges")


@pulumi.output_type
class NetworkInsightsAnalysisReturnPathComponentInboundHeaderDestinationPortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisReturnPathComponentInboundHeaderDestinationPortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisReturnPathComponentInboundHeaderDestinationPortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisReturnPathComponentInboundHeaderDestinationPortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: Optional[_builtins.int] = None,
                 to: Optional[_builtins.int] = None):
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "to")


@pulumi.output_type
class NetworkInsightsAnalysisReturnPathComponentInboundHeaderSourcePortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisReturnPathComponentInboundHeaderSourcePortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisReturnPathComponentInboundHeaderSourcePortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisReturnPathComponentInboundHeaderSourcePortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: Optional[_builtins.int] = None,
                 to: Optional[_builtins.int] = None):
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "to")


@pulumi.output_type
class NetworkInsightsAnalysisReturnPathComponentOutboundHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationAddresses":
            suggest = "destination_addresses"
        elif key == "destinationPortRanges":
            suggest = "destination_port_ranges"
        elif key == "sourceAddresses":
            suggest = "source_addresses"
        elif key == "sourcePortRanges":
            suggest = "source_port_ranges"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisReturnPathComponentOutboundHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisReturnPathComponentOutboundHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisReturnPathComponentOutboundHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_addresses: Optional[Sequence[_builtins.str]] = None,
                 destination_port_ranges: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentOutboundHeaderDestinationPortRange']] = None,
                 protocol: Optional[_builtins.str] = None,
                 source_addresses: Optional[Sequence[_builtins.str]] = None,
                 source_port_ranges: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentOutboundHeaderSourcePortRange']] = None):
        if destination_addresses is not None:
            pulumi.set(__self__, "destination_addresses", destination_addresses)
        if destination_port_ranges is not None:
            pulumi.set(__self__, "destination_port_ranges", destination_port_ranges)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if source_addresses is not None:
            pulumi.set(__self__, "source_addresses", source_addresses)
        if source_port_ranges is not None:
            pulumi.set(__self__, "source_port_ranges", source_port_ranges)

    @_builtins.property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "destination_addresses")

    @_builtins.property
    @pulumi.getter(name="destinationPortRanges")
    def destination_port_ranges(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentOutboundHeaderDestinationPortRange']]:
        return pulumi.get(self, "destination_port_ranges")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "source_addresses")

    @_builtins.property
    @pulumi.getter(name="sourcePortRanges")
    def source_port_ranges(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentOutboundHeaderSourcePortRange']]:
        return pulumi.get(self, "source_port_ranges")


@pulumi.output_type
class NetworkInsightsAnalysisReturnPathComponentOutboundHeaderDestinationPortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisReturnPathComponentOutboundHeaderDestinationPortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisReturnPathComponentOutboundHeaderDestinationPortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisReturnPathComponentOutboundHeaderDestinationPortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: Optional[_builtins.int] = None,
                 to: Optional[_builtins.int] = None):
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "to")


@pulumi.output_type
class NetworkInsightsAnalysisReturnPathComponentOutboundHeaderSourcePortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisReturnPathComponentOutboundHeaderSourcePortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisReturnPathComponentOutboundHeaderSourcePortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisReturnPathComponentOutboundHeaderSourcePortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: Optional[_builtins.int] = None,
                 to: Optional[_builtins.int] = None):
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "to")


@pulumi.output_type
class NetworkInsightsAnalysisReturnPathComponentRouteTableRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationCidr":
            suggest = "destination_cidr"
        elif key == "destinationPrefixListId":
            suggest = "destination_prefix_list_id"
        elif key == "egressOnlyInternetGatewayId":
            suggest = "egress_only_internet_gateway_id"
        elif key == "gatewayId":
            suggest = "gateway_id"
        elif key == "instanceId":
            suggest = "instance_id"
        elif key == "natGatewayId":
            suggest = "nat_gateway_id"
        elif key == "networkInterfaceId":
            suggest = "network_interface_id"
        elif key == "transitGatewayId":
            suggest = "transit_gateway_id"
        elif key == "vpcPeeringConnectionId":
            suggest = "vpc_peering_connection_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisReturnPathComponentRouteTableRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisReturnPathComponentRouteTableRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisReturnPathComponentRouteTableRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_cidr: Optional[_builtins.str] = None,
                 destination_prefix_list_id: Optional[_builtins.str] = None,
                 egress_only_internet_gateway_id: Optional[_builtins.str] = None,
                 gateway_id: Optional[_builtins.str] = None,
                 instance_id: Optional[_builtins.str] = None,
                 nat_gateway_id: Optional[_builtins.str] = None,
                 network_interface_id: Optional[_builtins.str] = None,
                 origin: Optional[_builtins.str] = None,
                 transit_gateway_id: Optional[_builtins.str] = None,
                 vpc_peering_connection_id: Optional[_builtins.str] = None):
        if destination_cidr is not None:
            pulumi.set(__self__, "destination_cidr", destination_cidr)
        if destination_prefix_list_id is not None:
            pulumi.set(__self__, "destination_prefix_list_id", destination_prefix_list_id)
        if egress_only_internet_gateway_id is not None:
            pulumi.set(__self__, "egress_only_internet_gateway_id", egress_only_internet_gateway_id)
        if gateway_id is not None:
            pulumi.set(__self__, "gateway_id", gateway_id)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if nat_gateway_id is not None:
            pulumi.set(__self__, "nat_gateway_id", nat_gateway_id)
        if network_interface_id is not None:
            pulumi.set(__self__, "network_interface_id", network_interface_id)
        if origin is not None:
            pulumi.set(__self__, "origin", origin)
        if transit_gateway_id is not None:
            pulumi.set(__self__, "transit_gateway_id", transit_gateway_id)
        if vpc_peering_connection_id is not None:
            pulumi.set(__self__, "vpc_peering_connection_id", vpc_peering_connection_id)

    @_builtins.property
    @pulumi.getter(name="destinationCidr")
    def destination_cidr(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "destination_cidr")

    @_builtins.property
    @pulumi.getter(name="destinationPrefixListId")
    def destination_prefix_list_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "destination_prefix_list_id")

    @_builtins.property
    @pulumi.getter(name="egressOnlyInternetGatewayId")
    def egress_only_internet_gateway_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "egress_only_internet_gateway_id")

    @_builtins.property
    @pulumi.getter(name="gatewayId")
    def gateway_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "gateway_id")

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "instance_id")

    @_builtins.property
    @pulumi.getter(name="natGatewayId")
    def nat_gateway_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "nat_gateway_id")

    @_builtins.property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "network_interface_id")

    @_builtins.property
    @pulumi.getter
    def origin(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "origin")

    @_builtins.property
    @pulumi.getter(name="transitGatewayId")
    def transit_gateway_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "transit_gateway_id")

    @_builtins.property
    @pulumi.getter(name="vpcPeeringConnectionId")
    def vpc_peering_connection_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "vpc_peering_connection_id")


@pulumi.output_type
class NetworkInsightsAnalysisReturnPathComponentSecurityGroupRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portRanges":
            suggest = "port_ranges"
        elif key == "prefixListId":
            suggest = "prefix_list_id"
        elif key == "securityGroupId":
            suggest = "security_group_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisReturnPathComponentSecurityGroupRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisReturnPathComponentSecurityGroupRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisReturnPathComponentSecurityGroupRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cidr: Optional[_builtins.str] = None,
                 direction: Optional[_builtins.str] = None,
                 port_ranges: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentSecurityGroupRulePortRange']] = None,
                 prefix_list_id: Optional[_builtins.str] = None,
                 protocol: Optional[_builtins.str] = None,
                 security_group_id: Optional[_builtins.str] = None):
        if cidr is not None:
            pulumi.set(__self__, "cidr", cidr)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if port_ranges is not None:
            pulumi.set(__self__, "port_ranges", port_ranges)
        if prefix_list_id is not None:
            pulumi.set(__self__, "prefix_list_id", prefix_list_id)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if security_group_id is not None:
            pulumi.set(__self__, "security_group_id", security_group_id)

    @_builtins.property
    @pulumi.getter
    def cidr(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cidr")

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "direction")

    @_builtins.property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentSecurityGroupRulePortRange']]:
        return pulumi.get(self, "port_ranges")

    @_builtins.property
    @pulumi.getter(name="prefixListId")
    def prefix_list_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_list_id")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "security_group_id")


@pulumi.output_type
class NetworkInsightsAnalysisReturnPathComponentSecurityGroupRulePortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisReturnPathComponentSecurityGroupRulePortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisReturnPathComponentSecurityGroupRulePortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisReturnPathComponentSecurityGroupRulePortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: Optional[_builtins.int] = None,
                 to: Optional[_builtins.int] = None):
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "to")


@pulumi.output_type
class NetworkInsightsAnalysisReturnPathComponentSourceVpc(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str arn: ARN of the Network Insights Analysis.
        :param _builtins.str id: ID of the Network Insights Analysis.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisReturnPathComponentSubnet(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str arn: ARN of the Network Insights Analysis.
        :param _builtins.str id: ID of the Network Insights Analysis.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisReturnPathComponentTransitGateway(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str arn: ARN of the Network Insights Analysis.
        :param _builtins.str id: ID of the Network Insights Analysis.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisReturnPathComponentTransitGatewayRouteTableRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attachmentId":
            suggest = "attachment_id"
        elif key == "destinationCidr":
            suggest = "destination_cidr"
        elif key == "prefixListId":
            suggest = "prefix_list_id"
        elif key == "resourceId":
            suggest = "resource_id"
        elif key == "resourceType":
            suggest = "resource_type"
        elif key == "routeOrigin":
            suggest = "route_origin"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisReturnPathComponentTransitGatewayRouteTableRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisReturnPathComponentTransitGatewayRouteTableRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisReturnPathComponentTransitGatewayRouteTableRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attachment_id: Optional[_builtins.str] = None,
                 destination_cidr: Optional[_builtins.str] = None,
                 prefix_list_id: Optional[_builtins.str] = None,
                 resource_id: Optional[_builtins.str] = None,
                 resource_type: Optional[_builtins.str] = None,
                 route_origin: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None):
        if attachment_id is not None:
            pulumi.set(__self__, "attachment_id", attachment_id)
        if destination_cidr is not None:
            pulumi.set(__self__, "destination_cidr", destination_cidr)
        if prefix_list_id is not None:
            pulumi.set(__self__, "prefix_list_id", prefix_list_id)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)
        if route_origin is not None:
            pulumi.set(__self__, "route_origin", route_origin)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="attachmentId")
    def attachment_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "attachment_id")

    @_builtins.property
    @pulumi.getter(name="destinationCidr")
    def destination_cidr(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "destination_cidr")

    @_builtins.property
    @pulumi.getter(name="prefixListId")
    def prefix_list_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_list_id")

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "resource_id")

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "resource_type")

    @_builtins.property
    @pulumi.getter(name="routeOrigin")
    def route_origin(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "route_origin")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "state")


@pulumi.output_type
class NetworkInsightsAnalysisReturnPathComponentVpc(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str arn: ARN of the Network Insights Analysis.
        :param _builtins.str id: ID of the Network Insights Analysis.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsPathFilterAtDestination(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationAddress":
            suggest = "destination_address"
        elif key == "destinationPortRange":
            suggest = "destination_port_range"
        elif key == "sourceAddress":
            suggest = "source_address"
        elif key == "sourcePortRange":
            suggest = "source_port_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsPathFilterAtDestination. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsPathFilterAtDestination.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsPathFilterAtDestination.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_address: Optional[_builtins.str] = None,
                 destination_port_range: Optional['outputs.NetworkInsightsPathFilterAtDestinationDestinationPortRange'] = None,
                 source_address: Optional[_builtins.str] = None,
                 source_port_range: Optional['outputs.NetworkInsightsPathFilterAtDestinationSourcePortRange'] = None):
        """
        :param _builtins.str destination_address: The destination IPv4 address.
        :param 'NetworkInsightsPathFilterAtDestinationDestinationPortRangeArgs' destination_port_range: The destination port range. See below for details.
        :param _builtins.str source_address: IP address of the source resource.
        :param 'NetworkInsightsPathFilterAtDestinationSourcePortRangeArgs' source_port_range: The source port range. See below for details.
        """
        if destination_address is not None:
            pulumi.set(__self__, "destination_address", destination_address)
        if destination_port_range is not None:
            pulumi.set(__self__, "destination_port_range", destination_port_range)
        if source_address is not None:
            pulumi.set(__self__, "source_address", source_address)
        if source_port_range is not None:
            pulumi.set(__self__, "source_port_range", source_port_range)

    @_builtins.property
    @pulumi.getter(name="destinationAddress")
    def destination_address(self) -> Optional[_builtins.str]:
        """
        The destination IPv4 address.
        """
        return pulumi.get(self, "destination_address")

    @_builtins.property
    @pulumi.getter(name="destinationPortRange")
    def destination_port_range(self) -> Optional['outputs.NetworkInsightsPathFilterAtDestinationDestinationPortRange']:
        """
        The destination port range. See below for details.
        """
        return pulumi.get(self, "destination_port_range")

    @_builtins.property
    @pulumi.getter(name="sourceAddress")
    def source_address(self) -> Optional[_builtins.str]:
        """
        IP address of the source resource.
        """
        return pulumi.get(self, "source_address")

    @_builtins.property
    @pulumi.getter(name="sourcePortRange")
    def source_port_range(self) -> Optional['outputs.NetworkInsightsPathFilterAtDestinationSourcePortRange']:
        """
        The source port range. See below for details.
        """
        return pulumi.get(self, "source_port_range")


@pulumi.output_type
class NetworkInsightsPathFilterAtDestinationDestinationPortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromPort":
            suggest = "from_port"
        elif key == "toPort":
            suggest = "to_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsPathFilterAtDestinationDestinationPortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsPathFilterAtDestinationDestinationPortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsPathFilterAtDestinationDestinationPortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_port: Optional[_builtins.int] = None,
                 to_port: Optional[_builtins.int] = None):
        """
        :param _builtins.int from_port: The first port in the range.
        :param _builtins.int to_port: The last port in the range.
        """
        if from_port is not None:
            pulumi.set(__self__, "from_port", from_port)
        if to_port is not None:
            pulumi.set(__self__, "to_port", to_port)

    @_builtins.property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> Optional[_builtins.int]:
        """
        The first port in the range.
        """
        return pulumi.get(self, "from_port")

    @_builtins.property
    @pulumi.getter(name="toPort")
    def to_port(self) -> Optional[_builtins.int]:
        """
        The last port in the range.
        """
        return pulumi.get(self, "to_port")


@pulumi.output_type
class NetworkInsightsPathFilterAtDestinationSourcePortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromPort":
            suggest = "from_port"
        elif key == "toPort":
            suggest = "to_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsPathFilterAtDestinationSourcePortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsPathFilterAtDestinationSourcePortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsPathFilterAtDestinationSourcePortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_port: Optional[_builtins.int] = None,
                 to_port: Optional[_builtins.int] = None):
        """
        :param _builtins.int from_port: The first port in the range.
        :param _builtins.int to_port: The last port in the range.
        """
        if from_port is not None:
            pulumi.set(__self__, "from_port", from_port)
        if to_port is not None:
            pulumi.set(__self__, "to_port", to_port)

    @_builtins.property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> Optional[_builtins.int]:
        """
        The first port in the range.
        """
        return pulumi.get(self, "from_port")

    @_builtins.property
    @pulumi.getter(name="toPort")
    def to_port(self) -> Optional[_builtins.int]:
        """
        The last port in the range.
        """
        return pulumi.get(self, "to_port")


@pulumi.output_type
class NetworkInsightsPathFilterAtSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationAddress":
            suggest = "destination_address"
        elif key == "destinationPortRange":
            suggest = "destination_port_range"
        elif key == "sourceAddress":
            suggest = "source_address"
        elif key == "sourcePortRange":
            suggest = "source_port_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsPathFilterAtSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsPathFilterAtSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsPathFilterAtSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_address: Optional[_builtins.str] = None,
                 destination_port_range: Optional['outputs.NetworkInsightsPathFilterAtSourceDestinationPortRange'] = None,
                 source_address: Optional[_builtins.str] = None,
                 source_port_range: Optional['outputs.NetworkInsightsPathFilterAtSourceSourcePortRange'] = None):
        """
        :param _builtins.str destination_address: The destination IPv4 address.
        :param 'NetworkInsightsPathFilterAtSourceDestinationPortRangeArgs' destination_port_range: The destination port range. See below for details.
        :param _builtins.str source_address: IP address of the source resource.
        :param 'NetworkInsightsPathFilterAtSourceSourcePortRangeArgs' source_port_range: The source port range. See below for details.
        """
        if destination_address is not None:
            pulumi.set(__self__, "destination_address", destination_address)
        if destination_port_range is not None:
            pulumi.set(__self__, "destination_port_range", destination_port_range)
        if source_address is not None:
            pulumi.set(__self__, "source_address", source_address)
        if source_port_range is not None:
            pulumi.set(__self__, "source_port_range", source_port_range)

    @_builtins.property
    @pulumi.getter(name="destinationAddress")
    def destination_address(self) -> Optional[_builtins.str]:
        """
        The destination IPv4 address.
        """
        return pulumi.get(self, "destination_address")

    @_builtins.property
    @pulumi.getter(name="destinationPortRange")
    def destination_port_range(self) -> Optional['outputs.NetworkInsightsPathFilterAtSourceDestinationPortRange']:
        """
        The destination port range. See below for details.
        """
        return pulumi.get(self, "destination_port_range")

    @_builtins.property
    @pulumi.getter(name="sourceAddress")
    def source_address(self) -> Optional[_builtins.str]:
        """
        IP address of the source resource.
        """
        return pulumi.get(self, "source_address")

    @_builtins.property
    @pulumi.getter(name="sourcePortRange")
    def source_port_range(self) -> Optional['outputs.NetworkInsightsPathFilterAtSourceSourcePortRange']:
        """
        The source port range. See below for details.
        """
        return pulumi.get(self, "source_port_range")


@pulumi.output_type
class NetworkInsightsPathFilterAtSourceDestinationPortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromPort":
            suggest = "from_port"
        elif key == "toPort":
            suggest = "to_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsPathFilterAtSourceDestinationPortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsPathFilterAtSourceDestinationPortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsPathFilterAtSourceDestinationPortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_port: Optional[_builtins.int] = None,
                 to_port: Optional[_builtins.int] = None):
        """
        :param _builtins.int from_port: The first port in the range.
        :param _builtins.int to_port: The last port in the range.
        """
        if from_port is not None:
            pulumi.set(__self__, "from_port", from_port)
        if to_port is not None:
            pulumi.set(__self__, "to_port", to_port)

    @_builtins.property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> Optional[_builtins.int]:
        """
        The first port in the range.
        """
        return pulumi.get(self, "from_port")

    @_builtins.property
    @pulumi.getter(name="toPort")
    def to_port(self) -> Optional[_builtins.int]:
        """
        The last port in the range.
        """
        return pulumi.get(self, "to_port")


@pulumi.output_type
class NetworkInsightsPathFilterAtSourceSourcePortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromPort":
            suggest = "from_port"
        elif key == "toPort":
            suggest = "to_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsPathFilterAtSourceSourcePortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsPathFilterAtSourceSourcePortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsPathFilterAtSourceSourcePortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_port: Optional[_builtins.int] = None,
                 to_port: Optional[_builtins.int] = None):
        """
        :param _builtins.int from_port: The first port in the range.
        :param _builtins.int to_port: The last port in the range.
        """
        if from_port is not None:
            pulumi.set(__self__, "from_port", from_port)
        if to_port is not None:
            pulumi.set(__self__, "to_port", to_port)

    @_builtins.property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> Optional[_builtins.int]:
        """
        The first port in the range.
        """
        return pulumi.get(self, "from_port")

    @_builtins.property
    @pulumi.getter(name="toPort")
    def to_port(self) -> Optional[_builtins.int]:
        """
        The last port in the range.
        """
        return pulumi.get(self, "to_port")


@pulumi.output_type
class NetworkInterfaceAttachment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceIndex":
            suggest = "device_index"
        elif key == "attachmentId":
            suggest = "attachment_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInterfaceAttachment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInterfaceAttachment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInterfaceAttachment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_index: _builtins.int,
                 instance: _builtins.str,
                 attachment_id: Optional[_builtins.str] = None):
        """
        :param _builtins.int device_index: Integer to define the devices index.
        :param _builtins.str instance: ID of the instance to attach to.
        """
        pulumi.set(__self__, "device_index", device_index)
        pulumi.set(__self__, "instance", instance)
        if attachment_id is not None:
            pulumi.set(__self__, "attachment_id", attachment_id)

    @_builtins.property
    @pulumi.getter(name="deviceIndex")
    def device_index(self) -> _builtins.int:
        """
        Integer to define the devices index.
        """
        return pulumi.get(self, "device_index")

    @_builtins.property
    @pulumi.getter
    def instance(self) -> _builtins.str:
        """
        ID of the instance to attach to.
        """
        return pulumi.get(self, "instance")

    @_builtins.property
    @pulumi.getter(name="attachmentId")
    def attachment_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "attachment_id")


@pulumi.output_type
class NetworkInterfacePermissionTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[_builtins.str] = None,
                 delete: Optional[_builtins.str] = None):
        """
        :param _builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param _builtins.str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")


@pulumi.output_type
class PeeringConnectionOptionsAccepter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowRemoteVpcDnsResolution":
            suggest = "allow_remote_vpc_dns_resolution"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PeeringConnectionOptionsAccepter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PeeringConnectionOptionsAccepter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PeeringConnectionOptionsAccepter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_remote_vpc_dns_resolution: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool allow_remote_vpc_dns_resolution: Allow a local VPC to resolve public DNS hostnames to private IP addresses when queried from instances in the peer VPC.
        """
        if allow_remote_vpc_dns_resolution is not None:
            pulumi.set(__self__, "allow_remote_vpc_dns_resolution", allow_remote_vpc_dns_resolution)

    @_builtins.property
    @pulumi.getter(name="allowRemoteVpcDnsResolution")
    def allow_remote_vpc_dns_resolution(self) -> Optional[_builtins.bool]:
        """
        Allow a local VPC to resolve public DNS hostnames to private IP addresses when queried from instances in the peer VPC.
        """
        return pulumi.get(self, "allow_remote_vpc_dns_resolution")


@pulumi.output_type
class PeeringConnectionOptionsRequester(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowRemoteVpcDnsResolution":
            suggest = "allow_remote_vpc_dns_resolution"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PeeringConnectionOptionsRequester. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PeeringConnectionOptionsRequester.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PeeringConnectionOptionsRequester.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_remote_vpc_dns_resolution: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool allow_remote_vpc_dns_resolution: Allow a local VPC to resolve public DNS hostnames to private IP addresses when queried from instances in the peer VPC.
        """
        if allow_remote_vpc_dns_resolution is not None:
            pulumi.set(__self__, "allow_remote_vpc_dns_resolution", allow_remote_vpc_dns_resolution)

    @_builtins.property
    @pulumi.getter(name="allowRemoteVpcDnsResolution")
    def allow_remote_vpc_dns_resolution(self) -> Optional[_builtins.bool]:
        """
        Allow a local VPC to resolve public DNS hostnames to private IP addresses when queried from instances in the peer VPC.
        """
        return pulumi.get(self, "allow_remote_vpc_dns_resolution")


@pulumi.output_type
class RouteTableRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "carrierGatewayId":
            suggest = "carrier_gateway_id"
        elif key == "cidrBlock":
            suggest = "cidr_block"
        elif key == "coreNetworkArn":
            suggest = "core_network_arn"
        elif key == "destinationPrefixListId":
            suggest = "destination_prefix_list_id"
        elif key == "egressOnlyGatewayId":
            suggest = "egress_only_gateway_id"
        elif key == "gatewayId":
            suggest = "gateway_id"
        elif key == "ipv6CidrBlock":
            suggest = "ipv6_cidr_block"
        elif key == "localGatewayId":
            suggest = "local_gateway_id"
        elif key == "natGatewayId":
            suggest = "nat_gateway_id"
        elif key == "networkInterfaceId":
            suggest = "network_interface_id"
        elif key == "transitGatewayId":
            suggest = "transit_gateway_id"
        elif key == "vpcEndpointId":
            suggest = "vpc_endpoint_id"
        elif key == "vpcPeeringConnectionId":
            suggest = "vpc_peering_connection_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RouteTableRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RouteTableRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RouteTableRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 carrier_gateway_id: Optional[_builtins.str] = None,
                 cidr_block: Optional[_builtins.str] = None,
                 core_network_arn: Optional[_builtins.str] = None,
                 destination_prefix_list_id: Optional[_builtins.str] = None,
                 egress_only_gateway_id: Optional[_builtins.str] = None,
                 gateway_id: Optional[_builtins.str] = None,
                 ipv6_cidr_block: Optional[_builtins.str] = None,
                 local_gateway_id: Optional[_builtins.str] = None,
                 nat_gateway_id: Optional[_builtins.str] = None,
                 network_interface_id: Optional[_builtins.str] = None,
                 transit_gateway_id: Optional[_builtins.str] = None,
                 vpc_endpoint_id: Optional[_builtins.str] = None,
                 vpc_peering_connection_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str carrier_gateway_id: Identifier of a carrier gateway. This attribute can only be used when the VPC contains a subnet which is associated with a Wavelength Zone.
        :param _builtins.str cidr_block: The CIDR block of the route.
        :param _builtins.str core_network_arn: The Amazon Resource Name (ARN) of a core network.
        :param _builtins.str destination_prefix_list_id: The ID of a managed prefix list destination of the route.
               
               One of the following target arguments must be supplied:
        :param _builtins.str egress_only_gateway_id: Identifier of a VPC Egress Only Internet Gateway.
        :param _builtins.str gateway_id: Identifier of a VPC internet gateway, virtual private gateway, or `local`. `local` routes cannot be created but can be adopted or imported. See the example above.
        :param _builtins.str ipv6_cidr_block: The Ipv6 CIDR block of the route.
        :param _builtins.str local_gateway_id: Identifier of a Outpost local gateway.
        :param _builtins.str nat_gateway_id: Identifier of a VPC NAT gateway.
        :param _builtins.str network_interface_id: Identifier of an EC2 network interface.
        :param _builtins.str transit_gateway_id: Identifier of an EC2 Transit Gateway.
        :param _builtins.str vpc_endpoint_id: Identifier of a VPC Endpoint.
        :param _builtins.str vpc_peering_connection_id: Identifier of a VPC peering connection.
               
               Note that the default route, mapping the VPC's CIDR block to "local", is created implicitly and cannot be specified.
        """
        if carrier_gateway_id is not None:
            pulumi.set(__self__, "carrier_gateway_id", carrier_gateway_id)
        if cidr_block is not None:
            pulumi.set(__self__, "cidr_block", cidr_block)
        if core_network_arn is not None:
            pulumi.set(__self__, "core_network_arn", core_network_arn)
        if destination_prefix_list_id is not None:
            pulumi.set(__self__, "destination_prefix_list_id", destination_prefix_list_id)
        if egress_only_gateway_id is not None:
            pulumi.set(__self__, "egress_only_gateway_id", egress_only_gateway_id)
        if gateway_id is not None:
            pulumi.set(__self__, "gateway_id", gateway_id)
        if ipv6_cidr_block is not None:
            pulumi.set(__self__, "ipv6_cidr_block", ipv6_cidr_block)
        if local_gateway_id is not None:
            pulumi.set(__self__, "local_gateway_id", local_gateway_id)
        if nat_gateway_id is not None:
            pulumi.set(__self__, "nat_gateway_id", nat_gateway_id)
        if network_interface_id is not None:
            pulumi.set(__self__, "network_interface_id", network_interface_id)
        if transit_gateway_id is not None:
            pulumi.set(__self__, "transit_gateway_id", transit_gateway_id)
        if vpc_endpoint_id is not None:
            pulumi.set(__self__, "vpc_endpoint_id", vpc_endpoint_id)
        if vpc_peering_connection_id is not None:
            pulumi.set(__self__, "vpc_peering_connection_id", vpc_peering_connection_id)

    @_builtins.property
    @pulumi.getter(name="carrierGatewayId")
    def carrier_gateway_id(self) -> Optional[_builtins.str]:
        """
        Identifier of a carrier gateway. This attribute can only be used when the VPC contains a subnet which is associated with a Wavelength Zone.
        """
        return pulumi.get(self, "carrier_gateway_id")

    @_builtins.property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> Optional[_builtins.str]:
        """
        The CIDR block of the route.
        """
        return pulumi.get(self, "cidr_block")

    @_builtins.property
    @pulumi.getter(name="coreNetworkArn")
    def core_network_arn(self) -> Optional[_builtins.str]:
        """
        The Amazon Resource Name (ARN) of a core network.
        """
        return pulumi.get(self, "core_network_arn")

    @_builtins.property
    @pulumi.getter(name="destinationPrefixListId")
    def destination_prefix_list_id(self) -> Optional[_builtins.str]:
        """
        The ID of a managed prefix list destination of the route.

        One of the following target arguments must be supplied:
        """
        return pulumi.get(self, "destination_prefix_list_id")

    @_builtins.property
    @pulumi.getter(name="egressOnlyGatewayId")
    def egress_only_gateway_id(self) -> Optional[_builtins.str]:
        """
        Identifier of a VPC Egress Only Internet Gateway.
        """
        return pulumi.get(self, "egress_only_gateway_id")

    @_builtins.property
    @pulumi.getter(name="gatewayId")
    def gateway_id(self) -> Optional[_builtins.str]:
        """
        Identifier of a VPC internet gateway, virtual private gateway, or `local`. `local` routes cannot be created but can be adopted or imported. See the example above.
        """
        return pulumi.get(self, "gateway_id")

    @_builtins.property
    @pulumi.getter(name="ipv6CidrBlock")
    def ipv6_cidr_block(self) -> Optional[_builtins.str]:
        """
        The Ipv6 CIDR block of the route.
        """
        return pulumi.get(self, "ipv6_cidr_block")

    @_builtins.property
    @pulumi.getter(name="localGatewayId")
    def local_gateway_id(self) -> Optional[_builtins.str]:
        """
        Identifier of a Outpost local gateway.
        """
        return pulumi.get(self, "local_gateway_id")

    @_builtins.property
    @pulumi.getter(name="natGatewayId")
    def nat_gateway_id(self) -> Optional[_builtins.str]:
        """
        Identifier of a VPC NAT gateway.
        """
        return pulumi.get(self, "nat_gateway_id")

    @_builtins.property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> Optional[_builtins.str]:
        """
        Identifier of an EC2 network interface.
        """
        return pulumi.get(self, "network_interface_id")

    @_builtins.property
    @pulumi.getter(name="transitGatewayId")
    def transit_gateway_id(self) -> Optional[_builtins.str]:
        """
        Identifier of an EC2 Transit Gateway.
        """
        return pulumi.get(self, "transit_gateway_id")

    @_builtins.property
    @pulumi.getter(name="vpcEndpointId")
    def vpc_endpoint_id(self) -> Optional[_builtins.str]:
        """
        Identifier of a VPC Endpoint.
        """
        return pulumi.get(self, "vpc_endpoint_id")

    @_builtins.property
    @pulumi.getter(name="vpcPeeringConnectionId")
    def vpc_peering_connection_id(self) -> Optional[_builtins.str]:
        """
        Identifier of a VPC peering connection.

        Note that the default route, mapping the VPC's CIDR block to "local", is created implicitly and cannot be specified.
        """
        return pulumi.get(self, "vpc_peering_connection_id")


@pulumi.output_type
class SecurityGroupEgress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromPort":
            suggest = "from_port"
        elif key == "toPort":
            suggest = "to_port"
        elif key == "cidrBlocks":
            suggest = "cidr_blocks"
        elif key == "ipv6CidrBlocks":
            suggest = "ipv6_cidr_blocks"
        elif key == "prefixListIds":
            suggest = "prefix_list_ids"
        elif key == "securityGroups":
            suggest = "security_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityGroupEgress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityGroupEgress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityGroupEgress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_port: _builtins.int,
                 protocol: _builtins.str,
                 to_port: _builtins.int,
                 cidr_blocks: Optional[Sequence[_builtins.str]] = None,
                 description: Optional[_builtins.str] = None,
                 ipv6_cidr_blocks: Optional[Sequence[_builtins.str]] = None,
                 prefix_list_ids: Optional[Sequence[_builtins.str]] = None,
                 security_groups: Optional[Sequence[_builtins.str]] = None,
                 self: Optional[_builtins.bool] = None):
        """
        :param _builtins.int from_port: Start port (or ICMP type number if protocol is `icmp`)
        :param _builtins.str protocol: Protocol. If you select a protocol of `-1` (semantically equivalent to `all`, which is not a valid value here), you must specify a `from_port` and `to_port` equal to 0. The supported values are defined in the `IpProtocol` argument in the [IpPermission](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_IpPermission.html) API reference.
        :param _builtins.int to_port: End range port (or ICMP code if protocol is `icmp`).
               
               The following arguments are optional:
               
               > **Note** Although `cidr_blocks`, `ipv6_cidr_blocks`, `prefix_list_ids`, and `security_groups` are all marked as optional, you _must_ provide one of them in order to configure the destination of the traffic.
        :param Sequence[_builtins.str] cidr_blocks: List of CIDR blocks.
        :param _builtins.str description: Description of this egress rule.
        :param Sequence[_builtins.str] ipv6_cidr_blocks: List of IPv6 CIDR blocks.
        :param Sequence[_builtins.str] prefix_list_ids: List of Prefix List IDs.
        :param Sequence[_builtins.str] security_groups: List of security groups. A group name can be used relative to the default VPC. Otherwise, group ID.
        :param _builtins.bool self: Whether the security group itself will be added as a source to this egress rule.
        """
        pulumi.set(__self__, "from_port", from_port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "to_port", to_port)
        if cidr_blocks is not None:
            pulumi.set(__self__, "cidr_blocks", cidr_blocks)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if ipv6_cidr_blocks is not None:
            pulumi.set(__self__, "ipv6_cidr_blocks", ipv6_cidr_blocks)
        if prefix_list_ids is not None:
            pulumi.set(__self__, "prefix_list_ids", prefix_list_ids)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if self is not None:
            pulumi.set(__self__, "self", self)

    @_builtins.property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> _builtins.int:
        """
        Start port (or ICMP type number if protocol is `icmp`)
        """
        return pulumi.get(self, "from_port")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        """
        Protocol. If you select a protocol of `-1` (semantically equivalent to `all`, which is not a valid value here), you must specify a `from_port` and `to_port` equal to 0. The supported values are defined in the `IpProtocol` argument in the [IpPermission](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_IpPermission.html) API reference.
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="toPort")
    def to_port(self) -> _builtins.int:
        """
        End range port (or ICMP code if protocol is `icmp`).

        The following arguments are optional:

        > **Note** Although `cidr_blocks`, `ipv6_cidr_blocks`, `prefix_list_ids`, and `security_groups` are all marked as optional, you _must_ provide one of them in order to configure the destination of the traffic.
        """
        return pulumi.get(self, "to_port")

    @_builtins.property
    @pulumi.getter(name="cidrBlocks")
    def cidr_blocks(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of CIDR blocks.
        """
        return pulumi.get(self, "cidr_blocks")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of this egress rule.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="ipv6CidrBlocks")
    def ipv6_cidr_blocks(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of IPv6 CIDR blocks.
        """
        return pulumi.get(self, "ipv6_cidr_blocks")

    @_builtins.property
    @pulumi.getter(name="prefixListIds")
    def prefix_list_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of Prefix List IDs.
        """
        return pulumi.get(self, "prefix_list_ids")

    @_builtins.property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of security groups. A group name can be used relative to the default VPC. Otherwise, group ID.
        """
        return pulumi.get(self, "security_groups")

    @_builtins.property
    @pulumi.getter
    def self(self) -> Optional[_builtins.bool]:
        """
        Whether the security group itself will be added as a source to this egress rule.
        """
        return pulumi.get(self, "self")


@pulumi.output_type
class SecurityGroupIngress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromPort":
            suggest = "from_port"
        elif key == "toPort":
            suggest = "to_port"
        elif key == "cidrBlocks":
            suggest = "cidr_blocks"
        elif key == "ipv6CidrBlocks":
            suggest = "ipv6_cidr_blocks"
        elif key == "prefixListIds":
            suggest = "prefix_list_ids"
        elif key == "securityGroups":
            suggest = "security_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityGroupIngress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityGroupIngress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityGroupIngress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_port: _builtins.int,
                 protocol: _builtins.str,
                 to_port: _builtins.int,
                 cidr_blocks: Optional[Sequence[_builtins.str]] = None,
                 description: Optional[_builtins.str] = None,
                 ipv6_cidr_blocks: Optional[Sequence[_builtins.str]] = None,
                 prefix_list_ids: Optional[Sequence[_builtins.str]] = None,
                 security_groups: Optional[Sequence[_builtins.str]] = None,
                 self: Optional[_builtins.bool] = None):
        """
        :param _builtins.int from_port: Start port (or ICMP type number if protocol is `icmp` or `icmpv6`).
        :param _builtins.str protocol: Protocol. If you select a protocol of `-1` (semantically equivalent to `all`, which is not a valid value here), you must specify a `from_port` and `to_port` equal to 0. The supported values are defined in the `IpProtocol` argument on the [IpPermission](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_IpPermission.html) API reference.
               
               The following arguments are optional:
               
               > **Note** Although `cidr_blocks`, `ipv6_cidr_blocks`, `prefix_list_ids`, and `security_groups` are all marked as optional, you _must_ provide one of them in order to configure the source of the traffic.
        :param _builtins.int to_port: End range port (or ICMP code if protocol is `icmp`).
        :param Sequence[_builtins.str] cidr_blocks: List of CIDR blocks.
        :param _builtins.str description: Description of this ingress rule.
        :param Sequence[_builtins.str] ipv6_cidr_blocks: List of IPv6 CIDR blocks.
        :param Sequence[_builtins.str] prefix_list_ids: List of Prefix List IDs.
        :param Sequence[_builtins.str] security_groups: List of security groups. A group name can be used relative to the default VPC. Otherwise, group ID.
        :param _builtins.bool self: Whether the security group itself will be added as a source to this ingress rule.
        """
        pulumi.set(__self__, "from_port", from_port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "to_port", to_port)
        if cidr_blocks is not None:
            pulumi.set(__self__, "cidr_blocks", cidr_blocks)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if ipv6_cidr_blocks is not None:
            pulumi.set(__self__, "ipv6_cidr_blocks", ipv6_cidr_blocks)
        if prefix_list_ids is not None:
            pulumi.set(__self__, "prefix_list_ids", prefix_list_ids)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if self is not None:
            pulumi.set(__self__, "self", self)

    @_builtins.property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> _builtins.int:
        """
        Start port (or ICMP type number if protocol is `icmp` or `icmpv6`).
        """
        return pulumi.get(self, "from_port")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        """
        Protocol. If you select a protocol of `-1` (semantically equivalent to `all`, which is not a valid value here), you must specify a `from_port` and `to_port` equal to 0. The supported values are defined in the `IpProtocol` argument on the [IpPermission](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_IpPermission.html) API reference.

        The following arguments are optional:

        > **Note** Although `cidr_blocks`, `ipv6_cidr_blocks`, `prefix_list_ids`, and `security_groups` are all marked as optional, you _must_ provide one of them in order to configure the source of the traffic.
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="toPort")
    def to_port(self) -> _builtins.int:
        """
        End range port (or ICMP code if protocol is `icmp`).
        """
        return pulumi.get(self, "to_port")

    @_builtins.property
    @pulumi.getter(name="cidrBlocks")
    def cidr_blocks(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of CIDR blocks.
        """
        return pulumi.get(self, "cidr_blocks")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of this ingress rule.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="ipv6CidrBlocks")
    def ipv6_cidr_blocks(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of IPv6 CIDR blocks.
        """
        return pulumi.get(self, "ipv6_cidr_blocks")

    @_builtins.property
    @pulumi.getter(name="prefixListIds")
    def prefix_list_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of Prefix List IDs.
        """
        return pulumi.get(self, "prefix_list_ids")

    @_builtins.property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of security groups. A group name can be used relative to the default VPC. Otherwise, group ID.
        """
        return pulumi.get(self, "security_groups")

    @_builtins.property
    @pulumi.getter
    def self(self) -> Optional[_builtins.bool]:
        """
        Whether the security group itself will be added as a source to this ingress rule.
        """
        return pulumi.get(self, "self")


@pulumi.output_type
class SpotFleetRequestLaunchSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceType":
            suggest = "instance_type"
        elif key == "associatePublicIpAddress":
            suggest = "associate_public_ip_address"
        elif key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "ebsBlockDevices":
            suggest = "ebs_block_devices"
        elif key == "ebsOptimized":
            suggest = "ebs_optimized"
        elif key == "ephemeralBlockDevices":
            suggest = "ephemeral_block_devices"
        elif key == "iamInstanceProfile":
            suggest = "iam_instance_profile"
        elif key == "iamInstanceProfileArn":
            suggest = "iam_instance_profile_arn"
        elif key == "keyName":
            suggest = "key_name"
        elif key == "placementGroup":
            suggest = "placement_group"
        elif key == "placementTenancy":
            suggest = "placement_tenancy"
        elif key == "rootBlockDevices":
            suggest = "root_block_devices"
        elif key == "spotPrice":
            suggest = "spot_price"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "userData":
            suggest = "user_data"
        elif key == "vpcSecurityGroupIds":
            suggest = "vpc_security_group_ids"
        elif key == "weightedCapacity":
            suggest = "weighted_capacity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetRequestLaunchSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetRequestLaunchSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetRequestLaunchSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ami: _builtins.str,
                 instance_type: _builtins.str,
                 associate_public_ip_address: Optional[_builtins.bool] = None,
                 availability_zone: Optional[_builtins.str] = None,
                 ebs_block_devices: Optional[Sequence['outputs.SpotFleetRequestLaunchSpecificationEbsBlockDevice']] = None,
                 ebs_optimized: Optional[_builtins.bool] = None,
                 ephemeral_block_devices: Optional[Sequence['outputs.SpotFleetRequestLaunchSpecificationEphemeralBlockDevice']] = None,
                 iam_instance_profile: Optional[_builtins.str] = None,
                 iam_instance_profile_arn: Optional[_builtins.str] = None,
                 key_name: Optional[_builtins.str] = None,
                 monitoring: Optional[_builtins.bool] = None,
                 placement_group: Optional[_builtins.str] = None,
                 placement_tenancy: Optional[_builtins.str] = None,
                 root_block_devices: Optional[Sequence['outputs.SpotFleetRequestLaunchSpecificationRootBlockDevice']] = None,
                 spot_price: Optional[_builtins.str] = None,
                 subnet_id: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 user_data: Optional[_builtins.str] = None,
                 vpc_security_group_ids: Optional[Sequence[_builtins.str]] = None,
                 weighted_capacity: Optional[_builtins.str] = None):
        """
        :param _builtins.str instance_type: The type of instance to request.
        :param _builtins.str availability_zone: The availability zone in which to place the request.
        :param _builtins.str spot_price: The maximum bid price per unit hour.
        :param _builtins.str subnet_id: The subnet in which to launch the requested instance.
        :param Mapping[str, _builtins.str] tags: A map of tags to assign to the resource. .If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        :param _builtins.str weighted_capacity: The capacity added to the fleet by a fulfilled request.
        """
        pulumi.set(__self__, "ami", ami)
        pulumi.set(__self__, "instance_type", instance_type)
        if associate_public_ip_address is not None:
            pulumi.set(__self__, "associate_public_ip_address", associate_public_ip_address)
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if ebs_block_devices is not None:
            pulumi.set(__self__, "ebs_block_devices", ebs_block_devices)
        if ebs_optimized is not None:
            pulumi.set(__self__, "ebs_optimized", ebs_optimized)
        if ephemeral_block_devices is not None:
            pulumi.set(__self__, "ephemeral_block_devices", ephemeral_block_devices)
        if iam_instance_profile is not None:
            pulumi.set(__self__, "iam_instance_profile", iam_instance_profile)
        if iam_instance_profile_arn is not None:
            pulumi.set(__self__, "iam_instance_profile_arn", iam_instance_profile_arn)
        if key_name is not None:
            pulumi.set(__self__, "key_name", key_name)
        if monitoring is not None:
            pulumi.set(__self__, "monitoring", monitoring)
        if placement_group is not None:
            pulumi.set(__self__, "placement_group", placement_group)
        if placement_tenancy is not None:
            pulumi.set(__self__, "placement_tenancy", placement_tenancy)
        if root_block_devices is not None:
            pulumi.set(__self__, "root_block_devices", root_block_devices)
        if spot_price is not None:
            pulumi.set(__self__, "spot_price", spot_price)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if user_data is not None:
            pulumi.set(__self__, "user_data", user_data)
        if vpc_security_group_ids is not None:
            pulumi.set(__self__, "vpc_security_group_ids", vpc_security_group_ids)
        if weighted_capacity is not None:
            pulumi.set(__self__, "weighted_capacity", weighted_capacity)

    @_builtins.property
    @pulumi.getter
    def ami(self) -> _builtins.str:
        return pulumi.get(self, "ami")

    @_builtins.property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> _builtins.str:
        """
        The type of instance to request.
        """
        return pulumi.get(self, "instance_type")

    @_builtins.property
    @pulumi.getter(name="associatePublicIpAddress")
    def associate_public_ip_address(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "associate_public_ip_address")

    @_builtins.property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[_builtins.str]:
        """
        The availability zone in which to place the request.
        """
        return pulumi.get(self, "availability_zone")

    @_builtins.property
    @pulumi.getter(name="ebsBlockDevices")
    def ebs_block_devices(self) -> Optional[Sequence['outputs.SpotFleetRequestLaunchSpecificationEbsBlockDevice']]:
        return pulumi.get(self, "ebs_block_devices")

    @_builtins.property
    @pulumi.getter(name="ebsOptimized")
    def ebs_optimized(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "ebs_optimized")

    @_builtins.property
    @pulumi.getter(name="ephemeralBlockDevices")
    def ephemeral_block_devices(self) -> Optional[Sequence['outputs.SpotFleetRequestLaunchSpecificationEphemeralBlockDevice']]:
        return pulumi.get(self, "ephemeral_block_devices")

    @_builtins.property
    @pulumi.getter(name="iamInstanceProfile")
    def iam_instance_profile(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "iam_instance_profile")

    @_builtins.property
    @pulumi.getter(name="iamInstanceProfileArn")
    def iam_instance_profile_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "iam_instance_profile_arn")

    @_builtins.property
    @pulumi.getter(name="keyName")
    def key_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "key_name")

    @_builtins.property
    @pulumi.getter
    def monitoring(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "monitoring")

    @_builtins.property
    @pulumi.getter(name="placementGroup")
    def placement_group(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "placement_group")

    @_builtins.property
    @pulumi.getter(name="placementTenancy")
    def placement_tenancy(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "placement_tenancy")

    @_builtins.property
    @pulumi.getter(name="rootBlockDevices")
    def root_block_devices(self) -> Optional[Sequence['outputs.SpotFleetRequestLaunchSpecificationRootBlockDevice']]:
        return pulumi.get(self, "root_block_devices")

    @_builtins.property
    @pulumi.getter(name="spotPrice")
    def spot_price(self) -> Optional[_builtins.str]:
        """
        The maximum bid price per unit hour.
        """
        return pulumi.get(self, "spot_price")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[_builtins.str]:
        """
        The subnet in which to launch the requested instance.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        A map of tags to assign to the resource. .If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="userData")
    def user_data(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "user_data")

    @_builtins.property
    @pulumi.getter(name="vpcSecurityGroupIds")
    def vpc_security_group_ids(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "vpc_security_group_ids")

    @_builtins.property
    @pulumi.getter(name="weightedCapacity")
    def weighted_capacity(self) -> Optional[_builtins.str]:
        """
        The capacity added to the fleet by a fulfilled request.
        """
        return pulumi.get(self, "weighted_capacity")


@pulumi.output_type
class SpotFleetRequestLaunchSpecificationEbsBlockDevice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "snapshotId":
            suggest = "snapshot_id"
        elif key == "volumeSize":
            suggest = "volume_size"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetRequestLaunchSpecificationEbsBlockDevice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetRequestLaunchSpecificationEbsBlockDevice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetRequestLaunchSpecificationEbsBlockDevice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_name: _builtins.str,
                 delete_on_termination: Optional[_builtins.bool] = None,
                 encrypted: Optional[_builtins.bool] = None,
                 iops: Optional[_builtins.int] = None,
                 kms_key_id: Optional[_builtins.str] = None,
                 snapshot_id: Optional[_builtins.str] = None,
                 throughput: Optional[_builtins.int] = None,
                 volume_size: Optional[_builtins.int] = None,
                 volume_type: Optional[_builtins.str] = None):
        pulumi.set(__self__, "device_name", device_name)
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> _builtins.str:
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "delete_on_termination")

    @_builtins.property
    @pulumi.getter
    def encrypted(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "encrypted")

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "iops")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "snapshot_id")

    @_builtins.property
    @pulumi.getter
    def throughput(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "throughput")

    @_builtins.property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "volume_size")

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class SpotFleetRequestLaunchSpecificationEphemeralBlockDevice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "virtualName":
            suggest = "virtual_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetRequestLaunchSpecificationEphemeralBlockDevice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetRequestLaunchSpecificationEphemeralBlockDevice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetRequestLaunchSpecificationEphemeralBlockDevice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_name: _builtins.str,
                 virtual_name: _builtins.str):
        pulumi.set(__self__, "device_name", device_name)
        pulumi.set(__self__, "virtual_name", virtual_name)

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> _builtins.str:
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> _builtins.str:
        return pulumi.get(self, "virtual_name")


@pulumi.output_type
class SpotFleetRequestLaunchSpecificationRootBlockDevice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "volumeSize":
            suggest = "volume_size"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetRequestLaunchSpecificationRootBlockDevice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetRequestLaunchSpecificationRootBlockDevice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetRequestLaunchSpecificationRootBlockDevice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delete_on_termination: Optional[_builtins.bool] = None,
                 encrypted: Optional[_builtins.bool] = None,
                 iops: Optional[_builtins.int] = None,
                 kms_key_id: Optional[_builtins.str] = None,
                 throughput: Optional[_builtins.int] = None,
                 volume_size: Optional[_builtins.int] = None,
                 volume_type: Optional[_builtins.str] = None):
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "delete_on_termination")

    @_builtins.property
    @pulumi.getter
    def encrypted(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "encrypted")

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "iops")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter
    def throughput(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "throughput")

    @_builtins.property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "volume_size")

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class SpotFleetRequestLaunchTemplateConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "launchTemplateSpecification":
            suggest = "launch_template_specification"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetRequestLaunchTemplateConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetRequestLaunchTemplateConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetRequestLaunchTemplateConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 launch_template_specification: 'outputs.SpotFleetRequestLaunchTemplateConfigLaunchTemplateSpecification',
                 overrides: Optional[Sequence['outputs.SpotFleetRequestLaunchTemplateConfigOverride']] = None):
        """
        :param 'SpotFleetRequestLaunchTemplateConfigLaunchTemplateSpecificationArgs' launch_template_specification: Launch template specification. See Launch Template Specification below for more details.
        :param Sequence['SpotFleetRequestLaunchTemplateConfigOverrideArgs'] overrides: One or more override configurations. See Overrides below for more details.
        """
        pulumi.set(__self__, "launch_template_specification", launch_template_specification)
        if overrides is not None:
            pulumi.set(__self__, "overrides", overrides)

    @_builtins.property
    @pulumi.getter(name="launchTemplateSpecification")
    def launch_template_specification(self) -> 'outputs.SpotFleetRequestLaunchTemplateConfigLaunchTemplateSpecification':
        """
        Launch template specification. See Launch Template Specification below for more details.
        """
        return pulumi.get(self, "launch_template_specification")

    @_builtins.property
    @pulumi.getter
    def overrides(self) -> Optional[Sequence['outputs.SpotFleetRequestLaunchTemplateConfigOverride']]:
        """
        One or more override configurations. See Overrides below for more details.
        """
        return pulumi.get(self, "overrides")


@pulumi.output_type
class SpotFleetRequestLaunchTemplateConfigLaunchTemplateSpecification(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 version: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: The ID of the launch template. Conflicts with `name`.
        :param _builtins.str name: The name of the launch template. Conflicts with `id`.
        :param _builtins.str version: Template version. Unlike the autoscaling equivalent, does not support `$Latest` or `$Default`, so use the launch_template resource's attribute, e.g., `"${aws_launch_template.foo.latest_version}"`. It will use the default version if omitted.
               
               **Note:** The specified launch template can specify only a subset of the
               inputs of `ec2.LaunchTemplate`.  There are limitations on
               what you can specify as spot fleet does not support all the attributes that are supported by autoscaling groups. [AWS documentation](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-templates.html#launch-templates-spot-fleet) is currently sparse, but at least `instance_initiated_shutdown_behavior` is confirmed unsupported.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The ID of the launch template. Conflicts with `name`.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the launch template. Conflicts with `id`.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.str]:
        """
        Template version. Unlike the autoscaling equivalent, does not support `$Latest` or `$Default`, so use the launch_template resource's attribute, e.g., `"${aws_launch_template.foo.latest_version}"`. It will use the default version if omitted.

        **Note:** The specified launch template can specify only a subset of the
        inputs of `ec2.LaunchTemplate`.  There are limitations on
        what you can specify as spot fleet does not support all the attributes that are supported by autoscaling groups. [AWS documentation](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-templates.html#launch-templates-spot-fleet) is currently sparse, but at least `instance_initiated_shutdown_behavior` is confirmed unsupported.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class SpotFleetRequestLaunchTemplateConfigOverride(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "instanceRequirements":
            suggest = "instance_requirements"
        elif key == "instanceType":
            suggest = "instance_type"
        elif key == "spotPrice":
            suggest = "spot_price"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "weightedCapacity":
            suggest = "weighted_capacity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetRequestLaunchTemplateConfigOverride. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetRequestLaunchTemplateConfigOverride.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetRequestLaunchTemplateConfigOverride.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_zone: Optional[_builtins.str] = None,
                 instance_requirements: Optional['outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirements'] = None,
                 instance_type: Optional[_builtins.str] = None,
                 priority: Optional[_builtins.float] = None,
                 spot_price: Optional[_builtins.str] = None,
                 subnet_id: Optional[_builtins.str] = None,
                 weighted_capacity: Optional[_builtins.float] = None):
        """
        :param _builtins.str availability_zone: The availability zone in which to place the request.
        :param 'SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsArgs' instance_requirements: The instance requirements. See below.
        :param _builtins.str instance_type: The type of instance to request.
        :param _builtins.float priority: The priority for the launch template override. The lower the number, the higher the priority. If no number is set, the launch template override has the lowest priority.
        :param _builtins.str spot_price: The maximum spot bid for this override request.
        :param _builtins.str subnet_id: The subnet in which to launch the requested instance.
        :param _builtins.float weighted_capacity: The capacity added to the fleet by a fulfilled request.
        """
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if instance_requirements is not None:
            pulumi.set(__self__, "instance_requirements", instance_requirements)
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if spot_price is not None:
            pulumi.set(__self__, "spot_price", spot_price)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if weighted_capacity is not None:
            pulumi.set(__self__, "weighted_capacity", weighted_capacity)

    @_builtins.property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[_builtins.str]:
        """
        The availability zone in which to place the request.
        """
        return pulumi.get(self, "availability_zone")

    @_builtins.property
    @pulumi.getter(name="instanceRequirements")
    def instance_requirements(self) -> Optional['outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirements']:
        """
        The instance requirements. See below.
        """
        return pulumi.get(self, "instance_requirements")

    @_builtins.property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[_builtins.str]:
        """
        The type of instance to request.
        """
        return pulumi.get(self, "instance_type")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[_builtins.float]:
        """
        The priority for the launch template override. The lower the number, the higher the priority. If no number is set, the launch template override has the lowest priority.
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter(name="spotPrice")
    def spot_price(self) -> Optional[_builtins.str]:
        """
        The maximum spot bid for this override request.
        """
        return pulumi.get(self, "spot_price")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[_builtins.str]:
        """
        The subnet in which to launch the requested instance.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter(name="weightedCapacity")
    def weighted_capacity(self) -> Optional[_builtins.float]:
        """
        The capacity added to the fleet by a fulfilled request.
        """
        return pulumi.get(self, "weighted_capacity")


@pulumi.output_type
class SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirements(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acceleratorCount":
            suggest = "accelerator_count"
        elif key == "acceleratorManufacturers":
            suggest = "accelerator_manufacturers"
        elif key == "acceleratorNames":
            suggest = "accelerator_names"
        elif key == "acceleratorTotalMemoryMib":
            suggest = "accelerator_total_memory_mib"
        elif key == "acceleratorTypes":
            suggest = "accelerator_types"
        elif key == "allowedInstanceTypes":
            suggest = "allowed_instance_types"
        elif key == "bareMetal":
            suggest = "bare_metal"
        elif key == "baselineEbsBandwidthMbps":
            suggest = "baseline_ebs_bandwidth_mbps"
        elif key == "burstablePerformance":
            suggest = "burstable_performance"
        elif key == "cpuManufacturers":
            suggest = "cpu_manufacturers"
        elif key == "excludedInstanceTypes":
            suggest = "excluded_instance_types"
        elif key == "instanceGenerations":
            suggest = "instance_generations"
        elif key == "localStorage":
            suggest = "local_storage"
        elif key == "localStorageTypes":
            suggest = "local_storage_types"
        elif key == "memoryGibPerVcpu":
            suggest = "memory_gib_per_vcpu"
        elif key == "memoryMib":
            suggest = "memory_mib"
        elif key == "networkBandwidthGbps":
            suggest = "network_bandwidth_gbps"
        elif key == "networkInterfaceCount":
            suggest = "network_interface_count"
        elif key == "onDemandMaxPricePercentageOverLowestPrice":
            suggest = "on_demand_max_price_percentage_over_lowest_price"
        elif key == "requireHibernateSupport":
            suggest = "require_hibernate_support"
        elif key == "spotMaxPricePercentageOverLowestPrice":
            suggest = "spot_max_price_percentage_over_lowest_price"
        elif key == "totalLocalStorageGb":
            suggest = "total_local_storage_gb"
        elif key == "vcpuCount":
            suggest = "vcpu_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirements. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirements.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirements.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 accelerator_count: Optional['outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorCount'] = None,
                 accelerator_manufacturers: Optional[Sequence[_builtins.str]] = None,
                 accelerator_names: Optional[Sequence[_builtins.str]] = None,
                 accelerator_total_memory_mib: Optional['outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorTotalMemoryMib'] = None,
                 accelerator_types: Optional[Sequence[_builtins.str]] = None,
                 allowed_instance_types: Optional[Sequence[_builtins.str]] = None,
                 bare_metal: Optional[_builtins.str] = None,
                 baseline_ebs_bandwidth_mbps: Optional['outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsBaselineEbsBandwidthMbps'] = None,
                 burstable_performance: Optional[_builtins.str] = None,
                 cpu_manufacturers: Optional[Sequence[_builtins.str]] = None,
                 excluded_instance_types: Optional[Sequence[_builtins.str]] = None,
                 instance_generations: Optional[Sequence[_builtins.str]] = None,
                 local_storage: Optional[_builtins.str] = None,
                 local_storage_types: Optional[Sequence[_builtins.str]] = None,
                 memory_gib_per_vcpu: Optional['outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsMemoryGibPerVcpu'] = None,
                 memory_mib: Optional['outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsMemoryMib'] = None,
                 network_bandwidth_gbps: Optional['outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsNetworkBandwidthGbps'] = None,
                 network_interface_count: Optional['outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsNetworkInterfaceCount'] = None,
                 on_demand_max_price_percentage_over_lowest_price: Optional[_builtins.int] = None,
                 require_hibernate_support: Optional[_builtins.bool] = None,
                 spot_max_price_percentage_over_lowest_price: Optional[_builtins.int] = None,
                 total_local_storage_gb: Optional['outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsTotalLocalStorageGb'] = None,
                 vcpu_count: Optional['outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsVcpuCount'] = None):
        """
        :param 'SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorCountArgs' accelerator_count: Block describing the minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips). Default is no minimum or maximum.
        :param Sequence[_builtins.str] accelerator_manufacturers: List of accelerator manufacturer names. Default is any manufacturer.
               
               ```
               Valid names:
               * amazon-web-services
               * amd
               * nvidia
               * xilinx
               ```
        :param Sequence[_builtins.str] accelerator_names: List of accelerator names. Default is any acclerator.
               
               ```
               Valid names:
               * a100            - NVIDIA A100 GPUs
               * v100            - NVIDIA V100 GPUs
               * k80             - NVIDIA K80 GPUs
               * t4              - NVIDIA T4 GPUs
               * m60             - NVIDIA M60 GPUs
               * radeon-pro-v520 - AMD Radeon Pro V520 GPUs
               * vu9p            - Xilinx VU9P FPGAs
               ```
        :param 'SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorTotalMemoryMibArgs' accelerator_total_memory_mib: Block describing the minimum and maximum total memory of the accelerators. Default is no minimum or maximum.
        :param Sequence[_builtins.str] accelerator_types: List of accelerator types. Default is any accelerator type.
               
               ```
               Valid types:
               * fpga
               * gpu
               * inference
               ```
        :param Sequence[_builtins.str] allowed_instance_types: List of instance types to apply your specified attributes against. All other instance types are ignored, even if they match your specified attributes. You can use strings with one or more wild cards, represented by an asterisk (\\*), to allow an instance type, size, or generation. The following are examples: `m5.8xlarge`, `c5*.*`, `m5a.*`, `r*`, `*3*`. For example, if you specify `c5*`, you are allowing the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*`, you are allowing all the M5a instance types, but not the M5n instance types. Maximum of 400 entries in the list; each entry is limited to 30 characters. Default is all instance types.
               
               > **NOTE:** If you specify `allowed_instance_types`, you can't specify `excluded_instance_types`.
        :param _builtins.str bare_metal: Indicate whether bare metal instace types should be `included`, `excluded`, or `required`. Default is `excluded`.
        :param 'SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsBaselineEbsBandwidthMbpsArgs' baseline_ebs_bandwidth_mbps: Block describing the minimum and maximum baseline EBS bandwidth, in Mbps. Default is no minimum or maximum.
        :param _builtins.str burstable_performance: Indicate whether burstable performance instance types should be `included`, `excluded`, or `required`. Default is `excluded`.
        :param Sequence[_builtins.str] cpu_manufacturers: List of CPU manufacturer names. Default is any manufacturer.
               
               > **NOTE:** Don't confuse the CPU hardware manufacturer with the CPU hardware architecture. Instances will be launched with a compatible CPU architecture based on the Amazon Machine Image (AMI) that you specify in your launch template.
               
               ```
               Valid names:
               * amazon-web-services
               * amd
               * intel
               ```
        :param Sequence[_builtins.str] excluded_instance_types: List of instance types to exclude. You can use strings with one or more wild cards, represented by an asterisk (\\*), to exclude an instance type, size, or generation. The following are examples: `m5.8xlarge`, `c5*.*`, `m5a.*`, `r*`, `*3*`. For example, if you specify `c5*`, you are excluding the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*`, you are excluding all the M5a instance types, but not the M5n instance types. Maximum of 400 entries in the list; each entry is limited to 30 characters. Default is no excluded instance types.
               
               > **NOTE:** If you specify `excluded_instance_types`, you can't specify `allowed_instance_types`.
        :param Sequence[_builtins.str] instance_generations: List of instance generation names. Default is any generation.
               
               ```
               Valid names:
               * current  - Recommended for best performance.
               * previous - For existing applications optimized for older instance types.
               ```
        :param _builtins.str local_storage: Indicate whether instance types with local storage volumes are `included`, `excluded`, or `required`. Default is `included`.
        :param Sequence[_builtins.str] local_storage_types: List of local storage type names. Default any storage type.
               
               ```
               Value names:
               * hdd - hard disk drive
               * ssd - solid state drive
               ```
        :param 'SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsMemoryGibPerVcpuArgs' memory_gib_per_vcpu: Block describing the minimum and maximum amount of memory (GiB) per vCPU. Default is no minimum or maximum.
        :param 'SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsMemoryMibArgs' memory_mib: Block describing the minimum and maximum amount of memory (MiB). Default is no maximum.
        :param 'SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsNetworkBandwidthGbpsArgs' network_bandwidth_gbps: Block describing the minimum and maximum amount of network bandwidth, in gigabits per second (Gbps). Default is no minimum or maximum.
        :param 'SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsNetworkInterfaceCountArgs' network_interface_count: Block describing the minimum and maximum number of network interfaces. Default is no minimum or maximum.
        :param _builtins.int on_demand_max_price_percentage_over_lowest_price: The price protection threshold for On-Demand Instances. This is the maximum you’ll pay for an On-Demand Instance, expressed as a percentage higher than the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price is higher than your threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as 999999. Default is 20.
               
               If you set DesiredCapacityType to vcpu or memory-mib, the price protection threshold is applied based on the per vCPU or per memory price instead of the per instance price.
        :param _builtins.bool require_hibernate_support: Indicate whether instance types must support On-Demand Instance Hibernation, either `true` or `false`. Default is `false`.
        :param _builtins.int spot_max_price_percentage_over_lowest_price: The price protection threshold for Spot Instances. This is the maximum you’ll pay for a Spot Instance, expressed as a percentage higher than the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price is higher than your threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as 999999. Default is 100.
               
               If you set DesiredCapacityType to vcpu or memory-mib, the price protection threshold is applied based on the per vCPU or per memory price instead of the per instance price.
        :param 'SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsTotalLocalStorageGbArgs' total_local_storage_gb: Block describing the minimum and maximum total local storage (GB). Default is no minimum or maximum.
        :param 'SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsVcpuCountArgs' vcpu_count: Block describing the minimum and maximum number of vCPUs. Default is no maximum.
        """
        if accelerator_count is not None:
            pulumi.set(__self__, "accelerator_count", accelerator_count)
        if accelerator_manufacturers is not None:
            pulumi.set(__self__, "accelerator_manufacturers", accelerator_manufacturers)
        if accelerator_names is not None:
            pulumi.set(__self__, "accelerator_names", accelerator_names)
        if accelerator_total_memory_mib is not None:
            pulumi.set(__self__, "accelerator_total_memory_mib", accelerator_total_memory_mib)
        if accelerator_types is not None:
            pulumi.set(__self__, "accelerator_types", accelerator_types)
        if allowed_instance_types is not None:
            pulumi.set(__self__, "allowed_instance_types", allowed_instance_types)
        if bare_metal is not None:
            pulumi.set(__self__, "bare_metal", bare_metal)
        if baseline_ebs_bandwidth_mbps is not None:
            pulumi.set(__self__, "baseline_ebs_bandwidth_mbps", baseline_ebs_bandwidth_mbps)
        if burstable_performance is not None:
            pulumi.set(__self__, "burstable_performance", burstable_performance)
        if cpu_manufacturers is not None:
            pulumi.set(__self__, "cpu_manufacturers", cpu_manufacturers)
        if excluded_instance_types is not None:
            pulumi.set(__self__, "excluded_instance_types", excluded_instance_types)
        if instance_generations is not None:
            pulumi.set(__self__, "instance_generations", instance_generations)
        if local_storage is not None:
            pulumi.set(__self__, "local_storage", local_storage)
        if local_storage_types is not None:
            pulumi.set(__self__, "local_storage_types", local_storage_types)
        if memory_gib_per_vcpu is not None:
            pulumi.set(__self__, "memory_gib_per_vcpu", memory_gib_per_vcpu)
        if memory_mib is not None:
            pulumi.set(__self__, "memory_mib", memory_mib)
        if network_bandwidth_gbps is not None:
            pulumi.set(__self__, "network_bandwidth_gbps", network_bandwidth_gbps)
        if network_interface_count is not None:
            pulumi.set(__self__, "network_interface_count", network_interface_count)
        if on_demand_max_price_percentage_over_lowest_price is not None:
            pulumi.set(__self__, "on_demand_max_price_percentage_over_lowest_price", on_demand_max_price_percentage_over_lowest_price)
        if require_hibernate_support is not None:
            pulumi.set(__self__, "require_hibernate_support", require_hibernate_support)
        if spot_max_price_percentage_over_lowest_price is not None:
            pulumi.set(__self__, "spot_max_price_percentage_over_lowest_price", spot_max_price_percentage_over_lowest_price)
        if total_local_storage_gb is not None:
            pulumi.set(__self__, "total_local_storage_gb", total_local_storage_gb)
        if vcpu_count is not None:
            pulumi.set(__self__, "vcpu_count", vcpu_count)

    @_builtins.property
    @pulumi.getter(name="acceleratorCount")
    def accelerator_count(self) -> Optional['outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorCount']:
        """
        Block describing the minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips). Default is no minimum or maximum.
        """
        return pulumi.get(self, "accelerator_count")

    @_builtins.property
    @pulumi.getter(name="acceleratorManufacturers")
    def accelerator_manufacturers(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of accelerator manufacturer names. Default is any manufacturer.

        ```
        Valid names:
        * amazon-web-services
        * amd
        * nvidia
        * xilinx
        ```
        """
        return pulumi.get(self, "accelerator_manufacturers")

    @_builtins.property
    @pulumi.getter(name="acceleratorNames")
    def accelerator_names(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of accelerator names. Default is any acclerator.

        ```
        Valid names:
        * a100            - NVIDIA A100 GPUs
        * v100            - NVIDIA V100 GPUs
        * k80             - NVIDIA K80 GPUs
        * t4              - NVIDIA T4 GPUs
        * m60             - NVIDIA M60 GPUs
        * radeon-pro-v520 - AMD Radeon Pro V520 GPUs
        * vu9p            - Xilinx VU9P FPGAs
        ```
        """
        return pulumi.get(self, "accelerator_names")

    @_builtins.property
    @pulumi.getter(name="acceleratorTotalMemoryMib")
    def accelerator_total_memory_mib(self) -> Optional['outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorTotalMemoryMib']:
        """
        Block describing the minimum and maximum total memory of the accelerators. Default is no minimum or maximum.
        """
        return pulumi.get(self, "accelerator_total_memory_mib")

    @_builtins.property
    @pulumi.getter(name="acceleratorTypes")
    def accelerator_types(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of accelerator types. Default is any accelerator type.

        ```
        Valid types:
        * fpga
        * gpu
        * inference
        ```
        """
        return pulumi.get(self, "accelerator_types")

    @_builtins.property
    @pulumi.getter(name="allowedInstanceTypes")
    def allowed_instance_types(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of instance types to apply your specified attributes against. All other instance types are ignored, even if they match your specified attributes. You can use strings with one or more wild cards, represented by an asterisk (\\*), to allow an instance type, size, or generation. The following are examples: `m5.8xlarge`, `c5*.*`, `m5a.*`, `r*`, `*3*`. For example, if you specify `c5*`, you are allowing the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*`, you are allowing all the M5a instance types, but not the M5n instance types. Maximum of 400 entries in the list; each entry is limited to 30 characters. Default is all instance types.

        > **NOTE:** If you specify `allowed_instance_types`, you can't specify `excluded_instance_types`.
        """
        return pulumi.get(self, "allowed_instance_types")

    @_builtins.property
    @pulumi.getter(name="bareMetal")
    def bare_metal(self) -> Optional[_builtins.str]:
        """
        Indicate whether bare metal instace types should be `included`, `excluded`, or `required`. Default is `excluded`.
        """
        return pulumi.get(self, "bare_metal")

    @_builtins.property
    @pulumi.getter(name="baselineEbsBandwidthMbps")
    def baseline_ebs_bandwidth_mbps(self) -> Optional['outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsBaselineEbsBandwidthMbps']:
        """
        Block describing the minimum and maximum baseline EBS bandwidth, in Mbps. Default is no minimum or maximum.
        """
        return pulumi.get(self, "baseline_ebs_bandwidth_mbps")

    @_builtins.property
    @pulumi.getter(name="burstablePerformance")
    def burstable_performance(self) -> Optional[_builtins.str]:
        """
        Indicate whether burstable performance instance types should be `included`, `excluded`, or `required`. Default is `excluded`.
        """
        return pulumi.get(self, "burstable_performance")

    @_builtins.property
    @pulumi.getter(name="cpuManufacturers")
    def cpu_manufacturers(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of CPU manufacturer names. Default is any manufacturer.

        > **NOTE:** Don't confuse the CPU hardware manufacturer with the CPU hardware architecture. Instances will be launched with a compatible CPU architecture based on the Amazon Machine Image (AMI) that you specify in your launch template.

        ```
        Valid names:
        * amazon-web-services
        * amd
        * intel
        ```
        """
        return pulumi.get(self, "cpu_manufacturers")

    @_builtins.property
    @pulumi.getter(name="excludedInstanceTypes")
    def excluded_instance_types(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of instance types to exclude. You can use strings with one or more wild cards, represented by an asterisk (\\*), to exclude an instance type, size, or generation. The following are examples: `m5.8xlarge`, `c5*.*`, `m5a.*`, `r*`, `*3*`. For example, if you specify `c5*`, you are excluding the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*`, you are excluding all the M5a instance types, but not the M5n instance types. Maximum of 400 entries in the list; each entry is limited to 30 characters. Default is no excluded instance types.

        > **NOTE:** If you specify `excluded_instance_types`, you can't specify `allowed_instance_types`.
        """
        return pulumi.get(self, "excluded_instance_types")

    @_builtins.property
    @pulumi.getter(name="instanceGenerations")
    def instance_generations(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of instance generation names. Default is any generation.

        ```
        Valid names:
        * current  - Recommended for best performance.
        * previous - For existing applications optimized for older instance types.
        ```
        """
        return pulumi.get(self, "instance_generations")

    @_builtins.property
    @pulumi.getter(name="localStorage")
    def local_storage(self) -> Optional[_builtins.str]:
        """
        Indicate whether instance types with local storage volumes are `included`, `excluded`, or `required`. Default is `included`.
        """
        return pulumi.get(self, "local_storage")

    @_builtins.property
    @pulumi.getter(name="localStorageTypes")
    def local_storage_types(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of local storage type names. Default any storage type.

        ```
        Value names:
        * hdd - hard disk drive
        * ssd - solid state drive
        ```
        """
        return pulumi.get(self, "local_storage_types")

    @_builtins.property
    @pulumi.getter(name="memoryGibPerVcpu")
    def memory_gib_per_vcpu(self) -> Optional['outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsMemoryGibPerVcpu']:
        """
        Block describing the minimum and maximum amount of memory (GiB) per vCPU. Default is no minimum or maximum.
        """
        return pulumi.get(self, "memory_gib_per_vcpu")

    @_builtins.property
    @pulumi.getter(name="memoryMib")
    def memory_mib(self) -> Optional['outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsMemoryMib']:
        """
        Block describing the minimum and maximum amount of memory (MiB). Default is no maximum.
        """
        return pulumi.get(self, "memory_mib")

    @_builtins.property
    @pulumi.getter(name="networkBandwidthGbps")
    def network_bandwidth_gbps(self) -> Optional['outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsNetworkBandwidthGbps']:
        """
        Block describing the minimum and maximum amount of network bandwidth, in gigabits per second (Gbps). Default is no minimum or maximum.
        """
        return pulumi.get(self, "network_bandwidth_gbps")

    @_builtins.property
    @pulumi.getter(name="networkInterfaceCount")
    def network_interface_count(self) -> Optional['outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsNetworkInterfaceCount']:
        """
        Block describing the minimum and maximum number of network interfaces. Default is no minimum or maximum.
        """
        return pulumi.get(self, "network_interface_count")

    @_builtins.property
    @pulumi.getter(name="onDemandMaxPricePercentageOverLowestPrice")
    def on_demand_max_price_percentage_over_lowest_price(self) -> Optional[_builtins.int]:
        """
        The price protection threshold for On-Demand Instances. This is the maximum you’ll pay for an On-Demand Instance, expressed as a percentage higher than the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price is higher than your threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as 999999. Default is 20.

        If you set DesiredCapacityType to vcpu or memory-mib, the price protection threshold is applied based on the per vCPU or per memory price instead of the per instance price.
        """
        return pulumi.get(self, "on_demand_max_price_percentage_over_lowest_price")

    @_builtins.property
    @pulumi.getter(name="requireHibernateSupport")
    def require_hibernate_support(self) -> Optional[_builtins.bool]:
        """
        Indicate whether instance types must support On-Demand Instance Hibernation, either `true` or `false`. Default is `false`.
        """
        return pulumi.get(self, "require_hibernate_support")

    @_builtins.property
    @pulumi.getter(name="spotMaxPricePercentageOverLowestPrice")
    def spot_max_price_percentage_over_lowest_price(self) -> Optional[_builtins.int]:
        """
        The price protection threshold for Spot Instances. This is the maximum you’ll pay for a Spot Instance, expressed as a percentage higher than the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price is higher than your threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as 999999. Default is 100.

        If you set DesiredCapacityType to vcpu or memory-mib, the price protection threshold is applied based on the per vCPU or per memory price instead of the per instance price.
        """
        return pulumi.get(self, "spot_max_price_percentage_over_lowest_price")

    @_builtins.property
    @pulumi.getter(name="totalLocalStorageGb")
    def total_local_storage_gb(self) -> Optional['outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsTotalLocalStorageGb']:
        """
        Block describing the minimum and maximum total local storage (GB). Default is no minimum or maximum.
        """
        return pulumi.get(self, "total_local_storage_gb")

    @_builtins.property
    @pulumi.getter(name="vcpuCount")
    def vcpu_count(self) -> Optional['outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsVcpuCount']:
        """
        Block describing the minimum and maximum number of vCPUs. Default is no maximum.
        """
        return pulumi.get(self, "vcpu_count")


@pulumi.output_type
class SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorCount(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.int] = None,
                 min: Optional[_builtins.int] = None):
        """
        :param _builtins.int max: Maximum. Set to `0` to exclude instance types with accelerators.
        :param _builtins.int min: Minimum.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.int]:
        """
        Maximum. Set to `0` to exclude instance types with accelerators.
        """
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.int]:
        """
        Minimum.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorTotalMemoryMib(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.int] = None,
                 min: Optional[_builtins.int] = None):
        """
        :param _builtins.int max: Maximum.
        :param _builtins.int min: Minimum.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.int]:
        """
        Maximum.
        """
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.int]:
        """
        Minimum.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsBaselineEbsBandwidthMbps(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.int] = None,
                 min: Optional[_builtins.int] = None):
        """
        :param _builtins.int max: Maximum.
        :param _builtins.int min: Minimum.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.int]:
        """
        Maximum.
        """
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.int]:
        """
        Minimum.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsMemoryGibPerVcpu(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.float] = None,
                 min: Optional[_builtins.float] = None):
        """
        :param _builtins.float max: Maximum. May be a decimal number, e.g. `0.5`.
        :param _builtins.float min: Minimum. May be a decimal number, e.g. `0.5`.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.float]:
        """
        Maximum. May be a decimal number, e.g. `0.5`.
        """
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.float]:
        """
        Minimum. May be a decimal number, e.g. `0.5`.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsMemoryMib(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.int] = None,
                 min: Optional[_builtins.int] = None):
        """
        :param _builtins.int max: Maximum.
        :param _builtins.int min: Minimum.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.int]:
        """
        Maximum.
        """
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.int]:
        """
        Minimum.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsNetworkBandwidthGbps(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.float] = None,
                 min: Optional[_builtins.float] = None):
        """
        :param _builtins.float max: Maximum.
        :param _builtins.float min: Minimum.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.float]:
        """
        Maximum.
        """
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.float]:
        """
        Minimum.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsNetworkInterfaceCount(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.int] = None,
                 min: Optional[_builtins.int] = None):
        """
        :param _builtins.int max: Maximum.
        :param _builtins.int min: Minimum.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.int]:
        """
        Maximum.
        """
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.int]:
        """
        Minimum.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsTotalLocalStorageGb(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.float] = None,
                 min: Optional[_builtins.float] = None):
        """
        :param _builtins.float max: Maximum. May be a decimal number, e.g. `0.5`.
        :param _builtins.float min: Minimum. May be a decimal number, e.g. `0.5`.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.float]:
        """
        Maximum. May be a decimal number, e.g. `0.5`.
        """
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.float]:
        """
        Minimum. May be a decimal number, e.g. `0.5`.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsVcpuCount(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.int] = None,
                 min: Optional[_builtins.int] = None):
        """
        :param _builtins.int max: Maximum.
        :param _builtins.int min: Minimum.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.int]:
        """
        Maximum.
        """
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.int]:
        """
        Minimum.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class SpotFleetRequestSpotMaintenanceStrategies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capacityRebalance":
            suggest = "capacity_rebalance"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetRequestSpotMaintenanceStrategies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetRequestSpotMaintenanceStrategies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetRequestSpotMaintenanceStrategies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capacity_rebalance: Optional['outputs.SpotFleetRequestSpotMaintenanceStrategiesCapacityRebalance'] = None):
        """
        :param 'SpotFleetRequestSpotMaintenanceStrategiesCapacityRebalanceArgs' capacity_rebalance: Nested argument containing the capacity rebalance for your fleet request. Defined below.
        """
        if capacity_rebalance is not None:
            pulumi.set(__self__, "capacity_rebalance", capacity_rebalance)

    @_builtins.property
    @pulumi.getter(name="capacityRebalance")
    def capacity_rebalance(self) -> Optional['outputs.SpotFleetRequestSpotMaintenanceStrategiesCapacityRebalance']:
        """
        Nested argument containing the capacity rebalance for your fleet request. Defined below.
        """
        return pulumi.get(self, "capacity_rebalance")


@pulumi.output_type
class SpotFleetRequestSpotMaintenanceStrategiesCapacityRebalance(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "replacementStrategy":
            suggest = "replacement_strategy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetRequestSpotMaintenanceStrategiesCapacityRebalance. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetRequestSpotMaintenanceStrategiesCapacityRebalance.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetRequestSpotMaintenanceStrategiesCapacityRebalance.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 replacement_strategy: Optional[_builtins.str] = None):
        """
        :param _builtins.str replacement_strategy: The replacement strategy to use. Only available for spot fleets with `fleet_type` set to `maintain`. Valid values: `launch`.
        """
        if replacement_strategy is not None:
            pulumi.set(__self__, "replacement_strategy", replacement_strategy)

    @_builtins.property
    @pulumi.getter(name="replacementStrategy")
    def replacement_strategy(self) -> Optional[_builtins.str]:
        """
        The replacement strategy to use. Only available for spot fleets with `fleet_type` set to `maintain`. Valid values: `launch`.
        """
        return pulumi.get(self, "replacement_strategy")


@pulumi.output_type
class SpotInstanceRequestCapacityReservationSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capacityReservationPreference":
            suggest = "capacity_reservation_preference"
        elif key == "capacityReservationTarget":
            suggest = "capacity_reservation_target"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotInstanceRequestCapacityReservationSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotInstanceRequestCapacityReservationSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotInstanceRequestCapacityReservationSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capacity_reservation_preference: Optional[_builtins.str] = None,
                 capacity_reservation_target: Optional['outputs.SpotInstanceRequestCapacityReservationSpecificationCapacityReservationTarget'] = None):
        """
        :param _builtins.str capacity_reservation_preference: Indicates the instance's Capacity Reservation preferences. Can be `"open"` or `"none"`. (Default: `"open"`).
        :param 'SpotInstanceRequestCapacityReservationSpecificationCapacityReservationTargetArgs' capacity_reservation_target: Information about the target Capacity Reservation. See Capacity Reservation Target below for more details.
               
               For more information, see the documentation on [Capacity Reservations](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/capacity-reservations-using.html).
        """
        if capacity_reservation_preference is not None:
            pulumi.set(__self__, "capacity_reservation_preference", capacity_reservation_preference)
        if capacity_reservation_target is not None:
            pulumi.set(__self__, "capacity_reservation_target", capacity_reservation_target)

    @_builtins.property
    @pulumi.getter(name="capacityReservationPreference")
    def capacity_reservation_preference(self) -> Optional[_builtins.str]:
        """
        Indicates the instance's Capacity Reservation preferences. Can be `"open"` or `"none"`. (Default: `"open"`).
        """
        return pulumi.get(self, "capacity_reservation_preference")

    @_builtins.property
    @pulumi.getter(name="capacityReservationTarget")
    def capacity_reservation_target(self) -> Optional['outputs.SpotInstanceRequestCapacityReservationSpecificationCapacityReservationTarget']:
        """
        Information about the target Capacity Reservation. See Capacity Reservation Target below for more details.

        For more information, see the documentation on [Capacity Reservations](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/capacity-reservations-using.html).
        """
        return pulumi.get(self, "capacity_reservation_target")


@pulumi.output_type
class SpotInstanceRequestCapacityReservationSpecificationCapacityReservationTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capacityReservationId":
            suggest = "capacity_reservation_id"
        elif key == "capacityReservationResourceGroupArn":
            suggest = "capacity_reservation_resource_group_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotInstanceRequestCapacityReservationSpecificationCapacityReservationTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotInstanceRequestCapacityReservationSpecificationCapacityReservationTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotInstanceRequestCapacityReservationSpecificationCapacityReservationTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capacity_reservation_id: Optional[_builtins.str] = None,
                 capacity_reservation_resource_group_arn: Optional[_builtins.str] = None):
        """
        :param _builtins.str capacity_reservation_id: ID of the Capacity Reservation in which to run the instance.
        :param _builtins.str capacity_reservation_resource_group_arn: ARN of the Capacity Reservation resource group in which to run the instance.
        """
        if capacity_reservation_id is not None:
            pulumi.set(__self__, "capacity_reservation_id", capacity_reservation_id)
        if capacity_reservation_resource_group_arn is not None:
            pulumi.set(__self__, "capacity_reservation_resource_group_arn", capacity_reservation_resource_group_arn)

    @_builtins.property
    @pulumi.getter(name="capacityReservationId")
    def capacity_reservation_id(self) -> Optional[_builtins.str]:
        """
        ID of the Capacity Reservation in which to run the instance.
        """
        return pulumi.get(self, "capacity_reservation_id")

    @_builtins.property
    @pulumi.getter(name="capacityReservationResourceGroupArn")
    def capacity_reservation_resource_group_arn(self) -> Optional[_builtins.str]:
        """
        ARN of the Capacity Reservation resource group in which to run the instance.
        """
        return pulumi.get(self, "capacity_reservation_resource_group_arn")


@pulumi.output_type
class SpotInstanceRequestCpuOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "amdSevSnp":
            suggest = "amd_sev_snp"
        elif key == "coreCount":
            suggest = "core_count"
        elif key == "threadsPerCore":
            suggest = "threads_per_core"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotInstanceRequestCpuOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotInstanceRequestCpuOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotInstanceRequestCpuOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 amd_sev_snp: Optional[_builtins.str] = None,
                 core_count: Optional[_builtins.int] = None,
                 threads_per_core: Optional[_builtins.int] = None):
        """
        :param _builtins.str amd_sev_snp: Indicates whether to enable the instance for AMD SEV-SNP. AMD SEV-SNP is supported with M6a, R6a, and C6a instance types only. Valid values are `enabled` and `disabled`.
        :param _builtins.int core_count: Sets the number of CPU cores for an instance. This option is only supported on creation of instance type that support CPU Options [CPU Cores and Threads Per CPU Core Per Instance Type](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html#cpu-options-supported-instances-values) - specifying this option for unsupported instance types will return an error from the EC2 API.
        :param _builtins.int threads_per_core: If set to 1, hyperthreading is disabled on the launched instance. Defaults to 2 if not set. See [Optimizing CPU Options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html) for more information.
               
               For more information, see the documentation on [Optimizing CPU options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html).
        """
        if amd_sev_snp is not None:
            pulumi.set(__self__, "amd_sev_snp", amd_sev_snp)
        if core_count is not None:
            pulumi.set(__self__, "core_count", core_count)
        if threads_per_core is not None:
            pulumi.set(__self__, "threads_per_core", threads_per_core)

    @_builtins.property
    @pulumi.getter(name="amdSevSnp")
    def amd_sev_snp(self) -> Optional[_builtins.str]:
        """
        Indicates whether to enable the instance for AMD SEV-SNP. AMD SEV-SNP is supported with M6a, R6a, and C6a instance types only. Valid values are `enabled` and `disabled`.
        """
        return pulumi.get(self, "amd_sev_snp")

    @_builtins.property
    @pulumi.getter(name="coreCount")
    def core_count(self) -> Optional[_builtins.int]:
        """
        Sets the number of CPU cores for an instance. This option is only supported on creation of instance type that support CPU Options [CPU Cores and Threads Per CPU Core Per Instance Type](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html#cpu-options-supported-instances-values) - specifying this option for unsupported instance types will return an error from the EC2 API.
        """
        return pulumi.get(self, "core_count")

    @_builtins.property
    @pulumi.getter(name="threadsPerCore")
    def threads_per_core(self) -> Optional[_builtins.int]:
        """
        If set to 1, hyperthreading is disabled on the launched instance. Defaults to 2 if not set. See [Optimizing CPU Options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html) for more information.

        For more information, see the documentation on [Optimizing CPU options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html).
        """
        return pulumi.get(self, "threads_per_core")


@pulumi.output_type
class SpotInstanceRequestCreditSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cpuCredits":
            suggest = "cpu_credits"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotInstanceRequestCreditSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotInstanceRequestCreditSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotInstanceRequestCreditSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu_credits: Optional[_builtins.str] = None):
        """
        :param _builtins.str cpu_credits: Credit option for CPU usage. Valid values include `standard` or `unlimited`. T3 instances are launched as unlimited by default. T2 instances are launched as standard by default.
        """
        if cpu_credits is not None:
            pulumi.set(__self__, "cpu_credits", cpu_credits)

    @_builtins.property
    @pulumi.getter(name="cpuCredits")
    def cpu_credits(self) -> Optional[_builtins.str]:
        """
        Credit option for CPU usage. Valid values include `standard` or `unlimited`. T3 instances are launched as unlimited by default. T2 instances are launched as standard by default.
        """
        return pulumi.get(self, "cpu_credits")


@pulumi.output_type
class SpotInstanceRequestEbsBlockDevice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "snapshotId":
            suggest = "snapshot_id"
        elif key == "tagsAll":
            suggest = "tags_all"
        elif key == "volumeId":
            suggest = "volume_id"
        elif key == "volumeSize":
            suggest = "volume_size"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotInstanceRequestEbsBlockDevice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotInstanceRequestEbsBlockDevice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotInstanceRequestEbsBlockDevice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_name: _builtins.str,
                 delete_on_termination: Optional[_builtins.bool] = None,
                 encrypted: Optional[_builtins.bool] = None,
                 iops: Optional[_builtins.int] = None,
                 kms_key_id: Optional[_builtins.str] = None,
                 snapshot_id: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 tags_all: Optional[Mapping[str, _builtins.str]] = None,
                 throughput: Optional[_builtins.int] = None,
                 volume_id: Optional[_builtins.str] = None,
                 volume_size: Optional[_builtins.int] = None,
                 volume_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str device_name: Name of the device to mount.
        :param _builtins.bool delete_on_termination: Whether the volume should be destroyed on instance termination. Defaults to `true`.
        :param _builtins.bool encrypted: Enables [EBS encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html) on the volume. Defaults to `false`. Cannot be used with `snapshot_id`. Must be configured to perform drift detection.
        :param _builtins.int iops: Amount of provisioned [IOPS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-io-characteristics.html). Only valid for volume_type of `io1`, `io2` or `gp3`.
        :param _builtins.str kms_key_id: Amazon Resource Name (ARN) of the KMS Key to use when encrypting the volume. Must be configured to perform drift detection.
        :param _builtins.str snapshot_id: Snapshot ID to mount.
        :param Mapping[str, _builtins.str] tags: Map of tags to assign to the device.
        :param Mapping[str, _builtins.str] tags_all: A map of tags assigned to the resource, including those inherited from the provider `default_tags` configuration block.
        :param _builtins.int throughput: Throughput to provision for a volume in mebibytes per second (MiB/s). This is only valid for `volume_type` of `gp3`.
        :param _builtins.int volume_size: Size of the volume in gibibytes (GiB).
        :param _builtins.str volume_type: Type of volume. Valid values include `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1`, or `st1`. Defaults to `gp2`.
               
               > **NOTE:** Currently, changes to the `ebs_block_device` configuration of _existing_ resources cannot be automatically detected by this provider. To manage changes and attachments of an EBS block to an instance, use the `ebs.Volume` and `ec2.VolumeAttachment` resources instead. If you use `ebs_block_device` on an `ec2.Instance`, this provider will assume management over the full set of non-root EBS block devices for the instance, treating additional block devices as drift. For this reason, `ebs_block_device` cannot be mixed with external `ebs.Volume` and `ec2.VolumeAttachment` resources for a given instance.
        """
        pulumi.set(__self__, "device_name", device_name)
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tags_all is not None:
            pulumi.set(__self__, "tags_all", tags_all)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)
        if volume_id is not None:
            pulumi.set(__self__, "volume_id", volume_id)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> _builtins.str:
        """
        Name of the device to mount.
        """
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[_builtins.bool]:
        """
        Whether the volume should be destroyed on instance termination. Defaults to `true`.
        """
        return pulumi.get(self, "delete_on_termination")

    @_builtins.property
    @pulumi.getter
    def encrypted(self) -> Optional[_builtins.bool]:
        """
        Enables [EBS encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html) on the volume. Defaults to `false`. Cannot be used with `snapshot_id`. Must be configured to perform drift detection.
        """
        return pulumi.get(self, "encrypted")

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[_builtins.int]:
        """
        Amount of provisioned [IOPS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-io-characteristics.html). Only valid for volume_type of `io1`, `io2` or `gp3`.
        """
        return pulumi.get(self, "iops")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[_builtins.str]:
        """
        Amazon Resource Name (ARN) of the KMS Key to use when encrypting the volume. Must be configured to perform drift detection.
        """
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[_builtins.str]:
        """
        Snapshot ID to mount.
        """
        return pulumi.get(self, "snapshot_id")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Map of tags to assign to the device.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="tagsAll")
    def tags_all(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        A map of tags assigned to the resource, including those inherited from the provider `default_tags` configuration block.
        """
        return pulumi.get(self, "tags_all")

    @_builtins.property
    @pulumi.getter
    def throughput(self) -> Optional[_builtins.int]:
        """
        Throughput to provision for a volume in mebibytes per second (MiB/s). This is only valid for `volume_type` of `gp3`.
        """
        return pulumi.get(self, "throughput")

    @_builtins.property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "volume_id")

    @_builtins.property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[_builtins.int]:
        """
        Size of the volume in gibibytes (GiB).
        """
        return pulumi.get(self, "volume_size")

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[_builtins.str]:
        """
        Type of volume. Valid values include `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1`, or `st1`. Defaults to `gp2`.

        > **NOTE:** Currently, changes to the `ebs_block_device` configuration of _existing_ resources cannot be automatically detected by this provider. To manage changes and attachments of an EBS block to an instance, use the `ebs.Volume` and `ec2.VolumeAttachment` resources instead. If you use `ebs_block_device` on an `ec2.Instance`, this provider will assume management over the full set of non-root EBS block devices for the instance, treating additional block devices as drift. For this reason, `ebs_block_device` cannot be mixed with external `ebs.Volume` and `ec2.VolumeAttachment` resources for a given instance.
        """
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class SpotInstanceRequestEnclaveOptions(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: Whether Nitro Enclaves will be enabled on the instance. Defaults to `false`.
               
               For more information, see the documentation on [Nitro Enclaves](https://docs.aws.amazon.com/enclaves/latest/user/nitro-enclave.html).
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Whether Nitro Enclaves will be enabled on the instance. Defaults to `false`.

        For more information, see the documentation on [Nitro Enclaves](https://docs.aws.amazon.com/enclaves/latest/user/nitro-enclave.html).
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class SpotInstanceRequestEphemeralBlockDevice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "noDevice":
            suggest = "no_device"
        elif key == "virtualName":
            suggest = "virtual_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotInstanceRequestEphemeralBlockDevice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotInstanceRequestEphemeralBlockDevice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotInstanceRequestEphemeralBlockDevice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_name: _builtins.str,
                 no_device: Optional[_builtins.bool] = None,
                 virtual_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str device_name: Name of the block device to mount on the instance.
        :param _builtins.bool no_device: Suppresses the specified device included in the AMI's block device mapping.
        :param _builtins.str virtual_name: [Instance Store Device Name](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#InstanceStoreDeviceNames) (e.g., `ephemeral0`).
               
               Each AWS Instance type has a different set of Instance Store block devices available for attachment. AWS [publishes a list](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#StorageOnInstanceTypes) of which ephemeral devices are available on each type. The devices are always identified by the `virtual_name` in the format `ephemeral{0..N}`.
        """
        pulumi.set(__self__, "device_name", device_name)
        if no_device is not None:
            pulumi.set(__self__, "no_device", no_device)
        if virtual_name is not None:
            pulumi.set(__self__, "virtual_name", virtual_name)

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> _builtins.str:
        """
        Name of the block device to mount on the instance.
        """
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter(name="noDevice")
    def no_device(self) -> Optional[_builtins.bool]:
        """
        Suppresses the specified device included in the AMI's block device mapping.
        """
        return pulumi.get(self, "no_device")

    @_builtins.property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> Optional[_builtins.str]:
        """
        [Instance Store Device Name](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#InstanceStoreDeviceNames) (e.g., `ephemeral0`).

        Each AWS Instance type has a different set of Instance Store block devices available for attachment. AWS [publishes a list](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#StorageOnInstanceTypes) of which ephemeral devices are available on each type. The devices are always identified by the `virtual_name` in the format `ephemeral{0..N}`.
        """
        return pulumi.get(self, "virtual_name")


@pulumi.output_type
class SpotInstanceRequestLaunchTemplate(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 version: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: ID of the launch template. Conflicts with `name`.
        :param _builtins.str name: Name of the launch template. Conflicts with `id`.
        :param _builtins.str version: Template version. Can be a specific version number, `$Latest` or `$Default`. The default value is `$Default`.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        ID of the launch template. Conflicts with `name`.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the launch template. Conflicts with `id`.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.str]:
        """
        Template version. Can be a specific version number, `$Latest` or `$Default`. The default value is `$Default`.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class SpotInstanceRequestMaintenanceOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoRecovery":
            suggest = "auto_recovery"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotInstanceRequestMaintenanceOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotInstanceRequestMaintenanceOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotInstanceRequestMaintenanceOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_recovery: Optional[_builtins.str] = None):
        """
        :param _builtins.str auto_recovery: Automatic recovery behavior of the Instance. Can be `"default"` or `"disabled"`. See [Recover your instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-recover.html) for more details.
        """
        if auto_recovery is not None:
            pulumi.set(__self__, "auto_recovery", auto_recovery)

    @_builtins.property
    @pulumi.getter(name="autoRecovery")
    def auto_recovery(self) -> Optional[_builtins.str]:
        """
        Automatic recovery behavior of the Instance. Can be `"default"` or `"disabled"`. See [Recover your instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-recover.html) for more details.
        """
        return pulumi.get(self, "auto_recovery")


@pulumi.output_type
class SpotInstanceRequestMetadataOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpEndpoint":
            suggest = "http_endpoint"
        elif key == "httpProtocolIpv6":
            suggest = "http_protocol_ipv6"
        elif key == "httpPutResponseHopLimit":
            suggest = "http_put_response_hop_limit"
        elif key == "httpTokens":
            suggest = "http_tokens"
        elif key == "instanceMetadataTags":
            suggest = "instance_metadata_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotInstanceRequestMetadataOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotInstanceRequestMetadataOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotInstanceRequestMetadataOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_endpoint: Optional[_builtins.str] = None,
                 http_protocol_ipv6: Optional[_builtins.str] = None,
                 http_put_response_hop_limit: Optional[_builtins.int] = None,
                 http_tokens: Optional[_builtins.str] = None,
                 instance_metadata_tags: Optional[_builtins.str] = None):
        """
        :param _builtins.str http_endpoint: Whether the metadata service is available. Valid values include `enabled` or `disabled`. Defaults to `enabled`.
        :param _builtins.str http_protocol_ipv6: Whether the IPv6 endpoint for the instance metadata service is enabled. Defaults to `disabled`.
        :param _builtins.int http_put_response_hop_limit: Desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel. Valid values are integer from `1` to `64`. Defaults to `1`.
        :param _builtins.str http_tokens: Whether or not the metadata service requires session tokens, also referred to as _Instance Metadata Service Version 2 (IMDSv2)_. Valid values include `optional` or `required`.
        :param _builtins.str instance_metadata_tags: Enables or disables access to instance tags from the instance metadata service. Valid values include `enabled` or `disabled`. Defaults to `disabled`.
               
               For more information, see the documentation on the [Instance Metadata Service](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html).
        """
        if http_endpoint is not None:
            pulumi.set(__self__, "http_endpoint", http_endpoint)
        if http_protocol_ipv6 is not None:
            pulumi.set(__self__, "http_protocol_ipv6", http_protocol_ipv6)
        if http_put_response_hop_limit is not None:
            pulumi.set(__self__, "http_put_response_hop_limit", http_put_response_hop_limit)
        if http_tokens is not None:
            pulumi.set(__self__, "http_tokens", http_tokens)
        if instance_metadata_tags is not None:
            pulumi.set(__self__, "instance_metadata_tags", instance_metadata_tags)

    @_builtins.property
    @pulumi.getter(name="httpEndpoint")
    def http_endpoint(self) -> Optional[_builtins.str]:
        """
        Whether the metadata service is available. Valid values include `enabled` or `disabled`. Defaults to `enabled`.
        """
        return pulumi.get(self, "http_endpoint")

    @_builtins.property
    @pulumi.getter(name="httpProtocolIpv6")
    def http_protocol_ipv6(self) -> Optional[_builtins.str]:
        """
        Whether the IPv6 endpoint for the instance metadata service is enabled. Defaults to `disabled`.
        """
        return pulumi.get(self, "http_protocol_ipv6")

    @_builtins.property
    @pulumi.getter(name="httpPutResponseHopLimit")
    def http_put_response_hop_limit(self) -> Optional[_builtins.int]:
        """
        Desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel. Valid values are integer from `1` to `64`. Defaults to `1`.
        """
        return pulumi.get(self, "http_put_response_hop_limit")

    @_builtins.property
    @pulumi.getter(name="httpTokens")
    def http_tokens(self) -> Optional[_builtins.str]:
        """
        Whether or not the metadata service requires session tokens, also referred to as _Instance Metadata Service Version 2 (IMDSv2)_. Valid values include `optional` or `required`.
        """
        return pulumi.get(self, "http_tokens")

    @_builtins.property
    @pulumi.getter(name="instanceMetadataTags")
    def instance_metadata_tags(self) -> Optional[_builtins.str]:
        """
        Enables or disables access to instance tags from the instance metadata service. Valid values include `enabled` or `disabled`. Defaults to `disabled`.

        For more information, see the documentation on the [Instance Metadata Service](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html).
        """
        return pulumi.get(self, "instance_metadata_tags")


@pulumi.output_type
class SpotInstanceRequestNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceIndex":
            suggest = "device_index"
        elif key == "networkInterfaceId":
            suggest = "network_interface_id"
        elif key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "networkCardIndex":
            suggest = "network_card_index"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotInstanceRequestNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotInstanceRequestNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotInstanceRequestNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_index: _builtins.int,
                 network_interface_id: _builtins.str,
                 delete_on_termination: Optional[_builtins.bool] = None,
                 network_card_index: Optional[_builtins.int] = None):
        """
        :param _builtins.int device_index: Integer index of the network interface attachment. Limited by instance type.
        :param _builtins.str network_interface_id: ID of the network interface to attach.
        :param _builtins.bool delete_on_termination: Whether or not to delete the network interface on instance termination. Defaults to `false`. Currently, the only valid value is `false`, as this is only supported when creating new network interfaces when launching an instance.
        :param _builtins.int network_card_index: Integer index of the network card. Limited by instance type. The default index is `0`.
        """
        pulumi.set(__self__, "device_index", device_index)
        pulumi.set(__self__, "network_interface_id", network_interface_id)
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if network_card_index is not None:
            pulumi.set(__self__, "network_card_index", network_card_index)

    @_builtins.property
    @pulumi.getter(name="deviceIndex")
    def device_index(self) -> _builtins.int:
        """
        Integer index of the network interface attachment. Limited by instance type.
        """
        return pulumi.get(self, "device_index")

    @_builtins.property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> _builtins.str:
        """
        ID of the network interface to attach.
        """
        return pulumi.get(self, "network_interface_id")

    @_builtins.property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[_builtins.bool]:
        """
        Whether or not to delete the network interface on instance termination. Defaults to `false`. Currently, the only valid value is `false`, as this is only supported when creating new network interfaces when launching an instance.
        """
        return pulumi.get(self, "delete_on_termination")

    @_builtins.property
    @pulumi.getter(name="networkCardIndex")
    def network_card_index(self) -> Optional[_builtins.int]:
        """
        Integer index of the network card. Limited by instance type. The default index is `0`.
        """
        return pulumi.get(self, "network_card_index")


@pulumi.output_type
class SpotInstanceRequestPrivateDnsNameOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableResourceNameDnsARecord":
            suggest = "enable_resource_name_dns_a_record"
        elif key == "enableResourceNameDnsAaaaRecord":
            suggest = "enable_resource_name_dns_aaaa_record"
        elif key == "hostnameType":
            suggest = "hostname_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotInstanceRequestPrivateDnsNameOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotInstanceRequestPrivateDnsNameOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotInstanceRequestPrivateDnsNameOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_resource_name_dns_a_record: Optional[_builtins.bool] = None,
                 enable_resource_name_dns_aaaa_record: Optional[_builtins.bool] = None,
                 hostname_type: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enable_resource_name_dns_a_record: Indicates whether to respond to DNS queries for instance hostnames with DNS A records.
        :param _builtins.bool enable_resource_name_dns_aaaa_record: Indicates whether to respond to DNS queries for instance hostnames with DNS AAAA records.
        :param _builtins.str hostname_type: Type of hostname for Amazon EC2 instances. For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 native subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID. Valid values: `ip-name` and `resource-name`.
        """
        if enable_resource_name_dns_a_record is not None:
            pulumi.set(__self__, "enable_resource_name_dns_a_record", enable_resource_name_dns_a_record)
        if enable_resource_name_dns_aaaa_record is not None:
            pulumi.set(__self__, "enable_resource_name_dns_aaaa_record", enable_resource_name_dns_aaaa_record)
        if hostname_type is not None:
            pulumi.set(__self__, "hostname_type", hostname_type)

    @_builtins.property
    @pulumi.getter(name="enableResourceNameDnsARecord")
    def enable_resource_name_dns_a_record(self) -> Optional[_builtins.bool]:
        """
        Indicates whether to respond to DNS queries for instance hostnames with DNS A records.
        """
        return pulumi.get(self, "enable_resource_name_dns_a_record")

    @_builtins.property
    @pulumi.getter(name="enableResourceNameDnsAaaaRecord")
    def enable_resource_name_dns_aaaa_record(self) -> Optional[_builtins.bool]:
        """
        Indicates whether to respond to DNS queries for instance hostnames with DNS AAAA records.
        """
        return pulumi.get(self, "enable_resource_name_dns_aaaa_record")

    @_builtins.property
    @pulumi.getter(name="hostnameType")
    def hostname_type(self) -> Optional[_builtins.str]:
        """
        Type of hostname for Amazon EC2 instances. For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 native subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID. Valid values: `ip-name` and `resource-name`.
        """
        return pulumi.get(self, "hostname_type")


@pulumi.output_type
class SpotInstanceRequestRootBlockDevice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "deviceName":
            suggest = "device_name"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "tagsAll":
            suggest = "tags_all"
        elif key == "volumeId":
            suggest = "volume_id"
        elif key == "volumeSize":
            suggest = "volume_size"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotInstanceRequestRootBlockDevice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotInstanceRequestRootBlockDevice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotInstanceRequestRootBlockDevice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delete_on_termination: Optional[_builtins.bool] = None,
                 device_name: Optional[_builtins.str] = None,
                 encrypted: Optional[_builtins.bool] = None,
                 iops: Optional[_builtins.int] = None,
                 kms_key_id: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 tags_all: Optional[Mapping[str, _builtins.str]] = None,
                 throughput: Optional[_builtins.int] = None,
                 volume_id: Optional[_builtins.str] = None,
                 volume_size: Optional[_builtins.int] = None,
                 volume_type: Optional[_builtins.str] = None):
        """
        :param _builtins.bool delete_on_termination: Whether the volume should be destroyed on instance termination. Defaults to `true`.
        :param _builtins.bool encrypted: Whether to enable volume encryption. Defaults to `false`. Must be configured to perform drift detection.
        :param _builtins.int iops: Amount of provisioned [IOPS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-io-characteristics.html). Only valid for volume_type of `io1`, `io2` or `gp3`.
        :param _builtins.str kms_key_id: Amazon Resource Name (ARN) of the KMS Key to use when encrypting the volume. Must be configured to perform drift detection.
        :param Mapping[str, _builtins.str] tags: Map of tags to assign to the device.
        :param Mapping[str, _builtins.str] tags_all: A map of tags assigned to the resource, including those inherited from the provider `default_tags` configuration block.
        :param _builtins.int throughput: Throughput to provision for a volume in mebibytes per second (MiB/s). This is only valid for `volume_type` of `gp3`.
        :param _builtins.int volume_size: Size of the volume in gibibytes (GiB).
        :param _builtins.str volume_type: Type of volume. Valid values include `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1`, or `st1`. Defaults to the volume type that the AMI uses.
               
               Modifying the `encrypted` or `kms_key_id` settings of the `root_block_device` requires resource replacement.
        """
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tags_all is not None:
            pulumi.set(__self__, "tags_all", tags_all)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)
        if volume_id is not None:
            pulumi.set(__self__, "volume_id", volume_id)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[_builtins.bool]:
        """
        Whether the volume should be destroyed on instance termination. Defaults to `true`.
        """
        return pulumi.get(self, "delete_on_termination")

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter
    def encrypted(self) -> Optional[_builtins.bool]:
        """
        Whether to enable volume encryption. Defaults to `false`. Must be configured to perform drift detection.
        """
        return pulumi.get(self, "encrypted")

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[_builtins.int]:
        """
        Amount of provisioned [IOPS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-io-characteristics.html). Only valid for volume_type of `io1`, `io2` or `gp3`.
        """
        return pulumi.get(self, "iops")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[_builtins.str]:
        """
        Amazon Resource Name (ARN) of the KMS Key to use when encrypting the volume. Must be configured to perform drift detection.
        """
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Map of tags to assign to the device.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="tagsAll")
    def tags_all(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        A map of tags assigned to the resource, including those inherited from the provider `default_tags` configuration block.
        """
        return pulumi.get(self, "tags_all")

    @_builtins.property
    @pulumi.getter
    def throughput(self) -> Optional[_builtins.int]:
        """
        Throughput to provision for a volume in mebibytes per second (MiB/s). This is only valid for `volume_type` of `gp3`.
        """
        return pulumi.get(self, "throughput")

    @_builtins.property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "volume_id")

    @_builtins.property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[_builtins.int]:
        """
        Size of the volume in gibibytes (GiB).
        """
        return pulumi.get(self, "volume_size")

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[_builtins.str]:
        """
        Type of volume. Valid values include `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1`, or `st1`. Defaults to the volume type that the AMI uses.

        Modifying the `encrypted` or `kms_key_id` settings of the `root_block_device` requires resource replacement.
        """
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class TrafficMirrorFilterRuleDestinationPortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromPort":
            suggest = "from_port"
        elif key == "toPort":
            suggest = "to_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TrafficMirrorFilterRuleDestinationPortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TrafficMirrorFilterRuleDestinationPortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TrafficMirrorFilterRuleDestinationPortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_port: Optional[_builtins.int] = None,
                 to_port: Optional[_builtins.int] = None):
        """
        :param _builtins.int from_port: Starting port of the range
        :param _builtins.int to_port: Ending port of the range
        """
        if from_port is not None:
            pulumi.set(__self__, "from_port", from_port)
        if to_port is not None:
            pulumi.set(__self__, "to_port", to_port)

    @_builtins.property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> Optional[_builtins.int]:
        """
        Starting port of the range
        """
        return pulumi.get(self, "from_port")

    @_builtins.property
    @pulumi.getter(name="toPort")
    def to_port(self) -> Optional[_builtins.int]:
        """
        Ending port of the range
        """
        return pulumi.get(self, "to_port")


@pulumi.output_type
class TrafficMirrorFilterRuleSourcePortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromPort":
            suggest = "from_port"
        elif key == "toPort":
            suggest = "to_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TrafficMirrorFilterRuleSourcePortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TrafficMirrorFilterRuleSourcePortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TrafficMirrorFilterRuleSourcePortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_port: Optional[_builtins.int] = None,
                 to_port: Optional[_builtins.int] = None):
        """
        :param _builtins.int from_port: Starting port of the range
        :param _builtins.int to_port: Ending port of the range
        """
        if from_port is not None:
            pulumi.set(__self__, "from_port", from_port)
        if to_port is not None:
            pulumi.set(__self__, "to_port", to_port)

    @_builtins.property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> Optional[_builtins.int]:
        """
        Starting port of the range
        """
        return pulumi.get(self, "from_port")

    @_builtins.property
    @pulumi.getter(name="toPort")
    def to_port(self) -> Optional[_builtins.int]:
        """
        Ending port of the range
        """
        return pulumi.get(self, "to_port")


@pulumi.output_type
class VpcBlockPublicAccessExclusionTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[_builtins.str] = None,
                 delete: Optional[_builtins.str] = None,
                 update: Optional[_builtins.str] = None):
        """
        :param _builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param _builtins.str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param _builtins.str update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")


@pulumi.output_type
class VpcBlockPublicAccessOptionsTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[_builtins.str] = None,
                 delete: Optional[_builtins.str] = None,
                 update: Optional[_builtins.str] = None):
        """
        :param _builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param _builtins.str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param _builtins.str update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")


@pulumi.output_type
class VpcEndpointDnsEntry(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsName":
            suggest = "dns_name"
        elif key == "hostedZoneId":
            suggest = "hosted_zone_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcEndpointDnsEntry. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcEndpointDnsEntry.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcEndpointDnsEntry.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dns_name: Optional[_builtins.str] = None,
                 hosted_zone_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str dns_name: The DNS name.
        :param _builtins.str hosted_zone_id: The ID of the private hosted zone.
        """
        if dns_name is not None:
            pulumi.set(__self__, "dns_name", dns_name)
        if hosted_zone_id is not None:
            pulumi.set(__self__, "hosted_zone_id", hosted_zone_id)

    @_builtins.property
    @pulumi.getter(name="dnsName")
    def dns_name(self) -> Optional[_builtins.str]:
        """
        The DNS name.
        """
        return pulumi.get(self, "dns_name")

    @_builtins.property
    @pulumi.getter(name="hostedZoneId")
    def hosted_zone_id(self) -> Optional[_builtins.str]:
        """
        The ID of the private hosted zone.
        """
        return pulumi.get(self, "hosted_zone_id")


@pulumi.output_type
class VpcEndpointDnsOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsRecordIpType":
            suggest = "dns_record_ip_type"
        elif key == "privateDnsOnlyForInboundResolverEndpoint":
            suggest = "private_dns_only_for_inbound_resolver_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcEndpointDnsOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcEndpointDnsOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcEndpointDnsOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dns_record_ip_type: Optional[_builtins.str] = None,
                 private_dns_only_for_inbound_resolver_endpoint: Optional[_builtins.bool] = None):
        """
        :param _builtins.str dns_record_ip_type: The DNS records created for the endpoint. Valid values are `ipv4`, `dualstack`, `service-defined`, and `ipv6`.
        :param _builtins.bool private_dns_only_for_inbound_resolver_endpoint: Indicates whether to enable private DNS only for inbound endpoints. This option is available only for services that support both gateway and interface endpoints. It routes traffic that originates from the VPC to the gateway endpoint and traffic that originates from on-premises to the interface endpoint. Default is `false`. Can only be specified if private_dns_enabled is `true`.
        """
        if dns_record_ip_type is not None:
            pulumi.set(__self__, "dns_record_ip_type", dns_record_ip_type)
        if private_dns_only_for_inbound_resolver_endpoint is not None:
            pulumi.set(__self__, "private_dns_only_for_inbound_resolver_endpoint", private_dns_only_for_inbound_resolver_endpoint)

    @_builtins.property
    @pulumi.getter(name="dnsRecordIpType")
    def dns_record_ip_type(self) -> Optional[_builtins.str]:
        """
        The DNS records created for the endpoint. Valid values are `ipv4`, `dualstack`, `service-defined`, and `ipv6`.
        """
        return pulumi.get(self, "dns_record_ip_type")

    @_builtins.property
    @pulumi.getter(name="privateDnsOnlyForInboundResolverEndpoint")
    def private_dns_only_for_inbound_resolver_endpoint(self) -> Optional[_builtins.bool]:
        """
        Indicates whether to enable private DNS only for inbound endpoints. This option is available only for services that support both gateway and interface endpoints. It routes traffic that originates from the VPC to the gateway endpoint and traffic that originates from on-premises to the interface endpoint. Default is `false`. Can only be specified if private_dns_enabled is `true`.
        """
        return pulumi.get(self, "private_dns_only_for_inbound_resolver_endpoint")


@pulumi.output_type
class VpcEndpointServicePrivateDnsNameConfiguration(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name of the record subdomain the service provider needs to create.
        :param _builtins.str state: Verification state of the VPC endpoint service. Consumers of the endpoint service can use the private name only when the state is `verified`.
        :param _builtins.str type: Endpoint service verification type, for example `TXT`.
        :param _builtins.str value: Value the service provider adds to the private DNS name domain record before verification.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the record subdomain the service provider needs to create.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Verification state of the VPC endpoint service. Consumers of the endpoint service can use the private name only when the state is `verified`.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Endpoint service verification type, for example `TXT`.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Value the service provider adds to the private DNS name domain record before verification.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class VpcEndpointSubnetConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcEndpointSubnetConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcEndpointSubnetConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcEndpointSubnetConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ipv4: Optional[_builtins.str] = None,
                 ipv6: Optional[_builtins.str] = None,
                 subnet_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str ipv4: The IPv4 address to assign to the endpoint network interface in the subnet. You must provide an IPv4 address if the VPC endpoint supports IPv4.
        :param _builtins.str ipv6: The IPv6 address to assign to the endpoint network interface in the subnet. You must provide an IPv6 address if the VPC endpoint supports IPv6.
        """
        if ipv4 is not None:
            pulumi.set(__self__, "ipv4", ipv4)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter
    def ipv4(self) -> Optional[_builtins.str]:
        """
        The IPv4 address to assign to the endpoint network interface in the subnet. You must provide an IPv4 address if the VPC endpoint supports IPv4.
        """
        return pulumi.get(self, "ipv4")

    @_builtins.property
    @pulumi.getter
    def ipv6(self) -> Optional[_builtins.str]:
        """
        The IPv6 address to assign to the endpoint network interface in the subnet. You must provide an IPv6 address if the VPC endpoint supports IPv6.
        """
        return pulumi.get(self, "ipv6")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class VpcIpamOperatingRegion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "regionName":
            suggest = "region_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcIpamOperatingRegion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcIpamOperatingRegion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcIpamOperatingRegion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 region_name: _builtins.str):
        """
        :param _builtins.str region_name: The name of the Region you want to add to the IPAM.
        """
        pulumi.set(__self__, "region_name", region_name)

    @_builtins.property
    @pulumi.getter(name="regionName")
    def region_name(self) -> _builtins.str:
        """
        The name of the Region you want to add to the IPAM.
        """
        return pulumi.get(self, "region_name")


@pulumi.output_type
class VpcIpamPoolCidrCidrAuthorizationContext(dict):
    def __init__(__self__, *,
                 message: Optional[_builtins.str] = None,
                 signature: Optional[_builtins.str] = None):
        """
        :param _builtins.str message: The plain-text authorization message for the prefix and account.
        :param _builtins.str signature: The signed authorization message for the prefix and account.
        """
        if message is not None:
            pulumi.set(__self__, "message", message)
        if signature is not None:
            pulumi.set(__self__, "signature", signature)

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[_builtins.str]:
        """
        The plain-text authorization message for the prefix and account.
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter
    def signature(self) -> Optional[_builtins.str]:
        """
        The signed authorization message for the prefix and account.
        """
        return pulumi.get(self, "signature")


@pulumi.output_type
class VpcIpamResourceDiscoveryOperatingRegion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "regionName":
            suggest = "region_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcIpamResourceDiscoveryOperatingRegion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcIpamResourceDiscoveryOperatingRegion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcIpamResourceDiscoveryOperatingRegion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 region_name: _builtins.str):
        """
        :param _builtins.str region_name: The name of the Region you want to add to the IPAM.
        """
        pulumi.set(__self__, "region_name", region_name)

    @_builtins.property
    @pulumi.getter(name="regionName")
    def region_name(self) -> _builtins.str:
        """
        The name of the Region you want to add to the IPAM.
        """
        return pulumi.get(self, "region_name")


@pulumi.output_type
class VpcPeeringConnectionAccepter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowRemoteVpcDnsResolution":
            suggest = "allow_remote_vpc_dns_resolution"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcPeeringConnectionAccepter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcPeeringConnectionAccepter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcPeeringConnectionAccepter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_remote_vpc_dns_resolution: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool allow_remote_vpc_dns_resolution: Allow a local VPC to resolve public DNS hostnames to
               private IP addresses when queried from instances in the peer VPC.
        """
        if allow_remote_vpc_dns_resolution is not None:
            pulumi.set(__self__, "allow_remote_vpc_dns_resolution", allow_remote_vpc_dns_resolution)

    @_builtins.property
    @pulumi.getter(name="allowRemoteVpcDnsResolution")
    def allow_remote_vpc_dns_resolution(self) -> Optional[_builtins.bool]:
        """
        Allow a local VPC to resolve public DNS hostnames to
        private IP addresses when queried from instances in the peer VPC.
        """
        return pulumi.get(self, "allow_remote_vpc_dns_resolution")


@pulumi.output_type
class VpcPeeringConnectionAccepterAccepter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowRemoteVpcDnsResolution":
            suggest = "allow_remote_vpc_dns_resolution"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcPeeringConnectionAccepterAccepter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcPeeringConnectionAccepterAccepter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcPeeringConnectionAccepterAccepter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_remote_vpc_dns_resolution: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool allow_remote_vpc_dns_resolution: Indicates whether a local VPC can resolve public DNS hostnames to
               private IP addresses when queried from instances in a peer VPC.
        """
        if allow_remote_vpc_dns_resolution is not None:
            pulumi.set(__self__, "allow_remote_vpc_dns_resolution", allow_remote_vpc_dns_resolution)

    @_builtins.property
    @pulumi.getter(name="allowRemoteVpcDnsResolution")
    def allow_remote_vpc_dns_resolution(self) -> Optional[_builtins.bool]:
        """
        Indicates whether a local VPC can resolve public DNS hostnames to
        private IP addresses when queried from instances in a peer VPC.
        """
        return pulumi.get(self, "allow_remote_vpc_dns_resolution")


@pulumi.output_type
class VpcPeeringConnectionAccepterRequester(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowRemoteVpcDnsResolution":
            suggest = "allow_remote_vpc_dns_resolution"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcPeeringConnectionAccepterRequester. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcPeeringConnectionAccepterRequester.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcPeeringConnectionAccepterRequester.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_remote_vpc_dns_resolution: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool allow_remote_vpc_dns_resolution: Indicates whether a local VPC can resolve public DNS hostnames to
               private IP addresses when queried from instances in a peer VPC.
        """
        if allow_remote_vpc_dns_resolution is not None:
            pulumi.set(__self__, "allow_remote_vpc_dns_resolution", allow_remote_vpc_dns_resolution)

    @_builtins.property
    @pulumi.getter(name="allowRemoteVpcDnsResolution")
    def allow_remote_vpc_dns_resolution(self) -> Optional[_builtins.bool]:
        """
        Indicates whether a local VPC can resolve public DNS hostnames to
        private IP addresses when queried from instances in a peer VPC.
        """
        return pulumi.get(self, "allow_remote_vpc_dns_resolution")


@pulumi.output_type
class VpcPeeringConnectionRequester(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowRemoteVpcDnsResolution":
            suggest = "allow_remote_vpc_dns_resolution"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcPeeringConnectionRequester. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcPeeringConnectionRequester.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcPeeringConnectionRequester.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_remote_vpc_dns_resolution: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool allow_remote_vpc_dns_resolution: Allow a local VPC to resolve public DNS hostnames to
               private IP addresses when queried from instances in the peer VPC.
        """
        if allow_remote_vpc_dns_resolution is not None:
            pulumi.set(__self__, "allow_remote_vpc_dns_resolution", allow_remote_vpc_dns_resolution)

    @_builtins.property
    @pulumi.getter(name="allowRemoteVpcDnsResolution")
    def allow_remote_vpc_dns_resolution(self) -> Optional[_builtins.bool]:
        """
        Allow a local VPC to resolve public DNS hostnames to
        private IP addresses when queried from instances in the peer VPC.
        """
        return pulumi.get(self, "allow_remote_vpc_dns_resolution")


@pulumi.output_type
class VpnConnectionRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationCidrBlock":
            suggest = "destination_cidr_block"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpnConnectionRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpnConnectionRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpnConnectionRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_cidr_block: Optional[_builtins.str] = None,
                 source: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str destination_cidr_block: The CIDR block associated with the local subnet of the customer data center.
        :param _builtins.str source: Indicates how the routes were provided.
        :param _builtins.str state: The current state of the static route.
        """
        if destination_cidr_block is not None:
            pulumi.set(__self__, "destination_cidr_block", destination_cidr_block)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="destinationCidrBlock")
    def destination_cidr_block(self) -> Optional[_builtins.str]:
        """
        The CIDR block associated with the local subnet of the customer data center.
        """
        return pulumi.get(self, "destination_cidr_block")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        """
        Indicates how the routes were provided.
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        The current state of the static route.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class VpnConnectionTunnel1LogOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudwatchLogOptions":
            suggest = "cloudwatch_log_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpnConnectionTunnel1LogOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpnConnectionTunnel1LogOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpnConnectionTunnel1LogOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloudwatch_log_options: Optional['outputs.VpnConnectionTunnel1LogOptionsCloudwatchLogOptions'] = None):
        """
        :param 'VpnConnectionTunnel1LogOptionsCloudwatchLogOptionsArgs' cloudwatch_log_options: Options for sending VPN tunnel logs to CloudWatch. See CloudWatch Log Options below for more details.
        """
        if cloudwatch_log_options is not None:
            pulumi.set(__self__, "cloudwatch_log_options", cloudwatch_log_options)

    @_builtins.property
    @pulumi.getter(name="cloudwatchLogOptions")
    def cloudwatch_log_options(self) -> Optional['outputs.VpnConnectionTunnel1LogOptionsCloudwatchLogOptions']:
        """
        Options for sending VPN tunnel logs to CloudWatch. See CloudWatch Log Options below for more details.
        """
        return pulumi.get(self, "cloudwatch_log_options")


@pulumi.output_type
class VpnConnectionTunnel1LogOptionsCloudwatchLogOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logEnabled":
            suggest = "log_enabled"
        elif key == "logGroupArn":
            suggest = "log_group_arn"
        elif key == "logOutputFormat":
            suggest = "log_output_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpnConnectionTunnel1LogOptionsCloudwatchLogOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpnConnectionTunnel1LogOptionsCloudwatchLogOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpnConnectionTunnel1LogOptionsCloudwatchLogOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_enabled: Optional[_builtins.bool] = None,
                 log_group_arn: Optional[_builtins.str] = None,
                 log_output_format: Optional[_builtins.str] = None):
        """
        :param _builtins.bool log_enabled: Enable or disable VPN tunnel logging feature. The default is `false`.
        :param _builtins.str log_group_arn: The Amazon Resource Name (ARN) of the CloudWatch log group to send logs to.
        :param _builtins.str log_output_format: Set log format. Default format is json. Possible values are: `json` and `text`. The default is `json`.
        """
        if log_enabled is not None:
            pulumi.set(__self__, "log_enabled", log_enabled)
        if log_group_arn is not None:
            pulumi.set(__self__, "log_group_arn", log_group_arn)
        if log_output_format is not None:
            pulumi.set(__self__, "log_output_format", log_output_format)

    @_builtins.property
    @pulumi.getter(name="logEnabled")
    def log_enabled(self) -> Optional[_builtins.bool]:
        """
        Enable or disable VPN tunnel logging feature. The default is `false`.
        """
        return pulumi.get(self, "log_enabled")

    @_builtins.property
    @pulumi.getter(name="logGroupArn")
    def log_group_arn(self) -> Optional[_builtins.str]:
        """
        The Amazon Resource Name (ARN) of the CloudWatch log group to send logs to.
        """
        return pulumi.get(self, "log_group_arn")

    @_builtins.property
    @pulumi.getter(name="logOutputFormat")
    def log_output_format(self) -> Optional[_builtins.str]:
        """
        Set log format. Default format is json. Possible values are: `json` and `text`. The default is `json`.
        """
        return pulumi.get(self, "log_output_format")


@pulumi.output_type
class VpnConnectionTunnel2LogOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudwatchLogOptions":
            suggest = "cloudwatch_log_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpnConnectionTunnel2LogOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpnConnectionTunnel2LogOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpnConnectionTunnel2LogOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloudwatch_log_options: Optional['outputs.VpnConnectionTunnel2LogOptionsCloudwatchLogOptions'] = None):
        """
        :param 'VpnConnectionTunnel2LogOptionsCloudwatchLogOptionsArgs' cloudwatch_log_options: Options for sending VPN tunnel logs to CloudWatch. See CloudWatch Log Options below for more details.
        """
        if cloudwatch_log_options is not None:
            pulumi.set(__self__, "cloudwatch_log_options", cloudwatch_log_options)

    @_builtins.property
    @pulumi.getter(name="cloudwatchLogOptions")
    def cloudwatch_log_options(self) -> Optional['outputs.VpnConnectionTunnel2LogOptionsCloudwatchLogOptions']:
        """
        Options for sending VPN tunnel logs to CloudWatch. See CloudWatch Log Options below for more details.
        """
        return pulumi.get(self, "cloudwatch_log_options")


@pulumi.output_type
class VpnConnectionTunnel2LogOptionsCloudwatchLogOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logEnabled":
            suggest = "log_enabled"
        elif key == "logGroupArn":
            suggest = "log_group_arn"
        elif key == "logOutputFormat":
            suggest = "log_output_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpnConnectionTunnel2LogOptionsCloudwatchLogOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpnConnectionTunnel2LogOptionsCloudwatchLogOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpnConnectionTunnel2LogOptionsCloudwatchLogOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_enabled: Optional[_builtins.bool] = None,
                 log_group_arn: Optional[_builtins.str] = None,
                 log_output_format: Optional[_builtins.str] = None):
        """
        :param _builtins.bool log_enabled: Enable or disable VPN tunnel logging feature. The default is `false`.
        :param _builtins.str log_group_arn: The Amazon Resource Name (ARN) of the CloudWatch log group to send logs to.
        :param _builtins.str log_output_format: Set log format. Default format is json. Possible values are: `json` and `text`. The default is `json`.
        """
        if log_enabled is not None:
            pulumi.set(__self__, "log_enabled", log_enabled)
        if log_group_arn is not None:
            pulumi.set(__self__, "log_group_arn", log_group_arn)
        if log_output_format is not None:
            pulumi.set(__self__, "log_output_format", log_output_format)

    @_builtins.property
    @pulumi.getter(name="logEnabled")
    def log_enabled(self) -> Optional[_builtins.bool]:
        """
        Enable or disable VPN tunnel logging feature. The default is `false`.
        """
        return pulumi.get(self, "log_enabled")

    @_builtins.property
    @pulumi.getter(name="logGroupArn")
    def log_group_arn(self) -> Optional[_builtins.str]:
        """
        The Amazon Resource Name (ARN) of the CloudWatch log group to send logs to.
        """
        return pulumi.get(self, "log_group_arn")

    @_builtins.property
    @pulumi.getter(name="logOutputFormat")
    def log_output_format(self) -> Optional[_builtins.str]:
        """
        Set log format. Default format is json. Possible values are: `json` and `text`. The default is `json`.
        """
        return pulumi.get(self, "log_output_format")


@pulumi.output_type
class VpnConnectionVgwTelemetry(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acceptedRouteCount":
            suggest = "accepted_route_count"
        elif key == "certificateArn":
            suggest = "certificate_arn"
        elif key == "lastStatusChange":
            suggest = "last_status_change"
        elif key == "outsideIpAddress":
            suggest = "outside_ip_address"
        elif key == "statusMessage":
            suggest = "status_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpnConnectionVgwTelemetry. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpnConnectionVgwTelemetry.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpnConnectionVgwTelemetry.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 accepted_route_count: Optional[_builtins.int] = None,
                 certificate_arn: Optional[_builtins.str] = None,
                 last_status_change: Optional[_builtins.str] = None,
                 outside_ip_address: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None,
                 status_message: Optional[_builtins.str] = None):
        """
        :param _builtins.int accepted_route_count: The number of accepted routes.
        :param _builtins.str certificate_arn: The Amazon Resource Name (ARN) of the VPN tunnel endpoint certificate.
        :param _builtins.str last_status_change: The date and time of the last change in status.
        :param _builtins.str outside_ip_address: The Internet-routable IP address of the virtual private gateway's outside interface.
        :param _builtins.str status: The status of the VPN tunnel.
        :param _builtins.str status_message: If an error occurs, a description of the error.
        """
        if accepted_route_count is not None:
            pulumi.set(__self__, "accepted_route_count", accepted_route_count)
        if certificate_arn is not None:
            pulumi.set(__self__, "certificate_arn", certificate_arn)
        if last_status_change is not None:
            pulumi.set(__self__, "last_status_change", last_status_change)
        if outside_ip_address is not None:
            pulumi.set(__self__, "outside_ip_address", outside_ip_address)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if status_message is not None:
            pulumi.set(__self__, "status_message", status_message)

    @_builtins.property
    @pulumi.getter(name="acceptedRouteCount")
    def accepted_route_count(self) -> Optional[_builtins.int]:
        """
        The number of accepted routes.
        """
        return pulumi.get(self, "accepted_route_count")

    @_builtins.property
    @pulumi.getter(name="certificateArn")
    def certificate_arn(self) -> Optional[_builtins.str]:
        """
        The Amazon Resource Name (ARN) of the VPN tunnel endpoint certificate.
        """
        return pulumi.get(self, "certificate_arn")

    @_builtins.property
    @pulumi.getter(name="lastStatusChange")
    def last_status_change(self) -> Optional[_builtins.str]:
        """
        The date and time of the last change in status.
        """
        return pulumi.get(self, "last_status_change")

    @_builtins.property
    @pulumi.getter(name="outsideIpAddress")
    def outside_ip_address(self) -> Optional[_builtins.str]:
        """
        The Internet-routable IP address of the virtual private gateway's outside interface.
        """
        return pulumi.get(self, "outside_ip_address")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        The status of the VPN tunnel.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="statusMessage")
    def status_message(self) -> Optional[_builtins.str]:
        """
        If an error occurs, a description of the error.
        """
        return pulumi.get(self, "status_message")


@pulumi.output_type
class GetAmiBlockDeviceMappingResult(dict):
    def __init__(__self__, *,
                 device_name: _builtins.str,
                 ebs: Mapping[str, _builtins.str],
                 no_device: _builtins.str,
                 virtual_name: _builtins.str):
        """
        :param _builtins.str device_name: Physical name of the device.
        :param Mapping[str, _builtins.str] ebs: Map containing EBS information, if the device is EBS based. Unlike most object attributes, these are accessed directly (e.g., `ebs.volume_size` or `ebs["volume_size"]`) rather than accessed through the first element of a list (e.g., `ebs[0].volume_size`).
        :param _builtins.str no_device: Suppresses the specified device included in the block device mapping of the AMI.
        :param _builtins.str virtual_name: Virtual device name (for instance stores).
        """
        pulumi.set(__self__, "device_name", device_name)
        pulumi.set(__self__, "ebs", ebs)
        pulumi.set(__self__, "no_device", no_device)
        pulumi.set(__self__, "virtual_name", virtual_name)

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> _builtins.str:
        """
        Physical name of the device.
        """
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter
    def ebs(self) -> Mapping[str, _builtins.str]:
        """
        Map containing EBS information, if the device is EBS based. Unlike most object attributes, these are accessed directly (e.g., `ebs.volume_size` or `ebs["volume_size"]`) rather than accessed through the first element of a list (e.g., `ebs[0].volume_size`).
        """
        return pulumi.get(self, "ebs")

    @_builtins.property
    @pulumi.getter(name="noDevice")
    def no_device(self) -> _builtins.str:
        """
        Suppresses the specified device included in the block device mapping of the AMI.
        """
        return pulumi.get(self, "no_device")

    @_builtins.property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> _builtins.str:
        """
        Virtual device name (for instance stores).
        """
        return pulumi.get(self, "virtual_name")


@pulumi.output_type
class GetAmiFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Name of the AMI that was provided during image creation.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the AMI that was provided during image creation.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetAmiIdsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetAmiProductCodeResult(dict):
    def __init__(__self__, *,
                 product_code_id: _builtins.str,
                 product_code_type: _builtins.str):
        pulumi.set(__self__, "product_code_id", product_code_id)
        pulumi.set(__self__, "product_code_type", product_code_type)

    @_builtins.property
    @pulumi.getter(name="productCodeId")
    def product_code_id(self) -> _builtins.str:
        return pulumi.get(self, "product_code_id")

    @_builtins.property
    @pulumi.getter(name="productCodeType")
    def product_code_type(self) -> _builtins.str:
        return pulumi.get(self, "product_code_type")


@pulumi.output_type
class GetCoipPoolFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Name of the field to filter by, as defined by
               [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeCoipPools.html).
        :param Sequence[_builtins.str] values: Set of values that are accepted for the given field.
               A COIP Pool will be selected if any one of the given values matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the field to filter by, as defined by
        [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeCoipPools.html).
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Set of values that are accepted for the given field.
        A COIP Pool will be selected if any one of the given values matches.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCoipPoolsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Name of the field to filter by, as defined by
               [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeCoipPools.html).
        :param Sequence[_builtins.str] values: Set of values that are accepted for the given field.
               A COIP Pool will be selected if any one of the given values matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the field to filter by, as defined by
        [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeCoipPools.html).
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Set of values that are accepted for the given field.
        A COIP Pool will be selected if any one of the given values matches.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCustomerGatewayFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetDedicatedHostFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Name of the field to filter by, as defined by [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeHosts.html).
        :param Sequence[_builtins.str] values: Set of values that are accepted for the given field. A host will be selected if any one of the given values matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the field to filter by, as defined by [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeHosts.html).
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Set of values that are accepted for the given field. A host will be selected if any one of the given values matches.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetEipsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Name of the field to filter by, as defined by
               [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeAddresses.html).
        :param Sequence[_builtins.str] values: Set of values that are accepted for the given field. An Elastic IP will be selected if any one of the given values matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the field to filter by, as defined by
        [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeAddresses.html).
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Set of values that are accepted for the given field. An Elastic IP will be selected if any one of the given values matches.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetElasticIpFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetInstanceCreditSpecificationResult(dict):
    def __init__(__self__, *,
                 cpu_credits: _builtins.str):
        pulumi.set(__self__, "cpu_credits", cpu_credits)

    @_builtins.property
    @pulumi.getter(name="cpuCredits")
    def cpu_credits(self) -> _builtins.str:
        return pulumi.get(self, "cpu_credits")


@pulumi.output_type
class GetInstanceEbsBlockDeviceResult(dict):
    def __init__(__self__, *,
                 delete_on_termination: _builtins.bool,
                 device_name: _builtins.str,
                 encrypted: _builtins.bool,
                 iops: _builtins.int,
                 kms_key_id: _builtins.str,
                 snapshot_id: _builtins.str,
                 tags: Mapping[str, _builtins.str],
                 throughput: _builtins.int,
                 volume_id: _builtins.str,
                 volume_size: _builtins.int,
                 volume_type: _builtins.str):
        """
        :param _builtins.bool delete_on_termination: If the root block device will be deleted on termination.
        :param _builtins.str device_name: Physical name of the device.
        :param _builtins.bool encrypted: If the EBS volume is encrypted.
        :param _builtins.int iops: `0` If the volume is not a provisioned IOPS image, otherwise the supported IOPS count.
        :param _builtins.str snapshot_id: ID of the snapshot.
        :param Mapping[str, _builtins.str] tags: Map of tags assigned to the Instance.
        :param _builtins.int throughput: Throughput of the volume, in MiB/s.
        :param _builtins.int volume_size: Size of the volume, in GiB.
        :param _builtins.str volume_type: Type of the volume.
        """
        pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        pulumi.set(__self__, "device_name", device_name)
        pulumi.set(__self__, "encrypted", encrypted)
        pulumi.set(__self__, "iops", iops)
        pulumi.set(__self__, "kms_key_id", kms_key_id)
        pulumi.set(__self__, "snapshot_id", snapshot_id)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "throughput", throughput)
        pulumi.set(__self__, "volume_id", volume_id)
        pulumi.set(__self__, "volume_size", volume_size)
        pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> _builtins.bool:
        """
        If the root block device will be deleted on termination.
        """
        return pulumi.get(self, "delete_on_termination")

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> _builtins.str:
        """
        Physical name of the device.
        """
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter
    def encrypted(self) -> _builtins.bool:
        """
        If the EBS volume is encrypted.
        """
        return pulumi.get(self, "encrypted")

    @_builtins.property
    @pulumi.getter
    def iops(self) -> _builtins.int:
        """
        `0` If the volume is not a provisioned IOPS image, otherwise the supported IOPS count.
        """
        return pulumi.get(self, "iops")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> _builtins.str:
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> _builtins.str:
        """
        ID of the snapshot.
        """
        return pulumi.get(self, "snapshot_id")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Mapping[str, _builtins.str]:
        """
        Map of tags assigned to the Instance.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def throughput(self) -> _builtins.int:
        """
        Throughput of the volume, in MiB/s.
        """
        return pulumi.get(self, "throughput")

    @_builtins.property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> _builtins.str:
        return pulumi.get(self, "volume_id")

    @_builtins.property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> _builtins.int:
        """
        Size of the volume, in GiB.
        """
        return pulumi.get(self, "volume_size")

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> _builtins.str:
        """
        Type of the volume.
        """
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class GetInstanceEnclaveOptionResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool):
        """
        :param _builtins.bool enabled: Whether Nitro Enclaves are enabled.
        """
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Whether Nitro Enclaves are enabled.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetInstanceEphemeralBlockDeviceResult(dict):
    def __init__(__self__, *,
                 device_name: _builtins.str,
                 no_device: Optional[_builtins.bool] = None,
                 virtual_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str device_name: Physical name of the device.
        :param _builtins.bool no_device: Whether the specified device included in the device mapping was suppressed or not (Boolean).
        :param _builtins.str virtual_name: Virtual device name.
        """
        pulumi.set(__self__, "device_name", device_name)
        if no_device is not None:
            pulumi.set(__self__, "no_device", no_device)
        if virtual_name is not None:
            pulumi.set(__self__, "virtual_name", virtual_name)

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> _builtins.str:
        """
        Physical name of the device.
        """
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter(name="noDevice")
    def no_device(self) -> Optional[_builtins.bool]:
        """
        Whether the specified device included in the device mapping was suppressed or not (Boolean).
        """
        return pulumi.get(self, "no_device")

    @_builtins.property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> Optional[_builtins.str]:
        """
        Virtual device name.
        """
        return pulumi.get(self, "virtual_name")


@pulumi.output_type
class GetInstanceFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetInstanceMaintenanceOptionResult(dict):
    def __init__(__self__, *,
                 auto_recovery: _builtins.str):
        """
        :param _builtins.str auto_recovery: Automatic recovery behavior of the instance.
        """
        pulumi.set(__self__, "auto_recovery", auto_recovery)

    @_builtins.property
    @pulumi.getter(name="autoRecovery")
    def auto_recovery(self) -> _builtins.str:
        """
        Automatic recovery behavior of the instance.
        """
        return pulumi.get(self, "auto_recovery")


@pulumi.output_type
class GetInstanceMetadataOptionResult(dict):
    def __init__(__self__, *,
                 http_endpoint: _builtins.str,
                 http_protocol_ipv6: _builtins.str,
                 http_put_response_hop_limit: _builtins.int,
                 http_tokens: _builtins.str,
                 instance_metadata_tags: _builtins.str):
        """
        :param _builtins.str http_endpoint: State of the metadata service: `enabled`, `disabled`.
        :param _builtins.str http_protocol_ipv6: Whether the IPv6 endpoint for the instance metadata service is `enabled` or `disabled`
        :param _builtins.int http_put_response_hop_limit: Desired HTTP PUT response hop limit for instance metadata requests.
        :param _builtins.str http_tokens: If session tokens are required: `optional`, `required`.
        :param _builtins.str instance_metadata_tags: If access to instance tags is allowed from the metadata service: `enabled`, `disabled`.
        """
        pulumi.set(__self__, "http_endpoint", http_endpoint)
        pulumi.set(__self__, "http_protocol_ipv6", http_protocol_ipv6)
        pulumi.set(__self__, "http_put_response_hop_limit", http_put_response_hop_limit)
        pulumi.set(__self__, "http_tokens", http_tokens)
        pulumi.set(__self__, "instance_metadata_tags", instance_metadata_tags)

    @_builtins.property
    @pulumi.getter(name="httpEndpoint")
    def http_endpoint(self) -> _builtins.str:
        """
        State of the metadata service: `enabled`, `disabled`.
        """
        return pulumi.get(self, "http_endpoint")

    @_builtins.property
    @pulumi.getter(name="httpProtocolIpv6")
    def http_protocol_ipv6(self) -> _builtins.str:
        """
        Whether the IPv6 endpoint for the instance metadata service is `enabled` or `disabled`
        """
        return pulumi.get(self, "http_protocol_ipv6")

    @_builtins.property
    @pulumi.getter(name="httpPutResponseHopLimit")
    def http_put_response_hop_limit(self) -> _builtins.int:
        """
        Desired HTTP PUT response hop limit for instance metadata requests.
        """
        return pulumi.get(self, "http_put_response_hop_limit")

    @_builtins.property
    @pulumi.getter(name="httpTokens")
    def http_tokens(self) -> _builtins.str:
        """
        If session tokens are required: `optional`, `required`.
        """
        return pulumi.get(self, "http_tokens")

    @_builtins.property
    @pulumi.getter(name="instanceMetadataTags")
    def instance_metadata_tags(self) -> _builtins.str:
        """
        If access to instance tags is allowed from the metadata service: `enabled`, `disabled`.
        """
        return pulumi.get(self, "instance_metadata_tags")


@pulumi.output_type
class GetInstancePrivateDnsNameOptionResult(dict):
    def __init__(__self__, *,
                 enable_resource_name_dns_a_record: _builtins.bool,
                 enable_resource_name_dns_aaaa_record: _builtins.bool,
                 hostname_type: _builtins.str):
        """
        :param _builtins.bool enable_resource_name_dns_a_record: Indicates whether to respond to DNS queries for instance hostnames with DNS A records.
        :param _builtins.bool enable_resource_name_dns_aaaa_record: Indicates whether to respond to DNS queries for instance hostnames with DNS AAAA records.
        :param _builtins.str hostname_type: Type of hostname for EC2 instances.
        """
        pulumi.set(__self__, "enable_resource_name_dns_a_record", enable_resource_name_dns_a_record)
        pulumi.set(__self__, "enable_resource_name_dns_aaaa_record", enable_resource_name_dns_aaaa_record)
        pulumi.set(__self__, "hostname_type", hostname_type)

    @_builtins.property
    @pulumi.getter(name="enableResourceNameDnsARecord")
    def enable_resource_name_dns_a_record(self) -> _builtins.bool:
        """
        Indicates whether to respond to DNS queries for instance hostnames with DNS A records.
        """
        return pulumi.get(self, "enable_resource_name_dns_a_record")

    @_builtins.property
    @pulumi.getter(name="enableResourceNameDnsAaaaRecord")
    def enable_resource_name_dns_aaaa_record(self) -> _builtins.bool:
        """
        Indicates whether to respond to DNS queries for instance hostnames with DNS AAAA records.
        """
        return pulumi.get(self, "enable_resource_name_dns_aaaa_record")

    @_builtins.property
    @pulumi.getter(name="hostnameType")
    def hostname_type(self) -> _builtins.str:
        """
        Type of hostname for EC2 instances.
        """
        return pulumi.get(self, "hostname_type")


@pulumi.output_type
class GetInstanceRootBlockDeviceResult(dict):
    def __init__(__self__, *,
                 delete_on_termination: _builtins.bool,
                 device_name: _builtins.str,
                 encrypted: _builtins.bool,
                 iops: _builtins.int,
                 kms_key_id: _builtins.str,
                 tags: Mapping[str, _builtins.str],
                 throughput: _builtins.int,
                 volume_id: _builtins.str,
                 volume_size: _builtins.int,
                 volume_type: _builtins.str):
        """
        :param _builtins.bool delete_on_termination: If the root block device will be deleted on termination.
        :param _builtins.str device_name: Physical name of the device.
        :param _builtins.bool encrypted: If the EBS volume is encrypted.
        :param _builtins.int iops: `0` If the volume is not a provisioned IOPS image, otherwise the supported IOPS count.
        :param Mapping[str, _builtins.str] tags: Map of tags assigned to the Instance.
        :param _builtins.int throughput: Throughput of the volume, in MiB/s.
        :param _builtins.int volume_size: Size of the volume, in GiB.
        :param _builtins.str volume_type: Type of the volume.
        """
        pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        pulumi.set(__self__, "device_name", device_name)
        pulumi.set(__self__, "encrypted", encrypted)
        pulumi.set(__self__, "iops", iops)
        pulumi.set(__self__, "kms_key_id", kms_key_id)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "throughput", throughput)
        pulumi.set(__self__, "volume_id", volume_id)
        pulumi.set(__self__, "volume_size", volume_size)
        pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> _builtins.bool:
        """
        If the root block device will be deleted on termination.
        """
        return pulumi.get(self, "delete_on_termination")

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> _builtins.str:
        """
        Physical name of the device.
        """
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter
    def encrypted(self) -> _builtins.bool:
        """
        If the EBS volume is encrypted.
        """
        return pulumi.get(self, "encrypted")

    @_builtins.property
    @pulumi.getter
    def iops(self) -> _builtins.int:
        """
        `0` If the volume is not a provisioned IOPS image, otherwise the supported IOPS count.
        """
        return pulumi.get(self, "iops")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> _builtins.str:
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Mapping[str, _builtins.str]:
        """
        Map of tags assigned to the Instance.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def throughput(self) -> _builtins.int:
        """
        Throughput of the volume, in MiB/s.
        """
        return pulumi.get(self, "throughput")

    @_builtins.property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> _builtins.str:
        return pulumi.get(self, "volume_id")

    @_builtins.property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> _builtins.int:
        """
        Size of the volume, in GiB.
        """
        return pulumi.get(self, "volume_size")

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> _builtins.str:
        """
        Type of the volume.
        """
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class GetInstanceTypeFpgaResult(dict):
    def __init__(__self__, *,
                 count: _builtins.int,
                 manufacturer: _builtins.str,
                 memory_size: _builtins.int,
                 name: _builtins.str):
        """
        :param _builtins.int memory_size: Size of the instance memory, in MiB.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "manufacturer", manufacturer)
        pulumi.set(__self__, "memory_size", memory_size)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def count(self) -> _builtins.int:
        return pulumi.get(self, "count")

    @_builtins.property
    @pulumi.getter
    def manufacturer(self) -> _builtins.str:
        return pulumi.get(self, "manufacturer")

    @_builtins.property
    @pulumi.getter(name="memorySize")
    def memory_size(self) -> _builtins.int:
        """
        Size of the instance memory, in MiB.
        """
        return pulumi.get(self, "memory_size")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetInstanceTypeGpusResult(dict):
    def __init__(__self__, *,
                 count: _builtins.int,
                 manufacturer: _builtins.str,
                 memory_size: _builtins.int,
                 name: _builtins.str):
        """
        :param _builtins.int memory_size: Size of the instance memory, in MiB.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "manufacturer", manufacturer)
        pulumi.set(__self__, "memory_size", memory_size)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def count(self) -> _builtins.int:
        return pulumi.get(self, "count")

    @_builtins.property
    @pulumi.getter
    def manufacturer(self) -> _builtins.str:
        return pulumi.get(self, "manufacturer")

    @_builtins.property
    @pulumi.getter(name="memorySize")
    def memory_size(self) -> _builtins.int:
        """
        Size of the instance memory, in MiB.
        """
        return pulumi.get(self, "memory_size")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetInstanceTypeInferenceAcceleratorResult(dict):
    def __init__(__self__, *,
                 count: _builtins.int,
                 manufacturer: _builtins.str,
                 memory_size: _builtins.int,
                 name: _builtins.str):
        """
        :param _builtins.int memory_size: Size of the instance memory, in MiB.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "manufacturer", manufacturer)
        pulumi.set(__self__, "memory_size", memory_size)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def count(self) -> _builtins.int:
        return pulumi.get(self, "count")

    @_builtins.property
    @pulumi.getter
    def manufacturer(self) -> _builtins.str:
        return pulumi.get(self, "manufacturer")

    @_builtins.property
    @pulumi.getter(name="memorySize")
    def memory_size(self) -> _builtins.int:
        """
        Size of the instance memory, in MiB.
        """
        return pulumi.get(self, "memory_size")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetInstanceTypeInstanceDiskResult(dict):
    def __init__(__self__, *,
                 count: _builtins.int,
                 size: _builtins.int,
                 type: _builtins.str):
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def count(self) -> _builtins.int:
        return pulumi.get(self, "count")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.int:
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetInstanceTypeMediaAcceleratorResult(dict):
    def __init__(__self__, *,
                 count: _builtins.int,
                 manufacturer: _builtins.str,
                 memory_size: _builtins.int,
                 name: _builtins.str):
        """
        :param _builtins.int memory_size: Size of the instance memory, in MiB.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "manufacturer", manufacturer)
        pulumi.set(__self__, "memory_size", memory_size)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def count(self) -> _builtins.int:
        return pulumi.get(self, "count")

    @_builtins.property
    @pulumi.getter
    def manufacturer(self) -> _builtins.str:
        return pulumi.get(self, "manufacturer")

    @_builtins.property
    @pulumi.getter(name="memorySize")
    def memory_size(self) -> _builtins.int:
        """
        Size of the instance memory, in MiB.
        """
        return pulumi.get(self, "memory_size")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetInstanceTypeNetworkCardResult(dict):
    def __init__(__self__, *,
                 baseline_bandwidth: _builtins.float,
                 index: _builtins.int,
                 maximum_interfaces: _builtins.int,
                 peak_bandwidth: _builtins.float,
                 performance: _builtins.str):
        pulumi.set(__self__, "baseline_bandwidth", baseline_bandwidth)
        pulumi.set(__self__, "index", index)
        pulumi.set(__self__, "maximum_interfaces", maximum_interfaces)
        pulumi.set(__self__, "peak_bandwidth", peak_bandwidth)
        pulumi.set(__self__, "performance", performance)

    @_builtins.property
    @pulumi.getter(name="baselineBandwidth")
    def baseline_bandwidth(self) -> _builtins.float:
        return pulumi.get(self, "baseline_bandwidth")

    @_builtins.property
    @pulumi.getter
    def index(self) -> _builtins.int:
        return pulumi.get(self, "index")

    @_builtins.property
    @pulumi.getter(name="maximumInterfaces")
    def maximum_interfaces(self) -> _builtins.int:
        return pulumi.get(self, "maximum_interfaces")

    @_builtins.property
    @pulumi.getter(name="peakBandwidth")
    def peak_bandwidth(self) -> _builtins.float:
        return pulumi.get(self, "peak_bandwidth")

    @_builtins.property
    @pulumi.getter
    def performance(self) -> _builtins.str:
        return pulumi.get(self, "performance")


@pulumi.output_type
class GetInstanceTypeNeuronDeviceResult(dict):
    def __init__(__self__, *,
                 core_count: _builtins.int,
                 core_version: _builtins.int,
                 count: _builtins.int,
                 memory_size: _builtins.int,
                 name: _builtins.str):
        """
        :param _builtins.int memory_size: Size of the instance memory, in MiB.
        """
        pulumi.set(__self__, "core_count", core_count)
        pulumi.set(__self__, "core_version", core_version)
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "memory_size", memory_size)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="coreCount")
    def core_count(self) -> _builtins.int:
        return pulumi.get(self, "core_count")

    @_builtins.property
    @pulumi.getter(name="coreVersion")
    def core_version(self) -> _builtins.int:
        return pulumi.get(self, "core_version")

    @_builtins.property
    @pulumi.getter
    def count(self) -> _builtins.int:
        return pulumi.get(self, "count")

    @_builtins.property
    @pulumi.getter(name="memorySize")
    def memory_size(self) -> _builtins.int:
        """
        Size of the instance memory, in MiB.
        """
        return pulumi.get(self, "memory_size")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetInstanceTypeOfferingFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Name of the filter. The `location` filter depends on the top-level `location_type` argument and if not specified, defaults to the current region.
        :param Sequence[_builtins.str] values: List of one or more values for the filter.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the filter. The `location` filter depends on the top-level `location_type` argument and if not specified, defaults to the current region.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        List of one or more values for the filter.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetInstanceTypeOfferingsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Name of the filter. The `location` filter depends on the top-level `location_type` argument and if not specified, defaults to the current region.
        :param Sequence[_builtins.str] values: List of one or more values for the filter.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the filter. The `location` filter depends on the top-level `location_type` argument and if not specified, defaults to the current region.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        List of one or more values for the filter.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetInstanceTypesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Name of the filter.
        :param Sequence[_builtins.str] values: List of one or more values for the filter.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the filter.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        List of one or more values for the filter.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetInstancesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetInternetGatewayAttachmentResult(dict):
    def __init__(__self__, *,
                 state: _builtins.str,
                 vpc_id: _builtins.str):
        """
        :param _builtins.str state: Current state of the attachment between the gateway and the VPC. Present only if a VPC is attached
        :param _builtins.str vpc_id: ID of an attached VPC.
        """
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "vpc_id", vpc_id)

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        Current state of the attachment between the gateway and the VPC. Present only if a VPC is attached
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> _builtins.str:
        """
        ID of an attached VPC.
        """
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class GetInternetGatewayFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Name of the field to filter by, as defined by
               [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeInternetGateways.html).
        :param Sequence[_builtins.str] values: Set of values that are accepted for the given field.
               An Internet Gateway will be selected if any one of the given values matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the field to filter by, as defined by
        [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeInternetGateways.html).
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Set of values that are accepted for the given field.
        An Internet Gateway will be selected if any one of the given values matches.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetKeyPairFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Name of the filter field. Valid values can be found in the [EC2 DescribeKeyPairs API Reference](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeKeyPairs.html).
        :param Sequence[_builtins.str] values: Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the filter field. Valid values can be found in the [EC2 DescribeKeyPairs API Reference](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeKeyPairs.html).
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetLaunchConfigurationEbsBlockDeviceResult(dict):
    def __init__(__self__, *,
                 delete_on_termination: _builtins.bool,
                 device_name: _builtins.str,
                 encrypted: _builtins.bool,
                 iops: _builtins.int,
                 no_device: _builtins.bool,
                 snapshot_id: _builtins.str,
                 throughput: _builtins.int,
                 volume_size: _builtins.int,
                 volume_type: _builtins.str):
        """
        :param _builtins.bool delete_on_termination: Whether the EBS Volume will be deleted on instance termination.
        :param _builtins.str device_name: Name of the device.
        :param _builtins.bool encrypted: Whether the volume is Encrypted.
        :param _builtins.int iops: Provisioned IOPs of the volume.
        :param _builtins.bool no_device: Whether the device in the block device mapping of the AMI is suppressed.
        :param _builtins.str snapshot_id: Snapshot ID of the mount.
        :param _builtins.int throughput: Throughput of the volume.
        :param _builtins.int volume_size: Size of the volume.
        :param _builtins.str volume_type: Type of the volume.
        """
        pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        pulumi.set(__self__, "device_name", device_name)
        pulumi.set(__self__, "encrypted", encrypted)
        pulumi.set(__self__, "iops", iops)
        pulumi.set(__self__, "no_device", no_device)
        pulumi.set(__self__, "snapshot_id", snapshot_id)
        pulumi.set(__self__, "throughput", throughput)
        pulumi.set(__self__, "volume_size", volume_size)
        pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> _builtins.bool:
        """
        Whether the EBS Volume will be deleted on instance termination.
        """
        return pulumi.get(self, "delete_on_termination")

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> _builtins.str:
        """
        Name of the device.
        """
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter
    def encrypted(self) -> _builtins.bool:
        """
        Whether the volume is Encrypted.
        """
        return pulumi.get(self, "encrypted")

    @_builtins.property
    @pulumi.getter
    def iops(self) -> _builtins.int:
        """
        Provisioned IOPs of the volume.
        """
        return pulumi.get(self, "iops")

    @_builtins.property
    @pulumi.getter(name="noDevice")
    def no_device(self) -> _builtins.bool:
        """
        Whether the device in the block device mapping of the AMI is suppressed.
        """
        return pulumi.get(self, "no_device")

    @_builtins.property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> _builtins.str:
        """
        Snapshot ID of the mount.
        """
        return pulumi.get(self, "snapshot_id")

    @_builtins.property
    @pulumi.getter
    def throughput(self) -> _builtins.int:
        """
        Throughput of the volume.
        """
        return pulumi.get(self, "throughput")

    @_builtins.property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> _builtins.int:
        """
        Size of the volume.
        """
        return pulumi.get(self, "volume_size")

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> _builtins.str:
        """
        Type of the volume.
        """
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class GetLaunchConfigurationEphemeralBlockDeviceResult(dict):
    def __init__(__self__, *,
                 device_name: _builtins.str,
                 virtual_name: _builtins.str):
        """
        :param _builtins.str device_name: Name of the device.
        :param _builtins.str virtual_name: Virtual Name of the device.
        """
        pulumi.set(__self__, "device_name", device_name)
        pulumi.set(__self__, "virtual_name", virtual_name)

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> _builtins.str:
        """
        Name of the device.
        """
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> _builtins.str:
        """
        Virtual Name of the device.
        """
        return pulumi.get(self, "virtual_name")


@pulumi.output_type
class GetLaunchConfigurationMetadataOptionResult(dict):
    def __init__(__self__, *,
                 http_endpoint: _builtins.str,
                 http_put_response_hop_limit: _builtins.int,
                 http_tokens: _builtins.str):
        """
        :param _builtins.str http_endpoint: State of the metadata service: `enabled`, `disabled`.
        :param _builtins.int http_put_response_hop_limit: The desired HTTP PUT response hop limit for instance metadata requests.
        :param _builtins.str http_tokens: If session tokens are required: `optional`, `required`.
        """
        pulumi.set(__self__, "http_endpoint", http_endpoint)
        pulumi.set(__self__, "http_put_response_hop_limit", http_put_response_hop_limit)
        pulumi.set(__self__, "http_tokens", http_tokens)

    @_builtins.property
    @pulumi.getter(name="httpEndpoint")
    def http_endpoint(self) -> _builtins.str:
        """
        State of the metadata service: `enabled`, `disabled`.
        """
        return pulumi.get(self, "http_endpoint")

    @_builtins.property
    @pulumi.getter(name="httpPutResponseHopLimit")
    def http_put_response_hop_limit(self) -> _builtins.int:
        """
        The desired HTTP PUT response hop limit for instance metadata requests.
        """
        return pulumi.get(self, "http_put_response_hop_limit")

    @_builtins.property
    @pulumi.getter(name="httpTokens")
    def http_tokens(self) -> _builtins.str:
        """
        If session tokens are required: `optional`, `required`.
        """
        return pulumi.get(self, "http_tokens")


@pulumi.output_type
class GetLaunchConfigurationRootBlockDeviceResult(dict):
    def __init__(__self__, *,
                 delete_on_termination: _builtins.bool,
                 encrypted: _builtins.bool,
                 iops: _builtins.int,
                 throughput: _builtins.int,
                 volume_size: _builtins.int,
                 volume_type: _builtins.str):
        """
        :param _builtins.bool delete_on_termination: Whether the EBS Volume will be deleted on instance termination.
        :param _builtins.bool encrypted: Whether the volume is Encrypted.
        :param _builtins.int iops: Provisioned IOPs of the volume.
        :param _builtins.int throughput: Throughput of the volume.
        :param _builtins.int volume_size: Size of the volume.
        :param _builtins.str volume_type: Type of the volume.
        """
        pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        pulumi.set(__self__, "encrypted", encrypted)
        pulumi.set(__self__, "iops", iops)
        pulumi.set(__self__, "throughput", throughput)
        pulumi.set(__self__, "volume_size", volume_size)
        pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> _builtins.bool:
        """
        Whether the EBS Volume will be deleted on instance termination.
        """
        return pulumi.get(self, "delete_on_termination")

    @_builtins.property
    @pulumi.getter
    def encrypted(self) -> _builtins.bool:
        """
        Whether the volume is Encrypted.
        """
        return pulumi.get(self, "encrypted")

    @_builtins.property
    @pulumi.getter
    def iops(self) -> _builtins.int:
        """
        Provisioned IOPs of the volume.
        """
        return pulumi.get(self, "iops")

    @_builtins.property
    @pulumi.getter
    def throughput(self) -> _builtins.int:
        """
        Throughput of the volume.
        """
        return pulumi.get(self, "throughput")

    @_builtins.property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> _builtins.int:
        """
        Size of the volume.
        """
        return pulumi.get(self, "volume_size")

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> _builtins.str:
        """
        Type of the volume.
        """
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class GetLaunchTemplateBlockDeviceMappingResult(dict):
    def __init__(__self__, *,
                 device_name: _builtins.str,
                 ebs: Sequence['outputs.GetLaunchTemplateBlockDeviceMappingEbResult'],
                 no_device: _builtins.str,
                 virtual_name: _builtins.str):
        pulumi.set(__self__, "device_name", device_name)
        pulumi.set(__self__, "ebs", ebs)
        pulumi.set(__self__, "no_device", no_device)
        pulumi.set(__self__, "virtual_name", virtual_name)

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> _builtins.str:
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter
    def ebs(self) -> Sequence['outputs.GetLaunchTemplateBlockDeviceMappingEbResult']:
        return pulumi.get(self, "ebs")

    @_builtins.property
    @pulumi.getter(name="noDevice")
    def no_device(self) -> _builtins.str:
        return pulumi.get(self, "no_device")

    @_builtins.property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> _builtins.str:
        return pulumi.get(self, "virtual_name")


@pulumi.output_type
class GetLaunchTemplateBlockDeviceMappingEbResult(dict):
    def __init__(__self__, *,
                 delete_on_termination: _builtins.str,
                 encrypted: _builtins.str,
                 iops: _builtins.int,
                 kms_key_id: _builtins.str,
                 snapshot_id: _builtins.str,
                 throughput: _builtins.int,
                 volume_initialization_rate: _builtins.int,
                 volume_size: _builtins.int,
                 volume_type: _builtins.str):
        pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        pulumi.set(__self__, "encrypted", encrypted)
        pulumi.set(__self__, "iops", iops)
        pulumi.set(__self__, "kms_key_id", kms_key_id)
        pulumi.set(__self__, "snapshot_id", snapshot_id)
        pulumi.set(__self__, "throughput", throughput)
        pulumi.set(__self__, "volume_initialization_rate", volume_initialization_rate)
        pulumi.set(__self__, "volume_size", volume_size)
        pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> _builtins.str:
        return pulumi.get(self, "delete_on_termination")

    @_builtins.property
    @pulumi.getter
    def encrypted(self) -> _builtins.str:
        return pulumi.get(self, "encrypted")

    @_builtins.property
    @pulumi.getter
    def iops(self) -> _builtins.int:
        return pulumi.get(self, "iops")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> _builtins.str:
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> _builtins.str:
        return pulumi.get(self, "snapshot_id")

    @_builtins.property
    @pulumi.getter
    def throughput(self) -> _builtins.int:
        return pulumi.get(self, "throughput")

    @_builtins.property
    @pulumi.getter(name="volumeInitializationRate")
    def volume_initialization_rate(self) -> _builtins.int:
        return pulumi.get(self, "volume_initialization_rate")

    @_builtins.property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> _builtins.int:
        return pulumi.get(self, "volume_size")

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> _builtins.str:
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class GetLaunchTemplateCapacityReservationSpecificationResult(dict):
    def __init__(__self__, *,
                 capacity_reservation_preference: _builtins.str,
                 capacity_reservation_targets: Sequence['outputs.GetLaunchTemplateCapacityReservationSpecificationCapacityReservationTargetResult']):
        pulumi.set(__self__, "capacity_reservation_preference", capacity_reservation_preference)
        pulumi.set(__self__, "capacity_reservation_targets", capacity_reservation_targets)

    @_builtins.property
    @pulumi.getter(name="capacityReservationPreference")
    def capacity_reservation_preference(self) -> _builtins.str:
        return pulumi.get(self, "capacity_reservation_preference")

    @_builtins.property
    @pulumi.getter(name="capacityReservationTargets")
    def capacity_reservation_targets(self) -> Sequence['outputs.GetLaunchTemplateCapacityReservationSpecificationCapacityReservationTargetResult']:
        return pulumi.get(self, "capacity_reservation_targets")


@pulumi.output_type
class GetLaunchTemplateCapacityReservationSpecificationCapacityReservationTargetResult(dict):
    def __init__(__self__, *,
                 capacity_reservation_id: _builtins.str,
                 capacity_reservation_resource_group_arn: _builtins.str):
        pulumi.set(__self__, "capacity_reservation_id", capacity_reservation_id)
        pulumi.set(__self__, "capacity_reservation_resource_group_arn", capacity_reservation_resource_group_arn)

    @_builtins.property
    @pulumi.getter(name="capacityReservationId")
    def capacity_reservation_id(self) -> _builtins.str:
        return pulumi.get(self, "capacity_reservation_id")

    @_builtins.property
    @pulumi.getter(name="capacityReservationResourceGroupArn")
    def capacity_reservation_resource_group_arn(self) -> _builtins.str:
        return pulumi.get(self, "capacity_reservation_resource_group_arn")


@pulumi.output_type
class GetLaunchTemplateCpuOptionResult(dict):
    def __init__(__self__, *,
                 amd_sev_snp: _builtins.str,
                 core_count: _builtins.int,
                 threads_per_core: _builtins.int):
        pulumi.set(__self__, "amd_sev_snp", amd_sev_snp)
        pulumi.set(__self__, "core_count", core_count)
        pulumi.set(__self__, "threads_per_core", threads_per_core)

    @_builtins.property
    @pulumi.getter(name="amdSevSnp")
    def amd_sev_snp(self) -> _builtins.str:
        return pulumi.get(self, "amd_sev_snp")

    @_builtins.property
    @pulumi.getter(name="coreCount")
    def core_count(self) -> _builtins.int:
        return pulumi.get(self, "core_count")

    @_builtins.property
    @pulumi.getter(name="threadsPerCore")
    def threads_per_core(self) -> _builtins.int:
        return pulumi.get(self, "threads_per_core")


@pulumi.output_type
class GetLaunchTemplateCreditSpecificationResult(dict):
    def __init__(__self__, *,
                 cpu_credits: _builtins.str):
        pulumi.set(__self__, "cpu_credits", cpu_credits)

    @_builtins.property
    @pulumi.getter(name="cpuCredits")
    def cpu_credits(self) -> _builtins.str:
        return pulumi.get(self, "cpu_credits")


@pulumi.output_type
class GetLaunchTemplateEnclaveOptionResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool):
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetLaunchTemplateFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Name of the filter field. Valid values can be found in the [EC2 DescribeLaunchTemplates API Reference](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeLaunchTemplates.html).
        :param Sequence[_builtins.str] values: Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the filter field. Valid values can be found in the [EC2 DescribeLaunchTemplates API Reference](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeLaunchTemplates.html).
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetLaunchTemplateHibernationOptionResult(dict):
    def __init__(__self__, *,
                 configured: _builtins.bool):
        pulumi.set(__self__, "configured", configured)

    @_builtins.property
    @pulumi.getter
    def configured(self) -> _builtins.bool:
        return pulumi.get(self, "configured")


@pulumi.output_type
class GetLaunchTemplateIamInstanceProfileResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str name: Name of the launch template.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the launch template.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetLaunchTemplateInstanceMarketOptionResult(dict):
    def __init__(__self__, *,
                 market_type: _builtins.str,
                 spot_options: Sequence['outputs.GetLaunchTemplateInstanceMarketOptionSpotOptionResult']):
        pulumi.set(__self__, "market_type", market_type)
        pulumi.set(__self__, "spot_options", spot_options)

    @_builtins.property
    @pulumi.getter(name="marketType")
    def market_type(self) -> _builtins.str:
        return pulumi.get(self, "market_type")

    @_builtins.property
    @pulumi.getter(name="spotOptions")
    def spot_options(self) -> Sequence['outputs.GetLaunchTemplateInstanceMarketOptionSpotOptionResult']:
        return pulumi.get(self, "spot_options")


@pulumi.output_type
class GetLaunchTemplateInstanceMarketOptionSpotOptionResult(dict):
    def __init__(__self__, *,
                 block_duration_minutes: _builtins.int,
                 instance_interruption_behavior: _builtins.str,
                 max_price: _builtins.str,
                 spot_instance_type: _builtins.str,
                 valid_until: _builtins.str):
        pulumi.set(__self__, "block_duration_minutes", block_duration_minutes)
        pulumi.set(__self__, "instance_interruption_behavior", instance_interruption_behavior)
        pulumi.set(__self__, "max_price", max_price)
        pulumi.set(__self__, "spot_instance_type", spot_instance_type)
        pulumi.set(__self__, "valid_until", valid_until)

    @_builtins.property
    @pulumi.getter(name="blockDurationMinutes")
    def block_duration_minutes(self) -> _builtins.int:
        return pulumi.get(self, "block_duration_minutes")

    @_builtins.property
    @pulumi.getter(name="instanceInterruptionBehavior")
    def instance_interruption_behavior(self) -> _builtins.str:
        return pulumi.get(self, "instance_interruption_behavior")

    @_builtins.property
    @pulumi.getter(name="maxPrice")
    def max_price(self) -> _builtins.str:
        return pulumi.get(self, "max_price")

    @_builtins.property
    @pulumi.getter(name="spotInstanceType")
    def spot_instance_type(self) -> _builtins.str:
        return pulumi.get(self, "spot_instance_type")

    @_builtins.property
    @pulumi.getter(name="validUntil")
    def valid_until(self) -> _builtins.str:
        return pulumi.get(self, "valid_until")


@pulumi.output_type
class GetLaunchTemplateInstanceRequirementResult(dict):
    def __init__(__self__, *,
                 accelerator_counts: Sequence['outputs.GetLaunchTemplateInstanceRequirementAcceleratorCountResult'],
                 accelerator_manufacturers: Sequence[_builtins.str],
                 accelerator_names: Sequence[_builtins.str],
                 accelerator_total_memory_mibs: Sequence['outputs.GetLaunchTemplateInstanceRequirementAcceleratorTotalMemoryMibResult'],
                 accelerator_types: Sequence[_builtins.str],
                 allowed_instance_types: Sequence[_builtins.str],
                 bare_metal: _builtins.str,
                 baseline_ebs_bandwidth_mbps: Sequence['outputs.GetLaunchTemplateInstanceRequirementBaselineEbsBandwidthMbpResult'],
                 burstable_performance: _builtins.str,
                 cpu_manufacturers: Sequence[_builtins.str],
                 excluded_instance_types: Sequence[_builtins.str],
                 instance_generations: Sequence[_builtins.str],
                 local_storage: _builtins.str,
                 local_storage_types: Sequence[_builtins.str],
                 max_spot_price_as_percentage_of_optimal_on_demand_price: _builtins.int,
                 memory_gib_per_vcpus: Sequence['outputs.GetLaunchTemplateInstanceRequirementMemoryGibPerVcpusResult'],
                 memory_mibs: Sequence['outputs.GetLaunchTemplateInstanceRequirementMemoryMibResult'],
                 network_bandwidth_gbps: Sequence['outputs.GetLaunchTemplateInstanceRequirementNetworkBandwidthGbpResult'],
                 network_interface_counts: Sequence['outputs.GetLaunchTemplateInstanceRequirementNetworkInterfaceCountResult'],
                 on_demand_max_price_percentage_over_lowest_price: _builtins.int,
                 require_hibernate_support: _builtins.bool,
                 spot_max_price_percentage_over_lowest_price: _builtins.int,
                 total_local_storage_gbs: Sequence['outputs.GetLaunchTemplateInstanceRequirementTotalLocalStorageGbResult'],
                 vcpu_counts: Sequence['outputs.GetLaunchTemplateInstanceRequirementVcpuCountResult']):
        pulumi.set(__self__, "accelerator_counts", accelerator_counts)
        pulumi.set(__self__, "accelerator_manufacturers", accelerator_manufacturers)
        pulumi.set(__self__, "accelerator_names", accelerator_names)
        pulumi.set(__self__, "accelerator_total_memory_mibs", accelerator_total_memory_mibs)
        pulumi.set(__self__, "accelerator_types", accelerator_types)
        pulumi.set(__self__, "allowed_instance_types", allowed_instance_types)
        pulumi.set(__self__, "bare_metal", bare_metal)
        pulumi.set(__self__, "baseline_ebs_bandwidth_mbps", baseline_ebs_bandwidth_mbps)
        pulumi.set(__self__, "burstable_performance", burstable_performance)
        pulumi.set(__self__, "cpu_manufacturers", cpu_manufacturers)
        pulumi.set(__self__, "excluded_instance_types", excluded_instance_types)
        pulumi.set(__self__, "instance_generations", instance_generations)
        pulumi.set(__self__, "local_storage", local_storage)
        pulumi.set(__self__, "local_storage_types", local_storage_types)
        pulumi.set(__self__, "max_spot_price_as_percentage_of_optimal_on_demand_price", max_spot_price_as_percentage_of_optimal_on_demand_price)
        pulumi.set(__self__, "memory_gib_per_vcpus", memory_gib_per_vcpus)
        pulumi.set(__self__, "memory_mibs", memory_mibs)
        pulumi.set(__self__, "network_bandwidth_gbps", network_bandwidth_gbps)
        pulumi.set(__self__, "network_interface_counts", network_interface_counts)
        pulumi.set(__self__, "on_demand_max_price_percentage_over_lowest_price", on_demand_max_price_percentage_over_lowest_price)
        pulumi.set(__self__, "require_hibernate_support", require_hibernate_support)
        pulumi.set(__self__, "spot_max_price_percentage_over_lowest_price", spot_max_price_percentage_over_lowest_price)
        pulumi.set(__self__, "total_local_storage_gbs", total_local_storage_gbs)
        pulumi.set(__self__, "vcpu_counts", vcpu_counts)

    @_builtins.property
    @pulumi.getter(name="acceleratorCounts")
    def accelerator_counts(self) -> Sequence['outputs.GetLaunchTemplateInstanceRequirementAcceleratorCountResult']:
        return pulumi.get(self, "accelerator_counts")

    @_builtins.property
    @pulumi.getter(name="acceleratorManufacturers")
    def accelerator_manufacturers(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "accelerator_manufacturers")

    @_builtins.property
    @pulumi.getter(name="acceleratorNames")
    def accelerator_names(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "accelerator_names")

    @_builtins.property
    @pulumi.getter(name="acceleratorTotalMemoryMibs")
    def accelerator_total_memory_mibs(self) -> Sequence['outputs.GetLaunchTemplateInstanceRequirementAcceleratorTotalMemoryMibResult']:
        return pulumi.get(self, "accelerator_total_memory_mibs")

    @_builtins.property
    @pulumi.getter(name="acceleratorTypes")
    def accelerator_types(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "accelerator_types")

    @_builtins.property
    @pulumi.getter(name="allowedInstanceTypes")
    def allowed_instance_types(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "allowed_instance_types")

    @_builtins.property
    @pulumi.getter(name="bareMetal")
    def bare_metal(self) -> _builtins.str:
        return pulumi.get(self, "bare_metal")

    @_builtins.property
    @pulumi.getter(name="baselineEbsBandwidthMbps")
    def baseline_ebs_bandwidth_mbps(self) -> Sequence['outputs.GetLaunchTemplateInstanceRequirementBaselineEbsBandwidthMbpResult']:
        return pulumi.get(self, "baseline_ebs_bandwidth_mbps")

    @_builtins.property
    @pulumi.getter(name="burstablePerformance")
    def burstable_performance(self) -> _builtins.str:
        return pulumi.get(self, "burstable_performance")

    @_builtins.property
    @pulumi.getter(name="cpuManufacturers")
    def cpu_manufacturers(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "cpu_manufacturers")

    @_builtins.property
    @pulumi.getter(name="excludedInstanceTypes")
    def excluded_instance_types(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "excluded_instance_types")

    @_builtins.property
    @pulumi.getter(name="instanceGenerations")
    def instance_generations(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "instance_generations")

    @_builtins.property
    @pulumi.getter(name="localStorage")
    def local_storage(self) -> _builtins.str:
        return pulumi.get(self, "local_storage")

    @_builtins.property
    @pulumi.getter(name="localStorageTypes")
    def local_storage_types(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "local_storage_types")

    @_builtins.property
    @pulumi.getter(name="maxSpotPriceAsPercentageOfOptimalOnDemandPrice")
    def max_spot_price_as_percentage_of_optimal_on_demand_price(self) -> _builtins.int:
        return pulumi.get(self, "max_spot_price_as_percentage_of_optimal_on_demand_price")

    @_builtins.property
    @pulumi.getter(name="memoryGibPerVcpus")
    def memory_gib_per_vcpus(self) -> Sequence['outputs.GetLaunchTemplateInstanceRequirementMemoryGibPerVcpusResult']:
        return pulumi.get(self, "memory_gib_per_vcpus")

    @_builtins.property
    @pulumi.getter(name="memoryMibs")
    def memory_mibs(self) -> Sequence['outputs.GetLaunchTemplateInstanceRequirementMemoryMibResult']:
        return pulumi.get(self, "memory_mibs")

    @_builtins.property
    @pulumi.getter(name="networkBandwidthGbps")
    def network_bandwidth_gbps(self) -> Sequence['outputs.GetLaunchTemplateInstanceRequirementNetworkBandwidthGbpResult']:
        return pulumi.get(self, "network_bandwidth_gbps")

    @_builtins.property
    @pulumi.getter(name="networkInterfaceCounts")
    def network_interface_counts(self) -> Sequence['outputs.GetLaunchTemplateInstanceRequirementNetworkInterfaceCountResult']:
        return pulumi.get(self, "network_interface_counts")

    @_builtins.property
    @pulumi.getter(name="onDemandMaxPricePercentageOverLowestPrice")
    def on_demand_max_price_percentage_over_lowest_price(self) -> _builtins.int:
        return pulumi.get(self, "on_demand_max_price_percentage_over_lowest_price")

    @_builtins.property
    @pulumi.getter(name="requireHibernateSupport")
    def require_hibernate_support(self) -> _builtins.bool:
        return pulumi.get(self, "require_hibernate_support")

    @_builtins.property
    @pulumi.getter(name="spotMaxPricePercentageOverLowestPrice")
    def spot_max_price_percentage_over_lowest_price(self) -> _builtins.int:
        return pulumi.get(self, "spot_max_price_percentage_over_lowest_price")

    @_builtins.property
    @pulumi.getter(name="totalLocalStorageGbs")
    def total_local_storage_gbs(self) -> Sequence['outputs.GetLaunchTemplateInstanceRequirementTotalLocalStorageGbResult']:
        return pulumi.get(self, "total_local_storage_gbs")

    @_builtins.property
    @pulumi.getter(name="vcpuCounts")
    def vcpu_counts(self) -> Sequence['outputs.GetLaunchTemplateInstanceRequirementVcpuCountResult']:
        return pulumi.get(self, "vcpu_counts")


@pulumi.output_type
class GetLaunchTemplateInstanceRequirementAcceleratorCountResult(dict):
    def __init__(__self__, *,
                 max: _builtins.int,
                 min: _builtins.int):
        pulumi.set(__self__, "max", max)
        pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> _builtins.int:
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> _builtins.int:
        return pulumi.get(self, "min")


@pulumi.output_type
class GetLaunchTemplateInstanceRequirementAcceleratorTotalMemoryMibResult(dict):
    def __init__(__self__, *,
                 max: _builtins.int,
                 min: _builtins.int):
        pulumi.set(__self__, "max", max)
        pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> _builtins.int:
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> _builtins.int:
        return pulumi.get(self, "min")


@pulumi.output_type
class GetLaunchTemplateInstanceRequirementBaselineEbsBandwidthMbpResult(dict):
    def __init__(__self__, *,
                 max: _builtins.int,
                 min: _builtins.int):
        pulumi.set(__self__, "max", max)
        pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> _builtins.int:
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> _builtins.int:
        return pulumi.get(self, "min")


@pulumi.output_type
class GetLaunchTemplateInstanceRequirementMemoryGibPerVcpusResult(dict):
    def __init__(__self__, *,
                 max: _builtins.float,
                 min: _builtins.float):
        pulumi.set(__self__, "max", max)
        pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> _builtins.float:
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> _builtins.float:
        return pulumi.get(self, "min")


@pulumi.output_type
class GetLaunchTemplateInstanceRequirementMemoryMibResult(dict):
    def __init__(__self__, *,
                 max: _builtins.int,
                 min: _builtins.int):
        pulumi.set(__self__, "max", max)
        pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> _builtins.int:
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> _builtins.int:
        return pulumi.get(self, "min")


@pulumi.output_type
class GetLaunchTemplateInstanceRequirementNetworkBandwidthGbpResult(dict):
    def __init__(__self__, *,
                 max: _builtins.float,
                 min: _builtins.float):
        pulumi.set(__self__, "max", max)
        pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> _builtins.float:
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> _builtins.float:
        return pulumi.get(self, "min")


@pulumi.output_type
class GetLaunchTemplateInstanceRequirementNetworkInterfaceCountResult(dict):
    def __init__(__self__, *,
                 max: _builtins.int,
                 min: _builtins.int):
        pulumi.set(__self__, "max", max)
        pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> _builtins.int:
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> _builtins.int:
        return pulumi.get(self, "min")


@pulumi.output_type
class GetLaunchTemplateInstanceRequirementTotalLocalStorageGbResult(dict):
    def __init__(__self__, *,
                 max: _builtins.float,
                 min: _builtins.float):
        pulumi.set(__self__, "max", max)
        pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> _builtins.float:
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> _builtins.float:
        return pulumi.get(self, "min")


@pulumi.output_type
class GetLaunchTemplateInstanceRequirementVcpuCountResult(dict):
    def __init__(__self__, *,
                 max: _builtins.int,
                 min: _builtins.int):
        pulumi.set(__self__, "max", max)
        pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> _builtins.int:
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> _builtins.int:
        return pulumi.get(self, "min")


@pulumi.output_type
class GetLaunchTemplateLicenseSpecificationResult(dict):
    def __init__(__self__, *,
                 license_configuration_arn: _builtins.str):
        pulumi.set(__self__, "license_configuration_arn", license_configuration_arn)

    @_builtins.property
    @pulumi.getter(name="licenseConfigurationArn")
    def license_configuration_arn(self) -> _builtins.str:
        return pulumi.get(self, "license_configuration_arn")


@pulumi.output_type
class GetLaunchTemplateMaintenanceOptionResult(dict):
    def __init__(__self__, *,
                 auto_recovery: _builtins.str):
        pulumi.set(__self__, "auto_recovery", auto_recovery)

    @_builtins.property
    @pulumi.getter(name="autoRecovery")
    def auto_recovery(self) -> _builtins.str:
        return pulumi.get(self, "auto_recovery")


@pulumi.output_type
class GetLaunchTemplateMetadataOptionResult(dict):
    def __init__(__self__, *,
                 http_endpoint: _builtins.str,
                 http_protocol_ipv6: _builtins.str,
                 http_put_response_hop_limit: _builtins.int,
                 http_tokens: _builtins.str,
                 instance_metadata_tags: _builtins.str):
        pulumi.set(__self__, "http_endpoint", http_endpoint)
        pulumi.set(__self__, "http_protocol_ipv6", http_protocol_ipv6)
        pulumi.set(__self__, "http_put_response_hop_limit", http_put_response_hop_limit)
        pulumi.set(__self__, "http_tokens", http_tokens)
        pulumi.set(__self__, "instance_metadata_tags", instance_metadata_tags)

    @_builtins.property
    @pulumi.getter(name="httpEndpoint")
    def http_endpoint(self) -> _builtins.str:
        return pulumi.get(self, "http_endpoint")

    @_builtins.property
    @pulumi.getter(name="httpProtocolIpv6")
    def http_protocol_ipv6(self) -> _builtins.str:
        return pulumi.get(self, "http_protocol_ipv6")

    @_builtins.property
    @pulumi.getter(name="httpPutResponseHopLimit")
    def http_put_response_hop_limit(self) -> _builtins.int:
        return pulumi.get(self, "http_put_response_hop_limit")

    @_builtins.property
    @pulumi.getter(name="httpTokens")
    def http_tokens(self) -> _builtins.str:
        return pulumi.get(self, "http_tokens")

    @_builtins.property
    @pulumi.getter(name="instanceMetadataTags")
    def instance_metadata_tags(self) -> _builtins.str:
        return pulumi.get(self, "instance_metadata_tags")


@pulumi.output_type
class GetLaunchTemplateMonitoringResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool):
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetLaunchTemplateNetworkInterfaceResult(dict):
    def __init__(__self__, *,
                 associate_carrier_ip_address: _builtins.str,
                 connection_tracking_specifications: Sequence['outputs.GetLaunchTemplateNetworkInterfaceConnectionTrackingSpecificationResult'],
                 description: _builtins.str,
                 device_index: _builtins.int,
                 interface_type: _builtins.str,
                 ipv4_address_count: _builtins.int,
                 ipv4_addresses: Sequence[_builtins.str],
                 ipv4_prefix_count: _builtins.int,
                 ipv4_prefixes: Sequence[_builtins.str],
                 ipv6_address_count: _builtins.int,
                 ipv6_addresses: Sequence[_builtins.str],
                 ipv6_prefix_count: _builtins.int,
                 ipv6_prefixes: Sequence[_builtins.str],
                 network_card_index: _builtins.int,
                 network_interface_id: _builtins.str,
                 primary_ipv6: _builtins.str,
                 private_ip_address: _builtins.str,
                 security_groups: Sequence[_builtins.str],
                 subnet_id: _builtins.str,
                 associate_public_ip_address: Optional[_builtins.bool] = None,
                 delete_on_termination: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "associate_carrier_ip_address", associate_carrier_ip_address)
        pulumi.set(__self__, "connection_tracking_specifications", connection_tracking_specifications)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "device_index", device_index)
        pulumi.set(__self__, "interface_type", interface_type)
        pulumi.set(__self__, "ipv4_address_count", ipv4_address_count)
        pulumi.set(__self__, "ipv4_addresses", ipv4_addresses)
        pulumi.set(__self__, "ipv4_prefix_count", ipv4_prefix_count)
        pulumi.set(__self__, "ipv4_prefixes", ipv4_prefixes)
        pulumi.set(__self__, "ipv6_address_count", ipv6_address_count)
        pulumi.set(__self__, "ipv6_addresses", ipv6_addresses)
        pulumi.set(__self__, "ipv6_prefix_count", ipv6_prefix_count)
        pulumi.set(__self__, "ipv6_prefixes", ipv6_prefixes)
        pulumi.set(__self__, "network_card_index", network_card_index)
        pulumi.set(__self__, "network_interface_id", network_interface_id)
        pulumi.set(__self__, "primary_ipv6", primary_ipv6)
        pulumi.set(__self__, "private_ip_address", private_ip_address)
        pulumi.set(__self__, "security_groups", security_groups)
        pulumi.set(__self__, "subnet_id", subnet_id)
        if associate_public_ip_address is not None:
            pulumi.set(__self__, "associate_public_ip_address", associate_public_ip_address)
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)

    @_builtins.property
    @pulumi.getter(name="associateCarrierIpAddress")
    def associate_carrier_ip_address(self) -> _builtins.str:
        return pulumi.get(self, "associate_carrier_ip_address")

    @_builtins.property
    @pulumi.getter(name="connectionTrackingSpecifications")
    def connection_tracking_specifications(self) -> Sequence['outputs.GetLaunchTemplateNetworkInterfaceConnectionTrackingSpecificationResult']:
        return pulumi.get(self, "connection_tracking_specifications")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="deviceIndex")
    def device_index(self) -> _builtins.int:
        return pulumi.get(self, "device_index")

    @_builtins.property
    @pulumi.getter(name="interfaceType")
    def interface_type(self) -> _builtins.str:
        return pulumi.get(self, "interface_type")

    @_builtins.property
    @pulumi.getter(name="ipv4AddressCount")
    def ipv4_address_count(self) -> _builtins.int:
        return pulumi.get(self, "ipv4_address_count")

    @_builtins.property
    @pulumi.getter(name="ipv4Addresses")
    def ipv4_addresses(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "ipv4_addresses")

    @_builtins.property
    @pulumi.getter(name="ipv4PrefixCount")
    def ipv4_prefix_count(self) -> _builtins.int:
        return pulumi.get(self, "ipv4_prefix_count")

    @_builtins.property
    @pulumi.getter(name="ipv4Prefixes")
    def ipv4_prefixes(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "ipv4_prefixes")

    @_builtins.property
    @pulumi.getter(name="ipv6AddressCount")
    def ipv6_address_count(self) -> _builtins.int:
        return pulumi.get(self, "ipv6_address_count")

    @_builtins.property
    @pulumi.getter(name="ipv6Addresses")
    def ipv6_addresses(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "ipv6_addresses")

    @_builtins.property
    @pulumi.getter(name="ipv6PrefixCount")
    def ipv6_prefix_count(self) -> _builtins.int:
        return pulumi.get(self, "ipv6_prefix_count")

    @_builtins.property
    @pulumi.getter(name="ipv6Prefixes")
    def ipv6_prefixes(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "ipv6_prefixes")

    @_builtins.property
    @pulumi.getter(name="networkCardIndex")
    def network_card_index(self) -> _builtins.int:
        return pulumi.get(self, "network_card_index")

    @_builtins.property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> _builtins.str:
        return pulumi.get(self, "network_interface_id")

    @_builtins.property
    @pulumi.getter(name="primaryIpv6")
    def primary_ipv6(self) -> _builtins.str:
        return pulumi.get(self, "primary_ipv6")

    @_builtins.property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> _builtins.str:
        return pulumi.get(self, "private_ip_address")

    @_builtins.property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "security_groups")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter(name="associatePublicIpAddress")
    def associate_public_ip_address(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "associate_public_ip_address")

    @_builtins.property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "delete_on_termination")


@pulumi.output_type
class GetLaunchTemplateNetworkInterfaceConnectionTrackingSpecificationResult(dict):
    def __init__(__self__, *,
                 tcp_established_timeout: _builtins.int,
                 udp_stream_timeout: _builtins.int,
                 udp_timeout: _builtins.int):
        pulumi.set(__self__, "tcp_established_timeout", tcp_established_timeout)
        pulumi.set(__self__, "udp_stream_timeout", udp_stream_timeout)
        pulumi.set(__self__, "udp_timeout", udp_timeout)

    @_builtins.property
    @pulumi.getter(name="tcpEstablishedTimeout")
    def tcp_established_timeout(self) -> _builtins.int:
        return pulumi.get(self, "tcp_established_timeout")

    @_builtins.property
    @pulumi.getter(name="udpStreamTimeout")
    def udp_stream_timeout(self) -> _builtins.int:
        return pulumi.get(self, "udp_stream_timeout")

    @_builtins.property
    @pulumi.getter(name="udpTimeout")
    def udp_timeout(self) -> _builtins.int:
        return pulumi.get(self, "udp_timeout")


@pulumi.output_type
class GetLaunchTemplatePlacementResult(dict):
    def __init__(__self__, *,
                 affinity: _builtins.str,
                 availability_zone: _builtins.str,
                 group_name: _builtins.str,
                 host_id: _builtins.str,
                 host_resource_group_arn: _builtins.str,
                 partition_number: _builtins.int,
                 spread_domain: _builtins.str,
                 tenancy: _builtins.str):
        pulumi.set(__self__, "affinity", affinity)
        pulumi.set(__self__, "availability_zone", availability_zone)
        pulumi.set(__self__, "group_name", group_name)
        pulumi.set(__self__, "host_id", host_id)
        pulumi.set(__self__, "host_resource_group_arn", host_resource_group_arn)
        pulumi.set(__self__, "partition_number", partition_number)
        pulumi.set(__self__, "spread_domain", spread_domain)
        pulumi.set(__self__, "tenancy", tenancy)

    @_builtins.property
    @pulumi.getter
    def affinity(self) -> _builtins.str:
        return pulumi.get(self, "affinity")

    @_builtins.property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> _builtins.str:
        return pulumi.get(self, "availability_zone")

    @_builtins.property
    @pulumi.getter(name="groupName")
    def group_name(self) -> _builtins.str:
        return pulumi.get(self, "group_name")

    @_builtins.property
    @pulumi.getter(name="hostId")
    def host_id(self) -> _builtins.str:
        return pulumi.get(self, "host_id")

    @_builtins.property
    @pulumi.getter(name="hostResourceGroupArn")
    def host_resource_group_arn(self) -> _builtins.str:
        return pulumi.get(self, "host_resource_group_arn")

    @_builtins.property
    @pulumi.getter(name="partitionNumber")
    def partition_number(self) -> _builtins.int:
        return pulumi.get(self, "partition_number")

    @_builtins.property
    @pulumi.getter(name="spreadDomain")
    def spread_domain(self) -> _builtins.str:
        return pulumi.get(self, "spread_domain")

    @_builtins.property
    @pulumi.getter
    def tenancy(self) -> _builtins.str:
        return pulumi.get(self, "tenancy")


@pulumi.output_type
class GetLaunchTemplatePrivateDnsNameOptionResult(dict):
    def __init__(__self__, *,
                 enable_resource_name_dns_a_record: _builtins.bool,
                 enable_resource_name_dns_aaaa_record: _builtins.bool,
                 hostname_type: _builtins.str):
        pulumi.set(__self__, "enable_resource_name_dns_a_record", enable_resource_name_dns_a_record)
        pulumi.set(__self__, "enable_resource_name_dns_aaaa_record", enable_resource_name_dns_aaaa_record)
        pulumi.set(__self__, "hostname_type", hostname_type)

    @_builtins.property
    @pulumi.getter(name="enableResourceNameDnsARecord")
    def enable_resource_name_dns_a_record(self) -> _builtins.bool:
        return pulumi.get(self, "enable_resource_name_dns_a_record")

    @_builtins.property
    @pulumi.getter(name="enableResourceNameDnsAaaaRecord")
    def enable_resource_name_dns_aaaa_record(self) -> _builtins.bool:
        return pulumi.get(self, "enable_resource_name_dns_aaaa_record")

    @_builtins.property
    @pulumi.getter(name="hostnameType")
    def hostname_type(self) -> _builtins.str:
        return pulumi.get(self, "hostname_type")


@pulumi.output_type
class GetLaunchTemplateTagSpecificationResult(dict):
    def __init__(__self__, *,
                 resource_type: _builtins.str,
                 tags: Mapping[str, _builtins.str]):
        """
        :param Mapping[str, _builtins.str] tags: Map of tags, each pair of which must exactly match a pair on the desired Launch Template.
        """
        pulumi.set(__self__, "resource_type", resource_type)
        pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> _builtins.str:
        return pulumi.get(self, "resource_type")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Mapping[str, _builtins.str]:
        """
        Map of tags, each pair of which must exactly match a pair on the desired Launch Template.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetLocalGatewayFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Name of the field to filter by, as defined by
               [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeLocalGateways.html).
        :param Sequence[_builtins.str] values: Set of values that are accepted for the given field.
               A Local Gateway will be selected if any one of the given values matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the field to filter by, as defined by
        [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeLocalGateways.html).
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Set of values that are accepted for the given field.
        A Local Gateway will be selected if any one of the given values matches.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetLocalGatewayRouteTableFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Name of the field to filter by, as defined by
               [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeLocalGatewayRouteTables.html).
        :param Sequence[_builtins.str] values: Set of values that are accepted for the given field.
               A local gateway route table will be selected if any one of the given values matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the field to filter by, as defined by
        [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeLocalGatewayRouteTables.html).
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Set of values that are accepted for the given field.
        A local gateway route table will be selected if any one of the given values matches.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetLocalGatewayRouteTablesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Name of the field to filter by, as defined by
               [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeLocalGatewayRouteTables.html).
        :param Sequence[_builtins.str] values: Set of values that are accepted for the given field.
               A Local Gateway Route Table will be selected if any one of the given values matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the field to filter by, as defined by
        [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeLocalGatewayRouteTables.html).
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Set of values that are accepted for the given field.
        A Local Gateway Route Table will be selected if any one of the given values matches.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetLocalGatewayVirtualInterfaceFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Name of the filter.
        :param Sequence[_builtins.str] values: List of one or more values for the filter.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the filter.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        List of one or more values for the filter.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetLocalGatewayVirtualInterfaceGroupFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Name of the filter.
        :param Sequence[_builtins.str] values: List of one or more values for the filter.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the filter.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        List of one or more values for the filter.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetLocalGatewayVirtualInterfaceGroupsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Name of the filter.
        :param Sequence[_builtins.str] values: List of one or more values for the filter.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the filter.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        List of one or more values for the filter.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetLocalGatewaysFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Name of the field to filter by, as defined by
               [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeLocalGateways.html).
        :param Sequence[_builtins.str] values: Set of values that are accepted for the given field.
               A Local Gateway will be selected if any one of the given values matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the field to filter by, as defined by
        [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeLocalGateways.html).
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Set of values that are accepted for the given field.
        A Local Gateway will be selected if any one of the given values matches.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetManagedPrefixListEntryResult(dict):
    def __init__(__self__, *,
                 cidr: _builtins.str,
                 description: _builtins.str):
        pulumi.set(__self__, "cidr", cidr)
        pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def cidr(self) -> _builtins.str:
        return pulumi.get(self, "cidr")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        return pulumi.get(self, "description")


@pulumi.output_type
class GetManagedPrefixListFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Name of the filter field. Valid values can be found in the EC2 [DescribeManagedPrefixLists](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeManagedPrefixLists.html) API Reference.
        :param Sequence[_builtins.str] values: Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the filter field. Valid values can be found in the EC2 [DescribeManagedPrefixLists](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeManagedPrefixLists.html) API Reference.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetManagedPrefixListsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Name of the field to filter by, as defined by
               [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeManagedPrefixLists.html).
        :param Sequence[_builtins.str] values: Set of values that are accepted for the given field.
               A managed prefix list will be selected if any one of the given values matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the field to filter by, as defined by
        [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeManagedPrefixLists.html).
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Set of values that are accepted for the given field.
        A managed prefix list will be selected if any one of the given values matches.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetNatGatewayFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Name of the field to filter by, as defined by
               [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNatGateways.html).
        :param Sequence[_builtins.str] values: Set of values that are accepted for the given field.
               An Nat Gateway will be selected if any one of the given values matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the field to filter by, as defined by
        [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNatGateways.html).
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Set of values that are accepted for the given field.
        An Nat Gateway will be selected if any one of the given values matches.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetNatGatewaysFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Name of the field to filter by, as defined by
               [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNatGateways.html).
        :param Sequence[_builtins.str] values: Set of values that are accepted for the given field.
               A Nat Gateway will be selected if any one of the given values matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the field to filter by, as defined by
        [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNatGateways.html).
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Set of values that are accepted for the given field.
        A Nat Gateway will be selected if any one of the given values matches.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetNetworkAclsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Name of the field to filter by, as defined by
               [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkAcls.html).
        :param Sequence[_builtins.str] values: Set of values that are accepted for the given field.
               A VPC will be selected if any one of the given values matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the field to filter by, as defined by
        [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkAcls.html).
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Set of values that are accepted for the given field.
        A VPC will be selected if any one of the given values matches.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetNetworkInsightsAnalysisAlternatePathHintResult(dict):
    def __init__(__self__, *,
                 component_arn: _builtins.str,
                 component_id: _builtins.str):
        pulumi.set(__self__, "component_arn", component_arn)
        pulumi.set(__self__, "component_id", component_id)

    @_builtins.property
    @pulumi.getter(name="componentArn")
    def component_arn(self) -> _builtins.str:
        return pulumi.get(self, "component_arn")

    @_builtins.property
    @pulumi.getter(name="componentId")
    def component_id(self) -> _builtins.str:
        return pulumi.get(self, "component_id")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationResult(dict):
    def __init__(__self__, *,
                 acl_rules: Sequence['outputs.GetNetworkInsightsAnalysisExplanationAclRuleResult'],
                 acls: Sequence['outputs.GetNetworkInsightsAnalysisExplanationAclResult'],
                 address: _builtins.str,
                 addresses: Sequence[_builtins.str],
                 attached_tos: Sequence['outputs.GetNetworkInsightsAnalysisExplanationAttachedToResult'],
                 availability_zones: Sequence[_builtins.str],
                 cidrs: Sequence[_builtins.str],
                 classic_load_balancer_listeners: Sequence['outputs.GetNetworkInsightsAnalysisExplanationClassicLoadBalancerListenerResult'],
                 components: Sequence['outputs.GetNetworkInsightsAnalysisExplanationComponentResult'],
                 customer_gateways: Sequence['outputs.GetNetworkInsightsAnalysisExplanationCustomerGatewayResult'],
                 destination_vpcs: Sequence['outputs.GetNetworkInsightsAnalysisExplanationDestinationVpcResult'],
                 destinations: Sequence['outputs.GetNetworkInsightsAnalysisExplanationDestinationResult'],
                 direction: _builtins.str,
                 elastic_load_balancer_listeners: Sequence['outputs.GetNetworkInsightsAnalysisExplanationElasticLoadBalancerListenerResult'],
                 explanation_code: _builtins.str,
                 ingress_route_tables: Sequence['outputs.GetNetworkInsightsAnalysisExplanationIngressRouteTableResult'],
                 internet_gateways: Sequence['outputs.GetNetworkInsightsAnalysisExplanationInternetGatewayResult'],
                 load_balancer_arn: _builtins.str,
                 load_balancer_listener_port: _builtins.int,
                 load_balancer_target_group: Sequence['outputs.GetNetworkInsightsAnalysisExplanationLoadBalancerTargetGroupResult'],
                 load_balancer_target_groups: Sequence['outputs.GetNetworkInsightsAnalysisExplanationLoadBalancerTargetGroupResult'],
                 load_balancer_target_port: _builtins.int,
                 missing_component: _builtins.str,
                 nat_gateways: Sequence['outputs.GetNetworkInsightsAnalysisExplanationNatGatewayResult'],
                 network_interfaces: Sequence['outputs.GetNetworkInsightsAnalysisExplanationNetworkInterfaceResult'],
                 packet_field: _builtins.str,
                 port: _builtins.int,
                 port_ranges: Sequence['outputs.GetNetworkInsightsAnalysisExplanationPortRangeResult'],
                 prefix_lists: Sequence['outputs.GetNetworkInsightsAnalysisExplanationPrefixListResult'],
                 protocols: Sequence[_builtins.str],
                 route_table_routes: Sequence['outputs.GetNetworkInsightsAnalysisExplanationRouteTableRouteResult'],
                 route_tables: Sequence['outputs.GetNetworkInsightsAnalysisExplanationRouteTableResult'],
                 security_group: Sequence['outputs.GetNetworkInsightsAnalysisExplanationSecurityGroupResult'],
                 security_group_rules: Sequence['outputs.GetNetworkInsightsAnalysisExplanationSecurityGroupRuleResult'],
                 security_groups: Sequence['outputs.GetNetworkInsightsAnalysisExplanationSecurityGroupResult'],
                 source_vpcs: Sequence['outputs.GetNetworkInsightsAnalysisExplanationSourceVpcResult'],
                 state: _builtins.str,
                 subnet_route_tables: Sequence['outputs.GetNetworkInsightsAnalysisExplanationSubnetRouteTableResult'],
                 subnets: Sequence['outputs.GetNetworkInsightsAnalysisExplanationSubnetResult'],
                 transit_gateway_attachments: Sequence['outputs.GetNetworkInsightsAnalysisExplanationTransitGatewayAttachmentResult'],
                 transit_gateway_route_table_routes: Sequence['outputs.GetNetworkInsightsAnalysisExplanationTransitGatewayRouteTableRouteResult'],
                 transit_gateway_route_tables: Sequence['outputs.GetNetworkInsightsAnalysisExplanationTransitGatewayRouteTableResult'],
                 transit_gateways: Sequence['outputs.GetNetworkInsightsAnalysisExplanationTransitGatewayResult'],
                 vpc_endpoints: Sequence['outputs.GetNetworkInsightsAnalysisExplanationVpcEndpointResult'],
                 vpc_peering_connections: Sequence['outputs.GetNetworkInsightsAnalysisExplanationVpcPeeringConnectionResult'],
                 vpcs: Sequence['outputs.GetNetworkInsightsAnalysisExplanationVpcResult'],
                 vpn_connections: Sequence['outputs.GetNetworkInsightsAnalysisExplanationVpnConnectionResult'],
                 vpn_gateways: Sequence['outputs.GetNetworkInsightsAnalysisExplanationVpnGatewayResult']):
        pulumi.set(__self__, "acl_rules", acl_rules)
        pulumi.set(__self__, "acls", acls)
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "addresses", addresses)
        pulumi.set(__self__, "attached_tos", attached_tos)
        pulumi.set(__self__, "availability_zones", availability_zones)
        pulumi.set(__self__, "cidrs", cidrs)
        pulumi.set(__self__, "classic_load_balancer_listeners", classic_load_balancer_listeners)
        pulumi.set(__self__, "components", components)
        pulumi.set(__self__, "customer_gateways", customer_gateways)
        pulumi.set(__self__, "destination_vpcs", destination_vpcs)
        pulumi.set(__self__, "destinations", destinations)
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "elastic_load_balancer_listeners", elastic_load_balancer_listeners)
        pulumi.set(__self__, "explanation_code", explanation_code)
        pulumi.set(__self__, "ingress_route_tables", ingress_route_tables)
        pulumi.set(__self__, "internet_gateways", internet_gateways)
        pulumi.set(__self__, "load_balancer_arn", load_balancer_arn)
        pulumi.set(__self__, "load_balancer_listener_port", load_balancer_listener_port)
        pulumi.set(__self__, "load_balancer_target_group", load_balancer_target_group)
        pulumi.set(__self__, "load_balancer_target_groups", load_balancer_target_groups)
        pulumi.set(__self__, "load_balancer_target_port", load_balancer_target_port)
        pulumi.set(__self__, "missing_component", missing_component)
        pulumi.set(__self__, "nat_gateways", nat_gateways)
        pulumi.set(__self__, "network_interfaces", network_interfaces)
        pulumi.set(__self__, "packet_field", packet_field)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "port_ranges", port_ranges)
        pulumi.set(__self__, "prefix_lists", prefix_lists)
        pulumi.set(__self__, "protocols", protocols)
        pulumi.set(__self__, "route_table_routes", route_table_routes)
        pulumi.set(__self__, "route_tables", route_tables)
        pulumi.set(__self__, "security_group", security_group)
        pulumi.set(__self__, "security_group_rules", security_group_rules)
        pulumi.set(__self__, "security_groups", security_groups)
        pulumi.set(__self__, "source_vpcs", source_vpcs)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "subnet_route_tables", subnet_route_tables)
        pulumi.set(__self__, "subnets", subnets)
        pulumi.set(__self__, "transit_gateway_attachments", transit_gateway_attachments)
        pulumi.set(__self__, "transit_gateway_route_table_routes", transit_gateway_route_table_routes)
        pulumi.set(__self__, "transit_gateway_route_tables", transit_gateway_route_tables)
        pulumi.set(__self__, "transit_gateways", transit_gateways)
        pulumi.set(__self__, "vpc_endpoints", vpc_endpoints)
        pulumi.set(__self__, "vpc_peering_connections", vpc_peering_connections)
        pulumi.set(__self__, "vpcs", vpcs)
        pulumi.set(__self__, "vpn_connections", vpn_connections)
        pulumi.set(__self__, "vpn_gateways", vpn_gateways)

    @_builtins.property
    @pulumi.getter(name="aclRules")
    def acl_rules(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationAclRuleResult']:
        return pulumi.get(self, "acl_rules")

    @_builtins.property
    @pulumi.getter
    def acls(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationAclResult']:
        return pulumi.get(self, "acls")

    @_builtins.property
    @pulumi.getter
    def address(self) -> _builtins.str:
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def addresses(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "addresses")

    @_builtins.property
    @pulumi.getter(name="attachedTos")
    def attached_tos(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationAttachedToResult']:
        return pulumi.get(self, "attached_tos")

    @_builtins.property
    @pulumi.getter(name="availabilityZones")
    def availability_zones(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "availability_zones")

    @_builtins.property
    @pulumi.getter
    def cidrs(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "cidrs")

    @_builtins.property
    @pulumi.getter(name="classicLoadBalancerListeners")
    def classic_load_balancer_listeners(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationClassicLoadBalancerListenerResult']:
        return pulumi.get(self, "classic_load_balancer_listeners")

    @_builtins.property
    @pulumi.getter
    def components(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationComponentResult']:
        return pulumi.get(self, "components")

    @_builtins.property
    @pulumi.getter(name="customerGateways")
    def customer_gateways(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationCustomerGatewayResult']:
        return pulumi.get(self, "customer_gateways")

    @_builtins.property
    @pulumi.getter(name="destinationVpcs")
    def destination_vpcs(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationDestinationVpcResult']:
        return pulumi.get(self, "destination_vpcs")

    @_builtins.property
    @pulumi.getter
    def destinations(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationDestinationResult']:
        return pulumi.get(self, "destinations")

    @_builtins.property
    @pulumi.getter
    def direction(self) -> _builtins.str:
        return pulumi.get(self, "direction")

    @_builtins.property
    @pulumi.getter(name="elasticLoadBalancerListeners")
    def elastic_load_balancer_listeners(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationElasticLoadBalancerListenerResult']:
        return pulumi.get(self, "elastic_load_balancer_listeners")

    @_builtins.property
    @pulumi.getter(name="explanationCode")
    def explanation_code(self) -> _builtins.str:
        return pulumi.get(self, "explanation_code")

    @_builtins.property
    @pulumi.getter(name="ingressRouteTables")
    def ingress_route_tables(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationIngressRouteTableResult']:
        return pulumi.get(self, "ingress_route_tables")

    @_builtins.property
    @pulumi.getter(name="internetGateways")
    def internet_gateways(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationInternetGatewayResult']:
        return pulumi.get(self, "internet_gateways")

    @_builtins.property
    @pulumi.getter(name="loadBalancerArn")
    def load_balancer_arn(self) -> _builtins.str:
        return pulumi.get(self, "load_balancer_arn")

    @_builtins.property
    @pulumi.getter(name="loadBalancerListenerPort")
    def load_balancer_listener_port(self) -> _builtins.int:
        return pulumi.get(self, "load_balancer_listener_port")

    @_builtins.property
    @pulumi.getter(name="loadBalancerTargetGroup")
    def load_balancer_target_group(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationLoadBalancerTargetGroupResult']:
        return pulumi.get(self, "load_balancer_target_group")

    @_builtins.property
    @pulumi.getter(name="loadBalancerTargetGroups")
    def load_balancer_target_groups(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationLoadBalancerTargetGroupResult']:
        return pulumi.get(self, "load_balancer_target_groups")

    @_builtins.property
    @pulumi.getter(name="loadBalancerTargetPort")
    def load_balancer_target_port(self) -> _builtins.int:
        return pulumi.get(self, "load_balancer_target_port")

    @_builtins.property
    @pulumi.getter(name="missingComponent")
    def missing_component(self) -> _builtins.str:
        return pulumi.get(self, "missing_component")

    @_builtins.property
    @pulumi.getter(name="natGateways")
    def nat_gateways(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationNatGatewayResult']:
        return pulumi.get(self, "nat_gateways")

    @_builtins.property
    @pulumi.getter(name="networkInterfaces")
    def network_interfaces(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationNetworkInterfaceResult']:
        return pulumi.get(self, "network_interfaces")

    @_builtins.property
    @pulumi.getter(name="packetField")
    def packet_field(self) -> _builtins.str:
        return pulumi.get(self, "packet_field")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationPortRangeResult']:
        return pulumi.get(self, "port_ranges")

    @_builtins.property
    @pulumi.getter(name="prefixLists")
    def prefix_lists(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationPrefixListResult']:
        return pulumi.get(self, "prefix_lists")

    @_builtins.property
    @pulumi.getter
    def protocols(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "protocols")

    @_builtins.property
    @pulumi.getter(name="routeTableRoutes")
    def route_table_routes(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationRouteTableRouteResult']:
        return pulumi.get(self, "route_table_routes")

    @_builtins.property
    @pulumi.getter(name="routeTables")
    def route_tables(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationRouteTableResult']:
        return pulumi.get(self, "route_tables")

    @_builtins.property
    @pulumi.getter(name="securityGroup")
    def security_group(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationSecurityGroupResult']:
        return pulumi.get(self, "security_group")

    @_builtins.property
    @pulumi.getter(name="securityGroupRules")
    def security_group_rules(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationSecurityGroupRuleResult']:
        return pulumi.get(self, "security_group_rules")

    @_builtins.property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationSecurityGroupResult']:
        return pulumi.get(self, "security_groups")

    @_builtins.property
    @pulumi.getter(name="sourceVpcs")
    def source_vpcs(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationSourceVpcResult']:
        return pulumi.get(self, "source_vpcs")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="subnetRouteTables")
    def subnet_route_tables(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationSubnetRouteTableResult']:
        return pulumi.get(self, "subnet_route_tables")

    @_builtins.property
    @pulumi.getter
    def subnets(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationSubnetResult']:
        return pulumi.get(self, "subnets")

    @_builtins.property
    @pulumi.getter(name="transitGatewayAttachments")
    def transit_gateway_attachments(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationTransitGatewayAttachmentResult']:
        return pulumi.get(self, "transit_gateway_attachments")

    @_builtins.property
    @pulumi.getter(name="transitGatewayRouteTableRoutes")
    def transit_gateway_route_table_routes(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationTransitGatewayRouteTableRouteResult']:
        return pulumi.get(self, "transit_gateway_route_table_routes")

    @_builtins.property
    @pulumi.getter(name="transitGatewayRouteTables")
    def transit_gateway_route_tables(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationTransitGatewayRouteTableResult']:
        return pulumi.get(self, "transit_gateway_route_tables")

    @_builtins.property
    @pulumi.getter(name="transitGateways")
    def transit_gateways(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationTransitGatewayResult']:
        return pulumi.get(self, "transit_gateways")

    @_builtins.property
    @pulumi.getter(name="vpcEndpoints")
    def vpc_endpoints(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationVpcEndpointResult']:
        return pulumi.get(self, "vpc_endpoints")

    @_builtins.property
    @pulumi.getter(name="vpcPeeringConnections")
    def vpc_peering_connections(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationVpcPeeringConnectionResult']:
        return pulumi.get(self, "vpc_peering_connections")

    @_builtins.property
    @pulumi.getter
    def vpcs(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationVpcResult']:
        return pulumi.get(self, "vpcs")

    @_builtins.property
    @pulumi.getter(name="vpnConnections")
    def vpn_connections(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationVpnConnectionResult']:
        return pulumi.get(self, "vpn_connections")

    @_builtins.property
    @pulumi.getter(name="vpnGateways")
    def vpn_gateways(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationVpnGatewayResult']:
        return pulumi.get(self, "vpn_gateways")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationAclResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str arn: ARN of the selected Network Insights Analysis.
        :param _builtins.str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationAclRuleResult(dict):
    def __init__(__self__, *,
                 cidr: _builtins.str,
                 egress: _builtins.bool,
                 port_ranges: Sequence['outputs.GetNetworkInsightsAnalysisExplanationAclRulePortRangeResult'],
                 protocol: _builtins.str,
                 rule_action: _builtins.str,
                 rule_number: _builtins.int):
        pulumi.set(__self__, "cidr", cidr)
        pulumi.set(__self__, "egress", egress)
        pulumi.set(__self__, "port_ranges", port_ranges)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "rule_action", rule_action)
        pulumi.set(__self__, "rule_number", rule_number)

    @_builtins.property
    @pulumi.getter
    def cidr(self) -> _builtins.str:
        return pulumi.get(self, "cidr")

    @_builtins.property
    @pulumi.getter
    def egress(self) -> _builtins.bool:
        return pulumi.get(self, "egress")

    @_builtins.property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationAclRulePortRangeResult']:
        return pulumi.get(self, "port_ranges")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="ruleAction")
    def rule_action(self) -> _builtins.str:
        return pulumi.get(self, "rule_action")

    @_builtins.property
    @pulumi.getter(name="ruleNumber")
    def rule_number(self) -> _builtins.int:
        return pulumi.get(self, "rule_number")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationAclRulePortRangeResult(dict):
    def __init__(__self__, *,
                 from_: _builtins.int,
                 to: _builtins.int):
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> _builtins.int:
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> _builtins.int:
        return pulumi.get(self, "to")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationAttachedToResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str arn: ARN of the selected Network Insights Analysis.
        :param _builtins.str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationClassicLoadBalancerListenerResult(dict):
    def __init__(__self__, *,
                 instance_port: _builtins.int,
                 load_balancer_port: _builtins.int):
        pulumi.set(__self__, "instance_port", instance_port)
        pulumi.set(__self__, "load_balancer_port", load_balancer_port)

    @_builtins.property
    @pulumi.getter(name="instancePort")
    def instance_port(self) -> _builtins.int:
        return pulumi.get(self, "instance_port")

    @_builtins.property
    @pulumi.getter(name="loadBalancerPort")
    def load_balancer_port(self) -> _builtins.int:
        return pulumi.get(self, "load_balancer_port")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationComponentResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str arn: ARN of the selected Network Insights Analysis.
        :param _builtins.str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationCustomerGatewayResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str arn: ARN of the selected Network Insights Analysis.
        :param _builtins.str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationDestinationResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str arn: ARN of the selected Network Insights Analysis.
        :param _builtins.str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationDestinationVpcResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str arn: ARN of the selected Network Insights Analysis.
        :param _builtins.str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationElasticLoadBalancerListenerResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str arn: ARN of the selected Network Insights Analysis.
        :param _builtins.str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationIngressRouteTableResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str arn: ARN of the selected Network Insights Analysis.
        :param _builtins.str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationInternetGatewayResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str arn: ARN of the selected Network Insights Analysis.
        :param _builtins.str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationLoadBalancerTargetGroupResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str arn: ARN of the selected Network Insights Analysis.
        :param _builtins.str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationNatGatewayResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str arn: ARN of the selected Network Insights Analysis.
        :param _builtins.str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationNetworkInterfaceResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str arn: ARN of the selected Network Insights Analysis.
        :param _builtins.str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationPortRangeResult(dict):
    def __init__(__self__, *,
                 from_: _builtins.int,
                 to: _builtins.int):
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> _builtins.int:
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> _builtins.int:
        return pulumi.get(self, "to")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationPrefixListResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str arn: ARN of the selected Network Insights Analysis.
        :param _builtins.str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationRouteTableResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str arn: ARN of the selected Network Insights Analysis.
        :param _builtins.str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationRouteTableRouteResult(dict):
    def __init__(__self__, *,
                 destination_cidr: _builtins.str,
                 destination_prefix_list_id: _builtins.str,
                 egress_only_internet_gateway_id: _builtins.str,
                 gateway_id: _builtins.str,
                 instance_id: _builtins.str,
                 nat_gateway_id: _builtins.str,
                 network_interface_id: _builtins.str,
                 origin: _builtins.str,
                 transit_gateway_id: _builtins.str,
                 vpc_peering_connection_id: _builtins.str):
        pulumi.set(__self__, "destination_cidr", destination_cidr)
        pulumi.set(__self__, "destination_prefix_list_id", destination_prefix_list_id)
        pulumi.set(__self__, "egress_only_internet_gateway_id", egress_only_internet_gateway_id)
        pulumi.set(__self__, "gateway_id", gateway_id)
        pulumi.set(__self__, "instance_id", instance_id)
        pulumi.set(__self__, "nat_gateway_id", nat_gateway_id)
        pulumi.set(__self__, "network_interface_id", network_interface_id)
        pulumi.set(__self__, "origin", origin)
        pulumi.set(__self__, "transit_gateway_id", transit_gateway_id)
        pulumi.set(__self__, "vpc_peering_connection_id", vpc_peering_connection_id)

    @_builtins.property
    @pulumi.getter(name="destinationCidr")
    def destination_cidr(self) -> _builtins.str:
        return pulumi.get(self, "destination_cidr")

    @_builtins.property
    @pulumi.getter(name="destinationPrefixListId")
    def destination_prefix_list_id(self) -> _builtins.str:
        return pulumi.get(self, "destination_prefix_list_id")

    @_builtins.property
    @pulumi.getter(name="egressOnlyInternetGatewayId")
    def egress_only_internet_gateway_id(self) -> _builtins.str:
        return pulumi.get(self, "egress_only_internet_gateway_id")

    @_builtins.property
    @pulumi.getter(name="gatewayId")
    def gateway_id(self) -> _builtins.str:
        return pulumi.get(self, "gateway_id")

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> _builtins.str:
        return pulumi.get(self, "instance_id")

    @_builtins.property
    @pulumi.getter(name="natGatewayId")
    def nat_gateway_id(self) -> _builtins.str:
        return pulumi.get(self, "nat_gateway_id")

    @_builtins.property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> _builtins.str:
        return pulumi.get(self, "network_interface_id")

    @_builtins.property
    @pulumi.getter
    def origin(self) -> _builtins.str:
        return pulumi.get(self, "origin")

    @_builtins.property
    @pulumi.getter(name="transitGatewayId")
    def transit_gateway_id(self) -> _builtins.str:
        return pulumi.get(self, "transit_gateway_id")

    @_builtins.property
    @pulumi.getter(name="vpcPeeringConnectionId")
    def vpc_peering_connection_id(self) -> _builtins.str:
        return pulumi.get(self, "vpc_peering_connection_id")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationSecurityGroupResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str arn: ARN of the selected Network Insights Analysis.
        :param _builtins.str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationSecurityGroupRuleResult(dict):
    def __init__(__self__, *,
                 cidr: _builtins.str,
                 direction: _builtins.str,
                 port_ranges: Sequence['outputs.GetNetworkInsightsAnalysisExplanationSecurityGroupRulePortRangeResult'],
                 prefix_list_id: _builtins.str,
                 protocol: _builtins.str,
                 security_group_id: _builtins.str):
        pulumi.set(__self__, "cidr", cidr)
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "port_ranges", port_ranges)
        pulumi.set(__self__, "prefix_list_id", prefix_list_id)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "security_group_id", security_group_id)

    @_builtins.property
    @pulumi.getter
    def cidr(self) -> _builtins.str:
        return pulumi.get(self, "cidr")

    @_builtins.property
    @pulumi.getter
    def direction(self) -> _builtins.str:
        return pulumi.get(self, "direction")

    @_builtins.property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationSecurityGroupRulePortRangeResult']:
        return pulumi.get(self, "port_ranges")

    @_builtins.property
    @pulumi.getter(name="prefixListId")
    def prefix_list_id(self) -> _builtins.str:
        return pulumi.get(self, "prefix_list_id")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> _builtins.str:
        return pulumi.get(self, "security_group_id")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationSecurityGroupRulePortRangeResult(dict):
    def __init__(__self__, *,
                 from_: _builtins.int,
                 to: _builtins.int):
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> _builtins.int:
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> _builtins.int:
        return pulumi.get(self, "to")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationSourceVpcResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str arn: ARN of the selected Network Insights Analysis.
        :param _builtins.str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationSubnetResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str arn: ARN of the selected Network Insights Analysis.
        :param _builtins.str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationSubnetRouteTableResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str arn: ARN of the selected Network Insights Analysis.
        :param _builtins.str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationTransitGatewayResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str arn: ARN of the selected Network Insights Analysis.
        :param _builtins.str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationTransitGatewayAttachmentResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str arn: ARN of the selected Network Insights Analysis.
        :param _builtins.str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationTransitGatewayRouteTableResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str arn: ARN of the selected Network Insights Analysis.
        :param _builtins.str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationTransitGatewayRouteTableRouteResult(dict):
    def __init__(__self__, *,
                 attachment_id: _builtins.str,
                 destination_cidr: _builtins.str,
                 prefix_list_id: _builtins.str,
                 resource_id: _builtins.str,
                 resource_type: _builtins.str,
                 route_origin: _builtins.str,
                 state: _builtins.str):
        pulumi.set(__self__, "attachment_id", attachment_id)
        pulumi.set(__self__, "destination_cidr", destination_cidr)
        pulumi.set(__self__, "prefix_list_id", prefix_list_id)
        pulumi.set(__self__, "resource_id", resource_id)
        pulumi.set(__self__, "resource_type", resource_type)
        pulumi.set(__self__, "route_origin", route_origin)
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="attachmentId")
    def attachment_id(self) -> _builtins.str:
        return pulumi.get(self, "attachment_id")

    @_builtins.property
    @pulumi.getter(name="destinationCidr")
    def destination_cidr(self) -> _builtins.str:
        return pulumi.get(self, "destination_cidr")

    @_builtins.property
    @pulumi.getter(name="prefixListId")
    def prefix_list_id(self) -> _builtins.str:
        return pulumi.get(self, "prefix_list_id")

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> _builtins.str:
        return pulumi.get(self, "resource_id")

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> _builtins.str:
        return pulumi.get(self, "resource_type")

    @_builtins.property
    @pulumi.getter(name="routeOrigin")
    def route_origin(self) -> _builtins.str:
        return pulumi.get(self, "route_origin")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        return pulumi.get(self, "state")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationVpcResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str arn: ARN of the selected Network Insights Analysis.
        :param _builtins.str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationVpcEndpointResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str arn: ARN of the selected Network Insights Analysis.
        :param _builtins.str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationVpcPeeringConnectionResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str arn: ARN of the selected Network Insights Analysis.
        :param _builtins.str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationVpnConnectionResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str arn: ARN of the selected Network Insights Analysis.
        :param _builtins.str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationVpnGatewayResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str arn: ARN of the selected Network Insights Analysis.
        :param _builtins.str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        :param Sequence[_builtins.str] values: Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetNetworkInsightsAnalysisForwardPathComponentResult(dict):
    def __init__(__self__, *,
                 acl_rules: Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentAclRuleResult'],
                 additional_details: Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentAdditionalDetailResult'],
                 attached_tos: Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentAttachedToResult'],
                 components: Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentComponentResult'],
                 destination_vpcs: Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentDestinationVpcResult'],
                 inbound_headers: Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentInboundHeaderResult'],
                 outbound_headers: Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentOutboundHeaderResult'],
                 route_table_routes: Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentRouteTableRouteResult'],
                 security_group_rules: Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentSecurityGroupRuleResult'],
                 sequence_number: _builtins.int,
                 source_vpcs: Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentSourceVpcResult'],
                 subnets: Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentSubnetResult'],
                 transit_gateway_route_table_routes: Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentTransitGatewayRouteTableRouteResult'],
                 transit_gateways: Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentTransitGatewayResult'],
                 vpcs: Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentVpcResult']):
        pulumi.set(__self__, "acl_rules", acl_rules)
        pulumi.set(__self__, "additional_details", additional_details)
        pulumi.set(__self__, "attached_tos", attached_tos)
        pulumi.set(__self__, "components", components)
        pulumi.set(__self__, "destination_vpcs", destination_vpcs)
        pulumi.set(__self__, "inbound_headers", inbound_headers)
        pulumi.set(__self__, "outbound_headers", outbound_headers)
        pulumi.set(__self__, "route_table_routes", route_table_routes)
        pulumi.set(__self__, "security_group_rules", security_group_rules)
        pulumi.set(__self__, "sequence_number", sequence_number)
        pulumi.set(__self__, "source_vpcs", source_vpcs)
        pulumi.set(__self__, "subnets", subnets)
        pulumi.set(__self__, "transit_gateway_route_table_routes", transit_gateway_route_table_routes)
        pulumi.set(__self__, "transit_gateways", transit_gateways)
        pulumi.set(__self__, "vpcs", vpcs)

    @_builtins.property
    @pulumi.getter(name="aclRules")
    def acl_rules(self) -> Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentAclRuleResult']:
        return pulumi.get(self, "acl_rules")

    @_builtins.property
    @pulumi.getter(name="additionalDetails")
    def additional_details(self) -> Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentAdditionalDetailResult']:
        return pulumi.get(self, "additional_details")

    @_builtins.property
    @pulumi.getter(name="attachedTos")
    def attached_tos(self) -> Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentAttachedToResult']:
        return pulumi.get(self, "attached_tos")

    @_builtins.property
    @pulumi.getter
    def components(self) -> Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentComponentResult']:
        return pulumi.get(self, "components")

    @_builtins.property
    @pulumi.getter(name="destinationVpcs")
    def destination_vpcs(self) -> Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentDestinationVpcResult']:
        return pulumi.get(self, "destination_vpcs")

    @_builtins.property
    @pulumi.getter(name="inboundHeaders")
    def inbound_headers(self) -> Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentInboundHeaderResult']:
        return pulumi.get(self, "inbound_headers")

    @_builtins.property
    @pulumi.getter(name="outboundHeaders")
    def outbound_headers(self) -> Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentOutboundHeaderResult']:
        return pulumi.get(self, "outbound_headers")

    @_builtins.property
    @pulumi.getter(name="routeTableRoutes")
    def route_table_routes(self) -> Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentRouteTableRouteResult']:
        return pulumi.get(self, "route_table_routes")

    @_builtins.property
    @pulumi.getter(name="securityGroupRules")
    def security_group_rules(self) -> Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentSecurityGroupRuleResult']:
        return pulumi.get(self, "security_group_rules")

    @_builtins.property
    @pulumi.getter(name="sequenceNumber")
    def sequence_number(self) -> _builtins.int:
        return pulumi.get(self, "sequence_number")

    @_builtins.property
    @pulumi.getter(name="sourceVpcs")
    def source_vpcs(self) -> Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentSourceVpcResult']:
        return pulumi.get(self, "source_vpcs")

    @_builtins.property
    @pulumi.getter
    def subnets(self) -> Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentSubnetResult']:
        return pulumi.get(self, "subnets")

    @_builtins.property
    @pulumi.getter(name="transitGatewayRouteTableRoutes")
    def transit_gateway_route_table_routes(self) -> Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentTransitGatewayRouteTableRouteResult']:
        return pulumi.get(self, "transit_gateway_route_table_routes")

    @_builtins.property
    @pulumi.getter(name="transitGateways")
    def transit_gateways(self) -> Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentTransitGatewayResult']:
        return pulumi.get(self, "transit_gateways")

    @_builtins.property
    @pulumi.getter
    def vpcs(self) -> Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentVpcResult']:
        return pulumi.get(self, "vpcs")


@pulumi.output_type
class GetNetworkInsightsAnalysisForwardPathComponentAclRuleResult(dict):
    def __init__(__self__, *,
                 cidr: _builtins.str,
                 egress: _builtins.bool,
                 port_ranges: Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentAclRulePortRangeResult'],
                 protocol: _builtins.str,
                 rule_action: _builtins.str,
                 rule_number: _builtins.int):
        pulumi.set(__self__, "cidr", cidr)
        pulumi.set(__self__, "egress", egress)
        pulumi.set(__self__, "port_ranges", port_ranges)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "rule_action", rule_action)
        pulumi.set(__self__, "rule_number", rule_number)

    @_builtins.property
    @pulumi.getter
    def cidr(self) -> _builtins.str:
        return pulumi.get(self, "cidr")

    @_builtins.property
    @pulumi.getter
    def egress(self) -> _builtins.bool:
        return pulumi.get(self, "egress")

    @_builtins.property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentAclRulePortRangeResult']:
        return pulumi.get(self, "port_ranges")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="ruleAction")
    def rule_action(self) -> _builtins.str:
        return pulumi.get(self, "rule_action")

    @_builtins.property
    @pulumi.getter(name="ruleNumber")
    def rule_number(self) -> _builtins.int:
        return pulumi.get(self, "rule_number")


@pulumi.output_type
class GetNetworkInsightsAnalysisForwardPathComponentAclRulePortRangeResult(dict):
    def __init__(__self__, *,
                 from_: _builtins.int,
                 to: _builtins.int):
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> _builtins.int:
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> _builtins.int:
        return pulumi.get(self, "to")


@pulumi.output_type
class GetNetworkInsightsAnalysisForwardPathComponentAdditionalDetailResult(dict):
    def __init__(__self__, *,
                 additional_detail_type: _builtins.str,
                 components: Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentAdditionalDetailComponentResult']):
        pulumi.set(__self__, "additional_detail_type", additional_detail_type)
        pulumi.set(__self__, "components", components)

    @_builtins.property
    @pulumi.getter(name="additionalDetailType")
    def additional_detail_type(self) -> _builtins.str:
        return pulumi.get(self, "additional_detail_type")

    @_builtins.property
    @pulumi.getter
    def components(self) -> Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentAdditionalDetailComponentResult']:
        return pulumi.get(self, "components")


@pulumi.output_type
class GetNetworkInsightsAnalysisForwardPathComponentAdditionalDetailComponentResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str arn: ARN of the selected Network Insights Analysis.
        :param _builtins.str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisForwardPathComponentAttachedToResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str arn: ARN of the selected Network Insights Analysis.
        :param _builtins.str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisForwardPathComponentComponentResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str arn: ARN of the selected Network Insights Analysis.
        :param _builtins.str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisForwardPathComponentDestinationVpcResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str arn: ARN of the selected Network Insights Analysis.
        :param _builtins.str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisForwardPathComponentInboundHeaderResult(dict):
    def __init__(__self__, *,
                 destination_addresses: Sequence[_builtins.str],
                 destination_port_ranges: Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentInboundHeaderDestinationPortRangeResult'],
                 protocol: _builtins.str,
                 source_addresses: Sequence[_builtins.str],
                 source_port_ranges: Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentInboundHeaderSourcePortRangeResult']):
        pulumi.set(__self__, "destination_addresses", destination_addresses)
        pulumi.set(__self__, "destination_port_ranges", destination_port_ranges)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "source_addresses", source_addresses)
        pulumi.set(__self__, "source_port_ranges", source_port_ranges)

    @_builtins.property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "destination_addresses")

    @_builtins.property
    @pulumi.getter(name="destinationPortRanges")
    def destination_port_ranges(self) -> Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentInboundHeaderDestinationPortRangeResult']:
        return pulumi.get(self, "destination_port_ranges")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "source_addresses")

    @_builtins.property
    @pulumi.getter(name="sourcePortRanges")
    def source_port_ranges(self) -> Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentInboundHeaderSourcePortRangeResult']:
        return pulumi.get(self, "source_port_ranges")


@pulumi.output_type
class GetNetworkInsightsAnalysisForwardPathComponentInboundHeaderDestinationPortRangeResult(dict):
    def __init__(__self__, *,
                 from_: _builtins.int,
                 to: _builtins.int):
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> _builtins.int:
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> _builtins.int:
        return pulumi.get(self, "to")


@pulumi.output_type
class GetNetworkInsightsAnalysisForwardPathComponentInboundHeaderSourcePortRangeResult(dict):
    def __init__(__self__, *,
                 from_: _builtins.int,
                 to: _builtins.int):
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> _builtins.int:
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> _builtins.int:
        return pulumi.get(self, "to")


@pulumi.output_type
class GetNetworkInsightsAnalysisForwardPathComponentOutboundHeaderResult(dict):
    def __init__(__self__, *,
                 destination_addresses: Sequence[_builtins.str],
                 destination_port_ranges: Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentOutboundHeaderDestinationPortRangeResult'],
                 protocol: _builtins.str,
                 source_addresses: Sequence[_builtins.str],
                 source_port_ranges: Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentOutboundHeaderSourcePortRangeResult']):
        pulumi.set(__self__, "destination_addresses", destination_addresses)
        pulumi.set(__self__, "destination_port_ranges", destination_port_ranges)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "source_addresses", source_addresses)
        pulumi.set(__self__, "source_port_ranges", source_port_ranges)

    @_builtins.property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "destination_addresses")

    @_builtins.property
    @pulumi.getter(name="destinationPortRanges")
    def destination_port_ranges(self) -> Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentOutboundHeaderDestinationPortRangeResult']:
        return pulumi.get(self, "destination_port_ranges")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "source_addresses")

    @_builtins.property
    @pulumi.getter(name="sourcePortRanges")
    def source_port_ranges(self) -> Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentOutboundHeaderSourcePortRangeResult']:
        return pulumi.get(self, "source_port_ranges")


@pulumi.output_type
class GetNetworkInsightsAnalysisForwardPathComponentOutboundHeaderDestinationPortRangeResult(dict):
    def __init__(__self__, *,
                 from_: _builtins.int,
                 to: _builtins.int):
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> _builtins.int:
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> _builtins.int:
        return pulumi.get(self, "to")


@pulumi.output_type
class GetNetworkInsightsAnalysisForwardPathComponentOutboundHeaderSourcePortRangeResult(dict):
    def __init__(__self__, *,
                 from_: _builtins.int,
                 to: _builtins.int):
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> _builtins.int:
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> _builtins.int:
        return pulumi.get(self, "to")


@pulumi.output_type
class GetNetworkInsightsAnalysisForwardPathComponentRouteTableRouteResult(dict):
    def __init__(__self__, *,
                 destination_cidr: _builtins.str,
                 destination_prefix_list_id: _builtins.str,
                 egress_only_internet_gateway_id: _builtins.str,
                 gateway_id: _builtins.str,
                 instance_id: _builtins.str,
                 nat_gateway_id: _builtins.str,
                 network_interface_id: _builtins.str,
                 origin: _builtins.str,
                 transit_gateway_id: _builtins.str,
                 vpc_peering_connection_id: _builtins.str):
        pulumi.set(__self__, "destination_cidr", destination_cidr)
        pulumi.set(__self__, "destination_prefix_list_id", destination_prefix_list_id)
        pulumi.set(__self__, "egress_only_internet_gateway_id", egress_only_internet_gateway_id)
        pulumi.set(__self__, "gateway_id", gateway_id)
        pulumi.set(__self__, "instance_id", instance_id)
        pulumi.set(__self__, "nat_gateway_id", nat_gateway_id)
        pulumi.set(__self__, "network_interface_id", network_interface_id)
        pulumi.set(__self__, "origin", origin)
        pulumi.set(__self__, "transit_gateway_id", transit_gateway_id)
        pulumi.set(__self__, "vpc_peering_connection_id", vpc_peering_connection_id)

    @_builtins.property
    @pulumi.getter(name="destinationCidr")
    def destination_cidr(self) -> _builtins.str:
        return pulumi.get(self, "destination_cidr")

    @_builtins.property
    @pulumi.getter(name="destinationPrefixListId")
    def destination_prefix_list_id(self) -> _builtins.str:
        return pulumi.get(self, "destination_prefix_list_id")

    @_builtins.property
    @pulumi.getter(name="egressOnlyInternetGatewayId")
    def egress_only_internet_gateway_id(self) -> _builtins.str:
        return pulumi.get(self, "egress_only_internet_gateway_id")

    @_builtins.property
    @pulumi.getter(name="gatewayId")
    def gateway_id(self) -> _builtins.str:
        return pulumi.get(self, "gateway_id")

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> _builtins.str:
        return pulumi.get(self, "instance_id")

    @_builtins.property
    @pulumi.getter(name="natGatewayId")
    def nat_gateway_id(self) -> _builtins.str:
        return pulumi.get(self, "nat_gateway_id")

    @_builtins.property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> _builtins.str:
        return pulumi.get(self, "network_interface_id")

    @_builtins.property
    @pulumi.getter
    def origin(self) -> _builtins.str:
        return pulumi.get(self, "origin")

    @_builtins.property
    @pulumi.getter(name="transitGatewayId")
    def transit_gateway_id(self) -> _builtins.str:
        return pulumi.get(self, "transit_gateway_id")

    @_builtins.property
    @pulumi.getter(name="vpcPeeringConnectionId")
    def vpc_peering_connection_id(self) -> _builtins.str:
        return pulumi.get(self, "vpc_peering_connection_id")


@pulumi.output_type
class GetNetworkInsightsAnalysisForwardPathComponentSecurityGroupRuleResult(dict):
    def __init__(__self__, *,
                 cidr: _builtins.str,
                 direction: _builtins.str,
                 port_ranges: Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentSecurityGroupRulePortRangeResult'],
                 prefix_list_id: _builtins.str,
                 protocol: _builtins.str,
                 security_group_id: _builtins.str):
        pulumi.set(__self__, "cidr", cidr)
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "port_ranges", port_ranges)
        pulumi.set(__self__, "prefix_list_id", prefix_list_id)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "security_group_id", security_group_id)

    @_builtins.property
    @pulumi.getter
    def cidr(self) -> _builtins.str:
        return pulumi.get(self, "cidr")

    @_builtins.property
    @pulumi.getter
    def direction(self) -> _builtins.str:
        return pulumi.get(self, "direction")

    @_builtins.property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentSecurityGroupRulePortRangeResult']:
        return pulumi.get(self, "port_ranges")

    @_builtins.property
    @pulumi.getter(name="prefixListId")
    def prefix_list_id(self) -> _builtins.str:
        return pulumi.get(self, "prefix_list_id")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> _builtins.str:
        return pulumi.get(self, "security_group_id")


@pulumi.output_type
class GetNetworkInsightsAnalysisForwardPathComponentSecurityGroupRulePortRangeResult(dict):
    def __init__(__self__, *,
                 from_: _builtins.int,
                 to: _builtins.int):
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> _builtins.int:
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> _builtins.int:
        return pulumi.get(self, "to")


@pulumi.output_type
class GetNetworkInsightsAnalysisForwardPathComponentSourceVpcResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str arn: ARN of the selected Network Insights Analysis.
        :param _builtins.str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisForwardPathComponentSubnetResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str arn: ARN of the selected Network Insights Analysis.
        :param _builtins.str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisForwardPathComponentTransitGatewayResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str arn: ARN of the selected Network Insights Analysis.
        :param _builtins.str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisForwardPathComponentTransitGatewayRouteTableRouteResult(dict):
    def __init__(__self__, *,
                 attachment_id: _builtins.str,
                 destination_cidr: _builtins.str,
                 prefix_list_id: _builtins.str,
                 resource_id: _builtins.str,
                 resource_type: _builtins.str,
                 route_origin: _builtins.str,
                 state: _builtins.str):
        pulumi.set(__self__, "attachment_id", attachment_id)
        pulumi.set(__self__, "destination_cidr", destination_cidr)
        pulumi.set(__self__, "prefix_list_id", prefix_list_id)
        pulumi.set(__self__, "resource_id", resource_id)
        pulumi.set(__self__, "resource_type", resource_type)
        pulumi.set(__self__, "route_origin", route_origin)
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="attachmentId")
    def attachment_id(self) -> _builtins.str:
        return pulumi.get(self, "attachment_id")

    @_builtins.property
    @pulumi.getter(name="destinationCidr")
    def destination_cidr(self) -> _builtins.str:
        return pulumi.get(self, "destination_cidr")

    @_builtins.property
    @pulumi.getter(name="prefixListId")
    def prefix_list_id(self) -> _builtins.str:
        return pulumi.get(self, "prefix_list_id")

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> _builtins.str:
        return pulumi.get(self, "resource_id")

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> _builtins.str:
        return pulumi.get(self, "resource_type")

    @_builtins.property
    @pulumi.getter(name="routeOrigin")
    def route_origin(self) -> _builtins.str:
        return pulumi.get(self, "route_origin")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        return pulumi.get(self, "state")


@pulumi.output_type
class GetNetworkInsightsAnalysisForwardPathComponentVpcResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str arn: ARN of the selected Network Insights Analysis.
        :param _builtins.str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisReturnPathComponentResult(dict):
    def __init__(__self__, *,
                 acl_rules: Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentAclRuleResult'],
                 additional_details: Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentAdditionalDetailResult'],
                 attached_tos: Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentAttachedToResult'],
                 components: Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentComponentResult'],
                 destination_vpcs: Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentDestinationVpcResult'],
                 inbound_headers: Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentInboundHeaderResult'],
                 outbound_headers: Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentOutboundHeaderResult'],
                 route_table_routes: Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentRouteTableRouteResult'],
                 security_group_rules: Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentSecurityGroupRuleResult'],
                 sequence_number: _builtins.int,
                 source_vpcs: Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentSourceVpcResult'],
                 subnets: Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentSubnetResult'],
                 transit_gateway_route_table_routes: Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentTransitGatewayRouteTableRouteResult'],
                 transit_gateways: Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentTransitGatewayResult'],
                 vpcs: Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentVpcResult']):
        pulumi.set(__self__, "acl_rules", acl_rules)
        pulumi.set(__self__, "additional_details", additional_details)
        pulumi.set(__self__, "attached_tos", attached_tos)
        pulumi.set(__self__, "components", components)
        pulumi.set(__self__, "destination_vpcs", destination_vpcs)
        pulumi.set(__self__, "inbound_headers", inbound_headers)
        pulumi.set(__self__, "outbound_headers", outbound_headers)
        pulumi.set(__self__, "route_table_routes", route_table_routes)
        pulumi.set(__self__, "security_group_rules", security_group_rules)
        pulumi.set(__self__, "sequence_number", sequence_number)
        pulumi.set(__self__, "source_vpcs", source_vpcs)
        pulumi.set(__self__, "subnets", subnets)
        pulumi.set(__self__, "transit_gateway_route_table_routes", transit_gateway_route_table_routes)
        pulumi.set(__self__, "transit_gateways", transit_gateways)
        pulumi.set(__self__, "vpcs", vpcs)

    @_builtins.property
    @pulumi.getter(name="aclRules")
    def acl_rules(self) -> Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentAclRuleResult']:
        return pulumi.get(self, "acl_rules")

    @_builtins.property
    @pulumi.getter(name="additionalDetails")
    def additional_details(self) -> Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentAdditionalDetailResult']:
        return pulumi.get(self, "additional_details")

    @_builtins.property
    @pulumi.getter(name="attachedTos")
    def attached_tos(self) -> Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentAttachedToResult']:
        return pulumi.get(self, "attached_tos")

    @_builtins.property
    @pulumi.getter
    def components(self) -> Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentComponentResult']:
        return pulumi.get(self, "components")

    @_builtins.property
    @pulumi.getter(name="destinationVpcs")
    def destination_vpcs(self) -> Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentDestinationVpcResult']:
        return pulumi.get(self, "destination_vpcs")

    @_builtins.property
    @pulumi.getter(name="inboundHeaders")
    def inbound_headers(self) -> Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentInboundHeaderResult']:
        return pulumi.get(self, "inbound_headers")

    @_builtins.property
    @pulumi.getter(name="outboundHeaders")
    def outbound_headers(self) -> Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentOutboundHeaderResult']:
        return pulumi.get(self, "outbound_headers")

    @_builtins.property
    @pulumi.getter(name="routeTableRoutes")
    def route_table_routes(self) -> Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentRouteTableRouteResult']:
        return pulumi.get(self, "route_table_routes")

    @_builtins.property
    @pulumi.getter(name="securityGroupRules")
    def security_group_rules(self) -> Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentSecurityGroupRuleResult']:
        return pulumi.get(self, "security_group_rules")

    @_builtins.property
    @pulumi.getter(name="sequenceNumber")
    def sequence_number(self) -> _builtins.int:
        return pulumi.get(self, "sequence_number")

    @_builtins.property
    @pulumi.getter(name="sourceVpcs")
    def source_vpcs(self) -> Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentSourceVpcResult']:
        return pulumi.get(self, "source_vpcs")

    @_builtins.property
    @pulumi.getter
    def subnets(self) -> Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentSubnetResult']:
        return pulumi.get(self, "subnets")

    @_builtins.property
    @pulumi.getter(name="transitGatewayRouteTableRoutes")
    def transit_gateway_route_table_routes(self) -> Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentTransitGatewayRouteTableRouteResult']:
        return pulumi.get(self, "transit_gateway_route_table_routes")

    @_builtins.property
    @pulumi.getter(name="transitGateways")
    def transit_gateways(self) -> Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentTransitGatewayResult']:
        return pulumi.get(self, "transit_gateways")

    @_builtins.property
    @pulumi.getter
    def vpcs(self) -> Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentVpcResult']:
        return pulumi.get(self, "vpcs")


@pulumi.output_type
class GetNetworkInsightsAnalysisReturnPathComponentAclRuleResult(dict):
    def __init__(__self__, *,
                 cidr: _builtins.str,
                 egress: _builtins.bool,
                 port_ranges: Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentAclRulePortRangeResult'],
                 protocol: _builtins.str,
                 rule_action: _builtins.str,
                 rule_number: _builtins.int):
        pulumi.set(__self__, "cidr", cidr)
        pulumi.set(__self__, "egress", egress)
        pulumi.set(__self__, "port_ranges", port_ranges)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "rule_action", rule_action)
        pulumi.set(__self__, "rule_number", rule_number)

    @_builtins.property
    @pulumi.getter
    def cidr(self) -> _builtins.str:
        return pulumi.get(self, "cidr")

    @_builtins.property
    @pulumi.getter
    def egress(self) -> _builtins.bool:
        return pulumi.get(self, "egress")

    @_builtins.property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentAclRulePortRangeResult']:
        return pulumi.get(self, "port_ranges")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="ruleAction")
    def rule_action(self) -> _builtins.str:
        return pulumi.get(self, "rule_action")

    @_builtins.property
    @pulumi.getter(name="ruleNumber")
    def rule_number(self) -> _builtins.int:
        return pulumi.get(self, "rule_number")


@pulumi.output_type
class GetNetworkInsightsAnalysisReturnPathComponentAclRulePortRangeResult(dict):
    def __init__(__self__, *,
                 from_: _builtins.int,
                 to: _builtins.int):
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> _builtins.int:
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> _builtins.int:
        return pulumi.get(self, "to")


@pulumi.output_type
class GetNetworkInsightsAnalysisReturnPathComponentAdditionalDetailResult(dict):
    def __init__(__self__, *,
                 additional_detail_type: _builtins.str,
                 components: Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentAdditionalDetailComponentResult']):
        pulumi.set(__self__, "additional_detail_type", additional_detail_type)
        pulumi.set(__self__, "components", components)

    @_builtins.property
    @pulumi.getter(name="additionalDetailType")
    def additional_detail_type(self) -> _builtins.str:
        return pulumi.get(self, "additional_detail_type")

    @_builtins.property
    @pulumi.getter
    def components(self) -> Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentAdditionalDetailComponentResult']:
        return pulumi.get(self, "components")


@pulumi.output_type
class GetNetworkInsightsAnalysisReturnPathComponentAdditionalDetailComponentResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str arn: ARN of the selected Network Insights Analysis.
        :param _builtins.str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisReturnPathComponentAttachedToResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str arn: ARN of the selected Network Insights Analysis.
        :param _builtins.str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisReturnPathComponentComponentResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str arn: ARN of the selected Network Insights Analysis.
        :param _builtins.str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisReturnPathComponentDestinationVpcResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str arn: ARN of the selected Network Insights Analysis.
        :param _builtins.str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisReturnPathComponentInboundHeaderResult(dict):
    def __init__(__self__, *,
                 destination_addresses: Sequence[_builtins.str],
                 destination_port_ranges: Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentInboundHeaderDestinationPortRangeResult'],
                 protocol: _builtins.str,
                 source_addresses: Sequence[_builtins.str],
                 source_port_ranges: Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentInboundHeaderSourcePortRangeResult']):
        pulumi.set(__self__, "destination_addresses", destination_addresses)
        pulumi.set(__self__, "destination_port_ranges", destination_port_ranges)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "source_addresses", source_addresses)
        pulumi.set(__self__, "source_port_ranges", source_port_ranges)

    @_builtins.property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "destination_addresses")

    @_builtins.property
    @pulumi.getter(name="destinationPortRanges")
    def destination_port_ranges(self) -> Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentInboundHeaderDestinationPortRangeResult']:
        return pulumi.get(self, "destination_port_ranges")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "source_addresses")

    @_builtins.property
    @pulumi.getter(name="sourcePortRanges")
    def source_port_ranges(self) -> Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentInboundHeaderSourcePortRangeResult']:
        return pulumi.get(self, "source_port_ranges")


@pulumi.output_type
class GetNetworkInsightsAnalysisReturnPathComponentInboundHeaderDestinationPortRangeResult(dict):
    def __init__(__self__, *,
                 from_: _builtins.int,
                 to: _builtins.int):
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> _builtins.int:
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> _builtins.int:
        return pulumi.get(self, "to")


@pulumi.output_type
class GetNetworkInsightsAnalysisReturnPathComponentInboundHeaderSourcePortRangeResult(dict):
    def __init__(__self__, *,
                 from_: _builtins.int,
                 to: _builtins.int):
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> _builtins.int:
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> _builtins.int:
        return pulumi.get(self, "to")


@pulumi.output_type
class GetNetworkInsightsAnalysisReturnPathComponentOutboundHeaderResult(dict):
    def __init__(__self__, *,
                 destination_addresses: Sequence[_builtins.str],
                 destination_port_ranges: Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentOutboundHeaderDestinationPortRangeResult'],
                 protocol: _builtins.str,
                 source_addresses: Sequence[_builtins.str],
                 source_port_ranges: Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentOutboundHeaderSourcePortRangeResult']):
        pulumi.set(__self__, "destination_addresses", destination_addresses)
        pulumi.set(__self__, "destination_port_ranges", destination_port_ranges)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "source_addresses", source_addresses)
        pulumi.set(__self__, "source_port_ranges", source_port_ranges)

    @_builtins.property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "destination_addresses")

    @_builtins.property
    @pulumi.getter(name="destinationPortRanges")
    def destination_port_ranges(self) -> Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentOutboundHeaderDestinationPortRangeResult']:
        return pulumi.get(self, "destination_port_ranges")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "source_addresses")

    @_builtins.property
    @pulumi.getter(name="sourcePortRanges")
    def source_port_ranges(self) -> Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentOutboundHeaderSourcePortRangeResult']:
        return pulumi.get(self, "source_port_ranges")


@pulumi.output_type
class GetNetworkInsightsAnalysisReturnPathComponentOutboundHeaderDestinationPortRangeResult(dict):
    def __init__(__self__, *,
                 from_: _builtins.int,
                 to: _builtins.int):
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> _builtins.int:
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> _builtins.int:
        return pulumi.get(self, "to")


@pulumi.output_type
class GetNetworkInsightsAnalysisReturnPathComponentOutboundHeaderSourcePortRangeResult(dict):
    def __init__(__self__, *,
                 from_: _builtins.int,
                 to: _builtins.int):
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> _builtins.int:
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> _builtins.int:
        return pulumi.get(self, "to")


@pulumi.output_type
class GetNetworkInsightsAnalysisReturnPathComponentRouteTableRouteResult(dict):
    def __init__(__self__, *,
                 destination_cidr: _builtins.str,
                 destination_prefix_list_id: _builtins.str,
                 egress_only_internet_gateway_id: _builtins.str,
                 gateway_id: _builtins.str,
                 instance_id: _builtins.str,
                 nat_gateway_id: _builtins.str,
                 network_interface_id: _builtins.str,
                 origin: _builtins.str,
                 transit_gateway_id: _builtins.str,
                 vpc_peering_connection_id: _builtins.str):
        pulumi.set(__self__, "destination_cidr", destination_cidr)
        pulumi.set(__self__, "destination_prefix_list_id", destination_prefix_list_id)
        pulumi.set(__self__, "egress_only_internet_gateway_id", egress_only_internet_gateway_id)
        pulumi.set(__self__, "gateway_id", gateway_id)
        pulumi.set(__self__, "instance_id", instance_id)
        pulumi.set(__self__, "nat_gateway_id", nat_gateway_id)
        pulumi.set(__self__, "network_interface_id", network_interface_id)
        pulumi.set(__self__, "origin", origin)
        pulumi.set(__self__, "transit_gateway_id", transit_gateway_id)
        pulumi.set(__self__, "vpc_peering_connection_id", vpc_peering_connection_id)

    @_builtins.property
    @pulumi.getter(name="destinationCidr")
    def destination_cidr(self) -> _builtins.str:
        return pulumi.get(self, "destination_cidr")

    @_builtins.property
    @pulumi.getter(name="destinationPrefixListId")
    def destination_prefix_list_id(self) -> _builtins.str:
        return pulumi.get(self, "destination_prefix_list_id")

    @_builtins.property
    @pulumi.getter(name="egressOnlyInternetGatewayId")
    def egress_only_internet_gateway_id(self) -> _builtins.str:
        return pulumi.get(self, "egress_only_internet_gateway_id")

    @_builtins.property
    @pulumi.getter(name="gatewayId")
    def gateway_id(self) -> _builtins.str:
        return pulumi.get(self, "gateway_id")

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> _builtins.str:
        return pulumi.get(self, "instance_id")

    @_builtins.property
    @pulumi.getter(name="natGatewayId")
    def nat_gateway_id(self) -> _builtins.str:
        return pulumi.get(self, "nat_gateway_id")

    @_builtins.property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> _builtins.str:
        return pulumi.get(self, "network_interface_id")

    @_builtins.property
    @pulumi.getter
    def origin(self) -> _builtins.str:
        return pulumi.get(self, "origin")

    @_builtins.property
    @pulumi.getter(name="transitGatewayId")
    def transit_gateway_id(self) -> _builtins.str:
        return pulumi.get(self, "transit_gateway_id")

    @_builtins.property
    @pulumi.getter(name="vpcPeeringConnectionId")
    def vpc_peering_connection_id(self) -> _builtins.str:
        return pulumi.get(self, "vpc_peering_connection_id")


@pulumi.output_type
class GetNetworkInsightsAnalysisReturnPathComponentSecurityGroupRuleResult(dict):
    def __init__(__self__, *,
                 cidr: _builtins.str,
                 direction: _builtins.str,
                 port_ranges: Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentSecurityGroupRulePortRangeResult'],
                 prefix_list_id: _builtins.str,
                 protocol: _builtins.str,
                 security_group_id: _builtins.str):
        pulumi.set(__self__, "cidr", cidr)
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "port_ranges", port_ranges)
        pulumi.set(__self__, "prefix_list_id", prefix_list_id)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "security_group_id", security_group_id)

    @_builtins.property
    @pulumi.getter
    def cidr(self) -> _builtins.str:
        return pulumi.get(self, "cidr")

    @_builtins.property
    @pulumi.getter
    def direction(self) -> _builtins.str:
        return pulumi.get(self, "direction")

    @_builtins.property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentSecurityGroupRulePortRangeResult']:
        return pulumi.get(self, "port_ranges")

    @_builtins.property
    @pulumi.getter(name="prefixListId")
    def prefix_list_id(self) -> _builtins.str:
        return pulumi.get(self, "prefix_list_id")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> _builtins.str:
        return pulumi.get(self, "security_group_id")


@pulumi.output_type
class GetNetworkInsightsAnalysisReturnPathComponentSecurityGroupRulePortRangeResult(dict):
    def __init__(__self__, *,
                 from_: _builtins.int,
                 to: _builtins.int):
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> _builtins.int:
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> _builtins.int:
        return pulumi.get(self, "to")


@pulumi.output_type
class GetNetworkInsightsAnalysisReturnPathComponentSourceVpcResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str arn: ARN of the selected Network Insights Analysis.
        :param _builtins.str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisReturnPathComponentSubnetResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str arn: ARN of the selected Network Insights Analysis.
        :param _builtins.str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisReturnPathComponentTransitGatewayResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str arn: ARN of the selected Network Insights Analysis.
        :param _builtins.str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisReturnPathComponentTransitGatewayRouteTableRouteResult(dict):
    def __init__(__self__, *,
                 attachment_id: _builtins.str,
                 destination_cidr: _builtins.str,
                 prefix_list_id: _builtins.str,
                 resource_id: _builtins.str,
                 resource_type: _builtins.str,
                 route_origin: _builtins.str,
                 state: _builtins.str):
        pulumi.set(__self__, "attachment_id", attachment_id)
        pulumi.set(__self__, "destination_cidr", destination_cidr)
        pulumi.set(__self__, "prefix_list_id", prefix_list_id)
        pulumi.set(__self__, "resource_id", resource_id)
        pulumi.set(__self__, "resource_type", resource_type)
        pulumi.set(__self__, "route_origin", route_origin)
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="attachmentId")
    def attachment_id(self) -> _builtins.str:
        return pulumi.get(self, "attachment_id")

    @_builtins.property
    @pulumi.getter(name="destinationCidr")
    def destination_cidr(self) -> _builtins.str:
        return pulumi.get(self, "destination_cidr")

    @_builtins.property
    @pulumi.getter(name="prefixListId")
    def prefix_list_id(self) -> _builtins.str:
        return pulumi.get(self, "prefix_list_id")

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> _builtins.str:
        return pulumi.get(self, "resource_id")

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> _builtins.str:
        return pulumi.get(self, "resource_type")

    @_builtins.property
    @pulumi.getter(name="routeOrigin")
    def route_origin(self) -> _builtins.str:
        return pulumi.get(self, "route_origin")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        return pulumi.get(self, "state")


@pulumi.output_type
class GetNetworkInsightsAnalysisReturnPathComponentVpcResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str arn: ARN of the selected Network Insights Analysis.
        :param _builtins.str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsPathFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsPaths`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsPaths.html) API Reference.
        :param Sequence[_builtins.str] values: Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsPaths`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsPaths.html) API Reference.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetNetworkInsightsPathFilterAtDestinationResult(dict):
    def __init__(__self__, *,
                 destination_address: _builtins.str,
                 destination_port_ranges: Sequence['outputs.GetNetworkInsightsPathFilterAtDestinationDestinationPortRangeResult'],
                 source_address: _builtins.str,
                 source_port_ranges: Sequence['outputs.GetNetworkInsightsPathFilterAtDestinationSourcePortRangeResult']):
        pulumi.set(__self__, "destination_address", destination_address)
        pulumi.set(__self__, "destination_port_ranges", destination_port_ranges)
        pulumi.set(__self__, "source_address", source_address)
        pulumi.set(__self__, "source_port_ranges", source_port_ranges)

    @_builtins.property
    @pulumi.getter(name="destinationAddress")
    def destination_address(self) -> _builtins.str:
        return pulumi.get(self, "destination_address")

    @_builtins.property
    @pulumi.getter(name="destinationPortRanges")
    def destination_port_ranges(self) -> Sequence['outputs.GetNetworkInsightsPathFilterAtDestinationDestinationPortRangeResult']:
        return pulumi.get(self, "destination_port_ranges")

    @_builtins.property
    @pulumi.getter(name="sourceAddress")
    def source_address(self) -> _builtins.str:
        return pulumi.get(self, "source_address")

    @_builtins.property
    @pulumi.getter(name="sourcePortRanges")
    def source_port_ranges(self) -> Sequence['outputs.GetNetworkInsightsPathFilterAtDestinationSourcePortRangeResult']:
        return pulumi.get(self, "source_port_ranges")


@pulumi.output_type
class GetNetworkInsightsPathFilterAtDestinationDestinationPortRangeResult(dict):
    def __init__(__self__, *,
                 from_port: _builtins.int,
                 to_port: _builtins.int):
        pulumi.set(__self__, "from_port", from_port)
        pulumi.set(__self__, "to_port", to_port)

    @_builtins.property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> _builtins.int:
        return pulumi.get(self, "from_port")

    @_builtins.property
    @pulumi.getter(name="toPort")
    def to_port(self) -> _builtins.int:
        return pulumi.get(self, "to_port")


@pulumi.output_type
class GetNetworkInsightsPathFilterAtDestinationSourcePortRangeResult(dict):
    def __init__(__self__, *,
                 from_port: _builtins.int,
                 to_port: _builtins.int):
        pulumi.set(__self__, "from_port", from_port)
        pulumi.set(__self__, "to_port", to_port)

    @_builtins.property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> _builtins.int:
        return pulumi.get(self, "from_port")

    @_builtins.property
    @pulumi.getter(name="toPort")
    def to_port(self) -> _builtins.int:
        return pulumi.get(self, "to_port")


@pulumi.output_type
class GetNetworkInsightsPathFilterAtSourceResult(dict):
    def __init__(__self__, *,
                 destination_address: _builtins.str,
                 destination_port_ranges: Sequence['outputs.GetNetworkInsightsPathFilterAtSourceDestinationPortRangeResult'],
                 source_address: _builtins.str,
                 source_port_ranges: Sequence['outputs.GetNetworkInsightsPathFilterAtSourceSourcePortRangeResult']):
        pulumi.set(__self__, "destination_address", destination_address)
        pulumi.set(__self__, "destination_port_ranges", destination_port_ranges)
        pulumi.set(__self__, "source_address", source_address)
        pulumi.set(__self__, "source_port_ranges", source_port_ranges)

    @_builtins.property
    @pulumi.getter(name="destinationAddress")
    def destination_address(self) -> _builtins.str:
        return pulumi.get(self, "destination_address")

    @_builtins.property
    @pulumi.getter(name="destinationPortRanges")
    def destination_port_ranges(self) -> Sequence['outputs.GetNetworkInsightsPathFilterAtSourceDestinationPortRangeResult']:
        return pulumi.get(self, "destination_port_ranges")

    @_builtins.property
    @pulumi.getter(name="sourceAddress")
    def source_address(self) -> _builtins.str:
        return pulumi.get(self, "source_address")

    @_builtins.property
    @pulumi.getter(name="sourcePortRanges")
    def source_port_ranges(self) -> Sequence['outputs.GetNetworkInsightsPathFilterAtSourceSourcePortRangeResult']:
        return pulumi.get(self, "source_port_ranges")


@pulumi.output_type
class GetNetworkInsightsPathFilterAtSourceDestinationPortRangeResult(dict):
    def __init__(__self__, *,
                 from_port: _builtins.int,
                 to_port: _builtins.int):
        pulumi.set(__self__, "from_port", from_port)
        pulumi.set(__self__, "to_port", to_port)

    @_builtins.property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> _builtins.int:
        return pulumi.get(self, "from_port")

    @_builtins.property
    @pulumi.getter(name="toPort")
    def to_port(self) -> _builtins.int:
        return pulumi.get(self, "to_port")


@pulumi.output_type
class GetNetworkInsightsPathFilterAtSourceSourcePortRangeResult(dict):
    def __init__(__self__, *,
                 from_port: _builtins.int,
                 to_port: _builtins.int):
        pulumi.set(__self__, "from_port", from_port)
        pulumi.set(__self__, "to_port", to_port)

    @_builtins.property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> _builtins.int:
        return pulumi.get(self, "from_port")

    @_builtins.property
    @pulumi.getter(name="toPort")
    def to_port(self) -> _builtins.int:
        return pulumi.get(self, "to_port")


@pulumi.output_type
class GetNetworkInterfaceAssociationResult(dict):
    def __init__(__self__, *,
                 allocation_id: _builtins.str,
                 association_id: _builtins.str,
                 carrier_ip: _builtins.str,
                 customer_owned_ip: _builtins.str,
                 ip_owner_id: _builtins.str,
                 public_dns_name: _builtins.str,
                 public_ip: _builtins.str):
        """
        :param _builtins.str allocation_id: Allocation ID.
        :param _builtins.str association_id: Association ID.
        :param _builtins.str carrier_ip: Carrier IP address associated with the network interface. This attribute is only set when the network interface is in a subnet which is associated with a Wavelength Zone.
        :param _builtins.str customer_owned_ip: Customer-owned IP address.
        :param _builtins.str ip_owner_id: ID of the Elastic IP address owner.
        :param _builtins.str public_dns_name: Public DNS name.
        :param _builtins.str public_ip: Address of the Elastic IP address bound to the network interface.
        """
        pulumi.set(__self__, "allocation_id", allocation_id)
        pulumi.set(__self__, "association_id", association_id)
        pulumi.set(__self__, "carrier_ip", carrier_ip)
        pulumi.set(__self__, "customer_owned_ip", customer_owned_ip)
        pulumi.set(__self__, "ip_owner_id", ip_owner_id)
        pulumi.set(__self__, "public_dns_name", public_dns_name)
        pulumi.set(__self__, "public_ip", public_ip)

    @_builtins.property
    @pulumi.getter(name="allocationId")
    def allocation_id(self) -> _builtins.str:
        """
        Allocation ID.
        """
        return pulumi.get(self, "allocation_id")

    @_builtins.property
    @pulumi.getter(name="associationId")
    def association_id(self) -> _builtins.str:
        """
        Association ID.
        """
        return pulumi.get(self, "association_id")

    @_builtins.property
    @pulumi.getter(name="carrierIp")
    def carrier_ip(self) -> _builtins.str:
        """
        Carrier IP address associated with the network interface. This attribute is only set when the network interface is in a subnet which is associated with a Wavelength Zone.
        """
        return pulumi.get(self, "carrier_ip")

    @_builtins.property
    @pulumi.getter(name="customerOwnedIp")
    def customer_owned_ip(self) -> _builtins.str:
        """
        Customer-owned IP address.
        """
        return pulumi.get(self, "customer_owned_ip")

    @_builtins.property
    @pulumi.getter(name="ipOwnerId")
    def ip_owner_id(self) -> _builtins.str:
        """
        ID of the Elastic IP address owner.
        """
        return pulumi.get(self, "ip_owner_id")

    @_builtins.property
    @pulumi.getter(name="publicDnsName")
    def public_dns_name(self) -> _builtins.str:
        """
        Public DNS name.
        """
        return pulumi.get(self, "public_dns_name")

    @_builtins.property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> _builtins.str:
        """
        Address of the Elastic IP address bound to the network interface.
        """
        return pulumi.get(self, "public_ip")


@pulumi.output_type
class GetNetworkInterfaceAttachmentResult(dict):
    def __init__(__self__, *,
                 attachment_id: _builtins.str,
                 device_index: _builtins.int,
                 instance_id: _builtins.str,
                 instance_owner_id: _builtins.str):
        pulumi.set(__self__, "attachment_id", attachment_id)
        pulumi.set(__self__, "device_index", device_index)
        pulumi.set(__self__, "instance_id", instance_id)
        pulumi.set(__self__, "instance_owner_id", instance_owner_id)

    @_builtins.property
    @pulumi.getter(name="attachmentId")
    def attachment_id(self) -> _builtins.str:
        return pulumi.get(self, "attachment_id")

    @_builtins.property
    @pulumi.getter(name="deviceIndex")
    def device_index(self) -> _builtins.int:
        return pulumi.get(self, "device_index")

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> _builtins.str:
        return pulumi.get(self, "instance_id")

    @_builtins.property
    @pulumi.getter(name="instanceOwnerId")
    def instance_owner_id(self) -> _builtins.str:
        return pulumi.get(self, "instance_owner_id")


@pulumi.output_type
class GetNetworkInterfaceFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetNetworkInterfacesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Name of the field to filter by, as defined by
               [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInterfaces.html).
        :param Sequence[_builtins.str] values: Set of values that are accepted for the given field.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the field to filter by, as defined by
        [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInterfaces.html).
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Set of values that are accepted for the given field.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetPrefixListFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Name of the filter field. Valid values can be found in the [EC2 DescribePrefixLists API Reference](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribePrefixLists.html).
        :param Sequence[_builtins.str] values: Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the filter field. Valid values can be found in the [EC2 DescribePrefixLists API Reference](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribePrefixLists.html).
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetPublicIpv4PoolPoolAddressRangeResult(dict):
    def __init__(__self__, *,
                 address_count: _builtins.int,
                 available_address_count: _builtins.int,
                 first_address: _builtins.str,
                 last_address: _builtins.str):
        """
        :param _builtins.int address_count: Number of addresses in the range.
        :param _builtins.int available_address_count: Number of available addresses in the range.
        :param _builtins.str first_address: First address in the range.
        :param _builtins.str last_address: Last address in the range.
        """
        pulumi.set(__self__, "address_count", address_count)
        pulumi.set(__self__, "available_address_count", available_address_count)
        pulumi.set(__self__, "first_address", first_address)
        pulumi.set(__self__, "last_address", last_address)

    @_builtins.property
    @pulumi.getter(name="addressCount")
    def address_count(self) -> _builtins.int:
        """
        Number of addresses in the range.
        """
        return pulumi.get(self, "address_count")

    @_builtins.property
    @pulumi.getter(name="availableAddressCount")
    def available_address_count(self) -> _builtins.int:
        """
        Number of available addresses in the range.
        """
        return pulumi.get(self, "available_address_count")

    @_builtins.property
    @pulumi.getter(name="firstAddress")
    def first_address(self) -> _builtins.str:
        """
        First address in the range.
        """
        return pulumi.get(self, "first_address")

    @_builtins.property
    @pulumi.getter(name="lastAddress")
    def last_address(self) -> _builtins.str:
        """
        Last address in the range.
        """
        return pulumi.get(self, "last_address")


@pulumi.output_type
class GetPublicIpv4PoolsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Name of the field to filter by, as defined by [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribePublicIpv4Pools.html).
        :param Sequence[_builtins.str] values: Set of values that are accepted for the given field. Pool IDs will be selected if any one of the given values match.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the field to filter by, as defined by [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribePublicIpv4Pools.html).
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Set of values that are accepted for the given field. Pool IDs will be selected if any one of the given values match.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetRouteTableAssociationResult(dict):
    def __init__(__self__, *,
                 gateway_id: _builtins.str,
                 main: _builtins.bool,
                 route_table_association_id: _builtins.str,
                 route_table_id: _builtins.str,
                 subnet_id: _builtins.str):
        """
        :param _builtins.str gateway_id: ID of an Internet Gateway or Virtual Private Gateway which is connected to the Route Table (not exported if not passed as a parameter).
        :param _builtins.bool main: Whether the association is due to the main route table.
        :param _builtins.str route_table_association_id: Association ID.
        :param _builtins.str route_table_id: ID of the specific Route Table to retrieve.
        :param _builtins.str subnet_id: ID of a Subnet which is connected to the Route Table (not exported if not passed as a parameter).
        """
        pulumi.set(__self__, "gateway_id", gateway_id)
        pulumi.set(__self__, "main", main)
        pulumi.set(__self__, "route_table_association_id", route_table_association_id)
        pulumi.set(__self__, "route_table_id", route_table_id)
        pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="gatewayId")
    def gateway_id(self) -> _builtins.str:
        """
        ID of an Internet Gateway or Virtual Private Gateway which is connected to the Route Table (not exported if not passed as a parameter).
        """
        return pulumi.get(self, "gateway_id")

    @_builtins.property
    @pulumi.getter
    def main(self) -> _builtins.bool:
        """
        Whether the association is due to the main route table.
        """
        return pulumi.get(self, "main")

    @_builtins.property
    @pulumi.getter(name="routeTableAssociationId")
    def route_table_association_id(self) -> _builtins.str:
        """
        Association ID.
        """
        return pulumi.get(self, "route_table_association_id")

    @_builtins.property
    @pulumi.getter(name="routeTableId")
    def route_table_id(self) -> _builtins.str:
        """
        ID of the specific Route Table to retrieve.
        """
        return pulumi.get(self, "route_table_id")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        ID of a Subnet which is connected to the Route Table (not exported if not passed as a parameter).
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class GetRouteTableFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Name of the field to filter by, as defined by [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeRouteTables.html).
        :param Sequence[_builtins.str] values: Set of values that are accepted for the given field. A Route Table will be selected if any one of the given values matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the field to filter by, as defined by [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeRouteTables.html).
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Set of values that are accepted for the given field. A Route Table will be selected if any one of the given values matches.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetRouteTableRouteResult(dict):
    def __init__(__self__, *,
                 carrier_gateway_id: _builtins.str,
                 cidr_block: _builtins.str,
                 core_network_arn: _builtins.str,
                 destination_prefix_list_id: _builtins.str,
                 egress_only_gateway_id: _builtins.str,
                 gateway_id: _builtins.str,
                 instance_id: _builtins.str,
                 ipv6_cidr_block: _builtins.str,
                 local_gateway_id: _builtins.str,
                 nat_gateway_id: _builtins.str,
                 network_interface_id: _builtins.str,
                 transit_gateway_id: _builtins.str,
                 vpc_endpoint_id: _builtins.str,
                 vpc_peering_connection_id: _builtins.str):
        """
        :param _builtins.str carrier_gateway_id: ID of the Carrier Gateway.
        :param _builtins.str cidr_block: CIDR block of the route.
        :param _builtins.str core_network_arn: ARN of the core network.
        :param _builtins.str destination_prefix_list_id: The ID of a managed prefix list destination of the route.
        :param _builtins.str egress_only_gateway_id: ID of the Egress Only Internet Gateway.
        :param _builtins.str gateway_id: ID of an Internet Gateway or Virtual Private Gateway which is connected to the Route Table (not exported if not passed as a parameter).
        :param _builtins.str instance_id: EC2 instance ID.
        :param _builtins.str ipv6_cidr_block: IPv6 CIDR block of the route.
        :param _builtins.str local_gateway_id: Local Gateway ID.
        :param _builtins.str nat_gateway_id: NAT Gateway ID.
        :param _builtins.str network_interface_id: ID of the elastic network interface (eni) to use.
        :param _builtins.str transit_gateway_id: EC2 Transit Gateway ID.
        :param _builtins.str vpc_endpoint_id: VPC Endpoint ID.
        :param _builtins.str vpc_peering_connection_id: VPC Peering ID.
        """
        pulumi.set(__self__, "carrier_gateway_id", carrier_gateway_id)
        pulumi.set(__self__, "cidr_block", cidr_block)
        pulumi.set(__self__, "core_network_arn", core_network_arn)
        pulumi.set(__self__, "destination_prefix_list_id", destination_prefix_list_id)
        pulumi.set(__self__, "egress_only_gateway_id", egress_only_gateway_id)
        pulumi.set(__self__, "gateway_id", gateway_id)
        pulumi.set(__self__, "instance_id", instance_id)
        pulumi.set(__self__, "ipv6_cidr_block", ipv6_cidr_block)
        pulumi.set(__self__, "local_gateway_id", local_gateway_id)
        pulumi.set(__self__, "nat_gateway_id", nat_gateway_id)
        pulumi.set(__self__, "network_interface_id", network_interface_id)
        pulumi.set(__self__, "transit_gateway_id", transit_gateway_id)
        pulumi.set(__self__, "vpc_endpoint_id", vpc_endpoint_id)
        pulumi.set(__self__, "vpc_peering_connection_id", vpc_peering_connection_id)

    @_builtins.property
    @pulumi.getter(name="carrierGatewayId")
    def carrier_gateway_id(self) -> _builtins.str:
        """
        ID of the Carrier Gateway.
        """
        return pulumi.get(self, "carrier_gateway_id")

    @_builtins.property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> _builtins.str:
        """
        CIDR block of the route.
        """
        return pulumi.get(self, "cidr_block")

    @_builtins.property
    @pulumi.getter(name="coreNetworkArn")
    def core_network_arn(self) -> _builtins.str:
        """
        ARN of the core network.
        """
        return pulumi.get(self, "core_network_arn")

    @_builtins.property
    @pulumi.getter(name="destinationPrefixListId")
    def destination_prefix_list_id(self) -> _builtins.str:
        """
        The ID of a managed prefix list destination of the route.
        """
        return pulumi.get(self, "destination_prefix_list_id")

    @_builtins.property
    @pulumi.getter(name="egressOnlyGatewayId")
    def egress_only_gateway_id(self) -> _builtins.str:
        """
        ID of the Egress Only Internet Gateway.
        """
        return pulumi.get(self, "egress_only_gateway_id")

    @_builtins.property
    @pulumi.getter(name="gatewayId")
    def gateway_id(self) -> _builtins.str:
        """
        ID of an Internet Gateway or Virtual Private Gateway which is connected to the Route Table (not exported if not passed as a parameter).
        """
        return pulumi.get(self, "gateway_id")

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> _builtins.str:
        """
        EC2 instance ID.
        """
        return pulumi.get(self, "instance_id")

    @_builtins.property
    @pulumi.getter(name="ipv6CidrBlock")
    def ipv6_cidr_block(self) -> _builtins.str:
        """
        IPv6 CIDR block of the route.
        """
        return pulumi.get(self, "ipv6_cidr_block")

    @_builtins.property
    @pulumi.getter(name="localGatewayId")
    def local_gateway_id(self) -> _builtins.str:
        """
        Local Gateway ID.
        """
        return pulumi.get(self, "local_gateway_id")

    @_builtins.property
    @pulumi.getter(name="natGatewayId")
    def nat_gateway_id(self) -> _builtins.str:
        """
        NAT Gateway ID.
        """
        return pulumi.get(self, "nat_gateway_id")

    @_builtins.property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> _builtins.str:
        """
        ID of the elastic network interface (eni) to use.
        """
        return pulumi.get(self, "network_interface_id")

    @_builtins.property
    @pulumi.getter(name="transitGatewayId")
    def transit_gateway_id(self) -> _builtins.str:
        """
        EC2 Transit Gateway ID.
        """
        return pulumi.get(self, "transit_gateway_id")

    @_builtins.property
    @pulumi.getter(name="vpcEndpointId")
    def vpc_endpoint_id(self) -> _builtins.str:
        """
        VPC Endpoint ID.
        """
        return pulumi.get(self, "vpc_endpoint_id")

    @_builtins.property
    @pulumi.getter(name="vpcPeeringConnectionId")
    def vpc_peering_connection_id(self) -> _builtins.str:
        """
        VPC Peering ID.
        """
        return pulumi.get(self, "vpc_peering_connection_id")


@pulumi.output_type
class GetRouteTablesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Name of the field to filter by, as defined by
               [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeRouteTables.html).
        :param Sequence[_builtins.str] values: Set of values that are accepted for the given field.
               A Route Table will be selected if any one of the given values matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the field to filter by, as defined by
        [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeRouteTables.html).
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Set of values that are accepted for the given field.
        A Route Table will be selected if any one of the given values matches.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetSecurityGroupFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Name of the field to filter by, as defined by
               [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeSecurityGroups.html).
        :param Sequence[_builtins.str] values: Set of values that are accepted for the given field.
               A Security Group will be selected if any one of the given values matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the field to filter by, as defined by
        [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeSecurityGroups.html).
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Set of values that are accepted for the given field.
        A Security Group will be selected if any one of the given values matches.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetSecurityGroupsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetSpotPriceFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Name of the filter.
        :param Sequence[_builtins.str] values: List of one or more values for the filter.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the filter.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        List of one or more values for the filter.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetSubnetFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Name of the field to filter by, as defined by [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeSubnets.html).
        :param Sequence[_builtins.str] values: Set of values that are accepted for the given field. A subnet will be selected if any one of the given values matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the field to filter by, as defined by [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeSubnets.html).
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Set of values that are accepted for the given field. A subnet will be selected if any one of the given values matches.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetSubnetsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Name of the field to filter by, as defined by
               [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeSubnets.html).
               For example, if matching against tag `Name`, use:
        :param Sequence[_builtins.str] values: Set of values that are accepted for the given field.
               Subnet IDs will be selected if any one of the given values match.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the field to filter by, as defined by
        [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeSubnets.html).
        For example, if matching against tag `Name`, use:
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Set of values that are accepted for the given field.
        Subnet IDs will be selected if any one of the given values match.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetTransitGatewayRouteTablesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Name of the field to filter by, as defined by
               [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeTransitGatewayRouteTables.html).
        :param Sequence[_builtins.str] values: Set of values that are accepted for the given field.
               A Transit Gateway Route Table will be selected if any one of the given values matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the field to filter by, as defined by
        [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeTransitGatewayRouteTables.html).
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Set of values that are accepted for the given field.
        A Transit Gateway Route Table will be selected if any one of the given values matches.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetVpcCidrBlockAssociationResult(dict):
    def __init__(__self__, *,
                 association_id: _builtins.str,
                 cidr_block: _builtins.str,
                 state: _builtins.str):
        """
        :param _builtins.str association_id: Association ID for the IPv4 CIDR block.
        :param _builtins.str cidr_block: Cidr block of the desired VPC.
        :param _builtins.str state: Current state of the desired VPC.
               Can be either `"pending"` or `"available"`.
        """
        pulumi.set(__self__, "association_id", association_id)
        pulumi.set(__self__, "cidr_block", cidr_block)
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="associationId")
    def association_id(self) -> _builtins.str:
        """
        Association ID for the IPv4 CIDR block.
        """
        return pulumi.get(self, "association_id")

    @_builtins.property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> _builtins.str:
        """
        Cidr block of the desired VPC.
        """
        return pulumi.get(self, "cidr_block")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        Current state of the desired VPC.
        Can be either `"pending"` or `"available"`.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetVpcDhcpOptionsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Name of the field to filter.
        :param Sequence[_builtins.str] values: Set of values for filtering.
               
               For more information about filtering, see the [EC2 API documentation](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeDhcpOptions.html).
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the field to filter.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Set of values for filtering.

        For more information about filtering, see the [EC2 API documentation](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeDhcpOptions.html).
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetVpcEndpointDnsEntryResult(dict):
    def __init__(__self__, *,
                 dns_name: _builtins.str,
                 hosted_zone_id: _builtins.str):
        """
        :param _builtins.str dns_name: DNS name.
        :param _builtins.str hosted_zone_id: ID of the private hosted zone.
        """
        pulumi.set(__self__, "dns_name", dns_name)
        pulumi.set(__self__, "hosted_zone_id", hosted_zone_id)

    @_builtins.property
    @pulumi.getter(name="dnsName")
    def dns_name(self) -> _builtins.str:
        """
        DNS name.
        """
        return pulumi.get(self, "dns_name")

    @_builtins.property
    @pulumi.getter(name="hostedZoneId")
    def hosted_zone_id(self) -> _builtins.str:
        """
        ID of the private hosted zone.
        """
        return pulumi.get(self, "hosted_zone_id")


@pulumi.output_type
class GetVpcEndpointDnsOptionResult(dict):
    def __init__(__self__, *,
                 dns_record_ip_type: _builtins.str,
                 private_dns_only_for_inbound_resolver_endpoint: _builtins.bool):
        """
        :param _builtins.str dns_record_ip_type: The DNS records created for the endpoint.
        :param _builtins.bool private_dns_only_for_inbound_resolver_endpoint: Indicates whether to enable private DNS only for inbound endpoints.
        """
        pulumi.set(__self__, "dns_record_ip_type", dns_record_ip_type)
        pulumi.set(__self__, "private_dns_only_for_inbound_resolver_endpoint", private_dns_only_for_inbound_resolver_endpoint)

    @_builtins.property
    @pulumi.getter(name="dnsRecordIpType")
    def dns_record_ip_type(self) -> _builtins.str:
        """
        The DNS records created for the endpoint.
        """
        return pulumi.get(self, "dns_record_ip_type")

    @_builtins.property
    @pulumi.getter(name="privateDnsOnlyForInboundResolverEndpoint")
    def private_dns_only_for_inbound_resolver_endpoint(self) -> _builtins.bool:
        """
        Indicates whether to enable private DNS only for inbound endpoints.
        """
        return pulumi.get(self, "private_dns_only_for_inbound_resolver_endpoint")


@pulumi.output_type
class GetVpcEndpointFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Name of the field to filter by, as defined by
               [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcEndpoints.html).
        :param Sequence[_builtins.str] values: Set of values that are accepted for the given field.
               A VPC Endpoint will be selected if any one of the given values matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the field to filter by, as defined by
        [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcEndpoints.html).
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Set of values that are accepted for the given field.
        A VPC Endpoint will be selected if any one of the given values matches.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetVpcEndpointServiceFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Name of the filter field. Valid values can be found in the [EC2 DescribeVpcEndpointServices API Reference](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcEndpointServices.html).
        :param Sequence[_builtins.str] values: Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the filter field. Valid values can be found in the [EC2 DescribeVpcEndpointServices API Reference](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcEndpointServices.html).
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetVpcFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Name of the field to filter by, as defined by
               [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcs.html).
        :param Sequence[_builtins.str] values: Set of values that are accepted for the given field.
               A VPC will be selected if any one of the given values matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the field to filter by, as defined by
        [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcs.html).
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Set of values that are accepted for the given field.
        A VPC will be selected if any one of the given values matches.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetVpcIpamOperatingRegionResult(dict):
    def __init__(__self__, *,
                 region_name: _builtins.str):
        pulumi.set(__self__, "region_name", region_name)

    @_builtins.property
    @pulumi.getter(name="regionName")
    def region_name(self) -> _builtins.str:
        return pulumi.get(self, "region_name")


@pulumi.output_type
class GetVpcIpamPoolCidrsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Name of the field to filter by, as defined by
               [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetIpamPoolCidrs.html).
        :param Sequence[_builtins.str] values: Set of values that are accepted for the given field.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the field to filter by, as defined by
        [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetIpamPoolCidrs.html).
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Set of values that are accepted for the given field.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetVpcIpamPoolCidrsIpamPoolCidrResult(dict):
    def __init__(__self__, *,
                 cidr: _builtins.str,
                 state: _builtins.str):
        """
        :param _builtins.str cidr: A network CIDR.
        :param _builtins.str state: The provisioning state of that CIDR.
        """
        pulumi.set(__self__, "cidr", cidr)
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def cidr(self) -> _builtins.str:
        """
        A network CIDR.
        """
        return pulumi.get(self, "cidr")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        The provisioning state of that CIDR.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetVpcIpamPoolFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: The name of the filter. Filter names are case-sensitive.
        :param Sequence[_builtins.str] values: The filter values. Filter values are case-sensitive.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the filter. Filter names are case-sensitive.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        The filter values. Filter values are case-sensitive.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetVpcIpamPoolsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: The name of the filter. Filter names are case-sensitive.
        :param Sequence[_builtins.str] values: The filter values. Filter values are case-sensitive.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the filter. Filter names are case-sensitive.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        The filter values. Filter values are case-sensitive.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetVpcIpamPoolsIpamPoolResult(dict):
    def __init__(__self__, *,
                 address_family: _builtins.str,
                 allocation_default_netmask_length: _builtins.int,
                 allocation_max_netmask_length: _builtins.int,
                 allocation_min_netmask_length: _builtins.int,
                 allocation_resource_tags: Mapping[str, _builtins.str],
                 arn: _builtins.str,
                 auto_import: _builtins.bool,
                 aws_service: _builtins.str,
                 description: _builtins.str,
                 id: _builtins.str,
                 ipam_scope_id: _builtins.str,
                 ipam_scope_type: _builtins.str,
                 locale: _builtins.str,
                 pool_depth: _builtins.int,
                 publicly_advertisable: _builtins.bool,
                 source_ipam_pool_id: _builtins.str,
                 state: _builtins.str,
                 tags: Mapping[str, _builtins.str]):
        """
        :param _builtins.str address_family: IP protocol assigned to this pool.
        :param _builtins.int allocation_default_netmask_length: A default netmask length for allocations added to this pool. If, for example, the CIDR assigned to this pool is `10.0.0.0/8` and you enter 16 here, new allocations will default to `10.0.0.0/16`.
        :param _builtins.int allocation_max_netmask_length: The maximum netmask length that will be required for CIDR allocations in this pool.
        :param _builtins.int allocation_min_netmask_length: The minimum netmask length that will be required for CIDR allocations in this pool.
        :param Mapping[str, _builtins.str] allocation_resource_tags: Tags that are required to create resources in using this pool.
        :param _builtins.str arn: ARN of the pool
        :param _builtins.bool auto_import: If enabled, IPAM will continuously look for resources within the CIDR range of this pool and automatically import them as allocations into your IPAM.
        :param _builtins.str aws_service: Limits which service in AWS that the pool can be used in. `ec2` for example, allows users to use space for Elastic IP addresses and VPCs.
        :param _builtins.str description: Description for the IPAM pool.
        :param _builtins.str id: ID of the IPAM pool.
        :param _builtins.str ipam_scope_id: ID of the scope the pool belongs to.
        :param _builtins.str locale: Locale is the Region where your pool is available for allocations. You can only create pools with locales that match the operating Regions of the IPAM. You can only create VPCs from a pool whose locale matches the VPC's Region.
        :param _builtins.bool publicly_advertisable: Defines whether or not IPv6 pool space is publicly advertisable over the internet.
        :param _builtins.str source_ipam_pool_id: ID of the source IPAM pool.
        :param Mapping[str, _builtins.str] tags: Map of tags to assigned to the resource.
        """
        pulumi.set(__self__, "address_family", address_family)
        pulumi.set(__self__, "allocation_default_netmask_length", allocation_default_netmask_length)
        pulumi.set(__self__, "allocation_max_netmask_length", allocation_max_netmask_length)
        pulumi.set(__self__, "allocation_min_netmask_length", allocation_min_netmask_length)
        pulumi.set(__self__, "allocation_resource_tags", allocation_resource_tags)
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "auto_import", auto_import)
        pulumi.set(__self__, "aws_service", aws_service)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ipam_scope_id", ipam_scope_id)
        pulumi.set(__self__, "ipam_scope_type", ipam_scope_type)
        pulumi.set(__self__, "locale", locale)
        pulumi.set(__self__, "pool_depth", pool_depth)
        pulumi.set(__self__, "publicly_advertisable", publicly_advertisable)
        pulumi.set(__self__, "source_ipam_pool_id", source_ipam_pool_id)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="addressFamily")
    def address_family(self) -> _builtins.str:
        """
        IP protocol assigned to this pool.
        """
        return pulumi.get(self, "address_family")

    @_builtins.property
    @pulumi.getter(name="allocationDefaultNetmaskLength")
    def allocation_default_netmask_length(self) -> _builtins.int:
        """
        A default netmask length for allocations added to this pool. If, for example, the CIDR assigned to this pool is `10.0.0.0/8` and you enter 16 here, new allocations will default to `10.0.0.0/16`.
        """
        return pulumi.get(self, "allocation_default_netmask_length")

    @_builtins.property
    @pulumi.getter(name="allocationMaxNetmaskLength")
    def allocation_max_netmask_length(self) -> _builtins.int:
        """
        The maximum netmask length that will be required for CIDR allocations in this pool.
        """
        return pulumi.get(self, "allocation_max_netmask_length")

    @_builtins.property
    @pulumi.getter(name="allocationMinNetmaskLength")
    def allocation_min_netmask_length(self) -> _builtins.int:
        """
        The minimum netmask length that will be required for CIDR allocations in this pool.
        """
        return pulumi.get(self, "allocation_min_netmask_length")

    @_builtins.property
    @pulumi.getter(name="allocationResourceTags")
    def allocation_resource_tags(self) -> Mapping[str, _builtins.str]:
        """
        Tags that are required to create resources in using this pool.
        """
        return pulumi.get(self, "allocation_resource_tags")

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        """
        ARN of the pool
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter(name="autoImport")
    def auto_import(self) -> _builtins.bool:
        """
        If enabled, IPAM will continuously look for resources within the CIDR range of this pool and automatically import them as allocations into your IPAM.
        """
        return pulumi.get(self, "auto_import")

    @_builtins.property
    @pulumi.getter(name="awsService")
    def aws_service(self) -> _builtins.str:
        """
        Limits which service in AWS that the pool can be used in. `ec2` for example, allows users to use space for Elastic IP addresses and VPCs.
        """
        return pulumi.get(self, "aws_service")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Description for the IPAM pool.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        ID of the IPAM pool.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="ipamScopeId")
    def ipam_scope_id(self) -> _builtins.str:
        """
        ID of the scope the pool belongs to.
        """
        return pulumi.get(self, "ipam_scope_id")

    @_builtins.property
    @pulumi.getter(name="ipamScopeType")
    def ipam_scope_type(self) -> _builtins.str:
        return pulumi.get(self, "ipam_scope_type")

    @_builtins.property
    @pulumi.getter
    def locale(self) -> _builtins.str:
        """
        Locale is the Region where your pool is available for allocations. You can only create pools with locales that match the operating Regions of the IPAM. You can only create VPCs from a pool whose locale matches the VPC's Region.
        """
        return pulumi.get(self, "locale")

    @_builtins.property
    @pulumi.getter(name="poolDepth")
    def pool_depth(self) -> _builtins.int:
        return pulumi.get(self, "pool_depth")

    @_builtins.property
    @pulumi.getter(name="publiclyAdvertisable")
    def publicly_advertisable(self) -> _builtins.bool:
        """
        Defines whether or not IPv6 pool space is publicly advertisable over the internet.
        """
        return pulumi.get(self, "publicly_advertisable")

    @_builtins.property
    @pulumi.getter(name="sourceIpamPoolId")
    def source_ipam_pool_id(self) -> _builtins.str:
        """
        ID of the source IPAM pool.
        """
        return pulumi.get(self, "source_ipam_pool_id")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Mapping[str, _builtins.str]:
        """
        Map of tags to assigned to the resource.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetVpcIpamsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Name of the field to filter by, as defined by
               [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeIpams.html).
        :param Sequence[_builtins.str] values: Set of values that are accepted for the given field.
               An IPAM resource will be selected if any one of the given values matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the field to filter by, as defined by
        [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeIpams.html).
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Set of values that are accepted for the given field.
        An IPAM resource will be selected if any one of the given values matches.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetVpcIpamsIpamResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 default_resource_discovery_association_id: _builtins.str,
                 default_resource_discovery_id: _builtins.str,
                 description: _builtins.str,
                 enable_private_gua: _builtins.bool,
                 id: _builtins.str,
                 ipam_region: _builtins.str,
                 operating_regions: Sequence['outputs.GetVpcIpamsIpamOperatingRegionResult'],
                 owner_id: _builtins.str,
                 private_default_scope_id: _builtins.str,
                 public_default_scope_id: _builtins.str,
                 resource_discovery_association_count: _builtins.int,
                 scope_count: _builtins.int,
                 state: _builtins.str,
                 state_message: _builtins.str,
                 tier: _builtins.str):
        """
        :param _builtins.str arn: ARN of the IPAM.
        :param _builtins.str default_resource_discovery_association_id: The default resource discovery association ID.
        :param _builtins.str default_resource_discovery_id: The default resource discovery ID.
        :param _builtins.str description: Description for the IPAM.
        :param _builtins.bool enable_private_gua: If private GUA is enabled.
        :param _builtins.str id: ID of the IPAM resource.
        :param _builtins.str ipam_region: Region that the IPAM exists in.
        :param Sequence['GetVpcIpamsIpamOperatingRegionArgs'] operating_regions: Regions that the IPAM is configured to operate in.
        :param _builtins.str owner_id: ID of the account that owns this IPAM.
        :param _builtins.str private_default_scope_id: ID of the default private scope.
        :param _builtins.str public_default_scope_id: ID of the default public scope.
        :param _builtins.int resource_discovery_association_count: Number of resource discovery associations.
        :param _builtins.int scope_count: Number of scopes on this IPAM.
        :param _builtins.str state: Current state of the IPAM.
        :param _builtins.str state_message: State message of the IPAM.
        :param _builtins.str tier: IPAM Tier.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "default_resource_discovery_association_id", default_resource_discovery_association_id)
        pulumi.set(__self__, "default_resource_discovery_id", default_resource_discovery_id)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "enable_private_gua", enable_private_gua)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ipam_region", ipam_region)
        pulumi.set(__self__, "operating_regions", operating_regions)
        pulumi.set(__self__, "owner_id", owner_id)
        pulumi.set(__self__, "private_default_scope_id", private_default_scope_id)
        pulumi.set(__self__, "public_default_scope_id", public_default_scope_id)
        pulumi.set(__self__, "resource_discovery_association_count", resource_discovery_association_count)
        pulumi.set(__self__, "scope_count", scope_count)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "state_message", state_message)
        pulumi.set(__self__, "tier", tier)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        """
        ARN of the IPAM.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter(name="defaultResourceDiscoveryAssociationId")
    def default_resource_discovery_association_id(self) -> _builtins.str:
        """
        The default resource discovery association ID.
        """
        return pulumi.get(self, "default_resource_discovery_association_id")

    @_builtins.property
    @pulumi.getter(name="defaultResourceDiscoveryId")
    def default_resource_discovery_id(self) -> _builtins.str:
        """
        The default resource discovery ID.
        """
        return pulumi.get(self, "default_resource_discovery_id")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Description for the IPAM.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="enablePrivateGua")
    def enable_private_gua(self) -> _builtins.bool:
        """
        If private GUA is enabled.
        """
        return pulumi.get(self, "enable_private_gua")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        ID of the IPAM resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="ipamRegion")
    def ipam_region(self) -> _builtins.str:
        """
        Region that the IPAM exists in.
        """
        return pulumi.get(self, "ipam_region")

    @_builtins.property
    @pulumi.getter(name="operatingRegions")
    def operating_regions(self) -> Sequence['outputs.GetVpcIpamsIpamOperatingRegionResult']:
        """
        Regions that the IPAM is configured to operate in.
        """
        return pulumi.get(self, "operating_regions")

    @_builtins.property
    @pulumi.getter(name="ownerId")
    def owner_id(self) -> _builtins.str:
        """
        ID of the account that owns this IPAM.
        """
        return pulumi.get(self, "owner_id")

    @_builtins.property
    @pulumi.getter(name="privateDefaultScopeId")
    def private_default_scope_id(self) -> _builtins.str:
        """
        ID of the default private scope.
        """
        return pulumi.get(self, "private_default_scope_id")

    @_builtins.property
    @pulumi.getter(name="publicDefaultScopeId")
    def public_default_scope_id(self) -> _builtins.str:
        """
        ID of the default public scope.
        """
        return pulumi.get(self, "public_default_scope_id")

    @_builtins.property
    @pulumi.getter(name="resourceDiscoveryAssociationCount")
    def resource_discovery_association_count(self) -> _builtins.int:
        """
        Number of resource discovery associations.
        """
        return pulumi.get(self, "resource_discovery_association_count")

    @_builtins.property
    @pulumi.getter(name="scopeCount")
    def scope_count(self) -> _builtins.int:
        """
        Number of scopes on this IPAM.
        """
        return pulumi.get(self, "scope_count")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        Current state of the IPAM.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="stateMessage")
    def state_message(self) -> _builtins.str:
        """
        State message of the IPAM.
        """
        return pulumi.get(self, "state_message")

    @_builtins.property
    @pulumi.getter
    def tier(self) -> _builtins.str:
        """
        IPAM Tier.
        """
        return pulumi.get(self, "tier")


@pulumi.output_type
class GetVpcIpamsIpamOperatingRegionResult(dict):
    def __init__(__self__, *,
                 region_name: _builtins.str):
        pulumi.set(__self__, "region_name", region_name)

    @_builtins.property
    @pulumi.getter(name="regionName")
    def region_name(self) -> _builtins.str:
        return pulumi.get(self, "region_name")


@pulumi.output_type
class GetVpcPeeringConnectionCidrBlockSetResult(dict):
    def __init__(__self__, *,
                 cidr_block: _builtins.str):
        """
        :param _builtins.str cidr_block: Primary CIDR block of the requester VPC of the specific VPC Peering Connection to retrieve.
        """
        pulumi.set(__self__, "cidr_block", cidr_block)

    @_builtins.property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> _builtins.str:
        """
        Primary CIDR block of the requester VPC of the specific VPC Peering Connection to retrieve.
        """
        return pulumi.get(self, "cidr_block")


@pulumi.output_type
class GetVpcPeeringConnectionFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Name of the field to filter by, as defined by
               [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcPeeringConnections.html).
        :param Sequence[_builtins.str] values: Set of values that are accepted for the given field.
               A VPC Peering Connection will be selected if any one of the given values matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the field to filter by, as defined by
        [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcPeeringConnections.html).
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Set of values that are accepted for the given field.
        A VPC Peering Connection will be selected if any one of the given values matches.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetVpcPeeringConnectionIpv6CidrBlockSetResult(dict):
    def __init__(__self__, *,
                 ipv6_cidr_block: _builtins.str):
        pulumi.set(__self__, "ipv6_cidr_block", ipv6_cidr_block)

    @_builtins.property
    @pulumi.getter(name="ipv6CidrBlock")
    def ipv6_cidr_block(self) -> _builtins.str:
        return pulumi.get(self, "ipv6_cidr_block")


@pulumi.output_type
class GetVpcPeeringConnectionPeerCidrBlockSetResult(dict):
    def __init__(__self__, *,
                 cidr_block: _builtins.str):
        """
        :param _builtins.str cidr_block: Primary CIDR block of the requester VPC of the specific VPC Peering Connection to retrieve.
        """
        pulumi.set(__self__, "cidr_block", cidr_block)

    @_builtins.property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> _builtins.str:
        """
        Primary CIDR block of the requester VPC of the specific VPC Peering Connection to retrieve.
        """
        return pulumi.get(self, "cidr_block")


@pulumi.output_type
class GetVpcPeeringConnectionPeerIpv6CidrBlockSetResult(dict):
    def __init__(__self__, *,
                 ipv6_cidr_block: _builtins.str):
        pulumi.set(__self__, "ipv6_cidr_block", ipv6_cidr_block)

    @_builtins.property
    @pulumi.getter(name="ipv6CidrBlock")
    def ipv6_cidr_block(self) -> _builtins.str:
        return pulumi.get(self, "ipv6_cidr_block")


@pulumi.output_type
class GetVpcPeeringConnectionsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Name of the field to filter by, as defined by
               [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcPeeringConnections.html).
        :param Sequence[_builtins.str] values: Set of values that are accepted for the given field.
               A VPC Peering Connection will be selected if any one of the given values matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the field to filter by, as defined by
        [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcPeeringConnections.html).
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Set of values that are accepted for the given field.
        A VPC Peering Connection will be selected if any one of the given values matches.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetVpcsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Name of the field to filter by, as defined by
               [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcs.html).
        :param Sequence[_builtins.str] values: Set of values that are accepted for the given field.
               A VPC will be selected if any one of the given values matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the field to filter by, as defined by
        [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcs.html).
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Set of values that are accepted for the given field.
        A VPC will be selected if any one of the given values matches.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetVpnGatewayFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Name of the field to filter by, as defined by
               [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpnGateways.html).
        :param Sequence[_builtins.str] values: Set of values that are accepted for the given field.
               A VPN Gateway will be selected if any one of the given values matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the field to filter by, as defined by
        [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpnGateways.html).
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Set of values that are accepted for the given field.
        A VPN Gateway will be selected if any one of the given values matches.
        """
        return pulumi.get(self, "values")


