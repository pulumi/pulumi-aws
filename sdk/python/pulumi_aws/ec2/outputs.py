# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AmiCopyEbsBlockDevice',
    'AmiCopyEphemeralBlockDevice',
    'AmiEbsBlockDevice',
    'AmiEphemeralBlockDevice',
    'AmiFromInstanceEbsBlockDevice',
    'AmiFromInstanceEphemeralBlockDevice',
    'DefaultNetworkAclEgress',
    'DefaultNetworkAclIngress',
    'DefaultRouteTableRoute',
    'DefaultSecurityGroupEgress',
    'DefaultSecurityGroupIngress',
    'FleetFleetInstanceSet',
    'FleetLaunchTemplateConfig',
    'FleetLaunchTemplateConfigLaunchTemplateSpecification',
    'FleetLaunchTemplateConfigOverride',
    'FleetLaunchTemplateConfigOverrideInstanceRequirements',
    'FleetLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorCount',
    'FleetLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorTotalMemoryMib',
    'FleetLaunchTemplateConfigOverrideInstanceRequirementsBaselineEbsBandwidthMbps',
    'FleetLaunchTemplateConfigOverrideInstanceRequirementsMemoryGibPerVcpu',
    'FleetLaunchTemplateConfigOverrideInstanceRequirementsMemoryMib',
    'FleetLaunchTemplateConfigOverrideInstanceRequirementsNetworkBandwidthGbps',
    'FleetLaunchTemplateConfigOverrideInstanceRequirementsNetworkInterfaceCount',
    'FleetLaunchTemplateConfigOverrideInstanceRequirementsTotalLocalStorageGb',
    'FleetLaunchTemplateConfigOverrideInstanceRequirementsVcpuCount',
    'FleetOnDemandOptions',
    'FleetSpotOptions',
    'FleetSpotOptionsMaintenanceStrategies',
    'FleetSpotOptionsMaintenanceStrategiesCapacityRebalance',
    'FleetTargetCapacitySpecification',
    'FlowLogDestinationOptions',
    'InstanceCapacityReservationSpecification',
    'InstanceCapacityReservationSpecificationCapacityReservationTarget',
    'InstanceCpuOptions',
    'InstanceCreditSpecification',
    'InstanceEbsBlockDevice',
    'InstanceEnclaveOptions',
    'InstanceEphemeralBlockDevice',
    'InstanceInstanceMarketOptions',
    'InstanceInstanceMarketOptionsSpotOptions',
    'InstanceLaunchTemplate',
    'InstanceMaintenanceOptions',
    'InstanceMetadataOptions',
    'InstanceNetworkInterface',
    'InstancePrivateDnsNameOptions',
    'InstanceRootBlockDevice',
    'LaunchConfigurationEbsBlockDevice',
    'LaunchConfigurationEphemeralBlockDevice',
    'LaunchConfigurationMetadataOptions',
    'LaunchConfigurationRootBlockDevice',
    'LaunchTemplateBlockDeviceMapping',
    'LaunchTemplateBlockDeviceMappingEbs',
    'LaunchTemplateCapacityReservationSpecification',
    'LaunchTemplateCapacityReservationSpecificationCapacityReservationTarget',
    'LaunchTemplateCpuOptions',
    'LaunchTemplateCreditSpecification',
    'LaunchTemplateElasticGpuSpecification',
    'LaunchTemplateElasticInferenceAccelerator',
    'LaunchTemplateEnclaveOptions',
    'LaunchTemplateHibernationOptions',
    'LaunchTemplateIamInstanceProfile',
    'LaunchTemplateInstanceMarketOptions',
    'LaunchTemplateInstanceMarketOptionsSpotOptions',
    'LaunchTemplateInstanceRequirements',
    'LaunchTemplateInstanceRequirementsAcceleratorCount',
    'LaunchTemplateInstanceRequirementsAcceleratorTotalMemoryMib',
    'LaunchTemplateInstanceRequirementsBaselineEbsBandwidthMbps',
    'LaunchTemplateInstanceRequirementsMemoryGibPerVcpu',
    'LaunchTemplateInstanceRequirementsMemoryMib',
    'LaunchTemplateInstanceRequirementsNetworkBandwidthGbps',
    'LaunchTemplateInstanceRequirementsNetworkInterfaceCount',
    'LaunchTemplateInstanceRequirementsTotalLocalStorageGb',
    'LaunchTemplateInstanceRequirementsVcpuCount',
    'LaunchTemplateLicenseSpecification',
    'LaunchTemplateMaintenanceOptions',
    'LaunchTemplateMetadataOptions',
    'LaunchTemplateMonitoring',
    'LaunchTemplateNetworkInterface',
    'LaunchTemplatePlacement',
    'LaunchTemplatePrivateDnsNameOptions',
    'LaunchTemplateTagSpecification',
    'ManagedPrefixListEntry',
    'NetworkAclEgress',
    'NetworkAclIngress',
    'NetworkInsightsAnalysisAlternatePathHint',
    'NetworkInsightsAnalysisExplanation',
    'NetworkInsightsAnalysisExplanationAcl',
    'NetworkInsightsAnalysisExplanationAclRule',
    'NetworkInsightsAnalysisExplanationAclRulePortRange',
    'NetworkInsightsAnalysisExplanationAttachedTo',
    'NetworkInsightsAnalysisExplanationClassicLoadBalancerListener',
    'NetworkInsightsAnalysisExplanationComponent',
    'NetworkInsightsAnalysisExplanationCustomerGateway',
    'NetworkInsightsAnalysisExplanationDestination',
    'NetworkInsightsAnalysisExplanationDestinationVpc',
    'NetworkInsightsAnalysisExplanationElasticLoadBalancerListener',
    'NetworkInsightsAnalysisExplanationIngressRouteTable',
    'NetworkInsightsAnalysisExplanationInternetGateway',
    'NetworkInsightsAnalysisExplanationLoadBalancerTargetGroup',
    'NetworkInsightsAnalysisExplanationNatGateway',
    'NetworkInsightsAnalysisExplanationNetworkInterface',
    'NetworkInsightsAnalysisExplanationPortRange',
    'NetworkInsightsAnalysisExplanationPrefixList',
    'NetworkInsightsAnalysisExplanationRouteTable',
    'NetworkInsightsAnalysisExplanationRouteTableRoute',
    'NetworkInsightsAnalysisExplanationSecurityGroup',
    'NetworkInsightsAnalysisExplanationSecurityGroupRule',
    'NetworkInsightsAnalysisExplanationSecurityGroupRulePortRange',
    'NetworkInsightsAnalysisExplanationSourceVpc',
    'NetworkInsightsAnalysisExplanationSubnet',
    'NetworkInsightsAnalysisExplanationSubnetRouteTable',
    'NetworkInsightsAnalysisExplanationTransitGateway',
    'NetworkInsightsAnalysisExplanationTransitGatewayAttachment',
    'NetworkInsightsAnalysisExplanationTransitGatewayRouteTable',
    'NetworkInsightsAnalysisExplanationTransitGatewayRouteTableRoute',
    'NetworkInsightsAnalysisExplanationVpc',
    'NetworkInsightsAnalysisExplanationVpcEndpoint',
    'NetworkInsightsAnalysisExplanationVpcPeeringConnection',
    'NetworkInsightsAnalysisExplanationVpnConnection',
    'NetworkInsightsAnalysisExplanationVpnGateway',
    'NetworkInsightsAnalysisForwardPathComponent',
    'NetworkInsightsAnalysisForwardPathComponentAclRule',
    'NetworkInsightsAnalysisForwardPathComponentAclRulePortRange',
    'NetworkInsightsAnalysisForwardPathComponentAdditionalDetail',
    'NetworkInsightsAnalysisForwardPathComponentAdditionalDetailComponent',
    'NetworkInsightsAnalysisForwardPathComponentAttachedTo',
    'NetworkInsightsAnalysisForwardPathComponentComponent',
    'NetworkInsightsAnalysisForwardPathComponentDestinationVpc',
    'NetworkInsightsAnalysisForwardPathComponentInboundHeader',
    'NetworkInsightsAnalysisForwardPathComponentInboundHeaderDestinationPortRange',
    'NetworkInsightsAnalysisForwardPathComponentInboundHeaderSourcePortRange',
    'NetworkInsightsAnalysisForwardPathComponentOutboundHeader',
    'NetworkInsightsAnalysisForwardPathComponentOutboundHeaderDestinationPortRange',
    'NetworkInsightsAnalysisForwardPathComponentOutboundHeaderSourcePortRange',
    'NetworkInsightsAnalysisForwardPathComponentRouteTableRoute',
    'NetworkInsightsAnalysisForwardPathComponentSecurityGroupRule',
    'NetworkInsightsAnalysisForwardPathComponentSecurityGroupRulePortRange',
    'NetworkInsightsAnalysisForwardPathComponentSourceVpc',
    'NetworkInsightsAnalysisForwardPathComponentSubnet',
    'NetworkInsightsAnalysisForwardPathComponentTransitGateway',
    'NetworkInsightsAnalysisForwardPathComponentTransitGatewayRouteTableRoute',
    'NetworkInsightsAnalysisForwardPathComponentVpc',
    'NetworkInsightsAnalysisReturnPathComponent',
    'NetworkInsightsAnalysisReturnPathComponentAclRule',
    'NetworkInsightsAnalysisReturnPathComponentAclRulePortRange',
    'NetworkInsightsAnalysisReturnPathComponentAdditionalDetail',
    'NetworkInsightsAnalysisReturnPathComponentAdditionalDetailComponent',
    'NetworkInsightsAnalysisReturnPathComponentAttachedTo',
    'NetworkInsightsAnalysisReturnPathComponentComponent',
    'NetworkInsightsAnalysisReturnPathComponentDestinationVpc',
    'NetworkInsightsAnalysisReturnPathComponentInboundHeader',
    'NetworkInsightsAnalysisReturnPathComponentInboundHeaderDestinationPortRange',
    'NetworkInsightsAnalysisReturnPathComponentInboundHeaderSourcePortRange',
    'NetworkInsightsAnalysisReturnPathComponentOutboundHeader',
    'NetworkInsightsAnalysisReturnPathComponentOutboundHeaderDestinationPortRange',
    'NetworkInsightsAnalysisReturnPathComponentOutboundHeaderSourcePortRange',
    'NetworkInsightsAnalysisReturnPathComponentRouteTableRoute',
    'NetworkInsightsAnalysisReturnPathComponentSecurityGroupRule',
    'NetworkInsightsAnalysisReturnPathComponentSecurityGroupRulePortRange',
    'NetworkInsightsAnalysisReturnPathComponentSourceVpc',
    'NetworkInsightsAnalysisReturnPathComponentSubnet',
    'NetworkInsightsAnalysisReturnPathComponentTransitGateway',
    'NetworkInsightsAnalysisReturnPathComponentTransitGatewayRouteTableRoute',
    'NetworkInsightsAnalysisReturnPathComponentVpc',
    'NetworkInterfaceAttachment',
    'PeeringConnectionOptionsAccepter',
    'PeeringConnectionOptionsRequester',
    'RouteTableRoute',
    'SecurityGroupEgress',
    'SecurityGroupIngress',
    'SpotFleetRequestLaunchSpecification',
    'SpotFleetRequestLaunchSpecificationEbsBlockDevice',
    'SpotFleetRequestLaunchSpecificationEphemeralBlockDevice',
    'SpotFleetRequestLaunchSpecificationRootBlockDevice',
    'SpotFleetRequestLaunchTemplateConfig',
    'SpotFleetRequestLaunchTemplateConfigLaunchTemplateSpecification',
    'SpotFleetRequestLaunchTemplateConfigOverride',
    'SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirements',
    'SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorCount',
    'SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorTotalMemoryMib',
    'SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsBaselineEbsBandwidthMbps',
    'SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsMemoryGibPerVcpu',
    'SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsMemoryMib',
    'SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsNetworkBandwidthGbps',
    'SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsNetworkInterfaceCount',
    'SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsTotalLocalStorageGb',
    'SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsVcpuCount',
    'SpotFleetRequestSpotMaintenanceStrategies',
    'SpotFleetRequestSpotMaintenanceStrategiesCapacityRebalance',
    'SpotInstanceRequestCapacityReservationSpecification',
    'SpotInstanceRequestCapacityReservationSpecificationCapacityReservationTarget',
    'SpotInstanceRequestCpuOptions',
    'SpotInstanceRequestCreditSpecification',
    'SpotInstanceRequestEbsBlockDevice',
    'SpotInstanceRequestEnclaveOptions',
    'SpotInstanceRequestEphemeralBlockDevice',
    'SpotInstanceRequestLaunchTemplate',
    'SpotInstanceRequestMaintenanceOptions',
    'SpotInstanceRequestMetadataOptions',
    'SpotInstanceRequestNetworkInterface',
    'SpotInstanceRequestPrivateDnsNameOptions',
    'SpotInstanceRequestRootBlockDevice',
    'TrafficMirrorFilterRuleDestinationPortRange',
    'TrafficMirrorFilterRuleSourcePortRange',
    'VpcEndpointDnsEntry',
    'VpcEndpointDnsOptions',
    'VpcEndpointServicePrivateDnsNameConfiguration',
    'VpcIpamOperatingRegion',
    'VpcIpamPoolCidrCidrAuthorizationContext',
    'VpcIpamResourceDiscoveryOperatingRegion',
    'VpcPeeringConnectionAccepter',
    'VpcPeeringConnectionAccepterAccepter',
    'VpcPeeringConnectionAccepterRequester',
    'VpcPeeringConnectionRequester',
    'VpnConnectionRoute',
    'VpnConnectionTunnel1LogOptions',
    'VpnConnectionTunnel1LogOptionsCloudwatchLogOptions',
    'VpnConnectionTunnel2LogOptions',
    'VpnConnectionTunnel2LogOptionsCloudwatchLogOptions',
    'VpnConnectionVgwTelemetry',
    'GetAmiBlockDeviceMappingResult',
    'GetAmiFilterResult',
    'GetAmiIdsFilterResult',
    'GetAmiProductCodeResult',
    'GetCoipPoolFilterResult',
    'GetCoipPoolsFilterResult',
    'GetCustomerGatewayFilterResult',
    'GetDedicatedHostFilterResult',
    'GetEipsFilterResult',
    'GetElasticIpFilterResult',
    'GetInstanceCreditSpecificationResult',
    'GetInstanceEbsBlockDeviceResult',
    'GetInstanceEnclaveOptionResult',
    'GetInstanceEphemeralBlockDeviceResult',
    'GetInstanceFilterResult',
    'GetInstanceMaintenanceOptionResult',
    'GetInstanceMetadataOptionResult',
    'GetInstancePrivateDnsNameOptionResult',
    'GetInstanceRootBlockDeviceResult',
    'GetInstanceTypeFpgaResult',
    'GetInstanceTypeGpusResult',
    'GetInstanceTypeInferenceAcceleratorResult',
    'GetInstanceTypeInstanceDiskResult',
    'GetInstanceTypeOfferingFilterResult',
    'GetInstanceTypeOfferingsFilterResult',
    'GetInstanceTypesFilterResult',
    'GetInstancesFilterResult',
    'GetInternetGatewayAttachmentResult',
    'GetInternetGatewayFilterResult',
    'GetKeyPairFilterResult',
    'GetLaunchConfigurationEbsBlockDeviceResult',
    'GetLaunchConfigurationEphemeralBlockDeviceResult',
    'GetLaunchConfigurationMetadataOptionResult',
    'GetLaunchConfigurationRootBlockDeviceResult',
    'GetLaunchTemplateBlockDeviceMappingResult',
    'GetLaunchTemplateBlockDeviceMappingEbResult',
    'GetLaunchTemplateCapacityReservationSpecificationResult',
    'GetLaunchTemplateCapacityReservationSpecificationCapacityReservationTargetResult',
    'GetLaunchTemplateCpuOptionResult',
    'GetLaunchTemplateCreditSpecificationResult',
    'GetLaunchTemplateElasticGpuSpecificationResult',
    'GetLaunchTemplateElasticInferenceAcceleratorResult',
    'GetLaunchTemplateEnclaveOptionResult',
    'GetLaunchTemplateFilterResult',
    'GetLaunchTemplateHibernationOptionResult',
    'GetLaunchTemplateIamInstanceProfileResult',
    'GetLaunchTemplateInstanceMarketOptionResult',
    'GetLaunchTemplateInstanceMarketOptionSpotOptionResult',
    'GetLaunchTemplateInstanceRequirementResult',
    'GetLaunchTemplateInstanceRequirementAcceleratorCountResult',
    'GetLaunchTemplateInstanceRequirementAcceleratorTotalMemoryMibResult',
    'GetLaunchTemplateInstanceRequirementBaselineEbsBandwidthMbpResult',
    'GetLaunchTemplateInstanceRequirementMemoryGibPerVcpusResult',
    'GetLaunchTemplateInstanceRequirementMemoryMibResult',
    'GetLaunchTemplateInstanceRequirementNetworkBandwidthGbpResult',
    'GetLaunchTemplateInstanceRequirementNetworkInterfaceCountResult',
    'GetLaunchTemplateInstanceRequirementTotalLocalStorageGbResult',
    'GetLaunchTemplateInstanceRequirementVcpuCountResult',
    'GetLaunchTemplateLicenseSpecificationResult',
    'GetLaunchTemplateMaintenanceOptionResult',
    'GetLaunchTemplateMetadataOptionResult',
    'GetLaunchTemplateMonitoringResult',
    'GetLaunchTemplateNetworkInterfaceResult',
    'GetLaunchTemplatePlacementResult',
    'GetLaunchTemplatePrivateDnsNameOptionResult',
    'GetLaunchTemplateTagSpecificationResult',
    'GetLocalGatewayFilterResult',
    'GetLocalGatewayRouteTableFilterResult',
    'GetLocalGatewayRouteTablesFilterResult',
    'GetLocalGatewayVirtualInterfaceFilterResult',
    'GetLocalGatewayVirtualInterfaceGroupFilterResult',
    'GetLocalGatewayVirtualInterfaceGroupsFilterResult',
    'GetLocalGatewaysFilterResult',
    'GetManagedPrefixListEntryResult',
    'GetManagedPrefixListFilterResult',
    'GetManagedPrefixListsFilterResult',
    'GetNatGatewayFilterResult',
    'GetNatGatewaysFilterResult',
    'GetNetworkAclsFilterResult',
    'GetNetworkInsightsAnalysisAlternatePathHintResult',
    'GetNetworkInsightsAnalysisExplanationResult',
    'GetNetworkInsightsAnalysisExplanationAclResult',
    'GetNetworkInsightsAnalysisExplanationAclRuleResult',
    'GetNetworkInsightsAnalysisExplanationAclRulePortRangeResult',
    'GetNetworkInsightsAnalysisExplanationAttachedToResult',
    'GetNetworkInsightsAnalysisExplanationClassicLoadBalancerListenerResult',
    'GetNetworkInsightsAnalysisExplanationComponentResult',
    'GetNetworkInsightsAnalysisExplanationCustomerGatewayResult',
    'GetNetworkInsightsAnalysisExplanationDestinationResult',
    'GetNetworkInsightsAnalysisExplanationDestinationVpcResult',
    'GetNetworkInsightsAnalysisExplanationElasticLoadBalancerListenerResult',
    'GetNetworkInsightsAnalysisExplanationIngressRouteTableResult',
    'GetNetworkInsightsAnalysisExplanationInternetGatewayResult',
    'GetNetworkInsightsAnalysisExplanationLoadBalancerTargetGroupResult',
    'GetNetworkInsightsAnalysisExplanationNatGatewayResult',
    'GetNetworkInsightsAnalysisExplanationNetworkInterfaceResult',
    'GetNetworkInsightsAnalysisExplanationPortRangeResult',
    'GetNetworkInsightsAnalysisExplanationPrefixListResult',
    'GetNetworkInsightsAnalysisExplanationRouteTableResult',
    'GetNetworkInsightsAnalysisExplanationRouteTableRouteResult',
    'GetNetworkInsightsAnalysisExplanationSecurityGroupResult',
    'GetNetworkInsightsAnalysisExplanationSecurityGroupRuleResult',
    'GetNetworkInsightsAnalysisExplanationSecurityGroupRulePortRangeResult',
    'GetNetworkInsightsAnalysisExplanationSourceVpcResult',
    'GetNetworkInsightsAnalysisExplanationSubnetResult',
    'GetNetworkInsightsAnalysisExplanationSubnetRouteTableResult',
    'GetNetworkInsightsAnalysisExplanationTransitGatewayResult',
    'GetNetworkInsightsAnalysisExplanationTransitGatewayAttachmentResult',
    'GetNetworkInsightsAnalysisExplanationTransitGatewayRouteTableResult',
    'GetNetworkInsightsAnalysisExplanationTransitGatewayRouteTableRouteResult',
    'GetNetworkInsightsAnalysisExplanationVpcResult',
    'GetNetworkInsightsAnalysisExplanationVpcEndpointResult',
    'GetNetworkInsightsAnalysisExplanationVpcPeeringConnectionResult',
    'GetNetworkInsightsAnalysisExplanationVpnConnectionResult',
    'GetNetworkInsightsAnalysisExplanationVpnGatewayResult',
    'GetNetworkInsightsAnalysisFilterResult',
    'GetNetworkInsightsAnalysisForwardPathComponentResult',
    'GetNetworkInsightsAnalysisForwardPathComponentAclRuleResult',
    'GetNetworkInsightsAnalysisForwardPathComponentAclRulePortRangeResult',
    'GetNetworkInsightsAnalysisForwardPathComponentAdditionalDetailResult',
    'GetNetworkInsightsAnalysisForwardPathComponentAdditionalDetailComponentResult',
    'GetNetworkInsightsAnalysisForwardPathComponentAttachedToResult',
    'GetNetworkInsightsAnalysisForwardPathComponentComponentResult',
    'GetNetworkInsightsAnalysisForwardPathComponentDestinationVpcResult',
    'GetNetworkInsightsAnalysisForwardPathComponentInboundHeaderResult',
    'GetNetworkInsightsAnalysisForwardPathComponentInboundHeaderDestinationPortRangeResult',
    'GetNetworkInsightsAnalysisForwardPathComponentInboundHeaderSourcePortRangeResult',
    'GetNetworkInsightsAnalysisForwardPathComponentOutboundHeaderResult',
    'GetNetworkInsightsAnalysisForwardPathComponentOutboundHeaderDestinationPortRangeResult',
    'GetNetworkInsightsAnalysisForwardPathComponentOutboundHeaderSourcePortRangeResult',
    'GetNetworkInsightsAnalysisForwardPathComponentRouteTableRouteResult',
    'GetNetworkInsightsAnalysisForwardPathComponentSecurityGroupRuleResult',
    'GetNetworkInsightsAnalysisForwardPathComponentSecurityGroupRulePortRangeResult',
    'GetNetworkInsightsAnalysisForwardPathComponentSourceVpcResult',
    'GetNetworkInsightsAnalysisForwardPathComponentSubnetResult',
    'GetNetworkInsightsAnalysisForwardPathComponentTransitGatewayResult',
    'GetNetworkInsightsAnalysisForwardPathComponentTransitGatewayRouteTableRouteResult',
    'GetNetworkInsightsAnalysisForwardPathComponentVpcResult',
    'GetNetworkInsightsAnalysisReturnPathComponentResult',
    'GetNetworkInsightsAnalysisReturnPathComponentAclRuleResult',
    'GetNetworkInsightsAnalysisReturnPathComponentAclRulePortRangeResult',
    'GetNetworkInsightsAnalysisReturnPathComponentAdditionalDetailResult',
    'GetNetworkInsightsAnalysisReturnPathComponentAdditionalDetailComponentResult',
    'GetNetworkInsightsAnalysisReturnPathComponentAttachedToResult',
    'GetNetworkInsightsAnalysisReturnPathComponentComponentResult',
    'GetNetworkInsightsAnalysisReturnPathComponentDestinationVpcResult',
    'GetNetworkInsightsAnalysisReturnPathComponentInboundHeaderResult',
    'GetNetworkInsightsAnalysisReturnPathComponentInboundHeaderDestinationPortRangeResult',
    'GetNetworkInsightsAnalysisReturnPathComponentInboundHeaderSourcePortRangeResult',
    'GetNetworkInsightsAnalysisReturnPathComponentOutboundHeaderResult',
    'GetNetworkInsightsAnalysisReturnPathComponentOutboundHeaderDestinationPortRangeResult',
    'GetNetworkInsightsAnalysisReturnPathComponentOutboundHeaderSourcePortRangeResult',
    'GetNetworkInsightsAnalysisReturnPathComponentRouteTableRouteResult',
    'GetNetworkInsightsAnalysisReturnPathComponentSecurityGroupRuleResult',
    'GetNetworkInsightsAnalysisReturnPathComponentSecurityGroupRulePortRangeResult',
    'GetNetworkInsightsAnalysisReturnPathComponentSourceVpcResult',
    'GetNetworkInsightsAnalysisReturnPathComponentSubnetResult',
    'GetNetworkInsightsAnalysisReturnPathComponentTransitGatewayResult',
    'GetNetworkInsightsAnalysisReturnPathComponentTransitGatewayRouteTableRouteResult',
    'GetNetworkInsightsAnalysisReturnPathComponentVpcResult',
    'GetNetworkInsightsPathFilterResult',
    'GetNetworkInterfaceAssociationResult',
    'GetNetworkInterfaceAttachmentResult',
    'GetNetworkInterfaceFilterResult',
    'GetNetworkInterfacesFilterResult',
    'GetPrefixListFilterResult',
    'GetPublicIpv4PoolPoolAddressRangeResult',
    'GetPublicIpv4PoolsFilterResult',
    'GetRouteTableAssociationResult',
    'GetRouteTableFilterResult',
    'GetRouteTableRouteResult',
    'GetRouteTablesFilterResult',
    'GetSecurityGroupFilterResult',
    'GetSecurityGroupsFilterResult',
    'GetSpotPriceFilterResult',
    'GetSubnetFilterResult',
    'GetSubnetsFilterResult',
    'GetTransitGatewayRouteTablesFilterResult',
    'GetVpcCidrBlockAssociationResult',
    'GetVpcDhcpOptionsFilterResult',
    'GetVpcEndpointDnsEntryResult',
    'GetVpcEndpointDnsOptionResult',
    'GetVpcEndpointFilterResult',
    'GetVpcEndpointServiceFilterResult',
    'GetVpcFilterResult',
    'GetVpcIamPoolCidrsFilterResult',
    'GetVpcIamPoolCidrsIpamPoolCidrResult',
    'GetVpcIamPoolFilterResult',
    'GetVpcIamPoolsFilterResult',
    'GetVpcIamPoolsIpamPoolResult',
    'GetVpcIpamPoolCidrsFilterResult',
    'GetVpcIpamPoolCidrsIpamPoolCidrResult',
    'GetVpcIpamPoolFilterResult',
    'GetVpcIpamPoolsFilterResult',
    'GetVpcIpamPoolsIpamPoolResult',
    'GetVpcPeeringConnectionCidrBlockSetResult',
    'GetVpcPeeringConnectionFilterResult',
    'GetVpcPeeringConnectionPeerCidrBlockSetResult',
    'GetVpcPeeringConnectionsFilterResult',
    'GetVpcsFilterResult',
    'GetVpnGatewayFilterResult',
]

@pulumi.output_type
class AmiCopyEbsBlockDevice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "deviceName":
            suggest = "device_name"
        elif key == "outpostArn":
            suggest = "outpost_arn"
        elif key == "snapshotId":
            suggest = "snapshot_id"
        elif key == "volumeSize":
            suggest = "volume_size"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AmiCopyEbsBlockDevice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AmiCopyEbsBlockDevice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AmiCopyEbsBlockDevice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delete_on_termination: Optional[bool] = None,
                 device_name: Optional[str] = None,
                 encrypted: Optional[bool] = None,
                 iops: Optional[int] = None,
                 outpost_arn: Optional[str] = None,
                 snapshot_id: Optional[str] = None,
                 throughput: Optional[int] = None,
                 volume_size: Optional[int] = None,
                 volume_type: Optional[str] = None):
        """
        :param bool delete_on_termination: Boolean controlling whether the EBS volumes created to
               support each created instance will be deleted once that instance is terminated.
        :param str device_name: Path at which the device is exposed to created instances.
        :param bool encrypted: Boolean controlling whether the created EBS volumes will be encrypted. Can't be used with `snapshot_id`.
        :param int iops: Number of I/O operations per second the
               created volumes will support.
        :param str outpost_arn: ARN of the Outpost on which the snapshot is stored.
               
               > **Note:** You can specify `encrypted` or `snapshot_id` but not both.
        :param str snapshot_id: ID of an EBS snapshot that will be used to initialize the created
               EBS volumes. If set, the `volume_size` attribute must be at least as large as the referenced
               snapshot.
        :param int throughput: Throughput that the EBS volume supports, in MiB/s. Only valid for `volume_type` of `gp3`.
        :param int volume_size: Size of created volumes in GiB.
               If `snapshot_id` is set and `volume_size` is omitted then the volume will have the same size
               as the selected snapshot.
        :param str volume_type: Type of EBS volume to create. Can be `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1` or `st1` (Default: `standard`).
        """
        AmiCopyEbsBlockDevice._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            delete_on_termination=delete_on_termination,
            device_name=device_name,
            encrypted=encrypted,
            iops=iops,
            outpost_arn=outpost_arn,
            snapshot_id=snapshot_id,
            throughput=throughput,
            volume_size=volume_size,
            volume_type=volume_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             delete_on_termination: Optional[bool] = None,
             device_name: Optional[str] = None,
             encrypted: Optional[bool] = None,
             iops: Optional[int] = None,
             outpost_arn: Optional[str] = None,
             snapshot_id: Optional[str] = None,
             throughput: Optional[int] = None,
             volume_size: Optional[int] = None,
             volume_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if delete_on_termination is None and 'deleteOnTermination' in kwargs:
            delete_on_termination = kwargs['deleteOnTermination']
        if device_name is None and 'deviceName' in kwargs:
            device_name = kwargs['deviceName']
        if outpost_arn is None and 'outpostArn' in kwargs:
            outpost_arn = kwargs['outpostArn']
        if snapshot_id is None and 'snapshotId' in kwargs:
            snapshot_id = kwargs['snapshotId']
        if volume_size is None and 'volumeSize' in kwargs:
            volume_size = kwargs['volumeSize']
        if volume_type is None and 'volumeType' in kwargs:
            volume_type = kwargs['volumeType']

        if delete_on_termination is not None:
            _setter("delete_on_termination", delete_on_termination)
        if device_name is not None:
            _setter("device_name", device_name)
        if encrypted is not None:
            _setter("encrypted", encrypted)
        if iops is not None:
            _setter("iops", iops)
        if outpost_arn is not None:
            _setter("outpost_arn", outpost_arn)
        if snapshot_id is not None:
            _setter("snapshot_id", snapshot_id)
        if throughput is not None:
            _setter("throughput", throughput)
        if volume_size is not None:
            _setter("volume_size", volume_size)
        if volume_type is not None:
            _setter("volume_type", volume_type)

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[bool]:
        """
        Boolean controlling whether the EBS volumes created to
        support each created instance will be deleted once that instance is terminated.
        """
        return pulumi.get(self, "delete_on_termination")

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[str]:
        """
        Path at which the device is exposed to created instances.
        """
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[bool]:
        """
        Boolean controlling whether the created EBS volumes will be encrypted. Can't be used with `snapshot_id`.
        """
        return pulumi.get(self, "encrypted")

    @property
    @pulumi.getter
    def iops(self) -> Optional[int]:
        """
        Number of I/O operations per second the
        created volumes will support.
        """
        return pulumi.get(self, "iops")

    @property
    @pulumi.getter(name="outpostArn")
    def outpost_arn(self) -> Optional[str]:
        """
        ARN of the Outpost on which the snapshot is stored.

        > **Note:** You can specify `encrypted` or `snapshot_id` but not both.
        """
        return pulumi.get(self, "outpost_arn")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[str]:
        """
        ID of an EBS snapshot that will be used to initialize the created
        EBS volumes. If set, the `volume_size` attribute must be at least as large as the referenced
        snapshot.
        """
        return pulumi.get(self, "snapshot_id")

    @property
    @pulumi.getter
    def throughput(self) -> Optional[int]:
        """
        Throughput that the EBS volume supports, in MiB/s. Only valid for `volume_type` of `gp3`.
        """
        return pulumi.get(self, "throughput")

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[int]:
        """
        Size of created volumes in GiB.
        If `snapshot_id` is set and `volume_size` is omitted then the volume will have the same size
        as the selected snapshot.
        """
        return pulumi.get(self, "volume_size")

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[str]:
        """
        Type of EBS volume to create. Can be `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1` or `st1` (Default: `standard`).
        """
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class AmiCopyEphemeralBlockDevice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "virtualName":
            suggest = "virtual_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AmiCopyEphemeralBlockDevice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AmiCopyEphemeralBlockDevice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AmiCopyEphemeralBlockDevice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_name: Optional[str] = None,
                 virtual_name: Optional[str] = None):
        """
        :param str device_name: Path at which the device is exposed to created instances.
        :param str virtual_name: Name for the ephemeral device, of the form "ephemeralN" where
               *N* is a volume number starting from zero.
        """
        AmiCopyEphemeralBlockDevice._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            device_name=device_name,
            virtual_name=virtual_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             device_name: Optional[str] = None,
             virtual_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if device_name is None and 'deviceName' in kwargs:
            device_name = kwargs['deviceName']
        if virtual_name is None and 'virtualName' in kwargs:
            virtual_name = kwargs['virtualName']

        if device_name is not None:
            _setter("device_name", device_name)
        if virtual_name is not None:
            _setter("virtual_name", virtual_name)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[str]:
        """
        Path at which the device is exposed to created instances.
        """
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> Optional[str]:
        """
        Name for the ephemeral device, of the form "ephemeralN" where
        *N* is a volume number starting from zero.
        """
        return pulumi.get(self, "virtual_name")


@pulumi.output_type
class AmiEbsBlockDevice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "outpostArn":
            suggest = "outpost_arn"
        elif key == "snapshotId":
            suggest = "snapshot_id"
        elif key == "volumeSize":
            suggest = "volume_size"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AmiEbsBlockDevice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AmiEbsBlockDevice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AmiEbsBlockDevice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_name: str,
                 delete_on_termination: Optional[bool] = None,
                 encrypted: Optional[bool] = None,
                 iops: Optional[int] = None,
                 outpost_arn: Optional[str] = None,
                 snapshot_id: Optional[str] = None,
                 throughput: Optional[int] = None,
                 volume_size: Optional[int] = None,
                 volume_type: Optional[str] = None):
        """
        :param str device_name: Path at which the device is exposed to created instances.
        :param bool delete_on_termination: Boolean controlling whether the EBS volumes created to
               support each created instance will be deleted once that instance is terminated.
        :param bool encrypted: Boolean controlling whether the created EBS volumes will be encrypted. Can't be used with `snapshot_id`.
        :param int iops: Number of I/O operations per second the
               created volumes will support.
        :param str outpost_arn: ARN of the Outpost on which the snapshot is stored.
               
               > **Note:** You can specify `encrypted` or `snapshot_id` but not both.
        :param str snapshot_id: ID of an EBS snapshot that will be used to initialize the created
               EBS volumes. If set, the `volume_size` attribute must be at least as large as the referenced
               snapshot.
        :param int throughput: Throughput that the EBS volume supports, in MiB/s. Only valid for `volume_type` of `gp3`.
        :param int volume_size: Size of created volumes in GiB.
               If `snapshot_id` is set and `volume_size` is omitted then the volume will have the same size
               as the selected snapshot.
        :param str volume_type: Type of EBS volume to create. Can be `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1` or `st1` (Default: `standard`).
        """
        AmiEbsBlockDevice._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            device_name=device_name,
            delete_on_termination=delete_on_termination,
            encrypted=encrypted,
            iops=iops,
            outpost_arn=outpost_arn,
            snapshot_id=snapshot_id,
            throughput=throughput,
            volume_size=volume_size,
            volume_type=volume_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             device_name: Optional[str] = None,
             delete_on_termination: Optional[bool] = None,
             encrypted: Optional[bool] = None,
             iops: Optional[int] = None,
             outpost_arn: Optional[str] = None,
             snapshot_id: Optional[str] = None,
             throughput: Optional[int] = None,
             volume_size: Optional[int] = None,
             volume_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if device_name is None and 'deviceName' in kwargs:
            device_name = kwargs['deviceName']
        if device_name is None:
            raise TypeError("Missing 'device_name' argument")
        if delete_on_termination is None and 'deleteOnTermination' in kwargs:
            delete_on_termination = kwargs['deleteOnTermination']
        if outpost_arn is None and 'outpostArn' in kwargs:
            outpost_arn = kwargs['outpostArn']
        if snapshot_id is None and 'snapshotId' in kwargs:
            snapshot_id = kwargs['snapshotId']
        if volume_size is None and 'volumeSize' in kwargs:
            volume_size = kwargs['volumeSize']
        if volume_type is None and 'volumeType' in kwargs:
            volume_type = kwargs['volumeType']

        _setter("device_name", device_name)
        if delete_on_termination is not None:
            _setter("delete_on_termination", delete_on_termination)
        if encrypted is not None:
            _setter("encrypted", encrypted)
        if iops is not None:
            _setter("iops", iops)
        if outpost_arn is not None:
            _setter("outpost_arn", outpost_arn)
        if snapshot_id is not None:
            _setter("snapshot_id", snapshot_id)
        if throughput is not None:
            _setter("throughput", throughput)
        if volume_size is not None:
            _setter("volume_size", volume_size)
        if volume_type is not None:
            _setter("volume_type", volume_type)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> str:
        """
        Path at which the device is exposed to created instances.
        """
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[bool]:
        """
        Boolean controlling whether the EBS volumes created to
        support each created instance will be deleted once that instance is terminated.
        """
        return pulumi.get(self, "delete_on_termination")

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[bool]:
        """
        Boolean controlling whether the created EBS volumes will be encrypted. Can't be used with `snapshot_id`.
        """
        return pulumi.get(self, "encrypted")

    @property
    @pulumi.getter
    def iops(self) -> Optional[int]:
        """
        Number of I/O operations per second the
        created volumes will support.
        """
        return pulumi.get(self, "iops")

    @property
    @pulumi.getter(name="outpostArn")
    def outpost_arn(self) -> Optional[str]:
        """
        ARN of the Outpost on which the snapshot is stored.

        > **Note:** You can specify `encrypted` or `snapshot_id` but not both.
        """
        return pulumi.get(self, "outpost_arn")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[str]:
        """
        ID of an EBS snapshot that will be used to initialize the created
        EBS volumes. If set, the `volume_size` attribute must be at least as large as the referenced
        snapshot.
        """
        return pulumi.get(self, "snapshot_id")

    @property
    @pulumi.getter
    def throughput(self) -> Optional[int]:
        """
        Throughput that the EBS volume supports, in MiB/s. Only valid for `volume_type` of `gp3`.
        """
        return pulumi.get(self, "throughput")

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[int]:
        """
        Size of created volumes in GiB.
        If `snapshot_id` is set and `volume_size` is omitted then the volume will have the same size
        as the selected snapshot.
        """
        return pulumi.get(self, "volume_size")

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[str]:
        """
        Type of EBS volume to create. Can be `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1` or `st1` (Default: `standard`).
        """
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class AmiEphemeralBlockDevice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "virtualName":
            suggest = "virtual_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AmiEphemeralBlockDevice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AmiEphemeralBlockDevice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AmiEphemeralBlockDevice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_name: str,
                 virtual_name: str):
        """
        :param str device_name: Path at which the device is exposed to created instances.
        :param str virtual_name: Name for the ephemeral device, of the form "ephemeralN" where
               *N* is a volume number starting from zero.
        """
        AmiEphemeralBlockDevice._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            device_name=device_name,
            virtual_name=virtual_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             device_name: Optional[str] = None,
             virtual_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if device_name is None and 'deviceName' in kwargs:
            device_name = kwargs['deviceName']
        if device_name is None:
            raise TypeError("Missing 'device_name' argument")
        if virtual_name is None and 'virtualName' in kwargs:
            virtual_name = kwargs['virtualName']
        if virtual_name is None:
            raise TypeError("Missing 'virtual_name' argument")

        _setter("device_name", device_name)
        _setter("virtual_name", virtual_name)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> str:
        """
        Path at which the device is exposed to created instances.
        """
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> str:
        """
        Name for the ephemeral device, of the form "ephemeralN" where
        *N* is a volume number starting from zero.
        """
        return pulumi.get(self, "virtual_name")


@pulumi.output_type
class AmiFromInstanceEbsBlockDevice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "deviceName":
            suggest = "device_name"
        elif key == "outpostArn":
            suggest = "outpost_arn"
        elif key == "snapshotId":
            suggest = "snapshot_id"
        elif key == "volumeSize":
            suggest = "volume_size"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AmiFromInstanceEbsBlockDevice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AmiFromInstanceEbsBlockDevice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AmiFromInstanceEbsBlockDevice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delete_on_termination: Optional[bool] = None,
                 device_name: Optional[str] = None,
                 encrypted: Optional[bool] = None,
                 iops: Optional[int] = None,
                 outpost_arn: Optional[str] = None,
                 snapshot_id: Optional[str] = None,
                 throughput: Optional[int] = None,
                 volume_size: Optional[int] = None,
                 volume_type: Optional[str] = None):
        """
        :param bool delete_on_termination: Boolean controlling whether the EBS volumes created to
               support each created instance will be deleted once that instance is terminated.
        :param str device_name: Path at which the device is exposed to created instances.
        :param bool encrypted: Boolean controlling whether the created EBS volumes will be encrypted. Can't be used with `snapshot_id`.
        :param int iops: Number of I/O operations per second the
               created volumes will support.
        :param str outpost_arn: ARN of the Outpost on which the snapshot is stored.
               
               > **Note:** You can specify `encrypted` or `snapshot_id` but not both.
        :param str snapshot_id: ID of an EBS snapshot that will be used to initialize the created
               EBS volumes. If set, the `volume_size` attribute must be at least as large as the referenced
               snapshot.
        :param int throughput: Throughput that the EBS volume supports, in MiB/s. Only valid for `volume_type` of `gp3`.
        :param int volume_size: Size of created volumes in GiB.
               If `snapshot_id` is set and `volume_size` is omitted then the volume will have the same size
               as the selected snapshot.
        :param str volume_type: Type of EBS volume to create. Can be `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1` or `st1` (Default: `standard`).
        """
        AmiFromInstanceEbsBlockDevice._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            delete_on_termination=delete_on_termination,
            device_name=device_name,
            encrypted=encrypted,
            iops=iops,
            outpost_arn=outpost_arn,
            snapshot_id=snapshot_id,
            throughput=throughput,
            volume_size=volume_size,
            volume_type=volume_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             delete_on_termination: Optional[bool] = None,
             device_name: Optional[str] = None,
             encrypted: Optional[bool] = None,
             iops: Optional[int] = None,
             outpost_arn: Optional[str] = None,
             snapshot_id: Optional[str] = None,
             throughput: Optional[int] = None,
             volume_size: Optional[int] = None,
             volume_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if delete_on_termination is None and 'deleteOnTermination' in kwargs:
            delete_on_termination = kwargs['deleteOnTermination']
        if device_name is None and 'deviceName' in kwargs:
            device_name = kwargs['deviceName']
        if outpost_arn is None and 'outpostArn' in kwargs:
            outpost_arn = kwargs['outpostArn']
        if snapshot_id is None and 'snapshotId' in kwargs:
            snapshot_id = kwargs['snapshotId']
        if volume_size is None and 'volumeSize' in kwargs:
            volume_size = kwargs['volumeSize']
        if volume_type is None and 'volumeType' in kwargs:
            volume_type = kwargs['volumeType']

        if delete_on_termination is not None:
            _setter("delete_on_termination", delete_on_termination)
        if device_name is not None:
            _setter("device_name", device_name)
        if encrypted is not None:
            _setter("encrypted", encrypted)
        if iops is not None:
            _setter("iops", iops)
        if outpost_arn is not None:
            _setter("outpost_arn", outpost_arn)
        if snapshot_id is not None:
            _setter("snapshot_id", snapshot_id)
        if throughput is not None:
            _setter("throughput", throughput)
        if volume_size is not None:
            _setter("volume_size", volume_size)
        if volume_type is not None:
            _setter("volume_type", volume_type)

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[bool]:
        """
        Boolean controlling whether the EBS volumes created to
        support each created instance will be deleted once that instance is terminated.
        """
        return pulumi.get(self, "delete_on_termination")

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[str]:
        """
        Path at which the device is exposed to created instances.
        """
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[bool]:
        """
        Boolean controlling whether the created EBS volumes will be encrypted. Can't be used with `snapshot_id`.
        """
        return pulumi.get(self, "encrypted")

    @property
    @pulumi.getter
    def iops(self) -> Optional[int]:
        """
        Number of I/O operations per second the
        created volumes will support.
        """
        return pulumi.get(self, "iops")

    @property
    @pulumi.getter(name="outpostArn")
    def outpost_arn(self) -> Optional[str]:
        """
        ARN of the Outpost on which the snapshot is stored.

        > **Note:** You can specify `encrypted` or `snapshot_id` but not both.
        """
        return pulumi.get(self, "outpost_arn")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[str]:
        """
        ID of an EBS snapshot that will be used to initialize the created
        EBS volumes. If set, the `volume_size` attribute must be at least as large as the referenced
        snapshot.
        """
        return pulumi.get(self, "snapshot_id")

    @property
    @pulumi.getter
    def throughput(self) -> Optional[int]:
        """
        Throughput that the EBS volume supports, in MiB/s. Only valid for `volume_type` of `gp3`.
        """
        return pulumi.get(self, "throughput")

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[int]:
        """
        Size of created volumes in GiB.
        If `snapshot_id` is set and `volume_size` is omitted then the volume will have the same size
        as the selected snapshot.
        """
        return pulumi.get(self, "volume_size")

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[str]:
        """
        Type of EBS volume to create. Can be `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1` or `st1` (Default: `standard`).
        """
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class AmiFromInstanceEphemeralBlockDevice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "virtualName":
            suggest = "virtual_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AmiFromInstanceEphemeralBlockDevice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AmiFromInstanceEphemeralBlockDevice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AmiFromInstanceEphemeralBlockDevice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_name: Optional[str] = None,
                 virtual_name: Optional[str] = None):
        """
        :param str device_name: Path at which the device is exposed to created instances.
        :param str virtual_name: Name for the ephemeral device, of the form "ephemeralN" where
               *N* is a volume number starting from zero.
        """
        AmiFromInstanceEphemeralBlockDevice._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            device_name=device_name,
            virtual_name=virtual_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             device_name: Optional[str] = None,
             virtual_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if device_name is None and 'deviceName' in kwargs:
            device_name = kwargs['deviceName']
        if virtual_name is None and 'virtualName' in kwargs:
            virtual_name = kwargs['virtualName']

        if device_name is not None:
            _setter("device_name", device_name)
        if virtual_name is not None:
            _setter("virtual_name", virtual_name)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[str]:
        """
        Path at which the device is exposed to created instances.
        """
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> Optional[str]:
        """
        Name for the ephemeral device, of the form "ephemeralN" where
        *N* is a volume number starting from zero.
        """
        return pulumi.get(self, "virtual_name")


@pulumi.output_type
class DefaultNetworkAclEgress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromPort":
            suggest = "from_port"
        elif key == "ruleNo":
            suggest = "rule_no"
        elif key == "toPort":
            suggest = "to_port"
        elif key == "cidrBlock":
            suggest = "cidr_block"
        elif key == "icmpCode":
            suggest = "icmp_code"
        elif key == "icmpType":
            suggest = "icmp_type"
        elif key == "ipv6CidrBlock":
            suggest = "ipv6_cidr_block"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DefaultNetworkAclEgress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DefaultNetworkAclEgress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DefaultNetworkAclEgress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: str,
                 from_port: int,
                 protocol: str,
                 rule_no: int,
                 to_port: int,
                 cidr_block: Optional[str] = None,
                 icmp_code: Optional[int] = None,
                 icmp_type: Optional[int] = None,
                 ipv6_cidr_block: Optional[str] = None):
        """
        :param str action: The action to take.
        :param int from_port: The from port to match.
        :param str protocol: The protocol to match. If using the -1 'all' protocol, you must specify a from and to port of 0.
        :param int rule_no: The rule number. Used for ordering.
        :param int to_port: The to port to match.
               
               The following arguments are optional:
        :param str cidr_block: The CIDR block to match. This must be a valid network mask.
        :param int icmp_code: The ICMP type code to be used. Default 0.
        :param int icmp_type: The ICMP type to be used. Default 0.
        :param str ipv6_cidr_block: The IPv6 CIDR block.
               
               > For more information on ICMP types and codes, see [Internet Control Message Protocol (ICMP) Parameters](https://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml).
        """
        DefaultNetworkAclEgress._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            from_port=from_port,
            protocol=protocol,
            rule_no=rule_no,
            to_port=to_port,
            cidr_block=cidr_block,
            icmp_code=icmp_code,
            icmp_type=icmp_type,
            ipv6_cidr_block=ipv6_cidr_block,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: Optional[str] = None,
             from_port: Optional[int] = None,
             protocol: Optional[str] = None,
             rule_no: Optional[int] = None,
             to_port: Optional[int] = None,
             cidr_block: Optional[str] = None,
             icmp_code: Optional[int] = None,
             icmp_type: Optional[int] = None,
             ipv6_cidr_block: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if action is None:
            raise TypeError("Missing 'action' argument")
        if from_port is None and 'fromPort' in kwargs:
            from_port = kwargs['fromPort']
        if from_port is None:
            raise TypeError("Missing 'from_port' argument")
        if protocol is None:
            raise TypeError("Missing 'protocol' argument")
        if rule_no is None and 'ruleNo' in kwargs:
            rule_no = kwargs['ruleNo']
        if rule_no is None:
            raise TypeError("Missing 'rule_no' argument")
        if to_port is None and 'toPort' in kwargs:
            to_port = kwargs['toPort']
        if to_port is None:
            raise TypeError("Missing 'to_port' argument")
        if cidr_block is None and 'cidrBlock' in kwargs:
            cidr_block = kwargs['cidrBlock']
        if icmp_code is None and 'icmpCode' in kwargs:
            icmp_code = kwargs['icmpCode']
        if icmp_type is None and 'icmpType' in kwargs:
            icmp_type = kwargs['icmpType']
        if ipv6_cidr_block is None and 'ipv6CidrBlock' in kwargs:
            ipv6_cidr_block = kwargs['ipv6CidrBlock']

        _setter("action", action)
        _setter("from_port", from_port)
        _setter("protocol", protocol)
        _setter("rule_no", rule_no)
        _setter("to_port", to_port)
        if cidr_block is not None:
            _setter("cidr_block", cidr_block)
        if icmp_code is not None:
            _setter("icmp_code", icmp_code)
        if icmp_type is not None:
            _setter("icmp_type", icmp_type)
        if ipv6_cidr_block is not None:
            _setter("ipv6_cidr_block", ipv6_cidr_block)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        The action to take.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> int:
        """
        The from port to match.
        """
        return pulumi.get(self, "from_port")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        The protocol to match. If using the -1 'all' protocol, you must specify a from and to port of 0.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="ruleNo")
    def rule_no(self) -> int:
        """
        The rule number. Used for ordering.
        """
        return pulumi.get(self, "rule_no")

    @property
    @pulumi.getter(name="toPort")
    def to_port(self) -> int:
        """
        The to port to match.

        The following arguments are optional:
        """
        return pulumi.get(self, "to_port")

    @property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> Optional[str]:
        """
        The CIDR block to match. This must be a valid network mask.
        """
        return pulumi.get(self, "cidr_block")

    @property
    @pulumi.getter(name="icmpCode")
    def icmp_code(self) -> Optional[int]:
        """
        The ICMP type code to be used. Default 0.
        """
        return pulumi.get(self, "icmp_code")

    @property
    @pulumi.getter(name="icmpType")
    def icmp_type(self) -> Optional[int]:
        """
        The ICMP type to be used. Default 0.
        """
        return pulumi.get(self, "icmp_type")

    @property
    @pulumi.getter(name="ipv6CidrBlock")
    def ipv6_cidr_block(self) -> Optional[str]:
        """
        The IPv6 CIDR block.

        > For more information on ICMP types and codes, see [Internet Control Message Protocol (ICMP) Parameters](https://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml).
        """
        return pulumi.get(self, "ipv6_cidr_block")


@pulumi.output_type
class DefaultNetworkAclIngress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromPort":
            suggest = "from_port"
        elif key == "ruleNo":
            suggest = "rule_no"
        elif key == "toPort":
            suggest = "to_port"
        elif key == "cidrBlock":
            suggest = "cidr_block"
        elif key == "icmpCode":
            suggest = "icmp_code"
        elif key == "icmpType":
            suggest = "icmp_type"
        elif key == "ipv6CidrBlock":
            suggest = "ipv6_cidr_block"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DefaultNetworkAclIngress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DefaultNetworkAclIngress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DefaultNetworkAclIngress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: str,
                 from_port: int,
                 protocol: str,
                 rule_no: int,
                 to_port: int,
                 cidr_block: Optional[str] = None,
                 icmp_code: Optional[int] = None,
                 icmp_type: Optional[int] = None,
                 ipv6_cidr_block: Optional[str] = None):
        """
        :param str action: The action to take.
        :param int from_port: The from port to match.
        :param str protocol: The protocol to match. If using the -1 'all' protocol, you must specify a from and to port of 0.
        :param int rule_no: The rule number. Used for ordering.
        :param int to_port: The to port to match.
               
               The following arguments are optional:
        :param str cidr_block: The CIDR block to match. This must be a valid network mask.
        :param int icmp_code: The ICMP type code to be used. Default 0.
        :param int icmp_type: The ICMP type to be used. Default 0.
        :param str ipv6_cidr_block: The IPv6 CIDR block.
               
               > For more information on ICMP types and codes, see [Internet Control Message Protocol (ICMP) Parameters](https://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml).
        """
        DefaultNetworkAclIngress._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            from_port=from_port,
            protocol=protocol,
            rule_no=rule_no,
            to_port=to_port,
            cidr_block=cidr_block,
            icmp_code=icmp_code,
            icmp_type=icmp_type,
            ipv6_cidr_block=ipv6_cidr_block,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: Optional[str] = None,
             from_port: Optional[int] = None,
             protocol: Optional[str] = None,
             rule_no: Optional[int] = None,
             to_port: Optional[int] = None,
             cidr_block: Optional[str] = None,
             icmp_code: Optional[int] = None,
             icmp_type: Optional[int] = None,
             ipv6_cidr_block: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if action is None:
            raise TypeError("Missing 'action' argument")
        if from_port is None and 'fromPort' in kwargs:
            from_port = kwargs['fromPort']
        if from_port is None:
            raise TypeError("Missing 'from_port' argument")
        if protocol is None:
            raise TypeError("Missing 'protocol' argument")
        if rule_no is None and 'ruleNo' in kwargs:
            rule_no = kwargs['ruleNo']
        if rule_no is None:
            raise TypeError("Missing 'rule_no' argument")
        if to_port is None and 'toPort' in kwargs:
            to_port = kwargs['toPort']
        if to_port is None:
            raise TypeError("Missing 'to_port' argument")
        if cidr_block is None and 'cidrBlock' in kwargs:
            cidr_block = kwargs['cidrBlock']
        if icmp_code is None and 'icmpCode' in kwargs:
            icmp_code = kwargs['icmpCode']
        if icmp_type is None and 'icmpType' in kwargs:
            icmp_type = kwargs['icmpType']
        if ipv6_cidr_block is None and 'ipv6CidrBlock' in kwargs:
            ipv6_cidr_block = kwargs['ipv6CidrBlock']

        _setter("action", action)
        _setter("from_port", from_port)
        _setter("protocol", protocol)
        _setter("rule_no", rule_no)
        _setter("to_port", to_port)
        if cidr_block is not None:
            _setter("cidr_block", cidr_block)
        if icmp_code is not None:
            _setter("icmp_code", icmp_code)
        if icmp_type is not None:
            _setter("icmp_type", icmp_type)
        if ipv6_cidr_block is not None:
            _setter("ipv6_cidr_block", ipv6_cidr_block)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        The action to take.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> int:
        """
        The from port to match.
        """
        return pulumi.get(self, "from_port")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        The protocol to match. If using the -1 'all' protocol, you must specify a from and to port of 0.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="ruleNo")
    def rule_no(self) -> int:
        """
        The rule number. Used for ordering.
        """
        return pulumi.get(self, "rule_no")

    @property
    @pulumi.getter(name="toPort")
    def to_port(self) -> int:
        """
        The to port to match.

        The following arguments are optional:
        """
        return pulumi.get(self, "to_port")

    @property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> Optional[str]:
        """
        The CIDR block to match. This must be a valid network mask.
        """
        return pulumi.get(self, "cidr_block")

    @property
    @pulumi.getter(name="icmpCode")
    def icmp_code(self) -> Optional[int]:
        """
        The ICMP type code to be used. Default 0.
        """
        return pulumi.get(self, "icmp_code")

    @property
    @pulumi.getter(name="icmpType")
    def icmp_type(self) -> Optional[int]:
        """
        The ICMP type to be used. Default 0.
        """
        return pulumi.get(self, "icmp_type")

    @property
    @pulumi.getter(name="ipv6CidrBlock")
    def ipv6_cidr_block(self) -> Optional[str]:
        """
        The IPv6 CIDR block.

        > For more information on ICMP types and codes, see [Internet Control Message Protocol (ICMP) Parameters](https://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml).
        """
        return pulumi.get(self, "ipv6_cidr_block")


@pulumi.output_type
class DefaultRouteTableRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cidrBlock":
            suggest = "cidr_block"
        elif key == "coreNetworkArn":
            suggest = "core_network_arn"
        elif key == "destinationPrefixListId":
            suggest = "destination_prefix_list_id"
        elif key == "egressOnlyGatewayId":
            suggest = "egress_only_gateway_id"
        elif key == "gatewayId":
            suggest = "gateway_id"
        elif key == "instanceId":
            suggest = "instance_id"
        elif key == "ipv6CidrBlock":
            suggest = "ipv6_cidr_block"
        elif key == "natGatewayId":
            suggest = "nat_gateway_id"
        elif key == "networkInterfaceId":
            suggest = "network_interface_id"
        elif key == "transitGatewayId":
            suggest = "transit_gateway_id"
        elif key == "vpcEndpointId":
            suggest = "vpc_endpoint_id"
        elif key == "vpcPeeringConnectionId":
            suggest = "vpc_peering_connection_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DefaultRouteTableRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DefaultRouteTableRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DefaultRouteTableRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cidr_block: Optional[str] = None,
                 core_network_arn: Optional[str] = None,
                 destination_prefix_list_id: Optional[str] = None,
                 egress_only_gateway_id: Optional[str] = None,
                 gateway_id: Optional[str] = None,
                 instance_id: Optional[str] = None,
                 ipv6_cidr_block: Optional[str] = None,
                 nat_gateway_id: Optional[str] = None,
                 network_interface_id: Optional[str] = None,
                 transit_gateway_id: Optional[str] = None,
                 vpc_endpoint_id: Optional[str] = None,
                 vpc_peering_connection_id: Optional[str] = None):
        """
        :param str cidr_block: The CIDR block of the route.
        :param str core_network_arn: The Amazon Resource Name (ARN) of a core network.
        :param str destination_prefix_list_id: The ID of a managed prefix list destination of the route.
               
               One of the following target arguments must be supplied:
        :param str egress_only_gateway_id: Identifier of a VPC Egress Only Internet Gateway.
        :param str gateway_id: Identifier of a VPC internet gateway or a virtual private gateway.
        :param str instance_id: Identifier of an EC2 instance.
        :param str ipv6_cidr_block: The Ipv6 CIDR block of the route
        :param str nat_gateway_id: Identifier of a VPC NAT gateway.
        :param str network_interface_id: Identifier of an EC2 network interface.
        :param str transit_gateway_id: Identifier of an EC2 Transit Gateway.
        :param str vpc_endpoint_id: Identifier of a VPC Endpoint. This route must be removed prior to VPC Endpoint deletion.
        :param str vpc_peering_connection_id: Identifier of a VPC peering connection.
               
               Note that the default route, mapping the VPC's CIDR block to "local", is created implicitly and cannot be specified.
        """
        DefaultRouteTableRoute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cidr_block=cidr_block,
            core_network_arn=core_network_arn,
            destination_prefix_list_id=destination_prefix_list_id,
            egress_only_gateway_id=egress_only_gateway_id,
            gateway_id=gateway_id,
            instance_id=instance_id,
            ipv6_cidr_block=ipv6_cidr_block,
            nat_gateway_id=nat_gateway_id,
            network_interface_id=network_interface_id,
            transit_gateway_id=transit_gateway_id,
            vpc_endpoint_id=vpc_endpoint_id,
            vpc_peering_connection_id=vpc_peering_connection_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cidr_block: Optional[str] = None,
             core_network_arn: Optional[str] = None,
             destination_prefix_list_id: Optional[str] = None,
             egress_only_gateway_id: Optional[str] = None,
             gateway_id: Optional[str] = None,
             instance_id: Optional[str] = None,
             ipv6_cidr_block: Optional[str] = None,
             nat_gateway_id: Optional[str] = None,
             network_interface_id: Optional[str] = None,
             transit_gateway_id: Optional[str] = None,
             vpc_endpoint_id: Optional[str] = None,
             vpc_peering_connection_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cidr_block is None and 'cidrBlock' in kwargs:
            cidr_block = kwargs['cidrBlock']
        if core_network_arn is None and 'coreNetworkArn' in kwargs:
            core_network_arn = kwargs['coreNetworkArn']
        if destination_prefix_list_id is None and 'destinationPrefixListId' in kwargs:
            destination_prefix_list_id = kwargs['destinationPrefixListId']
        if egress_only_gateway_id is None and 'egressOnlyGatewayId' in kwargs:
            egress_only_gateway_id = kwargs['egressOnlyGatewayId']
        if gateway_id is None and 'gatewayId' in kwargs:
            gateway_id = kwargs['gatewayId']
        if instance_id is None and 'instanceId' in kwargs:
            instance_id = kwargs['instanceId']
        if ipv6_cidr_block is None and 'ipv6CidrBlock' in kwargs:
            ipv6_cidr_block = kwargs['ipv6CidrBlock']
        if nat_gateway_id is None and 'natGatewayId' in kwargs:
            nat_gateway_id = kwargs['natGatewayId']
        if network_interface_id is None and 'networkInterfaceId' in kwargs:
            network_interface_id = kwargs['networkInterfaceId']
        if transit_gateway_id is None and 'transitGatewayId' in kwargs:
            transit_gateway_id = kwargs['transitGatewayId']
        if vpc_endpoint_id is None and 'vpcEndpointId' in kwargs:
            vpc_endpoint_id = kwargs['vpcEndpointId']
        if vpc_peering_connection_id is None and 'vpcPeeringConnectionId' in kwargs:
            vpc_peering_connection_id = kwargs['vpcPeeringConnectionId']

        if cidr_block is not None:
            _setter("cidr_block", cidr_block)
        if core_network_arn is not None:
            _setter("core_network_arn", core_network_arn)
        if destination_prefix_list_id is not None:
            _setter("destination_prefix_list_id", destination_prefix_list_id)
        if egress_only_gateway_id is not None:
            _setter("egress_only_gateway_id", egress_only_gateway_id)
        if gateway_id is not None:
            _setter("gateway_id", gateway_id)
        if instance_id is not None:
            _setter("instance_id", instance_id)
        if ipv6_cidr_block is not None:
            _setter("ipv6_cidr_block", ipv6_cidr_block)
        if nat_gateway_id is not None:
            _setter("nat_gateway_id", nat_gateway_id)
        if network_interface_id is not None:
            _setter("network_interface_id", network_interface_id)
        if transit_gateway_id is not None:
            _setter("transit_gateway_id", transit_gateway_id)
        if vpc_endpoint_id is not None:
            _setter("vpc_endpoint_id", vpc_endpoint_id)
        if vpc_peering_connection_id is not None:
            _setter("vpc_peering_connection_id", vpc_peering_connection_id)

    @property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> Optional[str]:
        """
        The CIDR block of the route.
        """
        return pulumi.get(self, "cidr_block")

    @property
    @pulumi.getter(name="coreNetworkArn")
    def core_network_arn(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) of a core network.
        """
        return pulumi.get(self, "core_network_arn")

    @property
    @pulumi.getter(name="destinationPrefixListId")
    def destination_prefix_list_id(self) -> Optional[str]:
        """
        The ID of a managed prefix list destination of the route.

        One of the following target arguments must be supplied:
        """
        return pulumi.get(self, "destination_prefix_list_id")

    @property
    @pulumi.getter(name="egressOnlyGatewayId")
    def egress_only_gateway_id(self) -> Optional[str]:
        """
        Identifier of a VPC Egress Only Internet Gateway.
        """
        return pulumi.get(self, "egress_only_gateway_id")

    @property
    @pulumi.getter(name="gatewayId")
    def gateway_id(self) -> Optional[str]:
        """
        Identifier of a VPC internet gateway or a virtual private gateway.
        """
        return pulumi.get(self, "gateway_id")

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[str]:
        """
        Identifier of an EC2 instance.
        """
        return pulumi.get(self, "instance_id")

    @property
    @pulumi.getter(name="ipv6CidrBlock")
    def ipv6_cidr_block(self) -> Optional[str]:
        """
        The Ipv6 CIDR block of the route
        """
        return pulumi.get(self, "ipv6_cidr_block")

    @property
    @pulumi.getter(name="natGatewayId")
    def nat_gateway_id(self) -> Optional[str]:
        """
        Identifier of a VPC NAT gateway.
        """
        return pulumi.get(self, "nat_gateway_id")

    @property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> Optional[str]:
        """
        Identifier of an EC2 network interface.
        """
        return pulumi.get(self, "network_interface_id")

    @property
    @pulumi.getter(name="transitGatewayId")
    def transit_gateway_id(self) -> Optional[str]:
        """
        Identifier of an EC2 Transit Gateway.
        """
        return pulumi.get(self, "transit_gateway_id")

    @property
    @pulumi.getter(name="vpcEndpointId")
    def vpc_endpoint_id(self) -> Optional[str]:
        """
        Identifier of a VPC Endpoint. This route must be removed prior to VPC Endpoint deletion.
        """
        return pulumi.get(self, "vpc_endpoint_id")

    @property
    @pulumi.getter(name="vpcPeeringConnectionId")
    def vpc_peering_connection_id(self) -> Optional[str]:
        """
        Identifier of a VPC peering connection.

        Note that the default route, mapping the VPC's CIDR block to "local", is created implicitly and cannot be specified.
        """
        return pulumi.get(self, "vpc_peering_connection_id")


@pulumi.output_type
class DefaultSecurityGroupEgress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromPort":
            suggest = "from_port"
        elif key == "toPort":
            suggest = "to_port"
        elif key == "cidrBlocks":
            suggest = "cidr_blocks"
        elif key == "ipv6CidrBlocks":
            suggest = "ipv6_cidr_blocks"
        elif key == "prefixListIds":
            suggest = "prefix_list_ids"
        elif key == "securityGroups":
            suggest = "security_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DefaultSecurityGroupEgress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DefaultSecurityGroupEgress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DefaultSecurityGroupEgress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_port: int,
                 protocol: str,
                 to_port: int,
                 cidr_blocks: Optional[Sequence[str]] = None,
                 description: Optional[str] = None,
                 ipv6_cidr_blocks: Optional[Sequence[str]] = None,
                 prefix_list_ids: Optional[Sequence[str]] = None,
                 security_groups: Optional[Sequence[str]] = None,
                 self: Optional[bool] = None):
        """
        :param int from_port: Start port (or ICMP type number if protocol is `icmp`)
        :param str protocol: Protocol. If you select a protocol of "-1" (semantically equivalent to `all`, which is not a valid value here), you must specify a `from_port` and `to_port` equal to `0`. If not `icmp`, `tcp`, `udp`, or `-1` use the [protocol number](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml).
        :param int to_port: End range port (or ICMP code if protocol is `icmp`).
        :param Sequence[str] cidr_blocks: List of CIDR blocks.
        :param str description: Description of this rule.
        :param Sequence[str] ipv6_cidr_blocks: List of IPv6 CIDR blocks.
        :param Sequence[str] prefix_list_ids: List of prefix list IDs (for allowing access to VPC endpoints)
        :param Sequence[str] security_groups: List of security groups. A group name can be used relative to the default VPC. Otherwise, group ID.
        :param bool self: Whether the security group itself will be added as a source to this egress rule.
        """
        DefaultSecurityGroupEgress._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            from_port=from_port,
            protocol=protocol,
            to_port=to_port,
            cidr_blocks=cidr_blocks,
            description=description,
            ipv6_cidr_blocks=ipv6_cidr_blocks,
            prefix_list_ids=prefix_list_ids,
            security_groups=security_groups,
            self=self,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             from_port: Optional[int] = None,
             protocol: Optional[str] = None,
             to_port: Optional[int] = None,
             cidr_blocks: Optional[Sequence[str]] = None,
             description: Optional[str] = None,
             ipv6_cidr_blocks: Optional[Sequence[str]] = None,
             prefix_list_ids: Optional[Sequence[str]] = None,
             security_groups: Optional[Sequence[str]] = None,
             self: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if from_port is None and 'fromPort' in kwargs:
            from_port = kwargs['fromPort']
        if from_port is None:
            raise TypeError("Missing 'from_port' argument")
        if protocol is None:
            raise TypeError("Missing 'protocol' argument")
        if to_port is None and 'toPort' in kwargs:
            to_port = kwargs['toPort']
        if to_port is None:
            raise TypeError("Missing 'to_port' argument")
        if cidr_blocks is None and 'cidrBlocks' in kwargs:
            cidr_blocks = kwargs['cidrBlocks']
        if ipv6_cidr_blocks is None and 'ipv6CidrBlocks' in kwargs:
            ipv6_cidr_blocks = kwargs['ipv6CidrBlocks']
        if prefix_list_ids is None and 'prefixListIds' in kwargs:
            prefix_list_ids = kwargs['prefixListIds']
        if security_groups is None and 'securityGroups' in kwargs:
            security_groups = kwargs['securityGroups']

        _setter("from_port", from_port)
        _setter("protocol", protocol)
        _setter("to_port", to_port)
        if cidr_blocks is not None:
            _setter("cidr_blocks", cidr_blocks)
        if description is not None:
            _setter("description", description)
        if ipv6_cidr_blocks is not None:
            _setter("ipv6_cidr_blocks", ipv6_cidr_blocks)
        if prefix_list_ids is not None:
            _setter("prefix_list_ids", prefix_list_ids)
        if security_groups is not None:
            _setter("security_groups", security_groups)
        if self is not None:
            _setter("self", self)

    @property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> int:
        """
        Start port (or ICMP type number if protocol is `icmp`)
        """
        return pulumi.get(self, "from_port")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        Protocol. If you select a protocol of "-1" (semantically equivalent to `all`, which is not a valid value here), you must specify a `from_port` and `to_port` equal to `0`. If not `icmp`, `tcp`, `udp`, or `-1` use the [protocol number](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml).
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="toPort")
    def to_port(self) -> int:
        """
        End range port (or ICMP code if protocol is `icmp`).
        """
        return pulumi.get(self, "to_port")

    @property
    @pulumi.getter(name="cidrBlocks")
    def cidr_blocks(self) -> Optional[Sequence[str]]:
        """
        List of CIDR blocks.
        """
        return pulumi.get(self, "cidr_blocks")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of this rule.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="ipv6CidrBlocks")
    def ipv6_cidr_blocks(self) -> Optional[Sequence[str]]:
        """
        List of IPv6 CIDR blocks.
        """
        return pulumi.get(self, "ipv6_cidr_blocks")

    @property
    @pulumi.getter(name="prefixListIds")
    def prefix_list_ids(self) -> Optional[Sequence[str]]:
        """
        List of prefix list IDs (for allowing access to VPC endpoints)
        """
        return pulumi.get(self, "prefix_list_ids")

    @property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[Sequence[str]]:
        """
        List of security groups. A group name can be used relative to the default VPC. Otherwise, group ID.
        """
        return pulumi.get(self, "security_groups")

    @property
    @pulumi.getter
    def self(self) -> Optional[bool]:
        """
        Whether the security group itself will be added as a source to this egress rule.
        """
        return pulumi.get(self, "self")


@pulumi.output_type
class DefaultSecurityGroupIngress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromPort":
            suggest = "from_port"
        elif key == "toPort":
            suggest = "to_port"
        elif key == "cidrBlocks":
            suggest = "cidr_blocks"
        elif key == "ipv6CidrBlocks":
            suggest = "ipv6_cidr_blocks"
        elif key == "prefixListIds":
            suggest = "prefix_list_ids"
        elif key == "securityGroups":
            suggest = "security_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DefaultSecurityGroupIngress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DefaultSecurityGroupIngress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DefaultSecurityGroupIngress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_port: int,
                 protocol: str,
                 to_port: int,
                 cidr_blocks: Optional[Sequence[str]] = None,
                 description: Optional[str] = None,
                 ipv6_cidr_blocks: Optional[Sequence[str]] = None,
                 prefix_list_ids: Optional[Sequence[str]] = None,
                 security_groups: Optional[Sequence[str]] = None,
                 self: Optional[bool] = None):
        """
        :param int from_port: Start port (or ICMP type number if protocol is `icmp`)
        :param str protocol: Protocol. If you select a protocol of "-1" (semantically equivalent to `all`, which is not a valid value here), you must specify a `from_port` and `to_port` equal to `0`. If not `icmp`, `tcp`, `udp`, or `-1` use the [protocol number](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml).
        :param int to_port: End range port (or ICMP code if protocol is `icmp`).
        :param Sequence[str] cidr_blocks: List of CIDR blocks.
        :param str description: Description of this rule.
        :param Sequence[str] ipv6_cidr_blocks: List of IPv6 CIDR blocks.
        :param Sequence[str] prefix_list_ids: List of prefix list IDs (for allowing access to VPC endpoints)
        :param Sequence[str] security_groups: List of security groups. A group name can be used relative to the default VPC. Otherwise, group ID.
        :param bool self: Whether the security group itself will be added as a source to this egress rule.
        """
        DefaultSecurityGroupIngress._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            from_port=from_port,
            protocol=protocol,
            to_port=to_port,
            cidr_blocks=cidr_blocks,
            description=description,
            ipv6_cidr_blocks=ipv6_cidr_blocks,
            prefix_list_ids=prefix_list_ids,
            security_groups=security_groups,
            self=self,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             from_port: Optional[int] = None,
             protocol: Optional[str] = None,
             to_port: Optional[int] = None,
             cidr_blocks: Optional[Sequence[str]] = None,
             description: Optional[str] = None,
             ipv6_cidr_blocks: Optional[Sequence[str]] = None,
             prefix_list_ids: Optional[Sequence[str]] = None,
             security_groups: Optional[Sequence[str]] = None,
             self: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if from_port is None and 'fromPort' in kwargs:
            from_port = kwargs['fromPort']
        if from_port is None:
            raise TypeError("Missing 'from_port' argument")
        if protocol is None:
            raise TypeError("Missing 'protocol' argument")
        if to_port is None and 'toPort' in kwargs:
            to_port = kwargs['toPort']
        if to_port is None:
            raise TypeError("Missing 'to_port' argument")
        if cidr_blocks is None and 'cidrBlocks' in kwargs:
            cidr_blocks = kwargs['cidrBlocks']
        if ipv6_cidr_blocks is None and 'ipv6CidrBlocks' in kwargs:
            ipv6_cidr_blocks = kwargs['ipv6CidrBlocks']
        if prefix_list_ids is None and 'prefixListIds' in kwargs:
            prefix_list_ids = kwargs['prefixListIds']
        if security_groups is None and 'securityGroups' in kwargs:
            security_groups = kwargs['securityGroups']

        _setter("from_port", from_port)
        _setter("protocol", protocol)
        _setter("to_port", to_port)
        if cidr_blocks is not None:
            _setter("cidr_blocks", cidr_blocks)
        if description is not None:
            _setter("description", description)
        if ipv6_cidr_blocks is not None:
            _setter("ipv6_cidr_blocks", ipv6_cidr_blocks)
        if prefix_list_ids is not None:
            _setter("prefix_list_ids", prefix_list_ids)
        if security_groups is not None:
            _setter("security_groups", security_groups)
        if self is not None:
            _setter("self", self)

    @property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> int:
        """
        Start port (or ICMP type number if protocol is `icmp`)
        """
        return pulumi.get(self, "from_port")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        Protocol. If you select a protocol of "-1" (semantically equivalent to `all`, which is not a valid value here), you must specify a `from_port` and `to_port` equal to `0`. If not `icmp`, `tcp`, `udp`, or `-1` use the [protocol number](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml).
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="toPort")
    def to_port(self) -> int:
        """
        End range port (or ICMP code if protocol is `icmp`).
        """
        return pulumi.get(self, "to_port")

    @property
    @pulumi.getter(name="cidrBlocks")
    def cidr_blocks(self) -> Optional[Sequence[str]]:
        """
        List of CIDR blocks.
        """
        return pulumi.get(self, "cidr_blocks")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of this rule.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="ipv6CidrBlocks")
    def ipv6_cidr_blocks(self) -> Optional[Sequence[str]]:
        """
        List of IPv6 CIDR blocks.
        """
        return pulumi.get(self, "ipv6_cidr_blocks")

    @property
    @pulumi.getter(name="prefixListIds")
    def prefix_list_ids(self) -> Optional[Sequence[str]]:
        """
        List of prefix list IDs (for allowing access to VPC endpoints)
        """
        return pulumi.get(self, "prefix_list_ids")

    @property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[Sequence[str]]:
        """
        List of security groups. A group name can be used relative to the default VPC. Otherwise, group ID.
        """
        return pulumi.get(self, "security_groups")

    @property
    @pulumi.getter
    def self(self) -> Optional[bool]:
        """
        Whether the security group itself will be added as a source to this egress rule.
        """
        return pulumi.get(self, "self")


@pulumi.output_type
class FleetFleetInstanceSet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceIds":
            suggest = "instance_ids"
        elif key == "instanceType":
            suggest = "instance_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FleetFleetInstanceSet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FleetFleetInstanceSet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FleetFleetInstanceSet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_ids: Optional[Sequence[str]] = None,
                 instance_type: Optional[str] = None,
                 lifecycle: Optional[str] = None,
                 platform: Optional[str] = None):
        """
        :param Sequence[str] instance_ids: The IDs of the instances.
        :param str instance_type: Instance type.
        :param str lifecycle: Indicates if the instance that was launched is a Spot Instance or On-Demand Instance.
        :param str platform: The value is `Windows` for Windows instances. Otherwise, the value is blank.
        """
        FleetFleetInstanceSet._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            instance_ids=instance_ids,
            instance_type=instance_type,
            lifecycle=lifecycle,
            platform=platform,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             instance_ids: Optional[Sequence[str]] = None,
             instance_type: Optional[str] = None,
             lifecycle: Optional[str] = None,
             platform: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if instance_ids is None and 'instanceIds' in kwargs:
            instance_ids = kwargs['instanceIds']
        if instance_type is None and 'instanceType' in kwargs:
            instance_type = kwargs['instanceType']

        if instance_ids is not None:
            _setter("instance_ids", instance_ids)
        if instance_type is not None:
            _setter("instance_type", instance_type)
        if lifecycle is not None:
            _setter("lifecycle", lifecycle)
        if platform is not None:
            _setter("platform", platform)

    @property
    @pulumi.getter(name="instanceIds")
    def instance_ids(self) -> Optional[Sequence[str]]:
        """
        The IDs of the instances.
        """
        return pulumi.get(self, "instance_ids")

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[str]:
        """
        Instance type.
        """
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter
    def lifecycle(self) -> Optional[str]:
        """
        Indicates if the instance that was launched is a Spot Instance or On-Demand Instance.
        """
        return pulumi.get(self, "lifecycle")

    @property
    @pulumi.getter
    def platform(self) -> Optional[str]:
        """
        The value is `Windows` for Windows instances. Otherwise, the value is blank.
        """
        return pulumi.get(self, "platform")


@pulumi.output_type
class FleetLaunchTemplateConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "launchTemplateSpecification":
            suggest = "launch_template_specification"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FleetLaunchTemplateConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FleetLaunchTemplateConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FleetLaunchTemplateConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 launch_template_specification: Optional['outputs.FleetLaunchTemplateConfigLaunchTemplateSpecification'] = None,
                 overrides: Optional[Sequence['outputs.FleetLaunchTemplateConfigOverride']] = None):
        """
        :param 'FleetLaunchTemplateConfigLaunchTemplateSpecificationArgs' launch_template_specification: Nested argument containing EC2 Launch Template to use. Defined below.
        :param Sequence['FleetLaunchTemplateConfigOverrideArgs'] overrides: Nested argument(s) containing parameters to override the same parameters in the Launch Template. Defined below.
        """
        FleetLaunchTemplateConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            launch_template_specification=launch_template_specification,
            overrides=overrides,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             launch_template_specification: Optional['outputs.FleetLaunchTemplateConfigLaunchTemplateSpecification'] = None,
             overrides: Optional[Sequence['outputs.FleetLaunchTemplateConfigOverride']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if launch_template_specification is None and 'launchTemplateSpecification' in kwargs:
            launch_template_specification = kwargs['launchTemplateSpecification']

        if launch_template_specification is not None:
            _setter("launch_template_specification", launch_template_specification)
        if overrides is not None:
            _setter("overrides", overrides)

    @property
    @pulumi.getter(name="launchTemplateSpecification")
    def launch_template_specification(self) -> Optional['outputs.FleetLaunchTemplateConfigLaunchTemplateSpecification']:
        """
        Nested argument containing EC2 Launch Template to use. Defined below.
        """
        return pulumi.get(self, "launch_template_specification")

    @property
    @pulumi.getter
    def overrides(self) -> Optional[Sequence['outputs.FleetLaunchTemplateConfigOverride']]:
        """
        Nested argument(s) containing parameters to override the same parameters in the Launch Template. Defined below.
        """
        return pulumi.get(self, "overrides")


@pulumi.output_type
class FleetLaunchTemplateConfigLaunchTemplateSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "launchTemplateId":
            suggest = "launch_template_id"
        elif key == "launchTemplateName":
            suggest = "launch_template_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FleetLaunchTemplateConfigLaunchTemplateSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FleetLaunchTemplateConfigLaunchTemplateSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FleetLaunchTemplateConfigLaunchTemplateSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 version: str,
                 launch_template_id: Optional[str] = None,
                 launch_template_name: Optional[str] = None):
        """
        :param str version: The launch template version number, `$Latest`, or `$Default.`
        :param str launch_template_id: The ID of the launch template.
        :param str launch_template_name: The name of the launch template.
        """
        FleetLaunchTemplateConfigLaunchTemplateSpecification._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            version=version,
            launch_template_id=launch_template_id,
            launch_template_name=launch_template_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             version: Optional[str] = None,
             launch_template_id: Optional[str] = None,
             launch_template_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if version is None:
            raise TypeError("Missing 'version' argument")
        if launch_template_id is None and 'launchTemplateId' in kwargs:
            launch_template_id = kwargs['launchTemplateId']
        if launch_template_name is None and 'launchTemplateName' in kwargs:
            launch_template_name = kwargs['launchTemplateName']

        _setter("version", version)
        if launch_template_id is not None:
            _setter("launch_template_id", launch_template_id)
        if launch_template_name is not None:
            _setter("launch_template_name", launch_template_name)

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        The launch template version number, `$Latest`, or `$Default.`
        """
        return pulumi.get(self, "version")

    @property
    @pulumi.getter(name="launchTemplateId")
    def launch_template_id(self) -> Optional[str]:
        """
        The ID of the launch template.
        """
        return pulumi.get(self, "launch_template_id")

    @property
    @pulumi.getter(name="launchTemplateName")
    def launch_template_name(self) -> Optional[str]:
        """
        The name of the launch template.
        """
        return pulumi.get(self, "launch_template_name")


@pulumi.output_type
class FleetLaunchTemplateConfigOverride(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "instanceRequirements":
            suggest = "instance_requirements"
        elif key == "instanceType":
            suggest = "instance_type"
        elif key == "maxPrice":
            suggest = "max_price"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "weightedCapacity":
            suggest = "weighted_capacity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FleetLaunchTemplateConfigOverride. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FleetLaunchTemplateConfigOverride.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FleetLaunchTemplateConfigOverride.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_zone: Optional[str] = None,
                 instance_requirements: Optional['outputs.FleetLaunchTemplateConfigOverrideInstanceRequirements'] = None,
                 instance_type: Optional[str] = None,
                 max_price: Optional[str] = None,
                 priority: Optional[float] = None,
                 subnet_id: Optional[str] = None,
                 weighted_capacity: Optional[float] = None):
        """
        :param str availability_zone: Availability Zone in which to launch the instances.
        :param 'FleetLaunchTemplateConfigOverrideInstanceRequirementsArgs' instance_requirements: Override the instance type in the Launch Template with instance types that satisfy the requirements.
        :param str instance_type: Instance type.
        :param str max_price: Maximum price per unit hour that you are willing to pay for a Spot Instance.
        :param float priority: Priority for the launch template override. If `on_demand_options` `allocation_strategy` is set to `prioritized`, EC2 Fleet uses priority to determine which launch template override to use first in fulfilling On-Demand capacity. The highest priority is launched first. The lower the number, the higher the priority. If no number is set, the launch template override has the lowest priority. Valid values are whole numbers starting at 0.
        :param str subnet_id: ID of the subnet in which to launch the instances.
        :param float weighted_capacity: Number of units provided by the specified instance type.
        """
        FleetLaunchTemplateConfigOverride._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability_zone=availability_zone,
            instance_requirements=instance_requirements,
            instance_type=instance_type,
            max_price=max_price,
            priority=priority,
            subnet_id=subnet_id,
            weighted_capacity=weighted_capacity,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability_zone: Optional[str] = None,
             instance_requirements: Optional['outputs.FleetLaunchTemplateConfigOverrideInstanceRequirements'] = None,
             instance_type: Optional[str] = None,
             max_price: Optional[str] = None,
             priority: Optional[float] = None,
             subnet_id: Optional[str] = None,
             weighted_capacity: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if availability_zone is None and 'availabilityZone' in kwargs:
            availability_zone = kwargs['availabilityZone']
        if instance_requirements is None and 'instanceRequirements' in kwargs:
            instance_requirements = kwargs['instanceRequirements']
        if instance_type is None and 'instanceType' in kwargs:
            instance_type = kwargs['instanceType']
        if max_price is None and 'maxPrice' in kwargs:
            max_price = kwargs['maxPrice']
        if subnet_id is None and 'subnetId' in kwargs:
            subnet_id = kwargs['subnetId']
        if weighted_capacity is None and 'weightedCapacity' in kwargs:
            weighted_capacity = kwargs['weightedCapacity']

        if availability_zone is not None:
            _setter("availability_zone", availability_zone)
        if instance_requirements is not None:
            _setter("instance_requirements", instance_requirements)
        if instance_type is not None:
            _setter("instance_type", instance_type)
        if max_price is not None:
            _setter("max_price", max_price)
        if priority is not None:
            _setter("priority", priority)
        if subnet_id is not None:
            _setter("subnet_id", subnet_id)
        if weighted_capacity is not None:
            _setter("weighted_capacity", weighted_capacity)

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[str]:
        """
        Availability Zone in which to launch the instances.
        """
        return pulumi.get(self, "availability_zone")

    @property
    @pulumi.getter(name="instanceRequirements")
    def instance_requirements(self) -> Optional['outputs.FleetLaunchTemplateConfigOverrideInstanceRequirements']:
        """
        Override the instance type in the Launch Template with instance types that satisfy the requirements.
        """
        return pulumi.get(self, "instance_requirements")

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[str]:
        """
        Instance type.
        """
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter(name="maxPrice")
    def max_price(self) -> Optional[str]:
        """
        Maximum price per unit hour that you are willing to pay for a Spot Instance.
        """
        return pulumi.get(self, "max_price")

    @property
    @pulumi.getter
    def priority(self) -> Optional[float]:
        """
        Priority for the launch template override. If `on_demand_options` `allocation_strategy` is set to `prioritized`, EC2 Fleet uses priority to determine which launch template override to use first in fulfilling On-Demand capacity. The highest priority is launched first. The lower the number, the higher the priority. If no number is set, the launch template override has the lowest priority. Valid values are whole numbers starting at 0.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        ID of the subnet in which to launch the instances.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="weightedCapacity")
    def weighted_capacity(self) -> Optional[float]:
        """
        Number of units provided by the specified instance type.
        """
        return pulumi.get(self, "weighted_capacity")


@pulumi.output_type
class FleetLaunchTemplateConfigOverrideInstanceRequirements(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "memoryMib":
            suggest = "memory_mib"
        elif key == "vcpuCount":
            suggest = "vcpu_count"
        elif key == "acceleratorCount":
            suggest = "accelerator_count"
        elif key == "acceleratorManufacturers":
            suggest = "accelerator_manufacturers"
        elif key == "acceleratorNames":
            suggest = "accelerator_names"
        elif key == "acceleratorTotalMemoryMib":
            suggest = "accelerator_total_memory_mib"
        elif key == "acceleratorTypes":
            suggest = "accelerator_types"
        elif key == "allowedInstanceTypes":
            suggest = "allowed_instance_types"
        elif key == "bareMetal":
            suggest = "bare_metal"
        elif key == "baselineEbsBandwidthMbps":
            suggest = "baseline_ebs_bandwidth_mbps"
        elif key == "burstablePerformance":
            suggest = "burstable_performance"
        elif key == "cpuManufacturers":
            suggest = "cpu_manufacturers"
        elif key == "excludedInstanceTypes":
            suggest = "excluded_instance_types"
        elif key == "instanceGenerations":
            suggest = "instance_generations"
        elif key == "localStorage":
            suggest = "local_storage"
        elif key == "localStorageTypes":
            suggest = "local_storage_types"
        elif key == "memoryGibPerVcpu":
            suggest = "memory_gib_per_vcpu"
        elif key == "networkBandwidthGbps":
            suggest = "network_bandwidth_gbps"
        elif key == "networkInterfaceCount":
            suggest = "network_interface_count"
        elif key == "onDemandMaxPricePercentageOverLowestPrice":
            suggest = "on_demand_max_price_percentage_over_lowest_price"
        elif key == "requireHibernateSupport":
            suggest = "require_hibernate_support"
        elif key == "spotMaxPricePercentageOverLowestPrice":
            suggest = "spot_max_price_percentage_over_lowest_price"
        elif key == "totalLocalStorageGb":
            suggest = "total_local_storage_gb"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FleetLaunchTemplateConfigOverrideInstanceRequirements. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FleetLaunchTemplateConfigOverrideInstanceRequirements.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FleetLaunchTemplateConfigOverrideInstanceRequirements.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 memory_mib: 'outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsMemoryMib',
                 vcpu_count: 'outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsVcpuCount',
                 accelerator_count: Optional['outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorCount'] = None,
                 accelerator_manufacturers: Optional[Sequence[str]] = None,
                 accelerator_names: Optional[Sequence[str]] = None,
                 accelerator_total_memory_mib: Optional['outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorTotalMemoryMib'] = None,
                 accelerator_types: Optional[Sequence[str]] = None,
                 allowed_instance_types: Optional[Sequence[str]] = None,
                 bare_metal: Optional[str] = None,
                 baseline_ebs_bandwidth_mbps: Optional['outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsBaselineEbsBandwidthMbps'] = None,
                 burstable_performance: Optional[str] = None,
                 cpu_manufacturers: Optional[Sequence[str]] = None,
                 excluded_instance_types: Optional[Sequence[str]] = None,
                 instance_generations: Optional[Sequence[str]] = None,
                 local_storage: Optional[str] = None,
                 local_storage_types: Optional[Sequence[str]] = None,
                 memory_gib_per_vcpu: Optional['outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsMemoryGibPerVcpu'] = None,
                 network_bandwidth_gbps: Optional['outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsNetworkBandwidthGbps'] = None,
                 network_interface_count: Optional['outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsNetworkInterfaceCount'] = None,
                 on_demand_max_price_percentage_over_lowest_price: Optional[int] = None,
                 require_hibernate_support: Optional[bool] = None,
                 spot_max_price_percentage_over_lowest_price: Optional[int] = None,
                 total_local_storage_gb: Optional['outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsTotalLocalStorageGb'] = None):
        """
        :param 'FleetLaunchTemplateConfigOverrideInstanceRequirementsMemoryMibArgs' memory_mib: The minimum and maximum amount of memory per vCPU, in GiB. Default is no minimum or maximum limits.
        :param 'FleetLaunchTemplateConfigOverrideInstanceRequirementsVcpuCountArgs' vcpu_count: Block describing the minimum and maximum number of vCPUs. Default is no maximum.
        :param 'FleetLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorCountArgs' accelerator_count: Block describing the minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips). Default is no minimum or maximum limits.
        :param Sequence[str] accelerator_manufacturers: List of accelerator manufacturer names. Default is any manufacturer.
        :param Sequence[str] accelerator_names: List of accelerator names. Default is any acclerator.
        :param 'FleetLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorTotalMemoryMibArgs' accelerator_total_memory_mib: Block describing the minimum and maximum total memory of the accelerators. Default is no minimum or maximum.
        :param Sequence[str] accelerator_types: The accelerator types that must be on the instance type. Default is any accelerator type.
        :param Sequence[str] allowed_instance_types: The instance types to apply your specified attributes against. All other instance types are ignored, even if they match your specified attributes. You can use strings with one or more wild cards,represented by an asterisk (\\*). The following are examples: `c5*`, `m5a.*`, `r*`, `*3*`. For example, if you specify `c5*`, you are excluding the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*`, you are excluding all the M5a instance types, but not the M5n instance types. Maximum of 400 entries in the list; each entry is limited to 30 characters. Default is no excluded instance types. Default is any instance type.
               
               If you specify `AllowedInstanceTypes`, you can't specify `ExcludedInstanceTypes`.
        :param str bare_metal: Indicate whether bare metal instace types should be `included`, `excluded`, or `required`. Default is `excluded`.
        :param 'FleetLaunchTemplateConfigOverrideInstanceRequirementsBaselineEbsBandwidthMbpsArgs' baseline_ebs_bandwidth_mbps: Block describing the minimum and maximum baseline EBS bandwidth, in Mbps. Default is no minimum or maximum.
        :param str burstable_performance: Indicates whether burstable performance T instance types are `included`, `excluded`, or `required`. Default is `excluded`.
        :param Sequence[str] cpu_manufacturers: The CPU manufacturers to include. Default is any manufacturer.
               > **NOTE:** Don't confuse the CPU hardware manufacturer with the CPU hardware architecture. Instances will be launched with a compatible CPU architecture based on the Amazon Machine Image (AMI) that you specify in your launch template.
        :param Sequence[str] excluded_instance_types: The instance types to exclude. You can use strings with one or more wild cards, represented by an asterisk (\\*). The following are examples: `c5*`, `m5a.*`, `r*`, `*3*`. For example, if you specify `c5*`, you are excluding the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*`, you are excluding all the M5a instance types, but not the M5n instance types. Maximum of 400 entries in the list; each entry is limited to 30 characters. Default is no excluded instance types.
               
               If you specify `AllowedInstanceTypes`, you can't specify `ExcludedInstanceTypes`.
        :param Sequence[str] instance_generations: Indicates whether current or previous generation instance types are included. The current generation instance types are recommended for use. Valid values are `current` and `previous`. Default is `current` and `previous` generation instance types.
        :param str local_storage: Indicate whether instance types with local storage volumes are `included`, `excluded`, or `required`. Default is `included`.
        :param Sequence[str] local_storage_types: List of local storage type names. Valid values are `hdd` and `ssd`. Default any storage type.
        :param 'FleetLaunchTemplateConfigOverrideInstanceRequirementsMemoryGibPerVcpuArgs' memory_gib_per_vcpu: Block describing the minimum and maximum amount of memory (GiB) per vCPU. Default is no minimum or maximum.
        :param 'FleetLaunchTemplateConfigOverrideInstanceRequirementsNetworkBandwidthGbpsArgs' network_bandwidth_gbps: The minimum and maximum amount of network bandwidth, in gigabits per second (Gbps). Default is No minimum or maximum.
        :param 'FleetLaunchTemplateConfigOverrideInstanceRequirementsNetworkInterfaceCountArgs' network_interface_count: Block describing the minimum and maximum number of network interfaces. Default is no minimum or maximum.
        :param int on_demand_max_price_percentage_over_lowest_price: The price protection threshold for On-Demand Instances. This is the maximum youll pay for an On-Demand Instance, expressed as a percentage higher than the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price is higher than your threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as 999999. Default is 20.
               
               If you set `target_capacity_unit_type` to `vcpu` or `memory-mib`, the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price.
        :param bool require_hibernate_support: Indicate whether instance types must support On-Demand Instance Hibernation, either `true` or `false`. Default is `false`.
        :param int spot_max_price_percentage_over_lowest_price: The price protection threshold for Spot Instances. This is the maximum youll pay for a Spot Instance, expressed as a percentage higher than the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price is higher than your threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as 999999. Default is 100.
               
               If you set DesiredCapacityType to vcpu or memory-mib, the price protection threshold is applied based on the per vCPU or per memory price instead of the per instance price.
        :param 'FleetLaunchTemplateConfigOverrideInstanceRequirementsTotalLocalStorageGbArgs' total_local_storage_gb: Block describing the minimum and maximum total local storage (GB). Default is no minimum or maximum.
        """
        FleetLaunchTemplateConfigOverrideInstanceRequirements._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            memory_mib=memory_mib,
            vcpu_count=vcpu_count,
            accelerator_count=accelerator_count,
            accelerator_manufacturers=accelerator_manufacturers,
            accelerator_names=accelerator_names,
            accelerator_total_memory_mib=accelerator_total_memory_mib,
            accelerator_types=accelerator_types,
            allowed_instance_types=allowed_instance_types,
            bare_metal=bare_metal,
            baseline_ebs_bandwidth_mbps=baseline_ebs_bandwidth_mbps,
            burstable_performance=burstable_performance,
            cpu_manufacturers=cpu_manufacturers,
            excluded_instance_types=excluded_instance_types,
            instance_generations=instance_generations,
            local_storage=local_storage,
            local_storage_types=local_storage_types,
            memory_gib_per_vcpu=memory_gib_per_vcpu,
            network_bandwidth_gbps=network_bandwidth_gbps,
            network_interface_count=network_interface_count,
            on_demand_max_price_percentage_over_lowest_price=on_demand_max_price_percentage_over_lowest_price,
            require_hibernate_support=require_hibernate_support,
            spot_max_price_percentage_over_lowest_price=spot_max_price_percentage_over_lowest_price,
            total_local_storage_gb=total_local_storage_gb,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             memory_mib: Optional['outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsMemoryMib'] = None,
             vcpu_count: Optional['outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsVcpuCount'] = None,
             accelerator_count: Optional['outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorCount'] = None,
             accelerator_manufacturers: Optional[Sequence[str]] = None,
             accelerator_names: Optional[Sequence[str]] = None,
             accelerator_total_memory_mib: Optional['outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorTotalMemoryMib'] = None,
             accelerator_types: Optional[Sequence[str]] = None,
             allowed_instance_types: Optional[Sequence[str]] = None,
             bare_metal: Optional[str] = None,
             baseline_ebs_bandwidth_mbps: Optional['outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsBaselineEbsBandwidthMbps'] = None,
             burstable_performance: Optional[str] = None,
             cpu_manufacturers: Optional[Sequence[str]] = None,
             excluded_instance_types: Optional[Sequence[str]] = None,
             instance_generations: Optional[Sequence[str]] = None,
             local_storage: Optional[str] = None,
             local_storage_types: Optional[Sequence[str]] = None,
             memory_gib_per_vcpu: Optional['outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsMemoryGibPerVcpu'] = None,
             network_bandwidth_gbps: Optional['outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsNetworkBandwidthGbps'] = None,
             network_interface_count: Optional['outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsNetworkInterfaceCount'] = None,
             on_demand_max_price_percentage_over_lowest_price: Optional[int] = None,
             require_hibernate_support: Optional[bool] = None,
             spot_max_price_percentage_over_lowest_price: Optional[int] = None,
             total_local_storage_gb: Optional['outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsTotalLocalStorageGb'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if memory_mib is None and 'memoryMib' in kwargs:
            memory_mib = kwargs['memoryMib']
        if memory_mib is None:
            raise TypeError("Missing 'memory_mib' argument")
        if vcpu_count is None and 'vcpuCount' in kwargs:
            vcpu_count = kwargs['vcpuCount']
        if vcpu_count is None:
            raise TypeError("Missing 'vcpu_count' argument")
        if accelerator_count is None and 'acceleratorCount' in kwargs:
            accelerator_count = kwargs['acceleratorCount']
        if accelerator_manufacturers is None and 'acceleratorManufacturers' in kwargs:
            accelerator_manufacturers = kwargs['acceleratorManufacturers']
        if accelerator_names is None and 'acceleratorNames' in kwargs:
            accelerator_names = kwargs['acceleratorNames']
        if accelerator_total_memory_mib is None and 'acceleratorTotalMemoryMib' in kwargs:
            accelerator_total_memory_mib = kwargs['acceleratorTotalMemoryMib']
        if accelerator_types is None and 'acceleratorTypes' in kwargs:
            accelerator_types = kwargs['acceleratorTypes']
        if allowed_instance_types is None and 'allowedInstanceTypes' in kwargs:
            allowed_instance_types = kwargs['allowedInstanceTypes']
        if bare_metal is None and 'bareMetal' in kwargs:
            bare_metal = kwargs['bareMetal']
        if baseline_ebs_bandwidth_mbps is None and 'baselineEbsBandwidthMbps' in kwargs:
            baseline_ebs_bandwidth_mbps = kwargs['baselineEbsBandwidthMbps']
        if burstable_performance is None and 'burstablePerformance' in kwargs:
            burstable_performance = kwargs['burstablePerformance']
        if cpu_manufacturers is None and 'cpuManufacturers' in kwargs:
            cpu_manufacturers = kwargs['cpuManufacturers']
        if excluded_instance_types is None and 'excludedInstanceTypes' in kwargs:
            excluded_instance_types = kwargs['excludedInstanceTypes']
        if instance_generations is None and 'instanceGenerations' in kwargs:
            instance_generations = kwargs['instanceGenerations']
        if local_storage is None and 'localStorage' in kwargs:
            local_storage = kwargs['localStorage']
        if local_storage_types is None and 'localStorageTypes' in kwargs:
            local_storage_types = kwargs['localStorageTypes']
        if memory_gib_per_vcpu is None and 'memoryGibPerVcpu' in kwargs:
            memory_gib_per_vcpu = kwargs['memoryGibPerVcpu']
        if network_bandwidth_gbps is None and 'networkBandwidthGbps' in kwargs:
            network_bandwidth_gbps = kwargs['networkBandwidthGbps']
        if network_interface_count is None and 'networkInterfaceCount' in kwargs:
            network_interface_count = kwargs['networkInterfaceCount']
        if on_demand_max_price_percentage_over_lowest_price is None and 'onDemandMaxPricePercentageOverLowestPrice' in kwargs:
            on_demand_max_price_percentage_over_lowest_price = kwargs['onDemandMaxPricePercentageOverLowestPrice']
        if require_hibernate_support is None and 'requireHibernateSupport' in kwargs:
            require_hibernate_support = kwargs['requireHibernateSupport']
        if spot_max_price_percentage_over_lowest_price is None and 'spotMaxPricePercentageOverLowestPrice' in kwargs:
            spot_max_price_percentage_over_lowest_price = kwargs['spotMaxPricePercentageOverLowestPrice']
        if total_local_storage_gb is None and 'totalLocalStorageGb' in kwargs:
            total_local_storage_gb = kwargs['totalLocalStorageGb']

        _setter("memory_mib", memory_mib)
        _setter("vcpu_count", vcpu_count)
        if accelerator_count is not None:
            _setter("accelerator_count", accelerator_count)
        if accelerator_manufacturers is not None:
            _setter("accelerator_manufacturers", accelerator_manufacturers)
        if accelerator_names is not None:
            _setter("accelerator_names", accelerator_names)
        if accelerator_total_memory_mib is not None:
            _setter("accelerator_total_memory_mib", accelerator_total_memory_mib)
        if accelerator_types is not None:
            _setter("accelerator_types", accelerator_types)
        if allowed_instance_types is not None:
            _setter("allowed_instance_types", allowed_instance_types)
        if bare_metal is not None:
            _setter("bare_metal", bare_metal)
        if baseline_ebs_bandwidth_mbps is not None:
            _setter("baseline_ebs_bandwidth_mbps", baseline_ebs_bandwidth_mbps)
        if burstable_performance is not None:
            _setter("burstable_performance", burstable_performance)
        if cpu_manufacturers is not None:
            _setter("cpu_manufacturers", cpu_manufacturers)
        if excluded_instance_types is not None:
            _setter("excluded_instance_types", excluded_instance_types)
        if instance_generations is not None:
            _setter("instance_generations", instance_generations)
        if local_storage is not None:
            _setter("local_storage", local_storage)
        if local_storage_types is not None:
            _setter("local_storage_types", local_storage_types)
        if memory_gib_per_vcpu is not None:
            _setter("memory_gib_per_vcpu", memory_gib_per_vcpu)
        if network_bandwidth_gbps is not None:
            _setter("network_bandwidth_gbps", network_bandwidth_gbps)
        if network_interface_count is not None:
            _setter("network_interface_count", network_interface_count)
        if on_demand_max_price_percentage_over_lowest_price is not None:
            _setter("on_demand_max_price_percentage_over_lowest_price", on_demand_max_price_percentage_over_lowest_price)
        if require_hibernate_support is not None:
            _setter("require_hibernate_support", require_hibernate_support)
        if spot_max_price_percentage_over_lowest_price is not None:
            _setter("spot_max_price_percentage_over_lowest_price", spot_max_price_percentage_over_lowest_price)
        if total_local_storage_gb is not None:
            _setter("total_local_storage_gb", total_local_storage_gb)

    @property
    @pulumi.getter(name="memoryMib")
    def memory_mib(self) -> 'outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsMemoryMib':
        """
        The minimum and maximum amount of memory per vCPU, in GiB. Default is no minimum or maximum limits.
        """
        return pulumi.get(self, "memory_mib")

    @property
    @pulumi.getter(name="vcpuCount")
    def vcpu_count(self) -> 'outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsVcpuCount':
        """
        Block describing the minimum and maximum number of vCPUs. Default is no maximum.
        """
        return pulumi.get(self, "vcpu_count")

    @property
    @pulumi.getter(name="acceleratorCount")
    def accelerator_count(self) -> Optional['outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorCount']:
        """
        Block describing the minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips). Default is no minimum or maximum limits.
        """
        return pulumi.get(self, "accelerator_count")

    @property
    @pulumi.getter(name="acceleratorManufacturers")
    def accelerator_manufacturers(self) -> Optional[Sequence[str]]:
        """
        List of accelerator manufacturer names. Default is any manufacturer.
        """
        return pulumi.get(self, "accelerator_manufacturers")

    @property
    @pulumi.getter(name="acceleratorNames")
    def accelerator_names(self) -> Optional[Sequence[str]]:
        """
        List of accelerator names. Default is any acclerator.
        """
        return pulumi.get(self, "accelerator_names")

    @property
    @pulumi.getter(name="acceleratorTotalMemoryMib")
    def accelerator_total_memory_mib(self) -> Optional['outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorTotalMemoryMib']:
        """
        Block describing the minimum and maximum total memory of the accelerators. Default is no minimum or maximum.
        """
        return pulumi.get(self, "accelerator_total_memory_mib")

    @property
    @pulumi.getter(name="acceleratorTypes")
    def accelerator_types(self) -> Optional[Sequence[str]]:
        """
        The accelerator types that must be on the instance type. Default is any accelerator type.
        """
        return pulumi.get(self, "accelerator_types")

    @property
    @pulumi.getter(name="allowedInstanceTypes")
    def allowed_instance_types(self) -> Optional[Sequence[str]]:
        """
        The instance types to apply your specified attributes against. All other instance types are ignored, even if they match your specified attributes. You can use strings with one or more wild cards,represented by an asterisk (\\*). The following are examples: `c5*`, `m5a.*`, `r*`, `*3*`. For example, if you specify `c5*`, you are excluding the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*`, you are excluding all the M5a instance types, but not the M5n instance types. Maximum of 400 entries in the list; each entry is limited to 30 characters. Default is no excluded instance types. Default is any instance type.

        If you specify `AllowedInstanceTypes`, you can't specify `ExcludedInstanceTypes`.
        """
        return pulumi.get(self, "allowed_instance_types")

    @property
    @pulumi.getter(name="bareMetal")
    def bare_metal(self) -> Optional[str]:
        """
        Indicate whether bare metal instace types should be `included`, `excluded`, or `required`. Default is `excluded`.
        """
        return pulumi.get(self, "bare_metal")

    @property
    @pulumi.getter(name="baselineEbsBandwidthMbps")
    def baseline_ebs_bandwidth_mbps(self) -> Optional['outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsBaselineEbsBandwidthMbps']:
        """
        Block describing the minimum and maximum baseline EBS bandwidth, in Mbps. Default is no minimum or maximum.
        """
        return pulumi.get(self, "baseline_ebs_bandwidth_mbps")

    @property
    @pulumi.getter(name="burstablePerformance")
    def burstable_performance(self) -> Optional[str]:
        """
        Indicates whether burstable performance T instance types are `included`, `excluded`, or `required`. Default is `excluded`.
        """
        return pulumi.get(self, "burstable_performance")

    @property
    @pulumi.getter(name="cpuManufacturers")
    def cpu_manufacturers(self) -> Optional[Sequence[str]]:
        """
        The CPU manufacturers to include. Default is any manufacturer.
        > **NOTE:** Don't confuse the CPU hardware manufacturer with the CPU hardware architecture. Instances will be launched with a compatible CPU architecture based on the Amazon Machine Image (AMI) that you specify in your launch template.
        """
        return pulumi.get(self, "cpu_manufacturers")

    @property
    @pulumi.getter(name="excludedInstanceTypes")
    def excluded_instance_types(self) -> Optional[Sequence[str]]:
        """
        The instance types to exclude. You can use strings with one or more wild cards, represented by an asterisk (\\*). The following are examples: `c5*`, `m5a.*`, `r*`, `*3*`. For example, if you specify `c5*`, you are excluding the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*`, you are excluding all the M5a instance types, but not the M5n instance types. Maximum of 400 entries in the list; each entry is limited to 30 characters. Default is no excluded instance types.

        If you specify `AllowedInstanceTypes`, you can't specify `ExcludedInstanceTypes`.
        """
        return pulumi.get(self, "excluded_instance_types")

    @property
    @pulumi.getter(name="instanceGenerations")
    def instance_generations(self) -> Optional[Sequence[str]]:
        """
        Indicates whether current or previous generation instance types are included. The current generation instance types are recommended for use. Valid values are `current` and `previous`. Default is `current` and `previous` generation instance types.
        """
        return pulumi.get(self, "instance_generations")

    @property
    @pulumi.getter(name="localStorage")
    def local_storage(self) -> Optional[str]:
        """
        Indicate whether instance types with local storage volumes are `included`, `excluded`, or `required`. Default is `included`.
        """
        return pulumi.get(self, "local_storage")

    @property
    @pulumi.getter(name="localStorageTypes")
    def local_storage_types(self) -> Optional[Sequence[str]]:
        """
        List of local storage type names. Valid values are `hdd` and `ssd`. Default any storage type.
        """
        return pulumi.get(self, "local_storage_types")

    @property
    @pulumi.getter(name="memoryGibPerVcpu")
    def memory_gib_per_vcpu(self) -> Optional['outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsMemoryGibPerVcpu']:
        """
        Block describing the minimum and maximum amount of memory (GiB) per vCPU. Default is no minimum or maximum.
        """
        return pulumi.get(self, "memory_gib_per_vcpu")

    @property
    @pulumi.getter(name="networkBandwidthGbps")
    def network_bandwidth_gbps(self) -> Optional['outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsNetworkBandwidthGbps']:
        """
        The minimum and maximum amount of network bandwidth, in gigabits per second (Gbps). Default is No minimum or maximum.
        """
        return pulumi.get(self, "network_bandwidth_gbps")

    @property
    @pulumi.getter(name="networkInterfaceCount")
    def network_interface_count(self) -> Optional['outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsNetworkInterfaceCount']:
        """
        Block describing the minimum and maximum number of network interfaces. Default is no minimum or maximum.
        """
        return pulumi.get(self, "network_interface_count")

    @property
    @pulumi.getter(name="onDemandMaxPricePercentageOverLowestPrice")
    def on_demand_max_price_percentage_over_lowest_price(self) -> Optional[int]:
        """
        The price protection threshold for On-Demand Instances. This is the maximum youll pay for an On-Demand Instance, expressed as a percentage higher than the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price is higher than your threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as 999999. Default is 20.

        If you set `target_capacity_unit_type` to `vcpu` or `memory-mib`, the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price.
        """
        return pulumi.get(self, "on_demand_max_price_percentage_over_lowest_price")

    @property
    @pulumi.getter(name="requireHibernateSupport")
    def require_hibernate_support(self) -> Optional[bool]:
        """
        Indicate whether instance types must support On-Demand Instance Hibernation, either `true` or `false`. Default is `false`.
        """
        return pulumi.get(self, "require_hibernate_support")

    @property
    @pulumi.getter(name="spotMaxPricePercentageOverLowestPrice")
    def spot_max_price_percentage_over_lowest_price(self) -> Optional[int]:
        """
        The price protection threshold for Spot Instances. This is the maximum youll pay for a Spot Instance, expressed as a percentage higher than the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price is higher than your threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as 999999. Default is 100.

        If you set DesiredCapacityType to vcpu or memory-mib, the price protection threshold is applied based on the per vCPU or per memory price instead of the per instance price.
        """
        return pulumi.get(self, "spot_max_price_percentage_over_lowest_price")

    @property
    @pulumi.getter(name="totalLocalStorageGb")
    def total_local_storage_gb(self) -> Optional['outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsTotalLocalStorageGb']:
        """
        Block describing the minimum and maximum total local storage (GB). Default is no minimum or maximum.
        """
        return pulumi.get(self, "total_local_storage_gb")


@pulumi.output_type
class FleetLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorCount(dict):
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        """
        :param int max: The maximum number of vCPUs. To specify no maximum limit, omit this parameter.
        :param int min: The minimum number of vCPUs. To specify no minimum limit, specify `0`.
        """
        FleetLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorCount._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            min=min,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: Optional[int] = None,
             min: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if max is not None:
            _setter("max", max)
        if min is not None:
            _setter("min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        """
        The maximum number of vCPUs. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        """
        The minimum number of vCPUs. To specify no minimum limit, specify `0`.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class FleetLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorTotalMemoryMib(dict):
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        """
        :param int max: The maximum number of vCPUs. To specify no maximum limit, omit this parameter.
        :param int min: The minimum number of vCPUs. To specify no minimum limit, specify `0`.
        """
        FleetLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorTotalMemoryMib._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            min=min,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: Optional[int] = None,
             min: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if max is not None:
            _setter("max", max)
        if min is not None:
            _setter("min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        """
        The maximum number of vCPUs. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        """
        The minimum number of vCPUs. To specify no minimum limit, specify `0`.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class FleetLaunchTemplateConfigOverrideInstanceRequirementsBaselineEbsBandwidthMbps(dict):
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        """
        :param int max: The maximum number of vCPUs. To specify no maximum limit, omit this parameter.
        :param int min: The minimum number of vCPUs. To specify no minimum limit, specify `0`.
        """
        FleetLaunchTemplateConfigOverrideInstanceRequirementsBaselineEbsBandwidthMbps._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            min=min,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: Optional[int] = None,
             min: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if max is not None:
            _setter("max", max)
        if min is not None:
            _setter("min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        """
        The maximum number of vCPUs. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        """
        The minimum number of vCPUs. To specify no minimum limit, specify `0`.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class FleetLaunchTemplateConfigOverrideInstanceRequirementsMemoryGibPerVcpu(dict):
    def __init__(__self__, *,
                 max: Optional[float] = None,
                 min: Optional[float] = None):
        """
        :param float max: The maximum number of vCPUs. To specify no maximum limit, omit this parameter.
        :param float min: The minimum number of vCPUs. To specify no minimum limit, specify `0`.
        """
        FleetLaunchTemplateConfigOverrideInstanceRequirementsMemoryGibPerVcpu._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            min=min,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: Optional[float] = None,
             min: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if max is not None:
            _setter("max", max)
        if min is not None:
            _setter("min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[float]:
        """
        The maximum number of vCPUs. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[float]:
        """
        The minimum number of vCPUs. To specify no minimum limit, specify `0`.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class FleetLaunchTemplateConfigOverrideInstanceRequirementsMemoryMib(dict):
    def __init__(__self__, *,
                 min: int,
                 max: Optional[int] = None):
        """
        :param int min: The minimum number of vCPUs. To specify no minimum limit, specify `0`.
        :param int max: The maximum number of vCPUs. To specify no maximum limit, omit this parameter.
        """
        FleetLaunchTemplateConfigOverrideInstanceRequirementsMemoryMib._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            min=min,
            max=max,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             min: Optional[int] = None,
             max: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if min is None:
            raise TypeError("Missing 'min' argument")

        _setter("min", min)
        if max is not None:
            _setter("max", max)

    @property
    @pulumi.getter
    def min(self) -> int:
        """
        The minimum number of vCPUs. To specify no minimum limit, specify `0`.
        """
        return pulumi.get(self, "min")

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        """
        The maximum number of vCPUs. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")


@pulumi.output_type
class FleetLaunchTemplateConfigOverrideInstanceRequirementsNetworkBandwidthGbps(dict):
    def __init__(__self__, *,
                 max: Optional[float] = None,
                 min: Optional[float] = None):
        """
        :param float max: The maximum number of vCPUs. To specify no maximum limit, omit this parameter.
        :param float min: The minimum number of vCPUs. To specify no minimum limit, specify `0`.
        """
        FleetLaunchTemplateConfigOverrideInstanceRequirementsNetworkBandwidthGbps._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            min=min,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: Optional[float] = None,
             min: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if max is not None:
            _setter("max", max)
        if min is not None:
            _setter("min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[float]:
        """
        The maximum number of vCPUs. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[float]:
        """
        The minimum number of vCPUs. To specify no minimum limit, specify `0`.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class FleetLaunchTemplateConfigOverrideInstanceRequirementsNetworkInterfaceCount(dict):
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        """
        :param int max: The maximum number of vCPUs. To specify no maximum limit, omit this parameter.
        :param int min: The minimum number of vCPUs. To specify no minimum limit, specify `0`.
        """
        FleetLaunchTemplateConfigOverrideInstanceRequirementsNetworkInterfaceCount._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            min=min,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: Optional[int] = None,
             min: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if max is not None:
            _setter("max", max)
        if min is not None:
            _setter("min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        """
        The maximum number of vCPUs. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        """
        The minimum number of vCPUs. To specify no minimum limit, specify `0`.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class FleetLaunchTemplateConfigOverrideInstanceRequirementsTotalLocalStorageGb(dict):
    def __init__(__self__, *,
                 max: Optional[float] = None,
                 min: Optional[float] = None):
        """
        :param float max: The maximum number of vCPUs. To specify no maximum limit, omit this parameter.
        :param float min: The minimum number of vCPUs. To specify no minimum limit, specify `0`.
        """
        FleetLaunchTemplateConfigOverrideInstanceRequirementsTotalLocalStorageGb._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            min=min,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: Optional[float] = None,
             min: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if max is not None:
            _setter("max", max)
        if min is not None:
            _setter("min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[float]:
        """
        The maximum number of vCPUs. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[float]:
        """
        The minimum number of vCPUs. To specify no minimum limit, specify `0`.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class FleetLaunchTemplateConfigOverrideInstanceRequirementsVcpuCount(dict):
    def __init__(__self__, *,
                 min: int,
                 max: Optional[int] = None):
        """
        :param int min: The minimum number of vCPUs. To specify no minimum limit, specify `0`.
        :param int max: The maximum number of vCPUs. To specify no maximum limit, omit this parameter.
        """
        FleetLaunchTemplateConfigOverrideInstanceRequirementsVcpuCount._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            min=min,
            max=max,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             min: Optional[int] = None,
             max: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if min is None:
            raise TypeError("Missing 'min' argument")

        _setter("min", min)
        if max is not None:
            _setter("max", max)

    @property
    @pulumi.getter
    def min(self) -> int:
        """
        The minimum number of vCPUs. To specify no minimum limit, specify `0`.
        """
        return pulumi.get(self, "min")

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        """
        The maximum number of vCPUs. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")


@pulumi.output_type
class FleetOnDemandOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allocationStrategy":
            suggest = "allocation_strategy"
        elif key == "maxTotalPrice":
            suggest = "max_total_price"
        elif key == "minTargetCapacity":
            suggest = "min_target_capacity"
        elif key == "singleAvailabilityZone":
            suggest = "single_availability_zone"
        elif key == "singleInstanceType":
            suggest = "single_instance_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FleetOnDemandOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FleetOnDemandOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FleetOnDemandOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allocation_strategy: Optional[str] = None,
                 max_total_price: Optional[str] = None,
                 min_target_capacity: Optional[int] = None,
                 single_availability_zone: Optional[bool] = None,
                 single_instance_type: Optional[bool] = None):
        """
        :param str allocation_strategy: The order of the launch template overrides to use in fulfilling On-Demand capacity. Valid values: `lowestPrice`, `prioritized`. Default: `lowestPrice`.
        :param str max_total_price: The maximum amount per hour for On-Demand Instances that you're willing to pay.
        :param int min_target_capacity: The minimum target capacity for On-Demand Instances in the fleet. If the minimum target capacity is not reached, the fleet launches no instances. Supported only for fleets of type `instant`.
               If you specify `min_target_capacity`, at least one of the following must be specified: `single_availability_zone` or `single_instance_type`.
        :param bool single_availability_zone: Indicates that the fleet launches all On-Demand Instances into a single Availability Zone. Supported only for fleets of type `instant`.
        :param bool single_instance_type: Indicates that the fleet uses a single instance type to launch all On-Demand Instances in the fleet. Supported only for fleets of type `instant`.
        """
        FleetOnDemandOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allocation_strategy=allocation_strategy,
            max_total_price=max_total_price,
            min_target_capacity=min_target_capacity,
            single_availability_zone=single_availability_zone,
            single_instance_type=single_instance_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allocation_strategy: Optional[str] = None,
             max_total_price: Optional[str] = None,
             min_target_capacity: Optional[int] = None,
             single_availability_zone: Optional[bool] = None,
             single_instance_type: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if allocation_strategy is None and 'allocationStrategy' in kwargs:
            allocation_strategy = kwargs['allocationStrategy']
        if max_total_price is None and 'maxTotalPrice' in kwargs:
            max_total_price = kwargs['maxTotalPrice']
        if min_target_capacity is None and 'minTargetCapacity' in kwargs:
            min_target_capacity = kwargs['minTargetCapacity']
        if single_availability_zone is None and 'singleAvailabilityZone' in kwargs:
            single_availability_zone = kwargs['singleAvailabilityZone']
        if single_instance_type is None and 'singleInstanceType' in kwargs:
            single_instance_type = kwargs['singleInstanceType']

        if allocation_strategy is not None:
            _setter("allocation_strategy", allocation_strategy)
        if max_total_price is not None:
            _setter("max_total_price", max_total_price)
        if min_target_capacity is not None:
            _setter("min_target_capacity", min_target_capacity)
        if single_availability_zone is not None:
            _setter("single_availability_zone", single_availability_zone)
        if single_instance_type is not None:
            _setter("single_instance_type", single_instance_type)

    @property
    @pulumi.getter(name="allocationStrategy")
    def allocation_strategy(self) -> Optional[str]:
        """
        The order of the launch template overrides to use in fulfilling On-Demand capacity. Valid values: `lowestPrice`, `prioritized`. Default: `lowestPrice`.
        """
        return pulumi.get(self, "allocation_strategy")

    @property
    @pulumi.getter(name="maxTotalPrice")
    def max_total_price(self) -> Optional[str]:
        """
        The maximum amount per hour for On-Demand Instances that you're willing to pay.
        """
        return pulumi.get(self, "max_total_price")

    @property
    @pulumi.getter(name="minTargetCapacity")
    def min_target_capacity(self) -> Optional[int]:
        """
        The minimum target capacity for On-Demand Instances in the fleet. If the minimum target capacity is not reached, the fleet launches no instances. Supported only for fleets of type `instant`.
        If you specify `min_target_capacity`, at least one of the following must be specified: `single_availability_zone` or `single_instance_type`.
        """
        return pulumi.get(self, "min_target_capacity")

    @property
    @pulumi.getter(name="singleAvailabilityZone")
    def single_availability_zone(self) -> Optional[bool]:
        """
        Indicates that the fleet launches all On-Demand Instances into a single Availability Zone. Supported only for fleets of type `instant`.
        """
        return pulumi.get(self, "single_availability_zone")

    @property
    @pulumi.getter(name="singleInstanceType")
    def single_instance_type(self) -> Optional[bool]:
        """
        Indicates that the fleet uses a single instance type to launch all On-Demand Instances in the fleet. Supported only for fleets of type `instant`.
        """
        return pulumi.get(self, "single_instance_type")


@pulumi.output_type
class FleetSpotOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allocationStrategy":
            suggest = "allocation_strategy"
        elif key == "instanceInterruptionBehavior":
            suggest = "instance_interruption_behavior"
        elif key == "instancePoolsToUseCount":
            suggest = "instance_pools_to_use_count"
        elif key == "maintenanceStrategies":
            suggest = "maintenance_strategies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FleetSpotOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FleetSpotOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FleetSpotOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allocation_strategy: Optional[str] = None,
                 instance_interruption_behavior: Optional[str] = None,
                 instance_pools_to_use_count: Optional[int] = None,
                 maintenance_strategies: Optional['outputs.FleetSpotOptionsMaintenanceStrategies'] = None):
        """
        :param str allocation_strategy: How to allocate the target capacity across the Spot pools. Valid values: `diversified`, `lowestPrice`, `capacity-optimized`, `capacity-optimized-prioritized` and `price-capacity-optimized`. Default: `lowestPrice`.
        :param str instance_interruption_behavior: Behavior when a Spot Instance is interrupted. Valid values: `hibernate`, `stop`, `terminate`. Default: `terminate`.
        :param int instance_pools_to_use_count: Number of Spot pools across which to allocate your target Spot capacity. Valid only when Spot `allocation_strategy` is set to `lowestPrice`. Default: `1`.
        :param 'FleetSpotOptionsMaintenanceStrategiesArgs' maintenance_strategies: Nested argument containing maintenance strategies for managing your Spot Instances that are at an elevated risk of being interrupted. Defined below.
        """
        FleetSpotOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allocation_strategy=allocation_strategy,
            instance_interruption_behavior=instance_interruption_behavior,
            instance_pools_to_use_count=instance_pools_to_use_count,
            maintenance_strategies=maintenance_strategies,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allocation_strategy: Optional[str] = None,
             instance_interruption_behavior: Optional[str] = None,
             instance_pools_to_use_count: Optional[int] = None,
             maintenance_strategies: Optional['outputs.FleetSpotOptionsMaintenanceStrategies'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if allocation_strategy is None and 'allocationStrategy' in kwargs:
            allocation_strategy = kwargs['allocationStrategy']
        if instance_interruption_behavior is None and 'instanceInterruptionBehavior' in kwargs:
            instance_interruption_behavior = kwargs['instanceInterruptionBehavior']
        if instance_pools_to_use_count is None and 'instancePoolsToUseCount' in kwargs:
            instance_pools_to_use_count = kwargs['instancePoolsToUseCount']
        if maintenance_strategies is None and 'maintenanceStrategies' in kwargs:
            maintenance_strategies = kwargs['maintenanceStrategies']

        if allocation_strategy is not None:
            _setter("allocation_strategy", allocation_strategy)
        if instance_interruption_behavior is not None:
            _setter("instance_interruption_behavior", instance_interruption_behavior)
        if instance_pools_to_use_count is not None:
            _setter("instance_pools_to_use_count", instance_pools_to_use_count)
        if maintenance_strategies is not None:
            _setter("maintenance_strategies", maintenance_strategies)

    @property
    @pulumi.getter(name="allocationStrategy")
    def allocation_strategy(self) -> Optional[str]:
        """
        How to allocate the target capacity across the Spot pools. Valid values: `diversified`, `lowestPrice`, `capacity-optimized`, `capacity-optimized-prioritized` and `price-capacity-optimized`. Default: `lowestPrice`.
        """
        return pulumi.get(self, "allocation_strategy")

    @property
    @pulumi.getter(name="instanceInterruptionBehavior")
    def instance_interruption_behavior(self) -> Optional[str]:
        """
        Behavior when a Spot Instance is interrupted. Valid values: `hibernate`, `stop`, `terminate`. Default: `terminate`.
        """
        return pulumi.get(self, "instance_interruption_behavior")

    @property
    @pulumi.getter(name="instancePoolsToUseCount")
    def instance_pools_to_use_count(self) -> Optional[int]:
        """
        Number of Spot pools across which to allocate your target Spot capacity. Valid only when Spot `allocation_strategy` is set to `lowestPrice`. Default: `1`.
        """
        return pulumi.get(self, "instance_pools_to_use_count")

    @property
    @pulumi.getter(name="maintenanceStrategies")
    def maintenance_strategies(self) -> Optional['outputs.FleetSpotOptionsMaintenanceStrategies']:
        """
        Nested argument containing maintenance strategies for managing your Spot Instances that are at an elevated risk of being interrupted. Defined below.
        """
        return pulumi.get(self, "maintenance_strategies")


@pulumi.output_type
class FleetSpotOptionsMaintenanceStrategies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capacityRebalance":
            suggest = "capacity_rebalance"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FleetSpotOptionsMaintenanceStrategies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FleetSpotOptionsMaintenanceStrategies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FleetSpotOptionsMaintenanceStrategies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capacity_rebalance: Optional['outputs.FleetSpotOptionsMaintenanceStrategiesCapacityRebalance'] = None):
        """
        :param 'FleetSpotOptionsMaintenanceStrategiesCapacityRebalanceArgs' capacity_rebalance: Nested argument containing the capacity rebalance for your fleet request. Defined below.
        """
        FleetSpotOptionsMaintenanceStrategies._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            capacity_rebalance=capacity_rebalance,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             capacity_rebalance: Optional['outputs.FleetSpotOptionsMaintenanceStrategiesCapacityRebalance'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if capacity_rebalance is None and 'capacityRebalance' in kwargs:
            capacity_rebalance = kwargs['capacityRebalance']

        if capacity_rebalance is not None:
            _setter("capacity_rebalance", capacity_rebalance)

    @property
    @pulumi.getter(name="capacityRebalance")
    def capacity_rebalance(self) -> Optional['outputs.FleetSpotOptionsMaintenanceStrategiesCapacityRebalance']:
        """
        Nested argument containing the capacity rebalance for your fleet request. Defined below.
        """
        return pulumi.get(self, "capacity_rebalance")


@pulumi.output_type
class FleetSpotOptionsMaintenanceStrategiesCapacityRebalance(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "replacementStrategy":
            suggest = "replacement_strategy"
        elif key == "terminationDelay":
            suggest = "termination_delay"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FleetSpotOptionsMaintenanceStrategiesCapacityRebalance. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FleetSpotOptionsMaintenanceStrategiesCapacityRebalance.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FleetSpotOptionsMaintenanceStrategiesCapacityRebalance.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 replacement_strategy: Optional[str] = None,
                 termination_delay: Optional[int] = None):
        """
        :param str replacement_strategy: The replacement strategy to use. Only available for fleets of `type` set to `maintain`. Valid values: `launch`.
        """
        FleetSpotOptionsMaintenanceStrategiesCapacityRebalance._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            replacement_strategy=replacement_strategy,
            termination_delay=termination_delay,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             replacement_strategy: Optional[str] = None,
             termination_delay: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if replacement_strategy is None and 'replacementStrategy' in kwargs:
            replacement_strategy = kwargs['replacementStrategy']
        if termination_delay is None and 'terminationDelay' in kwargs:
            termination_delay = kwargs['terminationDelay']

        if replacement_strategy is not None:
            _setter("replacement_strategy", replacement_strategy)
        if termination_delay is not None:
            _setter("termination_delay", termination_delay)

    @property
    @pulumi.getter(name="replacementStrategy")
    def replacement_strategy(self) -> Optional[str]:
        """
        The replacement strategy to use. Only available for fleets of `type` set to `maintain`. Valid values: `launch`.
        """
        return pulumi.get(self, "replacement_strategy")

    @property
    @pulumi.getter(name="terminationDelay")
    def termination_delay(self) -> Optional[int]:
        return pulumi.get(self, "termination_delay")


@pulumi.output_type
class FleetTargetCapacitySpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultTargetCapacityType":
            suggest = "default_target_capacity_type"
        elif key == "totalTargetCapacity":
            suggest = "total_target_capacity"
        elif key == "onDemandTargetCapacity":
            suggest = "on_demand_target_capacity"
        elif key == "spotTargetCapacity":
            suggest = "spot_target_capacity"
        elif key == "targetCapacityUnitType":
            suggest = "target_capacity_unit_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FleetTargetCapacitySpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FleetTargetCapacitySpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FleetTargetCapacitySpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_target_capacity_type: str,
                 total_target_capacity: int,
                 on_demand_target_capacity: Optional[int] = None,
                 spot_target_capacity: Optional[int] = None,
                 target_capacity_unit_type: Optional[str] = None):
        """
        :param str default_target_capacity_type: Default target capacity type. Valid values: `on-demand`, `spot`.
        :param int total_target_capacity: The number of units to request, filled using `default_target_capacity_type`.
        :param int on_demand_target_capacity: The number of On-Demand units to request.
        :param int spot_target_capacity: The number of Spot units to request.
        :param str target_capacity_unit_type: The unit for the target capacity.
               If you specify `target_capacity_unit_type`, `instance_requirements` must be specified.
        """
        FleetTargetCapacitySpecification._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            default_target_capacity_type=default_target_capacity_type,
            total_target_capacity=total_target_capacity,
            on_demand_target_capacity=on_demand_target_capacity,
            spot_target_capacity=spot_target_capacity,
            target_capacity_unit_type=target_capacity_unit_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             default_target_capacity_type: Optional[str] = None,
             total_target_capacity: Optional[int] = None,
             on_demand_target_capacity: Optional[int] = None,
             spot_target_capacity: Optional[int] = None,
             target_capacity_unit_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if default_target_capacity_type is None and 'defaultTargetCapacityType' in kwargs:
            default_target_capacity_type = kwargs['defaultTargetCapacityType']
        if default_target_capacity_type is None:
            raise TypeError("Missing 'default_target_capacity_type' argument")
        if total_target_capacity is None and 'totalTargetCapacity' in kwargs:
            total_target_capacity = kwargs['totalTargetCapacity']
        if total_target_capacity is None:
            raise TypeError("Missing 'total_target_capacity' argument")
        if on_demand_target_capacity is None and 'onDemandTargetCapacity' in kwargs:
            on_demand_target_capacity = kwargs['onDemandTargetCapacity']
        if spot_target_capacity is None and 'spotTargetCapacity' in kwargs:
            spot_target_capacity = kwargs['spotTargetCapacity']
        if target_capacity_unit_type is None and 'targetCapacityUnitType' in kwargs:
            target_capacity_unit_type = kwargs['targetCapacityUnitType']

        _setter("default_target_capacity_type", default_target_capacity_type)
        _setter("total_target_capacity", total_target_capacity)
        if on_demand_target_capacity is not None:
            _setter("on_demand_target_capacity", on_demand_target_capacity)
        if spot_target_capacity is not None:
            _setter("spot_target_capacity", spot_target_capacity)
        if target_capacity_unit_type is not None:
            _setter("target_capacity_unit_type", target_capacity_unit_type)

    @property
    @pulumi.getter(name="defaultTargetCapacityType")
    def default_target_capacity_type(self) -> str:
        """
        Default target capacity type. Valid values: `on-demand`, `spot`.
        """
        return pulumi.get(self, "default_target_capacity_type")

    @property
    @pulumi.getter(name="totalTargetCapacity")
    def total_target_capacity(self) -> int:
        """
        The number of units to request, filled using `default_target_capacity_type`.
        """
        return pulumi.get(self, "total_target_capacity")

    @property
    @pulumi.getter(name="onDemandTargetCapacity")
    def on_demand_target_capacity(self) -> Optional[int]:
        """
        The number of On-Demand units to request.
        """
        return pulumi.get(self, "on_demand_target_capacity")

    @property
    @pulumi.getter(name="spotTargetCapacity")
    def spot_target_capacity(self) -> Optional[int]:
        """
        The number of Spot units to request.
        """
        return pulumi.get(self, "spot_target_capacity")

    @property
    @pulumi.getter(name="targetCapacityUnitType")
    def target_capacity_unit_type(self) -> Optional[str]:
        """
        The unit for the target capacity.
        If you specify `target_capacity_unit_type`, `instance_requirements` must be specified.
        """
        return pulumi.get(self, "target_capacity_unit_type")


@pulumi.output_type
class FlowLogDestinationOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fileFormat":
            suggest = "file_format"
        elif key == "hiveCompatiblePartitions":
            suggest = "hive_compatible_partitions"
        elif key == "perHourPartition":
            suggest = "per_hour_partition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowLogDestinationOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowLogDestinationOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowLogDestinationOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 file_format: Optional[str] = None,
                 hive_compatible_partitions: Optional[bool] = None,
                 per_hour_partition: Optional[bool] = None):
        """
        :param str file_format: The format for the flow log. Default value: `plain-text`. Valid values: `plain-text`, `parquet`.
        :param bool hive_compatible_partitions: Indicates whether to use Hive-compatible prefixes for flow logs stored in Amazon S3. Default value: `false`.
        :param bool per_hour_partition: Indicates whether to partition the flow log per hour. This reduces the cost and response time for queries. Default value: `false`.
        """
        FlowLogDestinationOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            file_format=file_format,
            hive_compatible_partitions=hive_compatible_partitions,
            per_hour_partition=per_hour_partition,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             file_format: Optional[str] = None,
             hive_compatible_partitions: Optional[bool] = None,
             per_hour_partition: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if file_format is None and 'fileFormat' in kwargs:
            file_format = kwargs['fileFormat']
        if hive_compatible_partitions is None and 'hiveCompatiblePartitions' in kwargs:
            hive_compatible_partitions = kwargs['hiveCompatiblePartitions']
        if per_hour_partition is None and 'perHourPartition' in kwargs:
            per_hour_partition = kwargs['perHourPartition']

        if file_format is not None:
            _setter("file_format", file_format)
        if hive_compatible_partitions is not None:
            _setter("hive_compatible_partitions", hive_compatible_partitions)
        if per_hour_partition is not None:
            _setter("per_hour_partition", per_hour_partition)

    @property
    @pulumi.getter(name="fileFormat")
    def file_format(self) -> Optional[str]:
        """
        The format for the flow log. Default value: `plain-text`. Valid values: `plain-text`, `parquet`.
        """
        return pulumi.get(self, "file_format")

    @property
    @pulumi.getter(name="hiveCompatiblePartitions")
    def hive_compatible_partitions(self) -> Optional[bool]:
        """
        Indicates whether to use Hive-compatible prefixes for flow logs stored in Amazon S3. Default value: `false`.
        """
        return pulumi.get(self, "hive_compatible_partitions")

    @property
    @pulumi.getter(name="perHourPartition")
    def per_hour_partition(self) -> Optional[bool]:
        """
        Indicates whether to partition the flow log per hour. This reduces the cost and response time for queries. Default value: `false`.
        """
        return pulumi.get(self, "per_hour_partition")


@pulumi.output_type
class InstanceCapacityReservationSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capacityReservationPreference":
            suggest = "capacity_reservation_preference"
        elif key == "capacityReservationTarget":
            suggest = "capacity_reservation_target"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceCapacityReservationSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceCapacityReservationSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceCapacityReservationSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capacity_reservation_preference: Optional[str] = None,
                 capacity_reservation_target: Optional['outputs.InstanceCapacityReservationSpecificationCapacityReservationTarget'] = None):
        """
        :param str capacity_reservation_preference: Indicates the instance's Capacity Reservation preferences. Can be `"open"` or `"none"`. (Default: `"open"`).
        :param 'InstanceCapacityReservationSpecificationCapacityReservationTargetArgs' capacity_reservation_target: Information about the target Capacity Reservation. See Capacity Reservation Target below for more details.
               
               For more information, see the documentation on [Capacity Reservations](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/capacity-reservations-using.html).
        """
        InstanceCapacityReservationSpecification._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            capacity_reservation_preference=capacity_reservation_preference,
            capacity_reservation_target=capacity_reservation_target,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             capacity_reservation_preference: Optional[str] = None,
             capacity_reservation_target: Optional['outputs.InstanceCapacityReservationSpecificationCapacityReservationTarget'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if capacity_reservation_preference is None and 'capacityReservationPreference' in kwargs:
            capacity_reservation_preference = kwargs['capacityReservationPreference']
        if capacity_reservation_target is None and 'capacityReservationTarget' in kwargs:
            capacity_reservation_target = kwargs['capacityReservationTarget']

        if capacity_reservation_preference is not None:
            _setter("capacity_reservation_preference", capacity_reservation_preference)
        if capacity_reservation_target is not None:
            _setter("capacity_reservation_target", capacity_reservation_target)

    @property
    @pulumi.getter(name="capacityReservationPreference")
    def capacity_reservation_preference(self) -> Optional[str]:
        """
        Indicates the instance's Capacity Reservation preferences. Can be `"open"` or `"none"`. (Default: `"open"`).
        """
        return pulumi.get(self, "capacity_reservation_preference")

    @property
    @pulumi.getter(name="capacityReservationTarget")
    def capacity_reservation_target(self) -> Optional['outputs.InstanceCapacityReservationSpecificationCapacityReservationTarget']:
        """
        Information about the target Capacity Reservation. See Capacity Reservation Target below for more details.

        For more information, see the documentation on [Capacity Reservations](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/capacity-reservations-using.html).
        """
        return pulumi.get(self, "capacity_reservation_target")


@pulumi.output_type
class InstanceCapacityReservationSpecificationCapacityReservationTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capacityReservationId":
            suggest = "capacity_reservation_id"
        elif key == "capacityReservationResourceGroupArn":
            suggest = "capacity_reservation_resource_group_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceCapacityReservationSpecificationCapacityReservationTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceCapacityReservationSpecificationCapacityReservationTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceCapacityReservationSpecificationCapacityReservationTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capacity_reservation_id: Optional[str] = None,
                 capacity_reservation_resource_group_arn: Optional[str] = None):
        """
        :param str capacity_reservation_id: ID of the Capacity Reservation in which to run the instance.
        :param str capacity_reservation_resource_group_arn: ARN of the Capacity Reservation resource group in which to run the instance.
        """
        InstanceCapacityReservationSpecificationCapacityReservationTarget._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            capacity_reservation_id=capacity_reservation_id,
            capacity_reservation_resource_group_arn=capacity_reservation_resource_group_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             capacity_reservation_id: Optional[str] = None,
             capacity_reservation_resource_group_arn: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if capacity_reservation_id is None and 'capacityReservationId' in kwargs:
            capacity_reservation_id = kwargs['capacityReservationId']
        if capacity_reservation_resource_group_arn is None and 'capacityReservationResourceGroupArn' in kwargs:
            capacity_reservation_resource_group_arn = kwargs['capacityReservationResourceGroupArn']

        if capacity_reservation_id is not None:
            _setter("capacity_reservation_id", capacity_reservation_id)
        if capacity_reservation_resource_group_arn is not None:
            _setter("capacity_reservation_resource_group_arn", capacity_reservation_resource_group_arn)

    @property
    @pulumi.getter(name="capacityReservationId")
    def capacity_reservation_id(self) -> Optional[str]:
        """
        ID of the Capacity Reservation in which to run the instance.
        """
        return pulumi.get(self, "capacity_reservation_id")

    @property
    @pulumi.getter(name="capacityReservationResourceGroupArn")
    def capacity_reservation_resource_group_arn(self) -> Optional[str]:
        """
        ARN of the Capacity Reservation resource group in which to run the instance.
        """
        return pulumi.get(self, "capacity_reservation_resource_group_arn")


@pulumi.output_type
class InstanceCpuOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "amdSevSnp":
            suggest = "amd_sev_snp"
        elif key == "coreCount":
            suggest = "core_count"
        elif key == "threadsPerCore":
            suggest = "threads_per_core"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceCpuOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceCpuOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceCpuOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 amd_sev_snp: Optional[str] = None,
                 core_count: Optional[int] = None,
                 threads_per_core: Optional[int] = None):
        """
        :param str amd_sev_snp: Indicates whether to enable the instance for AMD SEV-SNP. AMD SEV-SNP is supported with M6a, R6a, and C6a instance types only. Valid values are `enabled` and `disabled`.
        :param int core_count: Sets the number of CPU cores for an instance. This option is only supported on creation of instance type that support CPU Options [CPU Cores and Threads Per CPU Core Per Instance Type](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html#cpu-options-supported-instances-values) - specifying this option for unsupported instance types will return an error from the EC2 API.
        :param int threads_per_core: If set to 1, hyperthreading is disabled on the launched instance. Defaults to 2 if not set. See [Optimizing CPU Options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html) for more information.
               
               For more information, see the documentation on [Optimizing CPU options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html).
        """
        InstanceCpuOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            amd_sev_snp=amd_sev_snp,
            core_count=core_count,
            threads_per_core=threads_per_core,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             amd_sev_snp: Optional[str] = None,
             core_count: Optional[int] = None,
             threads_per_core: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if amd_sev_snp is None and 'amdSevSnp' in kwargs:
            amd_sev_snp = kwargs['amdSevSnp']
        if core_count is None and 'coreCount' in kwargs:
            core_count = kwargs['coreCount']
        if threads_per_core is None and 'threadsPerCore' in kwargs:
            threads_per_core = kwargs['threadsPerCore']

        if amd_sev_snp is not None:
            _setter("amd_sev_snp", amd_sev_snp)
        if core_count is not None:
            _setter("core_count", core_count)
        if threads_per_core is not None:
            _setter("threads_per_core", threads_per_core)

    @property
    @pulumi.getter(name="amdSevSnp")
    def amd_sev_snp(self) -> Optional[str]:
        """
        Indicates whether to enable the instance for AMD SEV-SNP. AMD SEV-SNP is supported with M6a, R6a, and C6a instance types only. Valid values are `enabled` and `disabled`.
        """
        return pulumi.get(self, "amd_sev_snp")

    @property
    @pulumi.getter(name="coreCount")
    def core_count(self) -> Optional[int]:
        """
        Sets the number of CPU cores for an instance. This option is only supported on creation of instance type that support CPU Options [CPU Cores and Threads Per CPU Core Per Instance Type](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html#cpu-options-supported-instances-values) - specifying this option for unsupported instance types will return an error from the EC2 API.
        """
        return pulumi.get(self, "core_count")

    @property
    @pulumi.getter(name="threadsPerCore")
    def threads_per_core(self) -> Optional[int]:
        """
        If set to 1, hyperthreading is disabled on the launched instance. Defaults to 2 if not set. See [Optimizing CPU Options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html) for more information.

        For more information, see the documentation on [Optimizing CPU options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html).
        """
        return pulumi.get(self, "threads_per_core")


@pulumi.output_type
class InstanceCreditSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cpuCredits":
            suggest = "cpu_credits"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceCreditSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceCreditSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceCreditSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu_credits: Optional[str] = None):
        """
        :param str cpu_credits: Credit option for CPU usage. Valid values include `standard` or `unlimited`. T3 instances are launched as unlimited by default. T2 instances are launched as standard by default.
        """
        InstanceCreditSpecification._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cpu_credits=cpu_credits,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cpu_credits: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cpu_credits is None and 'cpuCredits' in kwargs:
            cpu_credits = kwargs['cpuCredits']

        if cpu_credits is not None:
            _setter("cpu_credits", cpu_credits)

    @property
    @pulumi.getter(name="cpuCredits")
    def cpu_credits(self) -> Optional[str]:
        """
        Credit option for CPU usage. Valid values include `standard` or `unlimited`. T3 instances are launched as unlimited by default. T2 instances are launched as standard by default.
        """
        return pulumi.get(self, "cpu_credits")


@pulumi.output_type
class InstanceEbsBlockDevice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "snapshotId":
            suggest = "snapshot_id"
        elif key == "volumeId":
            suggest = "volume_id"
        elif key == "volumeSize":
            suggest = "volume_size"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceEbsBlockDevice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceEbsBlockDevice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceEbsBlockDevice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_name: str,
                 delete_on_termination: Optional[bool] = None,
                 encrypted: Optional[bool] = None,
                 iops: Optional[int] = None,
                 kms_key_id: Optional[str] = None,
                 snapshot_id: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 throughput: Optional[int] = None,
                 volume_id: Optional[str] = None,
                 volume_size: Optional[int] = None,
                 volume_type: Optional[str] = None):
        """
        :param str device_name: Name of the device to mount.
        :param bool delete_on_termination: Whether the volume should be destroyed on instance termination. Defaults to `true`.
        :param bool encrypted: Enables [EBS encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html) on the volume. Defaults to `false`. Cannot be used with `snapshot_id`. Must be configured to perform drift detection.
        :param int iops: Amount of provisioned [IOPS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-io-characteristics.html). Only valid for volume_type of `io1`, `io2` or `gp3`.
        :param str kms_key_id: Amazon Resource Name (ARN) of the KMS Key to use when encrypting the volume. Must be configured to perform drift detection.
        :param str snapshot_id: Snapshot ID to mount.
        :param Mapping[str, str] tags: Map of tags to assign to the device.
        :param int throughput: Throughput to provision for a volume in mebibytes per second (MiB/s). This is only valid for `volume_type` of `gp3`.
        :param str volume_id: ID of the volume. For example, the ID can be accessed like this, `aws_instance.web.root_block_device.0.volume_id`.
        :param int volume_size: Size of the volume in gibibytes (GiB).
        :param str volume_type: Type of volume. Valid values include `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1`, or `st1`. Defaults to `gp2`.
               
               > **NOTE:** Currently, changes to the `ebs_block_device` configuration of _existing_ resources cannot be automatically detected by this provider. To manage changes and attachments of an EBS block to an instance, use the `ebs.Volume` and `ec2.VolumeAttachment` resources instead. If you use `ebs_block_device` on an `ec2.Instance`, this provider will assume management over the full set of non-root EBS block devices for the instance, treating additional block devices as drift. For this reason, `ebs_block_device` cannot be mixed with external `ebs.Volume` and `ec2.VolumeAttachment` resources for a given instance.
        """
        InstanceEbsBlockDevice._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            device_name=device_name,
            delete_on_termination=delete_on_termination,
            encrypted=encrypted,
            iops=iops,
            kms_key_id=kms_key_id,
            snapshot_id=snapshot_id,
            tags=tags,
            throughput=throughput,
            volume_id=volume_id,
            volume_size=volume_size,
            volume_type=volume_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             device_name: Optional[str] = None,
             delete_on_termination: Optional[bool] = None,
             encrypted: Optional[bool] = None,
             iops: Optional[int] = None,
             kms_key_id: Optional[str] = None,
             snapshot_id: Optional[str] = None,
             tags: Optional[Mapping[str, str]] = None,
             throughput: Optional[int] = None,
             volume_id: Optional[str] = None,
             volume_size: Optional[int] = None,
             volume_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if device_name is None and 'deviceName' in kwargs:
            device_name = kwargs['deviceName']
        if device_name is None:
            raise TypeError("Missing 'device_name' argument")
        if delete_on_termination is None and 'deleteOnTermination' in kwargs:
            delete_on_termination = kwargs['deleteOnTermination']
        if kms_key_id is None and 'kmsKeyId' in kwargs:
            kms_key_id = kwargs['kmsKeyId']
        if snapshot_id is None and 'snapshotId' in kwargs:
            snapshot_id = kwargs['snapshotId']
        if volume_id is None and 'volumeId' in kwargs:
            volume_id = kwargs['volumeId']
        if volume_size is None and 'volumeSize' in kwargs:
            volume_size = kwargs['volumeSize']
        if volume_type is None and 'volumeType' in kwargs:
            volume_type = kwargs['volumeType']

        _setter("device_name", device_name)
        if delete_on_termination is not None:
            _setter("delete_on_termination", delete_on_termination)
        if encrypted is not None:
            _setter("encrypted", encrypted)
        if iops is not None:
            _setter("iops", iops)
        if kms_key_id is not None:
            _setter("kms_key_id", kms_key_id)
        if snapshot_id is not None:
            _setter("snapshot_id", snapshot_id)
        if tags is not None:
            _setter("tags", tags)
        if throughput is not None:
            _setter("throughput", throughput)
        if volume_id is not None:
            _setter("volume_id", volume_id)
        if volume_size is not None:
            _setter("volume_size", volume_size)
        if volume_type is not None:
            _setter("volume_type", volume_type)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> str:
        """
        Name of the device to mount.
        """
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[bool]:
        """
        Whether the volume should be destroyed on instance termination. Defaults to `true`.
        """
        return pulumi.get(self, "delete_on_termination")

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[bool]:
        """
        Enables [EBS encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html) on the volume. Defaults to `false`. Cannot be used with `snapshot_id`. Must be configured to perform drift detection.
        """
        return pulumi.get(self, "encrypted")

    @property
    @pulumi.getter
    def iops(self) -> Optional[int]:
        """
        Amount of provisioned [IOPS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-io-characteristics.html). Only valid for volume_type of `io1`, `io2` or `gp3`.
        """
        return pulumi.get(self, "iops")

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN) of the KMS Key to use when encrypting the volume. Must be configured to perform drift detection.
        """
        return pulumi.get(self, "kms_key_id")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[str]:
        """
        Snapshot ID to mount.
        """
        return pulumi.get(self, "snapshot_id")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Map of tags to assign to the device.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def throughput(self) -> Optional[int]:
        """
        Throughput to provision for a volume in mebibytes per second (MiB/s). This is only valid for `volume_type` of `gp3`.
        """
        return pulumi.get(self, "throughput")

    @property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> Optional[str]:
        """
        ID of the volume. For example, the ID can be accessed like this, `aws_instance.web.root_block_device.0.volume_id`.
        """
        return pulumi.get(self, "volume_id")

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[int]:
        """
        Size of the volume in gibibytes (GiB).
        """
        return pulumi.get(self, "volume_size")

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[str]:
        """
        Type of volume. Valid values include `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1`, or `st1`. Defaults to `gp2`.

        > **NOTE:** Currently, changes to the `ebs_block_device` configuration of _existing_ resources cannot be automatically detected by this provider. To manage changes and attachments of an EBS block to an instance, use the `ebs.Volume` and `ec2.VolumeAttachment` resources instead. If you use `ebs_block_device` on an `ec2.Instance`, this provider will assume management over the full set of non-root EBS block devices for the instance, treating additional block devices as drift. For this reason, `ebs_block_device` cannot be mixed with external `ebs.Volume` and `ec2.VolumeAttachment` resources for a given instance.
        """
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class InstanceEnclaveOptions(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        """
        :param bool enabled: Whether Nitro Enclaves will be enabled on the instance. Defaults to `false`.
               
               For more information, see the documentation on [Nitro Enclaves](https://docs.aws.amazon.com/enclaves/latest/user/nitro-enclave.html).
        """
        InstanceEnclaveOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if enabled is not None:
            _setter("enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Whether Nitro Enclaves will be enabled on the instance. Defaults to `false`.

        For more information, see the documentation on [Nitro Enclaves](https://docs.aws.amazon.com/enclaves/latest/user/nitro-enclave.html).
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class InstanceEphemeralBlockDevice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "noDevice":
            suggest = "no_device"
        elif key == "virtualName":
            suggest = "virtual_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceEphemeralBlockDevice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceEphemeralBlockDevice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceEphemeralBlockDevice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_name: str,
                 no_device: Optional[bool] = None,
                 virtual_name: Optional[str] = None):
        """
        :param str device_name: Name of the block device to mount on the instance.
        :param bool no_device: Suppresses the specified device included in the AMI's block device mapping.
        :param str virtual_name: [Instance Store Device Name](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#InstanceStoreDeviceNames) (e.g., `ephemeral0`).
               
               Each AWS Instance type has a different set of Instance Store block devices available for attachment. AWS [publishes a list](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#StorageOnInstanceTypes) of which ephemeral devices are available on each type. The devices are always identified by the `virtual_name` in the format `ephemeral{0..N}`.
        """
        InstanceEphemeralBlockDevice._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            device_name=device_name,
            no_device=no_device,
            virtual_name=virtual_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             device_name: Optional[str] = None,
             no_device: Optional[bool] = None,
             virtual_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if device_name is None and 'deviceName' in kwargs:
            device_name = kwargs['deviceName']
        if device_name is None:
            raise TypeError("Missing 'device_name' argument")
        if no_device is None and 'noDevice' in kwargs:
            no_device = kwargs['noDevice']
        if virtual_name is None and 'virtualName' in kwargs:
            virtual_name = kwargs['virtualName']

        _setter("device_name", device_name)
        if no_device is not None:
            _setter("no_device", no_device)
        if virtual_name is not None:
            _setter("virtual_name", virtual_name)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> str:
        """
        Name of the block device to mount on the instance.
        """
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter(name="noDevice")
    def no_device(self) -> Optional[bool]:
        """
        Suppresses the specified device included in the AMI's block device mapping.
        """
        return pulumi.get(self, "no_device")

    @property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> Optional[str]:
        """
        [Instance Store Device Name](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#InstanceStoreDeviceNames) (e.g., `ephemeral0`).

        Each AWS Instance type has a different set of Instance Store block devices available for attachment. AWS [publishes a list](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#StorageOnInstanceTypes) of which ephemeral devices are available on each type. The devices are always identified by the `virtual_name` in the format `ephemeral{0..N}`.
        """
        return pulumi.get(self, "virtual_name")


@pulumi.output_type
class InstanceInstanceMarketOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "marketType":
            suggest = "market_type"
        elif key == "spotOptions":
            suggest = "spot_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceInstanceMarketOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceInstanceMarketOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceInstanceMarketOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 market_type: Optional[str] = None,
                 spot_options: Optional['outputs.InstanceInstanceMarketOptionsSpotOptions'] = None):
        """
        :param str market_type: Type of market for the instance. Valid value is `spot`. Defaults to `spot`.
        :param 'InstanceInstanceMarketOptionsSpotOptionsArgs' spot_options: Block to configure the options for Spot Instances. See Spot Options below for details on attributes.
        """
        InstanceInstanceMarketOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            market_type=market_type,
            spot_options=spot_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             market_type: Optional[str] = None,
             spot_options: Optional['outputs.InstanceInstanceMarketOptionsSpotOptions'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if market_type is None and 'marketType' in kwargs:
            market_type = kwargs['marketType']
        if spot_options is None and 'spotOptions' in kwargs:
            spot_options = kwargs['spotOptions']

        if market_type is not None:
            _setter("market_type", market_type)
        if spot_options is not None:
            _setter("spot_options", spot_options)

    @property
    @pulumi.getter(name="marketType")
    def market_type(self) -> Optional[str]:
        """
        Type of market for the instance. Valid value is `spot`. Defaults to `spot`.
        """
        return pulumi.get(self, "market_type")

    @property
    @pulumi.getter(name="spotOptions")
    def spot_options(self) -> Optional['outputs.InstanceInstanceMarketOptionsSpotOptions']:
        """
        Block to configure the options for Spot Instances. See Spot Options below for details on attributes.
        """
        return pulumi.get(self, "spot_options")


@pulumi.output_type
class InstanceInstanceMarketOptionsSpotOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceInterruptionBehavior":
            suggest = "instance_interruption_behavior"
        elif key == "maxPrice":
            suggest = "max_price"
        elif key == "spotInstanceType":
            suggest = "spot_instance_type"
        elif key == "validUntil":
            suggest = "valid_until"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceInstanceMarketOptionsSpotOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceInstanceMarketOptionsSpotOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceInstanceMarketOptionsSpotOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_interruption_behavior: Optional[str] = None,
                 max_price: Optional[str] = None,
                 spot_instance_type: Optional[str] = None,
                 valid_until: Optional[str] = None):
        """
        :param str instance_interruption_behavior: The behavior when a Spot Instance is interrupted. Valid values include `hibernate`, `stop`, `terminate` . The default is `terminate`.
        :param str max_price: The maximum hourly price that you're willing to pay for a Spot Instance.
        :param str spot_instance_type: The Spot Instance request type. Valid values include `one-time`, `persistent`. Persistent Spot Instance requests are only supported when the instance interruption behavior is either hibernate or stop. The default is `one-time`.
        :param str valid_until: The end date of the request, in UTC format (YYYY-MM-DDTHH:MM:SSZ). Supported only for persistent requests.
        """
        InstanceInstanceMarketOptionsSpotOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            instance_interruption_behavior=instance_interruption_behavior,
            max_price=max_price,
            spot_instance_type=spot_instance_type,
            valid_until=valid_until,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             instance_interruption_behavior: Optional[str] = None,
             max_price: Optional[str] = None,
             spot_instance_type: Optional[str] = None,
             valid_until: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if instance_interruption_behavior is None and 'instanceInterruptionBehavior' in kwargs:
            instance_interruption_behavior = kwargs['instanceInterruptionBehavior']
        if max_price is None and 'maxPrice' in kwargs:
            max_price = kwargs['maxPrice']
        if spot_instance_type is None and 'spotInstanceType' in kwargs:
            spot_instance_type = kwargs['spotInstanceType']
        if valid_until is None and 'validUntil' in kwargs:
            valid_until = kwargs['validUntil']

        if instance_interruption_behavior is not None:
            _setter("instance_interruption_behavior", instance_interruption_behavior)
        if max_price is not None:
            _setter("max_price", max_price)
        if spot_instance_type is not None:
            _setter("spot_instance_type", spot_instance_type)
        if valid_until is not None:
            _setter("valid_until", valid_until)

    @property
    @pulumi.getter(name="instanceInterruptionBehavior")
    def instance_interruption_behavior(self) -> Optional[str]:
        """
        The behavior when a Spot Instance is interrupted. Valid values include `hibernate`, `stop`, `terminate` . The default is `terminate`.
        """
        return pulumi.get(self, "instance_interruption_behavior")

    @property
    @pulumi.getter(name="maxPrice")
    def max_price(self) -> Optional[str]:
        """
        The maximum hourly price that you're willing to pay for a Spot Instance.
        """
        return pulumi.get(self, "max_price")

    @property
    @pulumi.getter(name="spotInstanceType")
    def spot_instance_type(self) -> Optional[str]:
        """
        The Spot Instance request type. Valid values include `one-time`, `persistent`. Persistent Spot Instance requests are only supported when the instance interruption behavior is either hibernate or stop. The default is `one-time`.
        """
        return pulumi.get(self, "spot_instance_type")

    @property
    @pulumi.getter(name="validUntil")
    def valid_until(self) -> Optional[str]:
        """
        The end date of the request, in UTC format (YYYY-MM-DDTHH:MM:SSZ). Supported only for persistent requests.
        """
        return pulumi.get(self, "valid_until")


@pulumi.output_type
class InstanceLaunchTemplate(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param str id: ID of the launch template. Conflicts with `name`.
        :param str name: Name of the launch template. Conflicts with `id`.
        :param str version: Template version. Can be a specific version number, `$Latest` or `$Default`. The default value is `$Default`.
        """
        InstanceLaunchTemplate._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            name=name,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             name: Optional[str] = None,
             version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)
        if version is not None:
            _setter("version", version)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the launch template. Conflicts with `name`.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the launch template. Conflicts with `id`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        Template version. Can be a specific version number, `$Latest` or `$Default`. The default value is `$Default`.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class InstanceMaintenanceOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoRecovery":
            suggest = "auto_recovery"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceMaintenanceOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceMaintenanceOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceMaintenanceOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_recovery: Optional[str] = None):
        """
        :param str auto_recovery: Automatic recovery behavior of the Instance. Can be `"default"` or `"disabled"`. See [Recover your instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-recover.html) for more details.
        """
        InstanceMaintenanceOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auto_recovery=auto_recovery,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auto_recovery: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if auto_recovery is None and 'autoRecovery' in kwargs:
            auto_recovery = kwargs['autoRecovery']

        if auto_recovery is not None:
            _setter("auto_recovery", auto_recovery)

    @property
    @pulumi.getter(name="autoRecovery")
    def auto_recovery(self) -> Optional[str]:
        """
        Automatic recovery behavior of the Instance. Can be `"default"` or `"disabled"`. See [Recover your instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-recover.html) for more details.
        """
        return pulumi.get(self, "auto_recovery")


@pulumi.output_type
class InstanceMetadataOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpEndpoint":
            suggest = "http_endpoint"
        elif key == "httpProtocolIpv6":
            suggest = "http_protocol_ipv6"
        elif key == "httpPutResponseHopLimit":
            suggest = "http_put_response_hop_limit"
        elif key == "httpTokens":
            suggest = "http_tokens"
        elif key == "instanceMetadataTags":
            suggest = "instance_metadata_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceMetadataOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceMetadataOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceMetadataOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_endpoint: Optional[str] = None,
                 http_protocol_ipv6: Optional[str] = None,
                 http_put_response_hop_limit: Optional[int] = None,
                 http_tokens: Optional[str] = None,
                 instance_metadata_tags: Optional[str] = None):
        """
        :param str http_endpoint: Whether the metadata service is available. Valid values include `enabled` or `disabled`. Defaults to `enabled`.
        :param str http_protocol_ipv6: Whether the IPv6 endpoint for the instance metadata service is enabled. Defaults to `disabled`.
        :param int http_put_response_hop_limit: Desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel. Valid values are integer from `1` to `64`. Defaults to `1`.
        :param str http_tokens: Whether or not the metadata service requires session tokens, also referred to as _Instance Metadata Service Version 2 (IMDSv2)_. Valid values include `optional` or `required`. Defaults to `optional`.
        :param str instance_metadata_tags: Enables or disables access to instance tags from the instance metadata service. Valid values include `enabled` or `disabled`. Defaults to `disabled`.
               
               For more information, see the documentation on the [Instance Metadata Service](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html).
        """
        InstanceMetadataOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            http_endpoint=http_endpoint,
            http_protocol_ipv6=http_protocol_ipv6,
            http_put_response_hop_limit=http_put_response_hop_limit,
            http_tokens=http_tokens,
            instance_metadata_tags=instance_metadata_tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             http_endpoint: Optional[str] = None,
             http_protocol_ipv6: Optional[str] = None,
             http_put_response_hop_limit: Optional[int] = None,
             http_tokens: Optional[str] = None,
             instance_metadata_tags: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if http_endpoint is None and 'httpEndpoint' in kwargs:
            http_endpoint = kwargs['httpEndpoint']
        if http_protocol_ipv6 is None and 'httpProtocolIpv6' in kwargs:
            http_protocol_ipv6 = kwargs['httpProtocolIpv6']
        if http_put_response_hop_limit is None and 'httpPutResponseHopLimit' in kwargs:
            http_put_response_hop_limit = kwargs['httpPutResponseHopLimit']
        if http_tokens is None and 'httpTokens' in kwargs:
            http_tokens = kwargs['httpTokens']
        if instance_metadata_tags is None and 'instanceMetadataTags' in kwargs:
            instance_metadata_tags = kwargs['instanceMetadataTags']

        if http_endpoint is not None:
            _setter("http_endpoint", http_endpoint)
        if http_protocol_ipv6 is not None:
            _setter("http_protocol_ipv6", http_protocol_ipv6)
        if http_put_response_hop_limit is not None:
            _setter("http_put_response_hop_limit", http_put_response_hop_limit)
        if http_tokens is not None:
            _setter("http_tokens", http_tokens)
        if instance_metadata_tags is not None:
            _setter("instance_metadata_tags", instance_metadata_tags)

    @property
    @pulumi.getter(name="httpEndpoint")
    def http_endpoint(self) -> Optional[str]:
        """
        Whether the metadata service is available. Valid values include `enabled` or `disabled`. Defaults to `enabled`.
        """
        return pulumi.get(self, "http_endpoint")

    @property
    @pulumi.getter(name="httpProtocolIpv6")
    def http_protocol_ipv6(self) -> Optional[str]:
        """
        Whether the IPv6 endpoint for the instance metadata service is enabled. Defaults to `disabled`.
        """
        return pulumi.get(self, "http_protocol_ipv6")

    @property
    @pulumi.getter(name="httpPutResponseHopLimit")
    def http_put_response_hop_limit(self) -> Optional[int]:
        """
        Desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel. Valid values are integer from `1` to `64`. Defaults to `1`.
        """
        return pulumi.get(self, "http_put_response_hop_limit")

    @property
    @pulumi.getter(name="httpTokens")
    def http_tokens(self) -> Optional[str]:
        """
        Whether or not the metadata service requires session tokens, also referred to as _Instance Metadata Service Version 2 (IMDSv2)_. Valid values include `optional` or `required`. Defaults to `optional`.
        """
        return pulumi.get(self, "http_tokens")

    @property
    @pulumi.getter(name="instanceMetadataTags")
    def instance_metadata_tags(self) -> Optional[str]:
        """
        Enables or disables access to instance tags from the instance metadata service. Valid values include `enabled` or `disabled`. Defaults to `disabled`.

        For more information, see the documentation on the [Instance Metadata Service](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html).
        """
        return pulumi.get(self, "instance_metadata_tags")


@pulumi.output_type
class InstanceNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceIndex":
            suggest = "device_index"
        elif key == "networkInterfaceId":
            suggest = "network_interface_id"
        elif key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "networkCardIndex":
            suggest = "network_card_index"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_index: int,
                 network_interface_id: str,
                 delete_on_termination: Optional[bool] = None,
                 network_card_index: Optional[int] = None):
        """
        :param int device_index: Integer index of the network interface attachment. Limited by instance type.
        :param str network_interface_id: ID of the network interface to attach.
        :param bool delete_on_termination: Whether or not to delete the network interface on instance termination. Defaults to `false`. Currently, the only valid value is `false`, as this is only supported when creating new network interfaces when launching an instance.
        :param int network_card_index: Integer index of the network card. Limited by instance type. The default index is `0`.
        """
        InstanceNetworkInterface._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            device_index=device_index,
            network_interface_id=network_interface_id,
            delete_on_termination=delete_on_termination,
            network_card_index=network_card_index,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             device_index: Optional[int] = None,
             network_interface_id: Optional[str] = None,
             delete_on_termination: Optional[bool] = None,
             network_card_index: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if device_index is None and 'deviceIndex' in kwargs:
            device_index = kwargs['deviceIndex']
        if device_index is None:
            raise TypeError("Missing 'device_index' argument")
        if network_interface_id is None and 'networkInterfaceId' in kwargs:
            network_interface_id = kwargs['networkInterfaceId']
        if network_interface_id is None:
            raise TypeError("Missing 'network_interface_id' argument")
        if delete_on_termination is None and 'deleteOnTermination' in kwargs:
            delete_on_termination = kwargs['deleteOnTermination']
        if network_card_index is None and 'networkCardIndex' in kwargs:
            network_card_index = kwargs['networkCardIndex']

        _setter("device_index", device_index)
        _setter("network_interface_id", network_interface_id)
        if delete_on_termination is not None:
            _setter("delete_on_termination", delete_on_termination)
        if network_card_index is not None:
            _setter("network_card_index", network_card_index)

    @property
    @pulumi.getter(name="deviceIndex")
    def device_index(self) -> int:
        """
        Integer index of the network interface attachment. Limited by instance type.
        """
        return pulumi.get(self, "device_index")

    @property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> str:
        """
        ID of the network interface to attach.
        """
        return pulumi.get(self, "network_interface_id")

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[bool]:
        """
        Whether or not to delete the network interface on instance termination. Defaults to `false`. Currently, the only valid value is `false`, as this is only supported when creating new network interfaces when launching an instance.
        """
        return pulumi.get(self, "delete_on_termination")

    @property
    @pulumi.getter(name="networkCardIndex")
    def network_card_index(self) -> Optional[int]:
        """
        Integer index of the network card. Limited by instance type. The default index is `0`.
        """
        return pulumi.get(self, "network_card_index")


@pulumi.output_type
class InstancePrivateDnsNameOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableResourceNameDnsARecord":
            suggest = "enable_resource_name_dns_a_record"
        elif key == "enableResourceNameDnsAaaaRecord":
            suggest = "enable_resource_name_dns_aaaa_record"
        elif key == "hostnameType":
            suggest = "hostname_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstancePrivateDnsNameOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstancePrivateDnsNameOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstancePrivateDnsNameOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_resource_name_dns_a_record: Optional[bool] = None,
                 enable_resource_name_dns_aaaa_record: Optional[bool] = None,
                 hostname_type: Optional[str] = None):
        """
        :param bool enable_resource_name_dns_a_record: Indicates whether to respond to DNS queries for instance hostnames with DNS A records.
        :param bool enable_resource_name_dns_aaaa_record: Indicates whether to respond to DNS queries for instance hostnames with DNS AAAA records.
        :param str hostname_type: Type of hostname for Amazon EC2 instances. For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 native subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID. Valid values: `ip-name` and `resource-name`.
        """
        InstancePrivateDnsNameOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enable_resource_name_dns_a_record=enable_resource_name_dns_a_record,
            enable_resource_name_dns_aaaa_record=enable_resource_name_dns_aaaa_record,
            hostname_type=hostname_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enable_resource_name_dns_a_record: Optional[bool] = None,
             enable_resource_name_dns_aaaa_record: Optional[bool] = None,
             hostname_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if enable_resource_name_dns_a_record is None and 'enableResourceNameDnsARecord' in kwargs:
            enable_resource_name_dns_a_record = kwargs['enableResourceNameDnsARecord']
        if enable_resource_name_dns_aaaa_record is None and 'enableResourceNameDnsAaaaRecord' in kwargs:
            enable_resource_name_dns_aaaa_record = kwargs['enableResourceNameDnsAaaaRecord']
        if hostname_type is None and 'hostnameType' in kwargs:
            hostname_type = kwargs['hostnameType']

        if enable_resource_name_dns_a_record is not None:
            _setter("enable_resource_name_dns_a_record", enable_resource_name_dns_a_record)
        if enable_resource_name_dns_aaaa_record is not None:
            _setter("enable_resource_name_dns_aaaa_record", enable_resource_name_dns_aaaa_record)
        if hostname_type is not None:
            _setter("hostname_type", hostname_type)

    @property
    @pulumi.getter(name="enableResourceNameDnsARecord")
    def enable_resource_name_dns_a_record(self) -> Optional[bool]:
        """
        Indicates whether to respond to DNS queries for instance hostnames with DNS A records.
        """
        return pulumi.get(self, "enable_resource_name_dns_a_record")

    @property
    @pulumi.getter(name="enableResourceNameDnsAaaaRecord")
    def enable_resource_name_dns_aaaa_record(self) -> Optional[bool]:
        """
        Indicates whether to respond to DNS queries for instance hostnames with DNS AAAA records.
        """
        return pulumi.get(self, "enable_resource_name_dns_aaaa_record")

    @property
    @pulumi.getter(name="hostnameType")
    def hostname_type(self) -> Optional[str]:
        """
        Type of hostname for Amazon EC2 instances. For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 native subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID. Valid values: `ip-name` and `resource-name`.
        """
        return pulumi.get(self, "hostname_type")


@pulumi.output_type
class InstanceRootBlockDevice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "deviceName":
            suggest = "device_name"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "volumeId":
            suggest = "volume_id"
        elif key == "volumeSize":
            suggest = "volume_size"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceRootBlockDevice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceRootBlockDevice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceRootBlockDevice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delete_on_termination: Optional[bool] = None,
                 device_name: Optional[str] = None,
                 encrypted: Optional[bool] = None,
                 iops: Optional[int] = None,
                 kms_key_id: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 throughput: Optional[int] = None,
                 volume_id: Optional[str] = None,
                 volume_size: Optional[int] = None,
                 volume_type: Optional[str] = None):
        """
        :param bool delete_on_termination: Whether the volume should be destroyed on instance termination. Defaults to `true`.
        :param str device_name: Name of the device to mount.
        :param bool encrypted: Whether to enable volume encryption. Defaults to `false`. Must be configured to perform drift detection.
        :param int iops: Amount of provisioned [IOPS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-io-characteristics.html). Only valid for volume_type of `io1`, `io2` or `gp3`.
        :param str kms_key_id: Amazon Resource Name (ARN) of the KMS Key to use when encrypting the volume. Must be configured to perform drift detection.
        :param Mapping[str, str] tags: Map of tags to assign to the device.
        :param int throughput: Throughput to provision for a volume in mebibytes per second (MiB/s). This is only valid for `volume_type` of `gp3`.
        :param str volume_id: ID of the volume. For example, the ID can be accessed like this, `aws_instance.web.root_block_device.0.volume_id`.
        :param int volume_size: Size of the volume in gibibytes (GiB).
        :param str volume_type: Type of volume. Valid values include `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1`, or `st1`. Defaults to `gp2`.
               
               Modifying the `encrypted` or `kms_key_id` settings of the `root_block_device` requires resource replacement.
        """
        InstanceRootBlockDevice._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            delete_on_termination=delete_on_termination,
            device_name=device_name,
            encrypted=encrypted,
            iops=iops,
            kms_key_id=kms_key_id,
            tags=tags,
            throughput=throughput,
            volume_id=volume_id,
            volume_size=volume_size,
            volume_type=volume_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             delete_on_termination: Optional[bool] = None,
             device_name: Optional[str] = None,
             encrypted: Optional[bool] = None,
             iops: Optional[int] = None,
             kms_key_id: Optional[str] = None,
             tags: Optional[Mapping[str, str]] = None,
             throughput: Optional[int] = None,
             volume_id: Optional[str] = None,
             volume_size: Optional[int] = None,
             volume_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if delete_on_termination is None and 'deleteOnTermination' in kwargs:
            delete_on_termination = kwargs['deleteOnTermination']
        if device_name is None and 'deviceName' in kwargs:
            device_name = kwargs['deviceName']
        if kms_key_id is None and 'kmsKeyId' in kwargs:
            kms_key_id = kwargs['kmsKeyId']
        if volume_id is None and 'volumeId' in kwargs:
            volume_id = kwargs['volumeId']
        if volume_size is None and 'volumeSize' in kwargs:
            volume_size = kwargs['volumeSize']
        if volume_type is None and 'volumeType' in kwargs:
            volume_type = kwargs['volumeType']

        if delete_on_termination is not None:
            _setter("delete_on_termination", delete_on_termination)
        if device_name is not None:
            _setter("device_name", device_name)
        if encrypted is not None:
            _setter("encrypted", encrypted)
        if iops is not None:
            _setter("iops", iops)
        if kms_key_id is not None:
            _setter("kms_key_id", kms_key_id)
        if tags is not None:
            _setter("tags", tags)
        if throughput is not None:
            _setter("throughput", throughput)
        if volume_id is not None:
            _setter("volume_id", volume_id)
        if volume_size is not None:
            _setter("volume_size", volume_size)
        if volume_type is not None:
            _setter("volume_type", volume_type)

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[bool]:
        """
        Whether the volume should be destroyed on instance termination. Defaults to `true`.
        """
        return pulumi.get(self, "delete_on_termination")

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[str]:
        """
        Name of the device to mount.
        """
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[bool]:
        """
        Whether to enable volume encryption. Defaults to `false`. Must be configured to perform drift detection.
        """
        return pulumi.get(self, "encrypted")

    @property
    @pulumi.getter
    def iops(self) -> Optional[int]:
        """
        Amount of provisioned [IOPS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-io-characteristics.html). Only valid for volume_type of `io1`, `io2` or `gp3`.
        """
        return pulumi.get(self, "iops")

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN) of the KMS Key to use when encrypting the volume. Must be configured to perform drift detection.
        """
        return pulumi.get(self, "kms_key_id")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Map of tags to assign to the device.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def throughput(self) -> Optional[int]:
        """
        Throughput to provision for a volume in mebibytes per second (MiB/s). This is only valid for `volume_type` of `gp3`.
        """
        return pulumi.get(self, "throughput")

    @property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> Optional[str]:
        """
        ID of the volume. For example, the ID can be accessed like this, `aws_instance.web.root_block_device.0.volume_id`.
        """
        return pulumi.get(self, "volume_id")

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[int]:
        """
        Size of the volume in gibibytes (GiB).
        """
        return pulumi.get(self, "volume_size")

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[str]:
        """
        Type of volume. Valid values include `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1`, or `st1`. Defaults to `gp2`.

        Modifying the `encrypted` or `kms_key_id` settings of the `root_block_device` requires resource replacement.
        """
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class LaunchConfigurationEbsBlockDevice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "noDevice":
            suggest = "no_device"
        elif key == "snapshotId":
            suggest = "snapshot_id"
        elif key == "volumeSize":
            suggest = "volume_size"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchConfigurationEbsBlockDevice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchConfigurationEbsBlockDevice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchConfigurationEbsBlockDevice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_name: str,
                 delete_on_termination: Optional[bool] = None,
                 encrypted: Optional[bool] = None,
                 iops: Optional[int] = None,
                 no_device: Optional[bool] = None,
                 snapshot_id: Optional[str] = None,
                 throughput: Optional[int] = None,
                 volume_size: Optional[int] = None,
                 volume_type: Optional[str] = None):
        LaunchConfigurationEbsBlockDevice._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            device_name=device_name,
            delete_on_termination=delete_on_termination,
            encrypted=encrypted,
            iops=iops,
            no_device=no_device,
            snapshot_id=snapshot_id,
            throughput=throughput,
            volume_size=volume_size,
            volume_type=volume_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             device_name: Optional[str] = None,
             delete_on_termination: Optional[bool] = None,
             encrypted: Optional[bool] = None,
             iops: Optional[int] = None,
             no_device: Optional[bool] = None,
             snapshot_id: Optional[str] = None,
             throughput: Optional[int] = None,
             volume_size: Optional[int] = None,
             volume_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if device_name is None and 'deviceName' in kwargs:
            device_name = kwargs['deviceName']
        if device_name is None:
            raise TypeError("Missing 'device_name' argument")
        if delete_on_termination is None and 'deleteOnTermination' in kwargs:
            delete_on_termination = kwargs['deleteOnTermination']
        if no_device is None and 'noDevice' in kwargs:
            no_device = kwargs['noDevice']
        if snapshot_id is None and 'snapshotId' in kwargs:
            snapshot_id = kwargs['snapshotId']
        if volume_size is None and 'volumeSize' in kwargs:
            volume_size = kwargs['volumeSize']
        if volume_type is None and 'volumeType' in kwargs:
            volume_type = kwargs['volumeType']

        _setter("device_name", device_name)
        if delete_on_termination is not None:
            _setter("delete_on_termination", delete_on_termination)
        if encrypted is not None:
            _setter("encrypted", encrypted)
        if iops is not None:
            _setter("iops", iops)
        if no_device is not None:
            _setter("no_device", no_device)
        if snapshot_id is not None:
            _setter("snapshot_id", snapshot_id)
        if throughput is not None:
            _setter("throughput", throughput)
        if volume_size is not None:
            _setter("volume_size", volume_size)
        if volume_type is not None:
            _setter("volume_type", volume_type)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> str:
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[bool]:
        return pulumi.get(self, "delete_on_termination")

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[bool]:
        return pulumi.get(self, "encrypted")

    @property
    @pulumi.getter
    def iops(self) -> Optional[int]:
        return pulumi.get(self, "iops")

    @property
    @pulumi.getter(name="noDevice")
    def no_device(self) -> Optional[bool]:
        return pulumi.get(self, "no_device")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[str]:
        return pulumi.get(self, "snapshot_id")

    @property
    @pulumi.getter
    def throughput(self) -> Optional[int]:
        return pulumi.get(self, "throughput")

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[int]:
        return pulumi.get(self, "volume_size")

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[str]:
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class LaunchConfigurationEphemeralBlockDevice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "noDevice":
            suggest = "no_device"
        elif key == "virtualName":
            suggest = "virtual_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchConfigurationEphemeralBlockDevice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchConfigurationEphemeralBlockDevice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchConfigurationEphemeralBlockDevice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_name: str,
                 no_device: Optional[bool] = None,
                 virtual_name: Optional[str] = None):
        LaunchConfigurationEphemeralBlockDevice._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            device_name=device_name,
            no_device=no_device,
            virtual_name=virtual_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             device_name: Optional[str] = None,
             no_device: Optional[bool] = None,
             virtual_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if device_name is None and 'deviceName' in kwargs:
            device_name = kwargs['deviceName']
        if device_name is None:
            raise TypeError("Missing 'device_name' argument")
        if no_device is None and 'noDevice' in kwargs:
            no_device = kwargs['noDevice']
        if virtual_name is None and 'virtualName' in kwargs:
            virtual_name = kwargs['virtualName']

        _setter("device_name", device_name)
        if no_device is not None:
            _setter("no_device", no_device)
        if virtual_name is not None:
            _setter("virtual_name", virtual_name)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> str:
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter(name="noDevice")
    def no_device(self) -> Optional[bool]:
        return pulumi.get(self, "no_device")

    @property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> Optional[str]:
        return pulumi.get(self, "virtual_name")


@pulumi.output_type
class LaunchConfigurationMetadataOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpEndpoint":
            suggest = "http_endpoint"
        elif key == "httpPutResponseHopLimit":
            suggest = "http_put_response_hop_limit"
        elif key == "httpTokens":
            suggest = "http_tokens"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchConfigurationMetadataOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchConfigurationMetadataOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchConfigurationMetadataOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_endpoint: Optional[str] = None,
                 http_put_response_hop_limit: Optional[int] = None,
                 http_tokens: Optional[str] = None):
        """
        :param str http_endpoint: The state of the metadata service: `enabled`, `disabled`.
        :param int http_put_response_hop_limit: The desired HTTP PUT response hop limit for instance metadata requests.
        :param str http_tokens: If session tokens are required: `optional`, `required`.
        """
        LaunchConfigurationMetadataOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            http_endpoint=http_endpoint,
            http_put_response_hop_limit=http_put_response_hop_limit,
            http_tokens=http_tokens,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             http_endpoint: Optional[str] = None,
             http_put_response_hop_limit: Optional[int] = None,
             http_tokens: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if http_endpoint is None and 'httpEndpoint' in kwargs:
            http_endpoint = kwargs['httpEndpoint']
        if http_put_response_hop_limit is None and 'httpPutResponseHopLimit' in kwargs:
            http_put_response_hop_limit = kwargs['httpPutResponseHopLimit']
        if http_tokens is None and 'httpTokens' in kwargs:
            http_tokens = kwargs['httpTokens']

        if http_endpoint is not None:
            _setter("http_endpoint", http_endpoint)
        if http_put_response_hop_limit is not None:
            _setter("http_put_response_hop_limit", http_put_response_hop_limit)
        if http_tokens is not None:
            _setter("http_tokens", http_tokens)

    @property
    @pulumi.getter(name="httpEndpoint")
    def http_endpoint(self) -> Optional[str]:
        """
        The state of the metadata service: `enabled`, `disabled`.
        """
        return pulumi.get(self, "http_endpoint")

    @property
    @pulumi.getter(name="httpPutResponseHopLimit")
    def http_put_response_hop_limit(self) -> Optional[int]:
        """
        The desired HTTP PUT response hop limit for instance metadata requests.
        """
        return pulumi.get(self, "http_put_response_hop_limit")

    @property
    @pulumi.getter(name="httpTokens")
    def http_tokens(self) -> Optional[str]:
        """
        If session tokens are required: `optional`, `required`.
        """
        return pulumi.get(self, "http_tokens")


@pulumi.output_type
class LaunchConfigurationRootBlockDevice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "volumeSize":
            suggest = "volume_size"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchConfigurationRootBlockDevice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchConfigurationRootBlockDevice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchConfigurationRootBlockDevice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delete_on_termination: Optional[bool] = None,
                 encrypted: Optional[bool] = None,
                 iops: Optional[int] = None,
                 throughput: Optional[int] = None,
                 volume_size: Optional[int] = None,
                 volume_type: Optional[str] = None):
        LaunchConfigurationRootBlockDevice._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            delete_on_termination=delete_on_termination,
            encrypted=encrypted,
            iops=iops,
            throughput=throughput,
            volume_size=volume_size,
            volume_type=volume_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             delete_on_termination: Optional[bool] = None,
             encrypted: Optional[bool] = None,
             iops: Optional[int] = None,
             throughput: Optional[int] = None,
             volume_size: Optional[int] = None,
             volume_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if delete_on_termination is None and 'deleteOnTermination' in kwargs:
            delete_on_termination = kwargs['deleteOnTermination']
        if volume_size is None and 'volumeSize' in kwargs:
            volume_size = kwargs['volumeSize']
        if volume_type is None and 'volumeType' in kwargs:
            volume_type = kwargs['volumeType']

        if delete_on_termination is not None:
            _setter("delete_on_termination", delete_on_termination)
        if encrypted is not None:
            _setter("encrypted", encrypted)
        if iops is not None:
            _setter("iops", iops)
        if throughput is not None:
            _setter("throughput", throughput)
        if volume_size is not None:
            _setter("volume_size", volume_size)
        if volume_type is not None:
            _setter("volume_type", volume_type)

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[bool]:
        return pulumi.get(self, "delete_on_termination")

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[bool]:
        return pulumi.get(self, "encrypted")

    @property
    @pulumi.getter
    def iops(self) -> Optional[int]:
        return pulumi.get(self, "iops")

    @property
    @pulumi.getter
    def throughput(self) -> Optional[int]:
        return pulumi.get(self, "throughput")

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[int]:
        return pulumi.get(self, "volume_size")

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[str]:
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class LaunchTemplateBlockDeviceMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "noDevice":
            suggest = "no_device"
        elif key == "virtualName":
            suggest = "virtual_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateBlockDeviceMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateBlockDeviceMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateBlockDeviceMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_name: Optional[str] = None,
                 ebs: Optional['outputs.LaunchTemplateBlockDeviceMappingEbs'] = None,
                 no_device: Optional[str] = None,
                 virtual_name: Optional[str] = None):
        """
        :param str device_name: The name of the device to mount.
        :param 'LaunchTemplateBlockDeviceMappingEbsArgs' ebs: Configure EBS volume properties.
        :param str no_device: Suppresses the specified device included in the AMI's block device mapping.
        :param str virtual_name: The [Instance Store Device
               Name](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#InstanceStoreDeviceNames)
               (e.g., `"ephemeral0"`).
        """
        LaunchTemplateBlockDeviceMapping._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            device_name=device_name,
            ebs=ebs,
            no_device=no_device,
            virtual_name=virtual_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             device_name: Optional[str] = None,
             ebs: Optional['outputs.LaunchTemplateBlockDeviceMappingEbs'] = None,
             no_device: Optional[str] = None,
             virtual_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if device_name is None and 'deviceName' in kwargs:
            device_name = kwargs['deviceName']
        if no_device is None and 'noDevice' in kwargs:
            no_device = kwargs['noDevice']
        if virtual_name is None and 'virtualName' in kwargs:
            virtual_name = kwargs['virtualName']

        if device_name is not None:
            _setter("device_name", device_name)
        if ebs is not None:
            _setter("ebs", ebs)
        if no_device is not None:
            _setter("no_device", no_device)
        if virtual_name is not None:
            _setter("virtual_name", virtual_name)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[str]:
        """
        The name of the device to mount.
        """
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter
    def ebs(self) -> Optional['outputs.LaunchTemplateBlockDeviceMappingEbs']:
        """
        Configure EBS volume properties.
        """
        return pulumi.get(self, "ebs")

    @property
    @pulumi.getter(name="noDevice")
    def no_device(self) -> Optional[str]:
        """
        Suppresses the specified device included in the AMI's block device mapping.
        """
        return pulumi.get(self, "no_device")

    @property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> Optional[str]:
        """
        The [Instance Store Device
        Name](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#InstanceStoreDeviceNames)
        (e.g., `"ephemeral0"`).
        """
        return pulumi.get(self, "virtual_name")


@pulumi.output_type
class LaunchTemplateBlockDeviceMappingEbs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "snapshotId":
            suggest = "snapshot_id"
        elif key == "volumeSize":
            suggest = "volume_size"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateBlockDeviceMappingEbs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateBlockDeviceMappingEbs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateBlockDeviceMappingEbs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delete_on_termination: Optional[str] = None,
                 encrypted: Optional[str] = None,
                 iops: Optional[int] = None,
                 kms_key_id: Optional[str] = None,
                 snapshot_id: Optional[str] = None,
                 throughput: Optional[int] = None,
                 volume_size: Optional[int] = None,
                 volume_type: Optional[str] = None):
        """
        :param str delete_on_termination: Whether the volume should be destroyed on instance termination.
               See [Preserving Amazon EBS Volumes on Instance Termination](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/terminating-instances.html#preserving-volumes-on-termination) for more information.
        :param str encrypted: Enables [EBS encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html) on the volume.
               Cannot be used with `snapshot_id`.
        :param int iops: The amount of provisioned [IOPS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-io-characteristics.html).
               This must be set with a `volume_type` of `"io1/io2/gp3"`.
        :param str kms_key_id: The ARN of the AWS Key Management Service (AWS KMS) customer master key (CMK) to use when creating the encrypted volume.
               `encrypted` must be set to `true` when this is set.
        :param str snapshot_id: The Snapshot ID to mount.
        :param int throughput: The throughput to provision for a `gp3` volume in MiB/s (specified as an integer, e.g., 500), with a maximum of 1,000 MiB/s.
        :param int volume_size: The size of the volume in gigabytes.
        :param str volume_type: The volume type.
               Can be one of `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1` or `st1`.
        """
        LaunchTemplateBlockDeviceMappingEbs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            delete_on_termination=delete_on_termination,
            encrypted=encrypted,
            iops=iops,
            kms_key_id=kms_key_id,
            snapshot_id=snapshot_id,
            throughput=throughput,
            volume_size=volume_size,
            volume_type=volume_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             delete_on_termination: Optional[str] = None,
             encrypted: Optional[str] = None,
             iops: Optional[int] = None,
             kms_key_id: Optional[str] = None,
             snapshot_id: Optional[str] = None,
             throughput: Optional[int] = None,
             volume_size: Optional[int] = None,
             volume_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if delete_on_termination is None and 'deleteOnTermination' in kwargs:
            delete_on_termination = kwargs['deleteOnTermination']
        if kms_key_id is None and 'kmsKeyId' in kwargs:
            kms_key_id = kwargs['kmsKeyId']
        if snapshot_id is None and 'snapshotId' in kwargs:
            snapshot_id = kwargs['snapshotId']
        if volume_size is None and 'volumeSize' in kwargs:
            volume_size = kwargs['volumeSize']
        if volume_type is None and 'volumeType' in kwargs:
            volume_type = kwargs['volumeType']

        if delete_on_termination is not None:
            _setter("delete_on_termination", delete_on_termination)
        if encrypted is not None:
            _setter("encrypted", encrypted)
        if iops is not None:
            _setter("iops", iops)
        if kms_key_id is not None:
            _setter("kms_key_id", kms_key_id)
        if snapshot_id is not None:
            _setter("snapshot_id", snapshot_id)
        if throughput is not None:
            _setter("throughput", throughput)
        if volume_size is not None:
            _setter("volume_size", volume_size)
        if volume_type is not None:
            _setter("volume_type", volume_type)

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[str]:
        """
        Whether the volume should be destroyed on instance termination.
        See [Preserving Amazon EBS Volumes on Instance Termination](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/terminating-instances.html#preserving-volumes-on-termination) for more information.
        """
        return pulumi.get(self, "delete_on_termination")

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[str]:
        """
        Enables [EBS encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html) on the volume.
        Cannot be used with `snapshot_id`.
        """
        return pulumi.get(self, "encrypted")

    @property
    @pulumi.getter
    def iops(self) -> Optional[int]:
        """
        The amount of provisioned [IOPS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-io-characteristics.html).
        This must be set with a `volume_type` of `"io1/io2/gp3"`.
        """
        return pulumi.get(self, "iops")

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[str]:
        """
        The ARN of the AWS Key Management Service (AWS KMS) customer master key (CMK) to use when creating the encrypted volume.
        `encrypted` must be set to `true` when this is set.
        """
        return pulumi.get(self, "kms_key_id")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[str]:
        """
        The Snapshot ID to mount.
        """
        return pulumi.get(self, "snapshot_id")

    @property
    @pulumi.getter
    def throughput(self) -> Optional[int]:
        """
        The throughput to provision for a `gp3` volume in MiB/s (specified as an integer, e.g., 500), with a maximum of 1,000 MiB/s.
        """
        return pulumi.get(self, "throughput")

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[int]:
        """
        The size of the volume in gigabytes.
        """
        return pulumi.get(self, "volume_size")

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[str]:
        """
        The volume type.
        Can be one of `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1` or `st1`.
        """
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class LaunchTemplateCapacityReservationSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capacityReservationPreference":
            suggest = "capacity_reservation_preference"
        elif key == "capacityReservationTarget":
            suggest = "capacity_reservation_target"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateCapacityReservationSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateCapacityReservationSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateCapacityReservationSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capacity_reservation_preference: Optional[str] = None,
                 capacity_reservation_target: Optional['outputs.LaunchTemplateCapacityReservationSpecificationCapacityReservationTarget'] = None):
        """
        :param str capacity_reservation_preference: Indicates the instance's Capacity Reservation preferences. Can be `open` or `none`. (Default `none`).
        :param 'LaunchTemplateCapacityReservationSpecificationCapacityReservationTargetArgs' capacity_reservation_target: Used to target a specific Capacity Reservation:
        """
        LaunchTemplateCapacityReservationSpecification._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            capacity_reservation_preference=capacity_reservation_preference,
            capacity_reservation_target=capacity_reservation_target,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             capacity_reservation_preference: Optional[str] = None,
             capacity_reservation_target: Optional['outputs.LaunchTemplateCapacityReservationSpecificationCapacityReservationTarget'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if capacity_reservation_preference is None and 'capacityReservationPreference' in kwargs:
            capacity_reservation_preference = kwargs['capacityReservationPreference']
        if capacity_reservation_target is None and 'capacityReservationTarget' in kwargs:
            capacity_reservation_target = kwargs['capacityReservationTarget']

        if capacity_reservation_preference is not None:
            _setter("capacity_reservation_preference", capacity_reservation_preference)
        if capacity_reservation_target is not None:
            _setter("capacity_reservation_target", capacity_reservation_target)

    @property
    @pulumi.getter(name="capacityReservationPreference")
    def capacity_reservation_preference(self) -> Optional[str]:
        """
        Indicates the instance's Capacity Reservation preferences. Can be `open` or `none`. (Default `none`).
        """
        return pulumi.get(self, "capacity_reservation_preference")

    @property
    @pulumi.getter(name="capacityReservationTarget")
    def capacity_reservation_target(self) -> Optional['outputs.LaunchTemplateCapacityReservationSpecificationCapacityReservationTarget']:
        """
        Used to target a specific Capacity Reservation:
        """
        return pulumi.get(self, "capacity_reservation_target")


@pulumi.output_type
class LaunchTemplateCapacityReservationSpecificationCapacityReservationTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capacityReservationId":
            suggest = "capacity_reservation_id"
        elif key == "capacityReservationResourceGroupArn":
            suggest = "capacity_reservation_resource_group_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateCapacityReservationSpecificationCapacityReservationTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateCapacityReservationSpecificationCapacityReservationTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateCapacityReservationSpecificationCapacityReservationTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capacity_reservation_id: Optional[str] = None,
                 capacity_reservation_resource_group_arn: Optional[str] = None):
        """
        :param str capacity_reservation_id: The ID of the Capacity Reservation in which to run the instance.
        :param str capacity_reservation_resource_group_arn: The ARN of the Capacity Reservation resource group in which to run the instance.
        """
        LaunchTemplateCapacityReservationSpecificationCapacityReservationTarget._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            capacity_reservation_id=capacity_reservation_id,
            capacity_reservation_resource_group_arn=capacity_reservation_resource_group_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             capacity_reservation_id: Optional[str] = None,
             capacity_reservation_resource_group_arn: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if capacity_reservation_id is None and 'capacityReservationId' in kwargs:
            capacity_reservation_id = kwargs['capacityReservationId']
        if capacity_reservation_resource_group_arn is None and 'capacityReservationResourceGroupArn' in kwargs:
            capacity_reservation_resource_group_arn = kwargs['capacityReservationResourceGroupArn']

        if capacity_reservation_id is not None:
            _setter("capacity_reservation_id", capacity_reservation_id)
        if capacity_reservation_resource_group_arn is not None:
            _setter("capacity_reservation_resource_group_arn", capacity_reservation_resource_group_arn)

    @property
    @pulumi.getter(name="capacityReservationId")
    def capacity_reservation_id(self) -> Optional[str]:
        """
        The ID of the Capacity Reservation in which to run the instance.
        """
        return pulumi.get(self, "capacity_reservation_id")

    @property
    @pulumi.getter(name="capacityReservationResourceGroupArn")
    def capacity_reservation_resource_group_arn(self) -> Optional[str]:
        """
        The ARN of the Capacity Reservation resource group in which to run the instance.
        """
        return pulumi.get(self, "capacity_reservation_resource_group_arn")


@pulumi.output_type
class LaunchTemplateCpuOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "amdSevSnp":
            suggest = "amd_sev_snp"
        elif key == "coreCount":
            suggest = "core_count"
        elif key == "threadsPerCore":
            suggest = "threads_per_core"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateCpuOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateCpuOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateCpuOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 amd_sev_snp: Optional[str] = None,
                 core_count: Optional[int] = None,
                 threads_per_core: Optional[int] = None):
        """
        :param str amd_sev_snp: Indicates whether to enable the instance for AMD SEV-SNP. AMD SEV-SNP is supported with M6a, R6a, and C6a instance types only. Valid values are `enabled` and `disabled`.
        :param int core_count: The number of CPU cores for the instance.
        :param int threads_per_core: The number of threads per CPU core.
               To disable Intel Hyper-Threading Technology for the instance, specify a value of 1.
               Otherwise, specify the default value of 2.
               
               Both number of CPU cores and threads per core must be specified. Valid number of CPU cores and threads per core for the instance type can be found in the [CPU Options Documentation](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html?shortFooter=true#cpu-options-supported-instances-values)
        """
        LaunchTemplateCpuOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            amd_sev_snp=amd_sev_snp,
            core_count=core_count,
            threads_per_core=threads_per_core,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             amd_sev_snp: Optional[str] = None,
             core_count: Optional[int] = None,
             threads_per_core: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if amd_sev_snp is None and 'amdSevSnp' in kwargs:
            amd_sev_snp = kwargs['amdSevSnp']
        if core_count is None and 'coreCount' in kwargs:
            core_count = kwargs['coreCount']
        if threads_per_core is None and 'threadsPerCore' in kwargs:
            threads_per_core = kwargs['threadsPerCore']

        if amd_sev_snp is not None:
            _setter("amd_sev_snp", amd_sev_snp)
        if core_count is not None:
            _setter("core_count", core_count)
        if threads_per_core is not None:
            _setter("threads_per_core", threads_per_core)

    @property
    @pulumi.getter(name="amdSevSnp")
    def amd_sev_snp(self) -> Optional[str]:
        """
        Indicates whether to enable the instance for AMD SEV-SNP. AMD SEV-SNP is supported with M6a, R6a, and C6a instance types only. Valid values are `enabled` and `disabled`.
        """
        return pulumi.get(self, "amd_sev_snp")

    @property
    @pulumi.getter(name="coreCount")
    def core_count(self) -> Optional[int]:
        """
        The number of CPU cores for the instance.
        """
        return pulumi.get(self, "core_count")

    @property
    @pulumi.getter(name="threadsPerCore")
    def threads_per_core(self) -> Optional[int]:
        """
        The number of threads per CPU core.
        To disable Intel Hyper-Threading Technology for the instance, specify a value of 1.
        Otherwise, specify the default value of 2.

        Both number of CPU cores and threads per core must be specified. Valid number of CPU cores and threads per core for the instance type can be found in the [CPU Options Documentation](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html?shortFooter=true#cpu-options-supported-instances-values)
        """
        return pulumi.get(self, "threads_per_core")


@pulumi.output_type
class LaunchTemplateCreditSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cpuCredits":
            suggest = "cpu_credits"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateCreditSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateCreditSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateCreditSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu_credits: Optional[str] = None):
        """
        :param str cpu_credits: The credit option for CPU usage.
               Can be `standard` or `unlimited`.
               T3 instances are launched as `unlimited` by default.
               T2 instances are launched as `standard` by default.
        """
        LaunchTemplateCreditSpecification._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cpu_credits=cpu_credits,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cpu_credits: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cpu_credits is None and 'cpuCredits' in kwargs:
            cpu_credits = kwargs['cpuCredits']

        if cpu_credits is not None:
            _setter("cpu_credits", cpu_credits)

    @property
    @pulumi.getter(name="cpuCredits")
    def cpu_credits(self) -> Optional[str]:
        """
        The credit option for CPU usage.
        Can be `standard` or `unlimited`.
        T3 instances are launched as `unlimited` by default.
        T2 instances are launched as `standard` by default.
        """
        return pulumi.get(self, "cpu_credits")


@pulumi.output_type
class LaunchTemplateElasticGpuSpecification(dict):
    def __init__(__self__, *,
                 type: str):
        """
        :param str type: The [Elastic GPU Type](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/elastic-gpus.html#elastic-gpus-basics)
        """
        LaunchTemplateElasticGpuSpecification._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("type", type)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The [Elastic GPU Type](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/elastic-gpus.html#elastic-gpus-basics)
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class LaunchTemplateElasticInferenceAccelerator(dict):
    def __init__(__self__, *,
                 type: str):
        """
        :param str type: Accelerator type.
        """
        LaunchTemplateElasticInferenceAccelerator._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("type", type)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Accelerator type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class LaunchTemplateEnclaveOptions(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        """
        :param bool enabled: If set to `true`, Nitro Enclaves will be enabled on the instance.
               
               For more information, see the documentation on [Nitro Enclaves](https://docs.aws.amazon.com/enclaves/latest/user/nitro-enclave.html).
        """
        LaunchTemplateEnclaveOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if enabled is not None:
            _setter("enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set to `true`, Nitro Enclaves will be enabled on the instance.

        For more information, see the documentation on [Nitro Enclaves](https://docs.aws.amazon.com/enclaves/latest/user/nitro-enclave.html).
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class LaunchTemplateHibernationOptions(dict):
    def __init__(__self__, *,
                 configured: bool):
        """
        :param bool configured: If set to `true`, the launched EC2 instance will hibernation enabled.
        """
        LaunchTemplateHibernationOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            configured=configured,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             configured: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if configured is None:
            raise TypeError("Missing 'configured' argument")

        _setter("configured", configured)

    @property
    @pulumi.getter
    def configured(self) -> bool:
        """
        If set to `true`, the launched EC2 instance will hibernation enabled.
        """
        return pulumi.get(self, "configured")


@pulumi.output_type
class LaunchTemplateIamInstanceProfile(dict):
    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str arn: The Amazon Resource Name (ARN) of the instance profile.
        :param str name: The name of the instance profile.
        """
        LaunchTemplateIamInstanceProfile._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if arn is not None:
            _setter("arn", arn)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) of the instance profile.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the instance profile.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class LaunchTemplateInstanceMarketOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "marketType":
            suggest = "market_type"
        elif key == "spotOptions":
            suggest = "spot_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateInstanceMarketOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateInstanceMarketOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateInstanceMarketOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 market_type: Optional[str] = None,
                 spot_options: Optional['outputs.LaunchTemplateInstanceMarketOptionsSpotOptions'] = None):
        """
        :param str market_type: The market type. Can be `spot`.
        :param 'LaunchTemplateInstanceMarketOptionsSpotOptionsArgs' spot_options: The options for [Spot Instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-spot-instances.html)
        """
        LaunchTemplateInstanceMarketOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            market_type=market_type,
            spot_options=spot_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             market_type: Optional[str] = None,
             spot_options: Optional['outputs.LaunchTemplateInstanceMarketOptionsSpotOptions'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if market_type is None and 'marketType' in kwargs:
            market_type = kwargs['marketType']
        if spot_options is None and 'spotOptions' in kwargs:
            spot_options = kwargs['spotOptions']

        if market_type is not None:
            _setter("market_type", market_type)
        if spot_options is not None:
            _setter("spot_options", spot_options)

    @property
    @pulumi.getter(name="marketType")
    def market_type(self) -> Optional[str]:
        """
        The market type. Can be `spot`.
        """
        return pulumi.get(self, "market_type")

    @property
    @pulumi.getter(name="spotOptions")
    def spot_options(self) -> Optional['outputs.LaunchTemplateInstanceMarketOptionsSpotOptions']:
        """
        The options for [Spot Instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-spot-instances.html)
        """
        return pulumi.get(self, "spot_options")


@pulumi.output_type
class LaunchTemplateInstanceMarketOptionsSpotOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blockDurationMinutes":
            suggest = "block_duration_minutes"
        elif key == "instanceInterruptionBehavior":
            suggest = "instance_interruption_behavior"
        elif key == "maxPrice":
            suggest = "max_price"
        elif key == "spotInstanceType":
            suggest = "spot_instance_type"
        elif key == "validUntil":
            suggest = "valid_until"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateInstanceMarketOptionsSpotOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateInstanceMarketOptionsSpotOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateInstanceMarketOptionsSpotOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 block_duration_minutes: Optional[int] = None,
                 instance_interruption_behavior: Optional[str] = None,
                 max_price: Optional[str] = None,
                 spot_instance_type: Optional[str] = None,
                 valid_until: Optional[str] = None):
        """
        :param int block_duration_minutes: The required duration in minutes. This value must be a multiple of 60.
        :param str instance_interruption_behavior: The behavior when a Spot Instance is interrupted. Can be `hibernate`,
               `stop`, or `terminate`. (Default: `terminate`).
        :param str max_price: The maximum hourly price you're willing to pay for the Spot Instances.
        :param str spot_instance_type: The Spot Instance request type. Can be `one-time`, or `persistent`.
        :param str valid_until: The end date of the request.
        """
        LaunchTemplateInstanceMarketOptionsSpotOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            block_duration_minutes=block_duration_minutes,
            instance_interruption_behavior=instance_interruption_behavior,
            max_price=max_price,
            spot_instance_type=spot_instance_type,
            valid_until=valid_until,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             block_duration_minutes: Optional[int] = None,
             instance_interruption_behavior: Optional[str] = None,
             max_price: Optional[str] = None,
             spot_instance_type: Optional[str] = None,
             valid_until: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if block_duration_minutes is None and 'blockDurationMinutes' in kwargs:
            block_duration_minutes = kwargs['blockDurationMinutes']
        if instance_interruption_behavior is None and 'instanceInterruptionBehavior' in kwargs:
            instance_interruption_behavior = kwargs['instanceInterruptionBehavior']
        if max_price is None and 'maxPrice' in kwargs:
            max_price = kwargs['maxPrice']
        if spot_instance_type is None and 'spotInstanceType' in kwargs:
            spot_instance_type = kwargs['spotInstanceType']
        if valid_until is None and 'validUntil' in kwargs:
            valid_until = kwargs['validUntil']

        if block_duration_minutes is not None:
            _setter("block_duration_minutes", block_duration_minutes)
        if instance_interruption_behavior is not None:
            _setter("instance_interruption_behavior", instance_interruption_behavior)
        if max_price is not None:
            _setter("max_price", max_price)
        if spot_instance_type is not None:
            _setter("spot_instance_type", spot_instance_type)
        if valid_until is not None:
            _setter("valid_until", valid_until)

    @property
    @pulumi.getter(name="blockDurationMinutes")
    def block_duration_minutes(self) -> Optional[int]:
        """
        The required duration in minutes. This value must be a multiple of 60.
        """
        return pulumi.get(self, "block_duration_minutes")

    @property
    @pulumi.getter(name="instanceInterruptionBehavior")
    def instance_interruption_behavior(self) -> Optional[str]:
        """
        The behavior when a Spot Instance is interrupted. Can be `hibernate`,
        `stop`, or `terminate`. (Default: `terminate`).
        """
        return pulumi.get(self, "instance_interruption_behavior")

    @property
    @pulumi.getter(name="maxPrice")
    def max_price(self) -> Optional[str]:
        """
        The maximum hourly price you're willing to pay for the Spot Instances.
        """
        return pulumi.get(self, "max_price")

    @property
    @pulumi.getter(name="spotInstanceType")
    def spot_instance_type(self) -> Optional[str]:
        """
        The Spot Instance request type. Can be `one-time`, or `persistent`.
        """
        return pulumi.get(self, "spot_instance_type")

    @property
    @pulumi.getter(name="validUntil")
    def valid_until(self) -> Optional[str]:
        """
        The end date of the request.
        """
        return pulumi.get(self, "valid_until")


@pulumi.output_type
class LaunchTemplateInstanceRequirements(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "memoryMib":
            suggest = "memory_mib"
        elif key == "vcpuCount":
            suggest = "vcpu_count"
        elif key == "acceleratorCount":
            suggest = "accelerator_count"
        elif key == "acceleratorManufacturers":
            suggest = "accelerator_manufacturers"
        elif key == "acceleratorNames":
            suggest = "accelerator_names"
        elif key == "acceleratorTotalMemoryMib":
            suggest = "accelerator_total_memory_mib"
        elif key == "acceleratorTypes":
            suggest = "accelerator_types"
        elif key == "allowedInstanceTypes":
            suggest = "allowed_instance_types"
        elif key == "bareMetal":
            suggest = "bare_metal"
        elif key == "baselineEbsBandwidthMbps":
            suggest = "baseline_ebs_bandwidth_mbps"
        elif key == "burstablePerformance":
            suggest = "burstable_performance"
        elif key == "cpuManufacturers":
            suggest = "cpu_manufacturers"
        elif key == "excludedInstanceTypes":
            suggest = "excluded_instance_types"
        elif key == "instanceGenerations":
            suggest = "instance_generations"
        elif key == "localStorage":
            suggest = "local_storage"
        elif key == "localStorageTypes":
            suggest = "local_storage_types"
        elif key == "memoryGibPerVcpu":
            suggest = "memory_gib_per_vcpu"
        elif key == "networkBandwidthGbps":
            suggest = "network_bandwidth_gbps"
        elif key == "networkInterfaceCount":
            suggest = "network_interface_count"
        elif key == "onDemandMaxPricePercentageOverLowestPrice":
            suggest = "on_demand_max_price_percentage_over_lowest_price"
        elif key == "requireHibernateSupport":
            suggest = "require_hibernate_support"
        elif key == "spotMaxPricePercentageOverLowestPrice":
            suggest = "spot_max_price_percentage_over_lowest_price"
        elif key == "totalLocalStorageGb":
            suggest = "total_local_storage_gb"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateInstanceRequirements. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateInstanceRequirements.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateInstanceRequirements.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 memory_mib: 'outputs.LaunchTemplateInstanceRequirementsMemoryMib',
                 vcpu_count: 'outputs.LaunchTemplateInstanceRequirementsVcpuCount',
                 accelerator_count: Optional['outputs.LaunchTemplateInstanceRequirementsAcceleratorCount'] = None,
                 accelerator_manufacturers: Optional[Sequence[str]] = None,
                 accelerator_names: Optional[Sequence[str]] = None,
                 accelerator_total_memory_mib: Optional['outputs.LaunchTemplateInstanceRequirementsAcceleratorTotalMemoryMib'] = None,
                 accelerator_types: Optional[Sequence[str]] = None,
                 allowed_instance_types: Optional[Sequence[str]] = None,
                 bare_metal: Optional[str] = None,
                 baseline_ebs_bandwidth_mbps: Optional['outputs.LaunchTemplateInstanceRequirementsBaselineEbsBandwidthMbps'] = None,
                 burstable_performance: Optional[str] = None,
                 cpu_manufacturers: Optional[Sequence[str]] = None,
                 excluded_instance_types: Optional[Sequence[str]] = None,
                 instance_generations: Optional[Sequence[str]] = None,
                 local_storage: Optional[str] = None,
                 local_storage_types: Optional[Sequence[str]] = None,
                 memory_gib_per_vcpu: Optional['outputs.LaunchTemplateInstanceRequirementsMemoryGibPerVcpu'] = None,
                 network_bandwidth_gbps: Optional['outputs.LaunchTemplateInstanceRequirementsNetworkBandwidthGbps'] = None,
                 network_interface_count: Optional['outputs.LaunchTemplateInstanceRequirementsNetworkInterfaceCount'] = None,
                 on_demand_max_price_percentage_over_lowest_price: Optional[int] = None,
                 require_hibernate_support: Optional[bool] = None,
                 spot_max_price_percentage_over_lowest_price: Optional[int] = None,
                 total_local_storage_gb: Optional['outputs.LaunchTemplateInstanceRequirementsTotalLocalStorageGb'] = None):
        """
        :param 'LaunchTemplateInstanceRequirementsMemoryMibArgs' memory_mib: Block describing the minimum and maximum amount of memory (MiB). Default is no maximum.
        :param 'LaunchTemplateInstanceRequirementsVcpuCountArgs' vcpu_count: Block describing the minimum and maximum number of vCPUs. Default is no maximum.
        :param 'LaunchTemplateInstanceRequirementsAcceleratorCountArgs' accelerator_count: Block describing the minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips). Default is no minimum or maximum.
        :param Sequence[str] accelerator_manufacturers: List of accelerator manufacturer names. Default is any manufacturer.
               
               ```python
               import pulumi
               ```
        :param Sequence[str] accelerator_names: List of accelerator names. Default is any acclerator.
               
               ```python
               import pulumi
               ```
        :param 'LaunchTemplateInstanceRequirementsAcceleratorTotalMemoryMibArgs' accelerator_total_memory_mib: Block describing the minimum and maximum total memory of the accelerators. Default is no minimum or maximum.
        :param Sequence[str] accelerator_types: List of accelerator types. Default is any accelerator type.
               
               ```python
               import pulumi
               ```
        :param Sequence[str] allowed_instance_types: List of instance types to apply your specified attributes against. All other instance types are ignored, even if they match your specified attributes. You can use strings with one or more wild cards, represented by an asterisk (\\*), to allow an instance type, size, or generation. The following are examples: `m5.8xlarge`, `c5*.*`, `m5a.*`, `r*`, `*3*`. For example, if you specify `c5*`, you are allowing the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*`, you are allowing all the M5a instance types, but not the M5n instance types. Maximum of 400 entries in the list; each entry is limited to 30 characters. Default is all instance types.
               
               > **NOTE:** If you specify `allowed_instance_types`, you can't specify `excluded_instance_types`.
        :param str bare_metal: Indicate whether bare metal instace types should be `included`, `excluded`, or `required`. Default is `excluded`.
        :param 'LaunchTemplateInstanceRequirementsBaselineEbsBandwidthMbpsArgs' baseline_ebs_bandwidth_mbps: Block describing the minimum and maximum baseline EBS bandwidth, in Mbps. Default is no minimum or maximum.
        :param str burstable_performance: Indicate whether burstable performance instance types should be `included`, `excluded`, or `required`. Default is `excluded`.
        :param Sequence[str] cpu_manufacturers: List of CPU manufacturer names. Default is any manufacturer.
               
               > **NOTE:** Don't confuse the CPU hardware manufacturer with the CPU hardware architecture. Instances will be launched with a compatible CPU architecture based on the Amazon Machine Image (AMI) that you specify in your launch template.
               
               ```python
               import pulumi
               ```
        :param Sequence[str] excluded_instance_types: List of instance types to exclude. You can use strings with one or more wild cards, represented by an asterisk (\\*), to exclude an instance type, size, or generation. The following are examples: `m5.8xlarge`, `c5*.*`, `m5a.*`, `r*`, `*3*`. For example, if you specify `c5*`, you are excluding the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*`, you are excluding all the M5a instance types, but not the M5n instance types. Maximum of 400 entries in the list; each entry is limited to 30 characters. Default is no excluded instance types.
               
               > **NOTE:** If you specify `excluded_instance_types`, you can't specify `allowed_instance_types`.
        :param Sequence[str] instance_generations: List of instance generation names. Default is any generation.
               
               ```python
               import pulumi
               ```
        :param str local_storage: Indicate whether instance types with local storage volumes are `included`, `excluded`, or `required`. Default is `included`.
        :param Sequence[str] local_storage_types: List of local storage type names. Default any storage type.
               
               ```python
               import pulumi
               ```
        :param 'LaunchTemplateInstanceRequirementsMemoryGibPerVcpuArgs' memory_gib_per_vcpu: Block describing the minimum and maximum amount of memory (GiB) per vCPU. Default is no minimum or maximum.
        :param 'LaunchTemplateInstanceRequirementsNetworkBandwidthGbpsArgs' network_bandwidth_gbps: Block describing the minimum and maximum amount of network bandwidth, in gigabits per second (Gbps). Default is no minimum or maximum.
        :param 'LaunchTemplateInstanceRequirementsNetworkInterfaceCountArgs' network_interface_count: Block describing the minimum and maximum number of network interfaces. Default is no minimum or maximum.
        :param int on_demand_max_price_percentage_over_lowest_price: The price protection threshold for On-Demand Instances. This is the maximum youll pay for an On-Demand Instance, expressed as a percentage higher than the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price is higher than your threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as 999999. Default is 20.
               
               If you set DesiredCapacityType to vcpu or memory-mib, the price protection threshold is applied based on the per vCPU or per memory price instead of the per instance price.
        :param bool require_hibernate_support: Indicate whether instance types must support On-Demand Instance Hibernation, either `true` or `false`. Default is `false`.
        :param int spot_max_price_percentage_over_lowest_price: The price protection threshold for Spot Instances. This is the maximum youll pay for a Spot Instance, expressed as a percentage higher than the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price is higher than your threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as 999999. Default is 100.
               
               If you set DesiredCapacityType to vcpu or memory-mib, the price protection threshold is applied based on the per vCPU or per memory price instead of the per instance price.
        :param 'LaunchTemplateInstanceRequirementsTotalLocalStorageGbArgs' total_local_storage_gb: Block describing the minimum and maximum total local storage (GB). Default is no minimum or maximum.
        """
        LaunchTemplateInstanceRequirements._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            memory_mib=memory_mib,
            vcpu_count=vcpu_count,
            accelerator_count=accelerator_count,
            accelerator_manufacturers=accelerator_manufacturers,
            accelerator_names=accelerator_names,
            accelerator_total_memory_mib=accelerator_total_memory_mib,
            accelerator_types=accelerator_types,
            allowed_instance_types=allowed_instance_types,
            bare_metal=bare_metal,
            baseline_ebs_bandwidth_mbps=baseline_ebs_bandwidth_mbps,
            burstable_performance=burstable_performance,
            cpu_manufacturers=cpu_manufacturers,
            excluded_instance_types=excluded_instance_types,
            instance_generations=instance_generations,
            local_storage=local_storage,
            local_storage_types=local_storage_types,
            memory_gib_per_vcpu=memory_gib_per_vcpu,
            network_bandwidth_gbps=network_bandwidth_gbps,
            network_interface_count=network_interface_count,
            on_demand_max_price_percentage_over_lowest_price=on_demand_max_price_percentage_over_lowest_price,
            require_hibernate_support=require_hibernate_support,
            spot_max_price_percentage_over_lowest_price=spot_max_price_percentage_over_lowest_price,
            total_local_storage_gb=total_local_storage_gb,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             memory_mib: Optional['outputs.LaunchTemplateInstanceRequirementsMemoryMib'] = None,
             vcpu_count: Optional['outputs.LaunchTemplateInstanceRequirementsVcpuCount'] = None,
             accelerator_count: Optional['outputs.LaunchTemplateInstanceRequirementsAcceleratorCount'] = None,
             accelerator_manufacturers: Optional[Sequence[str]] = None,
             accelerator_names: Optional[Sequence[str]] = None,
             accelerator_total_memory_mib: Optional['outputs.LaunchTemplateInstanceRequirementsAcceleratorTotalMemoryMib'] = None,
             accelerator_types: Optional[Sequence[str]] = None,
             allowed_instance_types: Optional[Sequence[str]] = None,
             bare_metal: Optional[str] = None,
             baseline_ebs_bandwidth_mbps: Optional['outputs.LaunchTemplateInstanceRequirementsBaselineEbsBandwidthMbps'] = None,
             burstable_performance: Optional[str] = None,
             cpu_manufacturers: Optional[Sequence[str]] = None,
             excluded_instance_types: Optional[Sequence[str]] = None,
             instance_generations: Optional[Sequence[str]] = None,
             local_storage: Optional[str] = None,
             local_storage_types: Optional[Sequence[str]] = None,
             memory_gib_per_vcpu: Optional['outputs.LaunchTemplateInstanceRequirementsMemoryGibPerVcpu'] = None,
             network_bandwidth_gbps: Optional['outputs.LaunchTemplateInstanceRequirementsNetworkBandwidthGbps'] = None,
             network_interface_count: Optional['outputs.LaunchTemplateInstanceRequirementsNetworkInterfaceCount'] = None,
             on_demand_max_price_percentage_over_lowest_price: Optional[int] = None,
             require_hibernate_support: Optional[bool] = None,
             spot_max_price_percentage_over_lowest_price: Optional[int] = None,
             total_local_storage_gb: Optional['outputs.LaunchTemplateInstanceRequirementsTotalLocalStorageGb'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if memory_mib is None and 'memoryMib' in kwargs:
            memory_mib = kwargs['memoryMib']
        if memory_mib is None:
            raise TypeError("Missing 'memory_mib' argument")
        if vcpu_count is None and 'vcpuCount' in kwargs:
            vcpu_count = kwargs['vcpuCount']
        if vcpu_count is None:
            raise TypeError("Missing 'vcpu_count' argument")
        if accelerator_count is None and 'acceleratorCount' in kwargs:
            accelerator_count = kwargs['acceleratorCount']
        if accelerator_manufacturers is None and 'acceleratorManufacturers' in kwargs:
            accelerator_manufacturers = kwargs['acceleratorManufacturers']
        if accelerator_names is None and 'acceleratorNames' in kwargs:
            accelerator_names = kwargs['acceleratorNames']
        if accelerator_total_memory_mib is None and 'acceleratorTotalMemoryMib' in kwargs:
            accelerator_total_memory_mib = kwargs['acceleratorTotalMemoryMib']
        if accelerator_types is None and 'acceleratorTypes' in kwargs:
            accelerator_types = kwargs['acceleratorTypes']
        if allowed_instance_types is None and 'allowedInstanceTypes' in kwargs:
            allowed_instance_types = kwargs['allowedInstanceTypes']
        if bare_metal is None and 'bareMetal' in kwargs:
            bare_metal = kwargs['bareMetal']
        if baseline_ebs_bandwidth_mbps is None and 'baselineEbsBandwidthMbps' in kwargs:
            baseline_ebs_bandwidth_mbps = kwargs['baselineEbsBandwidthMbps']
        if burstable_performance is None and 'burstablePerformance' in kwargs:
            burstable_performance = kwargs['burstablePerformance']
        if cpu_manufacturers is None and 'cpuManufacturers' in kwargs:
            cpu_manufacturers = kwargs['cpuManufacturers']
        if excluded_instance_types is None and 'excludedInstanceTypes' in kwargs:
            excluded_instance_types = kwargs['excludedInstanceTypes']
        if instance_generations is None and 'instanceGenerations' in kwargs:
            instance_generations = kwargs['instanceGenerations']
        if local_storage is None and 'localStorage' in kwargs:
            local_storage = kwargs['localStorage']
        if local_storage_types is None and 'localStorageTypes' in kwargs:
            local_storage_types = kwargs['localStorageTypes']
        if memory_gib_per_vcpu is None and 'memoryGibPerVcpu' in kwargs:
            memory_gib_per_vcpu = kwargs['memoryGibPerVcpu']
        if network_bandwidth_gbps is None and 'networkBandwidthGbps' in kwargs:
            network_bandwidth_gbps = kwargs['networkBandwidthGbps']
        if network_interface_count is None and 'networkInterfaceCount' in kwargs:
            network_interface_count = kwargs['networkInterfaceCount']
        if on_demand_max_price_percentage_over_lowest_price is None and 'onDemandMaxPricePercentageOverLowestPrice' in kwargs:
            on_demand_max_price_percentage_over_lowest_price = kwargs['onDemandMaxPricePercentageOverLowestPrice']
        if require_hibernate_support is None and 'requireHibernateSupport' in kwargs:
            require_hibernate_support = kwargs['requireHibernateSupport']
        if spot_max_price_percentage_over_lowest_price is None and 'spotMaxPricePercentageOverLowestPrice' in kwargs:
            spot_max_price_percentage_over_lowest_price = kwargs['spotMaxPricePercentageOverLowestPrice']
        if total_local_storage_gb is None and 'totalLocalStorageGb' in kwargs:
            total_local_storage_gb = kwargs['totalLocalStorageGb']

        _setter("memory_mib", memory_mib)
        _setter("vcpu_count", vcpu_count)
        if accelerator_count is not None:
            _setter("accelerator_count", accelerator_count)
        if accelerator_manufacturers is not None:
            _setter("accelerator_manufacturers", accelerator_manufacturers)
        if accelerator_names is not None:
            _setter("accelerator_names", accelerator_names)
        if accelerator_total_memory_mib is not None:
            _setter("accelerator_total_memory_mib", accelerator_total_memory_mib)
        if accelerator_types is not None:
            _setter("accelerator_types", accelerator_types)
        if allowed_instance_types is not None:
            _setter("allowed_instance_types", allowed_instance_types)
        if bare_metal is not None:
            _setter("bare_metal", bare_metal)
        if baseline_ebs_bandwidth_mbps is not None:
            _setter("baseline_ebs_bandwidth_mbps", baseline_ebs_bandwidth_mbps)
        if burstable_performance is not None:
            _setter("burstable_performance", burstable_performance)
        if cpu_manufacturers is not None:
            _setter("cpu_manufacturers", cpu_manufacturers)
        if excluded_instance_types is not None:
            _setter("excluded_instance_types", excluded_instance_types)
        if instance_generations is not None:
            _setter("instance_generations", instance_generations)
        if local_storage is not None:
            _setter("local_storage", local_storage)
        if local_storage_types is not None:
            _setter("local_storage_types", local_storage_types)
        if memory_gib_per_vcpu is not None:
            _setter("memory_gib_per_vcpu", memory_gib_per_vcpu)
        if network_bandwidth_gbps is not None:
            _setter("network_bandwidth_gbps", network_bandwidth_gbps)
        if network_interface_count is not None:
            _setter("network_interface_count", network_interface_count)
        if on_demand_max_price_percentage_over_lowest_price is not None:
            _setter("on_demand_max_price_percentage_over_lowest_price", on_demand_max_price_percentage_over_lowest_price)
        if require_hibernate_support is not None:
            _setter("require_hibernate_support", require_hibernate_support)
        if spot_max_price_percentage_over_lowest_price is not None:
            _setter("spot_max_price_percentage_over_lowest_price", spot_max_price_percentage_over_lowest_price)
        if total_local_storage_gb is not None:
            _setter("total_local_storage_gb", total_local_storage_gb)

    @property
    @pulumi.getter(name="memoryMib")
    def memory_mib(self) -> 'outputs.LaunchTemplateInstanceRequirementsMemoryMib':
        """
        Block describing the minimum and maximum amount of memory (MiB). Default is no maximum.
        """
        return pulumi.get(self, "memory_mib")

    @property
    @pulumi.getter(name="vcpuCount")
    def vcpu_count(self) -> 'outputs.LaunchTemplateInstanceRequirementsVcpuCount':
        """
        Block describing the minimum and maximum number of vCPUs. Default is no maximum.
        """
        return pulumi.get(self, "vcpu_count")

    @property
    @pulumi.getter(name="acceleratorCount")
    def accelerator_count(self) -> Optional['outputs.LaunchTemplateInstanceRequirementsAcceleratorCount']:
        """
        Block describing the minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips). Default is no minimum or maximum.
        """
        return pulumi.get(self, "accelerator_count")

    @property
    @pulumi.getter(name="acceleratorManufacturers")
    def accelerator_manufacturers(self) -> Optional[Sequence[str]]:
        """
        List of accelerator manufacturer names. Default is any manufacturer.

        ```python
        import pulumi
        ```
        """
        return pulumi.get(self, "accelerator_manufacturers")

    @property
    @pulumi.getter(name="acceleratorNames")
    def accelerator_names(self) -> Optional[Sequence[str]]:
        """
        List of accelerator names. Default is any acclerator.

        ```python
        import pulumi
        ```
        """
        return pulumi.get(self, "accelerator_names")

    @property
    @pulumi.getter(name="acceleratorTotalMemoryMib")
    def accelerator_total_memory_mib(self) -> Optional['outputs.LaunchTemplateInstanceRequirementsAcceleratorTotalMemoryMib']:
        """
        Block describing the minimum and maximum total memory of the accelerators. Default is no minimum or maximum.
        """
        return pulumi.get(self, "accelerator_total_memory_mib")

    @property
    @pulumi.getter(name="acceleratorTypes")
    def accelerator_types(self) -> Optional[Sequence[str]]:
        """
        List of accelerator types. Default is any accelerator type.

        ```python
        import pulumi
        ```
        """
        return pulumi.get(self, "accelerator_types")

    @property
    @pulumi.getter(name="allowedInstanceTypes")
    def allowed_instance_types(self) -> Optional[Sequence[str]]:
        """
        List of instance types to apply your specified attributes against. All other instance types are ignored, even if they match your specified attributes. You can use strings with one or more wild cards, represented by an asterisk (\\*), to allow an instance type, size, or generation. The following are examples: `m5.8xlarge`, `c5*.*`, `m5a.*`, `r*`, `*3*`. For example, if you specify `c5*`, you are allowing the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*`, you are allowing all the M5a instance types, but not the M5n instance types. Maximum of 400 entries in the list; each entry is limited to 30 characters. Default is all instance types.

        > **NOTE:** If you specify `allowed_instance_types`, you can't specify `excluded_instance_types`.
        """
        return pulumi.get(self, "allowed_instance_types")

    @property
    @pulumi.getter(name="bareMetal")
    def bare_metal(self) -> Optional[str]:
        """
        Indicate whether bare metal instace types should be `included`, `excluded`, or `required`. Default is `excluded`.
        """
        return pulumi.get(self, "bare_metal")

    @property
    @pulumi.getter(name="baselineEbsBandwidthMbps")
    def baseline_ebs_bandwidth_mbps(self) -> Optional['outputs.LaunchTemplateInstanceRequirementsBaselineEbsBandwidthMbps']:
        """
        Block describing the minimum and maximum baseline EBS bandwidth, in Mbps. Default is no minimum or maximum.
        """
        return pulumi.get(self, "baseline_ebs_bandwidth_mbps")

    @property
    @pulumi.getter(name="burstablePerformance")
    def burstable_performance(self) -> Optional[str]:
        """
        Indicate whether burstable performance instance types should be `included`, `excluded`, or `required`. Default is `excluded`.
        """
        return pulumi.get(self, "burstable_performance")

    @property
    @pulumi.getter(name="cpuManufacturers")
    def cpu_manufacturers(self) -> Optional[Sequence[str]]:
        """
        List of CPU manufacturer names. Default is any manufacturer.

        > **NOTE:** Don't confuse the CPU hardware manufacturer with the CPU hardware architecture. Instances will be launched with a compatible CPU architecture based on the Amazon Machine Image (AMI) that you specify in your launch template.

        ```python
        import pulumi
        ```
        """
        return pulumi.get(self, "cpu_manufacturers")

    @property
    @pulumi.getter(name="excludedInstanceTypes")
    def excluded_instance_types(self) -> Optional[Sequence[str]]:
        """
        List of instance types to exclude. You can use strings with one or more wild cards, represented by an asterisk (\\*), to exclude an instance type, size, or generation. The following are examples: `m5.8xlarge`, `c5*.*`, `m5a.*`, `r*`, `*3*`. For example, if you specify `c5*`, you are excluding the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*`, you are excluding all the M5a instance types, but not the M5n instance types. Maximum of 400 entries in the list; each entry is limited to 30 characters. Default is no excluded instance types.

        > **NOTE:** If you specify `excluded_instance_types`, you can't specify `allowed_instance_types`.
        """
        return pulumi.get(self, "excluded_instance_types")

    @property
    @pulumi.getter(name="instanceGenerations")
    def instance_generations(self) -> Optional[Sequence[str]]:
        """
        List of instance generation names. Default is any generation.

        ```python
        import pulumi
        ```
        """
        return pulumi.get(self, "instance_generations")

    @property
    @pulumi.getter(name="localStorage")
    def local_storage(self) -> Optional[str]:
        """
        Indicate whether instance types with local storage volumes are `included`, `excluded`, or `required`. Default is `included`.
        """
        return pulumi.get(self, "local_storage")

    @property
    @pulumi.getter(name="localStorageTypes")
    def local_storage_types(self) -> Optional[Sequence[str]]:
        """
        List of local storage type names. Default any storage type.

        ```python
        import pulumi
        ```
        """
        return pulumi.get(self, "local_storage_types")

    @property
    @pulumi.getter(name="memoryGibPerVcpu")
    def memory_gib_per_vcpu(self) -> Optional['outputs.LaunchTemplateInstanceRequirementsMemoryGibPerVcpu']:
        """
        Block describing the minimum and maximum amount of memory (GiB) per vCPU. Default is no minimum or maximum.
        """
        return pulumi.get(self, "memory_gib_per_vcpu")

    @property
    @pulumi.getter(name="networkBandwidthGbps")
    def network_bandwidth_gbps(self) -> Optional['outputs.LaunchTemplateInstanceRequirementsNetworkBandwidthGbps']:
        """
        Block describing the minimum and maximum amount of network bandwidth, in gigabits per second (Gbps). Default is no minimum or maximum.
        """
        return pulumi.get(self, "network_bandwidth_gbps")

    @property
    @pulumi.getter(name="networkInterfaceCount")
    def network_interface_count(self) -> Optional['outputs.LaunchTemplateInstanceRequirementsNetworkInterfaceCount']:
        """
        Block describing the minimum and maximum number of network interfaces. Default is no minimum or maximum.
        """
        return pulumi.get(self, "network_interface_count")

    @property
    @pulumi.getter(name="onDemandMaxPricePercentageOverLowestPrice")
    def on_demand_max_price_percentage_over_lowest_price(self) -> Optional[int]:
        """
        The price protection threshold for On-Demand Instances. This is the maximum youll pay for an On-Demand Instance, expressed as a percentage higher than the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price is higher than your threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as 999999. Default is 20.

        If you set DesiredCapacityType to vcpu or memory-mib, the price protection threshold is applied based on the per vCPU or per memory price instead of the per instance price.
        """
        return pulumi.get(self, "on_demand_max_price_percentage_over_lowest_price")

    @property
    @pulumi.getter(name="requireHibernateSupport")
    def require_hibernate_support(self) -> Optional[bool]:
        """
        Indicate whether instance types must support On-Demand Instance Hibernation, either `true` or `false`. Default is `false`.
        """
        return pulumi.get(self, "require_hibernate_support")

    @property
    @pulumi.getter(name="spotMaxPricePercentageOverLowestPrice")
    def spot_max_price_percentage_over_lowest_price(self) -> Optional[int]:
        """
        The price protection threshold for Spot Instances. This is the maximum youll pay for a Spot Instance, expressed as a percentage higher than the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price is higher than your threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as 999999. Default is 100.

        If you set DesiredCapacityType to vcpu or memory-mib, the price protection threshold is applied based on the per vCPU or per memory price instead of the per instance price.
        """
        return pulumi.get(self, "spot_max_price_percentage_over_lowest_price")

    @property
    @pulumi.getter(name="totalLocalStorageGb")
    def total_local_storage_gb(self) -> Optional['outputs.LaunchTemplateInstanceRequirementsTotalLocalStorageGb']:
        """
        Block describing the minimum and maximum total local storage (GB). Default is no minimum or maximum.
        """
        return pulumi.get(self, "total_local_storage_gb")


@pulumi.output_type
class LaunchTemplateInstanceRequirementsAcceleratorCount(dict):
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        """
        :param int max: Maximum.
        :param int min: Minimum.
        """
        LaunchTemplateInstanceRequirementsAcceleratorCount._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            min=min,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: Optional[int] = None,
             min: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if max is not None:
            _setter("max", max)
        if min is not None:
            _setter("min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        """
        Maximum.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        """
        Minimum.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class LaunchTemplateInstanceRequirementsAcceleratorTotalMemoryMib(dict):
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        """
        :param int max: Maximum.
        :param int min: Minimum.
        """
        LaunchTemplateInstanceRequirementsAcceleratorTotalMemoryMib._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            min=min,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: Optional[int] = None,
             min: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if max is not None:
            _setter("max", max)
        if min is not None:
            _setter("min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        """
        Maximum.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        """
        Minimum.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class LaunchTemplateInstanceRequirementsBaselineEbsBandwidthMbps(dict):
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        """
        :param int max: Maximum.
        :param int min: Minimum.
        """
        LaunchTemplateInstanceRequirementsBaselineEbsBandwidthMbps._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            min=min,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: Optional[int] = None,
             min: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if max is not None:
            _setter("max", max)
        if min is not None:
            _setter("min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        """
        Maximum.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        """
        Minimum.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class LaunchTemplateInstanceRequirementsMemoryGibPerVcpu(dict):
    def __init__(__self__, *,
                 max: Optional[float] = None,
                 min: Optional[float] = None):
        """
        :param float max: Maximum.
        :param float min: Minimum.
        """
        LaunchTemplateInstanceRequirementsMemoryGibPerVcpu._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            min=min,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: Optional[float] = None,
             min: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if max is not None:
            _setter("max", max)
        if min is not None:
            _setter("min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[float]:
        """
        Maximum.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[float]:
        """
        Minimum.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class LaunchTemplateInstanceRequirementsMemoryMib(dict):
    def __init__(__self__, *,
                 min: int,
                 max: Optional[int] = None):
        """
        :param int min: Minimum.
        :param int max: Maximum.
        """
        LaunchTemplateInstanceRequirementsMemoryMib._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            min=min,
            max=max,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             min: Optional[int] = None,
             max: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if min is None:
            raise TypeError("Missing 'min' argument")

        _setter("min", min)
        if max is not None:
            _setter("max", max)

    @property
    @pulumi.getter
    def min(self) -> int:
        """
        Minimum.
        """
        return pulumi.get(self, "min")

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        """
        Maximum.
        """
        return pulumi.get(self, "max")


@pulumi.output_type
class LaunchTemplateInstanceRequirementsNetworkBandwidthGbps(dict):
    def __init__(__self__, *,
                 max: Optional[float] = None,
                 min: Optional[float] = None):
        """
        :param float max: Maximum.
        :param float min: Minimum.
        """
        LaunchTemplateInstanceRequirementsNetworkBandwidthGbps._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            min=min,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: Optional[float] = None,
             min: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if max is not None:
            _setter("max", max)
        if min is not None:
            _setter("min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[float]:
        """
        Maximum.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[float]:
        """
        Minimum.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class LaunchTemplateInstanceRequirementsNetworkInterfaceCount(dict):
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        """
        :param int max: Maximum.
        :param int min: Minimum.
        """
        LaunchTemplateInstanceRequirementsNetworkInterfaceCount._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            min=min,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: Optional[int] = None,
             min: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if max is not None:
            _setter("max", max)
        if min is not None:
            _setter("min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        """
        Maximum.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        """
        Minimum.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class LaunchTemplateInstanceRequirementsTotalLocalStorageGb(dict):
    def __init__(__self__, *,
                 max: Optional[float] = None,
                 min: Optional[float] = None):
        """
        :param float max: Maximum.
        :param float min: Minimum.
        """
        LaunchTemplateInstanceRequirementsTotalLocalStorageGb._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            min=min,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: Optional[float] = None,
             min: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if max is not None:
            _setter("max", max)
        if min is not None:
            _setter("min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[float]:
        """
        Maximum.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[float]:
        """
        Minimum.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class LaunchTemplateInstanceRequirementsVcpuCount(dict):
    def __init__(__self__, *,
                 min: int,
                 max: Optional[int] = None):
        """
        :param int min: Minimum.
        :param int max: Maximum.
        """
        LaunchTemplateInstanceRequirementsVcpuCount._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            min=min,
            max=max,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             min: Optional[int] = None,
             max: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if min is None:
            raise TypeError("Missing 'min' argument")

        _setter("min", min)
        if max is not None:
            _setter("max", max)

    @property
    @pulumi.getter
    def min(self) -> int:
        """
        Minimum.
        """
        return pulumi.get(self, "min")

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        """
        Maximum.
        """
        return pulumi.get(self, "max")


@pulumi.output_type
class LaunchTemplateLicenseSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "licenseConfigurationArn":
            suggest = "license_configuration_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateLicenseSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateLicenseSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateLicenseSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 license_configuration_arn: str):
        """
        :param str license_configuration_arn: ARN of the license configuration.
        """
        LaunchTemplateLicenseSpecification._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            license_configuration_arn=license_configuration_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             license_configuration_arn: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if license_configuration_arn is None and 'licenseConfigurationArn' in kwargs:
            license_configuration_arn = kwargs['licenseConfigurationArn']
        if license_configuration_arn is None:
            raise TypeError("Missing 'license_configuration_arn' argument")

        _setter("license_configuration_arn", license_configuration_arn)

    @property
    @pulumi.getter(name="licenseConfigurationArn")
    def license_configuration_arn(self) -> str:
        """
        ARN of the license configuration.
        """
        return pulumi.get(self, "license_configuration_arn")


@pulumi.output_type
class LaunchTemplateMaintenanceOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoRecovery":
            suggest = "auto_recovery"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateMaintenanceOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateMaintenanceOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateMaintenanceOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_recovery: Optional[str] = None):
        """
        :param str auto_recovery: Disables the automatic recovery behavior of your instance or sets it to default. Can be `"default"` or `"disabled"`. See [Recover your instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-recover.html) for more details.
        """
        LaunchTemplateMaintenanceOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auto_recovery=auto_recovery,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auto_recovery: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if auto_recovery is None and 'autoRecovery' in kwargs:
            auto_recovery = kwargs['autoRecovery']

        if auto_recovery is not None:
            _setter("auto_recovery", auto_recovery)

    @property
    @pulumi.getter(name="autoRecovery")
    def auto_recovery(self) -> Optional[str]:
        """
        Disables the automatic recovery behavior of your instance or sets it to default. Can be `"default"` or `"disabled"`. See [Recover your instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-recover.html) for more details.
        """
        return pulumi.get(self, "auto_recovery")


@pulumi.output_type
class LaunchTemplateMetadataOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpEndpoint":
            suggest = "http_endpoint"
        elif key == "httpProtocolIpv6":
            suggest = "http_protocol_ipv6"
        elif key == "httpPutResponseHopLimit":
            suggest = "http_put_response_hop_limit"
        elif key == "httpTokens":
            suggest = "http_tokens"
        elif key == "instanceMetadataTags":
            suggest = "instance_metadata_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateMetadataOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateMetadataOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateMetadataOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_endpoint: Optional[str] = None,
                 http_protocol_ipv6: Optional[str] = None,
                 http_put_response_hop_limit: Optional[int] = None,
                 http_tokens: Optional[str] = None,
                 instance_metadata_tags: Optional[str] = None):
        """
        :param str http_endpoint: Whether the metadata service is available. Can be `"enabled"` or `"disabled"`. (Default: `"enabled"`).
        :param str http_protocol_ipv6: Enables or disables the IPv6 endpoint for the instance metadata service. Can be `"enabled"` or `"disabled"`.
        :param int http_put_response_hop_limit: The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel. Can be an integer from `1` to `64`. (Default: `1`).
        :param str http_tokens: Whether or not the metadata service requires session tokens, also referred to as _Instance Metadata Service Version 2 (IMDSv2)_. Can be `"optional"` or `"required"`. (Default: `"optional"`).
        :param str instance_metadata_tags: Enables or disables access to instance tags from the instance metadata service. Can be `"enabled"` or `"disabled"`.
               
               For more information, see the documentation on the [Instance Metadata Service](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html).
        """
        LaunchTemplateMetadataOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            http_endpoint=http_endpoint,
            http_protocol_ipv6=http_protocol_ipv6,
            http_put_response_hop_limit=http_put_response_hop_limit,
            http_tokens=http_tokens,
            instance_metadata_tags=instance_metadata_tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             http_endpoint: Optional[str] = None,
             http_protocol_ipv6: Optional[str] = None,
             http_put_response_hop_limit: Optional[int] = None,
             http_tokens: Optional[str] = None,
             instance_metadata_tags: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if http_endpoint is None and 'httpEndpoint' in kwargs:
            http_endpoint = kwargs['httpEndpoint']
        if http_protocol_ipv6 is None and 'httpProtocolIpv6' in kwargs:
            http_protocol_ipv6 = kwargs['httpProtocolIpv6']
        if http_put_response_hop_limit is None and 'httpPutResponseHopLimit' in kwargs:
            http_put_response_hop_limit = kwargs['httpPutResponseHopLimit']
        if http_tokens is None and 'httpTokens' in kwargs:
            http_tokens = kwargs['httpTokens']
        if instance_metadata_tags is None and 'instanceMetadataTags' in kwargs:
            instance_metadata_tags = kwargs['instanceMetadataTags']

        if http_endpoint is not None:
            _setter("http_endpoint", http_endpoint)
        if http_protocol_ipv6 is not None:
            _setter("http_protocol_ipv6", http_protocol_ipv6)
        if http_put_response_hop_limit is not None:
            _setter("http_put_response_hop_limit", http_put_response_hop_limit)
        if http_tokens is not None:
            _setter("http_tokens", http_tokens)
        if instance_metadata_tags is not None:
            _setter("instance_metadata_tags", instance_metadata_tags)

    @property
    @pulumi.getter(name="httpEndpoint")
    def http_endpoint(self) -> Optional[str]:
        """
        Whether the metadata service is available. Can be `"enabled"` or `"disabled"`. (Default: `"enabled"`).
        """
        return pulumi.get(self, "http_endpoint")

    @property
    @pulumi.getter(name="httpProtocolIpv6")
    def http_protocol_ipv6(self) -> Optional[str]:
        """
        Enables or disables the IPv6 endpoint for the instance metadata service. Can be `"enabled"` or `"disabled"`.
        """
        return pulumi.get(self, "http_protocol_ipv6")

    @property
    @pulumi.getter(name="httpPutResponseHopLimit")
    def http_put_response_hop_limit(self) -> Optional[int]:
        """
        The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel. Can be an integer from `1` to `64`. (Default: `1`).
        """
        return pulumi.get(self, "http_put_response_hop_limit")

    @property
    @pulumi.getter(name="httpTokens")
    def http_tokens(self) -> Optional[str]:
        """
        Whether or not the metadata service requires session tokens, also referred to as _Instance Metadata Service Version 2 (IMDSv2)_. Can be `"optional"` or `"required"`. (Default: `"optional"`).
        """
        return pulumi.get(self, "http_tokens")

    @property
    @pulumi.getter(name="instanceMetadataTags")
    def instance_metadata_tags(self) -> Optional[str]:
        """
        Enables or disables access to instance tags from the instance metadata service. Can be `"enabled"` or `"disabled"`.

        For more information, see the documentation on the [Instance Metadata Service](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html).
        """
        return pulumi.get(self, "instance_metadata_tags")


@pulumi.output_type
class LaunchTemplateMonitoring(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        """
        :param bool enabled: If `true`, the launched EC2 instance will have detailed monitoring enabled.
        """
        LaunchTemplateMonitoring._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if enabled is not None:
            _setter("enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If `true`, the launched EC2 instance will have detailed monitoring enabled.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class LaunchTemplateNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "associateCarrierIpAddress":
            suggest = "associate_carrier_ip_address"
        elif key == "associatePublicIpAddress":
            suggest = "associate_public_ip_address"
        elif key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "deviceIndex":
            suggest = "device_index"
        elif key == "interfaceType":
            suggest = "interface_type"
        elif key == "ipv4AddressCount":
            suggest = "ipv4_address_count"
        elif key == "ipv4Addresses":
            suggest = "ipv4_addresses"
        elif key == "ipv4PrefixCount":
            suggest = "ipv4_prefix_count"
        elif key == "ipv4Prefixes":
            suggest = "ipv4_prefixes"
        elif key == "ipv6AddressCount":
            suggest = "ipv6_address_count"
        elif key == "ipv6Addresses":
            suggest = "ipv6_addresses"
        elif key == "ipv6PrefixCount":
            suggest = "ipv6_prefix_count"
        elif key == "ipv6Prefixes":
            suggest = "ipv6_prefixes"
        elif key == "networkCardIndex":
            suggest = "network_card_index"
        elif key == "networkInterfaceId":
            suggest = "network_interface_id"
        elif key == "privateIpAddress":
            suggest = "private_ip_address"
        elif key == "securityGroups":
            suggest = "security_groups"
        elif key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 associate_carrier_ip_address: Optional[str] = None,
                 associate_public_ip_address: Optional[str] = None,
                 delete_on_termination: Optional[str] = None,
                 description: Optional[str] = None,
                 device_index: Optional[int] = None,
                 interface_type: Optional[str] = None,
                 ipv4_address_count: Optional[int] = None,
                 ipv4_addresses: Optional[Sequence[str]] = None,
                 ipv4_prefix_count: Optional[int] = None,
                 ipv4_prefixes: Optional[Sequence[str]] = None,
                 ipv6_address_count: Optional[int] = None,
                 ipv6_addresses: Optional[Sequence[str]] = None,
                 ipv6_prefix_count: Optional[int] = None,
                 ipv6_prefixes: Optional[Sequence[str]] = None,
                 network_card_index: Optional[int] = None,
                 network_interface_id: Optional[str] = None,
                 private_ip_address: Optional[str] = None,
                 security_groups: Optional[Sequence[str]] = None,
                 subnet_id: Optional[str] = None):
        """
        :param str associate_carrier_ip_address: Associate a Carrier IP address with `eth0` for a new network interface.
               Use this option when you launch an instance in a Wavelength Zone and want to associate a Carrier IP address with the network interface.
               Boolean value, can be left unset.
        :param str associate_public_ip_address: Associate a public ip address with the network interface.
               Boolean value, can be left unset.
        :param str delete_on_termination: Whether the network interface should be destroyed on instance termination.
        :param str description: Description of the network interface.
        :param int device_index: The integer index of the network interface attachment.
        :param str interface_type: The type of network interface. To create an Elastic Fabric Adapter (EFA), specify `efa`.
        :param int ipv4_address_count: The number of secondary private IPv4 addresses to assign to a network interface. Conflicts with `ipv4_addresses`
        :param Sequence[str] ipv4_addresses: One or more private IPv4 addresses to associate. Conflicts with `ipv4_address_count`
        :param int ipv4_prefix_count: The number of IPv4 prefixes to be automatically assigned to the network interface. Conflicts with `ipv4_prefixes`
        :param Sequence[str] ipv4_prefixes: One or more IPv4 prefixes to be assigned to the network interface. Conflicts with `ipv4_prefix_count`
        :param int ipv6_address_count: The number of IPv6 addresses to assign to a network interface. Conflicts with `ipv6_addresses`
        :param Sequence[str] ipv6_addresses: One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet. Conflicts with `ipv6_address_count`
        :param int ipv6_prefix_count: The number of IPv6 prefixes to be automatically assigned to the network interface. Conflicts with `ipv6_prefixes`
        :param Sequence[str] ipv6_prefixes: One or more IPv6 prefixes to be assigned to the network interface. Conflicts with `ipv6_prefix_count`
        :param int network_card_index: The index of the network card. Some instance types support multiple network cards. The primary network interface must be assigned to network card index 0. The default is network card index 0.
        :param str network_interface_id: The ID of the network interface to attach.
        :param str private_ip_address: The primary private IPv4 address.
        :param Sequence[str] security_groups: A list of security group IDs to associate.
        :param str subnet_id: The VPC Subnet ID to associate.
        """
        LaunchTemplateNetworkInterface._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            associate_carrier_ip_address=associate_carrier_ip_address,
            associate_public_ip_address=associate_public_ip_address,
            delete_on_termination=delete_on_termination,
            description=description,
            device_index=device_index,
            interface_type=interface_type,
            ipv4_address_count=ipv4_address_count,
            ipv4_addresses=ipv4_addresses,
            ipv4_prefix_count=ipv4_prefix_count,
            ipv4_prefixes=ipv4_prefixes,
            ipv6_address_count=ipv6_address_count,
            ipv6_addresses=ipv6_addresses,
            ipv6_prefix_count=ipv6_prefix_count,
            ipv6_prefixes=ipv6_prefixes,
            network_card_index=network_card_index,
            network_interface_id=network_interface_id,
            private_ip_address=private_ip_address,
            security_groups=security_groups,
            subnet_id=subnet_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             associate_carrier_ip_address: Optional[str] = None,
             associate_public_ip_address: Optional[str] = None,
             delete_on_termination: Optional[str] = None,
             description: Optional[str] = None,
             device_index: Optional[int] = None,
             interface_type: Optional[str] = None,
             ipv4_address_count: Optional[int] = None,
             ipv4_addresses: Optional[Sequence[str]] = None,
             ipv4_prefix_count: Optional[int] = None,
             ipv4_prefixes: Optional[Sequence[str]] = None,
             ipv6_address_count: Optional[int] = None,
             ipv6_addresses: Optional[Sequence[str]] = None,
             ipv6_prefix_count: Optional[int] = None,
             ipv6_prefixes: Optional[Sequence[str]] = None,
             network_card_index: Optional[int] = None,
             network_interface_id: Optional[str] = None,
             private_ip_address: Optional[str] = None,
             security_groups: Optional[Sequence[str]] = None,
             subnet_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if associate_carrier_ip_address is None and 'associateCarrierIpAddress' in kwargs:
            associate_carrier_ip_address = kwargs['associateCarrierIpAddress']
        if associate_public_ip_address is None and 'associatePublicIpAddress' in kwargs:
            associate_public_ip_address = kwargs['associatePublicIpAddress']
        if delete_on_termination is None and 'deleteOnTermination' in kwargs:
            delete_on_termination = kwargs['deleteOnTermination']
        if device_index is None and 'deviceIndex' in kwargs:
            device_index = kwargs['deviceIndex']
        if interface_type is None and 'interfaceType' in kwargs:
            interface_type = kwargs['interfaceType']
        if ipv4_address_count is None and 'ipv4AddressCount' in kwargs:
            ipv4_address_count = kwargs['ipv4AddressCount']
        if ipv4_addresses is None and 'ipv4Addresses' in kwargs:
            ipv4_addresses = kwargs['ipv4Addresses']
        if ipv4_prefix_count is None and 'ipv4PrefixCount' in kwargs:
            ipv4_prefix_count = kwargs['ipv4PrefixCount']
        if ipv4_prefixes is None and 'ipv4Prefixes' in kwargs:
            ipv4_prefixes = kwargs['ipv4Prefixes']
        if ipv6_address_count is None and 'ipv6AddressCount' in kwargs:
            ipv6_address_count = kwargs['ipv6AddressCount']
        if ipv6_addresses is None and 'ipv6Addresses' in kwargs:
            ipv6_addresses = kwargs['ipv6Addresses']
        if ipv6_prefix_count is None and 'ipv6PrefixCount' in kwargs:
            ipv6_prefix_count = kwargs['ipv6PrefixCount']
        if ipv6_prefixes is None and 'ipv6Prefixes' in kwargs:
            ipv6_prefixes = kwargs['ipv6Prefixes']
        if network_card_index is None and 'networkCardIndex' in kwargs:
            network_card_index = kwargs['networkCardIndex']
        if network_interface_id is None and 'networkInterfaceId' in kwargs:
            network_interface_id = kwargs['networkInterfaceId']
        if private_ip_address is None and 'privateIpAddress' in kwargs:
            private_ip_address = kwargs['privateIpAddress']
        if security_groups is None and 'securityGroups' in kwargs:
            security_groups = kwargs['securityGroups']
        if subnet_id is None and 'subnetId' in kwargs:
            subnet_id = kwargs['subnetId']

        if associate_carrier_ip_address is not None:
            _setter("associate_carrier_ip_address", associate_carrier_ip_address)
        if associate_public_ip_address is not None:
            _setter("associate_public_ip_address", associate_public_ip_address)
        if delete_on_termination is not None:
            _setter("delete_on_termination", delete_on_termination)
        if description is not None:
            _setter("description", description)
        if device_index is not None:
            _setter("device_index", device_index)
        if interface_type is not None:
            _setter("interface_type", interface_type)
        if ipv4_address_count is not None:
            _setter("ipv4_address_count", ipv4_address_count)
        if ipv4_addresses is not None:
            _setter("ipv4_addresses", ipv4_addresses)
        if ipv4_prefix_count is not None:
            _setter("ipv4_prefix_count", ipv4_prefix_count)
        if ipv4_prefixes is not None:
            _setter("ipv4_prefixes", ipv4_prefixes)
        if ipv6_address_count is not None:
            _setter("ipv6_address_count", ipv6_address_count)
        if ipv6_addresses is not None:
            _setter("ipv6_addresses", ipv6_addresses)
        if ipv6_prefix_count is not None:
            _setter("ipv6_prefix_count", ipv6_prefix_count)
        if ipv6_prefixes is not None:
            _setter("ipv6_prefixes", ipv6_prefixes)
        if network_card_index is not None:
            _setter("network_card_index", network_card_index)
        if network_interface_id is not None:
            _setter("network_interface_id", network_interface_id)
        if private_ip_address is not None:
            _setter("private_ip_address", private_ip_address)
        if security_groups is not None:
            _setter("security_groups", security_groups)
        if subnet_id is not None:
            _setter("subnet_id", subnet_id)

    @property
    @pulumi.getter(name="associateCarrierIpAddress")
    def associate_carrier_ip_address(self) -> Optional[str]:
        """
        Associate a Carrier IP address with `eth0` for a new network interface.
        Use this option when you launch an instance in a Wavelength Zone and want to associate a Carrier IP address with the network interface.
        Boolean value, can be left unset.
        """
        return pulumi.get(self, "associate_carrier_ip_address")

    @property
    @pulumi.getter(name="associatePublicIpAddress")
    def associate_public_ip_address(self) -> Optional[str]:
        """
        Associate a public ip address with the network interface.
        Boolean value, can be left unset.
        """
        return pulumi.get(self, "associate_public_ip_address")

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[str]:
        """
        Whether the network interface should be destroyed on instance termination.
        """
        return pulumi.get(self, "delete_on_termination")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of the network interface.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="deviceIndex")
    def device_index(self) -> Optional[int]:
        """
        The integer index of the network interface attachment.
        """
        return pulumi.get(self, "device_index")

    @property
    @pulumi.getter(name="interfaceType")
    def interface_type(self) -> Optional[str]:
        """
        The type of network interface. To create an Elastic Fabric Adapter (EFA), specify `efa`.
        """
        return pulumi.get(self, "interface_type")

    @property
    @pulumi.getter(name="ipv4AddressCount")
    def ipv4_address_count(self) -> Optional[int]:
        """
        The number of secondary private IPv4 addresses to assign to a network interface. Conflicts with `ipv4_addresses`
        """
        return pulumi.get(self, "ipv4_address_count")

    @property
    @pulumi.getter(name="ipv4Addresses")
    def ipv4_addresses(self) -> Optional[Sequence[str]]:
        """
        One or more private IPv4 addresses to associate. Conflicts with `ipv4_address_count`
        """
        return pulumi.get(self, "ipv4_addresses")

    @property
    @pulumi.getter(name="ipv4PrefixCount")
    def ipv4_prefix_count(self) -> Optional[int]:
        """
        The number of IPv4 prefixes to be automatically assigned to the network interface. Conflicts with `ipv4_prefixes`
        """
        return pulumi.get(self, "ipv4_prefix_count")

    @property
    @pulumi.getter(name="ipv4Prefixes")
    def ipv4_prefixes(self) -> Optional[Sequence[str]]:
        """
        One or more IPv4 prefixes to be assigned to the network interface. Conflicts with `ipv4_prefix_count`
        """
        return pulumi.get(self, "ipv4_prefixes")

    @property
    @pulumi.getter(name="ipv6AddressCount")
    def ipv6_address_count(self) -> Optional[int]:
        """
        The number of IPv6 addresses to assign to a network interface. Conflicts with `ipv6_addresses`
        """
        return pulumi.get(self, "ipv6_address_count")

    @property
    @pulumi.getter(name="ipv6Addresses")
    def ipv6_addresses(self) -> Optional[Sequence[str]]:
        """
        One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet. Conflicts with `ipv6_address_count`
        """
        return pulumi.get(self, "ipv6_addresses")

    @property
    @pulumi.getter(name="ipv6PrefixCount")
    def ipv6_prefix_count(self) -> Optional[int]:
        """
        The number of IPv6 prefixes to be automatically assigned to the network interface. Conflicts with `ipv6_prefixes`
        """
        return pulumi.get(self, "ipv6_prefix_count")

    @property
    @pulumi.getter(name="ipv6Prefixes")
    def ipv6_prefixes(self) -> Optional[Sequence[str]]:
        """
        One or more IPv6 prefixes to be assigned to the network interface. Conflicts with `ipv6_prefix_count`
        """
        return pulumi.get(self, "ipv6_prefixes")

    @property
    @pulumi.getter(name="networkCardIndex")
    def network_card_index(self) -> Optional[int]:
        """
        The index of the network card. Some instance types support multiple network cards. The primary network interface must be assigned to network card index 0. The default is network card index 0.
        """
        return pulumi.get(self, "network_card_index")

    @property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> Optional[str]:
        """
        The ID of the network interface to attach.
        """
        return pulumi.get(self, "network_interface_id")

    @property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> Optional[str]:
        """
        The primary private IPv4 address.
        """
        return pulumi.get(self, "private_ip_address")

    @property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[Sequence[str]]:
        """
        A list of security group IDs to associate.
        """
        return pulumi.get(self, "security_groups")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        The VPC Subnet ID to associate.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class LaunchTemplatePlacement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "groupName":
            suggest = "group_name"
        elif key == "hostId":
            suggest = "host_id"
        elif key == "hostResourceGroupArn":
            suggest = "host_resource_group_arn"
        elif key == "partitionNumber":
            suggest = "partition_number"
        elif key == "spreadDomain":
            suggest = "spread_domain"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplatePlacement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplatePlacement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplatePlacement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 affinity: Optional[str] = None,
                 availability_zone: Optional[str] = None,
                 group_name: Optional[str] = None,
                 host_id: Optional[str] = None,
                 host_resource_group_arn: Optional[str] = None,
                 partition_number: Optional[int] = None,
                 spread_domain: Optional[str] = None,
                 tenancy: Optional[str] = None):
        """
        :param str affinity: The affinity setting for an instance on a Dedicated Host.
        :param str availability_zone: The Availability Zone for the instance.
        :param str group_name: The name of the placement group for the instance.
        :param str host_id: The ID of the Dedicated Host for the instance.
        :param str host_resource_group_arn: The ARN of the Host Resource Group in which to launch instances.
        :param int partition_number: The number of the partition the instance should launch in. Valid only if the placement group strategy is set to partition.
        :param str spread_domain: Reserved for future use.
        :param str tenancy: The tenancy of the instance (if the instance is running in a VPC). Can be `default`, `dedicated`, or `host`.
        """
        LaunchTemplatePlacement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            affinity=affinity,
            availability_zone=availability_zone,
            group_name=group_name,
            host_id=host_id,
            host_resource_group_arn=host_resource_group_arn,
            partition_number=partition_number,
            spread_domain=spread_domain,
            tenancy=tenancy,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             affinity: Optional[str] = None,
             availability_zone: Optional[str] = None,
             group_name: Optional[str] = None,
             host_id: Optional[str] = None,
             host_resource_group_arn: Optional[str] = None,
             partition_number: Optional[int] = None,
             spread_domain: Optional[str] = None,
             tenancy: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if availability_zone is None and 'availabilityZone' in kwargs:
            availability_zone = kwargs['availabilityZone']
        if group_name is None and 'groupName' in kwargs:
            group_name = kwargs['groupName']
        if host_id is None and 'hostId' in kwargs:
            host_id = kwargs['hostId']
        if host_resource_group_arn is None and 'hostResourceGroupArn' in kwargs:
            host_resource_group_arn = kwargs['hostResourceGroupArn']
        if partition_number is None and 'partitionNumber' in kwargs:
            partition_number = kwargs['partitionNumber']
        if spread_domain is None and 'spreadDomain' in kwargs:
            spread_domain = kwargs['spreadDomain']

        if affinity is not None:
            _setter("affinity", affinity)
        if availability_zone is not None:
            _setter("availability_zone", availability_zone)
        if group_name is not None:
            _setter("group_name", group_name)
        if host_id is not None:
            _setter("host_id", host_id)
        if host_resource_group_arn is not None:
            _setter("host_resource_group_arn", host_resource_group_arn)
        if partition_number is not None:
            _setter("partition_number", partition_number)
        if spread_domain is not None:
            _setter("spread_domain", spread_domain)
        if tenancy is not None:
            _setter("tenancy", tenancy)

    @property
    @pulumi.getter
    def affinity(self) -> Optional[str]:
        """
        The affinity setting for an instance on a Dedicated Host.
        """
        return pulumi.get(self, "affinity")

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[str]:
        """
        The Availability Zone for the instance.
        """
        return pulumi.get(self, "availability_zone")

    @property
    @pulumi.getter(name="groupName")
    def group_name(self) -> Optional[str]:
        """
        The name of the placement group for the instance.
        """
        return pulumi.get(self, "group_name")

    @property
    @pulumi.getter(name="hostId")
    def host_id(self) -> Optional[str]:
        """
        The ID of the Dedicated Host for the instance.
        """
        return pulumi.get(self, "host_id")

    @property
    @pulumi.getter(name="hostResourceGroupArn")
    def host_resource_group_arn(self) -> Optional[str]:
        """
        The ARN of the Host Resource Group in which to launch instances.
        """
        return pulumi.get(self, "host_resource_group_arn")

    @property
    @pulumi.getter(name="partitionNumber")
    def partition_number(self) -> Optional[int]:
        """
        The number of the partition the instance should launch in. Valid only if the placement group strategy is set to partition.
        """
        return pulumi.get(self, "partition_number")

    @property
    @pulumi.getter(name="spreadDomain")
    def spread_domain(self) -> Optional[str]:
        """
        Reserved for future use.
        """
        return pulumi.get(self, "spread_domain")

    @property
    @pulumi.getter
    def tenancy(self) -> Optional[str]:
        """
        The tenancy of the instance (if the instance is running in a VPC). Can be `default`, `dedicated`, or `host`.
        """
        return pulumi.get(self, "tenancy")


@pulumi.output_type
class LaunchTemplatePrivateDnsNameOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableResourceNameDnsARecord":
            suggest = "enable_resource_name_dns_a_record"
        elif key == "enableResourceNameDnsAaaaRecord":
            suggest = "enable_resource_name_dns_aaaa_record"
        elif key == "hostnameType":
            suggest = "hostname_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplatePrivateDnsNameOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplatePrivateDnsNameOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplatePrivateDnsNameOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_resource_name_dns_a_record: Optional[bool] = None,
                 enable_resource_name_dns_aaaa_record: Optional[bool] = None,
                 hostname_type: Optional[str] = None):
        """
        :param bool enable_resource_name_dns_a_record: Indicates whether to respond to DNS queries for instance hostnames with DNS A records.
        :param bool enable_resource_name_dns_aaaa_record: Indicates whether to respond to DNS queries for instance hostnames with DNS AAAA records.
        :param str hostname_type: The type of hostname for Amazon EC2 instances. For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 native subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID. Valid values: `ip-name` and `resource-name`.
        """
        LaunchTemplatePrivateDnsNameOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enable_resource_name_dns_a_record=enable_resource_name_dns_a_record,
            enable_resource_name_dns_aaaa_record=enable_resource_name_dns_aaaa_record,
            hostname_type=hostname_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enable_resource_name_dns_a_record: Optional[bool] = None,
             enable_resource_name_dns_aaaa_record: Optional[bool] = None,
             hostname_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if enable_resource_name_dns_a_record is None and 'enableResourceNameDnsARecord' in kwargs:
            enable_resource_name_dns_a_record = kwargs['enableResourceNameDnsARecord']
        if enable_resource_name_dns_aaaa_record is None and 'enableResourceNameDnsAaaaRecord' in kwargs:
            enable_resource_name_dns_aaaa_record = kwargs['enableResourceNameDnsAaaaRecord']
        if hostname_type is None and 'hostnameType' in kwargs:
            hostname_type = kwargs['hostnameType']

        if enable_resource_name_dns_a_record is not None:
            _setter("enable_resource_name_dns_a_record", enable_resource_name_dns_a_record)
        if enable_resource_name_dns_aaaa_record is not None:
            _setter("enable_resource_name_dns_aaaa_record", enable_resource_name_dns_aaaa_record)
        if hostname_type is not None:
            _setter("hostname_type", hostname_type)

    @property
    @pulumi.getter(name="enableResourceNameDnsARecord")
    def enable_resource_name_dns_a_record(self) -> Optional[bool]:
        """
        Indicates whether to respond to DNS queries for instance hostnames with DNS A records.
        """
        return pulumi.get(self, "enable_resource_name_dns_a_record")

    @property
    @pulumi.getter(name="enableResourceNameDnsAaaaRecord")
    def enable_resource_name_dns_aaaa_record(self) -> Optional[bool]:
        """
        Indicates whether to respond to DNS queries for instance hostnames with DNS AAAA records.
        """
        return pulumi.get(self, "enable_resource_name_dns_aaaa_record")

    @property
    @pulumi.getter(name="hostnameType")
    def hostname_type(self) -> Optional[str]:
        """
        The type of hostname for Amazon EC2 instances. For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 native subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID. Valid values: `ip-name` and `resource-name`.
        """
        return pulumi.get(self, "hostname_type")


@pulumi.output_type
class LaunchTemplateTagSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceType":
            suggest = "resource_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateTagSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateTagSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateTagSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_type: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str resource_type: The type of resource to tag.
        :param Mapping[str, str] tags: A map of tags to assign to the resource.
        """
        LaunchTemplateTagSpecification._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            resource_type=resource_type,
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             resource_type: Optional[str] = None,
             tags: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if resource_type is None and 'resourceType' in kwargs:
            resource_type = kwargs['resourceType']

        if resource_type is not None:
            _setter("resource_type", resource_type)
        if tags is not None:
            _setter("tags", tags)

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[str]:
        """
        The type of resource to tag.
        """
        return pulumi.get(self, "resource_type")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        A map of tags to assign to the resource.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ManagedPrefixListEntry(dict):
    def __init__(__self__, *,
                 cidr: str,
                 description: Optional[str] = None):
        """
        :param str cidr: CIDR block of this entry.
        :param str description: Description of this entry. Due to API limitations, updating only the description of an existing entry requires temporarily removing and re-adding the entry.
        """
        ManagedPrefixListEntry._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cidr=cidr,
            description=description,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cidr: Optional[str] = None,
             description: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cidr is None:
            raise TypeError("Missing 'cidr' argument")

        _setter("cidr", cidr)
        if description is not None:
            _setter("description", description)

    @property
    @pulumi.getter
    def cidr(self) -> str:
        """
        CIDR block of this entry.
        """
        return pulumi.get(self, "cidr")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of this entry. Due to API limitations, updating only the description of an existing entry requires temporarily removing and re-adding the entry.
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class NetworkAclEgress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromPort":
            suggest = "from_port"
        elif key == "ruleNo":
            suggest = "rule_no"
        elif key == "toPort":
            suggest = "to_port"
        elif key == "cidrBlock":
            suggest = "cidr_block"
        elif key == "icmpCode":
            suggest = "icmp_code"
        elif key == "icmpType":
            suggest = "icmp_type"
        elif key == "ipv6CidrBlock":
            suggest = "ipv6_cidr_block"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkAclEgress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkAclEgress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkAclEgress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: str,
                 from_port: int,
                 protocol: str,
                 rule_no: int,
                 to_port: int,
                 cidr_block: Optional[str] = None,
                 icmp_code: Optional[int] = None,
                 icmp_type: Optional[int] = None,
                 ipv6_cidr_block: Optional[str] = None):
        """
        :param str action: The action to take.
        :param int from_port: The from port to match.
        :param str protocol: The protocol to match. If using the -1 'all'
               protocol, you must specify a from and to port of 0.
        :param int rule_no: The rule number. Used for ordering.
        :param int to_port: The to port to match.
        :param str cidr_block: The CIDR block to match. This must be a
               valid network mask.
        :param int icmp_code: The ICMP type code to be used. Default 0.
               
               > Note: For more information on ICMP types and codes, see here: https://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml
        :param int icmp_type: The ICMP type to be used. Default 0.
        :param str ipv6_cidr_block: The IPv6 CIDR block.
        """
        NetworkAclEgress._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            from_port=from_port,
            protocol=protocol,
            rule_no=rule_no,
            to_port=to_port,
            cidr_block=cidr_block,
            icmp_code=icmp_code,
            icmp_type=icmp_type,
            ipv6_cidr_block=ipv6_cidr_block,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: Optional[str] = None,
             from_port: Optional[int] = None,
             protocol: Optional[str] = None,
             rule_no: Optional[int] = None,
             to_port: Optional[int] = None,
             cidr_block: Optional[str] = None,
             icmp_code: Optional[int] = None,
             icmp_type: Optional[int] = None,
             ipv6_cidr_block: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if action is None:
            raise TypeError("Missing 'action' argument")
        if from_port is None and 'fromPort' in kwargs:
            from_port = kwargs['fromPort']
        if from_port is None:
            raise TypeError("Missing 'from_port' argument")
        if protocol is None:
            raise TypeError("Missing 'protocol' argument")
        if rule_no is None and 'ruleNo' in kwargs:
            rule_no = kwargs['ruleNo']
        if rule_no is None:
            raise TypeError("Missing 'rule_no' argument")
        if to_port is None and 'toPort' in kwargs:
            to_port = kwargs['toPort']
        if to_port is None:
            raise TypeError("Missing 'to_port' argument")
        if cidr_block is None and 'cidrBlock' in kwargs:
            cidr_block = kwargs['cidrBlock']
        if icmp_code is None and 'icmpCode' in kwargs:
            icmp_code = kwargs['icmpCode']
        if icmp_type is None and 'icmpType' in kwargs:
            icmp_type = kwargs['icmpType']
        if ipv6_cidr_block is None and 'ipv6CidrBlock' in kwargs:
            ipv6_cidr_block = kwargs['ipv6CidrBlock']

        _setter("action", action)
        _setter("from_port", from_port)
        _setter("protocol", protocol)
        _setter("rule_no", rule_no)
        _setter("to_port", to_port)
        if cidr_block is not None:
            _setter("cidr_block", cidr_block)
        if icmp_code is not None:
            _setter("icmp_code", icmp_code)
        if icmp_type is not None:
            _setter("icmp_type", icmp_type)
        if ipv6_cidr_block is not None:
            _setter("ipv6_cidr_block", ipv6_cidr_block)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        The action to take.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> int:
        """
        The from port to match.
        """
        return pulumi.get(self, "from_port")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        The protocol to match. If using the -1 'all'
        protocol, you must specify a from and to port of 0.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="ruleNo")
    def rule_no(self) -> int:
        """
        The rule number. Used for ordering.
        """
        return pulumi.get(self, "rule_no")

    @property
    @pulumi.getter(name="toPort")
    def to_port(self) -> int:
        """
        The to port to match.
        """
        return pulumi.get(self, "to_port")

    @property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> Optional[str]:
        """
        The CIDR block to match. This must be a
        valid network mask.
        """
        return pulumi.get(self, "cidr_block")

    @property
    @pulumi.getter(name="icmpCode")
    def icmp_code(self) -> Optional[int]:
        """
        The ICMP type code to be used. Default 0.

        > Note: For more information on ICMP types and codes, see here: https://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml
        """
        return pulumi.get(self, "icmp_code")

    @property
    @pulumi.getter(name="icmpType")
    def icmp_type(self) -> Optional[int]:
        """
        The ICMP type to be used. Default 0.
        """
        return pulumi.get(self, "icmp_type")

    @property
    @pulumi.getter(name="ipv6CidrBlock")
    def ipv6_cidr_block(self) -> Optional[str]:
        """
        The IPv6 CIDR block.
        """
        return pulumi.get(self, "ipv6_cidr_block")


@pulumi.output_type
class NetworkAclIngress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromPort":
            suggest = "from_port"
        elif key == "ruleNo":
            suggest = "rule_no"
        elif key == "toPort":
            suggest = "to_port"
        elif key == "cidrBlock":
            suggest = "cidr_block"
        elif key == "icmpCode":
            suggest = "icmp_code"
        elif key == "icmpType":
            suggest = "icmp_type"
        elif key == "ipv6CidrBlock":
            suggest = "ipv6_cidr_block"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkAclIngress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkAclIngress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkAclIngress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: str,
                 from_port: int,
                 protocol: str,
                 rule_no: int,
                 to_port: int,
                 cidr_block: Optional[str] = None,
                 icmp_code: Optional[int] = None,
                 icmp_type: Optional[int] = None,
                 ipv6_cidr_block: Optional[str] = None):
        """
        :param str action: The action to take.
        :param int from_port: The from port to match.
        :param str protocol: The protocol to match. If using the -1 'all'
               protocol, you must specify a from and to port of 0.
        :param int rule_no: The rule number. Used for ordering.
        :param int to_port: The to port to match.
        :param str cidr_block: The CIDR block to match. This must be a
               valid network mask.
        :param int icmp_code: The ICMP type code to be used. Default 0.
               
               > Note: For more information on ICMP types and codes, see here: https://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml
        :param int icmp_type: The ICMP type to be used. Default 0.
        :param str ipv6_cidr_block: The IPv6 CIDR block.
        """
        NetworkAclIngress._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            from_port=from_port,
            protocol=protocol,
            rule_no=rule_no,
            to_port=to_port,
            cidr_block=cidr_block,
            icmp_code=icmp_code,
            icmp_type=icmp_type,
            ipv6_cidr_block=ipv6_cidr_block,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: Optional[str] = None,
             from_port: Optional[int] = None,
             protocol: Optional[str] = None,
             rule_no: Optional[int] = None,
             to_port: Optional[int] = None,
             cidr_block: Optional[str] = None,
             icmp_code: Optional[int] = None,
             icmp_type: Optional[int] = None,
             ipv6_cidr_block: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if action is None:
            raise TypeError("Missing 'action' argument")
        if from_port is None and 'fromPort' in kwargs:
            from_port = kwargs['fromPort']
        if from_port is None:
            raise TypeError("Missing 'from_port' argument")
        if protocol is None:
            raise TypeError("Missing 'protocol' argument")
        if rule_no is None and 'ruleNo' in kwargs:
            rule_no = kwargs['ruleNo']
        if rule_no is None:
            raise TypeError("Missing 'rule_no' argument")
        if to_port is None and 'toPort' in kwargs:
            to_port = kwargs['toPort']
        if to_port is None:
            raise TypeError("Missing 'to_port' argument")
        if cidr_block is None and 'cidrBlock' in kwargs:
            cidr_block = kwargs['cidrBlock']
        if icmp_code is None and 'icmpCode' in kwargs:
            icmp_code = kwargs['icmpCode']
        if icmp_type is None and 'icmpType' in kwargs:
            icmp_type = kwargs['icmpType']
        if ipv6_cidr_block is None and 'ipv6CidrBlock' in kwargs:
            ipv6_cidr_block = kwargs['ipv6CidrBlock']

        _setter("action", action)
        _setter("from_port", from_port)
        _setter("protocol", protocol)
        _setter("rule_no", rule_no)
        _setter("to_port", to_port)
        if cidr_block is not None:
            _setter("cidr_block", cidr_block)
        if icmp_code is not None:
            _setter("icmp_code", icmp_code)
        if icmp_type is not None:
            _setter("icmp_type", icmp_type)
        if ipv6_cidr_block is not None:
            _setter("ipv6_cidr_block", ipv6_cidr_block)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        The action to take.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> int:
        """
        The from port to match.
        """
        return pulumi.get(self, "from_port")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        The protocol to match. If using the -1 'all'
        protocol, you must specify a from and to port of 0.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="ruleNo")
    def rule_no(self) -> int:
        """
        The rule number. Used for ordering.
        """
        return pulumi.get(self, "rule_no")

    @property
    @pulumi.getter(name="toPort")
    def to_port(self) -> int:
        """
        The to port to match.
        """
        return pulumi.get(self, "to_port")

    @property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> Optional[str]:
        """
        The CIDR block to match. This must be a
        valid network mask.
        """
        return pulumi.get(self, "cidr_block")

    @property
    @pulumi.getter(name="icmpCode")
    def icmp_code(self) -> Optional[int]:
        """
        The ICMP type code to be used. Default 0.

        > Note: For more information on ICMP types and codes, see here: https://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml
        """
        return pulumi.get(self, "icmp_code")

    @property
    @pulumi.getter(name="icmpType")
    def icmp_type(self) -> Optional[int]:
        """
        The ICMP type to be used. Default 0.
        """
        return pulumi.get(self, "icmp_type")

    @property
    @pulumi.getter(name="ipv6CidrBlock")
    def ipv6_cidr_block(self) -> Optional[str]:
        """
        The IPv6 CIDR block.
        """
        return pulumi.get(self, "ipv6_cidr_block")


@pulumi.output_type
class NetworkInsightsAnalysisAlternatePathHint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "componentArn":
            suggest = "component_arn"
        elif key == "componentId":
            suggest = "component_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisAlternatePathHint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisAlternatePathHint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisAlternatePathHint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 component_arn: Optional[str] = None,
                 component_id: Optional[str] = None):
        """
        :param str component_arn: The Amazon Resource Name (ARN) of the component.
        :param str component_id: The ID of the component.
        """
        NetworkInsightsAnalysisAlternatePathHint._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            component_arn=component_arn,
            component_id=component_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             component_arn: Optional[str] = None,
             component_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if component_arn is None and 'componentArn' in kwargs:
            component_arn = kwargs['componentArn']
        if component_id is None and 'componentId' in kwargs:
            component_id = kwargs['componentId']

        if component_arn is not None:
            _setter("component_arn", component_arn)
        if component_id is not None:
            _setter("component_id", component_id)

    @property
    @pulumi.getter(name="componentArn")
    def component_arn(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) of the component.
        """
        return pulumi.get(self, "component_arn")

    @property
    @pulumi.getter(name="componentId")
    def component_id(self) -> Optional[str]:
        """
        The ID of the component.
        """
        return pulumi.get(self, "component_id")


@pulumi.output_type
class NetworkInsightsAnalysisExplanation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aclRules":
            suggest = "acl_rules"
        elif key == "attachedTos":
            suggest = "attached_tos"
        elif key == "availabilityZones":
            suggest = "availability_zones"
        elif key == "classicLoadBalancerListeners":
            suggest = "classic_load_balancer_listeners"
        elif key == "customerGateways":
            suggest = "customer_gateways"
        elif key == "destinationVpcs":
            suggest = "destination_vpcs"
        elif key == "elasticLoadBalancerListeners":
            suggest = "elastic_load_balancer_listeners"
        elif key == "explanationCode":
            suggest = "explanation_code"
        elif key == "ingressRouteTables":
            suggest = "ingress_route_tables"
        elif key == "internetGateways":
            suggest = "internet_gateways"
        elif key == "loadBalancerArn":
            suggest = "load_balancer_arn"
        elif key == "loadBalancerListenerPort":
            suggest = "load_balancer_listener_port"
        elif key == "loadBalancerTargetGroup":
            suggest = "load_balancer_target_group"
        elif key == "loadBalancerTargetGroups":
            suggest = "load_balancer_target_groups"
        elif key == "loadBalancerTargetPort":
            suggest = "load_balancer_target_port"
        elif key == "missingComponent":
            suggest = "missing_component"
        elif key == "natGateways":
            suggest = "nat_gateways"
        elif key == "networkInterfaces":
            suggest = "network_interfaces"
        elif key == "packetField":
            suggest = "packet_field"
        elif key == "portRanges":
            suggest = "port_ranges"
        elif key == "prefixLists":
            suggest = "prefix_lists"
        elif key == "routeTableRoutes":
            suggest = "route_table_routes"
        elif key == "routeTables":
            suggest = "route_tables"
        elif key == "securityGroup":
            suggest = "security_group"
        elif key == "securityGroupRules":
            suggest = "security_group_rules"
        elif key == "securityGroups":
            suggest = "security_groups"
        elif key == "sourceVpcs":
            suggest = "source_vpcs"
        elif key == "subnetRouteTables":
            suggest = "subnet_route_tables"
        elif key == "transitGatewayAttachments":
            suggest = "transit_gateway_attachments"
        elif key == "transitGatewayRouteTableRoutes":
            suggest = "transit_gateway_route_table_routes"
        elif key == "transitGatewayRouteTables":
            suggest = "transit_gateway_route_tables"
        elif key == "transitGateways":
            suggest = "transit_gateways"
        elif key == "vpcEndpoints":
            suggest = "vpc_endpoints"
        elif key == "vpcPeeringConnections":
            suggest = "vpc_peering_connections"
        elif key == "vpnConnections":
            suggest = "vpn_connections"
        elif key == "vpnGateways":
            suggest = "vpn_gateways"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisExplanation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisExplanation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisExplanation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 acl_rules: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationAclRule']] = None,
                 acls: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationAcl']] = None,
                 address: Optional[str] = None,
                 addresses: Optional[Sequence[str]] = None,
                 attached_tos: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationAttachedTo']] = None,
                 availability_zones: Optional[Sequence[str]] = None,
                 cidrs: Optional[Sequence[str]] = None,
                 classic_load_balancer_listeners: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationClassicLoadBalancerListener']] = None,
                 components: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationComponent']] = None,
                 customer_gateways: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationCustomerGateway']] = None,
                 destination_vpcs: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationDestinationVpc']] = None,
                 destinations: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationDestination']] = None,
                 direction: Optional[str] = None,
                 elastic_load_balancer_listeners: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationElasticLoadBalancerListener']] = None,
                 explanation_code: Optional[str] = None,
                 ingress_route_tables: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationIngressRouteTable']] = None,
                 internet_gateways: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationInternetGateway']] = None,
                 load_balancer_arn: Optional[str] = None,
                 load_balancer_listener_port: Optional[int] = None,
                 load_balancer_target_group: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationLoadBalancerTargetGroup']] = None,
                 load_balancer_target_groups: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationLoadBalancerTargetGroup']] = None,
                 load_balancer_target_port: Optional[int] = None,
                 missing_component: Optional[str] = None,
                 nat_gateways: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationNatGateway']] = None,
                 network_interfaces: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationNetworkInterface']] = None,
                 packet_field: Optional[str] = None,
                 port: Optional[int] = None,
                 port_ranges: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationPortRange']] = None,
                 prefix_lists: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationPrefixList']] = None,
                 protocols: Optional[Sequence[str]] = None,
                 route_table_routes: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationRouteTableRoute']] = None,
                 route_tables: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationRouteTable']] = None,
                 security_group: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationSecurityGroup']] = None,
                 security_group_rules: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationSecurityGroupRule']] = None,
                 security_groups: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationSecurityGroup']] = None,
                 source_vpcs: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationSourceVpc']] = None,
                 state: Optional[str] = None,
                 subnet_route_tables: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationSubnetRouteTable']] = None,
                 subnets: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationSubnet']] = None,
                 transit_gateway_attachments: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationTransitGatewayAttachment']] = None,
                 transit_gateway_route_table_routes: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationTransitGatewayRouteTableRoute']] = None,
                 transit_gateway_route_tables: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationTransitGatewayRouteTable']] = None,
                 transit_gateways: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationTransitGateway']] = None,
                 vpc_endpoints: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationVpcEndpoint']] = None,
                 vpc_peering_connections: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationVpcPeeringConnection']] = None,
                 vpcs: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationVpc']] = None,
                 vpn_connections: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationVpnConnection']] = None,
                 vpn_gateways: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationVpnGateway']] = None):
        NetworkInsightsAnalysisExplanation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            acl_rules=acl_rules,
            acls=acls,
            address=address,
            addresses=addresses,
            attached_tos=attached_tos,
            availability_zones=availability_zones,
            cidrs=cidrs,
            classic_load_balancer_listeners=classic_load_balancer_listeners,
            components=components,
            customer_gateways=customer_gateways,
            destination_vpcs=destination_vpcs,
            destinations=destinations,
            direction=direction,
            elastic_load_balancer_listeners=elastic_load_balancer_listeners,
            explanation_code=explanation_code,
            ingress_route_tables=ingress_route_tables,
            internet_gateways=internet_gateways,
            load_balancer_arn=load_balancer_arn,
            load_balancer_listener_port=load_balancer_listener_port,
            load_balancer_target_group=load_balancer_target_group,
            load_balancer_target_groups=load_balancer_target_groups,
            load_balancer_target_port=load_balancer_target_port,
            missing_component=missing_component,
            nat_gateways=nat_gateways,
            network_interfaces=network_interfaces,
            packet_field=packet_field,
            port=port,
            port_ranges=port_ranges,
            prefix_lists=prefix_lists,
            protocols=protocols,
            route_table_routes=route_table_routes,
            route_tables=route_tables,
            security_group=security_group,
            security_group_rules=security_group_rules,
            security_groups=security_groups,
            source_vpcs=source_vpcs,
            state=state,
            subnet_route_tables=subnet_route_tables,
            subnets=subnets,
            transit_gateway_attachments=transit_gateway_attachments,
            transit_gateway_route_table_routes=transit_gateway_route_table_routes,
            transit_gateway_route_tables=transit_gateway_route_tables,
            transit_gateways=transit_gateways,
            vpc_endpoints=vpc_endpoints,
            vpc_peering_connections=vpc_peering_connections,
            vpcs=vpcs,
            vpn_connections=vpn_connections,
            vpn_gateways=vpn_gateways,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             acl_rules: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationAclRule']] = None,
             acls: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationAcl']] = None,
             address: Optional[str] = None,
             addresses: Optional[Sequence[str]] = None,
             attached_tos: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationAttachedTo']] = None,
             availability_zones: Optional[Sequence[str]] = None,
             cidrs: Optional[Sequence[str]] = None,
             classic_load_balancer_listeners: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationClassicLoadBalancerListener']] = None,
             components: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationComponent']] = None,
             customer_gateways: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationCustomerGateway']] = None,
             destination_vpcs: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationDestinationVpc']] = None,
             destinations: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationDestination']] = None,
             direction: Optional[str] = None,
             elastic_load_balancer_listeners: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationElasticLoadBalancerListener']] = None,
             explanation_code: Optional[str] = None,
             ingress_route_tables: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationIngressRouteTable']] = None,
             internet_gateways: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationInternetGateway']] = None,
             load_balancer_arn: Optional[str] = None,
             load_balancer_listener_port: Optional[int] = None,
             load_balancer_target_group: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationLoadBalancerTargetGroup']] = None,
             load_balancer_target_groups: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationLoadBalancerTargetGroup']] = None,
             load_balancer_target_port: Optional[int] = None,
             missing_component: Optional[str] = None,
             nat_gateways: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationNatGateway']] = None,
             network_interfaces: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationNetworkInterface']] = None,
             packet_field: Optional[str] = None,
             port: Optional[int] = None,
             port_ranges: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationPortRange']] = None,
             prefix_lists: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationPrefixList']] = None,
             protocols: Optional[Sequence[str]] = None,
             route_table_routes: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationRouteTableRoute']] = None,
             route_tables: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationRouteTable']] = None,
             security_group: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationSecurityGroup']] = None,
             security_group_rules: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationSecurityGroupRule']] = None,
             security_groups: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationSecurityGroup']] = None,
             source_vpcs: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationSourceVpc']] = None,
             state: Optional[str] = None,
             subnet_route_tables: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationSubnetRouteTable']] = None,
             subnets: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationSubnet']] = None,
             transit_gateway_attachments: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationTransitGatewayAttachment']] = None,
             transit_gateway_route_table_routes: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationTransitGatewayRouteTableRoute']] = None,
             transit_gateway_route_tables: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationTransitGatewayRouteTable']] = None,
             transit_gateways: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationTransitGateway']] = None,
             vpc_endpoints: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationVpcEndpoint']] = None,
             vpc_peering_connections: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationVpcPeeringConnection']] = None,
             vpcs: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationVpc']] = None,
             vpn_connections: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationVpnConnection']] = None,
             vpn_gateways: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationVpnGateway']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if acl_rules is None and 'aclRules' in kwargs:
            acl_rules = kwargs['aclRules']
        if attached_tos is None and 'attachedTos' in kwargs:
            attached_tos = kwargs['attachedTos']
        if availability_zones is None and 'availabilityZones' in kwargs:
            availability_zones = kwargs['availabilityZones']
        if classic_load_balancer_listeners is None and 'classicLoadBalancerListeners' in kwargs:
            classic_load_balancer_listeners = kwargs['classicLoadBalancerListeners']
        if customer_gateways is None and 'customerGateways' in kwargs:
            customer_gateways = kwargs['customerGateways']
        if destination_vpcs is None and 'destinationVpcs' in kwargs:
            destination_vpcs = kwargs['destinationVpcs']
        if elastic_load_balancer_listeners is None and 'elasticLoadBalancerListeners' in kwargs:
            elastic_load_balancer_listeners = kwargs['elasticLoadBalancerListeners']
        if explanation_code is None and 'explanationCode' in kwargs:
            explanation_code = kwargs['explanationCode']
        if ingress_route_tables is None and 'ingressRouteTables' in kwargs:
            ingress_route_tables = kwargs['ingressRouteTables']
        if internet_gateways is None and 'internetGateways' in kwargs:
            internet_gateways = kwargs['internetGateways']
        if load_balancer_arn is None and 'loadBalancerArn' in kwargs:
            load_balancer_arn = kwargs['loadBalancerArn']
        if load_balancer_listener_port is None and 'loadBalancerListenerPort' in kwargs:
            load_balancer_listener_port = kwargs['loadBalancerListenerPort']
        if load_balancer_target_group is None and 'loadBalancerTargetGroup' in kwargs:
            load_balancer_target_group = kwargs['loadBalancerTargetGroup']
        if load_balancer_target_groups is None and 'loadBalancerTargetGroups' in kwargs:
            load_balancer_target_groups = kwargs['loadBalancerTargetGroups']
        if load_balancer_target_port is None and 'loadBalancerTargetPort' in kwargs:
            load_balancer_target_port = kwargs['loadBalancerTargetPort']
        if missing_component is None and 'missingComponent' in kwargs:
            missing_component = kwargs['missingComponent']
        if nat_gateways is None and 'natGateways' in kwargs:
            nat_gateways = kwargs['natGateways']
        if network_interfaces is None and 'networkInterfaces' in kwargs:
            network_interfaces = kwargs['networkInterfaces']
        if packet_field is None and 'packetField' in kwargs:
            packet_field = kwargs['packetField']
        if port_ranges is None and 'portRanges' in kwargs:
            port_ranges = kwargs['portRanges']
        if prefix_lists is None and 'prefixLists' in kwargs:
            prefix_lists = kwargs['prefixLists']
        if route_table_routes is None and 'routeTableRoutes' in kwargs:
            route_table_routes = kwargs['routeTableRoutes']
        if route_tables is None and 'routeTables' in kwargs:
            route_tables = kwargs['routeTables']
        if security_group is None and 'securityGroup' in kwargs:
            security_group = kwargs['securityGroup']
        if security_group_rules is None and 'securityGroupRules' in kwargs:
            security_group_rules = kwargs['securityGroupRules']
        if security_groups is None and 'securityGroups' in kwargs:
            security_groups = kwargs['securityGroups']
        if source_vpcs is None and 'sourceVpcs' in kwargs:
            source_vpcs = kwargs['sourceVpcs']
        if subnet_route_tables is None and 'subnetRouteTables' in kwargs:
            subnet_route_tables = kwargs['subnetRouteTables']
        if transit_gateway_attachments is None and 'transitGatewayAttachments' in kwargs:
            transit_gateway_attachments = kwargs['transitGatewayAttachments']
        if transit_gateway_route_table_routes is None and 'transitGatewayRouteTableRoutes' in kwargs:
            transit_gateway_route_table_routes = kwargs['transitGatewayRouteTableRoutes']
        if transit_gateway_route_tables is None and 'transitGatewayRouteTables' in kwargs:
            transit_gateway_route_tables = kwargs['transitGatewayRouteTables']
        if transit_gateways is None and 'transitGateways' in kwargs:
            transit_gateways = kwargs['transitGateways']
        if vpc_endpoints is None and 'vpcEndpoints' in kwargs:
            vpc_endpoints = kwargs['vpcEndpoints']
        if vpc_peering_connections is None and 'vpcPeeringConnections' in kwargs:
            vpc_peering_connections = kwargs['vpcPeeringConnections']
        if vpn_connections is None and 'vpnConnections' in kwargs:
            vpn_connections = kwargs['vpnConnections']
        if vpn_gateways is None and 'vpnGateways' in kwargs:
            vpn_gateways = kwargs['vpnGateways']

        if acl_rules is not None:
            _setter("acl_rules", acl_rules)
        if acls is not None:
            _setter("acls", acls)
        if address is not None:
            _setter("address", address)
        if addresses is not None:
            _setter("addresses", addresses)
        if attached_tos is not None:
            _setter("attached_tos", attached_tos)
        if availability_zones is not None:
            _setter("availability_zones", availability_zones)
        if cidrs is not None:
            _setter("cidrs", cidrs)
        if classic_load_balancer_listeners is not None:
            _setter("classic_load_balancer_listeners", classic_load_balancer_listeners)
        if components is not None:
            _setter("components", components)
        if customer_gateways is not None:
            _setter("customer_gateways", customer_gateways)
        if destination_vpcs is not None:
            _setter("destination_vpcs", destination_vpcs)
        if destinations is not None:
            _setter("destinations", destinations)
        if direction is not None:
            _setter("direction", direction)
        if elastic_load_balancer_listeners is not None:
            _setter("elastic_load_balancer_listeners", elastic_load_balancer_listeners)
        if explanation_code is not None:
            _setter("explanation_code", explanation_code)
        if ingress_route_tables is not None:
            _setter("ingress_route_tables", ingress_route_tables)
        if internet_gateways is not None:
            _setter("internet_gateways", internet_gateways)
        if load_balancer_arn is not None:
            _setter("load_balancer_arn", load_balancer_arn)
        if load_balancer_listener_port is not None:
            _setter("load_balancer_listener_port", load_balancer_listener_port)
        if load_balancer_target_group is not None:
            _setter("load_balancer_target_group", load_balancer_target_group)
        if load_balancer_target_groups is not None:
            _setter("load_balancer_target_groups", load_balancer_target_groups)
        if load_balancer_target_port is not None:
            _setter("load_balancer_target_port", load_balancer_target_port)
        if missing_component is not None:
            _setter("missing_component", missing_component)
        if nat_gateways is not None:
            _setter("nat_gateways", nat_gateways)
        if network_interfaces is not None:
            _setter("network_interfaces", network_interfaces)
        if packet_field is not None:
            _setter("packet_field", packet_field)
        if port is not None:
            _setter("port", port)
        if port_ranges is not None:
            _setter("port_ranges", port_ranges)
        if prefix_lists is not None:
            _setter("prefix_lists", prefix_lists)
        if protocols is not None:
            _setter("protocols", protocols)
        if route_table_routes is not None:
            _setter("route_table_routes", route_table_routes)
        if route_tables is not None:
            _setter("route_tables", route_tables)
        if security_group is not None:
            _setter("security_group", security_group)
        if security_group_rules is not None:
            _setter("security_group_rules", security_group_rules)
        if security_groups is not None:
            _setter("security_groups", security_groups)
        if source_vpcs is not None:
            _setter("source_vpcs", source_vpcs)
        if state is not None:
            _setter("state", state)
        if subnet_route_tables is not None:
            _setter("subnet_route_tables", subnet_route_tables)
        if subnets is not None:
            _setter("subnets", subnets)
        if transit_gateway_attachments is not None:
            _setter("transit_gateway_attachments", transit_gateway_attachments)
        if transit_gateway_route_table_routes is not None:
            _setter("transit_gateway_route_table_routes", transit_gateway_route_table_routes)
        if transit_gateway_route_tables is not None:
            _setter("transit_gateway_route_tables", transit_gateway_route_tables)
        if transit_gateways is not None:
            _setter("transit_gateways", transit_gateways)
        if vpc_endpoints is not None:
            _setter("vpc_endpoints", vpc_endpoints)
        if vpc_peering_connections is not None:
            _setter("vpc_peering_connections", vpc_peering_connections)
        if vpcs is not None:
            _setter("vpcs", vpcs)
        if vpn_connections is not None:
            _setter("vpn_connections", vpn_connections)
        if vpn_gateways is not None:
            _setter("vpn_gateways", vpn_gateways)

    @property
    @pulumi.getter(name="aclRules")
    def acl_rules(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationAclRule']]:
        return pulumi.get(self, "acl_rules")

    @property
    @pulumi.getter
    def acls(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationAcl']]:
        return pulumi.get(self, "acls")

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def addresses(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "addresses")

    @property
    @pulumi.getter(name="attachedTos")
    def attached_tos(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationAttachedTo']]:
        return pulumi.get(self, "attached_tos")

    @property
    @pulumi.getter(name="availabilityZones")
    def availability_zones(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "availability_zones")

    @property
    @pulumi.getter
    def cidrs(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "cidrs")

    @property
    @pulumi.getter(name="classicLoadBalancerListeners")
    def classic_load_balancer_listeners(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationClassicLoadBalancerListener']]:
        return pulumi.get(self, "classic_load_balancer_listeners")

    @property
    @pulumi.getter
    def components(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationComponent']]:
        return pulumi.get(self, "components")

    @property
    @pulumi.getter(name="customerGateways")
    def customer_gateways(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationCustomerGateway']]:
        return pulumi.get(self, "customer_gateways")

    @property
    @pulumi.getter(name="destinationVpcs")
    def destination_vpcs(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationDestinationVpc']]:
        return pulumi.get(self, "destination_vpcs")

    @property
    @pulumi.getter
    def destinations(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationDestination']]:
        return pulumi.get(self, "destinations")

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter(name="elasticLoadBalancerListeners")
    def elastic_load_balancer_listeners(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationElasticLoadBalancerListener']]:
        return pulumi.get(self, "elastic_load_balancer_listeners")

    @property
    @pulumi.getter(name="explanationCode")
    def explanation_code(self) -> Optional[str]:
        return pulumi.get(self, "explanation_code")

    @property
    @pulumi.getter(name="ingressRouteTables")
    def ingress_route_tables(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationIngressRouteTable']]:
        return pulumi.get(self, "ingress_route_tables")

    @property
    @pulumi.getter(name="internetGateways")
    def internet_gateways(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationInternetGateway']]:
        return pulumi.get(self, "internet_gateways")

    @property
    @pulumi.getter(name="loadBalancerArn")
    def load_balancer_arn(self) -> Optional[str]:
        return pulumi.get(self, "load_balancer_arn")

    @property
    @pulumi.getter(name="loadBalancerListenerPort")
    def load_balancer_listener_port(self) -> Optional[int]:
        return pulumi.get(self, "load_balancer_listener_port")

    @property
    @pulumi.getter(name="loadBalancerTargetGroup")
    def load_balancer_target_group(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationLoadBalancerTargetGroup']]:
        return pulumi.get(self, "load_balancer_target_group")

    @property
    @pulumi.getter(name="loadBalancerTargetGroups")
    def load_balancer_target_groups(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationLoadBalancerTargetGroup']]:
        return pulumi.get(self, "load_balancer_target_groups")

    @property
    @pulumi.getter(name="loadBalancerTargetPort")
    def load_balancer_target_port(self) -> Optional[int]:
        return pulumi.get(self, "load_balancer_target_port")

    @property
    @pulumi.getter(name="missingComponent")
    def missing_component(self) -> Optional[str]:
        return pulumi.get(self, "missing_component")

    @property
    @pulumi.getter(name="natGateways")
    def nat_gateways(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationNatGateway']]:
        return pulumi.get(self, "nat_gateways")

    @property
    @pulumi.getter(name="networkInterfaces")
    def network_interfaces(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationNetworkInterface']]:
        return pulumi.get(self, "network_interfaces")

    @property
    @pulumi.getter(name="packetField")
    def packet_field(self) -> Optional[str]:
        return pulumi.get(self, "packet_field")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationPortRange']]:
        return pulumi.get(self, "port_ranges")

    @property
    @pulumi.getter(name="prefixLists")
    def prefix_lists(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationPrefixList']]:
        return pulumi.get(self, "prefix_lists")

    @property
    @pulumi.getter
    def protocols(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "protocols")

    @property
    @pulumi.getter(name="routeTableRoutes")
    def route_table_routes(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationRouteTableRoute']]:
        return pulumi.get(self, "route_table_routes")

    @property
    @pulumi.getter(name="routeTables")
    def route_tables(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationRouteTable']]:
        return pulumi.get(self, "route_tables")

    @property
    @pulumi.getter(name="securityGroup")
    def security_group(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationSecurityGroup']]:
        return pulumi.get(self, "security_group")

    @property
    @pulumi.getter(name="securityGroupRules")
    def security_group_rules(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationSecurityGroupRule']]:
        return pulumi.get(self, "security_group_rules")

    @property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationSecurityGroup']]:
        return pulumi.get(self, "security_groups")

    @property
    @pulumi.getter(name="sourceVpcs")
    def source_vpcs(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationSourceVpc']]:
        return pulumi.get(self, "source_vpcs")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="subnetRouteTables")
    def subnet_route_tables(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationSubnetRouteTable']]:
        return pulumi.get(self, "subnet_route_tables")

    @property
    @pulumi.getter
    def subnets(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationSubnet']]:
        return pulumi.get(self, "subnets")

    @property
    @pulumi.getter(name="transitGatewayAttachments")
    def transit_gateway_attachments(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationTransitGatewayAttachment']]:
        return pulumi.get(self, "transit_gateway_attachments")

    @property
    @pulumi.getter(name="transitGatewayRouteTableRoutes")
    def transit_gateway_route_table_routes(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationTransitGatewayRouteTableRoute']]:
        return pulumi.get(self, "transit_gateway_route_table_routes")

    @property
    @pulumi.getter(name="transitGatewayRouteTables")
    def transit_gateway_route_tables(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationTransitGatewayRouteTable']]:
        return pulumi.get(self, "transit_gateway_route_tables")

    @property
    @pulumi.getter(name="transitGateways")
    def transit_gateways(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationTransitGateway']]:
        return pulumi.get(self, "transit_gateways")

    @property
    @pulumi.getter(name="vpcEndpoints")
    def vpc_endpoints(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationVpcEndpoint']]:
        return pulumi.get(self, "vpc_endpoints")

    @property
    @pulumi.getter(name="vpcPeeringConnections")
    def vpc_peering_connections(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationVpcPeeringConnection']]:
        return pulumi.get(self, "vpc_peering_connections")

    @property
    @pulumi.getter
    def vpcs(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationVpc']]:
        return pulumi.get(self, "vpcs")

    @property
    @pulumi.getter(name="vpnConnections")
    def vpn_connections(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationVpnConnection']]:
        return pulumi.get(self, "vpn_connections")

    @property
    @pulumi.getter(name="vpnGateways")
    def vpn_gateways(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationVpnGateway']]:
        return pulumi.get(self, "vpn_gateways")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationAcl(dict):
    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str arn: ARN of the Network Insights Analysis.
        :param str id: ID of the Network Insights Analysis.
        """
        NetworkInsightsAnalysisExplanationAcl._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if arn is not None:
            _setter("arn", arn)
        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationAclRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portRanges":
            suggest = "port_ranges"
        elif key == "ruleAction":
            suggest = "rule_action"
        elif key == "ruleNumber":
            suggest = "rule_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisExplanationAclRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisExplanationAclRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisExplanationAclRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cidr: Optional[str] = None,
                 egress: Optional[bool] = None,
                 port_ranges: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationAclRulePortRange']] = None,
                 protocol: Optional[str] = None,
                 rule_action: Optional[str] = None,
                 rule_number: Optional[int] = None):
        NetworkInsightsAnalysisExplanationAclRule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cidr=cidr,
            egress=egress,
            port_ranges=port_ranges,
            protocol=protocol,
            rule_action=rule_action,
            rule_number=rule_number,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cidr: Optional[str] = None,
             egress: Optional[bool] = None,
             port_ranges: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationAclRulePortRange']] = None,
             protocol: Optional[str] = None,
             rule_action: Optional[str] = None,
             rule_number: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if port_ranges is None and 'portRanges' in kwargs:
            port_ranges = kwargs['portRanges']
        if rule_action is None and 'ruleAction' in kwargs:
            rule_action = kwargs['ruleAction']
        if rule_number is None and 'ruleNumber' in kwargs:
            rule_number = kwargs['ruleNumber']

        if cidr is not None:
            _setter("cidr", cidr)
        if egress is not None:
            _setter("egress", egress)
        if port_ranges is not None:
            _setter("port_ranges", port_ranges)
        if protocol is not None:
            _setter("protocol", protocol)
        if rule_action is not None:
            _setter("rule_action", rule_action)
        if rule_number is not None:
            _setter("rule_number", rule_number)

    @property
    @pulumi.getter
    def cidr(self) -> Optional[str]:
        return pulumi.get(self, "cidr")

    @property
    @pulumi.getter
    def egress(self) -> Optional[bool]:
        return pulumi.get(self, "egress")

    @property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationAclRulePortRange']]:
        return pulumi.get(self, "port_ranges")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="ruleAction")
    def rule_action(self) -> Optional[str]:
        return pulumi.get(self, "rule_action")

    @property
    @pulumi.getter(name="ruleNumber")
    def rule_number(self) -> Optional[int]:
        return pulumi.get(self, "rule_number")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationAclRulePortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisExplanationAclRulePortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisExplanationAclRulePortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisExplanationAclRulePortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: Optional[int] = None,
                 to: Optional[int] = None):
        NetworkInsightsAnalysisExplanationAclRulePortRange._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            from_=from_,
            to=to,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             from_: Optional[int] = None,
             to: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if from_ is None and 'from' in kwargs:
            from_ = kwargs['from']

        if from_ is not None:
            _setter("from_", from_)
        if to is not None:
            _setter("to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[int]:
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> Optional[int]:
        return pulumi.get(self, "to")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationAttachedTo(dict):
    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str arn: ARN of the Network Insights Analysis.
        :param str id: ID of the Network Insights Analysis.
        """
        NetworkInsightsAnalysisExplanationAttachedTo._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if arn is not None:
            _setter("arn", arn)
        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationClassicLoadBalancerListener(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instancePort":
            suggest = "instance_port"
        elif key == "loadBalancerPort":
            suggest = "load_balancer_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisExplanationClassicLoadBalancerListener. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisExplanationClassicLoadBalancerListener.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisExplanationClassicLoadBalancerListener.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_port: Optional[int] = None,
                 load_balancer_port: Optional[int] = None):
        NetworkInsightsAnalysisExplanationClassicLoadBalancerListener._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            instance_port=instance_port,
            load_balancer_port=load_balancer_port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             instance_port: Optional[int] = None,
             load_balancer_port: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if instance_port is None and 'instancePort' in kwargs:
            instance_port = kwargs['instancePort']
        if load_balancer_port is None and 'loadBalancerPort' in kwargs:
            load_balancer_port = kwargs['loadBalancerPort']

        if instance_port is not None:
            _setter("instance_port", instance_port)
        if load_balancer_port is not None:
            _setter("load_balancer_port", load_balancer_port)

    @property
    @pulumi.getter(name="instancePort")
    def instance_port(self) -> Optional[int]:
        return pulumi.get(self, "instance_port")

    @property
    @pulumi.getter(name="loadBalancerPort")
    def load_balancer_port(self) -> Optional[int]:
        return pulumi.get(self, "load_balancer_port")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationComponent(dict):
    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str arn: ARN of the Network Insights Analysis.
        :param str id: ID of the Network Insights Analysis.
        """
        NetworkInsightsAnalysisExplanationComponent._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if arn is not None:
            _setter("arn", arn)
        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationCustomerGateway(dict):
    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str arn: ARN of the Network Insights Analysis.
        :param str id: ID of the Network Insights Analysis.
        """
        NetworkInsightsAnalysisExplanationCustomerGateway._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if arn is not None:
            _setter("arn", arn)
        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationDestination(dict):
    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str arn: ARN of the Network Insights Analysis.
        :param str id: ID of the Network Insights Analysis.
        """
        NetworkInsightsAnalysisExplanationDestination._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if arn is not None:
            _setter("arn", arn)
        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationDestinationVpc(dict):
    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str arn: ARN of the Network Insights Analysis.
        :param str id: ID of the Network Insights Analysis.
        """
        NetworkInsightsAnalysisExplanationDestinationVpc._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if arn is not None:
            _setter("arn", arn)
        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationElasticLoadBalancerListener(dict):
    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str arn: ARN of the Network Insights Analysis.
        :param str id: ID of the Network Insights Analysis.
        """
        NetworkInsightsAnalysisExplanationElasticLoadBalancerListener._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if arn is not None:
            _setter("arn", arn)
        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationIngressRouteTable(dict):
    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str arn: ARN of the Network Insights Analysis.
        :param str id: ID of the Network Insights Analysis.
        """
        NetworkInsightsAnalysisExplanationIngressRouteTable._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if arn is not None:
            _setter("arn", arn)
        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationInternetGateway(dict):
    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str arn: ARN of the Network Insights Analysis.
        :param str id: ID of the Network Insights Analysis.
        """
        NetworkInsightsAnalysisExplanationInternetGateway._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if arn is not None:
            _setter("arn", arn)
        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationLoadBalancerTargetGroup(dict):
    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str arn: ARN of the Network Insights Analysis.
        :param str id: ID of the Network Insights Analysis.
        """
        NetworkInsightsAnalysisExplanationLoadBalancerTargetGroup._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if arn is not None:
            _setter("arn", arn)
        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationNatGateway(dict):
    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str arn: ARN of the Network Insights Analysis.
        :param str id: ID of the Network Insights Analysis.
        """
        NetworkInsightsAnalysisExplanationNatGateway._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if arn is not None:
            _setter("arn", arn)
        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationNetworkInterface(dict):
    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str arn: ARN of the Network Insights Analysis.
        :param str id: ID of the Network Insights Analysis.
        """
        NetworkInsightsAnalysisExplanationNetworkInterface._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if arn is not None:
            _setter("arn", arn)
        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationPortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisExplanationPortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisExplanationPortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisExplanationPortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: Optional[int] = None,
                 to: Optional[int] = None):
        NetworkInsightsAnalysisExplanationPortRange._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            from_=from_,
            to=to,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             from_: Optional[int] = None,
             to: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if from_ is None and 'from' in kwargs:
            from_ = kwargs['from']

        if from_ is not None:
            _setter("from_", from_)
        if to is not None:
            _setter("to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[int]:
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> Optional[int]:
        return pulumi.get(self, "to")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationPrefixList(dict):
    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str arn: ARN of the Network Insights Analysis.
        :param str id: ID of the Network Insights Analysis.
        """
        NetworkInsightsAnalysisExplanationPrefixList._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if arn is not None:
            _setter("arn", arn)
        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationRouteTable(dict):
    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str arn: ARN of the Network Insights Analysis.
        :param str id: ID of the Network Insights Analysis.
        """
        NetworkInsightsAnalysisExplanationRouteTable._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if arn is not None:
            _setter("arn", arn)
        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationRouteTableRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationCidr":
            suggest = "destination_cidr"
        elif key == "destinationPrefixListId":
            suggest = "destination_prefix_list_id"
        elif key == "egressOnlyInternetGatewayId":
            suggest = "egress_only_internet_gateway_id"
        elif key == "gatewayId":
            suggest = "gateway_id"
        elif key == "instanceId":
            suggest = "instance_id"
        elif key == "natGatewayId":
            suggest = "nat_gateway_id"
        elif key == "networkInterfaceId":
            suggest = "network_interface_id"
        elif key == "transitGatewayId":
            suggest = "transit_gateway_id"
        elif key == "vpcPeeringConnectionId":
            suggest = "vpc_peering_connection_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisExplanationRouteTableRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisExplanationRouteTableRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisExplanationRouteTableRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_cidr: Optional[str] = None,
                 destination_prefix_list_id: Optional[str] = None,
                 egress_only_internet_gateway_id: Optional[str] = None,
                 gateway_id: Optional[str] = None,
                 instance_id: Optional[str] = None,
                 nat_gateway_id: Optional[str] = None,
                 network_interface_id: Optional[str] = None,
                 origin: Optional[str] = None,
                 transit_gateway_id: Optional[str] = None,
                 vpc_peering_connection_id: Optional[str] = None):
        NetworkInsightsAnalysisExplanationRouteTableRoute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination_cidr=destination_cidr,
            destination_prefix_list_id=destination_prefix_list_id,
            egress_only_internet_gateway_id=egress_only_internet_gateway_id,
            gateway_id=gateway_id,
            instance_id=instance_id,
            nat_gateway_id=nat_gateway_id,
            network_interface_id=network_interface_id,
            origin=origin,
            transit_gateway_id=transit_gateway_id,
            vpc_peering_connection_id=vpc_peering_connection_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination_cidr: Optional[str] = None,
             destination_prefix_list_id: Optional[str] = None,
             egress_only_internet_gateway_id: Optional[str] = None,
             gateway_id: Optional[str] = None,
             instance_id: Optional[str] = None,
             nat_gateway_id: Optional[str] = None,
             network_interface_id: Optional[str] = None,
             origin: Optional[str] = None,
             transit_gateway_id: Optional[str] = None,
             vpc_peering_connection_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if destination_cidr is None and 'destinationCidr' in kwargs:
            destination_cidr = kwargs['destinationCidr']
        if destination_prefix_list_id is None and 'destinationPrefixListId' in kwargs:
            destination_prefix_list_id = kwargs['destinationPrefixListId']
        if egress_only_internet_gateway_id is None and 'egressOnlyInternetGatewayId' in kwargs:
            egress_only_internet_gateway_id = kwargs['egressOnlyInternetGatewayId']
        if gateway_id is None and 'gatewayId' in kwargs:
            gateway_id = kwargs['gatewayId']
        if instance_id is None and 'instanceId' in kwargs:
            instance_id = kwargs['instanceId']
        if nat_gateway_id is None and 'natGatewayId' in kwargs:
            nat_gateway_id = kwargs['natGatewayId']
        if network_interface_id is None and 'networkInterfaceId' in kwargs:
            network_interface_id = kwargs['networkInterfaceId']
        if transit_gateway_id is None and 'transitGatewayId' in kwargs:
            transit_gateway_id = kwargs['transitGatewayId']
        if vpc_peering_connection_id is None and 'vpcPeeringConnectionId' in kwargs:
            vpc_peering_connection_id = kwargs['vpcPeeringConnectionId']

        if destination_cidr is not None:
            _setter("destination_cidr", destination_cidr)
        if destination_prefix_list_id is not None:
            _setter("destination_prefix_list_id", destination_prefix_list_id)
        if egress_only_internet_gateway_id is not None:
            _setter("egress_only_internet_gateway_id", egress_only_internet_gateway_id)
        if gateway_id is not None:
            _setter("gateway_id", gateway_id)
        if instance_id is not None:
            _setter("instance_id", instance_id)
        if nat_gateway_id is not None:
            _setter("nat_gateway_id", nat_gateway_id)
        if network_interface_id is not None:
            _setter("network_interface_id", network_interface_id)
        if origin is not None:
            _setter("origin", origin)
        if transit_gateway_id is not None:
            _setter("transit_gateway_id", transit_gateway_id)
        if vpc_peering_connection_id is not None:
            _setter("vpc_peering_connection_id", vpc_peering_connection_id)

    @property
    @pulumi.getter(name="destinationCidr")
    def destination_cidr(self) -> Optional[str]:
        return pulumi.get(self, "destination_cidr")

    @property
    @pulumi.getter(name="destinationPrefixListId")
    def destination_prefix_list_id(self) -> Optional[str]:
        return pulumi.get(self, "destination_prefix_list_id")

    @property
    @pulumi.getter(name="egressOnlyInternetGatewayId")
    def egress_only_internet_gateway_id(self) -> Optional[str]:
        return pulumi.get(self, "egress_only_internet_gateway_id")

    @property
    @pulumi.getter(name="gatewayId")
    def gateway_id(self) -> Optional[str]:
        return pulumi.get(self, "gateway_id")

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[str]:
        return pulumi.get(self, "instance_id")

    @property
    @pulumi.getter(name="natGatewayId")
    def nat_gateway_id(self) -> Optional[str]:
        return pulumi.get(self, "nat_gateway_id")

    @property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> Optional[str]:
        return pulumi.get(self, "network_interface_id")

    @property
    @pulumi.getter
    def origin(self) -> Optional[str]:
        return pulumi.get(self, "origin")

    @property
    @pulumi.getter(name="transitGatewayId")
    def transit_gateway_id(self) -> Optional[str]:
        return pulumi.get(self, "transit_gateway_id")

    @property
    @pulumi.getter(name="vpcPeeringConnectionId")
    def vpc_peering_connection_id(self) -> Optional[str]:
        return pulumi.get(self, "vpc_peering_connection_id")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationSecurityGroup(dict):
    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str arn: ARN of the Network Insights Analysis.
        :param str id: ID of the Network Insights Analysis.
        """
        NetworkInsightsAnalysisExplanationSecurityGroup._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if arn is not None:
            _setter("arn", arn)
        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationSecurityGroupRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portRanges":
            suggest = "port_ranges"
        elif key == "prefixListId":
            suggest = "prefix_list_id"
        elif key == "securityGroupId":
            suggest = "security_group_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisExplanationSecurityGroupRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisExplanationSecurityGroupRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisExplanationSecurityGroupRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cidr: Optional[str] = None,
                 direction: Optional[str] = None,
                 port_ranges: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationSecurityGroupRulePortRange']] = None,
                 prefix_list_id: Optional[str] = None,
                 protocol: Optional[str] = None,
                 security_group_id: Optional[str] = None):
        NetworkInsightsAnalysisExplanationSecurityGroupRule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cidr=cidr,
            direction=direction,
            port_ranges=port_ranges,
            prefix_list_id=prefix_list_id,
            protocol=protocol,
            security_group_id=security_group_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cidr: Optional[str] = None,
             direction: Optional[str] = None,
             port_ranges: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationSecurityGroupRulePortRange']] = None,
             prefix_list_id: Optional[str] = None,
             protocol: Optional[str] = None,
             security_group_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if port_ranges is None and 'portRanges' in kwargs:
            port_ranges = kwargs['portRanges']
        if prefix_list_id is None and 'prefixListId' in kwargs:
            prefix_list_id = kwargs['prefixListId']
        if security_group_id is None and 'securityGroupId' in kwargs:
            security_group_id = kwargs['securityGroupId']

        if cidr is not None:
            _setter("cidr", cidr)
        if direction is not None:
            _setter("direction", direction)
        if port_ranges is not None:
            _setter("port_ranges", port_ranges)
        if prefix_list_id is not None:
            _setter("prefix_list_id", prefix_list_id)
        if protocol is not None:
            _setter("protocol", protocol)
        if security_group_id is not None:
            _setter("security_group_id", security_group_id)

    @property
    @pulumi.getter
    def cidr(self) -> Optional[str]:
        return pulumi.get(self, "cidr")

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationSecurityGroupRulePortRange']]:
        return pulumi.get(self, "port_ranges")

    @property
    @pulumi.getter(name="prefixListId")
    def prefix_list_id(self) -> Optional[str]:
        return pulumi.get(self, "prefix_list_id")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> Optional[str]:
        return pulumi.get(self, "security_group_id")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationSecurityGroupRulePortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisExplanationSecurityGroupRulePortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisExplanationSecurityGroupRulePortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisExplanationSecurityGroupRulePortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: Optional[int] = None,
                 to: Optional[int] = None):
        NetworkInsightsAnalysisExplanationSecurityGroupRulePortRange._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            from_=from_,
            to=to,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             from_: Optional[int] = None,
             to: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if from_ is None and 'from' in kwargs:
            from_ = kwargs['from']

        if from_ is not None:
            _setter("from_", from_)
        if to is not None:
            _setter("to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[int]:
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> Optional[int]:
        return pulumi.get(self, "to")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationSourceVpc(dict):
    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str arn: ARN of the Network Insights Analysis.
        :param str id: ID of the Network Insights Analysis.
        """
        NetworkInsightsAnalysisExplanationSourceVpc._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if arn is not None:
            _setter("arn", arn)
        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationSubnet(dict):
    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str arn: ARN of the Network Insights Analysis.
        :param str id: ID of the Network Insights Analysis.
        """
        NetworkInsightsAnalysisExplanationSubnet._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if arn is not None:
            _setter("arn", arn)
        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationSubnetRouteTable(dict):
    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str arn: ARN of the Network Insights Analysis.
        :param str id: ID of the Network Insights Analysis.
        """
        NetworkInsightsAnalysisExplanationSubnetRouteTable._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if arn is not None:
            _setter("arn", arn)
        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationTransitGateway(dict):
    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str arn: ARN of the Network Insights Analysis.
        :param str id: ID of the Network Insights Analysis.
        """
        NetworkInsightsAnalysisExplanationTransitGateway._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if arn is not None:
            _setter("arn", arn)
        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationTransitGatewayAttachment(dict):
    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str arn: ARN of the Network Insights Analysis.
        :param str id: ID of the Network Insights Analysis.
        """
        NetworkInsightsAnalysisExplanationTransitGatewayAttachment._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if arn is not None:
            _setter("arn", arn)
        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationTransitGatewayRouteTable(dict):
    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str arn: ARN of the Network Insights Analysis.
        :param str id: ID of the Network Insights Analysis.
        """
        NetworkInsightsAnalysisExplanationTransitGatewayRouteTable._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if arn is not None:
            _setter("arn", arn)
        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationTransitGatewayRouteTableRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attachmentId":
            suggest = "attachment_id"
        elif key == "destinationCidr":
            suggest = "destination_cidr"
        elif key == "prefixListId":
            suggest = "prefix_list_id"
        elif key == "resourceId":
            suggest = "resource_id"
        elif key == "resourceType":
            suggest = "resource_type"
        elif key == "routeOrigin":
            suggest = "route_origin"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisExplanationTransitGatewayRouteTableRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisExplanationTransitGatewayRouteTableRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisExplanationTransitGatewayRouteTableRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attachment_id: Optional[str] = None,
                 destination_cidr: Optional[str] = None,
                 prefix_list_id: Optional[str] = None,
                 resource_id: Optional[str] = None,
                 resource_type: Optional[str] = None,
                 route_origin: Optional[str] = None,
                 state: Optional[str] = None):
        NetworkInsightsAnalysisExplanationTransitGatewayRouteTableRoute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            attachment_id=attachment_id,
            destination_cidr=destination_cidr,
            prefix_list_id=prefix_list_id,
            resource_id=resource_id,
            resource_type=resource_type,
            route_origin=route_origin,
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             attachment_id: Optional[str] = None,
             destination_cidr: Optional[str] = None,
             prefix_list_id: Optional[str] = None,
             resource_id: Optional[str] = None,
             resource_type: Optional[str] = None,
             route_origin: Optional[str] = None,
             state: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if attachment_id is None and 'attachmentId' in kwargs:
            attachment_id = kwargs['attachmentId']
        if destination_cidr is None and 'destinationCidr' in kwargs:
            destination_cidr = kwargs['destinationCidr']
        if prefix_list_id is None and 'prefixListId' in kwargs:
            prefix_list_id = kwargs['prefixListId']
        if resource_id is None and 'resourceId' in kwargs:
            resource_id = kwargs['resourceId']
        if resource_type is None and 'resourceType' in kwargs:
            resource_type = kwargs['resourceType']
        if route_origin is None and 'routeOrigin' in kwargs:
            route_origin = kwargs['routeOrigin']

        if attachment_id is not None:
            _setter("attachment_id", attachment_id)
        if destination_cidr is not None:
            _setter("destination_cidr", destination_cidr)
        if prefix_list_id is not None:
            _setter("prefix_list_id", prefix_list_id)
        if resource_id is not None:
            _setter("resource_id", resource_id)
        if resource_type is not None:
            _setter("resource_type", resource_type)
        if route_origin is not None:
            _setter("route_origin", route_origin)
        if state is not None:
            _setter("state", state)

    @property
    @pulumi.getter(name="attachmentId")
    def attachment_id(self) -> Optional[str]:
        return pulumi.get(self, "attachment_id")

    @property
    @pulumi.getter(name="destinationCidr")
    def destination_cidr(self) -> Optional[str]:
        return pulumi.get(self, "destination_cidr")

    @property
    @pulumi.getter(name="prefixListId")
    def prefix_list_id(self) -> Optional[str]:
        return pulumi.get(self, "prefix_list_id")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[str]:
        return pulumi.get(self, "resource_id")

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[str]:
        return pulumi.get(self, "resource_type")

    @property
    @pulumi.getter(name="routeOrigin")
    def route_origin(self) -> Optional[str]:
        return pulumi.get(self, "route_origin")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        return pulumi.get(self, "state")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationVpc(dict):
    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str arn: ARN of the Network Insights Analysis.
        :param str id: ID of the Network Insights Analysis.
        """
        NetworkInsightsAnalysisExplanationVpc._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if arn is not None:
            _setter("arn", arn)
        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationVpcEndpoint(dict):
    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str arn: ARN of the Network Insights Analysis.
        :param str id: ID of the Network Insights Analysis.
        """
        NetworkInsightsAnalysisExplanationVpcEndpoint._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if arn is not None:
            _setter("arn", arn)
        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationVpcPeeringConnection(dict):
    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str arn: ARN of the Network Insights Analysis.
        :param str id: ID of the Network Insights Analysis.
        """
        NetworkInsightsAnalysisExplanationVpcPeeringConnection._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if arn is not None:
            _setter("arn", arn)
        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationVpnConnection(dict):
    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str arn: ARN of the Network Insights Analysis.
        :param str id: ID of the Network Insights Analysis.
        """
        NetworkInsightsAnalysisExplanationVpnConnection._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if arn is not None:
            _setter("arn", arn)
        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationVpnGateway(dict):
    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str arn: ARN of the Network Insights Analysis.
        :param str id: ID of the Network Insights Analysis.
        """
        NetworkInsightsAnalysisExplanationVpnGateway._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if arn is not None:
            _setter("arn", arn)
        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisForwardPathComponent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aclRules":
            suggest = "acl_rules"
        elif key == "additionalDetails":
            suggest = "additional_details"
        elif key == "attachedTos":
            suggest = "attached_tos"
        elif key == "destinationVpcs":
            suggest = "destination_vpcs"
        elif key == "inboundHeaders":
            suggest = "inbound_headers"
        elif key == "outboundHeaders":
            suggest = "outbound_headers"
        elif key == "routeTableRoutes":
            suggest = "route_table_routes"
        elif key == "securityGroupRules":
            suggest = "security_group_rules"
        elif key == "sequenceNumber":
            suggest = "sequence_number"
        elif key == "sourceVpcs":
            suggest = "source_vpcs"
        elif key == "transitGatewayRouteTableRoutes":
            suggest = "transit_gateway_route_table_routes"
        elif key == "transitGateways":
            suggest = "transit_gateways"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisForwardPathComponent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisForwardPathComponent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisForwardPathComponent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 acl_rules: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentAclRule']] = None,
                 additional_details: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentAdditionalDetail']] = None,
                 attached_tos: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentAttachedTo']] = None,
                 components: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentComponent']] = None,
                 destination_vpcs: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentDestinationVpc']] = None,
                 inbound_headers: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentInboundHeader']] = None,
                 outbound_headers: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentOutboundHeader']] = None,
                 route_table_routes: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentRouteTableRoute']] = None,
                 security_group_rules: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentSecurityGroupRule']] = None,
                 sequence_number: Optional[int] = None,
                 source_vpcs: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentSourceVpc']] = None,
                 subnets: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentSubnet']] = None,
                 transit_gateway_route_table_routes: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentTransitGatewayRouteTableRoute']] = None,
                 transit_gateways: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentTransitGateway']] = None,
                 vpcs: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentVpc']] = None):
        NetworkInsightsAnalysisForwardPathComponent._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            acl_rules=acl_rules,
            additional_details=additional_details,
            attached_tos=attached_tos,
            components=components,
            destination_vpcs=destination_vpcs,
            inbound_headers=inbound_headers,
            outbound_headers=outbound_headers,
            route_table_routes=route_table_routes,
            security_group_rules=security_group_rules,
            sequence_number=sequence_number,
            source_vpcs=source_vpcs,
            subnets=subnets,
            transit_gateway_route_table_routes=transit_gateway_route_table_routes,
            transit_gateways=transit_gateways,
            vpcs=vpcs,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             acl_rules: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentAclRule']] = None,
             additional_details: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentAdditionalDetail']] = None,
             attached_tos: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentAttachedTo']] = None,
             components: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentComponent']] = None,
             destination_vpcs: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentDestinationVpc']] = None,
             inbound_headers: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentInboundHeader']] = None,
             outbound_headers: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentOutboundHeader']] = None,
             route_table_routes: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentRouteTableRoute']] = None,
             security_group_rules: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentSecurityGroupRule']] = None,
             sequence_number: Optional[int] = None,
             source_vpcs: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentSourceVpc']] = None,
             subnets: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentSubnet']] = None,
             transit_gateway_route_table_routes: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentTransitGatewayRouteTableRoute']] = None,
             transit_gateways: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentTransitGateway']] = None,
             vpcs: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentVpc']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if acl_rules is None and 'aclRules' in kwargs:
            acl_rules = kwargs['aclRules']
        if additional_details is None and 'additionalDetails' in kwargs:
            additional_details = kwargs['additionalDetails']
        if attached_tos is None and 'attachedTos' in kwargs:
            attached_tos = kwargs['attachedTos']
        if destination_vpcs is None and 'destinationVpcs' in kwargs:
            destination_vpcs = kwargs['destinationVpcs']
        if inbound_headers is None and 'inboundHeaders' in kwargs:
            inbound_headers = kwargs['inboundHeaders']
        if outbound_headers is None and 'outboundHeaders' in kwargs:
            outbound_headers = kwargs['outboundHeaders']
        if route_table_routes is None and 'routeTableRoutes' in kwargs:
            route_table_routes = kwargs['routeTableRoutes']
        if security_group_rules is None and 'securityGroupRules' in kwargs:
            security_group_rules = kwargs['securityGroupRules']
        if sequence_number is None and 'sequenceNumber' in kwargs:
            sequence_number = kwargs['sequenceNumber']
        if source_vpcs is None and 'sourceVpcs' in kwargs:
            source_vpcs = kwargs['sourceVpcs']
        if transit_gateway_route_table_routes is None and 'transitGatewayRouteTableRoutes' in kwargs:
            transit_gateway_route_table_routes = kwargs['transitGatewayRouteTableRoutes']
        if transit_gateways is None and 'transitGateways' in kwargs:
            transit_gateways = kwargs['transitGateways']

        if acl_rules is not None:
            _setter("acl_rules", acl_rules)
        if additional_details is not None:
            _setter("additional_details", additional_details)
        if attached_tos is not None:
            _setter("attached_tos", attached_tos)
        if components is not None:
            _setter("components", components)
        if destination_vpcs is not None:
            _setter("destination_vpcs", destination_vpcs)
        if inbound_headers is not None:
            _setter("inbound_headers", inbound_headers)
        if outbound_headers is not None:
            _setter("outbound_headers", outbound_headers)
        if route_table_routes is not None:
            _setter("route_table_routes", route_table_routes)
        if security_group_rules is not None:
            _setter("security_group_rules", security_group_rules)
        if sequence_number is not None:
            _setter("sequence_number", sequence_number)
        if source_vpcs is not None:
            _setter("source_vpcs", source_vpcs)
        if subnets is not None:
            _setter("subnets", subnets)
        if transit_gateway_route_table_routes is not None:
            _setter("transit_gateway_route_table_routes", transit_gateway_route_table_routes)
        if transit_gateways is not None:
            _setter("transit_gateways", transit_gateways)
        if vpcs is not None:
            _setter("vpcs", vpcs)

    @property
    @pulumi.getter(name="aclRules")
    def acl_rules(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentAclRule']]:
        return pulumi.get(self, "acl_rules")

    @property
    @pulumi.getter(name="additionalDetails")
    def additional_details(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentAdditionalDetail']]:
        return pulumi.get(self, "additional_details")

    @property
    @pulumi.getter(name="attachedTos")
    def attached_tos(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentAttachedTo']]:
        return pulumi.get(self, "attached_tos")

    @property
    @pulumi.getter
    def components(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentComponent']]:
        return pulumi.get(self, "components")

    @property
    @pulumi.getter(name="destinationVpcs")
    def destination_vpcs(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentDestinationVpc']]:
        return pulumi.get(self, "destination_vpcs")

    @property
    @pulumi.getter(name="inboundHeaders")
    def inbound_headers(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentInboundHeader']]:
        return pulumi.get(self, "inbound_headers")

    @property
    @pulumi.getter(name="outboundHeaders")
    def outbound_headers(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentOutboundHeader']]:
        return pulumi.get(self, "outbound_headers")

    @property
    @pulumi.getter(name="routeTableRoutes")
    def route_table_routes(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentRouteTableRoute']]:
        return pulumi.get(self, "route_table_routes")

    @property
    @pulumi.getter(name="securityGroupRules")
    def security_group_rules(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentSecurityGroupRule']]:
        return pulumi.get(self, "security_group_rules")

    @property
    @pulumi.getter(name="sequenceNumber")
    def sequence_number(self) -> Optional[int]:
        return pulumi.get(self, "sequence_number")

    @property
    @pulumi.getter(name="sourceVpcs")
    def source_vpcs(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentSourceVpc']]:
        return pulumi.get(self, "source_vpcs")

    @property
    @pulumi.getter
    def subnets(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentSubnet']]:
        return pulumi.get(self, "subnets")

    @property
    @pulumi.getter(name="transitGatewayRouteTableRoutes")
    def transit_gateway_route_table_routes(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentTransitGatewayRouteTableRoute']]:
        return pulumi.get(self, "transit_gateway_route_table_routes")

    @property
    @pulumi.getter(name="transitGateways")
    def transit_gateways(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentTransitGateway']]:
        return pulumi.get(self, "transit_gateways")

    @property
    @pulumi.getter
    def vpcs(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentVpc']]:
        return pulumi.get(self, "vpcs")


@pulumi.output_type
class NetworkInsightsAnalysisForwardPathComponentAclRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portRanges":
            suggest = "port_ranges"
        elif key == "ruleAction":
            suggest = "rule_action"
        elif key == "ruleNumber":
            suggest = "rule_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisForwardPathComponentAclRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisForwardPathComponentAclRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisForwardPathComponentAclRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cidr: Optional[str] = None,
                 egress: Optional[bool] = None,
                 port_ranges: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentAclRulePortRange']] = None,
                 protocol: Optional[str] = None,
                 rule_action: Optional[str] = None,
                 rule_number: Optional[int] = None):
        NetworkInsightsAnalysisForwardPathComponentAclRule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cidr=cidr,
            egress=egress,
            port_ranges=port_ranges,
            protocol=protocol,
            rule_action=rule_action,
            rule_number=rule_number,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cidr: Optional[str] = None,
             egress: Optional[bool] = None,
             port_ranges: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentAclRulePortRange']] = None,
             protocol: Optional[str] = None,
             rule_action: Optional[str] = None,
             rule_number: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if port_ranges is None and 'portRanges' in kwargs:
            port_ranges = kwargs['portRanges']
        if rule_action is None and 'ruleAction' in kwargs:
            rule_action = kwargs['ruleAction']
        if rule_number is None and 'ruleNumber' in kwargs:
            rule_number = kwargs['ruleNumber']

        if cidr is not None:
            _setter("cidr", cidr)
        if egress is not None:
            _setter("egress", egress)
        if port_ranges is not None:
            _setter("port_ranges", port_ranges)
        if protocol is not None:
            _setter("protocol", protocol)
        if rule_action is not None:
            _setter("rule_action", rule_action)
        if rule_number is not None:
            _setter("rule_number", rule_number)

    @property
    @pulumi.getter
    def cidr(self) -> Optional[str]:
        return pulumi.get(self, "cidr")

    @property
    @pulumi.getter
    def egress(self) -> Optional[bool]:
        return pulumi.get(self, "egress")

    @property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentAclRulePortRange']]:
        return pulumi.get(self, "port_ranges")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="ruleAction")
    def rule_action(self) -> Optional[str]:
        return pulumi.get(self, "rule_action")

    @property
    @pulumi.getter(name="ruleNumber")
    def rule_number(self) -> Optional[int]:
        return pulumi.get(self, "rule_number")


@pulumi.output_type
class NetworkInsightsAnalysisForwardPathComponentAclRulePortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisForwardPathComponentAclRulePortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisForwardPathComponentAclRulePortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisForwardPathComponentAclRulePortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: Optional[int] = None,
                 to: Optional[int] = None):
        NetworkInsightsAnalysisForwardPathComponentAclRulePortRange._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            from_=from_,
            to=to,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             from_: Optional[int] = None,
             to: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if from_ is None and 'from' in kwargs:
            from_ = kwargs['from']

        if from_ is not None:
            _setter("from_", from_)
        if to is not None:
            _setter("to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[int]:
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> Optional[int]:
        return pulumi.get(self, "to")


@pulumi.output_type
class NetworkInsightsAnalysisForwardPathComponentAdditionalDetail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalDetailType":
            suggest = "additional_detail_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisForwardPathComponentAdditionalDetail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisForwardPathComponentAdditionalDetail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisForwardPathComponentAdditionalDetail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_detail_type: Optional[str] = None,
                 components: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentAdditionalDetailComponent']] = None):
        NetworkInsightsAnalysisForwardPathComponentAdditionalDetail._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            additional_detail_type=additional_detail_type,
            components=components,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             additional_detail_type: Optional[str] = None,
             components: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentAdditionalDetailComponent']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if additional_detail_type is None and 'additionalDetailType' in kwargs:
            additional_detail_type = kwargs['additionalDetailType']

        if additional_detail_type is not None:
            _setter("additional_detail_type", additional_detail_type)
        if components is not None:
            _setter("components", components)

    @property
    @pulumi.getter(name="additionalDetailType")
    def additional_detail_type(self) -> Optional[str]:
        return pulumi.get(self, "additional_detail_type")

    @property
    @pulumi.getter
    def components(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentAdditionalDetailComponent']]:
        return pulumi.get(self, "components")


@pulumi.output_type
class NetworkInsightsAnalysisForwardPathComponentAdditionalDetailComponent(dict):
    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str arn: ARN of the Network Insights Analysis.
        :param str id: ID of the Network Insights Analysis.
        """
        NetworkInsightsAnalysisForwardPathComponentAdditionalDetailComponent._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if arn is not None:
            _setter("arn", arn)
        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisForwardPathComponentAttachedTo(dict):
    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str arn: ARN of the Network Insights Analysis.
        :param str id: ID of the Network Insights Analysis.
        """
        NetworkInsightsAnalysisForwardPathComponentAttachedTo._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if arn is not None:
            _setter("arn", arn)
        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisForwardPathComponentComponent(dict):
    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str arn: ARN of the Network Insights Analysis.
        :param str id: ID of the Network Insights Analysis.
        """
        NetworkInsightsAnalysisForwardPathComponentComponent._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if arn is not None:
            _setter("arn", arn)
        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisForwardPathComponentDestinationVpc(dict):
    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str arn: ARN of the Network Insights Analysis.
        :param str id: ID of the Network Insights Analysis.
        """
        NetworkInsightsAnalysisForwardPathComponentDestinationVpc._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if arn is not None:
            _setter("arn", arn)
        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisForwardPathComponentInboundHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationAddresses":
            suggest = "destination_addresses"
        elif key == "destinationPortRanges":
            suggest = "destination_port_ranges"
        elif key == "sourceAddresses":
            suggest = "source_addresses"
        elif key == "sourcePortRanges":
            suggest = "source_port_ranges"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisForwardPathComponentInboundHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisForwardPathComponentInboundHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisForwardPathComponentInboundHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_addresses: Optional[Sequence[str]] = None,
                 destination_port_ranges: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentInboundHeaderDestinationPortRange']] = None,
                 protocol: Optional[str] = None,
                 source_addresses: Optional[Sequence[str]] = None,
                 source_port_ranges: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentInboundHeaderSourcePortRange']] = None):
        NetworkInsightsAnalysisForwardPathComponentInboundHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination_addresses=destination_addresses,
            destination_port_ranges=destination_port_ranges,
            protocol=protocol,
            source_addresses=source_addresses,
            source_port_ranges=source_port_ranges,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination_addresses: Optional[Sequence[str]] = None,
             destination_port_ranges: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentInboundHeaderDestinationPortRange']] = None,
             protocol: Optional[str] = None,
             source_addresses: Optional[Sequence[str]] = None,
             source_port_ranges: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentInboundHeaderSourcePortRange']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if destination_addresses is None and 'destinationAddresses' in kwargs:
            destination_addresses = kwargs['destinationAddresses']
        if destination_port_ranges is None and 'destinationPortRanges' in kwargs:
            destination_port_ranges = kwargs['destinationPortRanges']
        if source_addresses is None and 'sourceAddresses' in kwargs:
            source_addresses = kwargs['sourceAddresses']
        if source_port_ranges is None and 'sourcePortRanges' in kwargs:
            source_port_ranges = kwargs['sourcePortRanges']

        if destination_addresses is not None:
            _setter("destination_addresses", destination_addresses)
        if destination_port_ranges is not None:
            _setter("destination_port_ranges", destination_port_ranges)
        if protocol is not None:
            _setter("protocol", protocol)
        if source_addresses is not None:
            _setter("source_addresses", source_addresses)
        if source_port_ranges is not None:
            _setter("source_port_ranges", source_port_ranges)

    @property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "destination_addresses")

    @property
    @pulumi.getter(name="destinationPortRanges")
    def destination_port_ranges(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentInboundHeaderDestinationPortRange']]:
        return pulumi.get(self, "destination_port_ranges")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "source_addresses")

    @property
    @pulumi.getter(name="sourcePortRanges")
    def source_port_ranges(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentInboundHeaderSourcePortRange']]:
        return pulumi.get(self, "source_port_ranges")


@pulumi.output_type
class NetworkInsightsAnalysisForwardPathComponentInboundHeaderDestinationPortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisForwardPathComponentInboundHeaderDestinationPortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisForwardPathComponentInboundHeaderDestinationPortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisForwardPathComponentInboundHeaderDestinationPortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: Optional[int] = None,
                 to: Optional[int] = None):
        NetworkInsightsAnalysisForwardPathComponentInboundHeaderDestinationPortRange._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            from_=from_,
            to=to,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             from_: Optional[int] = None,
             to: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if from_ is None and 'from' in kwargs:
            from_ = kwargs['from']

        if from_ is not None:
            _setter("from_", from_)
        if to is not None:
            _setter("to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[int]:
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> Optional[int]:
        return pulumi.get(self, "to")


@pulumi.output_type
class NetworkInsightsAnalysisForwardPathComponentInboundHeaderSourcePortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisForwardPathComponentInboundHeaderSourcePortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisForwardPathComponentInboundHeaderSourcePortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisForwardPathComponentInboundHeaderSourcePortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: Optional[int] = None,
                 to: Optional[int] = None):
        NetworkInsightsAnalysisForwardPathComponentInboundHeaderSourcePortRange._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            from_=from_,
            to=to,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             from_: Optional[int] = None,
             to: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if from_ is None and 'from' in kwargs:
            from_ = kwargs['from']

        if from_ is not None:
            _setter("from_", from_)
        if to is not None:
            _setter("to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[int]:
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> Optional[int]:
        return pulumi.get(self, "to")


@pulumi.output_type
class NetworkInsightsAnalysisForwardPathComponentOutboundHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationAddresses":
            suggest = "destination_addresses"
        elif key == "destinationPortRanges":
            suggest = "destination_port_ranges"
        elif key == "sourceAddresses":
            suggest = "source_addresses"
        elif key == "sourcePortRanges":
            suggest = "source_port_ranges"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisForwardPathComponentOutboundHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisForwardPathComponentOutboundHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisForwardPathComponentOutboundHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_addresses: Optional[Sequence[str]] = None,
                 destination_port_ranges: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentOutboundHeaderDestinationPortRange']] = None,
                 protocol: Optional[str] = None,
                 source_addresses: Optional[Sequence[str]] = None,
                 source_port_ranges: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentOutboundHeaderSourcePortRange']] = None):
        NetworkInsightsAnalysisForwardPathComponentOutboundHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination_addresses=destination_addresses,
            destination_port_ranges=destination_port_ranges,
            protocol=protocol,
            source_addresses=source_addresses,
            source_port_ranges=source_port_ranges,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination_addresses: Optional[Sequence[str]] = None,
             destination_port_ranges: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentOutboundHeaderDestinationPortRange']] = None,
             protocol: Optional[str] = None,
             source_addresses: Optional[Sequence[str]] = None,
             source_port_ranges: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentOutboundHeaderSourcePortRange']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if destination_addresses is None and 'destinationAddresses' in kwargs:
            destination_addresses = kwargs['destinationAddresses']
        if destination_port_ranges is None and 'destinationPortRanges' in kwargs:
            destination_port_ranges = kwargs['destinationPortRanges']
        if source_addresses is None and 'sourceAddresses' in kwargs:
            source_addresses = kwargs['sourceAddresses']
        if source_port_ranges is None and 'sourcePortRanges' in kwargs:
            source_port_ranges = kwargs['sourcePortRanges']

        if destination_addresses is not None:
            _setter("destination_addresses", destination_addresses)
        if destination_port_ranges is not None:
            _setter("destination_port_ranges", destination_port_ranges)
        if protocol is not None:
            _setter("protocol", protocol)
        if source_addresses is not None:
            _setter("source_addresses", source_addresses)
        if source_port_ranges is not None:
            _setter("source_port_ranges", source_port_ranges)

    @property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "destination_addresses")

    @property
    @pulumi.getter(name="destinationPortRanges")
    def destination_port_ranges(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentOutboundHeaderDestinationPortRange']]:
        return pulumi.get(self, "destination_port_ranges")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "source_addresses")

    @property
    @pulumi.getter(name="sourcePortRanges")
    def source_port_ranges(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentOutboundHeaderSourcePortRange']]:
        return pulumi.get(self, "source_port_ranges")


@pulumi.output_type
class NetworkInsightsAnalysisForwardPathComponentOutboundHeaderDestinationPortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisForwardPathComponentOutboundHeaderDestinationPortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisForwardPathComponentOutboundHeaderDestinationPortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisForwardPathComponentOutboundHeaderDestinationPortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: Optional[int] = None,
                 to: Optional[int] = None):
        NetworkInsightsAnalysisForwardPathComponentOutboundHeaderDestinationPortRange._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            from_=from_,
            to=to,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             from_: Optional[int] = None,
             to: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if from_ is None and 'from' in kwargs:
            from_ = kwargs['from']

        if from_ is not None:
            _setter("from_", from_)
        if to is not None:
            _setter("to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[int]:
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> Optional[int]:
        return pulumi.get(self, "to")


@pulumi.output_type
class NetworkInsightsAnalysisForwardPathComponentOutboundHeaderSourcePortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisForwardPathComponentOutboundHeaderSourcePortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisForwardPathComponentOutboundHeaderSourcePortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisForwardPathComponentOutboundHeaderSourcePortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: Optional[int] = None,
                 to: Optional[int] = None):
        NetworkInsightsAnalysisForwardPathComponentOutboundHeaderSourcePortRange._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            from_=from_,
            to=to,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             from_: Optional[int] = None,
             to: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if from_ is None and 'from' in kwargs:
            from_ = kwargs['from']

        if from_ is not None:
            _setter("from_", from_)
        if to is not None:
            _setter("to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[int]:
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> Optional[int]:
        return pulumi.get(self, "to")


@pulumi.output_type
class NetworkInsightsAnalysisForwardPathComponentRouteTableRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationCidr":
            suggest = "destination_cidr"
        elif key == "destinationPrefixListId":
            suggest = "destination_prefix_list_id"
        elif key == "egressOnlyInternetGatewayId":
            suggest = "egress_only_internet_gateway_id"
        elif key == "gatewayId":
            suggest = "gateway_id"
        elif key == "instanceId":
            suggest = "instance_id"
        elif key == "natGatewayId":
            suggest = "nat_gateway_id"
        elif key == "networkInterfaceId":
            suggest = "network_interface_id"
        elif key == "transitGatewayId":
            suggest = "transit_gateway_id"
        elif key == "vpcPeeringConnectionId":
            suggest = "vpc_peering_connection_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisForwardPathComponentRouteTableRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisForwardPathComponentRouteTableRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisForwardPathComponentRouteTableRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_cidr: Optional[str] = None,
                 destination_prefix_list_id: Optional[str] = None,
                 egress_only_internet_gateway_id: Optional[str] = None,
                 gateway_id: Optional[str] = None,
                 instance_id: Optional[str] = None,
                 nat_gateway_id: Optional[str] = None,
                 network_interface_id: Optional[str] = None,
                 origin: Optional[str] = None,
                 transit_gateway_id: Optional[str] = None,
                 vpc_peering_connection_id: Optional[str] = None):
        NetworkInsightsAnalysisForwardPathComponentRouteTableRoute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination_cidr=destination_cidr,
            destination_prefix_list_id=destination_prefix_list_id,
            egress_only_internet_gateway_id=egress_only_internet_gateway_id,
            gateway_id=gateway_id,
            instance_id=instance_id,
            nat_gateway_id=nat_gateway_id,
            network_interface_id=network_interface_id,
            origin=origin,
            transit_gateway_id=transit_gateway_id,
            vpc_peering_connection_id=vpc_peering_connection_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination_cidr: Optional[str] = None,
             destination_prefix_list_id: Optional[str] = None,
             egress_only_internet_gateway_id: Optional[str] = None,
             gateway_id: Optional[str] = None,
             instance_id: Optional[str] = None,
             nat_gateway_id: Optional[str] = None,
             network_interface_id: Optional[str] = None,
             origin: Optional[str] = None,
             transit_gateway_id: Optional[str] = None,
             vpc_peering_connection_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if destination_cidr is None and 'destinationCidr' in kwargs:
            destination_cidr = kwargs['destinationCidr']
        if destination_prefix_list_id is None and 'destinationPrefixListId' in kwargs:
            destination_prefix_list_id = kwargs['destinationPrefixListId']
        if egress_only_internet_gateway_id is None and 'egressOnlyInternetGatewayId' in kwargs:
            egress_only_internet_gateway_id = kwargs['egressOnlyInternetGatewayId']
        if gateway_id is None and 'gatewayId' in kwargs:
            gateway_id = kwargs['gatewayId']
        if instance_id is None and 'instanceId' in kwargs:
            instance_id = kwargs['instanceId']
        if nat_gateway_id is None and 'natGatewayId' in kwargs:
            nat_gateway_id = kwargs['natGatewayId']
        if network_interface_id is None and 'networkInterfaceId' in kwargs:
            network_interface_id = kwargs['networkInterfaceId']
        if transit_gateway_id is None and 'transitGatewayId' in kwargs:
            transit_gateway_id = kwargs['transitGatewayId']
        if vpc_peering_connection_id is None and 'vpcPeeringConnectionId' in kwargs:
            vpc_peering_connection_id = kwargs['vpcPeeringConnectionId']

        if destination_cidr is not None:
            _setter("destination_cidr", destination_cidr)
        if destination_prefix_list_id is not None:
            _setter("destination_prefix_list_id", destination_prefix_list_id)
        if egress_only_internet_gateway_id is not None:
            _setter("egress_only_internet_gateway_id", egress_only_internet_gateway_id)
        if gateway_id is not None:
            _setter("gateway_id", gateway_id)
        if instance_id is not None:
            _setter("instance_id", instance_id)
        if nat_gateway_id is not None:
            _setter("nat_gateway_id", nat_gateway_id)
        if network_interface_id is not None:
            _setter("network_interface_id", network_interface_id)
        if origin is not None:
            _setter("origin", origin)
        if transit_gateway_id is not None:
            _setter("transit_gateway_id", transit_gateway_id)
        if vpc_peering_connection_id is not None:
            _setter("vpc_peering_connection_id", vpc_peering_connection_id)

    @property
    @pulumi.getter(name="destinationCidr")
    def destination_cidr(self) -> Optional[str]:
        return pulumi.get(self, "destination_cidr")

    @property
    @pulumi.getter(name="destinationPrefixListId")
    def destination_prefix_list_id(self) -> Optional[str]:
        return pulumi.get(self, "destination_prefix_list_id")

    @property
    @pulumi.getter(name="egressOnlyInternetGatewayId")
    def egress_only_internet_gateway_id(self) -> Optional[str]:
        return pulumi.get(self, "egress_only_internet_gateway_id")

    @property
    @pulumi.getter(name="gatewayId")
    def gateway_id(self) -> Optional[str]:
        return pulumi.get(self, "gateway_id")

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[str]:
        return pulumi.get(self, "instance_id")

    @property
    @pulumi.getter(name="natGatewayId")
    def nat_gateway_id(self) -> Optional[str]:
        return pulumi.get(self, "nat_gateway_id")

    @property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> Optional[str]:
        return pulumi.get(self, "network_interface_id")

    @property
    @pulumi.getter
    def origin(self) -> Optional[str]:
        return pulumi.get(self, "origin")

    @property
    @pulumi.getter(name="transitGatewayId")
    def transit_gateway_id(self) -> Optional[str]:
        return pulumi.get(self, "transit_gateway_id")

    @property
    @pulumi.getter(name="vpcPeeringConnectionId")
    def vpc_peering_connection_id(self) -> Optional[str]:
        return pulumi.get(self, "vpc_peering_connection_id")


@pulumi.output_type
class NetworkInsightsAnalysisForwardPathComponentSecurityGroupRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portRanges":
            suggest = "port_ranges"
        elif key == "prefixListId":
            suggest = "prefix_list_id"
        elif key == "securityGroupId":
            suggest = "security_group_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisForwardPathComponentSecurityGroupRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisForwardPathComponentSecurityGroupRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisForwardPathComponentSecurityGroupRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cidr: Optional[str] = None,
                 direction: Optional[str] = None,
                 port_ranges: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentSecurityGroupRulePortRange']] = None,
                 prefix_list_id: Optional[str] = None,
                 protocol: Optional[str] = None,
                 security_group_id: Optional[str] = None):
        NetworkInsightsAnalysisForwardPathComponentSecurityGroupRule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cidr=cidr,
            direction=direction,
            port_ranges=port_ranges,
            prefix_list_id=prefix_list_id,
            protocol=protocol,
            security_group_id=security_group_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cidr: Optional[str] = None,
             direction: Optional[str] = None,
             port_ranges: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentSecurityGroupRulePortRange']] = None,
             prefix_list_id: Optional[str] = None,
             protocol: Optional[str] = None,
             security_group_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if port_ranges is None and 'portRanges' in kwargs:
            port_ranges = kwargs['portRanges']
        if prefix_list_id is None and 'prefixListId' in kwargs:
            prefix_list_id = kwargs['prefixListId']
        if security_group_id is None and 'securityGroupId' in kwargs:
            security_group_id = kwargs['securityGroupId']

        if cidr is not None:
            _setter("cidr", cidr)
        if direction is not None:
            _setter("direction", direction)
        if port_ranges is not None:
            _setter("port_ranges", port_ranges)
        if prefix_list_id is not None:
            _setter("prefix_list_id", prefix_list_id)
        if protocol is not None:
            _setter("protocol", protocol)
        if security_group_id is not None:
            _setter("security_group_id", security_group_id)

    @property
    @pulumi.getter
    def cidr(self) -> Optional[str]:
        return pulumi.get(self, "cidr")

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentSecurityGroupRulePortRange']]:
        return pulumi.get(self, "port_ranges")

    @property
    @pulumi.getter(name="prefixListId")
    def prefix_list_id(self) -> Optional[str]:
        return pulumi.get(self, "prefix_list_id")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> Optional[str]:
        return pulumi.get(self, "security_group_id")


@pulumi.output_type
class NetworkInsightsAnalysisForwardPathComponentSecurityGroupRulePortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisForwardPathComponentSecurityGroupRulePortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisForwardPathComponentSecurityGroupRulePortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisForwardPathComponentSecurityGroupRulePortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: Optional[int] = None,
                 to: Optional[int] = None):
        NetworkInsightsAnalysisForwardPathComponentSecurityGroupRulePortRange._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            from_=from_,
            to=to,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             from_: Optional[int] = None,
             to: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if from_ is None and 'from' in kwargs:
            from_ = kwargs['from']

        if from_ is not None:
            _setter("from_", from_)
        if to is not None:
            _setter("to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[int]:
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> Optional[int]:
        return pulumi.get(self, "to")


@pulumi.output_type
class NetworkInsightsAnalysisForwardPathComponentSourceVpc(dict):
    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str arn: ARN of the Network Insights Analysis.
        :param str id: ID of the Network Insights Analysis.
        """
        NetworkInsightsAnalysisForwardPathComponentSourceVpc._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if arn is not None:
            _setter("arn", arn)
        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisForwardPathComponentSubnet(dict):
    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str arn: ARN of the Network Insights Analysis.
        :param str id: ID of the Network Insights Analysis.
        """
        NetworkInsightsAnalysisForwardPathComponentSubnet._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if arn is not None:
            _setter("arn", arn)
        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisForwardPathComponentTransitGateway(dict):
    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str arn: ARN of the Network Insights Analysis.
        :param str id: ID of the Network Insights Analysis.
        """
        NetworkInsightsAnalysisForwardPathComponentTransitGateway._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if arn is not None:
            _setter("arn", arn)
        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisForwardPathComponentTransitGatewayRouteTableRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attachmentId":
            suggest = "attachment_id"
        elif key == "destinationCidr":
            suggest = "destination_cidr"
        elif key == "prefixListId":
            suggest = "prefix_list_id"
        elif key == "resourceId":
            suggest = "resource_id"
        elif key == "resourceType":
            suggest = "resource_type"
        elif key == "routeOrigin":
            suggest = "route_origin"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisForwardPathComponentTransitGatewayRouteTableRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisForwardPathComponentTransitGatewayRouteTableRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisForwardPathComponentTransitGatewayRouteTableRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attachment_id: Optional[str] = None,
                 destination_cidr: Optional[str] = None,
                 prefix_list_id: Optional[str] = None,
                 resource_id: Optional[str] = None,
                 resource_type: Optional[str] = None,
                 route_origin: Optional[str] = None,
                 state: Optional[str] = None):
        NetworkInsightsAnalysisForwardPathComponentTransitGatewayRouteTableRoute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            attachment_id=attachment_id,
            destination_cidr=destination_cidr,
            prefix_list_id=prefix_list_id,
            resource_id=resource_id,
            resource_type=resource_type,
            route_origin=route_origin,
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             attachment_id: Optional[str] = None,
             destination_cidr: Optional[str] = None,
             prefix_list_id: Optional[str] = None,
             resource_id: Optional[str] = None,
             resource_type: Optional[str] = None,
             route_origin: Optional[str] = None,
             state: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if attachment_id is None and 'attachmentId' in kwargs:
            attachment_id = kwargs['attachmentId']
        if destination_cidr is None and 'destinationCidr' in kwargs:
            destination_cidr = kwargs['destinationCidr']
        if prefix_list_id is None and 'prefixListId' in kwargs:
            prefix_list_id = kwargs['prefixListId']
        if resource_id is None and 'resourceId' in kwargs:
            resource_id = kwargs['resourceId']
        if resource_type is None and 'resourceType' in kwargs:
            resource_type = kwargs['resourceType']
        if route_origin is None and 'routeOrigin' in kwargs:
            route_origin = kwargs['routeOrigin']

        if attachment_id is not None:
            _setter("attachment_id", attachment_id)
        if destination_cidr is not None:
            _setter("destination_cidr", destination_cidr)
        if prefix_list_id is not None:
            _setter("prefix_list_id", prefix_list_id)
        if resource_id is not None:
            _setter("resource_id", resource_id)
        if resource_type is not None:
            _setter("resource_type", resource_type)
        if route_origin is not None:
            _setter("route_origin", route_origin)
        if state is not None:
            _setter("state", state)

    @property
    @pulumi.getter(name="attachmentId")
    def attachment_id(self) -> Optional[str]:
        return pulumi.get(self, "attachment_id")

    @property
    @pulumi.getter(name="destinationCidr")
    def destination_cidr(self) -> Optional[str]:
        return pulumi.get(self, "destination_cidr")

    @property
    @pulumi.getter(name="prefixListId")
    def prefix_list_id(self) -> Optional[str]:
        return pulumi.get(self, "prefix_list_id")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[str]:
        return pulumi.get(self, "resource_id")

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[str]:
        return pulumi.get(self, "resource_type")

    @property
    @pulumi.getter(name="routeOrigin")
    def route_origin(self) -> Optional[str]:
        return pulumi.get(self, "route_origin")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        return pulumi.get(self, "state")


@pulumi.output_type
class NetworkInsightsAnalysisForwardPathComponentVpc(dict):
    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str arn: ARN of the Network Insights Analysis.
        :param str id: ID of the Network Insights Analysis.
        """
        NetworkInsightsAnalysisForwardPathComponentVpc._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if arn is not None:
            _setter("arn", arn)
        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisReturnPathComponent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aclRules":
            suggest = "acl_rules"
        elif key == "additionalDetails":
            suggest = "additional_details"
        elif key == "attachedTos":
            suggest = "attached_tos"
        elif key == "destinationVpcs":
            suggest = "destination_vpcs"
        elif key == "inboundHeaders":
            suggest = "inbound_headers"
        elif key == "outboundHeaders":
            suggest = "outbound_headers"
        elif key == "routeTableRoutes":
            suggest = "route_table_routes"
        elif key == "securityGroupRules":
            suggest = "security_group_rules"
        elif key == "sequenceNumber":
            suggest = "sequence_number"
        elif key == "sourceVpcs":
            suggest = "source_vpcs"
        elif key == "transitGatewayRouteTableRoutes":
            suggest = "transit_gateway_route_table_routes"
        elif key == "transitGateways":
            suggest = "transit_gateways"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisReturnPathComponent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisReturnPathComponent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisReturnPathComponent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 acl_rules: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentAclRule']] = None,
                 additional_details: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentAdditionalDetail']] = None,
                 attached_tos: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentAttachedTo']] = None,
                 components: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentComponent']] = None,
                 destination_vpcs: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentDestinationVpc']] = None,
                 inbound_headers: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentInboundHeader']] = None,
                 outbound_headers: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentOutboundHeader']] = None,
                 route_table_routes: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentRouteTableRoute']] = None,
                 security_group_rules: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentSecurityGroupRule']] = None,
                 sequence_number: Optional[int] = None,
                 source_vpcs: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentSourceVpc']] = None,
                 subnets: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentSubnet']] = None,
                 transit_gateway_route_table_routes: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentTransitGatewayRouteTableRoute']] = None,
                 transit_gateways: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentTransitGateway']] = None,
                 vpcs: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentVpc']] = None):
        NetworkInsightsAnalysisReturnPathComponent._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            acl_rules=acl_rules,
            additional_details=additional_details,
            attached_tos=attached_tos,
            components=components,
            destination_vpcs=destination_vpcs,
            inbound_headers=inbound_headers,
            outbound_headers=outbound_headers,
            route_table_routes=route_table_routes,
            security_group_rules=security_group_rules,
            sequence_number=sequence_number,
            source_vpcs=source_vpcs,
            subnets=subnets,
            transit_gateway_route_table_routes=transit_gateway_route_table_routes,
            transit_gateways=transit_gateways,
            vpcs=vpcs,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             acl_rules: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentAclRule']] = None,
             additional_details: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentAdditionalDetail']] = None,
             attached_tos: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentAttachedTo']] = None,
             components: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentComponent']] = None,
             destination_vpcs: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentDestinationVpc']] = None,
             inbound_headers: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentInboundHeader']] = None,
             outbound_headers: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentOutboundHeader']] = None,
             route_table_routes: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentRouteTableRoute']] = None,
             security_group_rules: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentSecurityGroupRule']] = None,
             sequence_number: Optional[int] = None,
             source_vpcs: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentSourceVpc']] = None,
             subnets: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentSubnet']] = None,
             transit_gateway_route_table_routes: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentTransitGatewayRouteTableRoute']] = None,
             transit_gateways: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentTransitGateway']] = None,
             vpcs: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentVpc']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if acl_rules is None and 'aclRules' in kwargs:
            acl_rules = kwargs['aclRules']
        if additional_details is None and 'additionalDetails' in kwargs:
            additional_details = kwargs['additionalDetails']
        if attached_tos is None and 'attachedTos' in kwargs:
            attached_tos = kwargs['attachedTos']
        if destination_vpcs is None and 'destinationVpcs' in kwargs:
            destination_vpcs = kwargs['destinationVpcs']
        if inbound_headers is None and 'inboundHeaders' in kwargs:
            inbound_headers = kwargs['inboundHeaders']
        if outbound_headers is None and 'outboundHeaders' in kwargs:
            outbound_headers = kwargs['outboundHeaders']
        if route_table_routes is None and 'routeTableRoutes' in kwargs:
            route_table_routes = kwargs['routeTableRoutes']
        if security_group_rules is None and 'securityGroupRules' in kwargs:
            security_group_rules = kwargs['securityGroupRules']
        if sequence_number is None and 'sequenceNumber' in kwargs:
            sequence_number = kwargs['sequenceNumber']
        if source_vpcs is None and 'sourceVpcs' in kwargs:
            source_vpcs = kwargs['sourceVpcs']
        if transit_gateway_route_table_routes is None and 'transitGatewayRouteTableRoutes' in kwargs:
            transit_gateway_route_table_routes = kwargs['transitGatewayRouteTableRoutes']
        if transit_gateways is None and 'transitGateways' in kwargs:
            transit_gateways = kwargs['transitGateways']

        if acl_rules is not None:
            _setter("acl_rules", acl_rules)
        if additional_details is not None:
            _setter("additional_details", additional_details)
        if attached_tos is not None:
            _setter("attached_tos", attached_tos)
        if components is not None:
            _setter("components", components)
        if destination_vpcs is not None:
            _setter("destination_vpcs", destination_vpcs)
        if inbound_headers is not None:
            _setter("inbound_headers", inbound_headers)
        if outbound_headers is not None:
            _setter("outbound_headers", outbound_headers)
        if route_table_routes is not None:
            _setter("route_table_routes", route_table_routes)
        if security_group_rules is not None:
            _setter("security_group_rules", security_group_rules)
        if sequence_number is not None:
            _setter("sequence_number", sequence_number)
        if source_vpcs is not None:
            _setter("source_vpcs", source_vpcs)
        if subnets is not None:
            _setter("subnets", subnets)
        if transit_gateway_route_table_routes is not None:
            _setter("transit_gateway_route_table_routes", transit_gateway_route_table_routes)
        if transit_gateways is not None:
            _setter("transit_gateways", transit_gateways)
        if vpcs is not None:
            _setter("vpcs", vpcs)

    @property
    @pulumi.getter(name="aclRules")
    def acl_rules(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentAclRule']]:
        return pulumi.get(self, "acl_rules")

    @property
    @pulumi.getter(name="additionalDetails")
    def additional_details(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentAdditionalDetail']]:
        return pulumi.get(self, "additional_details")

    @property
    @pulumi.getter(name="attachedTos")
    def attached_tos(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentAttachedTo']]:
        return pulumi.get(self, "attached_tos")

    @property
    @pulumi.getter
    def components(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentComponent']]:
        return pulumi.get(self, "components")

    @property
    @pulumi.getter(name="destinationVpcs")
    def destination_vpcs(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentDestinationVpc']]:
        return pulumi.get(self, "destination_vpcs")

    @property
    @pulumi.getter(name="inboundHeaders")
    def inbound_headers(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentInboundHeader']]:
        return pulumi.get(self, "inbound_headers")

    @property
    @pulumi.getter(name="outboundHeaders")
    def outbound_headers(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentOutboundHeader']]:
        return pulumi.get(self, "outbound_headers")

    @property
    @pulumi.getter(name="routeTableRoutes")
    def route_table_routes(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentRouteTableRoute']]:
        return pulumi.get(self, "route_table_routes")

    @property
    @pulumi.getter(name="securityGroupRules")
    def security_group_rules(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentSecurityGroupRule']]:
        return pulumi.get(self, "security_group_rules")

    @property
    @pulumi.getter(name="sequenceNumber")
    def sequence_number(self) -> Optional[int]:
        return pulumi.get(self, "sequence_number")

    @property
    @pulumi.getter(name="sourceVpcs")
    def source_vpcs(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentSourceVpc']]:
        return pulumi.get(self, "source_vpcs")

    @property
    @pulumi.getter
    def subnets(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentSubnet']]:
        return pulumi.get(self, "subnets")

    @property
    @pulumi.getter(name="transitGatewayRouteTableRoutes")
    def transit_gateway_route_table_routes(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentTransitGatewayRouteTableRoute']]:
        return pulumi.get(self, "transit_gateway_route_table_routes")

    @property
    @pulumi.getter(name="transitGateways")
    def transit_gateways(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentTransitGateway']]:
        return pulumi.get(self, "transit_gateways")

    @property
    @pulumi.getter
    def vpcs(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentVpc']]:
        return pulumi.get(self, "vpcs")


@pulumi.output_type
class NetworkInsightsAnalysisReturnPathComponentAclRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portRanges":
            suggest = "port_ranges"
        elif key == "ruleAction":
            suggest = "rule_action"
        elif key == "ruleNumber":
            suggest = "rule_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisReturnPathComponentAclRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisReturnPathComponentAclRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisReturnPathComponentAclRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cidr: Optional[str] = None,
                 egress: Optional[bool] = None,
                 port_ranges: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentAclRulePortRange']] = None,
                 protocol: Optional[str] = None,
                 rule_action: Optional[str] = None,
                 rule_number: Optional[int] = None):
        NetworkInsightsAnalysisReturnPathComponentAclRule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cidr=cidr,
            egress=egress,
            port_ranges=port_ranges,
            protocol=protocol,
            rule_action=rule_action,
            rule_number=rule_number,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cidr: Optional[str] = None,
             egress: Optional[bool] = None,
             port_ranges: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentAclRulePortRange']] = None,
             protocol: Optional[str] = None,
             rule_action: Optional[str] = None,
             rule_number: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if port_ranges is None and 'portRanges' in kwargs:
            port_ranges = kwargs['portRanges']
        if rule_action is None and 'ruleAction' in kwargs:
            rule_action = kwargs['ruleAction']
        if rule_number is None and 'ruleNumber' in kwargs:
            rule_number = kwargs['ruleNumber']

        if cidr is not None:
            _setter("cidr", cidr)
        if egress is not None:
            _setter("egress", egress)
        if port_ranges is not None:
            _setter("port_ranges", port_ranges)
        if protocol is not None:
            _setter("protocol", protocol)
        if rule_action is not None:
            _setter("rule_action", rule_action)
        if rule_number is not None:
            _setter("rule_number", rule_number)

    @property
    @pulumi.getter
    def cidr(self) -> Optional[str]:
        return pulumi.get(self, "cidr")

    @property
    @pulumi.getter
    def egress(self) -> Optional[bool]:
        return pulumi.get(self, "egress")

    @property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentAclRulePortRange']]:
        return pulumi.get(self, "port_ranges")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="ruleAction")
    def rule_action(self) -> Optional[str]:
        return pulumi.get(self, "rule_action")

    @property
    @pulumi.getter(name="ruleNumber")
    def rule_number(self) -> Optional[int]:
        return pulumi.get(self, "rule_number")


@pulumi.output_type
class NetworkInsightsAnalysisReturnPathComponentAclRulePortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisReturnPathComponentAclRulePortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisReturnPathComponentAclRulePortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisReturnPathComponentAclRulePortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: Optional[int] = None,
                 to: Optional[int] = None):
        NetworkInsightsAnalysisReturnPathComponentAclRulePortRange._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            from_=from_,
            to=to,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             from_: Optional[int] = None,
             to: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if from_ is None and 'from' in kwargs:
            from_ = kwargs['from']

        if from_ is not None:
            _setter("from_", from_)
        if to is not None:
            _setter("to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[int]:
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> Optional[int]:
        return pulumi.get(self, "to")


@pulumi.output_type
class NetworkInsightsAnalysisReturnPathComponentAdditionalDetail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalDetailType":
            suggest = "additional_detail_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisReturnPathComponentAdditionalDetail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisReturnPathComponentAdditionalDetail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisReturnPathComponentAdditionalDetail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_detail_type: Optional[str] = None,
                 components: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentAdditionalDetailComponent']] = None):
        NetworkInsightsAnalysisReturnPathComponentAdditionalDetail._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            additional_detail_type=additional_detail_type,
            components=components,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             additional_detail_type: Optional[str] = None,
             components: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentAdditionalDetailComponent']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if additional_detail_type is None and 'additionalDetailType' in kwargs:
            additional_detail_type = kwargs['additionalDetailType']

        if additional_detail_type is not None:
            _setter("additional_detail_type", additional_detail_type)
        if components is not None:
            _setter("components", components)

    @property
    @pulumi.getter(name="additionalDetailType")
    def additional_detail_type(self) -> Optional[str]:
        return pulumi.get(self, "additional_detail_type")

    @property
    @pulumi.getter
    def components(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentAdditionalDetailComponent']]:
        return pulumi.get(self, "components")


@pulumi.output_type
class NetworkInsightsAnalysisReturnPathComponentAdditionalDetailComponent(dict):
    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str arn: ARN of the Network Insights Analysis.
        :param str id: ID of the Network Insights Analysis.
        """
        NetworkInsightsAnalysisReturnPathComponentAdditionalDetailComponent._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if arn is not None:
            _setter("arn", arn)
        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisReturnPathComponentAttachedTo(dict):
    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str arn: ARN of the Network Insights Analysis.
        :param str id: ID of the Network Insights Analysis.
        """
        NetworkInsightsAnalysisReturnPathComponentAttachedTo._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if arn is not None:
            _setter("arn", arn)
        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisReturnPathComponentComponent(dict):
    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str arn: ARN of the Network Insights Analysis.
        :param str id: ID of the Network Insights Analysis.
        """
        NetworkInsightsAnalysisReturnPathComponentComponent._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if arn is not None:
            _setter("arn", arn)
        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisReturnPathComponentDestinationVpc(dict):
    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str arn: ARN of the Network Insights Analysis.
        :param str id: ID of the Network Insights Analysis.
        """
        NetworkInsightsAnalysisReturnPathComponentDestinationVpc._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if arn is not None:
            _setter("arn", arn)
        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisReturnPathComponentInboundHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationAddresses":
            suggest = "destination_addresses"
        elif key == "destinationPortRanges":
            suggest = "destination_port_ranges"
        elif key == "sourceAddresses":
            suggest = "source_addresses"
        elif key == "sourcePortRanges":
            suggest = "source_port_ranges"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisReturnPathComponentInboundHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisReturnPathComponentInboundHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisReturnPathComponentInboundHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_addresses: Optional[Sequence[str]] = None,
                 destination_port_ranges: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentInboundHeaderDestinationPortRange']] = None,
                 protocol: Optional[str] = None,
                 source_addresses: Optional[Sequence[str]] = None,
                 source_port_ranges: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentInboundHeaderSourcePortRange']] = None):
        NetworkInsightsAnalysisReturnPathComponentInboundHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination_addresses=destination_addresses,
            destination_port_ranges=destination_port_ranges,
            protocol=protocol,
            source_addresses=source_addresses,
            source_port_ranges=source_port_ranges,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination_addresses: Optional[Sequence[str]] = None,
             destination_port_ranges: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentInboundHeaderDestinationPortRange']] = None,
             protocol: Optional[str] = None,
             source_addresses: Optional[Sequence[str]] = None,
             source_port_ranges: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentInboundHeaderSourcePortRange']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if destination_addresses is None and 'destinationAddresses' in kwargs:
            destination_addresses = kwargs['destinationAddresses']
        if destination_port_ranges is None and 'destinationPortRanges' in kwargs:
            destination_port_ranges = kwargs['destinationPortRanges']
        if source_addresses is None and 'sourceAddresses' in kwargs:
            source_addresses = kwargs['sourceAddresses']
        if source_port_ranges is None and 'sourcePortRanges' in kwargs:
            source_port_ranges = kwargs['sourcePortRanges']

        if destination_addresses is not None:
            _setter("destination_addresses", destination_addresses)
        if destination_port_ranges is not None:
            _setter("destination_port_ranges", destination_port_ranges)
        if protocol is not None:
            _setter("protocol", protocol)
        if source_addresses is not None:
            _setter("source_addresses", source_addresses)
        if source_port_ranges is not None:
            _setter("source_port_ranges", source_port_ranges)

    @property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "destination_addresses")

    @property
    @pulumi.getter(name="destinationPortRanges")
    def destination_port_ranges(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentInboundHeaderDestinationPortRange']]:
        return pulumi.get(self, "destination_port_ranges")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "source_addresses")

    @property
    @pulumi.getter(name="sourcePortRanges")
    def source_port_ranges(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentInboundHeaderSourcePortRange']]:
        return pulumi.get(self, "source_port_ranges")


@pulumi.output_type
class NetworkInsightsAnalysisReturnPathComponentInboundHeaderDestinationPortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisReturnPathComponentInboundHeaderDestinationPortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisReturnPathComponentInboundHeaderDestinationPortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisReturnPathComponentInboundHeaderDestinationPortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: Optional[int] = None,
                 to: Optional[int] = None):
        NetworkInsightsAnalysisReturnPathComponentInboundHeaderDestinationPortRange._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            from_=from_,
            to=to,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             from_: Optional[int] = None,
             to: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if from_ is None and 'from' in kwargs:
            from_ = kwargs['from']

        if from_ is not None:
            _setter("from_", from_)
        if to is not None:
            _setter("to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[int]:
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> Optional[int]:
        return pulumi.get(self, "to")


@pulumi.output_type
class NetworkInsightsAnalysisReturnPathComponentInboundHeaderSourcePortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisReturnPathComponentInboundHeaderSourcePortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisReturnPathComponentInboundHeaderSourcePortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisReturnPathComponentInboundHeaderSourcePortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: Optional[int] = None,
                 to: Optional[int] = None):
        NetworkInsightsAnalysisReturnPathComponentInboundHeaderSourcePortRange._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            from_=from_,
            to=to,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             from_: Optional[int] = None,
             to: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if from_ is None and 'from' in kwargs:
            from_ = kwargs['from']

        if from_ is not None:
            _setter("from_", from_)
        if to is not None:
            _setter("to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[int]:
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> Optional[int]:
        return pulumi.get(self, "to")


@pulumi.output_type
class NetworkInsightsAnalysisReturnPathComponentOutboundHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationAddresses":
            suggest = "destination_addresses"
        elif key == "destinationPortRanges":
            suggest = "destination_port_ranges"
        elif key == "sourceAddresses":
            suggest = "source_addresses"
        elif key == "sourcePortRanges":
            suggest = "source_port_ranges"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisReturnPathComponentOutboundHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisReturnPathComponentOutboundHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisReturnPathComponentOutboundHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_addresses: Optional[Sequence[str]] = None,
                 destination_port_ranges: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentOutboundHeaderDestinationPortRange']] = None,
                 protocol: Optional[str] = None,
                 source_addresses: Optional[Sequence[str]] = None,
                 source_port_ranges: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentOutboundHeaderSourcePortRange']] = None):
        NetworkInsightsAnalysisReturnPathComponentOutboundHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination_addresses=destination_addresses,
            destination_port_ranges=destination_port_ranges,
            protocol=protocol,
            source_addresses=source_addresses,
            source_port_ranges=source_port_ranges,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination_addresses: Optional[Sequence[str]] = None,
             destination_port_ranges: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentOutboundHeaderDestinationPortRange']] = None,
             protocol: Optional[str] = None,
             source_addresses: Optional[Sequence[str]] = None,
             source_port_ranges: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentOutboundHeaderSourcePortRange']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if destination_addresses is None and 'destinationAddresses' in kwargs:
            destination_addresses = kwargs['destinationAddresses']
        if destination_port_ranges is None and 'destinationPortRanges' in kwargs:
            destination_port_ranges = kwargs['destinationPortRanges']
        if source_addresses is None and 'sourceAddresses' in kwargs:
            source_addresses = kwargs['sourceAddresses']
        if source_port_ranges is None and 'sourcePortRanges' in kwargs:
            source_port_ranges = kwargs['sourcePortRanges']

        if destination_addresses is not None:
            _setter("destination_addresses", destination_addresses)
        if destination_port_ranges is not None:
            _setter("destination_port_ranges", destination_port_ranges)
        if protocol is not None:
            _setter("protocol", protocol)
        if source_addresses is not None:
            _setter("source_addresses", source_addresses)
        if source_port_ranges is not None:
            _setter("source_port_ranges", source_port_ranges)

    @property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "destination_addresses")

    @property
    @pulumi.getter(name="destinationPortRanges")
    def destination_port_ranges(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentOutboundHeaderDestinationPortRange']]:
        return pulumi.get(self, "destination_port_ranges")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "source_addresses")

    @property
    @pulumi.getter(name="sourcePortRanges")
    def source_port_ranges(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentOutboundHeaderSourcePortRange']]:
        return pulumi.get(self, "source_port_ranges")


@pulumi.output_type
class NetworkInsightsAnalysisReturnPathComponentOutboundHeaderDestinationPortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisReturnPathComponentOutboundHeaderDestinationPortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisReturnPathComponentOutboundHeaderDestinationPortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisReturnPathComponentOutboundHeaderDestinationPortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: Optional[int] = None,
                 to: Optional[int] = None):
        NetworkInsightsAnalysisReturnPathComponentOutboundHeaderDestinationPortRange._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            from_=from_,
            to=to,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             from_: Optional[int] = None,
             to: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if from_ is None and 'from' in kwargs:
            from_ = kwargs['from']

        if from_ is not None:
            _setter("from_", from_)
        if to is not None:
            _setter("to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[int]:
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> Optional[int]:
        return pulumi.get(self, "to")


@pulumi.output_type
class NetworkInsightsAnalysisReturnPathComponentOutboundHeaderSourcePortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisReturnPathComponentOutboundHeaderSourcePortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisReturnPathComponentOutboundHeaderSourcePortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisReturnPathComponentOutboundHeaderSourcePortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: Optional[int] = None,
                 to: Optional[int] = None):
        NetworkInsightsAnalysisReturnPathComponentOutboundHeaderSourcePortRange._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            from_=from_,
            to=to,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             from_: Optional[int] = None,
             to: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if from_ is None and 'from' in kwargs:
            from_ = kwargs['from']

        if from_ is not None:
            _setter("from_", from_)
        if to is not None:
            _setter("to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[int]:
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> Optional[int]:
        return pulumi.get(self, "to")


@pulumi.output_type
class NetworkInsightsAnalysisReturnPathComponentRouteTableRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationCidr":
            suggest = "destination_cidr"
        elif key == "destinationPrefixListId":
            suggest = "destination_prefix_list_id"
        elif key == "egressOnlyInternetGatewayId":
            suggest = "egress_only_internet_gateway_id"
        elif key == "gatewayId":
            suggest = "gateway_id"
        elif key == "instanceId":
            suggest = "instance_id"
        elif key == "natGatewayId":
            suggest = "nat_gateway_id"
        elif key == "networkInterfaceId":
            suggest = "network_interface_id"
        elif key == "transitGatewayId":
            suggest = "transit_gateway_id"
        elif key == "vpcPeeringConnectionId":
            suggest = "vpc_peering_connection_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisReturnPathComponentRouteTableRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisReturnPathComponentRouteTableRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisReturnPathComponentRouteTableRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_cidr: Optional[str] = None,
                 destination_prefix_list_id: Optional[str] = None,
                 egress_only_internet_gateway_id: Optional[str] = None,
                 gateway_id: Optional[str] = None,
                 instance_id: Optional[str] = None,
                 nat_gateway_id: Optional[str] = None,
                 network_interface_id: Optional[str] = None,
                 origin: Optional[str] = None,
                 transit_gateway_id: Optional[str] = None,
                 vpc_peering_connection_id: Optional[str] = None):
        NetworkInsightsAnalysisReturnPathComponentRouteTableRoute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination_cidr=destination_cidr,
            destination_prefix_list_id=destination_prefix_list_id,
            egress_only_internet_gateway_id=egress_only_internet_gateway_id,
            gateway_id=gateway_id,
            instance_id=instance_id,
            nat_gateway_id=nat_gateway_id,
            network_interface_id=network_interface_id,
            origin=origin,
            transit_gateway_id=transit_gateway_id,
            vpc_peering_connection_id=vpc_peering_connection_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination_cidr: Optional[str] = None,
             destination_prefix_list_id: Optional[str] = None,
             egress_only_internet_gateway_id: Optional[str] = None,
             gateway_id: Optional[str] = None,
             instance_id: Optional[str] = None,
             nat_gateway_id: Optional[str] = None,
             network_interface_id: Optional[str] = None,
             origin: Optional[str] = None,
             transit_gateway_id: Optional[str] = None,
             vpc_peering_connection_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if destination_cidr is None and 'destinationCidr' in kwargs:
            destination_cidr = kwargs['destinationCidr']
        if destination_prefix_list_id is None and 'destinationPrefixListId' in kwargs:
            destination_prefix_list_id = kwargs['destinationPrefixListId']
        if egress_only_internet_gateway_id is None and 'egressOnlyInternetGatewayId' in kwargs:
            egress_only_internet_gateway_id = kwargs['egressOnlyInternetGatewayId']
        if gateway_id is None and 'gatewayId' in kwargs:
            gateway_id = kwargs['gatewayId']
        if instance_id is None and 'instanceId' in kwargs:
            instance_id = kwargs['instanceId']
        if nat_gateway_id is None and 'natGatewayId' in kwargs:
            nat_gateway_id = kwargs['natGatewayId']
        if network_interface_id is None and 'networkInterfaceId' in kwargs:
            network_interface_id = kwargs['networkInterfaceId']
        if transit_gateway_id is None and 'transitGatewayId' in kwargs:
            transit_gateway_id = kwargs['transitGatewayId']
        if vpc_peering_connection_id is None and 'vpcPeeringConnectionId' in kwargs:
            vpc_peering_connection_id = kwargs['vpcPeeringConnectionId']

        if destination_cidr is not None:
            _setter("destination_cidr", destination_cidr)
        if destination_prefix_list_id is not None:
            _setter("destination_prefix_list_id", destination_prefix_list_id)
        if egress_only_internet_gateway_id is not None:
            _setter("egress_only_internet_gateway_id", egress_only_internet_gateway_id)
        if gateway_id is not None:
            _setter("gateway_id", gateway_id)
        if instance_id is not None:
            _setter("instance_id", instance_id)
        if nat_gateway_id is not None:
            _setter("nat_gateway_id", nat_gateway_id)
        if network_interface_id is not None:
            _setter("network_interface_id", network_interface_id)
        if origin is not None:
            _setter("origin", origin)
        if transit_gateway_id is not None:
            _setter("transit_gateway_id", transit_gateway_id)
        if vpc_peering_connection_id is not None:
            _setter("vpc_peering_connection_id", vpc_peering_connection_id)

    @property
    @pulumi.getter(name="destinationCidr")
    def destination_cidr(self) -> Optional[str]:
        return pulumi.get(self, "destination_cidr")

    @property
    @pulumi.getter(name="destinationPrefixListId")
    def destination_prefix_list_id(self) -> Optional[str]:
        return pulumi.get(self, "destination_prefix_list_id")

    @property
    @pulumi.getter(name="egressOnlyInternetGatewayId")
    def egress_only_internet_gateway_id(self) -> Optional[str]:
        return pulumi.get(self, "egress_only_internet_gateway_id")

    @property
    @pulumi.getter(name="gatewayId")
    def gateway_id(self) -> Optional[str]:
        return pulumi.get(self, "gateway_id")

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[str]:
        return pulumi.get(self, "instance_id")

    @property
    @pulumi.getter(name="natGatewayId")
    def nat_gateway_id(self) -> Optional[str]:
        return pulumi.get(self, "nat_gateway_id")

    @property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> Optional[str]:
        return pulumi.get(self, "network_interface_id")

    @property
    @pulumi.getter
    def origin(self) -> Optional[str]:
        return pulumi.get(self, "origin")

    @property
    @pulumi.getter(name="transitGatewayId")
    def transit_gateway_id(self) -> Optional[str]:
        return pulumi.get(self, "transit_gateway_id")

    @property
    @pulumi.getter(name="vpcPeeringConnectionId")
    def vpc_peering_connection_id(self) -> Optional[str]:
        return pulumi.get(self, "vpc_peering_connection_id")


@pulumi.output_type
class NetworkInsightsAnalysisReturnPathComponentSecurityGroupRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portRanges":
            suggest = "port_ranges"
        elif key == "prefixListId":
            suggest = "prefix_list_id"
        elif key == "securityGroupId":
            suggest = "security_group_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisReturnPathComponentSecurityGroupRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisReturnPathComponentSecurityGroupRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisReturnPathComponentSecurityGroupRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cidr: Optional[str] = None,
                 direction: Optional[str] = None,
                 port_ranges: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentSecurityGroupRulePortRange']] = None,
                 prefix_list_id: Optional[str] = None,
                 protocol: Optional[str] = None,
                 security_group_id: Optional[str] = None):
        NetworkInsightsAnalysisReturnPathComponentSecurityGroupRule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cidr=cidr,
            direction=direction,
            port_ranges=port_ranges,
            prefix_list_id=prefix_list_id,
            protocol=protocol,
            security_group_id=security_group_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cidr: Optional[str] = None,
             direction: Optional[str] = None,
             port_ranges: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentSecurityGroupRulePortRange']] = None,
             prefix_list_id: Optional[str] = None,
             protocol: Optional[str] = None,
             security_group_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if port_ranges is None and 'portRanges' in kwargs:
            port_ranges = kwargs['portRanges']
        if prefix_list_id is None and 'prefixListId' in kwargs:
            prefix_list_id = kwargs['prefixListId']
        if security_group_id is None and 'securityGroupId' in kwargs:
            security_group_id = kwargs['securityGroupId']

        if cidr is not None:
            _setter("cidr", cidr)
        if direction is not None:
            _setter("direction", direction)
        if port_ranges is not None:
            _setter("port_ranges", port_ranges)
        if prefix_list_id is not None:
            _setter("prefix_list_id", prefix_list_id)
        if protocol is not None:
            _setter("protocol", protocol)
        if security_group_id is not None:
            _setter("security_group_id", security_group_id)

    @property
    @pulumi.getter
    def cidr(self) -> Optional[str]:
        return pulumi.get(self, "cidr")

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentSecurityGroupRulePortRange']]:
        return pulumi.get(self, "port_ranges")

    @property
    @pulumi.getter(name="prefixListId")
    def prefix_list_id(self) -> Optional[str]:
        return pulumi.get(self, "prefix_list_id")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> Optional[str]:
        return pulumi.get(self, "security_group_id")


@pulumi.output_type
class NetworkInsightsAnalysisReturnPathComponentSecurityGroupRulePortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisReturnPathComponentSecurityGroupRulePortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisReturnPathComponentSecurityGroupRulePortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisReturnPathComponentSecurityGroupRulePortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: Optional[int] = None,
                 to: Optional[int] = None):
        NetworkInsightsAnalysisReturnPathComponentSecurityGroupRulePortRange._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            from_=from_,
            to=to,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             from_: Optional[int] = None,
             to: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if from_ is None and 'from' in kwargs:
            from_ = kwargs['from']

        if from_ is not None:
            _setter("from_", from_)
        if to is not None:
            _setter("to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[int]:
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> Optional[int]:
        return pulumi.get(self, "to")


@pulumi.output_type
class NetworkInsightsAnalysisReturnPathComponentSourceVpc(dict):
    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str arn: ARN of the Network Insights Analysis.
        :param str id: ID of the Network Insights Analysis.
        """
        NetworkInsightsAnalysisReturnPathComponentSourceVpc._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if arn is not None:
            _setter("arn", arn)
        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisReturnPathComponentSubnet(dict):
    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str arn: ARN of the Network Insights Analysis.
        :param str id: ID of the Network Insights Analysis.
        """
        NetworkInsightsAnalysisReturnPathComponentSubnet._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if arn is not None:
            _setter("arn", arn)
        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisReturnPathComponentTransitGateway(dict):
    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str arn: ARN of the Network Insights Analysis.
        :param str id: ID of the Network Insights Analysis.
        """
        NetworkInsightsAnalysisReturnPathComponentTransitGateway._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if arn is not None:
            _setter("arn", arn)
        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisReturnPathComponentTransitGatewayRouteTableRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attachmentId":
            suggest = "attachment_id"
        elif key == "destinationCidr":
            suggest = "destination_cidr"
        elif key == "prefixListId":
            suggest = "prefix_list_id"
        elif key == "resourceId":
            suggest = "resource_id"
        elif key == "resourceType":
            suggest = "resource_type"
        elif key == "routeOrigin":
            suggest = "route_origin"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisReturnPathComponentTransitGatewayRouteTableRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisReturnPathComponentTransitGatewayRouteTableRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisReturnPathComponentTransitGatewayRouteTableRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attachment_id: Optional[str] = None,
                 destination_cidr: Optional[str] = None,
                 prefix_list_id: Optional[str] = None,
                 resource_id: Optional[str] = None,
                 resource_type: Optional[str] = None,
                 route_origin: Optional[str] = None,
                 state: Optional[str] = None):
        NetworkInsightsAnalysisReturnPathComponentTransitGatewayRouteTableRoute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            attachment_id=attachment_id,
            destination_cidr=destination_cidr,
            prefix_list_id=prefix_list_id,
            resource_id=resource_id,
            resource_type=resource_type,
            route_origin=route_origin,
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             attachment_id: Optional[str] = None,
             destination_cidr: Optional[str] = None,
             prefix_list_id: Optional[str] = None,
             resource_id: Optional[str] = None,
             resource_type: Optional[str] = None,
             route_origin: Optional[str] = None,
             state: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if attachment_id is None and 'attachmentId' in kwargs:
            attachment_id = kwargs['attachmentId']
        if destination_cidr is None and 'destinationCidr' in kwargs:
            destination_cidr = kwargs['destinationCidr']
        if prefix_list_id is None and 'prefixListId' in kwargs:
            prefix_list_id = kwargs['prefixListId']
        if resource_id is None and 'resourceId' in kwargs:
            resource_id = kwargs['resourceId']
        if resource_type is None and 'resourceType' in kwargs:
            resource_type = kwargs['resourceType']
        if route_origin is None and 'routeOrigin' in kwargs:
            route_origin = kwargs['routeOrigin']

        if attachment_id is not None:
            _setter("attachment_id", attachment_id)
        if destination_cidr is not None:
            _setter("destination_cidr", destination_cidr)
        if prefix_list_id is not None:
            _setter("prefix_list_id", prefix_list_id)
        if resource_id is not None:
            _setter("resource_id", resource_id)
        if resource_type is not None:
            _setter("resource_type", resource_type)
        if route_origin is not None:
            _setter("route_origin", route_origin)
        if state is not None:
            _setter("state", state)

    @property
    @pulumi.getter(name="attachmentId")
    def attachment_id(self) -> Optional[str]:
        return pulumi.get(self, "attachment_id")

    @property
    @pulumi.getter(name="destinationCidr")
    def destination_cidr(self) -> Optional[str]:
        return pulumi.get(self, "destination_cidr")

    @property
    @pulumi.getter(name="prefixListId")
    def prefix_list_id(self) -> Optional[str]:
        return pulumi.get(self, "prefix_list_id")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[str]:
        return pulumi.get(self, "resource_id")

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[str]:
        return pulumi.get(self, "resource_type")

    @property
    @pulumi.getter(name="routeOrigin")
    def route_origin(self) -> Optional[str]:
        return pulumi.get(self, "route_origin")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        return pulumi.get(self, "state")


@pulumi.output_type
class NetworkInsightsAnalysisReturnPathComponentVpc(dict):
    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str arn: ARN of the Network Insights Analysis.
        :param str id: ID of the Network Insights Analysis.
        """
        NetworkInsightsAnalysisReturnPathComponentVpc._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if arn is not None:
            _setter("arn", arn)
        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        ARN of the Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the Network Insights Analysis.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInterfaceAttachment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceIndex":
            suggest = "device_index"
        elif key == "attachmentId":
            suggest = "attachment_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInterfaceAttachment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInterfaceAttachment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInterfaceAttachment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_index: int,
                 instance: str,
                 attachment_id: Optional[str] = None):
        """
        :param int device_index: Integer to define the devices index.
        :param str instance: ID of the instance to attach to.
        """
        NetworkInterfaceAttachment._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            device_index=device_index,
            instance=instance,
            attachment_id=attachment_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             device_index: Optional[int] = None,
             instance: Optional[str] = None,
             attachment_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if device_index is None and 'deviceIndex' in kwargs:
            device_index = kwargs['deviceIndex']
        if device_index is None:
            raise TypeError("Missing 'device_index' argument")
        if instance is None:
            raise TypeError("Missing 'instance' argument")
        if attachment_id is None and 'attachmentId' in kwargs:
            attachment_id = kwargs['attachmentId']

        _setter("device_index", device_index)
        _setter("instance", instance)
        if attachment_id is not None:
            _setter("attachment_id", attachment_id)

    @property
    @pulumi.getter(name="deviceIndex")
    def device_index(self) -> int:
        """
        Integer to define the devices index.
        """
        return pulumi.get(self, "device_index")

    @property
    @pulumi.getter
    def instance(self) -> str:
        """
        ID of the instance to attach to.
        """
        return pulumi.get(self, "instance")

    @property
    @pulumi.getter(name="attachmentId")
    def attachment_id(self) -> Optional[str]:
        return pulumi.get(self, "attachment_id")


@pulumi.output_type
class PeeringConnectionOptionsAccepter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowRemoteVpcDnsResolution":
            suggest = "allow_remote_vpc_dns_resolution"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PeeringConnectionOptionsAccepter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PeeringConnectionOptionsAccepter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PeeringConnectionOptionsAccepter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_remote_vpc_dns_resolution: Optional[bool] = None):
        """
        :param bool allow_remote_vpc_dns_resolution: Allow a local VPC to resolve public DNS hostnames to private IP addresses when queried from instances in the peer VPC.
        """
        PeeringConnectionOptionsAccepter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allow_remote_vpc_dns_resolution=allow_remote_vpc_dns_resolution,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allow_remote_vpc_dns_resolution: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if allow_remote_vpc_dns_resolution is None and 'allowRemoteVpcDnsResolution' in kwargs:
            allow_remote_vpc_dns_resolution = kwargs['allowRemoteVpcDnsResolution']

        if allow_remote_vpc_dns_resolution is not None:
            _setter("allow_remote_vpc_dns_resolution", allow_remote_vpc_dns_resolution)

    @property
    @pulumi.getter(name="allowRemoteVpcDnsResolution")
    def allow_remote_vpc_dns_resolution(self) -> Optional[bool]:
        """
        Allow a local VPC to resolve public DNS hostnames to private IP addresses when queried from instances in the peer VPC.
        """
        return pulumi.get(self, "allow_remote_vpc_dns_resolution")


@pulumi.output_type
class PeeringConnectionOptionsRequester(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowRemoteVpcDnsResolution":
            suggest = "allow_remote_vpc_dns_resolution"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PeeringConnectionOptionsRequester. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PeeringConnectionOptionsRequester.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PeeringConnectionOptionsRequester.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_remote_vpc_dns_resolution: Optional[bool] = None):
        """
        :param bool allow_remote_vpc_dns_resolution: Allow a local VPC to resolve public DNS hostnames to private IP addresses when queried from instances in the peer VPC.
        """
        PeeringConnectionOptionsRequester._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allow_remote_vpc_dns_resolution=allow_remote_vpc_dns_resolution,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allow_remote_vpc_dns_resolution: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if allow_remote_vpc_dns_resolution is None and 'allowRemoteVpcDnsResolution' in kwargs:
            allow_remote_vpc_dns_resolution = kwargs['allowRemoteVpcDnsResolution']

        if allow_remote_vpc_dns_resolution is not None:
            _setter("allow_remote_vpc_dns_resolution", allow_remote_vpc_dns_resolution)

    @property
    @pulumi.getter(name="allowRemoteVpcDnsResolution")
    def allow_remote_vpc_dns_resolution(self) -> Optional[bool]:
        """
        Allow a local VPC to resolve public DNS hostnames to private IP addresses when queried from instances in the peer VPC.
        """
        return pulumi.get(self, "allow_remote_vpc_dns_resolution")


@pulumi.output_type
class RouteTableRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "carrierGatewayId":
            suggest = "carrier_gateway_id"
        elif key == "cidrBlock":
            suggest = "cidr_block"
        elif key == "coreNetworkArn":
            suggest = "core_network_arn"
        elif key == "destinationPrefixListId":
            suggest = "destination_prefix_list_id"
        elif key == "egressOnlyGatewayId":
            suggest = "egress_only_gateway_id"
        elif key == "gatewayId":
            suggest = "gateway_id"
        elif key == "ipv6CidrBlock":
            suggest = "ipv6_cidr_block"
        elif key == "localGatewayId":
            suggest = "local_gateway_id"
        elif key == "natGatewayId":
            suggest = "nat_gateway_id"
        elif key == "networkInterfaceId":
            suggest = "network_interface_id"
        elif key == "transitGatewayId":
            suggest = "transit_gateway_id"
        elif key == "vpcEndpointId":
            suggest = "vpc_endpoint_id"
        elif key == "vpcPeeringConnectionId":
            suggest = "vpc_peering_connection_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RouteTableRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RouteTableRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RouteTableRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 carrier_gateway_id: Optional[str] = None,
                 cidr_block: Optional[str] = None,
                 core_network_arn: Optional[str] = None,
                 destination_prefix_list_id: Optional[str] = None,
                 egress_only_gateway_id: Optional[str] = None,
                 gateway_id: Optional[str] = None,
                 ipv6_cidr_block: Optional[str] = None,
                 local_gateway_id: Optional[str] = None,
                 nat_gateway_id: Optional[str] = None,
                 network_interface_id: Optional[str] = None,
                 transit_gateway_id: Optional[str] = None,
                 vpc_endpoint_id: Optional[str] = None,
                 vpc_peering_connection_id: Optional[str] = None):
        """
        :param str carrier_gateway_id: Identifier of a carrier gateway. This attribute can only be used when the VPC contains a subnet which is associated with a Wavelength Zone.
        :param str cidr_block: The CIDR block of the route.
        :param str core_network_arn: The Amazon Resource Name (ARN) of a core network.
        :param str destination_prefix_list_id: The ID of a managed prefix list destination of the route.
               
               One of the following target arguments must be supplied:
        :param str egress_only_gateway_id: Identifier of a VPC Egress Only Internet Gateway.
        :param str gateway_id: Identifier of a VPC internet gateway, virtual private gateway, or `local`. `local` routes cannot be created but can be adopted or imported. See the example above.
        :param str ipv6_cidr_block: The Ipv6 CIDR block of the route.
        :param str local_gateway_id: Identifier of a Outpost local gateway.
        :param str nat_gateway_id: Identifier of a VPC NAT gateway.
        :param str network_interface_id: Identifier of an EC2 network interface.
        :param str transit_gateway_id: Identifier of an EC2 Transit Gateway.
        :param str vpc_endpoint_id: Identifier of a VPC Endpoint.
        :param str vpc_peering_connection_id: Identifier of a VPC peering connection.
               
               Note that the default route, mapping the VPC's CIDR block to "local", is created implicitly and cannot be specified.
        """
        RouteTableRoute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            carrier_gateway_id=carrier_gateway_id,
            cidr_block=cidr_block,
            core_network_arn=core_network_arn,
            destination_prefix_list_id=destination_prefix_list_id,
            egress_only_gateway_id=egress_only_gateway_id,
            gateway_id=gateway_id,
            ipv6_cidr_block=ipv6_cidr_block,
            local_gateway_id=local_gateway_id,
            nat_gateway_id=nat_gateway_id,
            network_interface_id=network_interface_id,
            transit_gateway_id=transit_gateway_id,
            vpc_endpoint_id=vpc_endpoint_id,
            vpc_peering_connection_id=vpc_peering_connection_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             carrier_gateway_id: Optional[str] = None,
             cidr_block: Optional[str] = None,
             core_network_arn: Optional[str] = None,
             destination_prefix_list_id: Optional[str] = None,
             egress_only_gateway_id: Optional[str] = None,
             gateway_id: Optional[str] = None,
             ipv6_cidr_block: Optional[str] = None,
             local_gateway_id: Optional[str] = None,
             nat_gateway_id: Optional[str] = None,
             network_interface_id: Optional[str] = None,
             transit_gateway_id: Optional[str] = None,
             vpc_endpoint_id: Optional[str] = None,
             vpc_peering_connection_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if carrier_gateway_id is None and 'carrierGatewayId' in kwargs:
            carrier_gateway_id = kwargs['carrierGatewayId']
        if cidr_block is None and 'cidrBlock' in kwargs:
            cidr_block = kwargs['cidrBlock']
        if core_network_arn is None and 'coreNetworkArn' in kwargs:
            core_network_arn = kwargs['coreNetworkArn']
        if destination_prefix_list_id is None and 'destinationPrefixListId' in kwargs:
            destination_prefix_list_id = kwargs['destinationPrefixListId']
        if egress_only_gateway_id is None and 'egressOnlyGatewayId' in kwargs:
            egress_only_gateway_id = kwargs['egressOnlyGatewayId']
        if gateway_id is None and 'gatewayId' in kwargs:
            gateway_id = kwargs['gatewayId']
        if ipv6_cidr_block is None and 'ipv6CidrBlock' in kwargs:
            ipv6_cidr_block = kwargs['ipv6CidrBlock']
        if local_gateway_id is None and 'localGatewayId' in kwargs:
            local_gateway_id = kwargs['localGatewayId']
        if nat_gateway_id is None and 'natGatewayId' in kwargs:
            nat_gateway_id = kwargs['natGatewayId']
        if network_interface_id is None and 'networkInterfaceId' in kwargs:
            network_interface_id = kwargs['networkInterfaceId']
        if transit_gateway_id is None and 'transitGatewayId' in kwargs:
            transit_gateway_id = kwargs['transitGatewayId']
        if vpc_endpoint_id is None and 'vpcEndpointId' in kwargs:
            vpc_endpoint_id = kwargs['vpcEndpointId']
        if vpc_peering_connection_id is None and 'vpcPeeringConnectionId' in kwargs:
            vpc_peering_connection_id = kwargs['vpcPeeringConnectionId']

        if carrier_gateway_id is not None:
            _setter("carrier_gateway_id", carrier_gateway_id)
        if cidr_block is not None:
            _setter("cidr_block", cidr_block)
        if core_network_arn is not None:
            _setter("core_network_arn", core_network_arn)
        if destination_prefix_list_id is not None:
            _setter("destination_prefix_list_id", destination_prefix_list_id)
        if egress_only_gateway_id is not None:
            _setter("egress_only_gateway_id", egress_only_gateway_id)
        if gateway_id is not None:
            _setter("gateway_id", gateway_id)
        if ipv6_cidr_block is not None:
            _setter("ipv6_cidr_block", ipv6_cidr_block)
        if local_gateway_id is not None:
            _setter("local_gateway_id", local_gateway_id)
        if nat_gateway_id is not None:
            _setter("nat_gateway_id", nat_gateway_id)
        if network_interface_id is not None:
            _setter("network_interface_id", network_interface_id)
        if transit_gateway_id is not None:
            _setter("transit_gateway_id", transit_gateway_id)
        if vpc_endpoint_id is not None:
            _setter("vpc_endpoint_id", vpc_endpoint_id)
        if vpc_peering_connection_id is not None:
            _setter("vpc_peering_connection_id", vpc_peering_connection_id)

    @property
    @pulumi.getter(name="carrierGatewayId")
    def carrier_gateway_id(self) -> Optional[str]:
        """
        Identifier of a carrier gateway. This attribute can only be used when the VPC contains a subnet which is associated with a Wavelength Zone.
        """
        return pulumi.get(self, "carrier_gateway_id")

    @property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> Optional[str]:
        """
        The CIDR block of the route.
        """
        return pulumi.get(self, "cidr_block")

    @property
    @pulumi.getter(name="coreNetworkArn")
    def core_network_arn(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) of a core network.
        """
        return pulumi.get(self, "core_network_arn")

    @property
    @pulumi.getter(name="destinationPrefixListId")
    def destination_prefix_list_id(self) -> Optional[str]:
        """
        The ID of a managed prefix list destination of the route.

        One of the following target arguments must be supplied:
        """
        return pulumi.get(self, "destination_prefix_list_id")

    @property
    @pulumi.getter(name="egressOnlyGatewayId")
    def egress_only_gateway_id(self) -> Optional[str]:
        """
        Identifier of a VPC Egress Only Internet Gateway.
        """
        return pulumi.get(self, "egress_only_gateway_id")

    @property
    @pulumi.getter(name="gatewayId")
    def gateway_id(self) -> Optional[str]:
        """
        Identifier of a VPC internet gateway, virtual private gateway, or `local`. `local` routes cannot be created but can be adopted or imported. See the example above.
        """
        return pulumi.get(self, "gateway_id")

    @property
    @pulumi.getter(name="ipv6CidrBlock")
    def ipv6_cidr_block(self) -> Optional[str]:
        """
        The Ipv6 CIDR block of the route.
        """
        return pulumi.get(self, "ipv6_cidr_block")

    @property
    @pulumi.getter(name="localGatewayId")
    def local_gateway_id(self) -> Optional[str]:
        """
        Identifier of a Outpost local gateway.
        """
        return pulumi.get(self, "local_gateway_id")

    @property
    @pulumi.getter(name="natGatewayId")
    def nat_gateway_id(self) -> Optional[str]:
        """
        Identifier of a VPC NAT gateway.
        """
        return pulumi.get(self, "nat_gateway_id")

    @property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> Optional[str]:
        """
        Identifier of an EC2 network interface.
        """
        return pulumi.get(self, "network_interface_id")

    @property
    @pulumi.getter(name="transitGatewayId")
    def transit_gateway_id(self) -> Optional[str]:
        """
        Identifier of an EC2 Transit Gateway.
        """
        return pulumi.get(self, "transit_gateway_id")

    @property
    @pulumi.getter(name="vpcEndpointId")
    def vpc_endpoint_id(self) -> Optional[str]:
        """
        Identifier of a VPC Endpoint.
        """
        return pulumi.get(self, "vpc_endpoint_id")

    @property
    @pulumi.getter(name="vpcPeeringConnectionId")
    def vpc_peering_connection_id(self) -> Optional[str]:
        """
        Identifier of a VPC peering connection.

        Note that the default route, mapping the VPC's CIDR block to "local", is created implicitly and cannot be specified.
        """
        return pulumi.get(self, "vpc_peering_connection_id")


@pulumi.output_type
class SecurityGroupEgress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromPort":
            suggest = "from_port"
        elif key == "toPort":
            suggest = "to_port"
        elif key == "cidrBlocks":
            suggest = "cidr_blocks"
        elif key == "ipv6CidrBlocks":
            suggest = "ipv6_cidr_blocks"
        elif key == "prefixListIds":
            suggest = "prefix_list_ids"
        elif key == "securityGroups":
            suggest = "security_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityGroupEgress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityGroupEgress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityGroupEgress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_port: int,
                 protocol: str,
                 to_port: int,
                 cidr_blocks: Optional[Sequence[str]] = None,
                 description: Optional[str] = None,
                 ipv6_cidr_blocks: Optional[Sequence[str]] = None,
                 prefix_list_ids: Optional[Sequence[str]] = None,
                 security_groups: Optional[Sequence[str]] = None,
                 self: Optional[bool] = None):
        """
        :param int from_port: Start port (or ICMP type number if protocol is `icmp`)
        :param str protocol: Protocol. If you select a protocol of `-1` (semantically equivalent to `all`, which is not a valid value here), you must specify a `from_port` and `to_port` equal to 0.  The supported values are defined in the `IpProtocol` argument in the [IpPermission](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_IpPermission.html) API reference.
        :param int to_port: End range port (or ICMP code if protocol is `icmp`).
               
               The following arguments are optional:
               
               > **Note** Although `cidr_blocks`, `ipv6_cidr_blocks`, `prefix_list_ids`, and `security_groups` are all marked as optional, you _must_ provide one of them in order to configure the destination of the traffic.
        :param Sequence[str] cidr_blocks: List of CIDR blocks.
        :param str description: Description of this egress rule.
        :param Sequence[str] ipv6_cidr_blocks: List of IPv6 CIDR blocks.
        :param Sequence[str] prefix_list_ids: List of Prefix List IDs.
        :param Sequence[str] security_groups: List of security groups. A group name can be used relative to the default VPC. Otherwise, group ID.
        :param bool self: Whether the security group itself will be added as a source to this egress rule.
        """
        SecurityGroupEgress._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            from_port=from_port,
            protocol=protocol,
            to_port=to_port,
            cidr_blocks=cidr_blocks,
            description=description,
            ipv6_cidr_blocks=ipv6_cidr_blocks,
            prefix_list_ids=prefix_list_ids,
            security_groups=security_groups,
            self=self,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             from_port: Optional[int] = None,
             protocol: Optional[str] = None,
             to_port: Optional[int] = None,
             cidr_blocks: Optional[Sequence[str]] = None,
             description: Optional[str] = None,
             ipv6_cidr_blocks: Optional[Sequence[str]] = None,
             prefix_list_ids: Optional[Sequence[str]] = None,
             security_groups: Optional[Sequence[str]] = None,
             self: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if from_port is None and 'fromPort' in kwargs:
            from_port = kwargs['fromPort']
        if from_port is None:
            raise TypeError("Missing 'from_port' argument")
        if protocol is None:
            raise TypeError("Missing 'protocol' argument")
        if to_port is None and 'toPort' in kwargs:
            to_port = kwargs['toPort']
        if to_port is None:
            raise TypeError("Missing 'to_port' argument")
        if cidr_blocks is None and 'cidrBlocks' in kwargs:
            cidr_blocks = kwargs['cidrBlocks']
        if ipv6_cidr_blocks is None and 'ipv6CidrBlocks' in kwargs:
            ipv6_cidr_blocks = kwargs['ipv6CidrBlocks']
        if prefix_list_ids is None and 'prefixListIds' in kwargs:
            prefix_list_ids = kwargs['prefixListIds']
        if security_groups is None and 'securityGroups' in kwargs:
            security_groups = kwargs['securityGroups']

        _setter("from_port", from_port)
        _setter("protocol", protocol)
        _setter("to_port", to_port)
        if cidr_blocks is not None:
            _setter("cidr_blocks", cidr_blocks)
        if description is not None:
            _setter("description", description)
        if ipv6_cidr_blocks is not None:
            _setter("ipv6_cidr_blocks", ipv6_cidr_blocks)
        if prefix_list_ids is not None:
            _setter("prefix_list_ids", prefix_list_ids)
        if security_groups is not None:
            _setter("security_groups", security_groups)
        if self is not None:
            _setter("self", self)

    @property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> int:
        """
        Start port (or ICMP type number if protocol is `icmp`)
        """
        return pulumi.get(self, "from_port")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        Protocol. If you select a protocol of `-1` (semantically equivalent to `all`, which is not a valid value here), you must specify a `from_port` and `to_port` equal to 0.  The supported values are defined in the `IpProtocol` argument in the [IpPermission](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_IpPermission.html) API reference.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="toPort")
    def to_port(self) -> int:
        """
        End range port (or ICMP code if protocol is `icmp`).

        The following arguments are optional:

        > **Note** Although `cidr_blocks`, `ipv6_cidr_blocks`, `prefix_list_ids`, and `security_groups` are all marked as optional, you _must_ provide one of them in order to configure the destination of the traffic.
        """
        return pulumi.get(self, "to_port")

    @property
    @pulumi.getter(name="cidrBlocks")
    def cidr_blocks(self) -> Optional[Sequence[str]]:
        """
        List of CIDR blocks.
        """
        return pulumi.get(self, "cidr_blocks")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of this egress rule.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="ipv6CidrBlocks")
    def ipv6_cidr_blocks(self) -> Optional[Sequence[str]]:
        """
        List of IPv6 CIDR blocks.
        """
        return pulumi.get(self, "ipv6_cidr_blocks")

    @property
    @pulumi.getter(name="prefixListIds")
    def prefix_list_ids(self) -> Optional[Sequence[str]]:
        """
        List of Prefix List IDs.
        """
        return pulumi.get(self, "prefix_list_ids")

    @property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[Sequence[str]]:
        """
        List of security groups. A group name can be used relative to the default VPC. Otherwise, group ID.
        """
        return pulumi.get(self, "security_groups")

    @property
    @pulumi.getter
    def self(self) -> Optional[bool]:
        """
        Whether the security group itself will be added as a source to this egress rule.
        """
        return pulumi.get(self, "self")


@pulumi.output_type
class SecurityGroupIngress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromPort":
            suggest = "from_port"
        elif key == "toPort":
            suggest = "to_port"
        elif key == "cidrBlocks":
            suggest = "cidr_blocks"
        elif key == "ipv6CidrBlocks":
            suggest = "ipv6_cidr_blocks"
        elif key == "prefixListIds":
            suggest = "prefix_list_ids"
        elif key == "securityGroups":
            suggest = "security_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityGroupIngress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityGroupIngress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityGroupIngress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_port: int,
                 protocol: str,
                 to_port: int,
                 cidr_blocks: Optional[Sequence[str]] = None,
                 description: Optional[str] = None,
                 ipv6_cidr_blocks: Optional[Sequence[str]] = None,
                 prefix_list_ids: Optional[Sequence[str]] = None,
                 security_groups: Optional[Sequence[str]] = None,
                 self: Optional[bool] = None):
        """
        :param int from_port: Start port (or ICMP type number if protocol is `icmp` or `icmpv6`).
        :param str protocol: Protocol. If you select a protocol of `-1` (semantically equivalent to `all`, which is not a valid value here), you must specify a `from_port` and `to_port` equal to 0.  The supported values are defined in the `IpProtocol` argument on the [IpPermission](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_IpPermission.html) API reference.
               
               The following arguments are optional:
               
               > **Note** Although `cidr_blocks`, `ipv6_cidr_blocks`, `prefix_list_ids`, and `security_groups` are all marked as optional, you _must_ provide one of them in order to configure the source of the traffic.
        :param int to_port: End range port (or ICMP code if protocol is `icmp`).
        :param Sequence[str] cidr_blocks: List of CIDR blocks.
        :param str description: Description of this ingress rule.
        :param Sequence[str] ipv6_cidr_blocks: List of IPv6 CIDR blocks.
        :param Sequence[str] prefix_list_ids: List of Prefix List IDs.
        :param Sequence[str] security_groups: List of security groups. A group name can be used relative to the default VPC. Otherwise, group ID.
        :param bool self: Whether the security group itself will be added as a source to this ingress rule.
        """
        SecurityGroupIngress._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            from_port=from_port,
            protocol=protocol,
            to_port=to_port,
            cidr_blocks=cidr_blocks,
            description=description,
            ipv6_cidr_blocks=ipv6_cidr_blocks,
            prefix_list_ids=prefix_list_ids,
            security_groups=security_groups,
            self=self,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             from_port: Optional[int] = None,
             protocol: Optional[str] = None,
             to_port: Optional[int] = None,
             cidr_blocks: Optional[Sequence[str]] = None,
             description: Optional[str] = None,
             ipv6_cidr_blocks: Optional[Sequence[str]] = None,
             prefix_list_ids: Optional[Sequence[str]] = None,
             security_groups: Optional[Sequence[str]] = None,
             self: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if from_port is None and 'fromPort' in kwargs:
            from_port = kwargs['fromPort']
        if from_port is None:
            raise TypeError("Missing 'from_port' argument")
        if protocol is None:
            raise TypeError("Missing 'protocol' argument")
        if to_port is None and 'toPort' in kwargs:
            to_port = kwargs['toPort']
        if to_port is None:
            raise TypeError("Missing 'to_port' argument")
        if cidr_blocks is None and 'cidrBlocks' in kwargs:
            cidr_blocks = kwargs['cidrBlocks']
        if ipv6_cidr_blocks is None and 'ipv6CidrBlocks' in kwargs:
            ipv6_cidr_blocks = kwargs['ipv6CidrBlocks']
        if prefix_list_ids is None and 'prefixListIds' in kwargs:
            prefix_list_ids = kwargs['prefixListIds']
        if security_groups is None and 'securityGroups' in kwargs:
            security_groups = kwargs['securityGroups']

        _setter("from_port", from_port)
        _setter("protocol", protocol)
        _setter("to_port", to_port)
        if cidr_blocks is not None:
            _setter("cidr_blocks", cidr_blocks)
        if description is not None:
            _setter("description", description)
        if ipv6_cidr_blocks is not None:
            _setter("ipv6_cidr_blocks", ipv6_cidr_blocks)
        if prefix_list_ids is not None:
            _setter("prefix_list_ids", prefix_list_ids)
        if security_groups is not None:
            _setter("security_groups", security_groups)
        if self is not None:
            _setter("self", self)

    @property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> int:
        """
        Start port (or ICMP type number if protocol is `icmp` or `icmpv6`).
        """
        return pulumi.get(self, "from_port")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        Protocol. If you select a protocol of `-1` (semantically equivalent to `all`, which is not a valid value here), you must specify a `from_port` and `to_port` equal to 0.  The supported values are defined in the `IpProtocol` argument on the [IpPermission](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_IpPermission.html) API reference.

        The following arguments are optional:

        > **Note** Although `cidr_blocks`, `ipv6_cidr_blocks`, `prefix_list_ids`, and `security_groups` are all marked as optional, you _must_ provide one of them in order to configure the source of the traffic.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="toPort")
    def to_port(self) -> int:
        """
        End range port (or ICMP code if protocol is `icmp`).
        """
        return pulumi.get(self, "to_port")

    @property
    @pulumi.getter(name="cidrBlocks")
    def cidr_blocks(self) -> Optional[Sequence[str]]:
        """
        List of CIDR blocks.
        """
        return pulumi.get(self, "cidr_blocks")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of this ingress rule.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="ipv6CidrBlocks")
    def ipv6_cidr_blocks(self) -> Optional[Sequence[str]]:
        """
        List of IPv6 CIDR blocks.
        """
        return pulumi.get(self, "ipv6_cidr_blocks")

    @property
    @pulumi.getter(name="prefixListIds")
    def prefix_list_ids(self) -> Optional[Sequence[str]]:
        """
        List of Prefix List IDs.
        """
        return pulumi.get(self, "prefix_list_ids")

    @property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[Sequence[str]]:
        """
        List of security groups. A group name can be used relative to the default VPC. Otherwise, group ID.
        """
        return pulumi.get(self, "security_groups")

    @property
    @pulumi.getter
    def self(self) -> Optional[bool]:
        """
        Whether the security group itself will be added as a source to this ingress rule.
        """
        return pulumi.get(self, "self")


@pulumi.output_type
class SpotFleetRequestLaunchSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceType":
            suggest = "instance_type"
        elif key == "associatePublicIpAddress":
            suggest = "associate_public_ip_address"
        elif key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "ebsBlockDevices":
            suggest = "ebs_block_devices"
        elif key == "ebsOptimized":
            suggest = "ebs_optimized"
        elif key == "ephemeralBlockDevices":
            suggest = "ephemeral_block_devices"
        elif key == "iamInstanceProfile":
            suggest = "iam_instance_profile"
        elif key == "iamInstanceProfileArn":
            suggest = "iam_instance_profile_arn"
        elif key == "keyName":
            suggest = "key_name"
        elif key == "placementGroup":
            suggest = "placement_group"
        elif key == "placementTenancy":
            suggest = "placement_tenancy"
        elif key == "rootBlockDevices":
            suggest = "root_block_devices"
        elif key == "spotPrice":
            suggest = "spot_price"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "userData":
            suggest = "user_data"
        elif key == "vpcSecurityGroupIds":
            suggest = "vpc_security_group_ids"
        elif key == "weightedCapacity":
            suggest = "weighted_capacity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetRequestLaunchSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetRequestLaunchSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetRequestLaunchSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ami: str,
                 instance_type: str,
                 associate_public_ip_address: Optional[bool] = None,
                 availability_zone: Optional[str] = None,
                 ebs_block_devices: Optional[Sequence['outputs.SpotFleetRequestLaunchSpecificationEbsBlockDevice']] = None,
                 ebs_optimized: Optional[bool] = None,
                 ephemeral_block_devices: Optional[Sequence['outputs.SpotFleetRequestLaunchSpecificationEphemeralBlockDevice']] = None,
                 iam_instance_profile: Optional[str] = None,
                 iam_instance_profile_arn: Optional[str] = None,
                 key_name: Optional[str] = None,
                 monitoring: Optional[bool] = None,
                 placement_group: Optional[str] = None,
                 placement_tenancy: Optional[str] = None,
                 root_block_devices: Optional[Sequence['outputs.SpotFleetRequestLaunchSpecificationRootBlockDevice']] = None,
                 spot_price: Optional[str] = None,
                 subnet_id: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 user_data: Optional[str] = None,
                 vpc_security_group_ids: Optional[Sequence[str]] = None,
                 weighted_capacity: Optional[str] = None):
        """
        :param str instance_type: The type of instance to request.
        :param str availability_zone: The availability zone in which to place the request.
        :param str spot_price: The maximum bid price per unit hour.
        :param str subnet_id: The subnet in which to launch the requested instance.
        :param Mapping[str, str] tags: A map of tags to assign to the resource. .If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        :param str weighted_capacity: The capacity added to the fleet by a fulfilled request.
        """
        SpotFleetRequestLaunchSpecification._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ami=ami,
            instance_type=instance_type,
            associate_public_ip_address=associate_public_ip_address,
            availability_zone=availability_zone,
            ebs_block_devices=ebs_block_devices,
            ebs_optimized=ebs_optimized,
            ephemeral_block_devices=ephemeral_block_devices,
            iam_instance_profile=iam_instance_profile,
            iam_instance_profile_arn=iam_instance_profile_arn,
            key_name=key_name,
            monitoring=monitoring,
            placement_group=placement_group,
            placement_tenancy=placement_tenancy,
            root_block_devices=root_block_devices,
            spot_price=spot_price,
            subnet_id=subnet_id,
            tags=tags,
            user_data=user_data,
            vpc_security_group_ids=vpc_security_group_ids,
            weighted_capacity=weighted_capacity,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ami: Optional[str] = None,
             instance_type: Optional[str] = None,
             associate_public_ip_address: Optional[bool] = None,
             availability_zone: Optional[str] = None,
             ebs_block_devices: Optional[Sequence['outputs.SpotFleetRequestLaunchSpecificationEbsBlockDevice']] = None,
             ebs_optimized: Optional[bool] = None,
             ephemeral_block_devices: Optional[Sequence['outputs.SpotFleetRequestLaunchSpecificationEphemeralBlockDevice']] = None,
             iam_instance_profile: Optional[str] = None,
             iam_instance_profile_arn: Optional[str] = None,
             key_name: Optional[str] = None,
             monitoring: Optional[bool] = None,
             placement_group: Optional[str] = None,
             placement_tenancy: Optional[str] = None,
             root_block_devices: Optional[Sequence['outputs.SpotFleetRequestLaunchSpecificationRootBlockDevice']] = None,
             spot_price: Optional[str] = None,
             subnet_id: Optional[str] = None,
             tags: Optional[Mapping[str, str]] = None,
             user_data: Optional[str] = None,
             vpc_security_group_ids: Optional[Sequence[str]] = None,
             weighted_capacity: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ami is None:
            raise TypeError("Missing 'ami' argument")
        if instance_type is None and 'instanceType' in kwargs:
            instance_type = kwargs['instanceType']
        if instance_type is None:
            raise TypeError("Missing 'instance_type' argument")
        if associate_public_ip_address is None and 'associatePublicIpAddress' in kwargs:
            associate_public_ip_address = kwargs['associatePublicIpAddress']
        if availability_zone is None and 'availabilityZone' in kwargs:
            availability_zone = kwargs['availabilityZone']
        if ebs_block_devices is None and 'ebsBlockDevices' in kwargs:
            ebs_block_devices = kwargs['ebsBlockDevices']
        if ebs_optimized is None and 'ebsOptimized' in kwargs:
            ebs_optimized = kwargs['ebsOptimized']
        if ephemeral_block_devices is None and 'ephemeralBlockDevices' in kwargs:
            ephemeral_block_devices = kwargs['ephemeralBlockDevices']
        if iam_instance_profile is None and 'iamInstanceProfile' in kwargs:
            iam_instance_profile = kwargs['iamInstanceProfile']
        if iam_instance_profile_arn is None and 'iamInstanceProfileArn' in kwargs:
            iam_instance_profile_arn = kwargs['iamInstanceProfileArn']
        if key_name is None and 'keyName' in kwargs:
            key_name = kwargs['keyName']
        if placement_group is None and 'placementGroup' in kwargs:
            placement_group = kwargs['placementGroup']
        if placement_tenancy is None and 'placementTenancy' in kwargs:
            placement_tenancy = kwargs['placementTenancy']
        if root_block_devices is None and 'rootBlockDevices' in kwargs:
            root_block_devices = kwargs['rootBlockDevices']
        if spot_price is None and 'spotPrice' in kwargs:
            spot_price = kwargs['spotPrice']
        if subnet_id is None and 'subnetId' in kwargs:
            subnet_id = kwargs['subnetId']
        if user_data is None and 'userData' in kwargs:
            user_data = kwargs['userData']
        if vpc_security_group_ids is None and 'vpcSecurityGroupIds' in kwargs:
            vpc_security_group_ids = kwargs['vpcSecurityGroupIds']
        if weighted_capacity is None and 'weightedCapacity' in kwargs:
            weighted_capacity = kwargs['weightedCapacity']

        _setter("ami", ami)
        _setter("instance_type", instance_type)
        if associate_public_ip_address is not None:
            _setter("associate_public_ip_address", associate_public_ip_address)
        if availability_zone is not None:
            _setter("availability_zone", availability_zone)
        if ebs_block_devices is not None:
            _setter("ebs_block_devices", ebs_block_devices)
        if ebs_optimized is not None:
            _setter("ebs_optimized", ebs_optimized)
        if ephemeral_block_devices is not None:
            _setter("ephemeral_block_devices", ephemeral_block_devices)
        if iam_instance_profile is not None:
            _setter("iam_instance_profile", iam_instance_profile)
        if iam_instance_profile_arn is not None:
            _setter("iam_instance_profile_arn", iam_instance_profile_arn)
        if key_name is not None:
            _setter("key_name", key_name)
        if monitoring is not None:
            _setter("monitoring", monitoring)
        if placement_group is not None:
            _setter("placement_group", placement_group)
        if placement_tenancy is not None:
            _setter("placement_tenancy", placement_tenancy)
        if root_block_devices is not None:
            _setter("root_block_devices", root_block_devices)
        if spot_price is not None:
            _setter("spot_price", spot_price)
        if subnet_id is not None:
            _setter("subnet_id", subnet_id)
        if tags is not None:
            _setter("tags", tags)
        if user_data is not None:
            _setter("user_data", user_data)
        if vpc_security_group_ids is not None:
            _setter("vpc_security_group_ids", vpc_security_group_ids)
        if weighted_capacity is not None:
            _setter("weighted_capacity", weighted_capacity)

    @property
    @pulumi.getter
    def ami(self) -> str:
        return pulumi.get(self, "ami")

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> str:
        """
        The type of instance to request.
        """
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter(name="associatePublicIpAddress")
    def associate_public_ip_address(self) -> Optional[bool]:
        return pulumi.get(self, "associate_public_ip_address")

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[str]:
        """
        The availability zone in which to place the request.
        """
        return pulumi.get(self, "availability_zone")

    @property
    @pulumi.getter(name="ebsBlockDevices")
    def ebs_block_devices(self) -> Optional[Sequence['outputs.SpotFleetRequestLaunchSpecificationEbsBlockDevice']]:
        return pulumi.get(self, "ebs_block_devices")

    @property
    @pulumi.getter(name="ebsOptimized")
    def ebs_optimized(self) -> Optional[bool]:
        return pulumi.get(self, "ebs_optimized")

    @property
    @pulumi.getter(name="ephemeralBlockDevices")
    def ephemeral_block_devices(self) -> Optional[Sequence['outputs.SpotFleetRequestLaunchSpecificationEphemeralBlockDevice']]:
        return pulumi.get(self, "ephemeral_block_devices")

    @property
    @pulumi.getter(name="iamInstanceProfile")
    def iam_instance_profile(self) -> Optional[str]:
        return pulumi.get(self, "iam_instance_profile")

    @property
    @pulumi.getter(name="iamInstanceProfileArn")
    def iam_instance_profile_arn(self) -> Optional[str]:
        return pulumi.get(self, "iam_instance_profile_arn")

    @property
    @pulumi.getter(name="keyName")
    def key_name(self) -> Optional[str]:
        return pulumi.get(self, "key_name")

    @property
    @pulumi.getter
    def monitoring(self) -> Optional[bool]:
        return pulumi.get(self, "monitoring")

    @property
    @pulumi.getter(name="placementGroup")
    def placement_group(self) -> Optional[str]:
        return pulumi.get(self, "placement_group")

    @property
    @pulumi.getter(name="placementTenancy")
    def placement_tenancy(self) -> Optional[str]:
        return pulumi.get(self, "placement_tenancy")

    @property
    @pulumi.getter(name="rootBlockDevices")
    def root_block_devices(self) -> Optional[Sequence['outputs.SpotFleetRequestLaunchSpecificationRootBlockDevice']]:
        return pulumi.get(self, "root_block_devices")

    @property
    @pulumi.getter(name="spotPrice")
    def spot_price(self) -> Optional[str]:
        """
        The maximum bid price per unit hour.
        """
        return pulumi.get(self, "spot_price")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        The subnet in which to launch the requested instance.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        A map of tags to assign to the resource. .If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="userData")
    def user_data(self) -> Optional[str]:
        return pulumi.get(self, "user_data")

    @property
    @pulumi.getter(name="vpcSecurityGroupIds")
    def vpc_security_group_ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "vpc_security_group_ids")

    @property
    @pulumi.getter(name="weightedCapacity")
    def weighted_capacity(self) -> Optional[str]:
        """
        The capacity added to the fleet by a fulfilled request.
        """
        return pulumi.get(self, "weighted_capacity")


@pulumi.output_type
class SpotFleetRequestLaunchSpecificationEbsBlockDevice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "snapshotId":
            suggest = "snapshot_id"
        elif key == "volumeSize":
            suggest = "volume_size"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetRequestLaunchSpecificationEbsBlockDevice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetRequestLaunchSpecificationEbsBlockDevice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetRequestLaunchSpecificationEbsBlockDevice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_name: str,
                 delete_on_termination: Optional[bool] = None,
                 encrypted: Optional[bool] = None,
                 iops: Optional[int] = None,
                 kms_key_id: Optional[str] = None,
                 snapshot_id: Optional[str] = None,
                 throughput: Optional[int] = None,
                 volume_size: Optional[int] = None,
                 volume_type: Optional[str] = None):
        SpotFleetRequestLaunchSpecificationEbsBlockDevice._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            device_name=device_name,
            delete_on_termination=delete_on_termination,
            encrypted=encrypted,
            iops=iops,
            kms_key_id=kms_key_id,
            snapshot_id=snapshot_id,
            throughput=throughput,
            volume_size=volume_size,
            volume_type=volume_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             device_name: Optional[str] = None,
             delete_on_termination: Optional[bool] = None,
             encrypted: Optional[bool] = None,
             iops: Optional[int] = None,
             kms_key_id: Optional[str] = None,
             snapshot_id: Optional[str] = None,
             throughput: Optional[int] = None,
             volume_size: Optional[int] = None,
             volume_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if device_name is None and 'deviceName' in kwargs:
            device_name = kwargs['deviceName']
        if device_name is None:
            raise TypeError("Missing 'device_name' argument")
        if delete_on_termination is None and 'deleteOnTermination' in kwargs:
            delete_on_termination = kwargs['deleteOnTermination']
        if kms_key_id is None and 'kmsKeyId' in kwargs:
            kms_key_id = kwargs['kmsKeyId']
        if snapshot_id is None and 'snapshotId' in kwargs:
            snapshot_id = kwargs['snapshotId']
        if volume_size is None and 'volumeSize' in kwargs:
            volume_size = kwargs['volumeSize']
        if volume_type is None and 'volumeType' in kwargs:
            volume_type = kwargs['volumeType']

        _setter("device_name", device_name)
        if delete_on_termination is not None:
            _setter("delete_on_termination", delete_on_termination)
        if encrypted is not None:
            _setter("encrypted", encrypted)
        if iops is not None:
            _setter("iops", iops)
        if kms_key_id is not None:
            _setter("kms_key_id", kms_key_id)
        if snapshot_id is not None:
            _setter("snapshot_id", snapshot_id)
        if throughput is not None:
            _setter("throughput", throughput)
        if volume_size is not None:
            _setter("volume_size", volume_size)
        if volume_type is not None:
            _setter("volume_type", volume_type)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> str:
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[bool]:
        return pulumi.get(self, "delete_on_termination")

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[bool]:
        return pulumi.get(self, "encrypted")

    @property
    @pulumi.getter
    def iops(self) -> Optional[int]:
        return pulumi.get(self, "iops")

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[str]:
        return pulumi.get(self, "kms_key_id")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[str]:
        return pulumi.get(self, "snapshot_id")

    @property
    @pulumi.getter
    def throughput(self) -> Optional[int]:
        return pulumi.get(self, "throughput")

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[int]:
        return pulumi.get(self, "volume_size")

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[str]:
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class SpotFleetRequestLaunchSpecificationEphemeralBlockDevice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "virtualName":
            suggest = "virtual_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetRequestLaunchSpecificationEphemeralBlockDevice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetRequestLaunchSpecificationEphemeralBlockDevice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetRequestLaunchSpecificationEphemeralBlockDevice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_name: str,
                 virtual_name: str):
        SpotFleetRequestLaunchSpecificationEphemeralBlockDevice._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            device_name=device_name,
            virtual_name=virtual_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             device_name: Optional[str] = None,
             virtual_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if device_name is None and 'deviceName' in kwargs:
            device_name = kwargs['deviceName']
        if device_name is None:
            raise TypeError("Missing 'device_name' argument")
        if virtual_name is None and 'virtualName' in kwargs:
            virtual_name = kwargs['virtualName']
        if virtual_name is None:
            raise TypeError("Missing 'virtual_name' argument")

        _setter("device_name", device_name)
        _setter("virtual_name", virtual_name)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> str:
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> str:
        return pulumi.get(self, "virtual_name")


@pulumi.output_type
class SpotFleetRequestLaunchSpecificationRootBlockDevice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "volumeSize":
            suggest = "volume_size"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetRequestLaunchSpecificationRootBlockDevice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetRequestLaunchSpecificationRootBlockDevice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetRequestLaunchSpecificationRootBlockDevice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delete_on_termination: Optional[bool] = None,
                 encrypted: Optional[bool] = None,
                 iops: Optional[int] = None,
                 kms_key_id: Optional[str] = None,
                 throughput: Optional[int] = None,
                 volume_size: Optional[int] = None,
                 volume_type: Optional[str] = None):
        SpotFleetRequestLaunchSpecificationRootBlockDevice._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            delete_on_termination=delete_on_termination,
            encrypted=encrypted,
            iops=iops,
            kms_key_id=kms_key_id,
            throughput=throughput,
            volume_size=volume_size,
            volume_type=volume_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             delete_on_termination: Optional[bool] = None,
             encrypted: Optional[bool] = None,
             iops: Optional[int] = None,
             kms_key_id: Optional[str] = None,
             throughput: Optional[int] = None,
             volume_size: Optional[int] = None,
             volume_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if delete_on_termination is None and 'deleteOnTermination' in kwargs:
            delete_on_termination = kwargs['deleteOnTermination']
        if kms_key_id is None and 'kmsKeyId' in kwargs:
            kms_key_id = kwargs['kmsKeyId']
        if volume_size is None and 'volumeSize' in kwargs:
            volume_size = kwargs['volumeSize']
        if volume_type is None and 'volumeType' in kwargs:
            volume_type = kwargs['volumeType']

        if delete_on_termination is not None:
            _setter("delete_on_termination", delete_on_termination)
        if encrypted is not None:
            _setter("encrypted", encrypted)
        if iops is not None:
            _setter("iops", iops)
        if kms_key_id is not None:
            _setter("kms_key_id", kms_key_id)
        if throughput is not None:
            _setter("throughput", throughput)
        if volume_size is not None:
            _setter("volume_size", volume_size)
        if volume_type is not None:
            _setter("volume_type", volume_type)

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[bool]:
        return pulumi.get(self, "delete_on_termination")

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[bool]:
        return pulumi.get(self, "encrypted")

    @property
    @pulumi.getter
    def iops(self) -> Optional[int]:
        return pulumi.get(self, "iops")

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[str]:
        return pulumi.get(self, "kms_key_id")

    @property
    @pulumi.getter
    def throughput(self) -> Optional[int]:
        return pulumi.get(self, "throughput")

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[int]:
        return pulumi.get(self, "volume_size")

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[str]:
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class SpotFleetRequestLaunchTemplateConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "launchTemplateSpecification":
            suggest = "launch_template_specification"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetRequestLaunchTemplateConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetRequestLaunchTemplateConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetRequestLaunchTemplateConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 launch_template_specification: 'outputs.SpotFleetRequestLaunchTemplateConfigLaunchTemplateSpecification',
                 overrides: Optional[Sequence['outputs.SpotFleetRequestLaunchTemplateConfigOverride']] = None):
        """
        :param 'SpotFleetRequestLaunchTemplateConfigLaunchTemplateSpecificationArgs' launch_template_specification: Launch template specification. See Launch Template Specification below for more details.
        :param Sequence['SpotFleetRequestLaunchTemplateConfigOverrideArgs'] overrides: One or more override configurations. See Overrides below for more details.
        """
        SpotFleetRequestLaunchTemplateConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            launch_template_specification=launch_template_specification,
            overrides=overrides,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             launch_template_specification: Optional['outputs.SpotFleetRequestLaunchTemplateConfigLaunchTemplateSpecification'] = None,
             overrides: Optional[Sequence['outputs.SpotFleetRequestLaunchTemplateConfigOverride']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if launch_template_specification is None and 'launchTemplateSpecification' in kwargs:
            launch_template_specification = kwargs['launchTemplateSpecification']
        if launch_template_specification is None:
            raise TypeError("Missing 'launch_template_specification' argument")

        _setter("launch_template_specification", launch_template_specification)
        if overrides is not None:
            _setter("overrides", overrides)

    @property
    @pulumi.getter(name="launchTemplateSpecification")
    def launch_template_specification(self) -> 'outputs.SpotFleetRequestLaunchTemplateConfigLaunchTemplateSpecification':
        """
        Launch template specification. See Launch Template Specification below for more details.
        """
        return pulumi.get(self, "launch_template_specification")

    @property
    @pulumi.getter
    def overrides(self) -> Optional[Sequence['outputs.SpotFleetRequestLaunchTemplateConfigOverride']]:
        """
        One or more override configurations. See Overrides below for more details.
        """
        return pulumi.get(self, "overrides")


@pulumi.output_type
class SpotFleetRequestLaunchTemplateConfigLaunchTemplateSpecification(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param str id: The ID of the launch template. Conflicts with `name`.
        :param str name: The name of the launch template. Conflicts with `id`.
        :param str version: Template version. Unlike the autoscaling equivalent, does not support `$Latest` or `$Default`, so use the launch_template resource's attribute, e.g., `"${aws_launch_template.foo.latest_version}"`. It will use the default version if omitted.
               
               **Note:** The specified launch template can specify only a subset of the
               inputs of `ec2.LaunchTemplate`.  There are limitations on
               what you can specify as spot fleet does not support all the attributes that are supported by autoscaling groups. [AWS documentation](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-templates.html#launch-templates-spot-fleet) is currently sparse, but at least `instance_initiated_shutdown_behavior` is confirmed unsupported.
        """
        SpotFleetRequestLaunchTemplateConfigLaunchTemplateSpecification._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            name=name,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             name: Optional[str] = None,
             version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)
        if version is not None:
            _setter("version", version)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the launch template. Conflicts with `name`.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the launch template. Conflicts with `id`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        Template version. Unlike the autoscaling equivalent, does not support `$Latest` or `$Default`, so use the launch_template resource's attribute, e.g., `"${aws_launch_template.foo.latest_version}"`. It will use the default version if omitted.

        **Note:** The specified launch template can specify only a subset of the
        inputs of `ec2.LaunchTemplate`.  There are limitations on
        what you can specify as spot fleet does not support all the attributes that are supported by autoscaling groups. [AWS documentation](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-templates.html#launch-templates-spot-fleet) is currently sparse, but at least `instance_initiated_shutdown_behavior` is confirmed unsupported.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class SpotFleetRequestLaunchTemplateConfigOverride(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "instanceRequirements":
            suggest = "instance_requirements"
        elif key == "instanceType":
            suggest = "instance_type"
        elif key == "spotPrice":
            suggest = "spot_price"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "weightedCapacity":
            suggest = "weighted_capacity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetRequestLaunchTemplateConfigOverride. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetRequestLaunchTemplateConfigOverride.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetRequestLaunchTemplateConfigOverride.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_zone: Optional[str] = None,
                 instance_requirements: Optional['outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirements'] = None,
                 instance_type: Optional[str] = None,
                 priority: Optional[float] = None,
                 spot_price: Optional[str] = None,
                 subnet_id: Optional[str] = None,
                 weighted_capacity: Optional[float] = None):
        """
        :param str availability_zone: The availability zone in which to place the request.
        :param 'SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsArgs' instance_requirements: The instance requirements. See below.
        :param str instance_type: The type of instance to request.
        :param float priority: The priority for the launch template override. The lower the number, the higher the priority. If no number is set, the launch template override has the lowest priority.
        :param str spot_price: The maximum spot bid for this override request.
        :param str subnet_id: The subnet in which to launch the requested instance.
        :param float weighted_capacity: The capacity added to the fleet by a fulfilled request.
        """
        SpotFleetRequestLaunchTemplateConfigOverride._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability_zone=availability_zone,
            instance_requirements=instance_requirements,
            instance_type=instance_type,
            priority=priority,
            spot_price=spot_price,
            subnet_id=subnet_id,
            weighted_capacity=weighted_capacity,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability_zone: Optional[str] = None,
             instance_requirements: Optional['outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirements'] = None,
             instance_type: Optional[str] = None,
             priority: Optional[float] = None,
             spot_price: Optional[str] = None,
             subnet_id: Optional[str] = None,
             weighted_capacity: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if availability_zone is None and 'availabilityZone' in kwargs:
            availability_zone = kwargs['availabilityZone']
        if instance_requirements is None and 'instanceRequirements' in kwargs:
            instance_requirements = kwargs['instanceRequirements']
        if instance_type is None and 'instanceType' in kwargs:
            instance_type = kwargs['instanceType']
        if spot_price is None and 'spotPrice' in kwargs:
            spot_price = kwargs['spotPrice']
        if subnet_id is None and 'subnetId' in kwargs:
            subnet_id = kwargs['subnetId']
        if weighted_capacity is None and 'weightedCapacity' in kwargs:
            weighted_capacity = kwargs['weightedCapacity']

        if availability_zone is not None:
            _setter("availability_zone", availability_zone)
        if instance_requirements is not None:
            _setter("instance_requirements", instance_requirements)
        if instance_type is not None:
            _setter("instance_type", instance_type)
        if priority is not None:
            _setter("priority", priority)
        if spot_price is not None:
            _setter("spot_price", spot_price)
        if subnet_id is not None:
            _setter("subnet_id", subnet_id)
        if weighted_capacity is not None:
            _setter("weighted_capacity", weighted_capacity)

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[str]:
        """
        The availability zone in which to place the request.
        """
        return pulumi.get(self, "availability_zone")

    @property
    @pulumi.getter(name="instanceRequirements")
    def instance_requirements(self) -> Optional['outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirements']:
        """
        The instance requirements. See below.
        """
        return pulumi.get(self, "instance_requirements")

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[str]:
        """
        The type of instance to request.
        """
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter
    def priority(self) -> Optional[float]:
        """
        The priority for the launch template override. The lower the number, the higher the priority. If no number is set, the launch template override has the lowest priority.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="spotPrice")
    def spot_price(self) -> Optional[str]:
        """
        The maximum spot bid for this override request.
        """
        return pulumi.get(self, "spot_price")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        The subnet in which to launch the requested instance.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="weightedCapacity")
    def weighted_capacity(self) -> Optional[float]:
        """
        The capacity added to the fleet by a fulfilled request.
        """
        return pulumi.get(self, "weighted_capacity")


@pulumi.output_type
class SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirements(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acceleratorCount":
            suggest = "accelerator_count"
        elif key == "acceleratorManufacturers":
            suggest = "accelerator_manufacturers"
        elif key == "acceleratorNames":
            suggest = "accelerator_names"
        elif key == "acceleratorTotalMemoryMib":
            suggest = "accelerator_total_memory_mib"
        elif key == "acceleratorTypes":
            suggest = "accelerator_types"
        elif key == "allowedInstanceTypes":
            suggest = "allowed_instance_types"
        elif key == "bareMetal":
            suggest = "bare_metal"
        elif key == "baselineEbsBandwidthMbps":
            suggest = "baseline_ebs_bandwidth_mbps"
        elif key == "burstablePerformance":
            suggest = "burstable_performance"
        elif key == "cpuManufacturers":
            suggest = "cpu_manufacturers"
        elif key == "excludedInstanceTypes":
            suggest = "excluded_instance_types"
        elif key == "instanceGenerations":
            suggest = "instance_generations"
        elif key == "localStorage":
            suggest = "local_storage"
        elif key == "localStorageTypes":
            suggest = "local_storage_types"
        elif key == "memoryGibPerVcpu":
            suggest = "memory_gib_per_vcpu"
        elif key == "memoryMib":
            suggest = "memory_mib"
        elif key == "networkBandwidthGbps":
            suggest = "network_bandwidth_gbps"
        elif key == "networkInterfaceCount":
            suggest = "network_interface_count"
        elif key == "onDemandMaxPricePercentageOverLowestPrice":
            suggest = "on_demand_max_price_percentage_over_lowest_price"
        elif key == "requireHibernateSupport":
            suggest = "require_hibernate_support"
        elif key == "spotMaxPricePercentageOverLowestPrice":
            suggest = "spot_max_price_percentage_over_lowest_price"
        elif key == "totalLocalStorageGb":
            suggest = "total_local_storage_gb"
        elif key == "vcpuCount":
            suggest = "vcpu_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirements. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirements.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirements.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 accelerator_count: Optional['outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorCount'] = None,
                 accelerator_manufacturers: Optional[Sequence[str]] = None,
                 accelerator_names: Optional[Sequence[str]] = None,
                 accelerator_total_memory_mib: Optional['outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorTotalMemoryMib'] = None,
                 accelerator_types: Optional[Sequence[str]] = None,
                 allowed_instance_types: Optional[Sequence[str]] = None,
                 bare_metal: Optional[str] = None,
                 baseline_ebs_bandwidth_mbps: Optional['outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsBaselineEbsBandwidthMbps'] = None,
                 burstable_performance: Optional[str] = None,
                 cpu_manufacturers: Optional[Sequence[str]] = None,
                 excluded_instance_types: Optional[Sequence[str]] = None,
                 instance_generations: Optional[Sequence[str]] = None,
                 local_storage: Optional[str] = None,
                 local_storage_types: Optional[Sequence[str]] = None,
                 memory_gib_per_vcpu: Optional['outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsMemoryGibPerVcpu'] = None,
                 memory_mib: Optional['outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsMemoryMib'] = None,
                 network_bandwidth_gbps: Optional['outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsNetworkBandwidthGbps'] = None,
                 network_interface_count: Optional['outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsNetworkInterfaceCount'] = None,
                 on_demand_max_price_percentage_over_lowest_price: Optional[int] = None,
                 require_hibernate_support: Optional[bool] = None,
                 spot_max_price_percentage_over_lowest_price: Optional[int] = None,
                 total_local_storage_gb: Optional['outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsTotalLocalStorageGb'] = None,
                 vcpu_count: Optional['outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsVcpuCount'] = None):
        """
        :param 'SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorCountArgs' accelerator_count: Block describing the minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips). Default is no minimum or maximum.
        :param Sequence[str] accelerator_manufacturers: List of accelerator manufacturer names. Default is any manufacturer.
               
               ```python
               import pulumi
               ```
        :param Sequence[str] accelerator_names: List of accelerator names. Default is any acclerator.
               
               ```python
               import pulumi
               ```
        :param 'SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorTotalMemoryMibArgs' accelerator_total_memory_mib: Block describing the minimum and maximum total memory of the accelerators. Default is no minimum or maximum.
        :param Sequence[str] accelerator_types: List of accelerator types. Default is any accelerator type.
               
               ```python
               import pulumi
               ```
        :param Sequence[str] allowed_instance_types: List of instance types to apply your specified attributes against. All other instance types are ignored, even if they match your specified attributes. You can use strings with one or more wild cards, represented by an asterisk (\\*), to allow an instance type, size, or generation. The following are examples: `m5.8xlarge`, `c5*.*`, `m5a.*`, `r*`, `*3*`. For example, if you specify `c5*`, you are allowing the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*`, you are allowing all the M5a instance types, but not the M5n instance types. Maximum of 400 entries in the list; each entry is limited to 30 characters. Default is all instance types.
               
               > **NOTE:** If you specify `allowed_instance_types`, you can't specify `excluded_instance_types`.
        :param str bare_metal: Indicate whether bare metal instace types should be `included`, `excluded`, or `required`. Default is `excluded`.
        :param 'SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsBaselineEbsBandwidthMbpsArgs' baseline_ebs_bandwidth_mbps: Block describing the minimum and maximum baseline EBS bandwidth, in Mbps. Default is no minimum or maximum.
        :param str burstable_performance: Indicate whether burstable performance instance types should be `included`, `excluded`, or `required`. Default is `excluded`.
        :param Sequence[str] cpu_manufacturers: List of CPU manufacturer names. Default is any manufacturer.
               
               > **NOTE:** Don't confuse the CPU hardware manufacturer with the CPU hardware architecture. Instances will be launched with a compatible CPU architecture based on the Amazon Machine Image (AMI) that you specify in your launch template.
               
               ```python
               import pulumi
               ```
        :param Sequence[str] excluded_instance_types: List of instance types to exclude. You can use strings with one or more wild cards, represented by an asterisk (\\*), to exclude an instance type, size, or generation. The following are examples: `m5.8xlarge`, `c5*.*`, `m5a.*`, `r*`, `*3*`. For example, if you specify `c5*`, you are excluding the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*`, you are excluding all the M5a instance types, but not the M5n instance types. Maximum of 400 entries in the list; each entry is limited to 30 characters. Default is no excluded instance types.
               
               > **NOTE:** If you specify `excluded_instance_types`, you can't specify `allowed_instance_types`.
        :param Sequence[str] instance_generations: List of instance generation names. Default is any generation.
               
               ```python
               import pulumi
               ```
        :param str local_storage: Indicate whether instance types with local storage volumes are `included`, `excluded`, or `required`. Default is `included`.
        :param Sequence[str] local_storage_types: List of local storage type names. Default any storage type.
               
               ```python
               import pulumi
               ```
        :param 'SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsMemoryGibPerVcpuArgs' memory_gib_per_vcpu: Block describing the minimum and maximum amount of memory (GiB) per vCPU. Default is no minimum or maximum.
        :param 'SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsMemoryMibArgs' memory_mib: Block describing the minimum and maximum amount of memory (MiB). Default is no maximum.
        :param 'SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsNetworkBandwidthGbpsArgs' network_bandwidth_gbps: Block describing the minimum and maximum amount of network bandwidth, in gigabits per second (Gbps). Default is no minimum or maximum.
        :param 'SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsNetworkInterfaceCountArgs' network_interface_count: Block describing the minimum and maximum number of network interfaces. Default is no minimum or maximum.
        :param int on_demand_max_price_percentage_over_lowest_price: The price protection threshold for On-Demand Instances. This is the maximum youll pay for an On-Demand Instance, expressed as a percentage higher than the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price is higher than your threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as 999999. Default is 20.
               
               If you set DesiredCapacityType to vcpu or memory-mib, the price protection threshold is applied based on the per vCPU or per memory price instead of the per instance price.
        :param bool require_hibernate_support: Indicate whether instance types must support On-Demand Instance Hibernation, either `true` or `false`. Default is `false`.
        :param int spot_max_price_percentage_over_lowest_price: The price protection threshold for Spot Instances. This is the maximum youll pay for a Spot Instance, expressed as a percentage higher than the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price is higher than your threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as 999999. Default is 100.
               
               If you set DesiredCapacityType to vcpu or memory-mib, the price protection threshold is applied based on the per vCPU or per memory price instead of the per instance price.
        :param 'SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsTotalLocalStorageGbArgs' total_local_storage_gb: Block describing the minimum and maximum total local storage (GB). Default is no minimum or maximum.
        :param 'SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsVcpuCountArgs' vcpu_count: Block describing the minimum and maximum number of vCPUs. Default is no maximum.
        """
        SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirements._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            accelerator_count=accelerator_count,
            accelerator_manufacturers=accelerator_manufacturers,
            accelerator_names=accelerator_names,
            accelerator_total_memory_mib=accelerator_total_memory_mib,
            accelerator_types=accelerator_types,
            allowed_instance_types=allowed_instance_types,
            bare_metal=bare_metal,
            baseline_ebs_bandwidth_mbps=baseline_ebs_bandwidth_mbps,
            burstable_performance=burstable_performance,
            cpu_manufacturers=cpu_manufacturers,
            excluded_instance_types=excluded_instance_types,
            instance_generations=instance_generations,
            local_storage=local_storage,
            local_storage_types=local_storage_types,
            memory_gib_per_vcpu=memory_gib_per_vcpu,
            memory_mib=memory_mib,
            network_bandwidth_gbps=network_bandwidth_gbps,
            network_interface_count=network_interface_count,
            on_demand_max_price_percentage_over_lowest_price=on_demand_max_price_percentage_over_lowest_price,
            require_hibernate_support=require_hibernate_support,
            spot_max_price_percentage_over_lowest_price=spot_max_price_percentage_over_lowest_price,
            total_local_storage_gb=total_local_storage_gb,
            vcpu_count=vcpu_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             accelerator_count: Optional['outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorCount'] = None,
             accelerator_manufacturers: Optional[Sequence[str]] = None,
             accelerator_names: Optional[Sequence[str]] = None,
             accelerator_total_memory_mib: Optional['outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorTotalMemoryMib'] = None,
             accelerator_types: Optional[Sequence[str]] = None,
             allowed_instance_types: Optional[Sequence[str]] = None,
             bare_metal: Optional[str] = None,
             baseline_ebs_bandwidth_mbps: Optional['outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsBaselineEbsBandwidthMbps'] = None,
             burstable_performance: Optional[str] = None,
             cpu_manufacturers: Optional[Sequence[str]] = None,
             excluded_instance_types: Optional[Sequence[str]] = None,
             instance_generations: Optional[Sequence[str]] = None,
             local_storage: Optional[str] = None,
             local_storage_types: Optional[Sequence[str]] = None,
             memory_gib_per_vcpu: Optional['outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsMemoryGibPerVcpu'] = None,
             memory_mib: Optional['outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsMemoryMib'] = None,
             network_bandwidth_gbps: Optional['outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsNetworkBandwidthGbps'] = None,
             network_interface_count: Optional['outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsNetworkInterfaceCount'] = None,
             on_demand_max_price_percentage_over_lowest_price: Optional[int] = None,
             require_hibernate_support: Optional[bool] = None,
             spot_max_price_percentage_over_lowest_price: Optional[int] = None,
             total_local_storage_gb: Optional['outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsTotalLocalStorageGb'] = None,
             vcpu_count: Optional['outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsVcpuCount'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if accelerator_count is None and 'acceleratorCount' in kwargs:
            accelerator_count = kwargs['acceleratorCount']
        if accelerator_manufacturers is None and 'acceleratorManufacturers' in kwargs:
            accelerator_manufacturers = kwargs['acceleratorManufacturers']
        if accelerator_names is None and 'acceleratorNames' in kwargs:
            accelerator_names = kwargs['acceleratorNames']
        if accelerator_total_memory_mib is None and 'acceleratorTotalMemoryMib' in kwargs:
            accelerator_total_memory_mib = kwargs['acceleratorTotalMemoryMib']
        if accelerator_types is None and 'acceleratorTypes' in kwargs:
            accelerator_types = kwargs['acceleratorTypes']
        if allowed_instance_types is None and 'allowedInstanceTypes' in kwargs:
            allowed_instance_types = kwargs['allowedInstanceTypes']
        if bare_metal is None and 'bareMetal' in kwargs:
            bare_metal = kwargs['bareMetal']
        if baseline_ebs_bandwidth_mbps is None and 'baselineEbsBandwidthMbps' in kwargs:
            baseline_ebs_bandwidth_mbps = kwargs['baselineEbsBandwidthMbps']
        if burstable_performance is None and 'burstablePerformance' in kwargs:
            burstable_performance = kwargs['burstablePerformance']
        if cpu_manufacturers is None and 'cpuManufacturers' in kwargs:
            cpu_manufacturers = kwargs['cpuManufacturers']
        if excluded_instance_types is None and 'excludedInstanceTypes' in kwargs:
            excluded_instance_types = kwargs['excludedInstanceTypes']
        if instance_generations is None and 'instanceGenerations' in kwargs:
            instance_generations = kwargs['instanceGenerations']
        if local_storage is None and 'localStorage' in kwargs:
            local_storage = kwargs['localStorage']
        if local_storage_types is None and 'localStorageTypes' in kwargs:
            local_storage_types = kwargs['localStorageTypes']
        if memory_gib_per_vcpu is None and 'memoryGibPerVcpu' in kwargs:
            memory_gib_per_vcpu = kwargs['memoryGibPerVcpu']
        if memory_mib is None and 'memoryMib' in kwargs:
            memory_mib = kwargs['memoryMib']
        if network_bandwidth_gbps is None and 'networkBandwidthGbps' in kwargs:
            network_bandwidth_gbps = kwargs['networkBandwidthGbps']
        if network_interface_count is None and 'networkInterfaceCount' in kwargs:
            network_interface_count = kwargs['networkInterfaceCount']
        if on_demand_max_price_percentage_over_lowest_price is None and 'onDemandMaxPricePercentageOverLowestPrice' in kwargs:
            on_demand_max_price_percentage_over_lowest_price = kwargs['onDemandMaxPricePercentageOverLowestPrice']
        if require_hibernate_support is None and 'requireHibernateSupport' in kwargs:
            require_hibernate_support = kwargs['requireHibernateSupport']
        if spot_max_price_percentage_over_lowest_price is None and 'spotMaxPricePercentageOverLowestPrice' in kwargs:
            spot_max_price_percentage_over_lowest_price = kwargs['spotMaxPricePercentageOverLowestPrice']
        if total_local_storage_gb is None and 'totalLocalStorageGb' in kwargs:
            total_local_storage_gb = kwargs['totalLocalStorageGb']
        if vcpu_count is None and 'vcpuCount' in kwargs:
            vcpu_count = kwargs['vcpuCount']

        if accelerator_count is not None:
            _setter("accelerator_count", accelerator_count)
        if accelerator_manufacturers is not None:
            _setter("accelerator_manufacturers", accelerator_manufacturers)
        if accelerator_names is not None:
            _setter("accelerator_names", accelerator_names)
        if accelerator_total_memory_mib is not None:
            _setter("accelerator_total_memory_mib", accelerator_total_memory_mib)
        if accelerator_types is not None:
            _setter("accelerator_types", accelerator_types)
        if allowed_instance_types is not None:
            _setter("allowed_instance_types", allowed_instance_types)
        if bare_metal is not None:
            _setter("bare_metal", bare_metal)
        if baseline_ebs_bandwidth_mbps is not None:
            _setter("baseline_ebs_bandwidth_mbps", baseline_ebs_bandwidth_mbps)
        if burstable_performance is not None:
            _setter("burstable_performance", burstable_performance)
        if cpu_manufacturers is not None:
            _setter("cpu_manufacturers", cpu_manufacturers)
        if excluded_instance_types is not None:
            _setter("excluded_instance_types", excluded_instance_types)
        if instance_generations is not None:
            _setter("instance_generations", instance_generations)
        if local_storage is not None:
            _setter("local_storage", local_storage)
        if local_storage_types is not None:
            _setter("local_storage_types", local_storage_types)
        if memory_gib_per_vcpu is not None:
            _setter("memory_gib_per_vcpu", memory_gib_per_vcpu)
        if memory_mib is not None:
            _setter("memory_mib", memory_mib)
        if network_bandwidth_gbps is not None:
            _setter("network_bandwidth_gbps", network_bandwidth_gbps)
        if network_interface_count is not None:
            _setter("network_interface_count", network_interface_count)
        if on_demand_max_price_percentage_over_lowest_price is not None:
            _setter("on_demand_max_price_percentage_over_lowest_price", on_demand_max_price_percentage_over_lowest_price)
        if require_hibernate_support is not None:
            _setter("require_hibernate_support", require_hibernate_support)
        if spot_max_price_percentage_over_lowest_price is not None:
            _setter("spot_max_price_percentage_over_lowest_price", spot_max_price_percentage_over_lowest_price)
        if total_local_storage_gb is not None:
            _setter("total_local_storage_gb", total_local_storage_gb)
        if vcpu_count is not None:
            _setter("vcpu_count", vcpu_count)

    @property
    @pulumi.getter(name="acceleratorCount")
    def accelerator_count(self) -> Optional['outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorCount']:
        """
        Block describing the minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips). Default is no minimum or maximum.
        """
        return pulumi.get(self, "accelerator_count")

    @property
    @pulumi.getter(name="acceleratorManufacturers")
    def accelerator_manufacturers(self) -> Optional[Sequence[str]]:
        """
        List of accelerator manufacturer names. Default is any manufacturer.

        ```python
        import pulumi
        ```
        """
        return pulumi.get(self, "accelerator_manufacturers")

    @property
    @pulumi.getter(name="acceleratorNames")
    def accelerator_names(self) -> Optional[Sequence[str]]:
        """
        List of accelerator names. Default is any acclerator.

        ```python
        import pulumi
        ```
        """
        return pulumi.get(self, "accelerator_names")

    @property
    @pulumi.getter(name="acceleratorTotalMemoryMib")
    def accelerator_total_memory_mib(self) -> Optional['outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorTotalMemoryMib']:
        """
        Block describing the minimum and maximum total memory of the accelerators. Default is no minimum or maximum.
        """
        return pulumi.get(self, "accelerator_total_memory_mib")

    @property
    @pulumi.getter(name="acceleratorTypes")
    def accelerator_types(self) -> Optional[Sequence[str]]:
        """
        List of accelerator types. Default is any accelerator type.

        ```python
        import pulumi
        ```
        """
        return pulumi.get(self, "accelerator_types")

    @property
    @pulumi.getter(name="allowedInstanceTypes")
    def allowed_instance_types(self) -> Optional[Sequence[str]]:
        """
        List of instance types to apply your specified attributes against. All other instance types are ignored, even if they match your specified attributes. You can use strings with one or more wild cards, represented by an asterisk (\\*), to allow an instance type, size, or generation. The following are examples: `m5.8xlarge`, `c5*.*`, `m5a.*`, `r*`, `*3*`. For example, if you specify `c5*`, you are allowing the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*`, you are allowing all the M5a instance types, but not the M5n instance types. Maximum of 400 entries in the list; each entry is limited to 30 characters. Default is all instance types.

        > **NOTE:** If you specify `allowed_instance_types`, you can't specify `excluded_instance_types`.
        """
        return pulumi.get(self, "allowed_instance_types")

    @property
    @pulumi.getter(name="bareMetal")
    def bare_metal(self) -> Optional[str]:
        """
        Indicate whether bare metal instace types should be `included`, `excluded`, or `required`. Default is `excluded`.
        """
        return pulumi.get(self, "bare_metal")

    @property
    @pulumi.getter(name="baselineEbsBandwidthMbps")
    def baseline_ebs_bandwidth_mbps(self) -> Optional['outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsBaselineEbsBandwidthMbps']:
        """
        Block describing the minimum and maximum baseline EBS bandwidth, in Mbps. Default is no minimum or maximum.
        """
        return pulumi.get(self, "baseline_ebs_bandwidth_mbps")

    @property
    @pulumi.getter(name="burstablePerformance")
    def burstable_performance(self) -> Optional[str]:
        """
        Indicate whether burstable performance instance types should be `included`, `excluded`, or `required`. Default is `excluded`.
        """
        return pulumi.get(self, "burstable_performance")

    @property
    @pulumi.getter(name="cpuManufacturers")
    def cpu_manufacturers(self) -> Optional[Sequence[str]]:
        """
        List of CPU manufacturer names. Default is any manufacturer.

        > **NOTE:** Don't confuse the CPU hardware manufacturer with the CPU hardware architecture. Instances will be launched with a compatible CPU architecture based on the Amazon Machine Image (AMI) that you specify in your launch template.

        ```python
        import pulumi
        ```
        """
        return pulumi.get(self, "cpu_manufacturers")

    @property
    @pulumi.getter(name="excludedInstanceTypes")
    def excluded_instance_types(self) -> Optional[Sequence[str]]:
        """
        List of instance types to exclude. You can use strings with one or more wild cards, represented by an asterisk (\\*), to exclude an instance type, size, or generation. The following are examples: `m5.8xlarge`, `c5*.*`, `m5a.*`, `r*`, `*3*`. For example, if you specify `c5*`, you are excluding the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*`, you are excluding all the M5a instance types, but not the M5n instance types. Maximum of 400 entries in the list; each entry is limited to 30 characters. Default is no excluded instance types.

        > **NOTE:** If you specify `excluded_instance_types`, you can't specify `allowed_instance_types`.
        """
        return pulumi.get(self, "excluded_instance_types")

    @property
    @pulumi.getter(name="instanceGenerations")
    def instance_generations(self) -> Optional[Sequence[str]]:
        """
        List of instance generation names. Default is any generation.

        ```python
        import pulumi
        ```
        """
        return pulumi.get(self, "instance_generations")

    @property
    @pulumi.getter(name="localStorage")
    def local_storage(self) -> Optional[str]:
        """
        Indicate whether instance types with local storage volumes are `included`, `excluded`, or `required`. Default is `included`.
        """
        return pulumi.get(self, "local_storage")

    @property
    @pulumi.getter(name="localStorageTypes")
    def local_storage_types(self) -> Optional[Sequence[str]]:
        """
        List of local storage type names. Default any storage type.

        ```python
        import pulumi
        ```
        """
        return pulumi.get(self, "local_storage_types")

    @property
    @pulumi.getter(name="memoryGibPerVcpu")
    def memory_gib_per_vcpu(self) -> Optional['outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsMemoryGibPerVcpu']:
        """
        Block describing the minimum and maximum amount of memory (GiB) per vCPU. Default is no minimum or maximum.
        """
        return pulumi.get(self, "memory_gib_per_vcpu")

    @property
    @pulumi.getter(name="memoryMib")
    def memory_mib(self) -> Optional['outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsMemoryMib']:
        """
        Block describing the minimum and maximum amount of memory (MiB). Default is no maximum.
        """
        return pulumi.get(self, "memory_mib")

    @property
    @pulumi.getter(name="networkBandwidthGbps")
    def network_bandwidth_gbps(self) -> Optional['outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsNetworkBandwidthGbps']:
        """
        Block describing the minimum and maximum amount of network bandwidth, in gigabits per second (Gbps). Default is no minimum or maximum.
        """
        return pulumi.get(self, "network_bandwidth_gbps")

    @property
    @pulumi.getter(name="networkInterfaceCount")
    def network_interface_count(self) -> Optional['outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsNetworkInterfaceCount']:
        """
        Block describing the minimum and maximum number of network interfaces. Default is no minimum or maximum.
        """
        return pulumi.get(self, "network_interface_count")

    @property
    @pulumi.getter(name="onDemandMaxPricePercentageOverLowestPrice")
    def on_demand_max_price_percentage_over_lowest_price(self) -> Optional[int]:
        """
        The price protection threshold for On-Demand Instances. This is the maximum youll pay for an On-Demand Instance, expressed as a percentage higher than the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price is higher than your threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as 999999. Default is 20.

        If you set DesiredCapacityType to vcpu or memory-mib, the price protection threshold is applied based on the per vCPU or per memory price instead of the per instance price.
        """
        return pulumi.get(self, "on_demand_max_price_percentage_over_lowest_price")

    @property
    @pulumi.getter(name="requireHibernateSupport")
    def require_hibernate_support(self) -> Optional[bool]:
        """
        Indicate whether instance types must support On-Demand Instance Hibernation, either `true` or `false`. Default is `false`.
        """
        return pulumi.get(self, "require_hibernate_support")

    @property
    @pulumi.getter(name="spotMaxPricePercentageOverLowestPrice")
    def spot_max_price_percentage_over_lowest_price(self) -> Optional[int]:
        """
        The price protection threshold for Spot Instances. This is the maximum youll pay for a Spot Instance, expressed as a percentage higher than the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price is higher than your threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as 999999. Default is 100.

        If you set DesiredCapacityType to vcpu or memory-mib, the price protection threshold is applied based on the per vCPU or per memory price instead of the per instance price.
        """
        return pulumi.get(self, "spot_max_price_percentage_over_lowest_price")

    @property
    @pulumi.getter(name="totalLocalStorageGb")
    def total_local_storage_gb(self) -> Optional['outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsTotalLocalStorageGb']:
        """
        Block describing the minimum and maximum total local storage (GB). Default is no minimum or maximum.
        """
        return pulumi.get(self, "total_local_storage_gb")

    @property
    @pulumi.getter(name="vcpuCount")
    def vcpu_count(self) -> Optional['outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsVcpuCount']:
        """
        Block describing the minimum and maximum number of vCPUs. Default is no maximum.
        """
        return pulumi.get(self, "vcpu_count")


@pulumi.output_type
class SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorCount(dict):
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        """
        :param int max: Maximum.
        :param int min: Minimum.
        """
        SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorCount._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            min=min,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: Optional[int] = None,
             min: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if max is not None:
            _setter("max", max)
        if min is not None:
            _setter("min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        """
        Maximum.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        """
        Minimum.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorTotalMemoryMib(dict):
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        """
        :param int max: Maximum.
        :param int min: Minimum.
        """
        SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorTotalMemoryMib._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            min=min,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: Optional[int] = None,
             min: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if max is not None:
            _setter("max", max)
        if min is not None:
            _setter("min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        """
        Maximum.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        """
        Minimum.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsBaselineEbsBandwidthMbps(dict):
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        """
        :param int max: Maximum.
        :param int min: Minimum.
        """
        SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsBaselineEbsBandwidthMbps._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            min=min,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: Optional[int] = None,
             min: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if max is not None:
            _setter("max", max)
        if min is not None:
            _setter("min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        """
        Maximum.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        """
        Minimum.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsMemoryGibPerVcpu(dict):
    def __init__(__self__, *,
                 max: Optional[float] = None,
                 min: Optional[float] = None):
        """
        :param float max: Maximum.
        :param float min: Minimum.
        """
        SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsMemoryGibPerVcpu._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            min=min,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: Optional[float] = None,
             min: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if max is not None:
            _setter("max", max)
        if min is not None:
            _setter("min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[float]:
        """
        Maximum.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[float]:
        """
        Minimum.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsMemoryMib(dict):
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        """
        :param int max: Maximum.
        :param int min: Minimum.
        """
        SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsMemoryMib._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            min=min,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: Optional[int] = None,
             min: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if max is not None:
            _setter("max", max)
        if min is not None:
            _setter("min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        """
        Maximum.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        """
        Minimum.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsNetworkBandwidthGbps(dict):
    def __init__(__self__, *,
                 max: Optional[float] = None,
                 min: Optional[float] = None):
        """
        :param float max: Maximum.
        :param float min: Minimum.
        """
        SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsNetworkBandwidthGbps._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            min=min,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: Optional[float] = None,
             min: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if max is not None:
            _setter("max", max)
        if min is not None:
            _setter("min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[float]:
        """
        Maximum.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[float]:
        """
        Minimum.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsNetworkInterfaceCount(dict):
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        """
        :param int max: Maximum.
        :param int min: Minimum.
        """
        SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsNetworkInterfaceCount._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            min=min,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: Optional[int] = None,
             min: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if max is not None:
            _setter("max", max)
        if min is not None:
            _setter("min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        """
        Maximum.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        """
        Minimum.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsTotalLocalStorageGb(dict):
    def __init__(__self__, *,
                 max: Optional[float] = None,
                 min: Optional[float] = None):
        """
        :param float max: Maximum.
        :param float min: Minimum.
        """
        SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsTotalLocalStorageGb._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            min=min,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: Optional[float] = None,
             min: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if max is not None:
            _setter("max", max)
        if min is not None:
            _setter("min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[float]:
        """
        Maximum.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[float]:
        """
        Minimum.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsVcpuCount(dict):
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        """
        :param int max: Maximum.
        :param int min: Minimum.
        """
        SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsVcpuCount._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            min=min,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: Optional[int] = None,
             min: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if max is not None:
            _setter("max", max)
        if min is not None:
            _setter("min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        """
        Maximum.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        """
        Minimum.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class SpotFleetRequestSpotMaintenanceStrategies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capacityRebalance":
            suggest = "capacity_rebalance"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetRequestSpotMaintenanceStrategies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetRequestSpotMaintenanceStrategies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetRequestSpotMaintenanceStrategies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capacity_rebalance: Optional['outputs.SpotFleetRequestSpotMaintenanceStrategiesCapacityRebalance'] = None):
        """
        :param 'SpotFleetRequestSpotMaintenanceStrategiesCapacityRebalanceArgs' capacity_rebalance: Nested argument containing the capacity rebalance for your fleet request. Defined below.
        """
        SpotFleetRequestSpotMaintenanceStrategies._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            capacity_rebalance=capacity_rebalance,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             capacity_rebalance: Optional['outputs.SpotFleetRequestSpotMaintenanceStrategiesCapacityRebalance'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if capacity_rebalance is None and 'capacityRebalance' in kwargs:
            capacity_rebalance = kwargs['capacityRebalance']

        if capacity_rebalance is not None:
            _setter("capacity_rebalance", capacity_rebalance)

    @property
    @pulumi.getter(name="capacityRebalance")
    def capacity_rebalance(self) -> Optional['outputs.SpotFleetRequestSpotMaintenanceStrategiesCapacityRebalance']:
        """
        Nested argument containing the capacity rebalance for your fleet request. Defined below.
        """
        return pulumi.get(self, "capacity_rebalance")


@pulumi.output_type
class SpotFleetRequestSpotMaintenanceStrategiesCapacityRebalance(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "replacementStrategy":
            suggest = "replacement_strategy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetRequestSpotMaintenanceStrategiesCapacityRebalance. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetRequestSpotMaintenanceStrategiesCapacityRebalance.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetRequestSpotMaintenanceStrategiesCapacityRebalance.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 replacement_strategy: Optional[str] = None):
        """
        :param str replacement_strategy: The replacement strategy to use. Only available for spot fleets with `fleet_type` set to `maintain`. Valid values: `launch`.
        """
        SpotFleetRequestSpotMaintenanceStrategiesCapacityRebalance._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            replacement_strategy=replacement_strategy,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             replacement_strategy: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if replacement_strategy is None and 'replacementStrategy' in kwargs:
            replacement_strategy = kwargs['replacementStrategy']

        if replacement_strategy is not None:
            _setter("replacement_strategy", replacement_strategy)

    @property
    @pulumi.getter(name="replacementStrategy")
    def replacement_strategy(self) -> Optional[str]:
        """
        The replacement strategy to use. Only available for spot fleets with `fleet_type` set to `maintain`. Valid values: `launch`.
        """
        return pulumi.get(self, "replacement_strategy")


@pulumi.output_type
class SpotInstanceRequestCapacityReservationSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capacityReservationPreference":
            suggest = "capacity_reservation_preference"
        elif key == "capacityReservationTarget":
            suggest = "capacity_reservation_target"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotInstanceRequestCapacityReservationSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotInstanceRequestCapacityReservationSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotInstanceRequestCapacityReservationSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capacity_reservation_preference: Optional[str] = None,
                 capacity_reservation_target: Optional['outputs.SpotInstanceRequestCapacityReservationSpecificationCapacityReservationTarget'] = None):
        """
        :param str capacity_reservation_preference: Indicates the instance's Capacity Reservation preferences. Can be `"open"` or `"none"`. (Default: `"open"`).
        :param 'SpotInstanceRequestCapacityReservationSpecificationCapacityReservationTargetArgs' capacity_reservation_target: Information about the target Capacity Reservation. See Capacity Reservation Target below for more details.
               
               For more information, see the documentation on [Capacity Reservations](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/capacity-reservations-using.html).
        """
        SpotInstanceRequestCapacityReservationSpecification._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            capacity_reservation_preference=capacity_reservation_preference,
            capacity_reservation_target=capacity_reservation_target,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             capacity_reservation_preference: Optional[str] = None,
             capacity_reservation_target: Optional['outputs.SpotInstanceRequestCapacityReservationSpecificationCapacityReservationTarget'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if capacity_reservation_preference is None and 'capacityReservationPreference' in kwargs:
            capacity_reservation_preference = kwargs['capacityReservationPreference']
        if capacity_reservation_target is None and 'capacityReservationTarget' in kwargs:
            capacity_reservation_target = kwargs['capacityReservationTarget']

        if capacity_reservation_preference is not None:
            _setter("capacity_reservation_preference", capacity_reservation_preference)
        if capacity_reservation_target is not None:
            _setter("capacity_reservation_target", capacity_reservation_target)

    @property
    @pulumi.getter(name="capacityReservationPreference")
    def capacity_reservation_preference(self) -> Optional[str]:
        """
        Indicates the instance's Capacity Reservation preferences. Can be `"open"` or `"none"`. (Default: `"open"`).
        """
        return pulumi.get(self, "capacity_reservation_preference")

    @property
    @pulumi.getter(name="capacityReservationTarget")
    def capacity_reservation_target(self) -> Optional['outputs.SpotInstanceRequestCapacityReservationSpecificationCapacityReservationTarget']:
        """
        Information about the target Capacity Reservation. See Capacity Reservation Target below for more details.

        For more information, see the documentation on [Capacity Reservations](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/capacity-reservations-using.html).
        """
        return pulumi.get(self, "capacity_reservation_target")


@pulumi.output_type
class SpotInstanceRequestCapacityReservationSpecificationCapacityReservationTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capacityReservationId":
            suggest = "capacity_reservation_id"
        elif key == "capacityReservationResourceGroupArn":
            suggest = "capacity_reservation_resource_group_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotInstanceRequestCapacityReservationSpecificationCapacityReservationTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotInstanceRequestCapacityReservationSpecificationCapacityReservationTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotInstanceRequestCapacityReservationSpecificationCapacityReservationTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capacity_reservation_id: Optional[str] = None,
                 capacity_reservation_resource_group_arn: Optional[str] = None):
        """
        :param str capacity_reservation_id: ID of the Capacity Reservation in which to run the instance.
        :param str capacity_reservation_resource_group_arn: ARN of the Capacity Reservation resource group in which to run the instance.
        """
        SpotInstanceRequestCapacityReservationSpecificationCapacityReservationTarget._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            capacity_reservation_id=capacity_reservation_id,
            capacity_reservation_resource_group_arn=capacity_reservation_resource_group_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             capacity_reservation_id: Optional[str] = None,
             capacity_reservation_resource_group_arn: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if capacity_reservation_id is None and 'capacityReservationId' in kwargs:
            capacity_reservation_id = kwargs['capacityReservationId']
        if capacity_reservation_resource_group_arn is None and 'capacityReservationResourceGroupArn' in kwargs:
            capacity_reservation_resource_group_arn = kwargs['capacityReservationResourceGroupArn']

        if capacity_reservation_id is not None:
            _setter("capacity_reservation_id", capacity_reservation_id)
        if capacity_reservation_resource_group_arn is not None:
            _setter("capacity_reservation_resource_group_arn", capacity_reservation_resource_group_arn)

    @property
    @pulumi.getter(name="capacityReservationId")
    def capacity_reservation_id(self) -> Optional[str]:
        """
        ID of the Capacity Reservation in which to run the instance.
        """
        return pulumi.get(self, "capacity_reservation_id")

    @property
    @pulumi.getter(name="capacityReservationResourceGroupArn")
    def capacity_reservation_resource_group_arn(self) -> Optional[str]:
        """
        ARN of the Capacity Reservation resource group in which to run the instance.
        """
        return pulumi.get(self, "capacity_reservation_resource_group_arn")


@pulumi.output_type
class SpotInstanceRequestCpuOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "amdSevSnp":
            suggest = "amd_sev_snp"
        elif key == "coreCount":
            suggest = "core_count"
        elif key == "threadsPerCore":
            suggest = "threads_per_core"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotInstanceRequestCpuOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotInstanceRequestCpuOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotInstanceRequestCpuOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 amd_sev_snp: Optional[str] = None,
                 core_count: Optional[int] = None,
                 threads_per_core: Optional[int] = None):
        """
        :param str amd_sev_snp: Indicates whether to enable the instance for AMD SEV-SNP. AMD SEV-SNP is supported with M6a, R6a, and C6a instance types only. Valid values are `enabled` and `disabled`.
        :param int core_count: Sets the number of CPU cores for an instance. This option is only supported on creation of instance type that support CPU Options [CPU Cores and Threads Per CPU Core Per Instance Type](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html#cpu-options-supported-instances-values) - specifying this option for unsupported instance types will return an error from the EC2 API.
        :param int threads_per_core: If set to 1, hyperthreading is disabled on the launched instance. Defaults to 2 if not set. See [Optimizing CPU Options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html) for more information.
               
               For more information, see the documentation on [Optimizing CPU options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html).
        """
        SpotInstanceRequestCpuOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            amd_sev_snp=amd_sev_snp,
            core_count=core_count,
            threads_per_core=threads_per_core,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             amd_sev_snp: Optional[str] = None,
             core_count: Optional[int] = None,
             threads_per_core: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if amd_sev_snp is None and 'amdSevSnp' in kwargs:
            amd_sev_snp = kwargs['amdSevSnp']
        if core_count is None and 'coreCount' in kwargs:
            core_count = kwargs['coreCount']
        if threads_per_core is None and 'threadsPerCore' in kwargs:
            threads_per_core = kwargs['threadsPerCore']

        if amd_sev_snp is not None:
            _setter("amd_sev_snp", amd_sev_snp)
        if core_count is not None:
            _setter("core_count", core_count)
        if threads_per_core is not None:
            _setter("threads_per_core", threads_per_core)

    @property
    @pulumi.getter(name="amdSevSnp")
    def amd_sev_snp(self) -> Optional[str]:
        """
        Indicates whether to enable the instance for AMD SEV-SNP. AMD SEV-SNP is supported with M6a, R6a, and C6a instance types only. Valid values are `enabled` and `disabled`.
        """
        return pulumi.get(self, "amd_sev_snp")

    @property
    @pulumi.getter(name="coreCount")
    def core_count(self) -> Optional[int]:
        """
        Sets the number of CPU cores for an instance. This option is only supported on creation of instance type that support CPU Options [CPU Cores and Threads Per CPU Core Per Instance Type](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html#cpu-options-supported-instances-values) - specifying this option for unsupported instance types will return an error from the EC2 API.
        """
        return pulumi.get(self, "core_count")

    @property
    @pulumi.getter(name="threadsPerCore")
    def threads_per_core(self) -> Optional[int]:
        """
        If set to 1, hyperthreading is disabled on the launched instance. Defaults to 2 if not set. See [Optimizing CPU Options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html) for more information.

        For more information, see the documentation on [Optimizing CPU options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html).
        """
        return pulumi.get(self, "threads_per_core")


@pulumi.output_type
class SpotInstanceRequestCreditSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cpuCredits":
            suggest = "cpu_credits"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotInstanceRequestCreditSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotInstanceRequestCreditSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotInstanceRequestCreditSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu_credits: Optional[str] = None):
        """
        :param str cpu_credits: Credit option for CPU usage. Valid values include `standard` or `unlimited`. T3 instances are launched as unlimited by default. T2 instances are launched as standard by default.
        """
        SpotInstanceRequestCreditSpecification._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cpu_credits=cpu_credits,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cpu_credits: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cpu_credits is None and 'cpuCredits' in kwargs:
            cpu_credits = kwargs['cpuCredits']

        if cpu_credits is not None:
            _setter("cpu_credits", cpu_credits)

    @property
    @pulumi.getter(name="cpuCredits")
    def cpu_credits(self) -> Optional[str]:
        """
        Credit option for CPU usage. Valid values include `standard` or `unlimited`. T3 instances are launched as unlimited by default. T2 instances are launched as standard by default.
        """
        return pulumi.get(self, "cpu_credits")


@pulumi.output_type
class SpotInstanceRequestEbsBlockDevice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "snapshotId":
            suggest = "snapshot_id"
        elif key == "volumeId":
            suggest = "volume_id"
        elif key == "volumeSize":
            suggest = "volume_size"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotInstanceRequestEbsBlockDevice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotInstanceRequestEbsBlockDevice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotInstanceRequestEbsBlockDevice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_name: str,
                 delete_on_termination: Optional[bool] = None,
                 encrypted: Optional[bool] = None,
                 iops: Optional[int] = None,
                 kms_key_id: Optional[str] = None,
                 snapshot_id: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 throughput: Optional[int] = None,
                 volume_id: Optional[str] = None,
                 volume_size: Optional[int] = None,
                 volume_type: Optional[str] = None):
        """
        :param str device_name: Name of the device to mount.
        :param bool delete_on_termination: Whether the volume should be destroyed on instance termination. Defaults to `true`.
        :param bool encrypted: Enables [EBS encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html) on the volume. Defaults to `false`. Cannot be used with `snapshot_id`. Must be configured to perform drift detection.
        :param int iops: Amount of provisioned [IOPS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-io-characteristics.html). Only valid for volume_type of `io1`, `io2` or `gp3`.
        :param str kms_key_id: Amazon Resource Name (ARN) of the KMS Key to use when encrypting the volume. Must be configured to perform drift detection.
        :param str snapshot_id: Snapshot ID to mount.
        :param Mapping[str, str] tags: Map of tags to assign to the device.
        :param int throughput: Throughput to provision for a volume in mebibytes per second (MiB/s). This is only valid for `volume_type` of `gp3`.
        :param int volume_size: Size of the volume in gibibytes (GiB).
        :param str volume_type: Type of volume. Valid values include `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1`, or `st1`. Defaults to `gp2`.
               
               > **NOTE:** Currently, changes to the `ebs_block_device` configuration of _existing_ resources cannot be automatically detected by this provider. To manage changes and attachments of an EBS block to an instance, use the `ebs.Volume` and `ec2.VolumeAttachment` resources instead. If you use `ebs_block_device` on an `ec2.Instance`, this provider will assume management over the full set of non-root EBS block devices for the instance, treating additional block devices as drift. For this reason, `ebs_block_device` cannot be mixed with external `ebs.Volume` and `ec2.VolumeAttachment` resources for a given instance.
        """
        SpotInstanceRequestEbsBlockDevice._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            device_name=device_name,
            delete_on_termination=delete_on_termination,
            encrypted=encrypted,
            iops=iops,
            kms_key_id=kms_key_id,
            snapshot_id=snapshot_id,
            tags=tags,
            throughput=throughput,
            volume_id=volume_id,
            volume_size=volume_size,
            volume_type=volume_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             device_name: Optional[str] = None,
             delete_on_termination: Optional[bool] = None,
             encrypted: Optional[bool] = None,
             iops: Optional[int] = None,
             kms_key_id: Optional[str] = None,
             snapshot_id: Optional[str] = None,
             tags: Optional[Mapping[str, str]] = None,
             throughput: Optional[int] = None,
             volume_id: Optional[str] = None,
             volume_size: Optional[int] = None,
             volume_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if device_name is None and 'deviceName' in kwargs:
            device_name = kwargs['deviceName']
        if device_name is None:
            raise TypeError("Missing 'device_name' argument")
        if delete_on_termination is None and 'deleteOnTermination' in kwargs:
            delete_on_termination = kwargs['deleteOnTermination']
        if kms_key_id is None and 'kmsKeyId' in kwargs:
            kms_key_id = kwargs['kmsKeyId']
        if snapshot_id is None and 'snapshotId' in kwargs:
            snapshot_id = kwargs['snapshotId']
        if volume_id is None and 'volumeId' in kwargs:
            volume_id = kwargs['volumeId']
        if volume_size is None and 'volumeSize' in kwargs:
            volume_size = kwargs['volumeSize']
        if volume_type is None and 'volumeType' in kwargs:
            volume_type = kwargs['volumeType']

        _setter("device_name", device_name)
        if delete_on_termination is not None:
            _setter("delete_on_termination", delete_on_termination)
        if encrypted is not None:
            _setter("encrypted", encrypted)
        if iops is not None:
            _setter("iops", iops)
        if kms_key_id is not None:
            _setter("kms_key_id", kms_key_id)
        if snapshot_id is not None:
            _setter("snapshot_id", snapshot_id)
        if tags is not None:
            _setter("tags", tags)
        if throughput is not None:
            _setter("throughput", throughput)
        if volume_id is not None:
            _setter("volume_id", volume_id)
        if volume_size is not None:
            _setter("volume_size", volume_size)
        if volume_type is not None:
            _setter("volume_type", volume_type)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> str:
        """
        Name of the device to mount.
        """
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[bool]:
        """
        Whether the volume should be destroyed on instance termination. Defaults to `true`.
        """
        return pulumi.get(self, "delete_on_termination")

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[bool]:
        """
        Enables [EBS encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html) on the volume. Defaults to `false`. Cannot be used with `snapshot_id`. Must be configured to perform drift detection.
        """
        return pulumi.get(self, "encrypted")

    @property
    @pulumi.getter
    def iops(self) -> Optional[int]:
        """
        Amount of provisioned [IOPS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-io-characteristics.html). Only valid for volume_type of `io1`, `io2` or `gp3`.
        """
        return pulumi.get(self, "iops")

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN) of the KMS Key to use when encrypting the volume. Must be configured to perform drift detection.
        """
        return pulumi.get(self, "kms_key_id")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[str]:
        """
        Snapshot ID to mount.
        """
        return pulumi.get(self, "snapshot_id")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Map of tags to assign to the device.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def throughput(self) -> Optional[int]:
        """
        Throughput to provision for a volume in mebibytes per second (MiB/s). This is only valid for `volume_type` of `gp3`.
        """
        return pulumi.get(self, "throughput")

    @property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> Optional[str]:
        return pulumi.get(self, "volume_id")

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[int]:
        """
        Size of the volume in gibibytes (GiB).
        """
        return pulumi.get(self, "volume_size")

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[str]:
        """
        Type of volume. Valid values include `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1`, or `st1`. Defaults to `gp2`.

        > **NOTE:** Currently, changes to the `ebs_block_device` configuration of _existing_ resources cannot be automatically detected by this provider. To manage changes and attachments of an EBS block to an instance, use the `ebs.Volume` and `ec2.VolumeAttachment` resources instead. If you use `ebs_block_device` on an `ec2.Instance`, this provider will assume management over the full set of non-root EBS block devices for the instance, treating additional block devices as drift. For this reason, `ebs_block_device` cannot be mixed with external `ebs.Volume` and `ec2.VolumeAttachment` resources for a given instance.
        """
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class SpotInstanceRequestEnclaveOptions(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        """
        :param bool enabled: Whether Nitro Enclaves will be enabled on the instance. Defaults to `false`.
               
               For more information, see the documentation on [Nitro Enclaves](https://docs.aws.amazon.com/enclaves/latest/user/nitro-enclave.html).
        """
        SpotInstanceRequestEnclaveOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if enabled is not None:
            _setter("enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Whether Nitro Enclaves will be enabled on the instance. Defaults to `false`.

        For more information, see the documentation on [Nitro Enclaves](https://docs.aws.amazon.com/enclaves/latest/user/nitro-enclave.html).
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class SpotInstanceRequestEphemeralBlockDevice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "noDevice":
            suggest = "no_device"
        elif key == "virtualName":
            suggest = "virtual_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotInstanceRequestEphemeralBlockDevice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotInstanceRequestEphemeralBlockDevice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotInstanceRequestEphemeralBlockDevice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_name: str,
                 no_device: Optional[bool] = None,
                 virtual_name: Optional[str] = None):
        """
        :param str device_name: Name of the block device to mount on the instance.
        :param bool no_device: Suppresses the specified device included in the AMI's block device mapping.
        :param str virtual_name: [Instance Store Device Name](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#InstanceStoreDeviceNames) (e.g., `ephemeral0`).
               
               Each AWS Instance type has a different set of Instance Store block devices available for attachment. AWS [publishes a list](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#StorageOnInstanceTypes) of which ephemeral devices are available on each type. The devices are always identified by the `virtual_name` in the format `ephemeral{0..N}`.
        """
        SpotInstanceRequestEphemeralBlockDevice._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            device_name=device_name,
            no_device=no_device,
            virtual_name=virtual_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             device_name: Optional[str] = None,
             no_device: Optional[bool] = None,
             virtual_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if device_name is None and 'deviceName' in kwargs:
            device_name = kwargs['deviceName']
        if device_name is None:
            raise TypeError("Missing 'device_name' argument")
        if no_device is None and 'noDevice' in kwargs:
            no_device = kwargs['noDevice']
        if virtual_name is None and 'virtualName' in kwargs:
            virtual_name = kwargs['virtualName']

        _setter("device_name", device_name)
        if no_device is not None:
            _setter("no_device", no_device)
        if virtual_name is not None:
            _setter("virtual_name", virtual_name)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> str:
        """
        Name of the block device to mount on the instance.
        """
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter(name="noDevice")
    def no_device(self) -> Optional[bool]:
        """
        Suppresses the specified device included in the AMI's block device mapping.
        """
        return pulumi.get(self, "no_device")

    @property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> Optional[str]:
        """
        [Instance Store Device Name](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#InstanceStoreDeviceNames) (e.g., `ephemeral0`).

        Each AWS Instance type has a different set of Instance Store block devices available for attachment. AWS [publishes a list](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#StorageOnInstanceTypes) of which ephemeral devices are available on each type. The devices are always identified by the `virtual_name` in the format `ephemeral{0..N}`.
        """
        return pulumi.get(self, "virtual_name")


@pulumi.output_type
class SpotInstanceRequestLaunchTemplate(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param str id: ID of the launch template. Conflicts with `name`.
        :param str name: Name of the launch template. Conflicts with `id`.
        :param str version: Template version. Can be a specific version number, `$Latest` or `$Default`. The default value is `$Default`.
        """
        SpotInstanceRequestLaunchTemplate._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            name=name,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             name: Optional[str] = None,
             version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)
        if version is not None:
            _setter("version", version)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the launch template. Conflicts with `name`.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the launch template. Conflicts with `id`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        Template version. Can be a specific version number, `$Latest` or `$Default`. The default value is `$Default`.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class SpotInstanceRequestMaintenanceOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoRecovery":
            suggest = "auto_recovery"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotInstanceRequestMaintenanceOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotInstanceRequestMaintenanceOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotInstanceRequestMaintenanceOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_recovery: Optional[str] = None):
        """
        :param str auto_recovery: Automatic recovery behavior of the Instance. Can be `"default"` or `"disabled"`. See [Recover your instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-recover.html) for more details.
        """
        SpotInstanceRequestMaintenanceOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auto_recovery=auto_recovery,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auto_recovery: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if auto_recovery is None and 'autoRecovery' in kwargs:
            auto_recovery = kwargs['autoRecovery']

        if auto_recovery is not None:
            _setter("auto_recovery", auto_recovery)

    @property
    @pulumi.getter(name="autoRecovery")
    def auto_recovery(self) -> Optional[str]:
        """
        Automatic recovery behavior of the Instance. Can be `"default"` or `"disabled"`. See [Recover your instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-recover.html) for more details.
        """
        return pulumi.get(self, "auto_recovery")


@pulumi.output_type
class SpotInstanceRequestMetadataOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpEndpoint":
            suggest = "http_endpoint"
        elif key == "httpProtocolIpv6":
            suggest = "http_protocol_ipv6"
        elif key == "httpPutResponseHopLimit":
            suggest = "http_put_response_hop_limit"
        elif key == "httpTokens":
            suggest = "http_tokens"
        elif key == "instanceMetadataTags":
            suggest = "instance_metadata_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotInstanceRequestMetadataOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotInstanceRequestMetadataOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotInstanceRequestMetadataOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_endpoint: Optional[str] = None,
                 http_protocol_ipv6: Optional[str] = None,
                 http_put_response_hop_limit: Optional[int] = None,
                 http_tokens: Optional[str] = None,
                 instance_metadata_tags: Optional[str] = None):
        """
        :param str http_endpoint: Whether the metadata service is available. Valid values include `enabled` or `disabled`. Defaults to `enabled`.
        :param str http_protocol_ipv6: Whether the IPv6 endpoint for the instance metadata service is enabled. Defaults to `disabled`.
        :param int http_put_response_hop_limit: Desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel. Valid values are integer from `1` to `64`. Defaults to `1`.
        :param str http_tokens: Whether or not the metadata service requires session tokens, also referred to as _Instance Metadata Service Version 2 (IMDSv2)_. Valid values include `optional` or `required`. Defaults to `optional`.
        :param str instance_metadata_tags: Enables or disables access to instance tags from the instance metadata service. Valid values include `enabled` or `disabled`. Defaults to `disabled`.
               
               For more information, see the documentation on the [Instance Metadata Service](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html).
        """
        SpotInstanceRequestMetadataOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            http_endpoint=http_endpoint,
            http_protocol_ipv6=http_protocol_ipv6,
            http_put_response_hop_limit=http_put_response_hop_limit,
            http_tokens=http_tokens,
            instance_metadata_tags=instance_metadata_tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             http_endpoint: Optional[str] = None,
             http_protocol_ipv6: Optional[str] = None,
             http_put_response_hop_limit: Optional[int] = None,
             http_tokens: Optional[str] = None,
             instance_metadata_tags: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if http_endpoint is None and 'httpEndpoint' in kwargs:
            http_endpoint = kwargs['httpEndpoint']
        if http_protocol_ipv6 is None and 'httpProtocolIpv6' in kwargs:
            http_protocol_ipv6 = kwargs['httpProtocolIpv6']
        if http_put_response_hop_limit is None and 'httpPutResponseHopLimit' in kwargs:
            http_put_response_hop_limit = kwargs['httpPutResponseHopLimit']
        if http_tokens is None and 'httpTokens' in kwargs:
            http_tokens = kwargs['httpTokens']
        if instance_metadata_tags is None and 'instanceMetadataTags' in kwargs:
            instance_metadata_tags = kwargs['instanceMetadataTags']

        if http_endpoint is not None:
            _setter("http_endpoint", http_endpoint)
        if http_protocol_ipv6 is not None:
            _setter("http_protocol_ipv6", http_protocol_ipv6)
        if http_put_response_hop_limit is not None:
            _setter("http_put_response_hop_limit", http_put_response_hop_limit)
        if http_tokens is not None:
            _setter("http_tokens", http_tokens)
        if instance_metadata_tags is not None:
            _setter("instance_metadata_tags", instance_metadata_tags)

    @property
    @pulumi.getter(name="httpEndpoint")
    def http_endpoint(self) -> Optional[str]:
        """
        Whether the metadata service is available. Valid values include `enabled` or `disabled`. Defaults to `enabled`.
        """
        return pulumi.get(self, "http_endpoint")

    @property
    @pulumi.getter(name="httpProtocolIpv6")
    def http_protocol_ipv6(self) -> Optional[str]:
        """
        Whether the IPv6 endpoint for the instance metadata service is enabled. Defaults to `disabled`.
        """
        return pulumi.get(self, "http_protocol_ipv6")

    @property
    @pulumi.getter(name="httpPutResponseHopLimit")
    def http_put_response_hop_limit(self) -> Optional[int]:
        """
        Desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel. Valid values are integer from `1` to `64`. Defaults to `1`.
        """
        return pulumi.get(self, "http_put_response_hop_limit")

    @property
    @pulumi.getter(name="httpTokens")
    def http_tokens(self) -> Optional[str]:
        """
        Whether or not the metadata service requires session tokens, also referred to as _Instance Metadata Service Version 2 (IMDSv2)_. Valid values include `optional` or `required`. Defaults to `optional`.
        """
        return pulumi.get(self, "http_tokens")

    @property
    @pulumi.getter(name="instanceMetadataTags")
    def instance_metadata_tags(self) -> Optional[str]:
        """
        Enables or disables access to instance tags from the instance metadata service. Valid values include `enabled` or `disabled`. Defaults to `disabled`.

        For more information, see the documentation on the [Instance Metadata Service](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html).
        """
        return pulumi.get(self, "instance_metadata_tags")


@pulumi.output_type
class SpotInstanceRequestNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceIndex":
            suggest = "device_index"
        elif key == "networkInterfaceId":
            suggest = "network_interface_id"
        elif key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "networkCardIndex":
            suggest = "network_card_index"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotInstanceRequestNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotInstanceRequestNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotInstanceRequestNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_index: int,
                 network_interface_id: str,
                 delete_on_termination: Optional[bool] = None,
                 network_card_index: Optional[int] = None):
        """
        :param int device_index: Integer index of the network interface attachment. Limited by instance type.
        :param str network_interface_id: ID of the network interface to attach.
        :param bool delete_on_termination: Whether or not to delete the network interface on instance termination. Defaults to `false`. Currently, the only valid value is `false`, as this is only supported when creating new network interfaces when launching an instance.
        :param int network_card_index: Integer index of the network card. Limited by instance type. The default index is `0`.
        """
        SpotInstanceRequestNetworkInterface._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            device_index=device_index,
            network_interface_id=network_interface_id,
            delete_on_termination=delete_on_termination,
            network_card_index=network_card_index,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             device_index: Optional[int] = None,
             network_interface_id: Optional[str] = None,
             delete_on_termination: Optional[bool] = None,
             network_card_index: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if device_index is None and 'deviceIndex' in kwargs:
            device_index = kwargs['deviceIndex']
        if device_index is None:
            raise TypeError("Missing 'device_index' argument")
        if network_interface_id is None and 'networkInterfaceId' in kwargs:
            network_interface_id = kwargs['networkInterfaceId']
        if network_interface_id is None:
            raise TypeError("Missing 'network_interface_id' argument")
        if delete_on_termination is None and 'deleteOnTermination' in kwargs:
            delete_on_termination = kwargs['deleteOnTermination']
        if network_card_index is None and 'networkCardIndex' in kwargs:
            network_card_index = kwargs['networkCardIndex']

        _setter("device_index", device_index)
        _setter("network_interface_id", network_interface_id)
        if delete_on_termination is not None:
            _setter("delete_on_termination", delete_on_termination)
        if network_card_index is not None:
            _setter("network_card_index", network_card_index)

    @property
    @pulumi.getter(name="deviceIndex")
    def device_index(self) -> int:
        """
        Integer index of the network interface attachment. Limited by instance type.
        """
        return pulumi.get(self, "device_index")

    @property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> str:
        """
        ID of the network interface to attach.
        """
        return pulumi.get(self, "network_interface_id")

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[bool]:
        """
        Whether or not to delete the network interface on instance termination. Defaults to `false`. Currently, the only valid value is `false`, as this is only supported when creating new network interfaces when launching an instance.
        """
        return pulumi.get(self, "delete_on_termination")

    @property
    @pulumi.getter(name="networkCardIndex")
    def network_card_index(self) -> Optional[int]:
        """
        Integer index of the network card. Limited by instance type. The default index is `0`.
        """
        return pulumi.get(self, "network_card_index")


@pulumi.output_type
class SpotInstanceRequestPrivateDnsNameOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableResourceNameDnsARecord":
            suggest = "enable_resource_name_dns_a_record"
        elif key == "enableResourceNameDnsAaaaRecord":
            suggest = "enable_resource_name_dns_aaaa_record"
        elif key == "hostnameType":
            suggest = "hostname_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotInstanceRequestPrivateDnsNameOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotInstanceRequestPrivateDnsNameOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotInstanceRequestPrivateDnsNameOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_resource_name_dns_a_record: Optional[bool] = None,
                 enable_resource_name_dns_aaaa_record: Optional[bool] = None,
                 hostname_type: Optional[str] = None):
        """
        :param bool enable_resource_name_dns_a_record: Indicates whether to respond to DNS queries for instance hostnames with DNS A records.
        :param bool enable_resource_name_dns_aaaa_record: Indicates whether to respond to DNS queries for instance hostnames with DNS AAAA records.
        :param str hostname_type: Type of hostname for Amazon EC2 instances. For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 native subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID. Valid values: `ip-name` and `resource-name`.
        """
        SpotInstanceRequestPrivateDnsNameOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enable_resource_name_dns_a_record=enable_resource_name_dns_a_record,
            enable_resource_name_dns_aaaa_record=enable_resource_name_dns_aaaa_record,
            hostname_type=hostname_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enable_resource_name_dns_a_record: Optional[bool] = None,
             enable_resource_name_dns_aaaa_record: Optional[bool] = None,
             hostname_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if enable_resource_name_dns_a_record is None and 'enableResourceNameDnsARecord' in kwargs:
            enable_resource_name_dns_a_record = kwargs['enableResourceNameDnsARecord']
        if enable_resource_name_dns_aaaa_record is None and 'enableResourceNameDnsAaaaRecord' in kwargs:
            enable_resource_name_dns_aaaa_record = kwargs['enableResourceNameDnsAaaaRecord']
        if hostname_type is None and 'hostnameType' in kwargs:
            hostname_type = kwargs['hostnameType']

        if enable_resource_name_dns_a_record is not None:
            _setter("enable_resource_name_dns_a_record", enable_resource_name_dns_a_record)
        if enable_resource_name_dns_aaaa_record is not None:
            _setter("enable_resource_name_dns_aaaa_record", enable_resource_name_dns_aaaa_record)
        if hostname_type is not None:
            _setter("hostname_type", hostname_type)

    @property
    @pulumi.getter(name="enableResourceNameDnsARecord")
    def enable_resource_name_dns_a_record(self) -> Optional[bool]:
        """
        Indicates whether to respond to DNS queries for instance hostnames with DNS A records.
        """
        return pulumi.get(self, "enable_resource_name_dns_a_record")

    @property
    @pulumi.getter(name="enableResourceNameDnsAaaaRecord")
    def enable_resource_name_dns_aaaa_record(self) -> Optional[bool]:
        """
        Indicates whether to respond to DNS queries for instance hostnames with DNS AAAA records.
        """
        return pulumi.get(self, "enable_resource_name_dns_aaaa_record")

    @property
    @pulumi.getter(name="hostnameType")
    def hostname_type(self) -> Optional[str]:
        """
        Type of hostname for Amazon EC2 instances. For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 native subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID. Valid values: `ip-name` and `resource-name`.
        """
        return pulumi.get(self, "hostname_type")


@pulumi.output_type
class SpotInstanceRequestRootBlockDevice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "deviceName":
            suggest = "device_name"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "volumeId":
            suggest = "volume_id"
        elif key == "volumeSize":
            suggest = "volume_size"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotInstanceRequestRootBlockDevice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotInstanceRequestRootBlockDevice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotInstanceRequestRootBlockDevice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delete_on_termination: Optional[bool] = None,
                 device_name: Optional[str] = None,
                 encrypted: Optional[bool] = None,
                 iops: Optional[int] = None,
                 kms_key_id: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 throughput: Optional[int] = None,
                 volume_id: Optional[str] = None,
                 volume_size: Optional[int] = None,
                 volume_type: Optional[str] = None):
        """
        :param bool delete_on_termination: Whether the volume should be destroyed on instance termination. Defaults to `true`.
        :param str device_name: Name of the device to mount.
        :param bool encrypted: Whether to enable volume encryption. Defaults to `false`. Must be configured to perform drift detection.
        :param int iops: Amount of provisioned [IOPS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-io-characteristics.html). Only valid for volume_type of `io1`, `io2` or `gp3`.
        :param str kms_key_id: Amazon Resource Name (ARN) of the KMS Key to use when encrypting the volume. Must be configured to perform drift detection.
        :param Mapping[str, str] tags: Map of tags to assign to the device.
        :param int throughput: Throughput to provision for a volume in mebibytes per second (MiB/s). This is only valid for `volume_type` of `gp3`.
        :param int volume_size: Size of the volume in gibibytes (GiB).
        :param str volume_type: Type of volume. Valid values include `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1`, or `st1`. Defaults to `gp2`.
               
               Modifying the `encrypted` or `kms_key_id` settings of the `root_block_device` requires resource replacement.
        """
        SpotInstanceRequestRootBlockDevice._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            delete_on_termination=delete_on_termination,
            device_name=device_name,
            encrypted=encrypted,
            iops=iops,
            kms_key_id=kms_key_id,
            tags=tags,
            throughput=throughput,
            volume_id=volume_id,
            volume_size=volume_size,
            volume_type=volume_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             delete_on_termination: Optional[bool] = None,
             device_name: Optional[str] = None,
             encrypted: Optional[bool] = None,
             iops: Optional[int] = None,
             kms_key_id: Optional[str] = None,
             tags: Optional[Mapping[str, str]] = None,
             throughput: Optional[int] = None,
             volume_id: Optional[str] = None,
             volume_size: Optional[int] = None,
             volume_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if delete_on_termination is None and 'deleteOnTermination' in kwargs:
            delete_on_termination = kwargs['deleteOnTermination']
        if device_name is None and 'deviceName' in kwargs:
            device_name = kwargs['deviceName']
        if kms_key_id is None and 'kmsKeyId' in kwargs:
            kms_key_id = kwargs['kmsKeyId']
        if volume_id is None and 'volumeId' in kwargs:
            volume_id = kwargs['volumeId']
        if volume_size is None and 'volumeSize' in kwargs:
            volume_size = kwargs['volumeSize']
        if volume_type is None and 'volumeType' in kwargs:
            volume_type = kwargs['volumeType']

        if delete_on_termination is not None:
            _setter("delete_on_termination", delete_on_termination)
        if device_name is not None:
            _setter("device_name", device_name)
        if encrypted is not None:
            _setter("encrypted", encrypted)
        if iops is not None:
            _setter("iops", iops)
        if kms_key_id is not None:
            _setter("kms_key_id", kms_key_id)
        if tags is not None:
            _setter("tags", tags)
        if throughput is not None:
            _setter("throughput", throughput)
        if volume_id is not None:
            _setter("volume_id", volume_id)
        if volume_size is not None:
            _setter("volume_size", volume_size)
        if volume_type is not None:
            _setter("volume_type", volume_type)

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[bool]:
        """
        Whether the volume should be destroyed on instance termination. Defaults to `true`.
        """
        return pulumi.get(self, "delete_on_termination")

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[str]:
        """
        Name of the device to mount.
        """
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[bool]:
        """
        Whether to enable volume encryption. Defaults to `false`. Must be configured to perform drift detection.
        """
        return pulumi.get(self, "encrypted")

    @property
    @pulumi.getter
    def iops(self) -> Optional[int]:
        """
        Amount of provisioned [IOPS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-io-characteristics.html). Only valid for volume_type of `io1`, `io2` or `gp3`.
        """
        return pulumi.get(self, "iops")

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN) of the KMS Key to use when encrypting the volume. Must be configured to perform drift detection.
        """
        return pulumi.get(self, "kms_key_id")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Map of tags to assign to the device.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def throughput(self) -> Optional[int]:
        """
        Throughput to provision for a volume in mebibytes per second (MiB/s). This is only valid for `volume_type` of `gp3`.
        """
        return pulumi.get(self, "throughput")

    @property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> Optional[str]:
        return pulumi.get(self, "volume_id")

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[int]:
        """
        Size of the volume in gibibytes (GiB).
        """
        return pulumi.get(self, "volume_size")

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[str]:
        """
        Type of volume. Valid values include `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1`, or `st1`. Defaults to `gp2`.

        Modifying the `encrypted` or `kms_key_id` settings of the `root_block_device` requires resource replacement.
        """
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class TrafficMirrorFilterRuleDestinationPortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromPort":
            suggest = "from_port"
        elif key == "toPort":
            suggest = "to_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TrafficMirrorFilterRuleDestinationPortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TrafficMirrorFilterRuleDestinationPortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TrafficMirrorFilterRuleDestinationPortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_port: Optional[int] = None,
                 to_port: Optional[int] = None):
        """
        :param int from_port: Starting port of the range
        :param int to_port: Ending port of the range
        """
        TrafficMirrorFilterRuleDestinationPortRange._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            from_port=from_port,
            to_port=to_port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             from_port: Optional[int] = None,
             to_port: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if from_port is None and 'fromPort' in kwargs:
            from_port = kwargs['fromPort']
        if to_port is None and 'toPort' in kwargs:
            to_port = kwargs['toPort']

        if from_port is not None:
            _setter("from_port", from_port)
        if to_port is not None:
            _setter("to_port", to_port)

    @property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> Optional[int]:
        """
        Starting port of the range
        """
        return pulumi.get(self, "from_port")

    @property
    @pulumi.getter(name="toPort")
    def to_port(self) -> Optional[int]:
        """
        Ending port of the range
        """
        return pulumi.get(self, "to_port")


@pulumi.output_type
class TrafficMirrorFilterRuleSourcePortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromPort":
            suggest = "from_port"
        elif key == "toPort":
            suggest = "to_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TrafficMirrorFilterRuleSourcePortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TrafficMirrorFilterRuleSourcePortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TrafficMirrorFilterRuleSourcePortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_port: Optional[int] = None,
                 to_port: Optional[int] = None):
        """
        :param int from_port: Starting port of the range
        :param int to_port: Ending port of the range
        """
        TrafficMirrorFilterRuleSourcePortRange._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            from_port=from_port,
            to_port=to_port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             from_port: Optional[int] = None,
             to_port: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if from_port is None and 'fromPort' in kwargs:
            from_port = kwargs['fromPort']
        if to_port is None and 'toPort' in kwargs:
            to_port = kwargs['toPort']

        if from_port is not None:
            _setter("from_port", from_port)
        if to_port is not None:
            _setter("to_port", to_port)

    @property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> Optional[int]:
        """
        Starting port of the range
        """
        return pulumi.get(self, "from_port")

    @property
    @pulumi.getter(name="toPort")
    def to_port(self) -> Optional[int]:
        """
        Ending port of the range
        """
        return pulumi.get(self, "to_port")


@pulumi.output_type
class VpcEndpointDnsEntry(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsName":
            suggest = "dns_name"
        elif key == "hostedZoneId":
            suggest = "hosted_zone_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcEndpointDnsEntry. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcEndpointDnsEntry.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcEndpointDnsEntry.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dns_name: Optional[str] = None,
                 hosted_zone_id: Optional[str] = None):
        """
        :param str dns_name: The DNS name.
        :param str hosted_zone_id: The ID of the private hosted zone.
        """
        VpcEndpointDnsEntry._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dns_name=dns_name,
            hosted_zone_id=hosted_zone_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dns_name: Optional[str] = None,
             hosted_zone_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if dns_name is None and 'dnsName' in kwargs:
            dns_name = kwargs['dnsName']
        if hosted_zone_id is None and 'hostedZoneId' in kwargs:
            hosted_zone_id = kwargs['hostedZoneId']

        if dns_name is not None:
            _setter("dns_name", dns_name)
        if hosted_zone_id is not None:
            _setter("hosted_zone_id", hosted_zone_id)

    @property
    @pulumi.getter(name="dnsName")
    def dns_name(self) -> Optional[str]:
        """
        The DNS name.
        """
        return pulumi.get(self, "dns_name")

    @property
    @pulumi.getter(name="hostedZoneId")
    def hosted_zone_id(self) -> Optional[str]:
        """
        The ID of the private hosted zone.
        """
        return pulumi.get(self, "hosted_zone_id")


@pulumi.output_type
class VpcEndpointDnsOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsRecordIpType":
            suggest = "dns_record_ip_type"
        elif key == "privateDnsOnlyForInboundResolverEndpoint":
            suggest = "private_dns_only_for_inbound_resolver_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcEndpointDnsOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcEndpointDnsOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcEndpointDnsOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dns_record_ip_type: Optional[str] = None,
                 private_dns_only_for_inbound_resolver_endpoint: Optional[bool] = None):
        """
        :param str dns_record_ip_type: The DNS records created for the endpoint. Valid values are `ipv4`, `dualstack`, `service-defined`, and `ipv6`.
        :param bool private_dns_only_for_inbound_resolver_endpoint: Indicates whether to enable private DNS only for inbound endpoints. This option is available only for services that support both gateway and interface endpoints. It routes traffic that originates from the VPC to the gateway endpoint and traffic that originates from on-premises to the interface endpoint. Default is `false`. Can only be specified if private_dns_enabled is `true`.
        """
        VpcEndpointDnsOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dns_record_ip_type=dns_record_ip_type,
            private_dns_only_for_inbound_resolver_endpoint=private_dns_only_for_inbound_resolver_endpoint,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dns_record_ip_type: Optional[str] = None,
             private_dns_only_for_inbound_resolver_endpoint: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if dns_record_ip_type is None and 'dnsRecordIpType' in kwargs:
            dns_record_ip_type = kwargs['dnsRecordIpType']
        if private_dns_only_for_inbound_resolver_endpoint is None and 'privateDnsOnlyForInboundResolverEndpoint' in kwargs:
            private_dns_only_for_inbound_resolver_endpoint = kwargs['privateDnsOnlyForInboundResolverEndpoint']

        if dns_record_ip_type is not None:
            _setter("dns_record_ip_type", dns_record_ip_type)
        if private_dns_only_for_inbound_resolver_endpoint is not None:
            _setter("private_dns_only_for_inbound_resolver_endpoint", private_dns_only_for_inbound_resolver_endpoint)

    @property
    @pulumi.getter(name="dnsRecordIpType")
    def dns_record_ip_type(self) -> Optional[str]:
        """
        The DNS records created for the endpoint. Valid values are `ipv4`, `dualstack`, `service-defined`, and `ipv6`.
        """
        return pulumi.get(self, "dns_record_ip_type")

    @property
    @pulumi.getter(name="privateDnsOnlyForInboundResolverEndpoint")
    def private_dns_only_for_inbound_resolver_endpoint(self) -> Optional[bool]:
        """
        Indicates whether to enable private DNS only for inbound endpoints. This option is available only for services that support both gateway and interface endpoints. It routes traffic that originates from the VPC to the gateway endpoint and traffic that originates from on-premises to the interface endpoint. Default is `false`. Can only be specified if private_dns_enabled is `true`.
        """
        return pulumi.get(self, "private_dns_only_for_inbound_resolver_endpoint")


@pulumi.output_type
class VpcEndpointServicePrivateDnsNameConfiguration(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 state: Optional[str] = None,
                 type: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: Name of the record subdomain the service provider needs to create.
        :param str state: Verification state of the VPC endpoint service. Consumers of the endpoint service can use the private name only when the state is `verified`.
        :param str type: Endpoint service verification type, for example `TXT`.
        :param str value: Value the service provider adds to the private DNS name domain record before verification.
        """
        VpcEndpointServicePrivateDnsNameConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            state=state,
            type=type,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             state: Optional[str] = None,
             type: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if name is not None:
            _setter("name", name)
        if state is not None:
            _setter("state", state)
        if type is not None:
            _setter("type", type)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the record subdomain the service provider needs to create.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        Verification state of the VPC endpoint service. Consumers of the endpoint service can use the private name only when the state is `verified`.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Endpoint service verification type, for example `TXT`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value the service provider adds to the private DNS name domain record before verification.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class VpcIpamOperatingRegion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "regionName":
            suggest = "region_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcIpamOperatingRegion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcIpamOperatingRegion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcIpamOperatingRegion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 region_name: str):
        """
        :param str region_name: The name of the Region you want to add to the IPAM.
        """
        VpcIpamOperatingRegion._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            region_name=region_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             region_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if region_name is None and 'regionName' in kwargs:
            region_name = kwargs['regionName']
        if region_name is None:
            raise TypeError("Missing 'region_name' argument")

        _setter("region_name", region_name)

    @property
    @pulumi.getter(name="regionName")
    def region_name(self) -> str:
        """
        The name of the Region you want to add to the IPAM.
        """
        return pulumi.get(self, "region_name")


@pulumi.output_type
class VpcIpamPoolCidrCidrAuthorizationContext(dict):
    def __init__(__self__, *,
                 message: Optional[str] = None,
                 signature: Optional[str] = None):
        """
        :param str message: The plain-text authorization message for the prefix and account.
        :param str signature: The signed authorization message for the prefix and account.
        """
        VpcIpamPoolCidrCidrAuthorizationContext._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            message=message,
            signature=signature,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             message: Optional[str] = None,
             signature: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if message is not None:
            _setter("message", message)
        if signature is not None:
            _setter("signature", signature)

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        The plain-text authorization message for the prefix and account.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def signature(self) -> Optional[str]:
        """
        The signed authorization message for the prefix and account.
        """
        return pulumi.get(self, "signature")


@pulumi.output_type
class VpcIpamResourceDiscoveryOperatingRegion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "regionName":
            suggest = "region_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcIpamResourceDiscoveryOperatingRegion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcIpamResourceDiscoveryOperatingRegion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcIpamResourceDiscoveryOperatingRegion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 region_name: str):
        """
        :param str region_name: The name of the Region you want to add to the IPAM.
        """
        VpcIpamResourceDiscoveryOperatingRegion._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            region_name=region_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             region_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if region_name is None and 'regionName' in kwargs:
            region_name = kwargs['regionName']
        if region_name is None:
            raise TypeError("Missing 'region_name' argument")

        _setter("region_name", region_name)

    @property
    @pulumi.getter(name="regionName")
    def region_name(self) -> str:
        """
        The name of the Region you want to add to the IPAM.
        """
        return pulumi.get(self, "region_name")


@pulumi.output_type
class VpcPeeringConnectionAccepter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowRemoteVpcDnsResolution":
            suggest = "allow_remote_vpc_dns_resolution"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcPeeringConnectionAccepter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcPeeringConnectionAccepter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcPeeringConnectionAccepter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_remote_vpc_dns_resolution: Optional[bool] = None):
        """
        :param bool allow_remote_vpc_dns_resolution: Allow a local VPC to resolve public DNS hostnames to
               private IP addresses when queried from instances in the peer VPC.
        """
        VpcPeeringConnectionAccepter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allow_remote_vpc_dns_resolution=allow_remote_vpc_dns_resolution,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allow_remote_vpc_dns_resolution: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if allow_remote_vpc_dns_resolution is None and 'allowRemoteVpcDnsResolution' in kwargs:
            allow_remote_vpc_dns_resolution = kwargs['allowRemoteVpcDnsResolution']

        if allow_remote_vpc_dns_resolution is not None:
            _setter("allow_remote_vpc_dns_resolution", allow_remote_vpc_dns_resolution)

    @property
    @pulumi.getter(name="allowRemoteVpcDnsResolution")
    def allow_remote_vpc_dns_resolution(self) -> Optional[bool]:
        """
        Allow a local VPC to resolve public DNS hostnames to
        private IP addresses when queried from instances in the peer VPC.
        """
        return pulumi.get(self, "allow_remote_vpc_dns_resolution")


@pulumi.output_type
class VpcPeeringConnectionAccepterAccepter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowRemoteVpcDnsResolution":
            suggest = "allow_remote_vpc_dns_resolution"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcPeeringConnectionAccepterAccepter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcPeeringConnectionAccepterAccepter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcPeeringConnectionAccepterAccepter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_remote_vpc_dns_resolution: Optional[bool] = None):
        """
        :param bool allow_remote_vpc_dns_resolution: Indicates whether a local VPC can resolve public DNS hostnames to
               private IP addresses when queried from instances in a peer VPC.
        """
        VpcPeeringConnectionAccepterAccepter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allow_remote_vpc_dns_resolution=allow_remote_vpc_dns_resolution,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allow_remote_vpc_dns_resolution: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if allow_remote_vpc_dns_resolution is None and 'allowRemoteVpcDnsResolution' in kwargs:
            allow_remote_vpc_dns_resolution = kwargs['allowRemoteVpcDnsResolution']

        if allow_remote_vpc_dns_resolution is not None:
            _setter("allow_remote_vpc_dns_resolution", allow_remote_vpc_dns_resolution)

    @property
    @pulumi.getter(name="allowRemoteVpcDnsResolution")
    def allow_remote_vpc_dns_resolution(self) -> Optional[bool]:
        """
        Indicates whether a local VPC can resolve public DNS hostnames to
        private IP addresses when queried from instances in a peer VPC.
        """
        return pulumi.get(self, "allow_remote_vpc_dns_resolution")


@pulumi.output_type
class VpcPeeringConnectionAccepterRequester(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowRemoteVpcDnsResolution":
            suggest = "allow_remote_vpc_dns_resolution"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcPeeringConnectionAccepterRequester. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcPeeringConnectionAccepterRequester.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcPeeringConnectionAccepterRequester.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_remote_vpc_dns_resolution: Optional[bool] = None):
        """
        :param bool allow_remote_vpc_dns_resolution: Indicates whether a local VPC can resolve public DNS hostnames to
               private IP addresses when queried from instances in a peer VPC.
        """
        VpcPeeringConnectionAccepterRequester._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allow_remote_vpc_dns_resolution=allow_remote_vpc_dns_resolution,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allow_remote_vpc_dns_resolution: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if allow_remote_vpc_dns_resolution is None and 'allowRemoteVpcDnsResolution' in kwargs:
            allow_remote_vpc_dns_resolution = kwargs['allowRemoteVpcDnsResolution']

        if allow_remote_vpc_dns_resolution is not None:
            _setter("allow_remote_vpc_dns_resolution", allow_remote_vpc_dns_resolution)

    @property
    @pulumi.getter(name="allowRemoteVpcDnsResolution")
    def allow_remote_vpc_dns_resolution(self) -> Optional[bool]:
        """
        Indicates whether a local VPC can resolve public DNS hostnames to
        private IP addresses when queried from instances in a peer VPC.
        """
        return pulumi.get(self, "allow_remote_vpc_dns_resolution")


@pulumi.output_type
class VpcPeeringConnectionRequester(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowRemoteVpcDnsResolution":
            suggest = "allow_remote_vpc_dns_resolution"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcPeeringConnectionRequester. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcPeeringConnectionRequester.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcPeeringConnectionRequester.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_remote_vpc_dns_resolution: Optional[bool] = None):
        """
        :param bool allow_remote_vpc_dns_resolution: Allow a local VPC to resolve public DNS hostnames to
               private IP addresses when queried from instances in the peer VPC.
        """
        VpcPeeringConnectionRequester._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allow_remote_vpc_dns_resolution=allow_remote_vpc_dns_resolution,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allow_remote_vpc_dns_resolution: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if allow_remote_vpc_dns_resolution is None and 'allowRemoteVpcDnsResolution' in kwargs:
            allow_remote_vpc_dns_resolution = kwargs['allowRemoteVpcDnsResolution']

        if allow_remote_vpc_dns_resolution is not None:
            _setter("allow_remote_vpc_dns_resolution", allow_remote_vpc_dns_resolution)

    @property
    @pulumi.getter(name="allowRemoteVpcDnsResolution")
    def allow_remote_vpc_dns_resolution(self) -> Optional[bool]:
        """
        Allow a local VPC to resolve public DNS hostnames to
        private IP addresses when queried from instances in the peer VPC.
        """
        return pulumi.get(self, "allow_remote_vpc_dns_resolution")


@pulumi.output_type
class VpnConnectionRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationCidrBlock":
            suggest = "destination_cidr_block"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpnConnectionRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpnConnectionRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpnConnectionRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_cidr_block: Optional[str] = None,
                 source: Optional[str] = None,
                 state: Optional[str] = None):
        """
        :param str destination_cidr_block: The CIDR block associated with the local subnet of the customer data center.
        :param str source: Indicates how the routes were provided.
        :param str state: The current state of the static route.
        """
        VpnConnectionRoute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination_cidr_block=destination_cidr_block,
            source=source,
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination_cidr_block: Optional[str] = None,
             source: Optional[str] = None,
             state: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if destination_cidr_block is None and 'destinationCidrBlock' in kwargs:
            destination_cidr_block = kwargs['destinationCidrBlock']

        if destination_cidr_block is not None:
            _setter("destination_cidr_block", destination_cidr_block)
        if source is not None:
            _setter("source", source)
        if state is not None:
            _setter("state", state)

    @property
    @pulumi.getter(name="destinationCidrBlock")
    def destination_cidr_block(self) -> Optional[str]:
        """
        The CIDR block associated with the local subnet of the customer data center.
        """
        return pulumi.get(self, "destination_cidr_block")

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        """
        Indicates how the routes were provided.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        The current state of the static route.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class VpnConnectionTunnel1LogOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudwatchLogOptions":
            suggest = "cloudwatch_log_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpnConnectionTunnel1LogOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpnConnectionTunnel1LogOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpnConnectionTunnel1LogOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloudwatch_log_options: Optional['outputs.VpnConnectionTunnel1LogOptionsCloudwatchLogOptions'] = None):
        """
        :param 'VpnConnectionTunnel1LogOptionsCloudwatchLogOptionsArgs' cloudwatch_log_options: Options for sending VPN tunnel logs to CloudWatch. See CloudWatch Log Options below for more details.
        """
        VpnConnectionTunnel1LogOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloudwatch_log_options=cloudwatch_log_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloudwatch_log_options: Optional['outputs.VpnConnectionTunnel1LogOptionsCloudwatchLogOptions'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cloudwatch_log_options is None and 'cloudwatchLogOptions' in kwargs:
            cloudwatch_log_options = kwargs['cloudwatchLogOptions']

        if cloudwatch_log_options is not None:
            _setter("cloudwatch_log_options", cloudwatch_log_options)

    @property
    @pulumi.getter(name="cloudwatchLogOptions")
    def cloudwatch_log_options(self) -> Optional['outputs.VpnConnectionTunnel1LogOptionsCloudwatchLogOptions']:
        """
        Options for sending VPN tunnel logs to CloudWatch. See CloudWatch Log Options below for more details.
        """
        return pulumi.get(self, "cloudwatch_log_options")


@pulumi.output_type
class VpnConnectionTunnel1LogOptionsCloudwatchLogOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logEnabled":
            suggest = "log_enabled"
        elif key == "logGroupArn":
            suggest = "log_group_arn"
        elif key == "logOutputFormat":
            suggest = "log_output_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpnConnectionTunnel1LogOptionsCloudwatchLogOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpnConnectionTunnel1LogOptionsCloudwatchLogOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpnConnectionTunnel1LogOptionsCloudwatchLogOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_enabled: Optional[bool] = None,
                 log_group_arn: Optional[str] = None,
                 log_output_format: Optional[str] = None):
        """
        :param bool log_enabled: Enable or disable VPN tunnel logging feature. The default is `false`.
        :param str log_group_arn: The Amazon Resource Name (ARN) of the CloudWatch log group to send logs to.
        :param str log_output_format: Set log format. Default format is json. Possible values are: `json` and `text`. The default is `json`.
        """
        VpnConnectionTunnel1LogOptionsCloudwatchLogOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            log_enabled=log_enabled,
            log_group_arn=log_group_arn,
            log_output_format=log_output_format,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             log_enabled: Optional[bool] = None,
             log_group_arn: Optional[str] = None,
             log_output_format: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if log_enabled is None and 'logEnabled' in kwargs:
            log_enabled = kwargs['logEnabled']
        if log_group_arn is None and 'logGroupArn' in kwargs:
            log_group_arn = kwargs['logGroupArn']
        if log_output_format is None and 'logOutputFormat' in kwargs:
            log_output_format = kwargs['logOutputFormat']

        if log_enabled is not None:
            _setter("log_enabled", log_enabled)
        if log_group_arn is not None:
            _setter("log_group_arn", log_group_arn)
        if log_output_format is not None:
            _setter("log_output_format", log_output_format)

    @property
    @pulumi.getter(name="logEnabled")
    def log_enabled(self) -> Optional[bool]:
        """
        Enable or disable VPN tunnel logging feature. The default is `false`.
        """
        return pulumi.get(self, "log_enabled")

    @property
    @pulumi.getter(name="logGroupArn")
    def log_group_arn(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) of the CloudWatch log group to send logs to.
        """
        return pulumi.get(self, "log_group_arn")

    @property
    @pulumi.getter(name="logOutputFormat")
    def log_output_format(self) -> Optional[str]:
        """
        Set log format. Default format is json. Possible values are: `json` and `text`. The default is `json`.
        """
        return pulumi.get(self, "log_output_format")


@pulumi.output_type
class VpnConnectionTunnel2LogOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudwatchLogOptions":
            suggest = "cloudwatch_log_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpnConnectionTunnel2LogOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpnConnectionTunnel2LogOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpnConnectionTunnel2LogOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloudwatch_log_options: Optional['outputs.VpnConnectionTunnel2LogOptionsCloudwatchLogOptions'] = None):
        """
        :param 'VpnConnectionTunnel2LogOptionsCloudwatchLogOptionsArgs' cloudwatch_log_options: Options for sending VPN tunnel logs to CloudWatch. See CloudWatch Log Options below for more details.
        """
        VpnConnectionTunnel2LogOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloudwatch_log_options=cloudwatch_log_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloudwatch_log_options: Optional['outputs.VpnConnectionTunnel2LogOptionsCloudwatchLogOptions'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cloudwatch_log_options is None and 'cloudwatchLogOptions' in kwargs:
            cloudwatch_log_options = kwargs['cloudwatchLogOptions']

        if cloudwatch_log_options is not None:
            _setter("cloudwatch_log_options", cloudwatch_log_options)

    @property
    @pulumi.getter(name="cloudwatchLogOptions")
    def cloudwatch_log_options(self) -> Optional['outputs.VpnConnectionTunnel2LogOptionsCloudwatchLogOptions']:
        """
        Options for sending VPN tunnel logs to CloudWatch. See CloudWatch Log Options below for more details.
        """
        return pulumi.get(self, "cloudwatch_log_options")


@pulumi.output_type
class VpnConnectionTunnel2LogOptionsCloudwatchLogOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logEnabled":
            suggest = "log_enabled"
        elif key == "logGroupArn":
            suggest = "log_group_arn"
        elif key == "logOutputFormat":
            suggest = "log_output_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpnConnectionTunnel2LogOptionsCloudwatchLogOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpnConnectionTunnel2LogOptionsCloudwatchLogOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpnConnectionTunnel2LogOptionsCloudwatchLogOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_enabled: Optional[bool] = None,
                 log_group_arn: Optional[str] = None,
                 log_output_format: Optional[str] = None):
        """
        :param bool log_enabled: Enable or disable VPN tunnel logging feature. The default is `false`.
        :param str log_group_arn: The Amazon Resource Name (ARN) of the CloudWatch log group to send logs to.
        :param str log_output_format: Set log format. Default format is json. Possible values are: `json` and `text`. The default is `json`.
        """
        VpnConnectionTunnel2LogOptionsCloudwatchLogOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            log_enabled=log_enabled,
            log_group_arn=log_group_arn,
            log_output_format=log_output_format,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             log_enabled: Optional[bool] = None,
             log_group_arn: Optional[str] = None,
             log_output_format: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if log_enabled is None and 'logEnabled' in kwargs:
            log_enabled = kwargs['logEnabled']
        if log_group_arn is None and 'logGroupArn' in kwargs:
            log_group_arn = kwargs['logGroupArn']
        if log_output_format is None and 'logOutputFormat' in kwargs:
            log_output_format = kwargs['logOutputFormat']

        if log_enabled is not None:
            _setter("log_enabled", log_enabled)
        if log_group_arn is not None:
            _setter("log_group_arn", log_group_arn)
        if log_output_format is not None:
            _setter("log_output_format", log_output_format)

    @property
    @pulumi.getter(name="logEnabled")
    def log_enabled(self) -> Optional[bool]:
        """
        Enable or disable VPN tunnel logging feature. The default is `false`.
        """
        return pulumi.get(self, "log_enabled")

    @property
    @pulumi.getter(name="logGroupArn")
    def log_group_arn(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) of the CloudWatch log group to send logs to.
        """
        return pulumi.get(self, "log_group_arn")

    @property
    @pulumi.getter(name="logOutputFormat")
    def log_output_format(self) -> Optional[str]:
        """
        Set log format. Default format is json. Possible values are: `json` and `text`. The default is `json`.
        """
        return pulumi.get(self, "log_output_format")


@pulumi.output_type
class VpnConnectionVgwTelemetry(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acceptedRouteCount":
            suggest = "accepted_route_count"
        elif key == "certificateArn":
            suggest = "certificate_arn"
        elif key == "lastStatusChange":
            suggest = "last_status_change"
        elif key == "outsideIpAddress":
            suggest = "outside_ip_address"
        elif key == "statusMessage":
            suggest = "status_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpnConnectionVgwTelemetry. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpnConnectionVgwTelemetry.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpnConnectionVgwTelemetry.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 accepted_route_count: Optional[int] = None,
                 certificate_arn: Optional[str] = None,
                 last_status_change: Optional[str] = None,
                 outside_ip_address: Optional[str] = None,
                 status: Optional[str] = None,
                 status_message: Optional[str] = None):
        """
        :param int accepted_route_count: The number of accepted routes.
        :param str certificate_arn: The Amazon Resource Name (ARN) of the VPN tunnel endpoint certificate.
        :param str last_status_change: The date and time of the last change in status.
        :param str outside_ip_address: The Internet-routable IP address of the virtual private gateway's outside interface.
        :param str status: The status of the VPN tunnel.
        :param str status_message: If an error occurs, a description of the error.
        """
        VpnConnectionVgwTelemetry._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            accepted_route_count=accepted_route_count,
            certificate_arn=certificate_arn,
            last_status_change=last_status_change,
            outside_ip_address=outside_ip_address,
            status=status,
            status_message=status_message,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             accepted_route_count: Optional[int] = None,
             certificate_arn: Optional[str] = None,
             last_status_change: Optional[str] = None,
             outside_ip_address: Optional[str] = None,
             status: Optional[str] = None,
             status_message: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if accepted_route_count is None and 'acceptedRouteCount' in kwargs:
            accepted_route_count = kwargs['acceptedRouteCount']
        if certificate_arn is None and 'certificateArn' in kwargs:
            certificate_arn = kwargs['certificateArn']
        if last_status_change is None and 'lastStatusChange' in kwargs:
            last_status_change = kwargs['lastStatusChange']
        if outside_ip_address is None and 'outsideIpAddress' in kwargs:
            outside_ip_address = kwargs['outsideIpAddress']
        if status_message is None and 'statusMessage' in kwargs:
            status_message = kwargs['statusMessage']

        if accepted_route_count is not None:
            _setter("accepted_route_count", accepted_route_count)
        if certificate_arn is not None:
            _setter("certificate_arn", certificate_arn)
        if last_status_change is not None:
            _setter("last_status_change", last_status_change)
        if outside_ip_address is not None:
            _setter("outside_ip_address", outside_ip_address)
        if status is not None:
            _setter("status", status)
        if status_message is not None:
            _setter("status_message", status_message)

    @property
    @pulumi.getter(name="acceptedRouteCount")
    def accepted_route_count(self) -> Optional[int]:
        """
        The number of accepted routes.
        """
        return pulumi.get(self, "accepted_route_count")

    @property
    @pulumi.getter(name="certificateArn")
    def certificate_arn(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) of the VPN tunnel endpoint certificate.
        """
        return pulumi.get(self, "certificate_arn")

    @property
    @pulumi.getter(name="lastStatusChange")
    def last_status_change(self) -> Optional[str]:
        """
        The date and time of the last change in status.
        """
        return pulumi.get(self, "last_status_change")

    @property
    @pulumi.getter(name="outsideIpAddress")
    def outside_ip_address(self) -> Optional[str]:
        """
        The Internet-routable IP address of the virtual private gateway's outside interface.
        """
        return pulumi.get(self, "outside_ip_address")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        The status of the VPN tunnel.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="statusMessage")
    def status_message(self) -> Optional[str]:
        """
        If an error occurs, a description of the error.
        """
        return pulumi.get(self, "status_message")


@pulumi.output_type
class GetAmiBlockDeviceMappingResult(dict):
    def __init__(__self__, *,
                 device_name: str,
                 ebs: Mapping[str, str],
                 no_device: str,
                 virtual_name: str):
        """
        :param str device_name: Physical name of the device.
        :param Mapping[str, str] ebs: Map containing EBS information, if the device is EBS based. Unlike most object attributes, these are accessed directly (e.g., `ebs.volume_size` or `ebs["volume_size"]`) rather than accessed through the first element of a list (e.g., `ebs[0].volume_size`).
        :param str no_device: Suppresses the specified device included in the block device mapping of the AMI.
        :param str virtual_name: Virtual device name (for instance stores).
        """
        GetAmiBlockDeviceMappingResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            device_name=device_name,
            ebs=ebs,
            no_device=no_device,
            virtual_name=virtual_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             device_name: Optional[str] = None,
             ebs: Optional[Mapping[str, str]] = None,
             no_device: Optional[str] = None,
             virtual_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if device_name is None and 'deviceName' in kwargs:
            device_name = kwargs['deviceName']
        if device_name is None:
            raise TypeError("Missing 'device_name' argument")
        if ebs is None:
            raise TypeError("Missing 'ebs' argument")
        if no_device is None and 'noDevice' in kwargs:
            no_device = kwargs['noDevice']
        if no_device is None:
            raise TypeError("Missing 'no_device' argument")
        if virtual_name is None and 'virtualName' in kwargs:
            virtual_name = kwargs['virtualName']
        if virtual_name is None:
            raise TypeError("Missing 'virtual_name' argument")

        _setter("device_name", device_name)
        _setter("ebs", ebs)
        _setter("no_device", no_device)
        _setter("virtual_name", virtual_name)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> str:
        """
        Physical name of the device.
        """
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter
    def ebs(self) -> Mapping[str, str]:
        """
        Map containing EBS information, if the device is EBS based. Unlike most object attributes, these are accessed directly (e.g., `ebs.volume_size` or `ebs["volume_size"]`) rather than accessed through the first element of a list (e.g., `ebs[0].volume_size`).
        """
        return pulumi.get(self, "ebs")

    @property
    @pulumi.getter(name="noDevice")
    def no_device(self) -> str:
        """
        Suppresses the specified device included in the block device mapping of the AMI.
        """
        return pulumi.get(self, "no_device")

    @property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> str:
        """
        Virtual device name (for instance stores).
        """
        return pulumi.get(self, "virtual_name")


@pulumi.output_type
class GetAmiFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Name of the AMI that was provided during image creation.
        """
        GetAmiFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the AMI that was provided during image creation.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetAmiIdsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        GetAmiIdsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetAmiProductCodeResult(dict):
    def __init__(__self__, *,
                 product_code_id: str,
                 product_code_type: str):
        GetAmiProductCodeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            product_code_id=product_code_id,
            product_code_type=product_code_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             product_code_id: Optional[str] = None,
             product_code_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if product_code_id is None and 'productCodeId' in kwargs:
            product_code_id = kwargs['productCodeId']
        if product_code_id is None:
            raise TypeError("Missing 'product_code_id' argument")
        if product_code_type is None and 'productCodeType' in kwargs:
            product_code_type = kwargs['productCodeType']
        if product_code_type is None:
            raise TypeError("Missing 'product_code_type' argument")

        _setter("product_code_id", product_code_id)
        _setter("product_code_type", product_code_type)

    @property
    @pulumi.getter(name="productCodeId")
    def product_code_id(self) -> str:
        return pulumi.get(self, "product_code_id")

    @property
    @pulumi.getter(name="productCodeType")
    def product_code_type(self) -> str:
        return pulumi.get(self, "product_code_type")


@pulumi.output_type
class GetCoipPoolFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Name of the field to filter by, as defined by
               [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeCoipPools.html).
        :param Sequence[str] values: Set of values that are accepted for the given field.
               A COIP Pool will be selected if any one of the given values matches.
        """
        GetCoipPoolFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the field to filter by, as defined by
        [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeCoipPools.html).
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Set of values that are accepted for the given field.
        A COIP Pool will be selected if any one of the given values matches.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCoipPoolsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Name of the field to filter by, as defined by
               [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeCoipPools.html).
        :param Sequence[str] values: Set of values that are accepted for the given field.
               A COIP Pool will be selected if any one of the given values matches.
        """
        GetCoipPoolsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the field to filter by, as defined by
        [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeCoipPools.html).
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Set of values that are accepted for the given field.
        A COIP Pool will be selected if any one of the given values matches.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCustomerGatewayFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        GetCustomerGatewayFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetDedicatedHostFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Name of the field to filter by, as defined by [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeHosts.html).
        :param Sequence[str] values: Set of values that are accepted for the given field. A host will be selected if any one of the given values matches.
        """
        GetDedicatedHostFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the field to filter by, as defined by [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeHosts.html).
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Set of values that are accepted for the given field. A host will be selected if any one of the given values matches.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetEipsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Name of the field to filter by, as defined by
               [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeAddresses.html).
        :param Sequence[str] values: Set of values that are accepted for the given field. An Elastic IP will be selected if any one of the given values matches.
        """
        GetEipsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the field to filter by, as defined by
        [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeAddresses.html).
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Set of values that are accepted for the given field. An Elastic IP will be selected if any one of the given values matches.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetElasticIpFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        GetElasticIpFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetInstanceCreditSpecificationResult(dict):
    def __init__(__self__, *,
                 cpu_credits: str):
        GetInstanceCreditSpecificationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cpu_credits=cpu_credits,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cpu_credits: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cpu_credits is None and 'cpuCredits' in kwargs:
            cpu_credits = kwargs['cpuCredits']
        if cpu_credits is None:
            raise TypeError("Missing 'cpu_credits' argument")

        _setter("cpu_credits", cpu_credits)

    @property
    @pulumi.getter(name="cpuCredits")
    def cpu_credits(self) -> str:
        return pulumi.get(self, "cpu_credits")


@pulumi.output_type
class GetInstanceEbsBlockDeviceResult(dict):
    def __init__(__self__, *,
                 delete_on_termination: bool,
                 device_name: str,
                 encrypted: bool,
                 iops: int,
                 kms_key_id: str,
                 snapshot_id: str,
                 tags: Mapping[str, str],
                 throughput: int,
                 volume_id: str,
                 volume_size: int,
                 volume_type: str):
        """
        :param bool delete_on_termination: If the root block device will be deleted on termination.
        :param str device_name: Physical name of the device.
        :param bool encrypted: If the EBS volume is encrypted.
        :param int iops: `0` If the volume is not a provisioned IOPS image, otherwise the supported IOPS count.
        :param str snapshot_id: ID of the snapshot.
        :param Mapping[str, str] tags: Map of tags assigned to the Instance.
        :param int throughput: Throughput of the volume, in MiB/s.
        :param int volume_size: Size of the volume, in GiB.
        :param str volume_type: Type of the volume.
        """
        GetInstanceEbsBlockDeviceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            delete_on_termination=delete_on_termination,
            device_name=device_name,
            encrypted=encrypted,
            iops=iops,
            kms_key_id=kms_key_id,
            snapshot_id=snapshot_id,
            tags=tags,
            throughput=throughput,
            volume_id=volume_id,
            volume_size=volume_size,
            volume_type=volume_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             delete_on_termination: Optional[bool] = None,
             device_name: Optional[str] = None,
             encrypted: Optional[bool] = None,
             iops: Optional[int] = None,
             kms_key_id: Optional[str] = None,
             snapshot_id: Optional[str] = None,
             tags: Optional[Mapping[str, str]] = None,
             throughput: Optional[int] = None,
             volume_id: Optional[str] = None,
             volume_size: Optional[int] = None,
             volume_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if delete_on_termination is None and 'deleteOnTermination' in kwargs:
            delete_on_termination = kwargs['deleteOnTermination']
        if delete_on_termination is None:
            raise TypeError("Missing 'delete_on_termination' argument")
        if device_name is None and 'deviceName' in kwargs:
            device_name = kwargs['deviceName']
        if device_name is None:
            raise TypeError("Missing 'device_name' argument")
        if encrypted is None:
            raise TypeError("Missing 'encrypted' argument")
        if iops is None:
            raise TypeError("Missing 'iops' argument")
        if kms_key_id is None and 'kmsKeyId' in kwargs:
            kms_key_id = kwargs['kmsKeyId']
        if kms_key_id is None:
            raise TypeError("Missing 'kms_key_id' argument")
        if snapshot_id is None and 'snapshotId' in kwargs:
            snapshot_id = kwargs['snapshotId']
        if snapshot_id is None:
            raise TypeError("Missing 'snapshot_id' argument")
        if tags is None:
            raise TypeError("Missing 'tags' argument")
        if throughput is None:
            raise TypeError("Missing 'throughput' argument")
        if volume_id is None and 'volumeId' in kwargs:
            volume_id = kwargs['volumeId']
        if volume_id is None:
            raise TypeError("Missing 'volume_id' argument")
        if volume_size is None and 'volumeSize' in kwargs:
            volume_size = kwargs['volumeSize']
        if volume_size is None:
            raise TypeError("Missing 'volume_size' argument")
        if volume_type is None and 'volumeType' in kwargs:
            volume_type = kwargs['volumeType']
        if volume_type is None:
            raise TypeError("Missing 'volume_type' argument")

        _setter("delete_on_termination", delete_on_termination)
        _setter("device_name", device_name)
        _setter("encrypted", encrypted)
        _setter("iops", iops)
        _setter("kms_key_id", kms_key_id)
        _setter("snapshot_id", snapshot_id)
        _setter("tags", tags)
        _setter("throughput", throughput)
        _setter("volume_id", volume_id)
        _setter("volume_size", volume_size)
        _setter("volume_type", volume_type)

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> bool:
        """
        If the root block device will be deleted on termination.
        """
        return pulumi.get(self, "delete_on_termination")

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> str:
        """
        Physical name of the device.
        """
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter
    def encrypted(self) -> bool:
        """
        If the EBS volume is encrypted.
        """
        return pulumi.get(self, "encrypted")

    @property
    @pulumi.getter
    def iops(self) -> int:
        """
        `0` If the volume is not a provisioned IOPS image, otherwise the supported IOPS count.
        """
        return pulumi.get(self, "iops")

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> str:
        return pulumi.get(self, "kms_key_id")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> str:
        """
        ID of the snapshot.
        """
        return pulumi.get(self, "snapshot_id")

    @property
    @pulumi.getter
    def tags(self) -> Mapping[str, str]:
        """
        Map of tags assigned to the Instance.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def throughput(self) -> int:
        """
        Throughput of the volume, in MiB/s.
        """
        return pulumi.get(self, "throughput")

    @property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> str:
        return pulumi.get(self, "volume_id")

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> int:
        """
        Size of the volume, in GiB.
        """
        return pulumi.get(self, "volume_size")

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> str:
        """
        Type of the volume.
        """
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class GetInstanceEnclaveOptionResult(dict):
    def __init__(__self__, *,
                 enabled: bool):
        """
        :param bool enabled: Whether Nitro Enclaves are enabled.
        """
        GetInstanceEnclaveOptionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if enabled is None:
            raise TypeError("Missing 'enabled' argument")

        _setter("enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Whether Nitro Enclaves are enabled.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetInstanceEphemeralBlockDeviceResult(dict):
    def __init__(__self__, *,
                 device_name: str,
                 no_device: Optional[bool] = None,
                 virtual_name: Optional[str] = None):
        """
        :param str device_name: Physical name of the device.
        :param bool no_device: Whether the specified device included in the device mapping was suppressed or not (Boolean).
        :param str virtual_name: Virtual device name.
        """
        GetInstanceEphemeralBlockDeviceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            device_name=device_name,
            no_device=no_device,
            virtual_name=virtual_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             device_name: Optional[str] = None,
             no_device: Optional[bool] = None,
             virtual_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if device_name is None and 'deviceName' in kwargs:
            device_name = kwargs['deviceName']
        if device_name is None:
            raise TypeError("Missing 'device_name' argument")
        if no_device is None and 'noDevice' in kwargs:
            no_device = kwargs['noDevice']
        if virtual_name is None and 'virtualName' in kwargs:
            virtual_name = kwargs['virtualName']

        _setter("device_name", device_name)
        if no_device is not None:
            _setter("no_device", no_device)
        if virtual_name is not None:
            _setter("virtual_name", virtual_name)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> str:
        """
        Physical name of the device.
        """
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter(name="noDevice")
    def no_device(self) -> Optional[bool]:
        """
        Whether the specified device included in the device mapping was suppressed or not (Boolean).
        """
        return pulumi.get(self, "no_device")

    @property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> Optional[str]:
        """
        Virtual device name.
        """
        return pulumi.get(self, "virtual_name")


@pulumi.output_type
class GetInstanceFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        GetInstanceFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetInstanceMaintenanceOptionResult(dict):
    def __init__(__self__, *,
                 auto_recovery: str):
        """
        :param str auto_recovery: Automatic recovery behavior of the instance.
        """
        GetInstanceMaintenanceOptionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auto_recovery=auto_recovery,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auto_recovery: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if auto_recovery is None and 'autoRecovery' in kwargs:
            auto_recovery = kwargs['autoRecovery']
        if auto_recovery is None:
            raise TypeError("Missing 'auto_recovery' argument")

        _setter("auto_recovery", auto_recovery)

    @property
    @pulumi.getter(name="autoRecovery")
    def auto_recovery(self) -> str:
        """
        Automatic recovery behavior of the instance.
        """
        return pulumi.get(self, "auto_recovery")


@pulumi.output_type
class GetInstanceMetadataOptionResult(dict):
    def __init__(__self__, *,
                 http_endpoint: str,
                 http_protocol_ipv6: str,
                 http_put_response_hop_limit: int,
                 http_tokens: str,
                 instance_metadata_tags: str):
        """
        :param str http_endpoint: State of the metadata service: `enabled`, `disabled`.
        :param str http_protocol_ipv6: Whether the IPv6 endpoint for the instance metadata service is `enabled` or `disabled`
        :param int http_put_response_hop_limit: Desired HTTP PUT response hop limit for instance metadata requests.
        :param str http_tokens: If session tokens are required: `optional`, `required`.
        :param str instance_metadata_tags: If access to instance tags is allowed from the metadata service: `enabled`, `disabled`.
        """
        GetInstanceMetadataOptionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            http_endpoint=http_endpoint,
            http_protocol_ipv6=http_protocol_ipv6,
            http_put_response_hop_limit=http_put_response_hop_limit,
            http_tokens=http_tokens,
            instance_metadata_tags=instance_metadata_tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             http_endpoint: Optional[str] = None,
             http_protocol_ipv6: Optional[str] = None,
             http_put_response_hop_limit: Optional[int] = None,
             http_tokens: Optional[str] = None,
             instance_metadata_tags: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if http_endpoint is None and 'httpEndpoint' in kwargs:
            http_endpoint = kwargs['httpEndpoint']
        if http_endpoint is None:
            raise TypeError("Missing 'http_endpoint' argument")
        if http_protocol_ipv6 is None and 'httpProtocolIpv6' in kwargs:
            http_protocol_ipv6 = kwargs['httpProtocolIpv6']
        if http_protocol_ipv6 is None:
            raise TypeError("Missing 'http_protocol_ipv6' argument")
        if http_put_response_hop_limit is None and 'httpPutResponseHopLimit' in kwargs:
            http_put_response_hop_limit = kwargs['httpPutResponseHopLimit']
        if http_put_response_hop_limit is None:
            raise TypeError("Missing 'http_put_response_hop_limit' argument")
        if http_tokens is None and 'httpTokens' in kwargs:
            http_tokens = kwargs['httpTokens']
        if http_tokens is None:
            raise TypeError("Missing 'http_tokens' argument")
        if instance_metadata_tags is None and 'instanceMetadataTags' in kwargs:
            instance_metadata_tags = kwargs['instanceMetadataTags']
        if instance_metadata_tags is None:
            raise TypeError("Missing 'instance_metadata_tags' argument")

        _setter("http_endpoint", http_endpoint)
        _setter("http_protocol_ipv6", http_protocol_ipv6)
        _setter("http_put_response_hop_limit", http_put_response_hop_limit)
        _setter("http_tokens", http_tokens)
        _setter("instance_metadata_tags", instance_metadata_tags)

    @property
    @pulumi.getter(name="httpEndpoint")
    def http_endpoint(self) -> str:
        """
        State of the metadata service: `enabled`, `disabled`.
        """
        return pulumi.get(self, "http_endpoint")

    @property
    @pulumi.getter(name="httpProtocolIpv6")
    def http_protocol_ipv6(self) -> str:
        """
        Whether the IPv6 endpoint for the instance metadata service is `enabled` or `disabled`
        """
        return pulumi.get(self, "http_protocol_ipv6")

    @property
    @pulumi.getter(name="httpPutResponseHopLimit")
    def http_put_response_hop_limit(self) -> int:
        """
        Desired HTTP PUT response hop limit for instance metadata requests.
        """
        return pulumi.get(self, "http_put_response_hop_limit")

    @property
    @pulumi.getter(name="httpTokens")
    def http_tokens(self) -> str:
        """
        If session tokens are required: `optional`, `required`.
        """
        return pulumi.get(self, "http_tokens")

    @property
    @pulumi.getter(name="instanceMetadataTags")
    def instance_metadata_tags(self) -> str:
        """
        If access to instance tags is allowed from the metadata service: `enabled`, `disabled`.
        """
        return pulumi.get(self, "instance_metadata_tags")


@pulumi.output_type
class GetInstancePrivateDnsNameOptionResult(dict):
    def __init__(__self__, *,
                 enable_resource_name_dns_a_record: bool,
                 enable_resource_name_dns_aaaa_record: bool,
                 hostname_type: str):
        """
        :param bool enable_resource_name_dns_a_record: Indicates whether to respond to DNS queries for instance hostnames with DNS A records.
        :param bool enable_resource_name_dns_aaaa_record: Indicates whether to respond to DNS queries for instance hostnames with DNS AAAA records.
        :param str hostname_type: Type of hostname for EC2 instances.
        """
        GetInstancePrivateDnsNameOptionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enable_resource_name_dns_a_record=enable_resource_name_dns_a_record,
            enable_resource_name_dns_aaaa_record=enable_resource_name_dns_aaaa_record,
            hostname_type=hostname_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enable_resource_name_dns_a_record: Optional[bool] = None,
             enable_resource_name_dns_aaaa_record: Optional[bool] = None,
             hostname_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if enable_resource_name_dns_a_record is None and 'enableResourceNameDnsARecord' in kwargs:
            enable_resource_name_dns_a_record = kwargs['enableResourceNameDnsARecord']
        if enable_resource_name_dns_a_record is None:
            raise TypeError("Missing 'enable_resource_name_dns_a_record' argument")
        if enable_resource_name_dns_aaaa_record is None and 'enableResourceNameDnsAaaaRecord' in kwargs:
            enable_resource_name_dns_aaaa_record = kwargs['enableResourceNameDnsAaaaRecord']
        if enable_resource_name_dns_aaaa_record is None:
            raise TypeError("Missing 'enable_resource_name_dns_aaaa_record' argument")
        if hostname_type is None and 'hostnameType' in kwargs:
            hostname_type = kwargs['hostnameType']
        if hostname_type is None:
            raise TypeError("Missing 'hostname_type' argument")

        _setter("enable_resource_name_dns_a_record", enable_resource_name_dns_a_record)
        _setter("enable_resource_name_dns_aaaa_record", enable_resource_name_dns_aaaa_record)
        _setter("hostname_type", hostname_type)

    @property
    @pulumi.getter(name="enableResourceNameDnsARecord")
    def enable_resource_name_dns_a_record(self) -> bool:
        """
        Indicates whether to respond to DNS queries for instance hostnames with DNS A records.
        """
        return pulumi.get(self, "enable_resource_name_dns_a_record")

    @property
    @pulumi.getter(name="enableResourceNameDnsAaaaRecord")
    def enable_resource_name_dns_aaaa_record(self) -> bool:
        """
        Indicates whether to respond to DNS queries for instance hostnames with DNS AAAA records.
        """
        return pulumi.get(self, "enable_resource_name_dns_aaaa_record")

    @property
    @pulumi.getter(name="hostnameType")
    def hostname_type(self) -> str:
        """
        Type of hostname for EC2 instances.
        """
        return pulumi.get(self, "hostname_type")


@pulumi.output_type
class GetInstanceRootBlockDeviceResult(dict):
    def __init__(__self__, *,
                 delete_on_termination: bool,
                 device_name: str,
                 encrypted: bool,
                 iops: int,
                 kms_key_id: str,
                 tags: Mapping[str, str],
                 throughput: int,
                 volume_id: str,
                 volume_size: int,
                 volume_type: str):
        """
        :param bool delete_on_termination: If the root block device will be deleted on termination.
        :param str device_name: Physical name of the device.
        :param bool encrypted: If the EBS volume is encrypted.
        :param int iops: `0` If the volume is not a provisioned IOPS image, otherwise the supported IOPS count.
        :param Mapping[str, str] tags: Map of tags assigned to the Instance.
        :param int throughput: Throughput of the volume, in MiB/s.
        :param int volume_size: Size of the volume, in GiB.
        :param str volume_type: Type of the volume.
        """
        GetInstanceRootBlockDeviceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            delete_on_termination=delete_on_termination,
            device_name=device_name,
            encrypted=encrypted,
            iops=iops,
            kms_key_id=kms_key_id,
            tags=tags,
            throughput=throughput,
            volume_id=volume_id,
            volume_size=volume_size,
            volume_type=volume_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             delete_on_termination: Optional[bool] = None,
             device_name: Optional[str] = None,
             encrypted: Optional[bool] = None,
             iops: Optional[int] = None,
             kms_key_id: Optional[str] = None,
             tags: Optional[Mapping[str, str]] = None,
             throughput: Optional[int] = None,
             volume_id: Optional[str] = None,
             volume_size: Optional[int] = None,
             volume_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if delete_on_termination is None and 'deleteOnTermination' in kwargs:
            delete_on_termination = kwargs['deleteOnTermination']
        if delete_on_termination is None:
            raise TypeError("Missing 'delete_on_termination' argument")
        if device_name is None and 'deviceName' in kwargs:
            device_name = kwargs['deviceName']
        if device_name is None:
            raise TypeError("Missing 'device_name' argument")
        if encrypted is None:
            raise TypeError("Missing 'encrypted' argument")
        if iops is None:
            raise TypeError("Missing 'iops' argument")
        if kms_key_id is None and 'kmsKeyId' in kwargs:
            kms_key_id = kwargs['kmsKeyId']
        if kms_key_id is None:
            raise TypeError("Missing 'kms_key_id' argument")
        if tags is None:
            raise TypeError("Missing 'tags' argument")
        if throughput is None:
            raise TypeError("Missing 'throughput' argument")
        if volume_id is None and 'volumeId' in kwargs:
            volume_id = kwargs['volumeId']
        if volume_id is None:
            raise TypeError("Missing 'volume_id' argument")
        if volume_size is None and 'volumeSize' in kwargs:
            volume_size = kwargs['volumeSize']
        if volume_size is None:
            raise TypeError("Missing 'volume_size' argument")
        if volume_type is None and 'volumeType' in kwargs:
            volume_type = kwargs['volumeType']
        if volume_type is None:
            raise TypeError("Missing 'volume_type' argument")

        _setter("delete_on_termination", delete_on_termination)
        _setter("device_name", device_name)
        _setter("encrypted", encrypted)
        _setter("iops", iops)
        _setter("kms_key_id", kms_key_id)
        _setter("tags", tags)
        _setter("throughput", throughput)
        _setter("volume_id", volume_id)
        _setter("volume_size", volume_size)
        _setter("volume_type", volume_type)

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> bool:
        """
        If the root block device will be deleted on termination.
        """
        return pulumi.get(self, "delete_on_termination")

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> str:
        """
        Physical name of the device.
        """
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter
    def encrypted(self) -> bool:
        """
        If the EBS volume is encrypted.
        """
        return pulumi.get(self, "encrypted")

    @property
    @pulumi.getter
    def iops(self) -> int:
        """
        `0` If the volume is not a provisioned IOPS image, otherwise the supported IOPS count.
        """
        return pulumi.get(self, "iops")

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> str:
        return pulumi.get(self, "kms_key_id")

    @property
    @pulumi.getter
    def tags(self) -> Mapping[str, str]:
        """
        Map of tags assigned to the Instance.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def throughput(self) -> int:
        """
        Throughput of the volume, in MiB/s.
        """
        return pulumi.get(self, "throughput")

    @property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> str:
        return pulumi.get(self, "volume_id")

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> int:
        """
        Size of the volume, in GiB.
        """
        return pulumi.get(self, "volume_size")

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> str:
        """
        Type of the volume.
        """
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class GetInstanceTypeFpgaResult(dict):
    def __init__(__self__, *,
                 count: int,
                 manufacturer: str,
                 memory_size: int,
                 name: str):
        """
        :param int memory_size: Size of the instance memory, in MiB.
        """
        GetInstanceTypeFpgaResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            count=count,
            manufacturer=manufacturer,
            memory_size=memory_size,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             count: Optional[int] = None,
             manufacturer: Optional[str] = None,
             memory_size: Optional[int] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if count is None:
            raise TypeError("Missing 'count' argument")
        if manufacturer is None:
            raise TypeError("Missing 'manufacturer' argument")
        if memory_size is None and 'memorySize' in kwargs:
            memory_size = kwargs['memorySize']
        if memory_size is None:
            raise TypeError("Missing 'memory_size' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("count", count)
        _setter("manufacturer", manufacturer)
        _setter("memory_size", memory_size)
        _setter("name", name)

    @property
    @pulumi.getter
    def count(self) -> int:
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def manufacturer(self) -> str:
        return pulumi.get(self, "manufacturer")

    @property
    @pulumi.getter(name="memorySize")
    def memory_size(self) -> int:
        """
        Size of the instance memory, in MiB.
        """
        return pulumi.get(self, "memory_size")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetInstanceTypeGpusResult(dict):
    def __init__(__self__, *,
                 count: int,
                 manufacturer: str,
                 memory_size: int,
                 name: str):
        """
        :param int memory_size: Size of the instance memory, in MiB.
        """
        GetInstanceTypeGpusResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            count=count,
            manufacturer=manufacturer,
            memory_size=memory_size,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             count: Optional[int] = None,
             manufacturer: Optional[str] = None,
             memory_size: Optional[int] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if count is None:
            raise TypeError("Missing 'count' argument")
        if manufacturer is None:
            raise TypeError("Missing 'manufacturer' argument")
        if memory_size is None and 'memorySize' in kwargs:
            memory_size = kwargs['memorySize']
        if memory_size is None:
            raise TypeError("Missing 'memory_size' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("count", count)
        _setter("manufacturer", manufacturer)
        _setter("memory_size", memory_size)
        _setter("name", name)

    @property
    @pulumi.getter
    def count(self) -> int:
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def manufacturer(self) -> str:
        return pulumi.get(self, "manufacturer")

    @property
    @pulumi.getter(name="memorySize")
    def memory_size(self) -> int:
        """
        Size of the instance memory, in MiB.
        """
        return pulumi.get(self, "memory_size")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetInstanceTypeInferenceAcceleratorResult(dict):
    def __init__(__self__, *,
                 count: int,
                 manufacturer: str,
                 name: str):
        GetInstanceTypeInferenceAcceleratorResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            count=count,
            manufacturer=manufacturer,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             count: Optional[int] = None,
             manufacturer: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if count is None:
            raise TypeError("Missing 'count' argument")
        if manufacturer is None:
            raise TypeError("Missing 'manufacturer' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("count", count)
        _setter("manufacturer", manufacturer)
        _setter("name", name)

    @property
    @pulumi.getter
    def count(self) -> int:
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def manufacturer(self) -> str:
        return pulumi.get(self, "manufacturer")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetInstanceTypeInstanceDiskResult(dict):
    def __init__(__self__, *,
                 count: int,
                 size: int,
                 type: str):
        GetInstanceTypeInstanceDiskResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            count=count,
            size=size,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             count: Optional[int] = None,
             size: Optional[int] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if count is None:
            raise TypeError("Missing 'count' argument")
        if size is None:
            raise TypeError("Missing 'size' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("count", count)
        _setter("size", size)
        _setter("type", type)

    @property
    @pulumi.getter
    def count(self) -> int:
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def size(self) -> int:
        return pulumi.get(self, "size")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetInstanceTypeOfferingFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Name of the filter. The `location` filter depends on the top-level `location_type` argument and if not specified, defaults to the current region.
        :param Sequence[str] values: List of one or more values for the filter.
        """
        GetInstanceTypeOfferingFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the filter. The `location` filter depends on the top-level `location_type` argument and if not specified, defaults to the current region.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        List of one or more values for the filter.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetInstanceTypeOfferingsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Name of the filter. The `location` filter depends on the top-level `location_type` argument and if not specified, defaults to the current region.
        :param Sequence[str] values: List of one or more values for the filter.
        """
        GetInstanceTypeOfferingsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the filter. The `location` filter depends on the top-level `location_type` argument and if not specified, defaults to the current region.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        List of one or more values for the filter.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetInstanceTypesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Name of the filter.
        :param Sequence[str] values: List of one or more values for the filter.
        """
        GetInstanceTypesFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the filter.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        List of one or more values for the filter.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetInstancesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        GetInstancesFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetInternetGatewayAttachmentResult(dict):
    def __init__(__self__, *,
                 state: str,
                 vpc_id: str):
        """
        :param str state: Current state of the attachment between the gateway and the VPC. Present only if a VPC is attached
        :param str vpc_id: ID of an attached VPC.
        """
        GetInternetGatewayAttachmentResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            state=state,
            vpc_id=vpc_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             state: Optional[str] = None,
             vpc_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if state is None:
            raise TypeError("Missing 'state' argument")
        if vpc_id is None and 'vpcId' in kwargs:
            vpc_id = kwargs['vpcId']
        if vpc_id is None:
            raise TypeError("Missing 'vpc_id' argument")

        _setter("state", state)
        _setter("vpc_id", vpc_id)

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        Current state of the attachment between the gateway and the VPC. Present only if a VPC is attached
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> str:
        """
        ID of an attached VPC.
        """
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class GetInternetGatewayFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Name of the field to filter by, as defined by
               [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeInternetGateways.html).
        :param Sequence[str] values: Set of values that are accepted for the given field.
               An Internet Gateway will be selected if any one of the given values matches.
        """
        GetInternetGatewayFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the field to filter by, as defined by
        [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeInternetGateways.html).
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Set of values that are accepted for the given field.
        An Internet Gateway will be selected if any one of the given values matches.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetKeyPairFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Name of the filter field. Valid values can be found in the [EC2 DescribeKeyPairs API Reference](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeKeyPairs.html).
        :param Sequence[str] values: Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
        """
        GetKeyPairFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the filter field. Valid values can be found in the [EC2 DescribeKeyPairs API Reference](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeKeyPairs.html).
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetLaunchConfigurationEbsBlockDeviceResult(dict):
    def __init__(__self__, *,
                 delete_on_termination: bool,
                 device_name: str,
                 encrypted: bool,
                 iops: int,
                 no_device: bool,
                 snapshot_id: str,
                 throughput: int,
                 volume_size: int,
                 volume_type: str):
        """
        :param bool delete_on_termination: Whether the EBS Volume will be deleted on instance termination.
        :param str device_name: Name of the device.
        :param bool encrypted: Whether the volume is Encrypted.
        :param int iops: Provisioned IOPs of the volume.
        :param bool no_device: Whether the device in the block device mapping of the AMI is suppressed.
        :param str snapshot_id: Snapshot ID of the mount.
        :param int throughput: Throughput of the volume.
        :param int volume_size: Size of the volume.
        :param str volume_type: Type of the volume.
        """
        GetLaunchConfigurationEbsBlockDeviceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            delete_on_termination=delete_on_termination,
            device_name=device_name,
            encrypted=encrypted,
            iops=iops,
            no_device=no_device,
            snapshot_id=snapshot_id,
            throughput=throughput,
            volume_size=volume_size,
            volume_type=volume_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             delete_on_termination: Optional[bool] = None,
             device_name: Optional[str] = None,
             encrypted: Optional[bool] = None,
             iops: Optional[int] = None,
             no_device: Optional[bool] = None,
             snapshot_id: Optional[str] = None,
             throughput: Optional[int] = None,
             volume_size: Optional[int] = None,
             volume_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if delete_on_termination is None and 'deleteOnTermination' in kwargs:
            delete_on_termination = kwargs['deleteOnTermination']
        if delete_on_termination is None:
            raise TypeError("Missing 'delete_on_termination' argument")
        if device_name is None and 'deviceName' in kwargs:
            device_name = kwargs['deviceName']
        if device_name is None:
            raise TypeError("Missing 'device_name' argument")
        if encrypted is None:
            raise TypeError("Missing 'encrypted' argument")
        if iops is None:
            raise TypeError("Missing 'iops' argument")
        if no_device is None and 'noDevice' in kwargs:
            no_device = kwargs['noDevice']
        if no_device is None:
            raise TypeError("Missing 'no_device' argument")
        if snapshot_id is None and 'snapshotId' in kwargs:
            snapshot_id = kwargs['snapshotId']
        if snapshot_id is None:
            raise TypeError("Missing 'snapshot_id' argument")
        if throughput is None:
            raise TypeError("Missing 'throughput' argument")
        if volume_size is None and 'volumeSize' in kwargs:
            volume_size = kwargs['volumeSize']
        if volume_size is None:
            raise TypeError("Missing 'volume_size' argument")
        if volume_type is None and 'volumeType' in kwargs:
            volume_type = kwargs['volumeType']
        if volume_type is None:
            raise TypeError("Missing 'volume_type' argument")

        _setter("delete_on_termination", delete_on_termination)
        _setter("device_name", device_name)
        _setter("encrypted", encrypted)
        _setter("iops", iops)
        _setter("no_device", no_device)
        _setter("snapshot_id", snapshot_id)
        _setter("throughput", throughput)
        _setter("volume_size", volume_size)
        _setter("volume_type", volume_type)

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> bool:
        """
        Whether the EBS Volume will be deleted on instance termination.
        """
        return pulumi.get(self, "delete_on_termination")

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> str:
        """
        Name of the device.
        """
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter
    def encrypted(self) -> bool:
        """
        Whether the volume is Encrypted.
        """
        return pulumi.get(self, "encrypted")

    @property
    @pulumi.getter
    def iops(self) -> int:
        """
        Provisioned IOPs of the volume.
        """
        return pulumi.get(self, "iops")

    @property
    @pulumi.getter(name="noDevice")
    def no_device(self) -> bool:
        """
        Whether the device in the block device mapping of the AMI is suppressed.
        """
        return pulumi.get(self, "no_device")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> str:
        """
        Snapshot ID of the mount.
        """
        return pulumi.get(self, "snapshot_id")

    @property
    @pulumi.getter
    def throughput(self) -> int:
        """
        Throughput of the volume.
        """
        return pulumi.get(self, "throughput")

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> int:
        """
        Size of the volume.
        """
        return pulumi.get(self, "volume_size")

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> str:
        """
        Type of the volume.
        """
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class GetLaunchConfigurationEphemeralBlockDeviceResult(dict):
    def __init__(__self__, *,
                 device_name: str,
                 virtual_name: str):
        """
        :param str device_name: Name of the device.
        :param str virtual_name: Virtual Name of the device.
        """
        GetLaunchConfigurationEphemeralBlockDeviceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            device_name=device_name,
            virtual_name=virtual_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             device_name: Optional[str] = None,
             virtual_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if device_name is None and 'deviceName' in kwargs:
            device_name = kwargs['deviceName']
        if device_name is None:
            raise TypeError("Missing 'device_name' argument")
        if virtual_name is None and 'virtualName' in kwargs:
            virtual_name = kwargs['virtualName']
        if virtual_name is None:
            raise TypeError("Missing 'virtual_name' argument")

        _setter("device_name", device_name)
        _setter("virtual_name", virtual_name)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> str:
        """
        Name of the device.
        """
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> str:
        """
        Virtual Name of the device.
        """
        return pulumi.get(self, "virtual_name")


@pulumi.output_type
class GetLaunchConfigurationMetadataOptionResult(dict):
    def __init__(__self__, *,
                 http_endpoint: str,
                 http_put_response_hop_limit: int,
                 http_tokens: str):
        """
        :param str http_endpoint: State of the metadata service: `enabled`, `disabled`.
        :param int http_put_response_hop_limit: The desired HTTP PUT response hop limit for instance metadata requests.
        :param str http_tokens: If session tokens are required: `optional`, `required`.
        """
        GetLaunchConfigurationMetadataOptionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            http_endpoint=http_endpoint,
            http_put_response_hop_limit=http_put_response_hop_limit,
            http_tokens=http_tokens,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             http_endpoint: Optional[str] = None,
             http_put_response_hop_limit: Optional[int] = None,
             http_tokens: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if http_endpoint is None and 'httpEndpoint' in kwargs:
            http_endpoint = kwargs['httpEndpoint']
        if http_endpoint is None:
            raise TypeError("Missing 'http_endpoint' argument")
        if http_put_response_hop_limit is None and 'httpPutResponseHopLimit' in kwargs:
            http_put_response_hop_limit = kwargs['httpPutResponseHopLimit']
        if http_put_response_hop_limit is None:
            raise TypeError("Missing 'http_put_response_hop_limit' argument")
        if http_tokens is None and 'httpTokens' in kwargs:
            http_tokens = kwargs['httpTokens']
        if http_tokens is None:
            raise TypeError("Missing 'http_tokens' argument")

        _setter("http_endpoint", http_endpoint)
        _setter("http_put_response_hop_limit", http_put_response_hop_limit)
        _setter("http_tokens", http_tokens)

    @property
    @pulumi.getter(name="httpEndpoint")
    def http_endpoint(self) -> str:
        """
        State of the metadata service: `enabled`, `disabled`.
        """
        return pulumi.get(self, "http_endpoint")

    @property
    @pulumi.getter(name="httpPutResponseHopLimit")
    def http_put_response_hop_limit(self) -> int:
        """
        The desired HTTP PUT response hop limit for instance metadata requests.
        """
        return pulumi.get(self, "http_put_response_hop_limit")

    @property
    @pulumi.getter(name="httpTokens")
    def http_tokens(self) -> str:
        """
        If session tokens are required: `optional`, `required`.
        """
        return pulumi.get(self, "http_tokens")


@pulumi.output_type
class GetLaunchConfigurationRootBlockDeviceResult(dict):
    def __init__(__self__, *,
                 delete_on_termination: bool,
                 encrypted: bool,
                 iops: int,
                 throughput: int,
                 volume_size: int,
                 volume_type: str):
        """
        :param bool delete_on_termination: Whether the EBS Volume will be deleted on instance termination.
        :param bool encrypted: Whether the volume is Encrypted.
        :param int iops: Provisioned IOPs of the volume.
        :param int throughput: Throughput of the volume.
        :param int volume_size: Size of the volume.
        :param str volume_type: Type of the volume.
        """
        GetLaunchConfigurationRootBlockDeviceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            delete_on_termination=delete_on_termination,
            encrypted=encrypted,
            iops=iops,
            throughput=throughput,
            volume_size=volume_size,
            volume_type=volume_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             delete_on_termination: Optional[bool] = None,
             encrypted: Optional[bool] = None,
             iops: Optional[int] = None,
             throughput: Optional[int] = None,
             volume_size: Optional[int] = None,
             volume_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if delete_on_termination is None and 'deleteOnTermination' in kwargs:
            delete_on_termination = kwargs['deleteOnTermination']
        if delete_on_termination is None:
            raise TypeError("Missing 'delete_on_termination' argument")
        if encrypted is None:
            raise TypeError("Missing 'encrypted' argument")
        if iops is None:
            raise TypeError("Missing 'iops' argument")
        if throughput is None:
            raise TypeError("Missing 'throughput' argument")
        if volume_size is None and 'volumeSize' in kwargs:
            volume_size = kwargs['volumeSize']
        if volume_size is None:
            raise TypeError("Missing 'volume_size' argument")
        if volume_type is None and 'volumeType' in kwargs:
            volume_type = kwargs['volumeType']
        if volume_type is None:
            raise TypeError("Missing 'volume_type' argument")

        _setter("delete_on_termination", delete_on_termination)
        _setter("encrypted", encrypted)
        _setter("iops", iops)
        _setter("throughput", throughput)
        _setter("volume_size", volume_size)
        _setter("volume_type", volume_type)

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> bool:
        """
        Whether the EBS Volume will be deleted on instance termination.
        """
        return pulumi.get(self, "delete_on_termination")

    @property
    @pulumi.getter
    def encrypted(self) -> bool:
        """
        Whether the volume is Encrypted.
        """
        return pulumi.get(self, "encrypted")

    @property
    @pulumi.getter
    def iops(self) -> int:
        """
        Provisioned IOPs of the volume.
        """
        return pulumi.get(self, "iops")

    @property
    @pulumi.getter
    def throughput(self) -> int:
        """
        Throughput of the volume.
        """
        return pulumi.get(self, "throughput")

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> int:
        """
        Size of the volume.
        """
        return pulumi.get(self, "volume_size")

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> str:
        """
        Type of the volume.
        """
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class GetLaunchTemplateBlockDeviceMappingResult(dict):
    def __init__(__self__, *,
                 device_name: str,
                 ebs: Sequence['outputs.GetLaunchTemplateBlockDeviceMappingEbResult'],
                 no_device: str,
                 virtual_name: str):
        GetLaunchTemplateBlockDeviceMappingResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            device_name=device_name,
            ebs=ebs,
            no_device=no_device,
            virtual_name=virtual_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             device_name: Optional[str] = None,
             ebs: Optional[Sequence['outputs.GetLaunchTemplateBlockDeviceMappingEbResult']] = None,
             no_device: Optional[str] = None,
             virtual_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if device_name is None and 'deviceName' in kwargs:
            device_name = kwargs['deviceName']
        if device_name is None:
            raise TypeError("Missing 'device_name' argument")
        if ebs is None:
            raise TypeError("Missing 'ebs' argument")
        if no_device is None and 'noDevice' in kwargs:
            no_device = kwargs['noDevice']
        if no_device is None:
            raise TypeError("Missing 'no_device' argument")
        if virtual_name is None and 'virtualName' in kwargs:
            virtual_name = kwargs['virtualName']
        if virtual_name is None:
            raise TypeError("Missing 'virtual_name' argument")

        _setter("device_name", device_name)
        _setter("ebs", ebs)
        _setter("no_device", no_device)
        _setter("virtual_name", virtual_name)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> str:
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter
    def ebs(self) -> Sequence['outputs.GetLaunchTemplateBlockDeviceMappingEbResult']:
        return pulumi.get(self, "ebs")

    @property
    @pulumi.getter(name="noDevice")
    def no_device(self) -> str:
        return pulumi.get(self, "no_device")

    @property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> str:
        return pulumi.get(self, "virtual_name")


@pulumi.output_type
class GetLaunchTemplateBlockDeviceMappingEbResult(dict):
    def __init__(__self__, *,
                 delete_on_termination: str,
                 encrypted: str,
                 iops: int,
                 kms_key_id: str,
                 snapshot_id: str,
                 throughput: int,
                 volume_size: int,
                 volume_type: str):
        GetLaunchTemplateBlockDeviceMappingEbResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            delete_on_termination=delete_on_termination,
            encrypted=encrypted,
            iops=iops,
            kms_key_id=kms_key_id,
            snapshot_id=snapshot_id,
            throughput=throughput,
            volume_size=volume_size,
            volume_type=volume_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             delete_on_termination: Optional[str] = None,
             encrypted: Optional[str] = None,
             iops: Optional[int] = None,
             kms_key_id: Optional[str] = None,
             snapshot_id: Optional[str] = None,
             throughput: Optional[int] = None,
             volume_size: Optional[int] = None,
             volume_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if delete_on_termination is None and 'deleteOnTermination' in kwargs:
            delete_on_termination = kwargs['deleteOnTermination']
        if delete_on_termination is None:
            raise TypeError("Missing 'delete_on_termination' argument")
        if encrypted is None:
            raise TypeError("Missing 'encrypted' argument")
        if iops is None:
            raise TypeError("Missing 'iops' argument")
        if kms_key_id is None and 'kmsKeyId' in kwargs:
            kms_key_id = kwargs['kmsKeyId']
        if kms_key_id is None:
            raise TypeError("Missing 'kms_key_id' argument")
        if snapshot_id is None and 'snapshotId' in kwargs:
            snapshot_id = kwargs['snapshotId']
        if snapshot_id is None:
            raise TypeError("Missing 'snapshot_id' argument")
        if throughput is None:
            raise TypeError("Missing 'throughput' argument")
        if volume_size is None and 'volumeSize' in kwargs:
            volume_size = kwargs['volumeSize']
        if volume_size is None:
            raise TypeError("Missing 'volume_size' argument")
        if volume_type is None and 'volumeType' in kwargs:
            volume_type = kwargs['volumeType']
        if volume_type is None:
            raise TypeError("Missing 'volume_type' argument")

        _setter("delete_on_termination", delete_on_termination)
        _setter("encrypted", encrypted)
        _setter("iops", iops)
        _setter("kms_key_id", kms_key_id)
        _setter("snapshot_id", snapshot_id)
        _setter("throughput", throughput)
        _setter("volume_size", volume_size)
        _setter("volume_type", volume_type)

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> str:
        return pulumi.get(self, "delete_on_termination")

    @property
    @pulumi.getter
    def encrypted(self) -> str:
        return pulumi.get(self, "encrypted")

    @property
    @pulumi.getter
    def iops(self) -> int:
        return pulumi.get(self, "iops")

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> str:
        return pulumi.get(self, "kms_key_id")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> str:
        return pulumi.get(self, "snapshot_id")

    @property
    @pulumi.getter
    def throughput(self) -> int:
        return pulumi.get(self, "throughput")

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> int:
        return pulumi.get(self, "volume_size")

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> str:
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class GetLaunchTemplateCapacityReservationSpecificationResult(dict):
    def __init__(__self__, *,
                 capacity_reservation_preference: str,
                 capacity_reservation_targets: Sequence['outputs.GetLaunchTemplateCapacityReservationSpecificationCapacityReservationTargetResult']):
        GetLaunchTemplateCapacityReservationSpecificationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            capacity_reservation_preference=capacity_reservation_preference,
            capacity_reservation_targets=capacity_reservation_targets,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             capacity_reservation_preference: Optional[str] = None,
             capacity_reservation_targets: Optional[Sequence['outputs.GetLaunchTemplateCapacityReservationSpecificationCapacityReservationTargetResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if capacity_reservation_preference is None and 'capacityReservationPreference' in kwargs:
            capacity_reservation_preference = kwargs['capacityReservationPreference']
        if capacity_reservation_preference is None:
            raise TypeError("Missing 'capacity_reservation_preference' argument")
        if capacity_reservation_targets is None and 'capacityReservationTargets' in kwargs:
            capacity_reservation_targets = kwargs['capacityReservationTargets']
        if capacity_reservation_targets is None:
            raise TypeError("Missing 'capacity_reservation_targets' argument")

        _setter("capacity_reservation_preference", capacity_reservation_preference)
        _setter("capacity_reservation_targets", capacity_reservation_targets)

    @property
    @pulumi.getter(name="capacityReservationPreference")
    def capacity_reservation_preference(self) -> str:
        return pulumi.get(self, "capacity_reservation_preference")

    @property
    @pulumi.getter(name="capacityReservationTargets")
    def capacity_reservation_targets(self) -> Sequence['outputs.GetLaunchTemplateCapacityReservationSpecificationCapacityReservationTargetResult']:
        return pulumi.get(self, "capacity_reservation_targets")


@pulumi.output_type
class GetLaunchTemplateCapacityReservationSpecificationCapacityReservationTargetResult(dict):
    def __init__(__self__, *,
                 capacity_reservation_id: str,
                 capacity_reservation_resource_group_arn: str):
        GetLaunchTemplateCapacityReservationSpecificationCapacityReservationTargetResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            capacity_reservation_id=capacity_reservation_id,
            capacity_reservation_resource_group_arn=capacity_reservation_resource_group_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             capacity_reservation_id: Optional[str] = None,
             capacity_reservation_resource_group_arn: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if capacity_reservation_id is None and 'capacityReservationId' in kwargs:
            capacity_reservation_id = kwargs['capacityReservationId']
        if capacity_reservation_id is None:
            raise TypeError("Missing 'capacity_reservation_id' argument")
        if capacity_reservation_resource_group_arn is None and 'capacityReservationResourceGroupArn' in kwargs:
            capacity_reservation_resource_group_arn = kwargs['capacityReservationResourceGroupArn']
        if capacity_reservation_resource_group_arn is None:
            raise TypeError("Missing 'capacity_reservation_resource_group_arn' argument")

        _setter("capacity_reservation_id", capacity_reservation_id)
        _setter("capacity_reservation_resource_group_arn", capacity_reservation_resource_group_arn)

    @property
    @pulumi.getter(name="capacityReservationId")
    def capacity_reservation_id(self) -> str:
        return pulumi.get(self, "capacity_reservation_id")

    @property
    @pulumi.getter(name="capacityReservationResourceGroupArn")
    def capacity_reservation_resource_group_arn(self) -> str:
        return pulumi.get(self, "capacity_reservation_resource_group_arn")


@pulumi.output_type
class GetLaunchTemplateCpuOptionResult(dict):
    def __init__(__self__, *,
                 amd_sev_snp: str,
                 core_count: int,
                 threads_per_core: int):
        GetLaunchTemplateCpuOptionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            amd_sev_snp=amd_sev_snp,
            core_count=core_count,
            threads_per_core=threads_per_core,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             amd_sev_snp: Optional[str] = None,
             core_count: Optional[int] = None,
             threads_per_core: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if amd_sev_snp is None and 'amdSevSnp' in kwargs:
            amd_sev_snp = kwargs['amdSevSnp']
        if amd_sev_snp is None:
            raise TypeError("Missing 'amd_sev_snp' argument")
        if core_count is None and 'coreCount' in kwargs:
            core_count = kwargs['coreCount']
        if core_count is None:
            raise TypeError("Missing 'core_count' argument")
        if threads_per_core is None and 'threadsPerCore' in kwargs:
            threads_per_core = kwargs['threadsPerCore']
        if threads_per_core is None:
            raise TypeError("Missing 'threads_per_core' argument")

        _setter("amd_sev_snp", amd_sev_snp)
        _setter("core_count", core_count)
        _setter("threads_per_core", threads_per_core)

    @property
    @pulumi.getter(name="amdSevSnp")
    def amd_sev_snp(self) -> str:
        return pulumi.get(self, "amd_sev_snp")

    @property
    @pulumi.getter(name="coreCount")
    def core_count(self) -> int:
        return pulumi.get(self, "core_count")

    @property
    @pulumi.getter(name="threadsPerCore")
    def threads_per_core(self) -> int:
        return pulumi.get(self, "threads_per_core")


@pulumi.output_type
class GetLaunchTemplateCreditSpecificationResult(dict):
    def __init__(__self__, *,
                 cpu_credits: str):
        GetLaunchTemplateCreditSpecificationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cpu_credits=cpu_credits,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cpu_credits: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cpu_credits is None and 'cpuCredits' in kwargs:
            cpu_credits = kwargs['cpuCredits']
        if cpu_credits is None:
            raise TypeError("Missing 'cpu_credits' argument")

        _setter("cpu_credits", cpu_credits)

    @property
    @pulumi.getter(name="cpuCredits")
    def cpu_credits(self) -> str:
        return pulumi.get(self, "cpu_credits")


@pulumi.output_type
class GetLaunchTemplateElasticGpuSpecificationResult(dict):
    def __init__(__self__, *,
                 type: str):
        GetLaunchTemplateElasticGpuSpecificationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("type", type)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetLaunchTemplateElasticInferenceAcceleratorResult(dict):
    def __init__(__self__, *,
                 type: str):
        GetLaunchTemplateElasticInferenceAcceleratorResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("type", type)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetLaunchTemplateEnclaveOptionResult(dict):
    def __init__(__self__, *,
                 enabled: bool):
        GetLaunchTemplateEnclaveOptionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if enabled is None:
            raise TypeError("Missing 'enabled' argument")

        _setter("enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetLaunchTemplateFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Name of the filter field. Valid values can be found in the [EC2 DescribeLaunchTemplates API Reference](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeLaunchTemplates.html).
        :param Sequence[str] values: Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
        """
        GetLaunchTemplateFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the filter field. Valid values can be found in the [EC2 DescribeLaunchTemplates API Reference](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeLaunchTemplates.html).
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetLaunchTemplateHibernationOptionResult(dict):
    def __init__(__self__, *,
                 configured: bool):
        GetLaunchTemplateHibernationOptionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            configured=configured,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             configured: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if configured is None:
            raise TypeError("Missing 'configured' argument")

        _setter("configured", configured)

    @property
    @pulumi.getter
    def configured(self) -> bool:
        return pulumi.get(self, "configured")


@pulumi.output_type
class GetLaunchTemplateIamInstanceProfileResult(dict):
    def __init__(__self__, *,
                 arn: str,
                 name: str):
        """
        :param str name: Name of the launch template.
        """
        GetLaunchTemplateIamInstanceProfileResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if arn is None:
            raise TypeError("Missing 'arn' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("arn", arn)
        _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> str:
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the launch template.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetLaunchTemplateInstanceMarketOptionResult(dict):
    def __init__(__self__, *,
                 market_type: str,
                 spot_options: Sequence['outputs.GetLaunchTemplateInstanceMarketOptionSpotOptionResult']):
        GetLaunchTemplateInstanceMarketOptionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            market_type=market_type,
            spot_options=spot_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             market_type: Optional[str] = None,
             spot_options: Optional[Sequence['outputs.GetLaunchTemplateInstanceMarketOptionSpotOptionResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if market_type is None and 'marketType' in kwargs:
            market_type = kwargs['marketType']
        if market_type is None:
            raise TypeError("Missing 'market_type' argument")
        if spot_options is None and 'spotOptions' in kwargs:
            spot_options = kwargs['spotOptions']
        if spot_options is None:
            raise TypeError("Missing 'spot_options' argument")

        _setter("market_type", market_type)
        _setter("spot_options", spot_options)

    @property
    @pulumi.getter(name="marketType")
    def market_type(self) -> str:
        return pulumi.get(self, "market_type")

    @property
    @pulumi.getter(name="spotOptions")
    def spot_options(self) -> Sequence['outputs.GetLaunchTemplateInstanceMarketOptionSpotOptionResult']:
        return pulumi.get(self, "spot_options")


@pulumi.output_type
class GetLaunchTemplateInstanceMarketOptionSpotOptionResult(dict):
    def __init__(__self__, *,
                 block_duration_minutes: int,
                 instance_interruption_behavior: str,
                 max_price: str,
                 spot_instance_type: str,
                 valid_until: str):
        GetLaunchTemplateInstanceMarketOptionSpotOptionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            block_duration_minutes=block_duration_minutes,
            instance_interruption_behavior=instance_interruption_behavior,
            max_price=max_price,
            spot_instance_type=spot_instance_type,
            valid_until=valid_until,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             block_duration_minutes: Optional[int] = None,
             instance_interruption_behavior: Optional[str] = None,
             max_price: Optional[str] = None,
             spot_instance_type: Optional[str] = None,
             valid_until: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if block_duration_minutes is None and 'blockDurationMinutes' in kwargs:
            block_duration_minutes = kwargs['blockDurationMinutes']
        if block_duration_minutes is None:
            raise TypeError("Missing 'block_duration_minutes' argument")
        if instance_interruption_behavior is None and 'instanceInterruptionBehavior' in kwargs:
            instance_interruption_behavior = kwargs['instanceInterruptionBehavior']
        if instance_interruption_behavior is None:
            raise TypeError("Missing 'instance_interruption_behavior' argument")
        if max_price is None and 'maxPrice' in kwargs:
            max_price = kwargs['maxPrice']
        if max_price is None:
            raise TypeError("Missing 'max_price' argument")
        if spot_instance_type is None and 'spotInstanceType' in kwargs:
            spot_instance_type = kwargs['spotInstanceType']
        if spot_instance_type is None:
            raise TypeError("Missing 'spot_instance_type' argument")
        if valid_until is None and 'validUntil' in kwargs:
            valid_until = kwargs['validUntil']
        if valid_until is None:
            raise TypeError("Missing 'valid_until' argument")

        _setter("block_duration_minutes", block_duration_minutes)
        _setter("instance_interruption_behavior", instance_interruption_behavior)
        _setter("max_price", max_price)
        _setter("spot_instance_type", spot_instance_type)
        _setter("valid_until", valid_until)

    @property
    @pulumi.getter(name="blockDurationMinutes")
    def block_duration_minutes(self) -> int:
        return pulumi.get(self, "block_duration_minutes")

    @property
    @pulumi.getter(name="instanceInterruptionBehavior")
    def instance_interruption_behavior(self) -> str:
        return pulumi.get(self, "instance_interruption_behavior")

    @property
    @pulumi.getter(name="maxPrice")
    def max_price(self) -> str:
        return pulumi.get(self, "max_price")

    @property
    @pulumi.getter(name="spotInstanceType")
    def spot_instance_type(self) -> str:
        return pulumi.get(self, "spot_instance_type")

    @property
    @pulumi.getter(name="validUntil")
    def valid_until(self) -> str:
        return pulumi.get(self, "valid_until")


@pulumi.output_type
class GetLaunchTemplateInstanceRequirementResult(dict):
    def __init__(__self__, *,
                 accelerator_counts: Sequence['outputs.GetLaunchTemplateInstanceRequirementAcceleratorCountResult'],
                 accelerator_manufacturers: Sequence[str],
                 accelerator_names: Sequence[str],
                 accelerator_total_memory_mibs: Sequence['outputs.GetLaunchTemplateInstanceRequirementAcceleratorTotalMemoryMibResult'],
                 accelerator_types: Sequence[str],
                 allowed_instance_types: Sequence[str],
                 bare_metal: str,
                 baseline_ebs_bandwidth_mbps: Sequence['outputs.GetLaunchTemplateInstanceRequirementBaselineEbsBandwidthMbpResult'],
                 burstable_performance: str,
                 cpu_manufacturers: Sequence[str],
                 excluded_instance_types: Sequence[str],
                 instance_generations: Sequence[str],
                 local_storage: str,
                 local_storage_types: Sequence[str],
                 memory_gib_per_vcpus: Sequence['outputs.GetLaunchTemplateInstanceRequirementMemoryGibPerVcpusResult'],
                 memory_mibs: Sequence['outputs.GetLaunchTemplateInstanceRequirementMemoryMibResult'],
                 network_bandwidth_gbps: Sequence['outputs.GetLaunchTemplateInstanceRequirementNetworkBandwidthGbpResult'],
                 network_interface_counts: Sequence['outputs.GetLaunchTemplateInstanceRequirementNetworkInterfaceCountResult'],
                 on_demand_max_price_percentage_over_lowest_price: int,
                 require_hibernate_support: bool,
                 spot_max_price_percentage_over_lowest_price: int,
                 total_local_storage_gbs: Sequence['outputs.GetLaunchTemplateInstanceRequirementTotalLocalStorageGbResult'],
                 vcpu_counts: Sequence['outputs.GetLaunchTemplateInstanceRequirementVcpuCountResult']):
        GetLaunchTemplateInstanceRequirementResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            accelerator_counts=accelerator_counts,
            accelerator_manufacturers=accelerator_manufacturers,
            accelerator_names=accelerator_names,
            accelerator_total_memory_mibs=accelerator_total_memory_mibs,
            accelerator_types=accelerator_types,
            allowed_instance_types=allowed_instance_types,
            bare_metal=bare_metal,
            baseline_ebs_bandwidth_mbps=baseline_ebs_bandwidth_mbps,
            burstable_performance=burstable_performance,
            cpu_manufacturers=cpu_manufacturers,
            excluded_instance_types=excluded_instance_types,
            instance_generations=instance_generations,
            local_storage=local_storage,
            local_storage_types=local_storage_types,
            memory_gib_per_vcpus=memory_gib_per_vcpus,
            memory_mibs=memory_mibs,
            network_bandwidth_gbps=network_bandwidth_gbps,
            network_interface_counts=network_interface_counts,
            on_demand_max_price_percentage_over_lowest_price=on_demand_max_price_percentage_over_lowest_price,
            require_hibernate_support=require_hibernate_support,
            spot_max_price_percentage_over_lowest_price=spot_max_price_percentage_over_lowest_price,
            total_local_storage_gbs=total_local_storage_gbs,
            vcpu_counts=vcpu_counts,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             accelerator_counts: Optional[Sequence['outputs.GetLaunchTemplateInstanceRequirementAcceleratorCountResult']] = None,
             accelerator_manufacturers: Optional[Sequence[str]] = None,
             accelerator_names: Optional[Sequence[str]] = None,
             accelerator_total_memory_mibs: Optional[Sequence['outputs.GetLaunchTemplateInstanceRequirementAcceleratorTotalMemoryMibResult']] = None,
             accelerator_types: Optional[Sequence[str]] = None,
             allowed_instance_types: Optional[Sequence[str]] = None,
             bare_metal: Optional[str] = None,
             baseline_ebs_bandwidth_mbps: Optional[Sequence['outputs.GetLaunchTemplateInstanceRequirementBaselineEbsBandwidthMbpResult']] = None,
             burstable_performance: Optional[str] = None,
             cpu_manufacturers: Optional[Sequence[str]] = None,
             excluded_instance_types: Optional[Sequence[str]] = None,
             instance_generations: Optional[Sequence[str]] = None,
             local_storage: Optional[str] = None,
             local_storage_types: Optional[Sequence[str]] = None,
             memory_gib_per_vcpus: Optional[Sequence['outputs.GetLaunchTemplateInstanceRequirementMemoryGibPerVcpusResult']] = None,
             memory_mibs: Optional[Sequence['outputs.GetLaunchTemplateInstanceRequirementMemoryMibResult']] = None,
             network_bandwidth_gbps: Optional[Sequence['outputs.GetLaunchTemplateInstanceRequirementNetworkBandwidthGbpResult']] = None,
             network_interface_counts: Optional[Sequence['outputs.GetLaunchTemplateInstanceRequirementNetworkInterfaceCountResult']] = None,
             on_demand_max_price_percentage_over_lowest_price: Optional[int] = None,
             require_hibernate_support: Optional[bool] = None,
             spot_max_price_percentage_over_lowest_price: Optional[int] = None,
             total_local_storage_gbs: Optional[Sequence['outputs.GetLaunchTemplateInstanceRequirementTotalLocalStorageGbResult']] = None,
             vcpu_counts: Optional[Sequence['outputs.GetLaunchTemplateInstanceRequirementVcpuCountResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if accelerator_counts is None and 'acceleratorCounts' in kwargs:
            accelerator_counts = kwargs['acceleratorCounts']
        if accelerator_counts is None:
            raise TypeError("Missing 'accelerator_counts' argument")
        if accelerator_manufacturers is None and 'acceleratorManufacturers' in kwargs:
            accelerator_manufacturers = kwargs['acceleratorManufacturers']
        if accelerator_manufacturers is None:
            raise TypeError("Missing 'accelerator_manufacturers' argument")
        if accelerator_names is None and 'acceleratorNames' in kwargs:
            accelerator_names = kwargs['acceleratorNames']
        if accelerator_names is None:
            raise TypeError("Missing 'accelerator_names' argument")
        if accelerator_total_memory_mibs is None and 'acceleratorTotalMemoryMibs' in kwargs:
            accelerator_total_memory_mibs = kwargs['acceleratorTotalMemoryMibs']
        if accelerator_total_memory_mibs is None:
            raise TypeError("Missing 'accelerator_total_memory_mibs' argument")
        if accelerator_types is None and 'acceleratorTypes' in kwargs:
            accelerator_types = kwargs['acceleratorTypes']
        if accelerator_types is None:
            raise TypeError("Missing 'accelerator_types' argument")
        if allowed_instance_types is None and 'allowedInstanceTypes' in kwargs:
            allowed_instance_types = kwargs['allowedInstanceTypes']
        if allowed_instance_types is None:
            raise TypeError("Missing 'allowed_instance_types' argument")
        if bare_metal is None and 'bareMetal' in kwargs:
            bare_metal = kwargs['bareMetal']
        if bare_metal is None:
            raise TypeError("Missing 'bare_metal' argument")
        if baseline_ebs_bandwidth_mbps is None and 'baselineEbsBandwidthMbps' in kwargs:
            baseline_ebs_bandwidth_mbps = kwargs['baselineEbsBandwidthMbps']
        if baseline_ebs_bandwidth_mbps is None:
            raise TypeError("Missing 'baseline_ebs_bandwidth_mbps' argument")
        if burstable_performance is None and 'burstablePerformance' in kwargs:
            burstable_performance = kwargs['burstablePerformance']
        if burstable_performance is None:
            raise TypeError("Missing 'burstable_performance' argument")
        if cpu_manufacturers is None and 'cpuManufacturers' in kwargs:
            cpu_manufacturers = kwargs['cpuManufacturers']
        if cpu_manufacturers is None:
            raise TypeError("Missing 'cpu_manufacturers' argument")
        if excluded_instance_types is None and 'excludedInstanceTypes' in kwargs:
            excluded_instance_types = kwargs['excludedInstanceTypes']
        if excluded_instance_types is None:
            raise TypeError("Missing 'excluded_instance_types' argument")
        if instance_generations is None and 'instanceGenerations' in kwargs:
            instance_generations = kwargs['instanceGenerations']
        if instance_generations is None:
            raise TypeError("Missing 'instance_generations' argument")
        if local_storage is None and 'localStorage' in kwargs:
            local_storage = kwargs['localStorage']
        if local_storage is None:
            raise TypeError("Missing 'local_storage' argument")
        if local_storage_types is None and 'localStorageTypes' in kwargs:
            local_storage_types = kwargs['localStorageTypes']
        if local_storage_types is None:
            raise TypeError("Missing 'local_storage_types' argument")
        if memory_gib_per_vcpus is None and 'memoryGibPerVcpus' in kwargs:
            memory_gib_per_vcpus = kwargs['memoryGibPerVcpus']
        if memory_gib_per_vcpus is None:
            raise TypeError("Missing 'memory_gib_per_vcpus' argument")
        if memory_mibs is None and 'memoryMibs' in kwargs:
            memory_mibs = kwargs['memoryMibs']
        if memory_mibs is None:
            raise TypeError("Missing 'memory_mibs' argument")
        if network_bandwidth_gbps is None and 'networkBandwidthGbps' in kwargs:
            network_bandwidth_gbps = kwargs['networkBandwidthGbps']
        if network_bandwidth_gbps is None:
            raise TypeError("Missing 'network_bandwidth_gbps' argument")
        if network_interface_counts is None and 'networkInterfaceCounts' in kwargs:
            network_interface_counts = kwargs['networkInterfaceCounts']
        if network_interface_counts is None:
            raise TypeError("Missing 'network_interface_counts' argument")
        if on_demand_max_price_percentage_over_lowest_price is None and 'onDemandMaxPricePercentageOverLowestPrice' in kwargs:
            on_demand_max_price_percentage_over_lowest_price = kwargs['onDemandMaxPricePercentageOverLowestPrice']
        if on_demand_max_price_percentage_over_lowest_price is None:
            raise TypeError("Missing 'on_demand_max_price_percentage_over_lowest_price' argument")
        if require_hibernate_support is None and 'requireHibernateSupport' in kwargs:
            require_hibernate_support = kwargs['requireHibernateSupport']
        if require_hibernate_support is None:
            raise TypeError("Missing 'require_hibernate_support' argument")
        if spot_max_price_percentage_over_lowest_price is None and 'spotMaxPricePercentageOverLowestPrice' in kwargs:
            spot_max_price_percentage_over_lowest_price = kwargs['spotMaxPricePercentageOverLowestPrice']
        if spot_max_price_percentage_over_lowest_price is None:
            raise TypeError("Missing 'spot_max_price_percentage_over_lowest_price' argument")
        if total_local_storage_gbs is None and 'totalLocalStorageGbs' in kwargs:
            total_local_storage_gbs = kwargs['totalLocalStorageGbs']
        if total_local_storage_gbs is None:
            raise TypeError("Missing 'total_local_storage_gbs' argument")
        if vcpu_counts is None and 'vcpuCounts' in kwargs:
            vcpu_counts = kwargs['vcpuCounts']
        if vcpu_counts is None:
            raise TypeError("Missing 'vcpu_counts' argument")

        _setter("accelerator_counts", accelerator_counts)
        _setter("accelerator_manufacturers", accelerator_manufacturers)
        _setter("accelerator_names", accelerator_names)
        _setter("accelerator_total_memory_mibs", accelerator_total_memory_mibs)
        _setter("accelerator_types", accelerator_types)
        _setter("allowed_instance_types", allowed_instance_types)
        _setter("bare_metal", bare_metal)
        _setter("baseline_ebs_bandwidth_mbps", baseline_ebs_bandwidth_mbps)
        _setter("burstable_performance", burstable_performance)
        _setter("cpu_manufacturers", cpu_manufacturers)
        _setter("excluded_instance_types", excluded_instance_types)
        _setter("instance_generations", instance_generations)
        _setter("local_storage", local_storage)
        _setter("local_storage_types", local_storage_types)
        _setter("memory_gib_per_vcpus", memory_gib_per_vcpus)
        _setter("memory_mibs", memory_mibs)
        _setter("network_bandwidth_gbps", network_bandwidth_gbps)
        _setter("network_interface_counts", network_interface_counts)
        _setter("on_demand_max_price_percentage_over_lowest_price", on_demand_max_price_percentage_over_lowest_price)
        _setter("require_hibernate_support", require_hibernate_support)
        _setter("spot_max_price_percentage_over_lowest_price", spot_max_price_percentage_over_lowest_price)
        _setter("total_local_storage_gbs", total_local_storage_gbs)
        _setter("vcpu_counts", vcpu_counts)

    @property
    @pulumi.getter(name="acceleratorCounts")
    def accelerator_counts(self) -> Sequence['outputs.GetLaunchTemplateInstanceRequirementAcceleratorCountResult']:
        return pulumi.get(self, "accelerator_counts")

    @property
    @pulumi.getter(name="acceleratorManufacturers")
    def accelerator_manufacturers(self) -> Sequence[str]:
        return pulumi.get(self, "accelerator_manufacturers")

    @property
    @pulumi.getter(name="acceleratorNames")
    def accelerator_names(self) -> Sequence[str]:
        return pulumi.get(self, "accelerator_names")

    @property
    @pulumi.getter(name="acceleratorTotalMemoryMibs")
    def accelerator_total_memory_mibs(self) -> Sequence['outputs.GetLaunchTemplateInstanceRequirementAcceleratorTotalMemoryMibResult']:
        return pulumi.get(self, "accelerator_total_memory_mibs")

    @property
    @pulumi.getter(name="acceleratorTypes")
    def accelerator_types(self) -> Sequence[str]:
        return pulumi.get(self, "accelerator_types")

    @property
    @pulumi.getter(name="allowedInstanceTypes")
    def allowed_instance_types(self) -> Sequence[str]:
        return pulumi.get(self, "allowed_instance_types")

    @property
    @pulumi.getter(name="bareMetal")
    def bare_metal(self) -> str:
        return pulumi.get(self, "bare_metal")

    @property
    @pulumi.getter(name="baselineEbsBandwidthMbps")
    def baseline_ebs_bandwidth_mbps(self) -> Sequence['outputs.GetLaunchTemplateInstanceRequirementBaselineEbsBandwidthMbpResult']:
        return pulumi.get(self, "baseline_ebs_bandwidth_mbps")

    @property
    @pulumi.getter(name="burstablePerformance")
    def burstable_performance(self) -> str:
        return pulumi.get(self, "burstable_performance")

    @property
    @pulumi.getter(name="cpuManufacturers")
    def cpu_manufacturers(self) -> Sequence[str]:
        return pulumi.get(self, "cpu_manufacturers")

    @property
    @pulumi.getter(name="excludedInstanceTypes")
    def excluded_instance_types(self) -> Sequence[str]:
        return pulumi.get(self, "excluded_instance_types")

    @property
    @pulumi.getter(name="instanceGenerations")
    def instance_generations(self) -> Sequence[str]:
        return pulumi.get(self, "instance_generations")

    @property
    @pulumi.getter(name="localStorage")
    def local_storage(self) -> str:
        return pulumi.get(self, "local_storage")

    @property
    @pulumi.getter(name="localStorageTypes")
    def local_storage_types(self) -> Sequence[str]:
        return pulumi.get(self, "local_storage_types")

    @property
    @pulumi.getter(name="memoryGibPerVcpus")
    def memory_gib_per_vcpus(self) -> Sequence['outputs.GetLaunchTemplateInstanceRequirementMemoryGibPerVcpusResult']:
        return pulumi.get(self, "memory_gib_per_vcpus")

    @property
    @pulumi.getter(name="memoryMibs")
    def memory_mibs(self) -> Sequence['outputs.GetLaunchTemplateInstanceRequirementMemoryMibResult']:
        return pulumi.get(self, "memory_mibs")

    @property
    @pulumi.getter(name="networkBandwidthGbps")
    def network_bandwidth_gbps(self) -> Sequence['outputs.GetLaunchTemplateInstanceRequirementNetworkBandwidthGbpResult']:
        return pulumi.get(self, "network_bandwidth_gbps")

    @property
    @pulumi.getter(name="networkInterfaceCounts")
    def network_interface_counts(self) -> Sequence['outputs.GetLaunchTemplateInstanceRequirementNetworkInterfaceCountResult']:
        return pulumi.get(self, "network_interface_counts")

    @property
    @pulumi.getter(name="onDemandMaxPricePercentageOverLowestPrice")
    def on_demand_max_price_percentage_over_lowest_price(self) -> int:
        return pulumi.get(self, "on_demand_max_price_percentage_over_lowest_price")

    @property
    @pulumi.getter(name="requireHibernateSupport")
    def require_hibernate_support(self) -> bool:
        return pulumi.get(self, "require_hibernate_support")

    @property
    @pulumi.getter(name="spotMaxPricePercentageOverLowestPrice")
    def spot_max_price_percentage_over_lowest_price(self) -> int:
        return pulumi.get(self, "spot_max_price_percentage_over_lowest_price")

    @property
    @pulumi.getter(name="totalLocalStorageGbs")
    def total_local_storage_gbs(self) -> Sequence['outputs.GetLaunchTemplateInstanceRequirementTotalLocalStorageGbResult']:
        return pulumi.get(self, "total_local_storage_gbs")

    @property
    @pulumi.getter(name="vcpuCounts")
    def vcpu_counts(self) -> Sequence['outputs.GetLaunchTemplateInstanceRequirementVcpuCountResult']:
        return pulumi.get(self, "vcpu_counts")


@pulumi.output_type
class GetLaunchTemplateInstanceRequirementAcceleratorCountResult(dict):
    def __init__(__self__, *,
                 max: int,
                 min: int):
        GetLaunchTemplateInstanceRequirementAcceleratorCountResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            min=min,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: Optional[int] = None,
             min: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if max is None:
            raise TypeError("Missing 'max' argument")
        if min is None:
            raise TypeError("Missing 'min' argument")

        _setter("max", max)
        _setter("min", min)

    @property
    @pulumi.getter
    def max(self) -> int:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> int:
        return pulumi.get(self, "min")


@pulumi.output_type
class GetLaunchTemplateInstanceRequirementAcceleratorTotalMemoryMibResult(dict):
    def __init__(__self__, *,
                 max: int,
                 min: int):
        GetLaunchTemplateInstanceRequirementAcceleratorTotalMemoryMibResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            min=min,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: Optional[int] = None,
             min: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if max is None:
            raise TypeError("Missing 'max' argument")
        if min is None:
            raise TypeError("Missing 'min' argument")

        _setter("max", max)
        _setter("min", min)

    @property
    @pulumi.getter
    def max(self) -> int:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> int:
        return pulumi.get(self, "min")


@pulumi.output_type
class GetLaunchTemplateInstanceRequirementBaselineEbsBandwidthMbpResult(dict):
    def __init__(__self__, *,
                 max: int,
                 min: int):
        GetLaunchTemplateInstanceRequirementBaselineEbsBandwidthMbpResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            min=min,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: Optional[int] = None,
             min: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if max is None:
            raise TypeError("Missing 'max' argument")
        if min is None:
            raise TypeError("Missing 'min' argument")

        _setter("max", max)
        _setter("min", min)

    @property
    @pulumi.getter
    def max(self) -> int:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> int:
        return pulumi.get(self, "min")


@pulumi.output_type
class GetLaunchTemplateInstanceRequirementMemoryGibPerVcpusResult(dict):
    def __init__(__self__, *,
                 max: float,
                 min: float):
        GetLaunchTemplateInstanceRequirementMemoryGibPerVcpusResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            min=min,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: Optional[float] = None,
             min: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if max is None:
            raise TypeError("Missing 'max' argument")
        if min is None:
            raise TypeError("Missing 'min' argument")

        _setter("max", max)
        _setter("min", min)

    @property
    @pulumi.getter
    def max(self) -> float:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> float:
        return pulumi.get(self, "min")


@pulumi.output_type
class GetLaunchTemplateInstanceRequirementMemoryMibResult(dict):
    def __init__(__self__, *,
                 max: int,
                 min: int):
        GetLaunchTemplateInstanceRequirementMemoryMibResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            min=min,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: Optional[int] = None,
             min: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if max is None:
            raise TypeError("Missing 'max' argument")
        if min is None:
            raise TypeError("Missing 'min' argument")

        _setter("max", max)
        _setter("min", min)

    @property
    @pulumi.getter
    def max(self) -> int:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> int:
        return pulumi.get(self, "min")


@pulumi.output_type
class GetLaunchTemplateInstanceRequirementNetworkBandwidthGbpResult(dict):
    def __init__(__self__, *,
                 max: float,
                 min: float):
        GetLaunchTemplateInstanceRequirementNetworkBandwidthGbpResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            min=min,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: Optional[float] = None,
             min: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if max is None:
            raise TypeError("Missing 'max' argument")
        if min is None:
            raise TypeError("Missing 'min' argument")

        _setter("max", max)
        _setter("min", min)

    @property
    @pulumi.getter
    def max(self) -> float:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> float:
        return pulumi.get(self, "min")


@pulumi.output_type
class GetLaunchTemplateInstanceRequirementNetworkInterfaceCountResult(dict):
    def __init__(__self__, *,
                 max: int,
                 min: int):
        GetLaunchTemplateInstanceRequirementNetworkInterfaceCountResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            min=min,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: Optional[int] = None,
             min: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if max is None:
            raise TypeError("Missing 'max' argument")
        if min is None:
            raise TypeError("Missing 'min' argument")

        _setter("max", max)
        _setter("min", min)

    @property
    @pulumi.getter
    def max(self) -> int:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> int:
        return pulumi.get(self, "min")


@pulumi.output_type
class GetLaunchTemplateInstanceRequirementTotalLocalStorageGbResult(dict):
    def __init__(__self__, *,
                 max: float,
                 min: float):
        GetLaunchTemplateInstanceRequirementTotalLocalStorageGbResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            min=min,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: Optional[float] = None,
             min: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if max is None:
            raise TypeError("Missing 'max' argument")
        if min is None:
            raise TypeError("Missing 'min' argument")

        _setter("max", max)
        _setter("min", min)

    @property
    @pulumi.getter
    def max(self) -> float:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> float:
        return pulumi.get(self, "min")


@pulumi.output_type
class GetLaunchTemplateInstanceRequirementVcpuCountResult(dict):
    def __init__(__self__, *,
                 max: int,
                 min: int):
        GetLaunchTemplateInstanceRequirementVcpuCountResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            min=min,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: Optional[int] = None,
             min: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if max is None:
            raise TypeError("Missing 'max' argument")
        if min is None:
            raise TypeError("Missing 'min' argument")

        _setter("max", max)
        _setter("min", min)

    @property
    @pulumi.getter
    def max(self) -> int:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> int:
        return pulumi.get(self, "min")


@pulumi.output_type
class GetLaunchTemplateLicenseSpecificationResult(dict):
    def __init__(__self__, *,
                 license_configuration_arn: str):
        GetLaunchTemplateLicenseSpecificationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            license_configuration_arn=license_configuration_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             license_configuration_arn: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if license_configuration_arn is None and 'licenseConfigurationArn' in kwargs:
            license_configuration_arn = kwargs['licenseConfigurationArn']
        if license_configuration_arn is None:
            raise TypeError("Missing 'license_configuration_arn' argument")

        _setter("license_configuration_arn", license_configuration_arn)

    @property
    @pulumi.getter(name="licenseConfigurationArn")
    def license_configuration_arn(self) -> str:
        return pulumi.get(self, "license_configuration_arn")


@pulumi.output_type
class GetLaunchTemplateMaintenanceOptionResult(dict):
    def __init__(__self__, *,
                 auto_recovery: str):
        GetLaunchTemplateMaintenanceOptionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auto_recovery=auto_recovery,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auto_recovery: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if auto_recovery is None and 'autoRecovery' in kwargs:
            auto_recovery = kwargs['autoRecovery']
        if auto_recovery is None:
            raise TypeError("Missing 'auto_recovery' argument")

        _setter("auto_recovery", auto_recovery)

    @property
    @pulumi.getter(name="autoRecovery")
    def auto_recovery(self) -> str:
        return pulumi.get(self, "auto_recovery")


@pulumi.output_type
class GetLaunchTemplateMetadataOptionResult(dict):
    def __init__(__self__, *,
                 http_endpoint: str,
                 http_protocol_ipv6: str,
                 http_put_response_hop_limit: int,
                 http_tokens: str,
                 instance_metadata_tags: str):
        GetLaunchTemplateMetadataOptionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            http_endpoint=http_endpoint,
            http_protocol_ipv6=http_protocol_ipv6,
            http_put_response_hop_limit=http_put_response_hop_limit,
            http_tokens=http_tokens,
            instance_metadata_tags=instance_metadata_tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             http_endpoint: Optional[str] = None,
             http_protocol_ipv6: Optional[str] = None,
             http_put_response_hop_limit: Optional[int] = None,
             http_tokens: Optional[str] = None,
             instance_metadata_tags: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if http_endpoint is None and 'httpEndpoint' in kwargs:
            http_endpoint = kwargs['httpEndpoint']
        if http_endpoint is None:
            raise TypeError("Missing 'http_endpoint' argument")
        if http_protocol_ipv6 is None and 'httpProtocolIpv6' in kwargs:
            http_protocol_ipv6 = kwargs['httpProtocolIpv6']
        if http_protocol_ipv6 is None:
            raise TypeError("Missing 'http_protocol_ipv6' argument")
        if http_put_response_hop_limit is None and 'httpPutResponseHopLimit' in kwargs:
            http_put_response_hop_limit = kwargs['httpPutResponseHopLimit']
        if http_put_response_hop_limit is None:
            raise TypeError("Missing 'http_put_response_hop_limit' argument")
        if http_tokens is None and 'httpTokens' in kwargs:
            http_tokens = kwargs['httpTokens']
        if http_tokens is None:
            raise TypeError("Missing 'http_tokens' argument")
        if instance_metadata_tags is None and 'instanceMetadataTags' in kwargs:
            instance_metadata_tags = kwargs['instanceMetadataTags']
        if instance_metadata_tags is None:
            raise TypeError("Missing 'instance_metadata_tags' argument")

        _setter("http_endpoint", http_endpoint)
        _setter("http_protocol_ipv6", http_protocol_ipv6)
        _setter("http_put_response_hop_limit", http_put_response_hop_limit)
        _setter("http_tokens", http_tokens)
        _setter("instance_metadata_tags", instance_metadata_tags)

    @property
    @pulumi.getter(name="httpEndpoint")
    def http_endpoint(self) -> str:
        return pulumi.get(self, "http_endpoint")

    @property
    @pulumi.getter(name="httpProtocolIpv6")
    def http_protocol_ipv6(self) -> str:
        return pulumi.get(self, "http_protocol_ipv6")

    @property
    @pulumi.getter(name="httpPutResponseHopLimit")
    def http_put_response_hop_limit(self) -> int:
        return pulumi.get(self, "http_put_response_hop_limit")

    @property
    @pulumi.getter(name="httpTokens")
    def http_tokens(self) -> str:
        return pulumi.get(self, "http_tokens")

    @property
    @pulumi.getter(name="instanceMetadataTags")
    def instance_metadata_tags(self) -> str:
        return pulumi.get(self, "instance_metadata_tags")


@pulumi.output_type
class GetLaunchTemplateMonitoringResult(dict):
    def __init__(__self__, *,
                 enabled: bool):
        GetLaunchTemplateMonitoringResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if enabled is None:
            raise TypeError("Missing 'enabled' argument")

        _setter("enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetLaunchTemplateNetworkInterfaceResult(dict):
    def __init__(__self__, *,
                 associate_carrier_ip_address: str,
                 description: str,
                 device_index: int,
                 interface_type: str,
                 ipv4_address_count: int,
                 ipv4_addresses: Sequence[str],
                 ipv4_prefix_count: int,
                 ipv4_prefixes: Sequence[str],
                 ipv6_address_count: int,
                 ipv6_addresses: Sequence[str],
                 ipv6_prefix_count: int,
                 ipv6_prefixes: Sequence[str],
                 network_card_index: int,
                 network_interface_id: str,
                 private_ip_address: str,
                 security_groups: Sequence[str],
                 subnet_id: str,
                 associate_public_ip_address: Optional[bool] = None,
                 delete_on_termination: Optional[bool] = None):
        GetLaunchTemplateNetworkInterfaceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            associate_carrier_ip_address=associate_carrier_ip_address,
            description=description,
            device_index=device_index,
            interface_type=interface_type,
            ipv4_address_count=ipv4_address_count,
            ipv4_addresses=ipv4_addresses,
            ipv4_prefix_count=ipv4_prefix_count,
            ipv4_prefixes=ipv4_prefixes,
            ipv6_address_count=ipv6_address_count,
            ipv6_addresses=ipv6_addresses,
            ipv6_prefix_count=ipv6_prefix_count,
            ipv6_prefixes=ipv6_prefixes,
            network_card_index=network_card_index,
            network_interface_id=network_interface_id,
            private_ip_address=private_ip_address,
            security_groups=security_groups,
            subnet_id=subnet_id,
            associate_public_ip_address=associate_public_ip_address,
            delete_on_termination=delete_on_termination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             associate_carrier_ip_address: Optional[str] = None,
             description: Optional[str] = None,
             device_index: Optional[int] = None,
             interface_type: Optional[str] = None,
             ipv4_address_count: Optional[int] = None,
             ipv4_addresses: Optional[Sequence[str]] = None,
             ipv4_prefix_count: Optional[int] = None,
             ipv4_prefixes: Optional[Sequence[str]] = None,
             ipv6_address_count: Optional[int] = None,
             ipv6_addresses: Optional[Sequence[str]] = None,
             ipv6_prefix_count: Optional[int] = None,
             ipv6_prefixes: Optional[Sequence[str]] = None,
             network_card_index: Optional[int] = None,
             network_interface_id: Optional[str] = None,
             private_ip_address: Optional[str] = None,
             security_groups: Optional[Sequence[str]] = None,
             subnet_id: Optional[str] = None,
             associate_public_ip_address: Optional[bool] = None,
             delete_on_termination: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if associate_carrier_ip_address is None and 'associateCarrierIpAddress' in kwargs:
            associate_carrier_ip_address = kwargs['associateCarrierIpAddress']
        if associate_carrier_ip_address is None:
            raise TypeError("Missing 'associate_carrier_ip_address' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if device_index is None and 'deviceIndex' in kwargs:
            device_index = kwargs['deviceIndex']
        if device_index is None:
            raise TypeError("Missing 'device_index' argument")
        if interface_type is None and 'interfaceType' in kwargs:
            interface_type = kwargs['interfaceType']
        if interface_type is None:
            raise TypeError("Missing 'interface_type' argument")
        if ipv4_address_count is None and 'ipv4AddressCount' in kwargs:
            ipv4_address_count = kwargs['ipv4AddressCount']
        if ipv4_address_count is None:
            raise TypeError("Missing 'ipv4_address_count' argument")
        if ipv4_addresses is None and 'ipv4Addresses' in kwargs:
            ipv4_addresses = kwargs['ipv4Addresses']
        if ipv4_addresses is None:
            raise TypeError("Missing 'ipv4_addresses' argument")
        if ipv4_prefix_count is None and 'ipv4PrefixCount' in kwargs:
            ipv4_prefix_count = kwargs['ipv4PrefixCount']
        if ipv4_prefix_count is None:
            raise TypeError("Missing 'ipv4_prefix_count' argument")
        if ipv4_prefixes is None and 'ipv4Prefixes' in kwargs:
            ipv4_prefixes = kwargs['ipv4Prefixes']
        if ipv4_prefixes is None:
            raise TypeError("Missing 'ipv4_prefixes' argument")
        if ipv6_address_count is None and 'ipv6AddressCount' in kwargs:
            ipv6_address_count = kwargs['ipv6AddressCount']
        if ipv6_address_count is None:
            raise TypeError("Missing 'ipv6_address_count' argument")
        if ipv6_addresses is None and 'ipv6Addresses' in kwargs:
            ipv6_addresses = kwargs['ipv6Addresses']
        if ipv6_addresses is None:
            raise TypeError("Missing 'ipv6_addresses' argument")
        if ipv6_prefix_count is None and 'ipv6PrefixCount' in kwargs:
            ipv6_prefix_count = kwargs['ipv6PrefixCount']
        if ipv6_prefix_count is None:
            raise TypeError("Missing 'ipv6_prefix_count' argument")
        if ipv6_prefixes is None and 'ipv6Prefixes' in kwargs:
            ipv6_prefixes = kwargs['ipv6Prefixes']
        if ipv6_prefixes is None:
            raise TypeError("Missing 'ipv6_prefixes' argument")
        if network_card_index is None and 'networkCardIndex' in kwargs:
            network_card_index = kwargs['networkCardIndex']
        if network_card_index is None:
            raise TypeError("Missing 'network_card_index' argument")
        if network_interface_id is None and 'networkInterfaceId' in kwargs:
            network_interface_id = kwargs['networkInterfaceId']
        if network_interface_id is None:
            raise TypeError("Missing 'network_interface_id' argument")
        if private_ip_address is None and 'privateIpAddress' in kwargs:
            private_ip_address = kwargs['privateIpAddress']
        if private_ip_address is None:
            raise TypeError("Missing 'private_ip_address' argument")
        if security_groups is None and 'securityGroups' in kwargs:
            security_groups = kwargs['securityGroups']
        if security_groups is None:
            raise TypeError("Missing 'security_groups' argument")
        if subnet_id is None and 'subnetId' in kwargs:
            subnet_id = kwargs['subnetId']
        if subnet_id is None:
            raise TypeError("Missing 'subnet_id' argument")
        if associate_public_ip_address is None and 'associatePublicIpAddress' in kwargs:
            associate_public_ip_address = kwargs['associatePublicIpAddress']
        if delete_on_termination is None and 'deleteOnTermination' in kwargs:
            delete_on_termination = kwargs['deleteOnTermination']

        _setter("associate_carrier_ip_address", associate_carrier_ip_address)
        _setter("description", description)
        _setter("device_index", device_index)
        _setter("interface_type", interface_type)
        _setter("ipv4_address_count", ipv4_address_count)
        _setter("ipv4_addresses", ipv4_addresses)
        _setter("ipv4_prefix_count", ipv4_prefix_count)
        _setter("ipv4_prefixes", ipv4_prefixes)
        _setter("ipv6_address_count", ipv6_address_count)
        _setter("ipv6_addresses", ipv6_addresses)
        _setter("ipv6_prefix_count", ipv6_prefix_count)
        _setter("ipv6_prefixes", ipv6_prefixes)
        _setter("network_card_index", network_card_index)
        _setter("network_interface_id", network_interface_id)
        _setter("private_ip_address", private_ip_address)
        _setter("security_groups", security_groups)
        _setter("subnet_id", subnet_id)
        if associate_public_ip_address is not None:
            _setter("associate_public_ip_address", associate_public_ip_address)
        if delete_on_termination is not None:
            _setter("delete_on_termination", delete_on_termination)

    @property
    @pulumi.getter(name="associateCarrierIpAddress")
    def associate_carrier_ip_address(self) -> str:
        return pulumi.get(self, "associate_carrier_ip_address")

    @property
    @pulumi.getter
    def description(self) -> str:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="deviceIndex")
    def device_index(self) -> int:
        return pulumi.get(self, "device_index")

    @property
    @pulumi.getter(name="interfaceType")
    def interface_type(self) -> str:
        return pulumi.get(self, "interface_type")

    @property
    @pulumi.getter(name="ipv4AddressCount")
    def ipv4_address_count(self) -> int:
        return pulumi.get(self, "ipv4_address_count")

    @property
    @pulumi.getter(name="ipv4Addresses")
    def ipv4_addresses(self) -> Sequence[str]:
        return pulumi.get(self, "ipv4_addresses")

    @property
    @pulumi.getter(name="ipv4PrefixCount")
    def ipv4_prefix_count(self) -> int:
        return pulumi.get(self, "ipv4_prefix_count")

    @property
    @pulumi.getter(name="ipv4Prefixes")
    def ipv4_prefixes(self) -> Sequence[str]:
        return pulumi.get(self, "ipv4_prefixes")

    @property
    @pulumi.getter(name="ipv6AddressCount")
    def ipv6_address_count(self) -> int:
        return pulumi.get(self, "ipv6_address_count")

    @property
    @pulumi.getter(name="ipv6Addresses")
    def ipv6_addresses(self) -> Sequence[str]:
        return pulumi.get(self, "ipv6_addresses")

    @property
    @pulumi.getter(name="ipv6PrefixCount")
    def ipv6_prefix_count(self) -> int:
        return pulumi.get(self, "ipv6_prefix_count")

    @property
    @pulumi.getter(name="ipv6Prefixes")
    def ipv6_prefixes(self) -> Sequence[str]:
        return pulumi.get(self, "ipv6_prefixes")

    @property
    @pulumi.getter(name="networkCardIndex")
    def network_card_index(self) -> int:
        return pulumi.get(self, "network_card_index")

    @property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> str:
        return pulumi.get(self, "network_interface_id")

    @property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> str:
        return pulumi.get(self, "private_ip_address")

    @property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Sequence[str]:
        return pulumi.get(self, "security_groups")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="associatePublicIpAddress")
    def associate_public_ip_address(self) -> Optional[bool]:
        return pulumi.get(self, "associate_public_ip_address")

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[bool]:
        return pulumi.get(self, "delete_on_termination")


@pulumi.output_type
class GetLaunchTemplatePlacementResult(dict):
    def __init__(__self__, *,
                 affinity: str,
                 availability_zone: str,
                 group_name: str,
                 host_id: str,
                 host_resource_group_arn: str,
                 partition_number: int,
                 spread_domain: str,
                 tenancy: str):
        GetLaunchTemplatePlacementResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            affinity=affinity,
            availability_zone=availability_zone,
            group_name=group_name,
            host_id=host_id,
            host_resource_group_arn=host_resource_group_arn,
            partition_number=partition_number,
            spread_domain=spread_domain,
            tenancy=tenancy,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             affinity: Optional[str] = None,
             availability_zone: Optional[str] = None,
             group_name: Optional[str] = None,
             host_id: Optional[str] = None,
             host_resource_group_arn: Optional[str] = None,
             partition_number: Optional[int] = None,
             spread_domain: Optional[str] = None,
             tenancy: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if affinity is None:
            raise TypeError("Missing 'affinity' argument")
        if availability_zone is None and 'availabilityZone' in kwargs:
            availability_zone = kwargs['availabilityZone']
        if availability_zone is None:
            raise TypeError("Missing 'availability_zone' argument")
        if group_name is None and 'groupName' in kwargs:
            group_name = kwargs['groupName']
        if group_name is None:
            raise TypeError("Missing 'group_name' argument")
        if host_id is None and 'hostId' in kwargs:
            host_id = kwargs['hostId']
        if host_id is None:
            raise TypeError("Missing 'host_id' argument")
        if host_resource_group_arn is None and 'hostResourceGroupArn' in kwargs:
            host_resource_group_arn = kwargs['hostResourceGroupArn']
        if host_resource_group_arn is None:
            raise TypeError("Missing 'host_resource_group_arn' argument")
        if partition_number is None and 'partitionNumber' in kwargs:
            partition_number = kwargs['partitionNumber']
        if partition_number is None:
            raise TypeError("Missing 'partition_number' argument")
        if spread_domain is None and 'spreadDomain' in kwargs:
            spread_domain = kwargs['spreadDomain']
        if spread_domain is None:
            raise TypeError("Missing 'spread_domain' argument")
        if tenancy is None:
            raise TypeError("Missing 'tenancy' argument")

        _setter("affinity", affinity)
        _setter("availability_zone", availability_zone)
        _setter("group_name", group_name)
        _setter("host_id", host_id)
        _setter("host_resource_group_arn", host_resource_group_arn)
        _setter("partition_number", partition_number)
        _setter("spread_domain", spread_domain)
        _setter("tenancy", tenancy)

    @property
    @pulumi.getter
    def affinity(self) -> str:
        return pulumi.get(self, "affinity")

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> str:
        return pulumi.get(self, "availability_zone")

    @property
    @pulumi.getter(name="groupName")
    def group_name(self) -> str:
        return pulumi.get(self, "group_name")

    @property
    @pulumi.getter(name="hostId")
    def host_id(self) -> str:
        return pulumi.get(self, "host_id")

    @property
    @pulumi.getter(name="hostResourceGroupArn")
    def host_resource_group_arn(self) -> str:
        return pulumi.get(self, "host_resource_group_arn")

    @property
    @pulumi.getter(name="partitionNumber")
    def partition_number(self) -> int:
        return pulumi.get(self, "partition_number")

    @property
    @pulumi.getter(name="spreadDomain")
    def spread_domain(self) -> str:
        return pulumi.get(self, "spread_domain")

    @property
    @pulumi.getter
    def tenancy(self) -> str:
        return pulumi.get(self, "tenancy")


@pulumi.output_type
class GetLaunchTemplatePrivateDnsNameOptionResult(dict):
    def __init__(__self__, *,
                 enable_resource_name_dns_a_record: bool,
                 enable_resource_name_dns_aaaa_record: bool,
                 hostname_type: str):
        GetLaunchTemplatePrivateDnsNameOptionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enable_resource_name_dns_a_record=enable_resource_name_dns_a_record,
            enable_resource_name_dns_aaaa_record=enable_resource_name_dns_aaaa_record,
            hostname_type=hostname_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enable_resource_name_dns_a_record: Optional[bool] = None,
             enable_resource_name_dns_aaaa_record: Optional[bool] = None,
             hostname_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if enable_resource_name_dns_a_record is None and 'enableResourceNameDnsARecord' in kwargs:
            enable_resource_name_dns_a_record = kwargs['enableResourceNameDnsARecord']
        if enable_resource_name_dns_a_record is None:
            raise TypeError("Missing 'enable_resource_name_dns_a_record' argument")
        if enable_resource_name_dns_aaaa_record is None and 'enableResourceNameDnsAaaaRecord' in kwargs:
            enable_resource_name_dns_aaaa_record = kwargs['enableResourceNameDnsAaaaRecord']
        if enable_resource_name_dns_aaaa_record is None:
            raise TypeError("Missing 'enable_resource_name_dns_aaaa_record' argument")
        if hostname_type is None and 'hostnameType' in kwargs:
            hostname_type = kwargs['hostnameType']
        if hostname_type is None:
            raise TypeError("Missing 'hostname_type' argument")

        _setter("enable_resource_name_dns_a_record", enable_resource_name_dns_a_record)
        _setter("enable_resource_name_dns_aaaa_record", enable_resource_name_dns_aaaa_record)
        _setter("hostname_type", hostname_type)

    @property
    @pulumi.getter(name="enableResourceNameDnsARecord")
    def enable_resource_name_dns_a_record(self) -> bool:
        return pulumi.get(self, "enable_resource_name_dns_a_record")

    @property
    @pulumi.getter(name="enableResourceNameDnsAaaaRecord")
    def enable_resource_name_dns_aaaa_record(self) -> bool:
        return pulumi.get(self, "enable_resource_name_dns_aaaa_record")

    @property
    @pulumi.getter(name="hostnameType")
    def hostname_type(self) -> str:
        return pulumi.get(self, "hostname_type")


@pulumi.output_type
class GetLaunchTemplateTagSpecificationResult(dict):
    def __init__(__self__, *,
                 resource_type: str,
                 tags: Mapping[str, str]):
        """
        :param Mapping[str, str] tags: Map of tags, each pair of which must exactly match a pair on the desired Launch Template.
        """
        GetLaunchTemplateTagSpecificationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            resource_type=resource_type,
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             resource_type: Optional[str] = None,
             tags: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if resource_type is None and 'resourceType' in kwargs:
            resource_type = kwargs['resourceType']
        if resource_type is None:
            raise TypeError("Missing 'resource_type' argument")
        if tags is None:
            raise TypeError("Missing 'tags' argument")

        _setter("resource_type", resource_type)
        _setter("tags", tags)

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> str:
        return pulumi.get(self, "resource_type")

    @property
    @pulumi.getter
    def tags(self) -> Mapping[str, str]:
        """
        Map of tags, each pair of which must exactly match a pair on the desired Launch Template.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetLocalGatewayFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Name of the field to filter by, as defined by
               [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeLocalGateways.html).
        :param Sequence[str] values: Set of values that are accepted for the given field.
               A Local Gateway will be selected if any one of the given values matches.
        """
        GetLocalGatewayFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the field to filter by, as defined by
        [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeLocalGateways.html).
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Set of values that are accepted for the given field.
        A Local Gateway will be selected if any one of the given values matches.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetLocalGatewayRouteTableFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Name of the field to filter by, as defined by
               [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeLocalGatewayRouteTables.html).
        :param Sequence[str] values: Set of values that are accepted for the given field.
               A local gateway route table will be selected if any one of the given values matches.
        """
        GetLocalGatewayRouteTableFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the field to filter by, as defined by
        [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeLocalGatewayRouteTables.html).
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Set of values that are accepted for the given field.
        A local gateway route table will be selected if any one of the given values matches.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetLocalGatewayRouteTablesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Name of the field to filter by, as defined by
               [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeLocalGatewayRouteTables.html).
        :param Sequence[str] values: Set of values that are accepted for the given field.
               A Local Gateway Route Table will be selected if any one of the given values matches.
        """
        GetLocalGatewayRouteTablesFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the field to filter by, as defined by
        [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeLocalGatewayRouteTables.html).
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Set of values that are accepted for the given field.
        A Local Gateway Route Table will be selected if any one of the given values matches.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetLocalGatewayVirtualInterfaceFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Name of the filter.
        :param Sequence[str] values: List of one or more values for the filter.
        """
        GetLocalGatewayVirtualInterfaceFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the filter.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        List of one or more values for the filter.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetLocalGatewayVirtualInterfaceGroupFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Name of the filter.
        :param Sequence[str] values: List of one or more values for the filter.
        """
        GetLocalGatewayVirtualInterfaceGroupFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the filter.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        List of one or more values for the filter.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetLocalGatewayVirtualInterfaceGroupsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Name of the filter.
        :param Sequence[str] values: List of one or more values for the filter.
        """
        GetLocalGatewayVirtualInterfaceGroupsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the filter.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        List of one or more values for the filter.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetLocalGatewaysFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Name of the field to filter by, as defined by
               [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeLocalGateways.html).
        :param Sequence[str] values: Set of values that are accepted for the given field.
               A Local Gateway will be selected if any one of the given values matches.
        """
        GetLocalGatewaysFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the field to filter by, as defined by
        [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeLocalGateways.html).
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Set of values that are accepted for the given field.
        A Local Gateway will be selected if any one of the given values matches.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetManagedPrefixListEntryResult(dict):
    def __init__(__self__, *,
                 cidr: str,
                 description: str):
        GetManagedPrefixListEntryResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cidr=cidr,
            description=description,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cidr: Optional[str] = None,
             description: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cidr is None:
            raise TypeError("Missing 'cidr' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")

        _setter("cidr", cidr)
        _setter("description", description)

    @property
    @pulumi.getter
    def cidr(self) -> str:
        return pulumi.get(self, "cidr")

    @property
    @pulumi.getter
    def description(self) -> str:
        return pulumi.get(self, "description")


@pulumi.output_type
class GetManagedPrefixListFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Name of the filter field. Valid values can be found in the EC2 [DescribeManagedPrefixLists](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeManagedPrefixLists.html) API Reference.
        :param Sequence[str] values: Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
        """
        GetManagedPrefixListFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the filter field. Valid values can be found in the EC2 [DescribeManagedPrefixLists](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeManagedPrefixLists.html) API Reference.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetManagedPrefixListsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Name of the field to filter by, as defined by
               [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeManagedPrefixLists.html).
        :param Sequence[str] values: Set of values that are accepted for the given field.
               A managed prefix list will be selected if any one of the given values matches.
        """
        GetManagedPrefixListsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the field to filter by, as defined by
        [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeManagedPrefixLists.html).
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Set of values that are accepted for the given field.
        A managed prefix list will be selected if any one of the given values matches.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetNatGatewayFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Name of the field to filter by, as defined by
               [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNatGateways.html).
        :param Sequence[str] values: Set of values that are accepted for the given field.
               An Nat Gateway will be selected if any one of the given values matches.
        """
        GetNatGatewayFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the field to filter by, as defined by
        [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNatGateways.html).
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Set of values that are accepted for the given field.
        An Nat Gateway will be selected if any one of the given values matches.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetNatGatewaysFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Name of the field to filter by, as defined by
               [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNatGateways.html).
        :param Sequence[str] values: Set of values that are accepted for the given field.
               A Nat Gateway will be selected if any one of the given values matches.
        """
        GetNatGatewaysFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the field to filter by, as defined by
        [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNatGateways.html).
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Set of values that are accepted for the given field.
        A Nat Gateway will be selected if any one of the given values matches.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetNetworkAclsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Name of the field to filter by, as defined by
               [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkAcls.html).
        :param Sequence[str] values: Set of values that are accepted for the given field.
               A VPC will be selected if any one of the given values matches.
        """
        GetNetworkAclsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the field to filter by, as defined by
        [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkAcls.html).
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Set of values that are accepted for the given field.
        A VPC will be selected if any one of the given values matches.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetNetworkInsightsAnalysisAlternatePathHintResult(dict):
    def __init__(__self__, *,
                 component_arn: str,
                 component_id: str):
        GetNetworkInsightsAnalysisAlternatePathHintResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            component_arn=component_arn,
            component_id=component_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             component_arn: Optional[str] = None,
             component_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if component_arn is None and 'componentArn' in kwargs:
            component_arn = kwargs['componentArn']
        if component_arn is None:
            raise TypeError("Missing 'component_arn' argument")
        if component_id is None and 'componentId' in kwargs:
            component_id = kwargs['componentId']
        if component_id is None:
            raise TypeError("Missing 'component_id' argument")

        _setter("component_arn", component_arn)
        _setter("component_id", component_id)

    @property
    @pulumi.getter(name="componentArn")
    def component_arn(self) -> str:
        return pulumi.get(self, "component_arn")

    @property
    @pulumi.getter(name="componentId")
    def component_id(self) -> str:
        return pulumi.get(self, "component_id")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationResult(dict):
    def __init__(__self__, *,
                 acl_rules: Sequence['outputs.GetNetworkInsightsAnalysisExplanationAclRuleResult'],
                 acls: Sequence['outputs.GetNetworkInsightsAnalysisExplanationAclResult'],
                 address: str,
                 addresses: Sequence[str],
                 attached_tos: Sequence['outputs.GetNetworkInsightsAnalysisExplanationAttachedToResult'],
                 availability_zones: Sequence[str],
                 cidrs: Sequence[str],
                 classic_load_balancer_listeners: Sequence['outputs.GetNetworkInsightsAnalysisExplanationClassicLoadBalancerListenerResult'],
                 components: Sequence['outputs.GetNetworkInsightsAnalysisExplanationComponentResult'],
                 customer_gateways: Sequence['outputs.GetNetworkInsightsAnalysisExplanationCustomerGatewayResult'],
                 destination_vpcs: Sequence['outputs.GetNetworkInsightsAnalysisExplanationDestinationVpcResult'],
                 destinations: Sequence['outputs.GetNetworkInsightsAnalysisExplanationDestinationResult'],
                 direction: str,
                 elastic_load_balancer_listeners: Sequence['outputs.GetNetworkInsightsAnalysisExplanationElasticLoadBalancerListenerResult'],
                 explanation_code: str,
                 ingress_route_tables: Sequence['outputs.GetNetworkInsightsAnalysisExplanationIngressRouteTableResult'],
                 internet_gateways: Sequence['outputs.GetNetworkInsightsAnalysisExplanationInternetGatewayResult'],
                 load_balancer_arn: str,
                 load_balancer_listener_port: int,
                 load_balancer_target_group: Sequence['outputs.GetNetworkInsightsAnalysisExplanationLoadBalancerTargetGroupResult'],
                 load_balancer_target_groups: Sequence['outputs.GetNetworkInsightsAnalysisExplanationLoadBalancerTargetGroupResult'],
                 load_balancer_target_port: int,
                 missing_component: str,
                 nat_gateways: Sequence['outputs.GetNetworkInsightsAnalysisExplanationNatGatewayResult'],
                 network_interfaces: Sequence['outputs.GetNetworkInsightsAnalysisExplanationNetworkInterfaceResult'],
                 packet_field: str,
                 port: int,
                 port_ranges: Sequence['outputs.GetNetworkInsightsAnalysisExplanationPortRangeResult'],
                 prefix_lists: Sequence['outputs.GetNetworkInsightsAnalysisExplanationPrefixListResult'],
                 protocols: Sequence[str],
                 route_table_routes: Sequence['outputs.GetNetworkInsightsAnalysisExplanationRouteTableRouteResult'],
                 route_tables: Sequence['outputs.GetNetworkInsightsAnalysisExplanationRouteTableResult'],
                 security_group: Sequence['outputs.GetNetworkInsightsAnalysisExplanationSecurityGroupResult'],
                 security_group_rules: Sequence['outputs.GetNetworkInsightsAnalysisExplanationSecurityGroupRuleResult'],
                 security_groups: Sequence['outputs.GetNetworkInsightsAnalysisExplanationSecurityGroupResult'],
                 source_vpcs: Sequence['outputs.GetNetworkInsightsAnalysisExplanationSourceVpcResult'],
                 state: str,
                 subnet_route_tables: Sequence['outputs.GetNetworkInsightsAnalysisExplanationSubnetRouteTableResult'],
                 subnets: Sequence['outputs.GetNetworkInsightsAnalysisExplanationSubnetResult'],
                 transit_gateway_attachments: Sequence['outputs.GetNetworkInsightsAnalysisExplanationTransitGatewayAttachmentResult'],
                 transit_gateway_route_table_routes: Sequence['outputs.GetNetworkInsightsAnalysisExplanationTransitGatewayRouteTableRouteResult'],
                 transit_gateway_route_tables: Sequence['outputs.GetNetworkInsightsAnalysisExplanationTransitGatewayRouteTableResult'],
                 transit_gateways: Sequence['outputs.GetNetworkInsightsAnalysisExplanationTransitGatewayResult'],
                 vpc_endpoints: Sequence['outputs.GetNetworkInsightsAnalysisExplanationVpcEndpointResult'],
                 vpc_peering_connections: Sequence['outputs.GetNetworkInsightsAnalysisExplanationVpcPeeringConnectionResult'],
                 vpcs: Sequence['outputs.GetNetworkInsightsAnalysisExplanationVpcResult'],
                 vpn_connections: Sequence['outputs.GetNetworkInsightsAnalysisExplanationVpnConnectionResult'],
                 vpn_gateways: Sequence['outputs.GetNetworkInsightsAnalysisExplanationVpnGatewayResult']):
        GetNetworkInsightsAnalysisExplanationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            acl_rules=acl_rules,
            acls=acls,
            address=address,
            addresses=addresses,
            attached_tos=attached_tos,
            availability_zones=availability_zones,
            cidrs=cidrs,
            classic_load_balancer_listeners=classic_load_balancer_listeners,
            components=components,
            customer_gateways=customer_gateways,
            destination_vpcs=destination_vpcs,
            destinations=destinations,
            direction=direction,
            elastic_load_balancer_listeners=elastic_load_balancer_listeners,
            explanation_code=explanation_code,
            ingress_route_tables=ingress_route_tables,
            internet_gateways=internet_gateways,
            load_balancer_arn=load_balancer_arn,
            load_balancer_listener_port=load_balancer_listener_port,
            load_balancer_target_group=load_balancer_target_group,
            load_balancer_target_groups=load_balancer_target_groups,
            load_balancer_target_port=load_balancer_target_port,
            missing_component=missing_component,
            nat_gateways=nat_gateways,
            network_interfaces=network_interfaces,
            packet_field=packet_field,
            port=port,
            port_ranges=port_ranges,
            prefix_lists=prefix_lists,
            protocols=protocols,
            route_table_routes=route_table_routes,
            route_tables=route_tables,
            security_group=security_group,
            security_group_rules=security_group_rules,
            security_groups=security_groups,
            source_vpcs=source_vpcs,
            state=state,
            subnet_route_tables=subnet_route_tables,
            subnets=subnets,
            transit_gateway_attachments=transit_gateway_attachments,
            transit_gateway_route_table_routes=transit_gateway_route_table_routes,
            transit_gateway_route_tables=transit_gateway_route_tables,
            transit_gateways=transit_gateways,
            vpc_endpoints=vpc_endpoints,
            vpc_peering_connections=vpc_peering_connections,
            vpcs=vpcs,
            vpn_connections=vpn_connections,
            vpn_gateways=vpn_gateways,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             acl_rules: Optional[Sequence['outputs.GetNetworkInsightsAnalysisExplanationAclRuleResult']] = None,
             acls: Optional[Sequence['outputs.GetNetworkInsightsAnalysisExplanationAclResult']] = None,
             address: Optional[str] = None,
             addresses: Optional[Sequence[str]] = None,
             attached_tos: Optional[Sequence['outputs.GetNetworkInsightsAnalysisExplanationAttachedToResult']] = None,
             availability_zones: Optional[Sequence[str]] = None,
             cidrs: Optional[Sequence[str]] = None,
             classic_load_balancer_listeners: Optional[Sequence['outputs.GetNetworkInsightsAnalysisExplanationClassicLoadBalancerListenerResult']] = None,
             components: Optional[Sequence['outputs.GetNetworkInsightsAnalysisExplanationComponentResult']] = None,
             customer_gateways: Optional[Sequence['outputs.GetNetworkInsightsAnalysisExplanationCustomerGatewayResult']] = None,
             destination_vpcs: Optional[Sequence['outputs.GetNetworkInsightsAnalysisExplanationDestinationVpcResult']] = None,
             destinations: Optional[Sequence['outputs.GetNetworkInsightsAnalysisExplanationDestinationResult']] = None,
             direction: Optional[str] = None,
             elastic_load_balancer_listeners: Optional[Sequence['outputs.GetNetworkInsightsAnalysisExplanationElasticLoadBalancerListenerResult']] = None,
             explanation_code: Optional[str] = None,
             ingress_route_tables: Optional[Sequence['outputs.GetNetworkInsightsAnalysisExplanationIngressRouteTableResult']] = None,
             internet_gateways: Optional[Sequence['outputs.GetNetworkInsightsAnalysisExplanationInternetGatewayResult']] = None,
             load_balancer_arn: Optional[str] = None,
             load_balancer_listener_port: Optional[int] = None,
             load_balancer_target_group: Optional[Sequence['outputs.GetNetworkInsightsAnalysisExplanationLoadBalancerTargetGroupResult']] = None,
             load_balancer_target_groups: Optional[Sequence['outputs.GetNetworkInsightsAnalysisExplanationLoadBalancerTargetGroupResult']] = None,
             load_balancer_target_port: Optional[int] = None,
             missing_component: Optional[str] = None,
             nat_gateways: Optional[Sequence['outputs.GetNetworkInsightsAnalysisExplanationNatGatewayResult']] = None,
             network_interfaces: Optional[Sequence['outputs.GetNetworkInsightsAnalysisExplanationNetworkInterfaceResult']] = None,
             packet_field: Optional[str] = None,
             port: Optional[int] = None,
             port_ranges: Optional[Sequence['outputs.GetNetworkInsightsAnalysisExplanationPortRangeResult']] = None,
             prefix_lists: Optional[Sequence['outputs.GetNetworkInsightsAnalysisExplanationPrefixListResult']] = None,
             protocols: Optional[Sequence[str]] = None,
             route_table_routes: Optional[Sequence['outputs.GetNetworkInsightsAnalysisExplanationRouteTableRouteResult']] = None,
             route_tables: Optional[Sequence['outputs.GetNetworkInsightsAnalysisExplanationRouteTableResult']] = None,
             security_group: Optional[Sequence['outputs.GetNetworkInsightsAnalysisExplanationSecurityGroupResult']] = None,
             security_group_rules: Optional[Sequence['outputs.GetNetworkInsightsAnalysisExplanationSecurityGroupRuleResult']] = None,
             security_groups: Optional[Sequence['outputs.GetNetworkInsightsAnalysisExplanationSecurityGroupResult']] = None,
             source_vpcs: Optional[Sequence['outputs.GetNetworkInsightsAnalysisExplanationSourceVpcResult']] = None,
             state: Optional[str] = None,
             subnet_route_tables: Optional[Sequence['outputs.GetNetworkInsightsAnalysisExplanationSubnetRouteTableResult']] = None,
             subnets: Optional[Sequence['outputs.GetNetworkInsightsAnalysisExplanationSubnetResult']] = None,
             transit_gateway_attachments: Optional[Sequence['outputs.GetNetworkInsightsAnalysisExplanationTransitGatewayAttachmentResult']] = None,
             transit_gateway_route_table_routes: Optional[Sequence['outputs.GetNetworkInsightsAnalysisExplanationTransitGatewayRouteTableRouteResult']] = None,
             transit_gateway_route_tables: Optional[Sequence['outputs.GetNetworkInsightsAnalysisExplanationTransitGatewayRouteTableResult']] = None,
             transit_gateways: Optional[Sequence['outputs.GetNetworkInsightsAnalysisExplanationTransitGatewayResult']] = None,
             vpc_endpoints: Optional[Sequence['outputs.GetNetworkInsightsAnalysisExplanationVpcEndpointResult']] = None,
             vpc_peering_connections: Optional[Sequence['outputs.GetNetworkInsightsAnalysisExplanationVpcPeeringConnectionResult']] = None,
             vpcs: Optional[Sequence['outputs.GetNetworkInsightsAnalysisExplanationVpcResult']] = None,
             vpn_connections: Optional[Sequence['outputs.GetNetworkInsightsAnalysisExplanationVpnConnectionResult']] = None,
             vpn_gateways: Optional[Sequence['outputs.GetNetworkInsightsAnalysisExplanationVpnGatewayResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if acl_rules is None and 'aclRules' in kwargs:
            acl_rules = kwargs['aclRules']
        if acl_rules is None:
            raise TypeError("Missing 'acl_rules' argument")
        if acls is None:
            raise TypeError("Missing 'acls' argument")
        if address is None:
            raise TypeError("Missing 'address' argument")
        if addresses is None:
            raise TypeError("Missing 'addresses' argument")
        if attached_tos is None and 'attachedTos' in kwargs:
            attached_tos = kwargs['attachedTos']
        if attached_tos is None:
            raise TypeError("Missing 'attached_tos' argument")
        if availability_zones is None and 'availabilityZones' in kwargs:
            availability_zones = kwargs['availabilityZones']
        if availability_zones is None:
            raise TypeError("Missing 'availability_zones' argument")
        if cidrs is None:
            raise TypeError("Missing 'cidrs' argument")
        if classic_load_balancer_listeners is None and 'classicLoadBalancerListeners' in kwargs:
            classic_load_balancer_listeners = kwargs['classicLoadBalancerListeners']
        if classic_load_balancer_listeners is None:
            raise TypeError("Missing 'classic_load_balancer_listeners' argument")
        if components is None:
            raise TypeError("Missing 'components' argument")
        if customer_gateways is None and 'customerGateways' in kwargs:
            customer_gateways = kwargs['customerGateways']
        if customer_gateways is None:
            raise TypeError("Missing 'customer_gateways' argument")
        if destination_vpcs is None and 'destinationVpcs' in kwargs:
            destination_vpcs = kwargs['destinationVpcs']
        if destination_vpcs is None:
            raise TypeError("Missing 'destination_vpcs' argument")
        if destinations is None:
            raise TypeError("Missing 'destinations' argument")
        if direction is None:
            raise TypeError("Missing 'direction' argument")
        if elastic_load_balancer_listeners is None and 'elasticLoadBalancerListeners' in kwargs:
            elastic_load_balancer_listeners = kwargs['elasticLoadBalancerListeners']
        if elastic_load_balancer_listeners is None:
            raise TypeError("Missing 'elastic_load_balancer_listeners' argument")
        if explanation_code is None and 'explanationCode' in kwargs:
            explanation_code = kwargs['explanationCode']
        if explanation_code is None:
            raise TypeError("Missing 'explanation_code' argument")
        if ingress_route_tables is None and 'ingressRouteTables' in kwargs:
            ingress_route_tables = kwargs['ingressRouteTables']
        if ingress_route_tables is None:
            raise TypeError("Missing 'ingress_route_tables' argument")
        if internet_gateways is None and 'internetGateways' in kwargs:
            internet_gateways = kwargs['internetGateways']
        if internet_gateways is None:
            raise TypeError("Missing 'internet_gateways' argument")
        if load_balancer_arn is None and 'loadBalancerArn' in kwargs:
            load_balancer_arn = kwargs['loadBalancerArn']
        if load_balancer_arn is None:
            raise TypeError("Missing 'load_balancer_arn' argument")
        if load_balancer_listener_port is None and 'loadBalancerListenerPort' in kwargs:
            load_balancer_listener_port = kwargs['loadBalancerListenerPort']
        if load_balancer_listener_port is None:
            raise TypeError("Missing 'load_balancer_listener_port' argument")
        if load_balancer_target_group is None and 'loadBalancerTargetGroup' in kwargs:
            load_balancer_target_group = kwargs['loadBalancerTargetGroup']
        if load_balancer_target_group is None:
            raise TypeError("Missing 'load_balancer_target_group' argument")
        if load_balancer_target_groups is None and 'loadBalancerTargetGroups' in kwargs:
            load_balancer_target_groups = kwargs['loadBalancerTargetGroups']
        if load_balancer_target_groups is None:
            raise TypeError("Missing 'load_balancer_target_groups' argument")
        if load_balancer_target_port is None and 'loadBalancerTargetPort' in kwargs:
            load_balancer_target_port = kwargs['loadBalancerTargetPort']
        if load_balancer_target_port is None:
            raise TypeError("Missing 'load_balancer_target_port' argument")
        if missing_component is None and 'missingComponent' in kwargs:
            missing_component = kwargs['missingComponent']
        if missing_component is None:
            raise TypeError("Missing 'missing_component' argument")
        if nat_gateways is None and 'natGateways' in kwargs:
            nat_gateways = kwargs['natGateways']
        if nat_gateways is None:
            raise TypeError("Missing 'nat_gateways' argument")
        if network_interfaces is None and 'networkInterfaces' in kwargs:
            network_interfaces = kwargs['networkInterfaces']
        if network_interfaces is None:
            raise TypeError("Missing 'network_interfaces' argument")
        if packet_field is None and 'packetField' in kwargs:
            packet_field = kwargs['packetField']
        if packet_field is None:
            raise TypeError("Missing 'packet_field' argument")
        if port is None:
            raise TypeError("Missing 'port' argument")
        if port_ranges is None and 'portRanges' in kwargs:
            port_ranges = kwargs['portRanges']
        if port_ranges is None:
            raise TypeError("Missing 'port_ranges' argument")
        if prefix_lists is None and 'prefixLists' in kwargs:
            prefix_lists = kwargs['prefixLists']
        if prefix_lists is None:
            raise TypeError("Missing 'prefix_lists' argument")
        if protocols is None:
            raise TypeError("Missing 'protocols' argument")
        if route_table_routes is None and 'routeTableRoutes' in kwargs:
            route_table_routes = kwargs['routeTableRoutes']
        if route_table_routes is None:
            raise TypeError("Missing 'route_table_routes' argument")
        if route_tables is None and 'routeTables' in kwargs:
            route_tables = kwargs['routeTables']
        if route_tables is None:
            raise TypeError("Missing 'route_tables' argument")
        if security_group is None and 'securityGroup' in kwargs:
            security_group = kwargs['securityGroup']
        if security_group is None:
            raise TypeError("Missing 'security_group' argument")
        if security_group_rules is None and 'securityGroupRules' in kwargs:
            security_group_rules = kwargs['securityGroupRules']
        if security_group_rules is None:
            raise TypeError("Missing 'security_group_rules' argument")
        if security_groups is None and 'securityGroups' in kwargs:
            security_groups = kwargs['securityGroups']
        if security_groups is None:
            raise TypeError("Missing 'security_groups' argument")
        if source_vpcs is None and 'sourceVpcs' in kwargs:
            source_vpcs = kwargs['sourceVpcs']
        if source_vpcs is None:
            raise TypeError("Missing 'source_vpcs' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if subnet_route_tables is None and 'subnetRouteTables' in kwargs:
            subnet_route_tables = kwargs['subnetRouteTables']
        if subnet_route_tables is None:
            raise TypeError("Missing 'subnet_route_tables' argument")
        if subnets is None:
            raise TypeError("Missing 'subnets' argument")
        if transit_gateway_attachments is None and 'transitGatewayAttachments' in kwargs:
            transit_gateway_attachments = kwargs['transitGatewayAttachments']
        if transit_gateway_attachments is None:
            raise TypeError("Missing 'transit_gateway_attachments' argument")
        if transit_gateway_route_table_routes is None and 'transitGatewayRouteTableRoutes' in kwargs:
            transit_gateway_route_table_routes = kwargs['transitGatewayRouteTableRoutes']
        if transit_gateway_route_table_routes is None:
            raise TypeError("Missing 'transit_gateway_route_table_routes' argument")
        if transit_gateway_route_tables is None and 'transitGatewayRouteTables' in kwargs:
            transit_gateway_route_tables = kwargs['transitGatewayRouteTables']
        if transit_gateway_route_tables is None:
            raise TypeError("Missing 'transit_gateway_route_tables' argument")
        if transit_gateways is None and 'transitGateways' in kwargs:
            transit_gateways = kwargs['transitGateways']
        if transit_gateways is None:
            raise TypeError("Missing 'transit_gateways' argument")
        if vpc_endpoints is None and 'vpcEndpoints' in kwargs:
            vpc_endpoints = kwargs['vpcEndpoints']
        if vpc_endpoints is None:
            raise TypeError("Missing 'vpc_endpoints' argument")
        if vpc_peering_connections is None and 'vpcPeeringConnections' in kwargs:
            vpc_peering_connections = kwargs['vpcPeeringConnections']
        if vpc_peering_connections is None:
            raise TypeError("Missing 'vpc_peering_connections' argument")
        if vpcs is None:
            raise TypeError("Missing 'vpcs' argument")
        if vpn_connections is None and 'vpnConnections' in kwargs:
            vpn_connections = kwargs['vpnConnections']
        if vpn_connections is None:
            raise TypeError("Missing 'vpn_connections' argument")
        if vpn_gateways is None and 'vpnGateways' in kwargs:
            vpn_gateways = kwargs['vpnGateways']
        if vpn_gateways is None:
            raise TypeError("Missing 'vpn_gateways' argument")

        _setter("acl_rules", acl_rules)
        _setter("acls", acls)
        _setter("address", address)
        _setter("addresses", addresses)
        _setter("attached_tos", attached_tos)
        _setter("availability_zones", availability_zones)
        _setter("cidrs", cidrs)
        _setter("classic_load_balancer_listeners", classic_load_balancer_listeners)
        _setter("components", components)
        _setter("customer_gateways", customer_gateways)
        _setter("destination_vpcs", destination_vpcs)
        _setter("destinations", destinations)
        _setter("direction", direction)
        _setter("elastic_load_balancer_listeners", elastic_load_balancer_listeners)
        _setter("explanation_code", explanation_code)
        _setter("ingress_route_tables", ingress_route_tables)
        _setter("internet_gateways", internet_gateways)
        _setter("load_balancer_arn", load_balancer_arn)
        _setter("load_balancer_listener_port", load_balancer_listener_port)
        _setter("load_balancer_target_group", load_balancer_target_group)
        _setter("load_balancer_target_groups", load_balancer_target_groups)
        _setter("load_balancer_target_port", load_balancer_target_port)
        _setter("missing_component", missing_component)
        _setter("nat_gateways", nat_gateways)
        _setter("network_interfaces", network_interfaces)
        _setter("packet_field", packet_field)
        _setter("port", port)
        _setter("port_ranges", port_ranges)
        _setter("prefix_lists", prefix_lists)
        _setter("protocols", protocols)
        _setter("route_table_routes", route_table_routes)
        _setter("route_tables", route_tables)
        _setter("security_group", security_group)
        _setter("security_group_rules", security_group_rules)
        _setter("security_groups", security_groups)
        _setter("source_vpcs", source_vpcs)
        _setter("state", state)
        _setter("subnet_route_tables", subnet_route_tables)
        _setter("subnets", subnets)
        _setter("transit_gateway_attachments", transit_gateway_attachments)
        _setter("transit_gateway_route_table_routes", transit_gateway_route_table_routes)
        _setter("transit_gateway_route_tables", transit_gateway_route_tables)
        _setter("transit_gateways", transit_gateways)
        _setter("vpc_endpoints", vpc_endpoints)
        _setter("vpc_peering_connections", vpc_peering_connections)
        _setter("vpcs", vpcs)
        _setter("vpn_connections", vpn_connections)
        _setter("vpn_gateways", vpn_gateways)

    @property
    @pulumi.getter(name="aclRules")
    def acl_rules(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationAclRuleResult']:
        return pulumi.get(self, "acl_rules")

    @property
    @pulumi.getter
    def acls(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationAclResult']:
        return pulumi.get(self, "acls")

    @property
    @pulumi.getter
    def address(self) -> str:
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def addresses(self) -> Sequence[str]:
        return pulumi.get(self, "addresses")

    @property
    @pulumi.getter(name="attachedTos")
    def attached_tos(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationAttachedToResult']:
        return pulumi.get(self, "attached_tos")

    @property
    @pulumi.getter(name="availabilityZones")
    def availability_zones(self) -> Sequence[str]:
        return pulumi.get(self, "availability_zones")

    @property
    @pulumi.getter
    def cidrs(self) -> Sequence[str]:
        return pulumi.get(self, "cidrs")

    @property
    @pulumi.getter(name="classicLoadBalancerListeners")
    def classic_load_balancer_listeners(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationClassicLoadBalancerListenerResult']:
        return pulumi.get(self, "classic_load_balancer_listeners")

    @property
    @pulumi.getter
    def components(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationComponentResult']:
        return pulumi.get(self, "components")

    @property
    @pulumi.getter(name="customerGateways")
    def customer_gateways(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationCustomerGatewayResult']:
        return pulumi.get(self, "customer_gateways")

    @property
    @pulumi.getter(name="destinationVpcs")
    def destination_vpcs(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationDestinationVpcResult']:
        return pulumi.get(self, "destination_vpcs")

    @property
    @pulumi.getter
    def destinations(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationDestinationResult']:
        return pulumi.get(self, "destinations")

    @property
    @pulumi.getter
    def direction(self) -> str:
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter(name="elasticLoadBalancerListeners")
    def elastic_load_balancer_listeners(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationElasticLoadBalancerListenerResult']:
        return pulumi.get(self, "elastic_load_balancer_listeners")

    @property
    @pulumi.getter(name="explanationCode")
    def explanation_code(self) -> str:
        return pulumi.get(self, "explanation_code")

    @property
    @pulumi.getter(name="ingressRouteTables")
    def ingress_route_tables(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationIngressRouteTableResult']:
        return pulumi.get(self, "ingress_route_tables")

    @property
    @pulumi.getter(name="internetGateways")
    def internet_gateways(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationInternetGatewayResult']:
        return pulumi.get(self, "internet_gateways")

    @property
    @pulumi.getter(name="loadBalancerArn")
    def load_balancer_arn(self) -> str:
        return pulumi.get(self, "load_balancer_arn")

    @property
    @pulumi.getter(name="loadBalancerListenerPort")
    def load_balancer_listener_port(self) -> int:
        return pulumi.get(self, "load_balancer_listener_port")

    @property
    @pulumi.getter(name="loadBalancerTargetGroup")
    def load_balancer_target_group(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationLoadBalancerTargetGroupResult']:
        return pulumi.get(self, "load_balancer_target_group")

    @property
    @pulumi.getter(name="loadBalancerTargetGroups")
    def load_balancer_target_groups(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationLoadBalancerTargetGroupResult']:
        return pulumi.get(self, "load_balancer_target_groups")

    @property
    @pulumi.getter(name="loadBalancerTargetPort")
    def load_balancer_target_port(self) -> int:
        return pulumi.get(self, "load_balancer_target_port")

    @property
    @pulumi.getter(name="missingComponent")
    def missing_component(self) -> str:
        return pulumi.get(self, "missing_component")

    @property
    @pulumi.getter(name="natGateways")
    def nat_gateways(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationNatGatewayResult']:
        return pulumi.get(self, "nat_gateways")

    @property
    @pulumi.getter(name="networkInterfaces")
    def network_interfaces(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationNetworkInterfaceResult']:
        return pulumi.get(self, "network_interfaces")

    @property
    @pulumi.getter(name="packetField")
    def packet_field(self) -> str:
        return pulumi.get(self, "packet_field")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationPortRangeResult']:
        return pulumi.get(self, "port_ranges")

    @property
    @pulumi.getter(name="prefixLists")
    def prefix_lists(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationPrefixListResult']:
        return pulumi.get(self, "prefix_lists")

    @property
    @pulumi.getter
    def protocols(self) -> Sequence[str]:
        return pulumi.get(self, "protocols")

    @property
    @pulumi.getter(name="routeTableRoutes")
    def route_table_routes(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationRouteTableRouteResult']:
        return pulumi.get(self, "route_table_routes")

    @property
    @pulumi.getter(name="routeTables")
    def route_tables(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationRouteTableResult']:
        return pulumi.get(self, "route_tables")

    @property
    @pulumi.getter(name="securityGroup")
    def security_group(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationSecurityGroupResult']:
        return pulumi.get(self, "security_group")

    @property
    @pulumi.getter(name="securityGroupRules")
    def security_group_rules(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationSecurityGroupRuleResult']:
        return pulumi.get(self, "security_group_rules")

    @property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationSecurityGroupResult']:
        return pulumi.get(self, "security_groups")

    @property
    @pulumi.getter(name="sourceVpcs")
    def source_vpcs(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationSourceVpcResult']:
        return pulumi.get(self, "source_vpcs")

    @property
    @pulumi.getter
    def state(self) -> str:
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="subnetRouteTables")
    def subnet_route_tables(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationSubnetRouteTableResult']:
        return pulumi.get(self, "subnet_route_tables")

    @property
    @pulumi.getter
    def subnets(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationSubnetResult']:
        return pulumi.get(self, "subnets")

    @property
    @pulumi.getter(name="transitGatewayAttachments")
    def transit_gateway_attachments(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationTransitGatewayAttachmentResult']:
        return pulumi.get(self, "transit_gateway_attachments")

    @property
    @pulumi.getter(name="transitGatewayRouteTableRoutes")
    def transit_gateway_route_table_routes(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationTransitGatewayRouteTableRouteResult']:
        return pulumi.get(self, "transit_gateway_route_table_routes")

    @property
    @pulumi.getter(name="transitGatewayRouteTables")
    def transit_gateway_route_tables(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationTransitGatewayRouteTableResult']:
        return pulumi.get(self, "transit_gateway_route_tables")

    @property
    @pulumi.getter(name="transitGateways")
    def transit_gateways(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationTransitGatewayResult']:
        return pulumi.get(self, "transit_gateways")

    @property
    @pulumi.getter(name="vpcEndpoints")
    def vpc_endpoints(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationVpcEndpointResult']:
        return pulumi.get(self, "vpc_endpoints")

    @property
    @pulumi.getter(name="vpcPeeringConnections")
    def vpc_peering_connections(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationVpcPeeringConnectionResult']:
        return pulumi.get(self, "vpc_peering_connections")

    @property
    @pulumi.getter
    def vpcs(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationVpcResult']:
        return pulumi.get(self, "vpcs")

    @property
    @pulumi.getter(name="vpnConnections")
    def vpn_connections(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationVpnConnectionResult']:
        return pulumi.get(self, "vpn_connections")

    @property
    @pulumi.getter(name="vpnGateways")
    def vpn_gateways(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationVpnGatewayResult']:
        return pulumi.get(self, "vpn_gateways")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationAclResult(dict):
    def __init__(__self__, *,
                 arn: str,
                 id: str,
                 name: str):
        """
        :param str arn: ARN of the selected Network Insights Analysis.
        :param str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        GetNetworkInsightsAnalysisExplanationAclResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if arn is None:
            raise TypeError("Missing 'arn' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("arn", arn)
        _setter("id", id)
        _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationAclRuleResult(dict):
    def __init__(__self__, *,
                 cidr: str,
                 egress: bool,
                 port_ranges: Sequence['outputs.GetNetworkInsightsAnalysisExplanationAclRulePortRangeResult'],
                 protocol: str,
                 rule_action: str,
                 rule_number: int):
        GetNetworkInsightsAnalysisExplanationAclRuleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cidr=cidr,
            egress=egress,
            port_ranges=port_ranges,
            protocol=protocol,
            rule_action=rule_action,
            rule_number=rule_number,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cidr: Optional[str] = None,
             egress: Optional[bool] = None,
             port_ranges: Optional[Sequence['outputs.GetNetworkInsightsAnalysisExplanationAclRulePortRangeResult']] = None,
             protocol: Optional[str] = None,
             rule_action: Optional[str] = None,
             rule_number: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cidr is None:
            raise TypeError("Missing 'cidr' argument")
        if egress is None:
            raise TypeError("Missing 'egress' argument")
        if port_ranges is None and 'portRanges' in kwargs:
            port_ranges = kwargs['portRanges']
        if port_ranges is None:
            raise TypeError("Missing 'port_ranges' argument")
        if protocol is None:
            raise TypeError("Missing 'protocol' argument")
        if rule_action is None and 'ruleAction' in kwargs:
            rule_action = kwargs['ruleAction']
        if rule_action is None:
            raise TypeError("Missing 'rule_action' argument")
        if rule_number is None and 'ruleNumber' in kwargs:
            rule_number = kwargs['ruleNumber']
        if rule_number is None:
            raise TypeError("Missing 'rule_number' argument")

        _setter("cidr", cidr)
        _setter("egress", egress)
        _setter("port_ranges", port_ranges)
        _setter("protocol", protocol)
        _setter("rule_action", rule_action)
        _setter("rule_number", rule_number)

    @property
    @pulumi.getter
    def cidr(self) -> str:
        return pulumi.get(self, "cidr")

    @property
    @pulumi.getter
    def egress(self) -> bool:
        return pulumi.get(self, "egress")

    @property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationAclRulePortRangeResult']:
        return pulumi.get(self, "port_ranges")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="ruleAction")
    def rule_action(self) -> str:
        return pulumi.get(self, "rule_action")

    @property
    @pulumi.getter(name="ruleNumber")
    def rule_number(self) -> int:
        return pulumi.get(self, "rule_number")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationAclRulePortRangeResult(dict):
    def __init__(__self__, *,
                 from_: int,
                 to: int):
        GetNetworkInsightsAnalysisExplanationAclRulePortRangeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            from_=from_,
            to=to,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             from_: Optional[int] = None,
             to: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if from_ is None and 'from' in kwargs:
            from_ = kwargs['from']
        if from_ is None:
            raise TypeError("Missing 'from_' argument")
        if to is None:
            raise TypeError("Missing 'to' argument")

        _setter("from_", from_)
        _setter("to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> int:
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> int:
        return pulumi.get(self, "to")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationAttachedToResult(dict):
    def __init__(__self__, *,
                 arn: str,
                 id: str,
                 name: str):
        """
        :param str arn: ARN of the selected Network Insights Analysis.
        :param str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        GetNetworkInsightsAnalysisExplanationAttachedToResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if arn is None:
            raise TypeError("Missing 'arn' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("arn", arn)
        _setter("id", id)
        _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationClassicLoadBalancerListenerResult(dict):
    def __init__(__self__, *,
                 instance_port: int,
                 load_balancer_port: int):
        GetNetworkInsightsAnalysisExplanationClassicLoadBalancerListenerResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            instance_port=instance_port,
            load_balancer_port=load_balancer_port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             instance_port: Optional[int] = None,
             load_balancer_port: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if instance_port is None and 'instancePort' in kwargs:
            instance_port = kwargs['instancePort']
        if instance_port is None:
            raise TypeError("Missing 'instance_port' argument")
        if load_balancer_port is None and 'loadBalancerPort' in kwargs:
            load_balancer_port = kwargs['loadBalancerPort']
        if load_balancer_port is None:
            raise TypeError("Missing 'load_balancer_port' argument")

        _setter("instance_port", instance_port)
        _setter("load_balancer_port", load_balancer_port)

    @property
    @pulumi.getter(name="instancePort")
    def instance_port(self) -> int:
        return pulumi.get(self, "instance_port")

    @property
    @pulumi.getter(name="loadBalancerPort")
    def load_balancer_port(self) -> int:
        return pulumi.get(self, "load_balancer_port")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationComponentResult(dict):
    def __init__(__self__, *,
                 arn: str,
                 id: str,
                 name: str):
        """
        :param str arn: ARN of the selected Network Insights Analysis.
        :param str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        GetNetworkInsightsAnalysisExplanationComponentResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if arn is None:
            raise TypeError("Missing 'arn' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("arn", arn)
        _setter("id", id)
        _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationCustomerGatewayResult(dict):
    def __init__(__self__, *,
                 arn: str,
                 id: str,
                 name: str):
        """
        :param str arn: ARN of the selected Network Insights Analysis.
        :param str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        GetNetworkInsightsAnalysisExplanationCustomerGatewayResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if arn is None:
            raise TypeError("Missing 'arn' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("arn", arn)
        _setter("id", id)
        _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationDestinationResult(dict):
    def __init__(__self__, *,
                 arn: str,
                 id: str,
                 name: str):
        """
        :param str arn: ARN of the selected Network Insights Analysis.
        :param str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        GetNetworkInsightsAnalysisExplanationDestinationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if arn is None:
            raise TypeError("Missing 'arn' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("arn", arn)
        _setter("id", id)
        _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationDestinationVpcResult(dict):
    def __init__(__self__, *,
                 arn: str,
                 id: str,
                 name: str):
        """
        :param str arn: ARN of the selected Network Insights Analysis.
        :param str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        GetNetworkInsightsAnalysisExplanationDestinationVpcResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if arn is None:
            raise TypeError("Missing 'arn' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("arn", arn)
        _setter("id", id)
        _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationElasticLoadBalancerListenerResult(dict):
    def __init__(__self__, *,
                 arn: str,
                 id: str,
                 name: str):
        """
        :param str arn: ARN of the selected Network Insights Analysis.
        :param str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        GetNetworkInsightsAnalysisExplanationElasticLoadBalancerListenerResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if arn is None:
            raise TypeError("Missing 'arn' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("arn", arn)
        _setter("id", id)
        _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationIngressRouteTableResult(dict):
    def __init__(__self__, *,
                 arn: str,
                 id: str,
                 name: str):
        """
        :param str arn: ARN of the selected Network Insights Analysis.
        :param str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        GetNetworkInsightsAnalysisExplanationIngressRouteTableResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if arn is None:
            raise TypeError("Missing 'arn' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("arn", arn)
        _setter("id", id)
        _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationInternetGatewayResult(dict):
    def __init__(__self__, *,
                 arn: str,
                 id: str,
                 name: str):
        """
        :param str arn: ARN of the selected Network Insights Analysis.
        :param str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        GetNetworkInsightsAnalysisExplanationInternetGatewayResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if arn is None:
            raise TypeError("Missing 'arn' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("arn", arn)
        _setter("id", id)
        _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationLoadBalancerTargetGroupResult(dict):
    def __init__(__self__, *,
                 arn: str,
                 id: str,
                 name: str):
        """
        :param str arn: ARN of the selected Network Insights Analysis.
        :param str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        GetNetworkInsightsAnalysisExplanationLoadBalancerTargetGroupResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if arn is None:
            raise TypeError("Missing 'arn' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("arn", arn)
        _setter("id", id)
        _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationNatGatewayResult(dict):
    def __init__(__self__, *,
                 arn: str,
                 id: str,
                 name: str):
        """
        :param str arn: ARN of the selected Network Insights Analysis.
        :param str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        GetNetworkInsightsAnalysisExplanationNatGatewayResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if arn is None:
            raise TypeError("Missing 'arn' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("arn", arn)
        _setter("id", id)
        _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationNetworkInterfaceResult(dict):
    def __init__(__self__, *,
                 arn: str,
                 id: str,
                 name: str):
        """
        :param str arn: ARN of the selected Network Insights Analysis.
        :param str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        GetNetworkInsightsAnalysisExplanationNetworkInterfaceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if arn is None:
            raise TypeError("Missing 'arn' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("arn", arn)
        _setter("id", id)
        _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationPortRangeResult(dict):
    def __init__(__self__, *,
                 from_: int,
                 to: int):
        GetNetworkInsightsAnalysisExplanationPortRangeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            from_=from_,
            to=to,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             from_: Optional[int] = None,
             to: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if from_ is None and 'from' in kwargs:
            from_ = kwargs['from']
        if from_ is None:
            raise TypeError("Missing 'from_' argument")
        if to is None:
            raise TypeError("Missing 'to' argument")

        _setter("from_", from_)
        _setter("to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> int:
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> int:
        return pulumi.get(self, "to")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationPrefixListResult(dict):
    def __init__(__self__, *,
                 arn: str,
                 id: str,
                 name: str):
        """
        :param str arn: ARN of the selected Network Insights Analysis.
        :param str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        GetNetworkInsightsAnalysisExplanationPrefixListResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if arn is None:
            raise TypeError("Missing 'arn' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("arn", arn)
        _setter("id", id)
        _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationRouteTableResult(dict):
    def __init__(__self__, *,
                 arn: str,
                 id: str,
                 name: str):
        """
        :param str arn: ARN of the selected Network Insights Analysis.
        :param str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        GetNetworkInsightsAnalysisExplanationRouteTableResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if arn is None:
            raise TypeError("Missing 'arn' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("arn", arn)
        _setter("id", id)
        _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationRouteTableRouteResult(dict):
    def __init__(__self__, *,
                 destination_cidr: str,
                 destination_prefix_list_id: str,
                 egress_only_internet_gateway_id: str,
                 gateway_id: str,
                 instance_id: str,
                 nat_gateway_id: str,
                 network_interface_id: str,
                 origin: str,
                 transit_gateway_id: str,
                 vpc_peering_connection_id: str):
        GetNetworkInsightsAnalysisExplanationRouteTableRouteResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination_cidr=destination_cidr,
            destination_prefix_list_id=destination_prefix_list_id,
            egress_only_internet_gateway_id=egress_only_internet_gateway_id,
            gateway_id=gateway_id,
            instance_id=instance_id,
            nat_gateway_id=nat_gateway_id,
            network_interface_id=network_interface_id,
            origin=origin,
            transit_gateway_id=transit_gateway_id,
            vpc_peering_connection_id=vpc_peering_connection_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination_cidr: Optional[str] = None,
             destination_prefix_list_id: Optional[str] = None,
             egress_only_internet_gateway_id: Optional[str] = None,
             gateway_id: Optional[str] = None,
             instance_id: Optional[str] = None,
             nat_gateway_id: Optional[str] = None,
             network_interface_id: Optional[str] = None,
             origin: Optional[str] = None,
             transit_gateway_id: Optional[str] = None,
             vpc_peering_connection_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if destination_cidr is None and 'destinationCidr' in kwargs:
            destination_cidr = kwargs['destinationCidr']
        if destination_cidr is None:
            raise TypeError("Missing 'destination_cidr' argument")
        if destination_prefix_list_id is None and 'destinationPrefixListId' in kwargs:
            destination_prefix_list_id = kwargs['destinationPrefixListId']
        if destination_prefix_list_id is None:
            raise TypeError("Missing 'destination_prefix_list_id' argument")
        if egress_only_internet_gateway_id is None and 'egressOnlyInternetGatewayId' in kwargs:
            egress_only_internet_gateway_id = kwargs['egressOnlyInternetGatewayId']
        if egress_only_internet_gateway_id is None:
            raise TypeError("Missing 'egress_only_internet_gateway_id' argument")
        if gateway_id is None and 'gatewayId' in kwargs:
            gateway_id = kwargs['gatewayId']
        if gateway_id is None:
            raise TypeError("Missing 'gateway_id' argument")
        if instance_id is None and 'instanceId' in kwargs:
            instance_id = kwargs['instanceId']
        if instance_id is None:
            raise TypeError("Missing 'instance_id' argument")
        if nat_gateway_id is None and 'natGatewayId' in kwargs:
            nat_gateway_id = kwargs['natGatewayId']
        if nat_gateway_id is None:
            raise TypeError("Missing 'nat_gateway_id' argument")
        if network_interface_id is None and 'networkInterfaceId' in kwargs:
            network_interface_id = kwargs['networkInterfaceId']
        if network_interface_id is None:
            raise TypeError("Missing 'network_interface_id' argument")
        if origin is None:
            raise TypeError("Missing 'origin' argument")
        if transit_gateway_id is None and 'transitGatewayId' in kwargs:
            transit_gateway_id = kwargs['transitGatewayId']
        if transit_gateway_id is None:
            raise TypeError("Missing 'transit_gateway_id' argument")
        if vpc_peering_connection_id is None and 'vpcPeeringConnectionId' in kwargs:
            vpc_peering_connection_id = kwargs['vpcPeeringConnectionId']
        if vpc_peering_connection_id is None:
            raise TypeError("Missing 'vpc_peering_connection_id' argument")

        _setter("destination_cidr", destination_cidr)
        _setter("destination_prefix_list_id", destination_prefix_list_id)
        _setter("egress_only_internet_gateway_id", egress_only_internet_gateway_id)
        _setter("gateway_id", gateway_id)
        _setter("instance_id", instance_id)
        _setter("nat_gateway_id", nat_gateway_id)
        _setter("network_interface_id", network_interface_id)
        _setter("origin", origin)
        _setter("transit_gateway_id", transit_gateway_id)
        _setter("vpc_peering_connection_id", vpc_peering_connection_id)

    @property
    @pulumi.getter(name="destinationCidr")
    def destination_cidr(self) -> str:
        return pulumi.get(self, "destination_cidr")

    @property
    @pulumi.getter(name="destinationPrefixListId")
    def destination_prefix_list_id(self) -> str:
        return pulumi.get(self, "destination_prefix_list_id")

    @property
    @pulumi.getter(name="egressOnlyInternetGatewayId")
    def egress_only_internet_gateway_id(self) -> str:
        return pulumi.get(self, "egress_only_internet_gateway_id")

    @property
    @pulumi.getter(name="gatewayId")
    def gateway_id(self) -> str:
        return pulumi.get(self, "gateway_id")

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> str:
        return pulumi.get(self, "instance_id")

    @property
    @pulumi.getter(name="natGatewayId")
    def nat_gateway_id(self) -> str:
        return pulumi.get(self, "nat_gateway_id")

    @property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> str:
        return pulumi.get(self, "network_interface_id")

    @property
    @pulumi.getter
    def origin(self) -> str:
        return pulumi.get(self, "origin")

    @property
    @pulumi.getter(name="transitGatewayId")
    def transit_gateway_id(self) -> str:
        return pulumi.get(self, "transit_gateway_id")

    @property
    @pulumi.getter(name="vpcPeeringConnectionId")
    def vpc_peering_connection_id(self) -> str:
        return pulumi.get(self, "vpc_peering_connection_id")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationSecurityGroupResult(dict):
    def __init__(__self__, *,
                 arn: str,
                 id: str,
                 name: str):
        """
        :param str arn: ARN of the selected Network Insights Analysis.
        :param str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        GetNetworkInsightsAnalysisExplanationSecurityGroupResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if arn is None:
            raise TypeError("Missing 'arn' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("arn", arn)
        _setter("id", id)
        _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationSecurityGroupRuleResult(dict):
    def __init__(__self__, *,
                 cidr: str,
                 direction: str,
                 port_ranges: Sequence['outputs.GetNetworkInsightsAnalysisExplanationSecurityGroupRulePortRangeResult'],
                 prefix_list_id: str,
                 protocol: str,
                 security_group_id: str):
        GetNetworkInsightsAnalysisExplanationSecurityGroupRuleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cidr=cidr,
            direction=direction,
            port_ranges=port_ranges,
            prefix_list_id=prefix_list_id,
            protocol=protocol,
            security_group_id=security_group_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cidr: Optional[str] = None,
             direction: Optional[str] = None,
             port_ranges: Optional[Sequence['outputs.GetNetworkInsightsAnalysisExplanationSecurityGroupRulePortRangeResult']] = None,
             prefix_list_id: Optional[str] = None,
             protocol: Optional[str] = None,
             security_group_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cidr is None:
            raise TypeError("Missing 'cidr' argument")
        if direction is None:
            raise TypeError("Missing 'direction' argument")
        if port_ranges is None and 'portRanges' in kwargs:
            port_ranges = kwargs['portRanges']
        if port_ranges is None:
            raise TypeError("Missing 'port_ranges' argument")
        if prefix_list_id is None and 'prefixListId' in kwargs:
            prefix_list_id = kwargs['prefixListId']
        if prefix_list_id is None:
            raise TypeError("Missing 'prefix_list_id' argument")
        if protocol is None:
            raise TypeError("Missing 'protocol' argument")
        if security_group_id is None and 'securityGroupId' in kwargs:
            security_group_id = kwargs['securityGroupId']
        if security_group_id is None:
            raise TypeError("Missing 'security_group_id' argument")

        _setter("cidr", cidr)
        _setter("direction", direction)
        _setter("port_ranges", port_ranges)
        _setter("prefix_list_id", prefix_list_id)
        _setter("protocol", protocol)
        _setter("security_group_id", security_group_id)

    @property
    @pulumi.getter
    def cidr(self) -> str:
        return pulumi.get(self, "cidr")

    @property
    @pulumi.getter
    def direction(self) -> str:
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationSecurityGroupRulePortRangeResult']:
        return pulumi.get(self, "port_ranges")

    @property
    @pulumi.getter(name="prefixListId")
    def prefix_list_id(self) -> str:
        return pulumi.get(self, "prefix_list_id")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> str:
        return pulumi.get(self, "security_group_id")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationSecurityGroupRulePortRangeResult(dict):
    def __init__(__self__, *,
                 from_: int,
                 to: int):
        GetNetworkInsightsAnalysisExplanationSecurityGroupRulePortRangeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            from_=from_,
            to=to,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             from_: Optional[int] = None,
             to: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if from_ is None and 'from' in kwargs:
            from_ = kwargs['from']
        if from_ is None:
            raise TypeError("Missing 'from_' argument")
        if to is None:
            raise TypeError("Missing 'to' argument")

        _setter("from_", from_)
        _setter("to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> int:
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> int:
        return pulumi.get(self, "to")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationSourceVpcResult(dict):
    def __init__(__self__, *,
                 arn: str,
                 id: str,
                 name: str):
        """
        :param str arn: ARN of the selected Network Insights Analysis.
        :param str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        GetNetworkInsightsAnalysisExplanationSourceVpcResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if arn is None:
            raise TypeError("Missing 'arn' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("arn", arn)
        _setter("id", id)
        _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationSubnetResult(dict):
    def __init__(__self__, *,
                 arn: str,
                 id: str,
                 name: str):
        """
        :param str arn: ARN of the selected Network Insights Analysis.
        :param str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        GetNetworkInsightsAnalysisExplanationSubnetResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if arn is None:
            raise TypeError("Missing 'arn' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("arn", arn)
        _setter("id", id)
        _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationSubnetRouteTableResult(dict):
    def __init__(__self__, *,
                 arn: str,
                 id: str,
                 name: str):
        """
        :param str arn: ARN of the selected Network Insights Analysis.
        :param str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        GetNetworkInsightsAnalysisExplanationSubnetRouteTableResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if arn is None:
            raise TypeError("Missing 'arn' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("arn", arn)
        _setter("id", id)
        _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationTransitGatewayResult(dict):
    def __init__(__self__, *,
                 arn: str,
                 id: str,
                 name: str):
        """
        :param str arn: ARN of the selected Network Insights Analysis.
        :param str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        GetNetworkInsightsAnalysisExplanationTransitGatewayResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if arn is None:
            raise TypeError("Missing 'arn' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("arn", arn)
        _setter("id", id)
        _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationTransitGatewayAttachmentResult(dict):
    def __init__(__self__, *,
                 arn: str,
                 id: str,
                 name: str):
        """
        :param str arn: ARN of the selected Network Insights Analysis.
        :param str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        GetNetworkInsightsAnalysisExplanationTransitGatewayAttachmentResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if arn is None:
            raise TypeError("Missing 'arn' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("arn", arn)
        _setter("id", id)
        _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationTransitGatewayRouteTableResult(dict):
    def __init__(__self__, *,
                 arn: str,
                 id: str,
                 name: str):
        """
        :param str arn: ARN of the selected Network Insights Analysis.
        :param str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        GetNetworkInsightsAnalysisExplanationTransitGatewayRouteTableResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if arn is None:
            raise TypeError("Missing 'arn' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("arn", arn)
        _setter("id", id)
        _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationTransitGatewayRouteTableRouteResult(dict):
    def __init__(__self__, *,
                 attachment_id: str,
                 destination_cidr: str,
                 prefix_list_id: str,
                 resource_id: str,
                 resource_type: str,
                 route_origin: str,
                 state: str):
        GetNetworkInsightsAnalysisExplanationTransitGatewayRouteTableRouteResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            attachment_id=attachment_id,
            destination_cidr=destination_cidr,
            prefix_list_id=prefix_list_id,
            resource_id=resource_id,
            resource_type=resource_type,
            route_origin=route_origin,
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             attachment_id: Optional[str] = None,
             destination_cidr: Optional[str] = None,
             prefix_list_id: Optional[str] = None,
             resource_id: Optional[str] = None,
             resource_type: Optional[str] = None,
             route_origin: Optional[str] = None,
             state: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if attachment_id is None and 'attachmentId' in kwargs:
            attachment_id = kwargs['attachmentId']
        if attachment_id is None:
            raise TypeError("Missing 'attachment_id' argument")
        if destination_cidr is None and 'destinationCidr' in kwargs:
            destination_cidr = kwargs['destinationCidr']
        if destination_cidr is None:
            raise TypeError("Missing 'destination_cidr' argument")
        if prefix_list_id is None and 'prefixListId' in kwargs:
            prefix_list_id = kwargs['prefixListId']
        if prefix_list_id is None:
            raise TypeError("Missing 'prefix_list_id' argument")
        if resource_id is None and 'resourceId' in kwargs:
            resource_id = kwargs['resourceId']
        if resource_id is None:
            raise TypeError("Missing 'resource_id' argument")
        if resource_type is None and 'resourceType' in kwargs:
            resource_type = kwargs['resourceType']
        if resource_type is None:
            raise TypeError("Missing 'resource_type' argument")
        if route_origin is None and 'routeOrigin' in kwargs:
            route_origin = kwargs['routeOrigin']
        if route_origin is None:
            raise TypeError("Missing 'route_origin' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")

        _setter("attachment_id", attachment_id)
        _setter("destination_cidr", destination_cidr)
        _setter("prefix_list_id", prefix_list_id)
        _setter("resource_id", resource_id)
        _setter("resource_type", resource_type)
        _setter("route_origin", route_origin)
        _setter("state", state)

    @property
    @pulumi.getter(name="attachmentId")
    def attachment_id(self) -> str:
        return pulumi.get(self, "attachment_id")

    @property
    @pulumi.getter(name="destinationCidr")
    def destination_cidr(self) -> str:
        return pulumi.get(self, "destination_cidr")

    @property
    @pulumi.getter(name="prefixListId")
    def prefix_list_id(self) -> str:
        return pulumi.get(self, "prefix_list_id")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> str:
        return pulumi.get(self, "resource_id")

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> str:
        return pulumi.get(self, "resource_type")

    @property
    @pulumi.getter(name="routeOrigin")
    def route_origin(self) -> str:
        return pulumi.get(self, "route_origin")

    @property
    @pulumi.getter
    def state(self) -> str:
        return pulumi.get(self, "state")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationVpcResult(dict):
    def __init__(__self__, *,
                 arn: str,
                 id: str,
                 name: str):
        """
        :param str arn: ARN of the selected Network Insights Analysis.
        :param str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        GetNetworkInsightsAnalysisExplanationVpcResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if arn is None:
            raise TypeError("Missing 'arn' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("arn", arn)
        _setter("id", id)
        _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationVpcEndpointResult(dict):
    def __init__(__self__, *,
                 arn: str,
                 id: str,
                 name: str):
        """
        :param str arn: ARN of the selected Network Insights Analysis.
        :param str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        GetNetworkInsightsAnalysisExplanationVpcEndpointResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if arn is None:
            raise TypeError("Missing 'arn' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("arn", arn)
        _setter("id", id)
        _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationVpcPeeringConnectionResult(dict):
    def __init__(__self__, *,
                 arn: str,
                 id: str,
                 name: str):
        """
        :param str arn: ARN of the selected Network Insights Analysis.
        :param str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        GetNetworkInsightsAnalysisExplanationVpcPeeringConnectionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if arn is None:
            raise TypeError("Missing 'arn' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("arn", arn)
        _setter("id", id)
        _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationVpnConnectionResult(dict):
    def __init__(__self__, *,
                 arn: str,
                 id: str,
                 name: str):
        """
        :param str arn: ARN of the selected Network Insights Analysis.
        :param str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        GetNetworkInsightsAnalysisExplanationVpnConnectionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if arn is None:
            raise TypeError("Missing 'arn' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("arn", arn)
        _setter("id", id)
        _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationVpnGatewayResult(dict):
    def __init__(__self__, *,
                 arn: str,
                 id: str,
                 name: str):
        """
        :param str arn: ARN of the selected Network Insights Analysis.
        :param str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        GetNetworkInsightsAnalysisExplanationVpnGatewayResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if arn is None:
            raise TypeError("Missing 'arn' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("arn", arn)
        _setter("id", id)
        _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        :param Sequence[str] values: Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
        """
        GetNetworkInsightsAnalysisFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetNetworkInsightsAnalysisForwardPathComponentResult(dict):
    def __init__(__self__, *,
                 acl_rules: Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentAclRuleResult'],
                 additional_details: Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentAdditionalDetailResult'],
                 attached_tos: Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentAttachedToResult'],
                 components: Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentComponentResult'],
                 destination_vpcs: Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentDestinationVpcResult'],
                 inbound_headers: Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentInboundHeaderResult'],
                 outbound_headers: Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentOutboundHeaderResult'],
                 route_table_routes: Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentRouteTableRouteResult'],
                 security_group_rules: Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentSecurityGroupRuleResult'],
                 sequence_number: int,
                 source_vpcs: Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentSourceVpcResult'],
                 subnets: Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentSubnetResult'],
                 transit_gateway_route_table_routes: Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentTransitGatewayRouteTableRouteResult'],
                 transit_gateways: Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentTransitGatewayResult'],
                 vpcs: Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentVpcResult']):
        GetNetworkInsightsAnalysisForwardPathComponentResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            acl_rules=acl_rules,
            additional_details=additional_details,
            attached_tos=attached_tos,
            components=components,
            destination_vpcs=destination_vpcs,
            inbound_headers=inbound_headers,
            outbound_headers=outbound_headers,
            route_table_routes=route_table_routes,
            security_group_rules=security_group_rules,
            sequence_number=sequence_number,
            source_vpcs=source_vpcs,
            subnets=subnets,
            transit_gateway_route_table_routes=transit_gateway_route_table_routes,
            transit_gateways=transit_gateways,
            vpcs=vpcs,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             acl_rules: Optional[Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentAclRuleResult']] = None,
             additional_details: Optional[Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentAdditionalDetailResult']] = None,
             attached_tos: Optional[Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentAttachedToResult']] = None,
             components: Optional[Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentComponentResult']] = None,
             destination_vpcs: Optional[Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentDestinationVpcResult']] = None,
             inbound_headers: Optional[Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentInboundHeaderResult']] = None,
             outbound_headers: Optional[Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentOutboundHeaderResult']] = None,
             route_table_routes: Optional[Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentRouteTableRouteResult']] = None,
             security_group_rules: Optional[Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentSecurityGroupRuleResult']] = None,
             sequence_number: Optional[int] = None,
             source_vpcs: Optional[Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentSourceVpcResult']] = None,
             subnets: Optional[Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentSubnetResult']] = None,
             transit_gateway_route_table_routes: Optional[Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentTransitGatewayRouteTableRouteResult']] = None,
             transit_gateways: Optional[Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentTransitGatewayResult']] = None,
             vpcs: Optional[Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentVpcResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if acl_rules is None and 'aclRules' in kwargs:
            acl_rules = kwargs['aclRules']
        if acl_rules is None:
            raise TypeError("Missing 'acl_rules' argument")
        if additional_details is None and 'additionalDetails' in kwargs:
            additional_details = kwargs['additionalDetails']
        if additional_details is None:
            raise TypeError("Missing 'additional_details' argument")
        if attached_tos is None and 'attachedTos' in kwargs:
            attached_tos = kwargs['attachedTos']
        if attached_tos is None:
            raise TypeError("Missing 'attached_tos' argument")
        if components is None:
            raise TypeError("Missing 'components' argument")
        if destination_vpcs is None and 'destinationVpcs' in kwargs:
            destination_vpcs = kwargs['destinationVpcs']
        if destination_vpcs is None:
            raise TypeError("Missing 'destination_vpcs' argument")
        if inbound_headers is None and 'inboundHeaders' in kwargs:
            inbound_headers = kwargs['inboundHeaders']
        if inbound_headers is None:
            raise TypeError("Missing 'inbound_headers' argument")
        if outbound_headers is None and 'outboundHeaders' in kwargs:
            outbound_headers = kwargs['outboundHeaders']
        if outbound_headers is None:
            raise TypeError("Missing 'outbound_headers' argument")
        if route_table_routes is None and 'routeTableRoutes' in kwargs:
            route_table_routes = kwargs['routeTableRoutes']
        if route_table_routes is None:
            raise TypeError("Missing 'route_table_routes' argument")
        if security_group_rules is None and 'securityGroupRules' in kwargs:
            security_group_rules = kwargs['securityGroupRules']
        if security_group_rules is None:
            raise TypeError("Missing 'security_group_rules' argument")
        if sequence_number is None and 'sequenceNumber' in kwargs:
            sequence_number = kwargs['sequenceNumber']
        if sequence_number is None:
            raise TypeError("Missing 'sequence_number' argument")
        if source_vpcs is None and 'sourceVpcs' in kwargs:
            source_vpcs = kwargs['sourceVpcs']
        if source_vpcs is None:
            raise TypeError("Missing 'source_vpcs' argument")
        if subnets is None:
            raise TypeError("Missing 'subnets' argument")
        if transit_gateway_route_table_routes is None and 'transitGatewayRouteTableRoutes' in kwargs:
            transit_gateway_route_table_routes = kwargs['transitGatewayRouteTableRoutes']
        if transit_gateway_route_table_routes is None:
            raise TypeError("Missing 'transit_gateway_route_table_routes' argument")
        if transit_gateways is None and 'transitGateways' in kwargs:
            transit_gateways = kwargs['transitGateways']
        if transit_gateways is None:
            raise TypeError("Missing 'transit_gateways' argument")
        if vpcs is None:
            raise TypeError("Missing 'vpcs' argument")

        _setter("acl_rules", acl_rules)
        _setter("additional_details", additional_details)
        _setter("attached_tos", attached_tos)
        _setter("components", components)
        _setter("destination_vpcs", destination_vpcs)
        _setter("inbound_headers", inbound_headers)
        _setter("outbound_headers", outbound_headers)
        _setter("route_table_routes", route_table_routes)
        _setter("security_group_rules", security_group_rules)
        _setter("sequence_number", sequence_number)
        _setter("source_vpcs", source_vpcs)
        _setter("subnets", subnets)
        _setter("transit_gateway_route_table_routes", transit_gateway_route_table_routes)
        _setter("transit_gateways", transit_gateways)
        _setter("vpcs", vpcs)

    @property
    @pulumi.getter(name="aclRules")
    def acl_rules(self) -> Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentAclRuleResult']:
        return pulumi.get(self, "acl_rules")

    @property
    @pulumi.getter(name="additionalDetails")
    def additional_details(self) -> Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentAdditionalDetailResult']:
        return pulumi.get(self, "additional_details")

    @property
    @pulumi.getter(name="attachedTos")
    def attached_tos(self) -> Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentAttachedToResult']:
        return pulumi.get(self, "attached_tos")

    @property
    @pulumi.getter
    def components(self) -> Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentComponentResult']:
        return pulumi.get(self, "components")

    @property
    @pulumi.getter(name="destinationVpcs")
    def destination_vpcs(self) -> Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentDestinationVpcResult']:
        return pulumi.get(self, "destination_vpcs")

    @property
    @pulumi.getter(name="inboundHeaders")
    def inbound_headers(self) -> Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentInboundHeaderResult']:
        return pulumi.get(self, "inbound_headers")

    @property
    @pulumi.getter(name="outboundHeaders")
    def outbound_headers(self) -> Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentOutboundHeaderResult']:
        return pulumi.get(self, "outbound_headers")

    @property
    @pulumi.getter(name="routeTableRoutes")
    def route_table_routes(self) -> Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentRouteTableRouteResult']:
        return pulumi.get(self, "route_table_routes")

    @property
    @pulumi.getter(name="securityGroupRules")
    def security_group_rules(self) -> Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentSecurityGroupRuleResult']:
        return pulumi.get(self, "security_group_rules")

    @property
    @pulumi.getter(name="sequenceNumber")
    def sequence_number(self) -> int:
        return pulumi.get(self, "sequence_number")

    @property
    @pulumi.getter(name="sourceVpcs")
    def source_vpcs(self) -> Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentSourceVpcResult']:
        return pulumi.get(self, "source_vpcs")

    @property
    @pulumi.getter
    def subnets(self) -> Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentSubnetResult']:
        return pulumi.get(self, "subnets")

    @property
    @pulumi.getter(name="transitGatewayRouteTableRoutes")
    def transit_gateway_route_table_routes(self) -> Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentTransitGatewayRouteTableRouteResult']:
        return pulumi.get(self, "transit_gateway_route_table_routes")

    @property
    @pulumi.getter(name="transitGateways")
    def transit_gateways(self) -> Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentTransitGatewayResult']:
        return pulumi.get(self, "transit_gateways")

    @property
    @pulumi.getter
    def vpcs(self) -> Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentVpcResult']:
        return pulumi.get(self, "vpcs")


@pulumi.output_type
class GetNetworkInsightsAnalysisForwardPathComponentAclRuleResult(dict):
    def __init__(__self__, *,
                 cidr: str,
                 egress: bool,
                 port_ranges: Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentAclRulePortRangeResult'],
                 protocol: str,
                 rule_action: str,
                 rule_number: int):
        GetNetworkInsightsAnalysisForwardPathComponentAclRuleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cidr=cidr,
            egress=egress,
            port_ranges=port_ranges,
            protocol=protocol,
            rule_action=rule_action,
            rule_number=rule_number,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cidr: Optional[str] = None,
             egress: Optional[bool] = None,
             port_ranges: Optional[Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentAclRulePortRangeResult']] = None,
             protocol: Optional[str] = None,
             rule_action: Optional[str] = None,
             rule_number: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cidr is None:
            raise TypeError("Missing 'cidr' argument")
        if egress is None:
            raise TypeError("Missing 'egress' argument")
        if port_ranges is None and 'portRanges' in kwargs:
            port_ranges = kwargs['portRanges']
        if port_ranges is None:
            raise TypeError("Missing 'port_ranges' argument")
        if protocol is None:
            raise TypeError("Missing 'protocol' argument")
        if rule_action is None and 'ruleAction' in kwargs:
            rule_action = kwargs['ruleAction']
        if rule_action is None:
            raise TypeError("Missing 'rule_action' argument")
        if rule_number is None and 'ruleNumber' in kwargs:
            rule_number = kwargs['ruleNumber']
        if rule_number is None:
            raise TypeError("Missing 'rule_number' argument")

        _setter("cidr", cidr)
        _setter("egress", egress)
        _setter("port_ranges", port_ranges)
        _setter("protocol", protocol)
        _setter("rule_action", rule_action)
        _setter("rule_number", rule_number)

    @property
    @pulumi.getter
    def cidr(self) -> str:
        return pulumi.get(self, "cidr")

    @property
    @pulumi.getter
    def egress(self) -> bool:
        return pulumi.get(self, "egress")

    @property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentAclRulePortRangeResult']:
        return pulumi.get(self, "port_ranges")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="ruleAction")
    def rule_action(self) -> str:
        return pulumi.get(self, "rule_action")

    @property
    @pulumi.getter(name="ruleNumber")
    def rule_number(self) -> int:
        return pulumi.get(self, "rule_number")


@pulumi.output_type
class GetNetworkInsightsAnalysisForwardPathComponentAclRulePortRangeResult(dict):
    def __init__(__self__, *,
                 from_: int,
                 to: int):
        GetNetworkInsightsAnalysisForwardPathComponentAclRulePortRangeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            from_=from_,
            to=to,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             from_: Optional[int] = None,
             to: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if from_ is None and 'from' in kwargs:
            from_ = kwargs['from']
        if from_ is None:
            raise TypeError("Missing 'from_' argument")
        if to is None:
            raise TypeError("Missing 'to' argument")

        _setter("from_", from_)
        _setter("to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> int:
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> int:
        return pulumi.get(self, "to")


@pulumi.output_type
class GetNetworkInsightsAnalysisForwardPathComponentAdditionalDetailResult(dict):
    def __init__(__self__, *,
                 additional_detail_type: str,
                 components: Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentAdditionalDetailComponentResult']):
        GetNetworkInsightsAnalysisForwardPathComponentAdditionalDetailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            additional_detail_type=additional_detail_type,
            components=components,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             additional_detail_type: Optional[str] = None,
             components: Optional[Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentAdditionalDetailComponentResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if additional_detail_type is None and 'additionalDetailType' in kwargs:
            additional_detail_type = kwargs['additionalDetailType']
        if additional_detail_type is None:
            raise TypeError("Missing 'additional_detail_type' argument")
        if components is None:
            raise TypeError("Missing 'components' argument")

        _setter("additional_detail_type", additional_detail_type)
        _setter("components", components)

    @property
    @pulumi.getter(name="additionalDetailType")
    def additional_detail_type(self) -> str:
        return pulumi.get(self, "additional_detail_type")

    @property
    @pulumi.getter
    def components(self) -> Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentAdditionalDetailComponentResult']:
        return pulumi.get(self, "components")


@pulumi.output_type
class GetNetworkInsightsAnalysisForwardPathComponentAdditionalDetailComponentResult(dict):
    def __init__(__self__, *,
                 arn: str,
                 id: str,
                 name: str):
        """
        :param str arn: ARN of the selected Network Insights Analysis.
        :param str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        GetNetworkInsightsAnalysisForwardPathComponentAdditionalDetailComponentResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if arn is None:
            raise TypeError("Missing 'arn' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("arn", arn)
        _setter("id", id)
        _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisForwardPathComponentAttachedToResult(dict):
    def __init__(__self__, *,
                 arn: str,
                 id: str,
                 name: str):
        """
        :param str arn: ARN of the selected Network Insights Analysis.
        :param str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        GetNetworkInsightsAnalysisForwardPathComponentAttachedToResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if arn is None:
            raise TypeError("Missing 'arn' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("arn", arn)
        _setter("id", id)
        _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisForwardPathComponentComponentResult(dict):
    def __init__(__self__, *,
                 arn: str,
                 id: str,
                 name: str):
        """
        :param str arn: ARN of the selected Network Insights Analysis.
        :param str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        GetNetworkInsightsAnalysisForwardPathComponentComponentResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if arn is None:
            raise TypeError("Missing 'arn' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("arn", arn)
        _setter("id", id)
        _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisForwardPathComponentDestinationVpcResult(dict):
    def __init__(__self__, *,
                 arn: str,
                 id: str,
                 name: str):
        """
        :param str arn: ARN of the selected Network Insights Analysis.
        :param str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        GetNetworkInsightsAnalysisForwardPathComponentDestinationVpcResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if arn is None:
            raise TypeError("Missing 'arn' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("arn", arn)
        _setter("id", id)
        _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisForwardPathComponentInboundHeaderResult(dict):
    def __init__(__self__, *,
                 destination_addresses: Sequence[str],
                 destination_port_ranges: Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentInboundHeaderDestinationPortRangeResult'],
                 protocol: str,
                 source_addresses: Sequence[str],
                 source_port_ranges: Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentInboundHeaderSourcePortRangeResult']):
        GetNetworkInsightsAnalysisForwardPathComponentInboundHeaderResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination_addresses=destination_addresses,
            destination_port_ranges=destination_port_ranges,
            protocol=protocol,
            source_addresses=source_addresses,
            source_port_ranges=source_port_ranges,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination_addresses: Optional[Sequence[str]] = None,
             destination_port_ranges: Optional[Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentInboundHeaderDestinationPortRangeResult']] = None,
             protocol: Optional[str] = None,
             source_addresses: Optional[Sequence[str]] = None,
             source_port_ranges: Optional[Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentInboundHeaderSourcePortRangeResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if destination_addresses is None and 'destinationAddresses' in kwargs:
            destination_addresses = kwargs['destinationAddresses']
        if destination_addresses is None:
            raise TypeError("Missing 'destination_addresses' argument")
        if destination_port_ranges is None and 'destinationPortRanges' in kwargs:
            destination_port_ranges = kwargs['destinationPortRanges']
        if destination_port_ranges is None:
            raise TypeError("Missing 'destination_port_ranges' argument")
        if protocol is None:
            raise TypeError("Missing 'protocol' argument")
        if source_addresses is None and 'sourceAddresses' in kwargs:
            source_addresses = kwargs['sourceAddresses']
        if source_addresses is None:
            raise TypeError("Missing 'source_addresses' argument")
        if source_port_ranges is None and 'sourcePortRanges' in kwargs:
            source_port_ranges = kwargs['sourcePortRanges']
        if source_port_ranges is None:
            raise TypeError("Missing 'source_port_ranges' argument")

        _setter("destination_addresses", destination_addresses)
        _setter("destination_port_ranges", destination_port_ranges)
        _setter("protocol", protocol)
        _setter("source_addresses", source_addresses)
        _setter("source_port_ranges", source_port_ranges)

    @property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Sequence[str]:
        return pulumi.get(self, "destination_addresses")

    @property
    @pulumi.getter(name="destinationPortRanges")
    def destination_port_ranges(self) -> Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentInboundHeaderDestinationPortRangeResult']:
        return pulumi.get(self, "destination_port_ranges")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Sequence[str]:
        return pulumi.get(self, "source_addresses")

    @property
    @pulumi.getter(name="sourcePortRanges")
    def source_port_ranges(self) -> Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentInboundHeaderSourcePortRangeResult']:
        return pulumi.get(self, "source_port_ranges")


@pulumi.output_type
class GetNetworkInsightsAnalysisForwardPathComponentInboundHeaderDestinationPortRangeResult(dict):
    def __init__(__self__, *,
                 from_: int,
                 to: int):
        GetNetworkInsightsAnalysisForwardPathComponentInboundHeaderDestinationPortRangeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            from_=from_,
            to=to,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             from_: Optional[int] = None,
             to: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if from_ is None and 'from' in kwargs:
            from_ = kwargs['from']
        if from_ is None:
            raise TypeError("Missing 'from_' argument")
        if to is None:
            raise TypeError("Missing 'to' argument")

        _setter("from_", from_)
        _setter("to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> int:
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> int:
        return pulumi.get(self, "to")


@pulumi.output_type
class GetNetworkInsightsAnalysisForwardPathComponentInboundHeaderSourcePortRangeResult(dict):
    def __init__(__self__, *,
                 from_: int,
                 to: int):
        GetNetworkInsightsAnalysisForwardPathComponentInboundHeaderSourcePortRangeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            from_=from_,
            to=to,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             from_: Optional[int] = None,
             to: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if from_ is None and 'from' in kwargs:
            from_ = kwargs['from']
        if from_ is None:
            raise TypeError("Missing 'from_' argument")
        if to is None:
            raise TypeError("Missing 'to' argument")

        _setter("from_", from_)
        _setter("to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> int:
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> int:
        return pulumi.get(self, "to")


@pulumi.output_type
class GetNetworkInsightsAnalysisForwardPathComponentOutboundHeaderResult(dict):
    def __init__(__self__, *,
                 destination_addresses: Sequence[str],
                 destination_port_ranges: Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentOutboundHeaderDestinationPortRangeResult'],
                 protocol: str,
                 source_addresses: Sequence[str],
                 source_port_ranges: Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentOutboundHeaderSourcePortRangeResult']):
        GetNetworkInsightsAnalysisForwardPathComponentOutboundHeaderResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination_addresses=destination_addresses,
            destination_port_ranges=destination_port_ranges,
            protocol=protocol,
            source_addresses=source_addresses,
            source_port_ranges=source_port_ranges,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination_addresses: Optional[Sequence[str]] = None,
             destination_port_ranges: Optional[Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentOutboundHeaderDestinationPortRangeResult']] = None,
             protocol: Optional[str] = None,
             source_addresses: Optional[Sequence[str]] = None,
             source_port_ranges: Optional[Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentOutboundHeaderSourcePortRangeResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if destination_addresses is None and 'destinationAddresses' in kwargs:
            destination_addresses = kwargs['destinationAddresses']
        if destination_addresses is None:
            raise TypeError("Missing 'destination_addresses' argument")
        if destination_port_ranges is None and 'destinationPortRanges' in kwargs:
            destination_port_ranges = kwargs['destinationPortRanges']
        if destination_port_ranges is None:
            raise TypeError("Missing 'destination_port_ranges' argument")
        if protocol is None:
            raise TypeError("Missing 'protocol' argument")
        if source_addresses is None and 'sourceAddresses' in kwargs:
            source_addresses = kwargs['sourceAddresses']
        if source_addresses is None:
            raise TypeError("Missing 'source_addresses' argument")
        if source_port_ranges is None and 'sourcePortRanges' in kwargs:
            source_port_ranges = kwargs['sourcePortRanges']
        if source_port_ranges is None:
            raise TypeError("Missing 'source_port_ranges' argument")

        _setter("destination_addresses", destination_addresses)
        _setter("destination_port_ranges", destination_port_ranges)
        _setter("protocol", protocol)
        _setter("source_addresses", source_addresses)
        _setter("source_port_ranges", source_port_ranges)

    @property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Sequence[str]:
        return pulumi.get(self, "destination_addresses")

    @property
    @pulumi.getter(name="destinationPortRanges")
    def destination_port_ranges(self) -> Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentOutboundHeaderDestinationPortRangeResult']:
        return pulumi.get(self, "destination_port_ranges")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Sequence[str]:
        return pulumi.get(self, "source_addresses")

    @property
    @pulumi.getter(name="sourcePortRanges")
    def source_port_ranges(self) -> Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentOutboundHeaderSourcePortRangeResult']:
        return pulumi.get(self, "source_port_ranges")


@pulumi.output_type
class GetNetworkInsightsAnalysisForwardPathComponentOutboundHeaderDestinationPortRangeResult(dict):
    def __init__(__self__, *,
                 from_: int,
                 to: int):
        GetNetworkInsightsAnalysisForwardPathComponentOutboundHeaderDestinationPortRangeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            from_=from_,
            to=to,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             from_: Optional[int] = None,
             to: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if from_ is None and 'from' in kwargs:
            from_ = kwargs['from']
        if from_ is None:
            raise TypeError("Missing 'from_' argument")
        if to is None:
            raise TypeError("Missing 'to' argument")

        _setter("from_", from_)
        _setter("to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> int:
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> int:
        return pulumi.get(self, "to")


@pulumi.output_type
class GetNetworkInsightsAnalysisForwardPathComponentOutboundHeaderSourcePortRangeResult(dict):
    def __init__(__self__, *,
                 from_: int,
                 to: int):
        GetNetworkInsightsAnalysisForwardPathComponentOutboundHeaderSourcePortRangeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            from_=from_,
            to=to,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             from_: Optional[int] = None,
             to: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if from_ is None and 'from' in kwargs:
            from_ = kwargs['from']
        if from_ is None:
            raise TypeError("Missing 'from_' argument")
        if to is None:
            raise TypeError("Missing 'to' argument")

        _setter("from_", from_)
        _setter("to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> int:
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> int:
        return pulumi.get(self, "to")


@pulumi.output_type
class GetNetworkInsightsAnalysisForwardPathComponentRouteTableRouteResult(dict):
    def __init__(__self__, *,
                 destination_cidr: str,
                 destination_prefix_list_id: str,
                 egress_only_internet_gateway_id: str,
                 gateway_id: str,
                 instance_id: str,
                 nat_gateway_id: str,
                 network_interface_id: str,
                 origin: str,
                 transit_gateway_id: str,
                 vpc_peering_connection_id: str):
        GetNetworkInsightsAnalysisForwardPathComponentRouteTableRouteResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination_cidr=destination_cidr,
            destination_prefix_list_id=destination_prefix_list_id,
            egress_only_internet_gateway_id=egress_only_internet_gateway_id,
            gateway_id=gateway_id,
            instance_id=instance_id,
            nat_gateway_id=nat_gateway_id,
            network_interface_id=network_interface_id,
            origin=origin,
            transit_gateway_id=transit_gateway_id,
            vpc_peering_connection_id=vpc_peering_connection_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination_cidr: Optional[str] = None,
             destination_prefix_list_id: Optional[str] = None,
             egress_only_internet_gateway_id: Optional[str] = None,
             gateway_id: Optional[str] = None,
             instance_id: Optional[str] = None,
             nat_gateway_id: Optional[str] = None,
             network_interface_id: Optional[str] = None,
             origin: Optional[str] = None,
             transit_gateway_id: Optional[str] = None,
             vpc_peering_connection_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if destination_cidr is None and 'destinationCidr' in kwargs:
            destination_cidr = kwargs['destinationCidr']
        if destination_cidr is None:
            raise TypeError("Missing 'destination_cidr' argument")
        if destination_prefix_list_id is None and 'destinationPrefixListId' in kwargs:
            destination_prefix_list_id = kwargs['destinationPrefixListId']
        if destination_prefix_list_id is None:
            raise TypeError("Missing 'destination_prefix_list_id' argument")
        if egress_only_internet_gateway_id is None and 'egressOnlyInternetGatewayId' in kwargs:
            egress_only_internet_gateway_id = kwargs['egressOnlyInternetGatewayId']
        if egress_only_internet_gateway_id is None:
            raise TypeError("Missing 'egress_only_internet_gateway_id' argument")
        if gateway_id is None and 'gatewayId' in kwargs:
            gateway_id = kwargs['gatewayId']
        if gateway_id is None:
            raise TypeError("Missing 'gateway_id' argument")
        if instance_id is None and 'instanceId' in kwargs:
            instance_id = kwargs['instanceId']
        if instance_id is None:
            raise TypeError("Missing 'instance_id' argument")
        if nat_gateway_id is None and 'natGatewayId' in kwargs:
            nat_gateway_id = kwargs['natGatewayId']
        if nat_gateway_id is None:
            raise TypeError("Missing 'nat_gateway_id' argument")
        if network_interface_id is None and 'networkInterfaceId' in kwargs:
            network_interface_id = kwargs['networkInterfaceId']
        if network_interface_id is None:
            raise TypeError("Missing 'network_interface_id' argument")
        if origin is None:
            raise TypeError("Missing 'origin' argument")
        if transit_gateway_id is None and 'transitGatewayId' in kwargs:
            transit_gateway_id = kwargs['transitGatewayId']
        if transit_gateway_id is None:
            raise TypeError("Missing 'transit_gateway_id' argument")
        if vpc_peering_connection_id is None and 'vpcPeeringConnectionId' in kwargs:
            vpc_peering_connection_id = kwargs['vpcPeeringConnectionId']
        if vpc_peering_connection_id is None:
            raise TypeError("Missing 'vpc_peering_connection_id' argument")

        _setter("destination_cidr", destination_cidr)
        _setter("destination_prefix_list_id", destination_prefix_list_id)
        _setter("egress_only_internet_gateway_id", egress_only_internet_gateway_id)
        _setter("gateway_id", gateway_id)
        _setter("instance_id", instance_id)
        _setter("nat_gateway_id", nat_gateway_id)
        _setter("network_interface_id", network_interface_id)
        _setter("origin", origin)
        _setter("transit_gateway_id", transit_gateway_id)
        _setter("vpc_peering_connection_id", vpc_peering_connection_id)

    @property
    @pulumi.getter(name="destinationCidr")
    def destination_cidr(self) -> str:
        return pulumi.get(self, "destination_cidr")

    @property
    @pulumi.getter(name="destinationPrefixListId")
    def destination_prefix_list_id(self) -> str:
        return pulumi.get(self, "destination_prefix_list_id")

    @property
    @pulumi.getter(name="egressOnlyInternetGatewayId")
    def egress_only_internet_gateway_id(self) -> str:
        return pulumi.get(self, "egress_only_internet_gateway_id")

    @property
    @pulumi.getter(name="gatewayId")
    def gateway_id(self) -> str:
        return pulumi.get(self, "gateway_id")

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> str:
        return pulumi.get(self, "instance_id")

    @property
    @pulumi.getter(name="natGatewayId")
    def nat_gateway_id(self) -> str:
        return pulumi.get(self, "nat_gateway_id")

    @property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> str:
        return pulumi.get(self, "network_interface_id")

    @property
    @pulumi.getter
    def origin(self) -> str:
        return pulumi.get(self, "origin")

    @property
    @pulumi.getter(name="transitGatewayId")
    def transit_gateway_id(self) -> str:
        return pulumi.get(self, "transit_gateway_id")

    @property
    @pulumi.getter(name="vpcPeeringConnectionId")
    def vpc_peering_connection_id(self) -> str:
        return pulumi.get(self, "vpc_peering_connection_id")


@pulumi.output_type
class GetNetworkInsightsAnalysisForwardPathComponentSecurityGroupRuleResult(dict):
    def __init__(__self__, *,
                 cidr: str,
                 direction: str,
                 port_ranges: Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentSecurityGroupRulePortRangeResult'],
                 prefix_list_id: str,
                 protocol: str,
                 security_group_id: str):
        GetNetworkInsightsAnalysisForwardPathComponentSecurityGroupRuleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cidr=cidr,
            direction=direction,
            port_ranges=port_ranges,
            prefix_list_id=prefix_list_id,
            protocol=protocol,
            security_group_id=security_group_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cidr: Optional[str] = None,
             direction: Optional[str] = None,
             port_ranges: Optional[Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentSecurityGroupRulePortRangeResult']] = None,
             prefix_list_id: Optional[str] = None,
             protocol: Optional[str] = None,
             security_group_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cidr is None:
            raise TypeError("Missing 'cidr' argument")
        if direction is None:
            raise TypeError("Missing 'direction' argument")
        if port_ranges is None and 'portRanges' in kwargs:
            port_ranges = kwargs['portRanges']
        if port_ranges is None:
            raise TypeError("Missing 'port_ranges' argument")
        if prefix_list_id is None and 'prefixListId' in kwargs:
            prefix_list_id = kwargs['prefixListId']
        if prefix_list_id is None:
            raise TypeError("Missing 'prefix_list_id' argument")
        if protocol is None:
            raise TypeError("Missing 'protocol' argument")
        if security_group_id is None and 'securityGroupId' in kwargs:
            security_group_id = kwargs['securityGroupId']
        if security_group_id is None:
            raise TypeError("Missing 'security_group_id' argument")

        _setter("cidr", cidr)
        _setter("direction", direction)
        _setter("port_ranges", port_ranges)
        _setter("prefix_list_id", prefix_list_id)
        _setter("protocol", protocol)
        _setter("security_group_id", security_group_id)

    @property
    @pulumi.getter
    def cidr(self) -> str:
        return pulumi.get(self, "cidr")

    @property
    @pulumi.getter
    def direction(self) -> str:
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentSecurityGroupRulePortRangeResult']:
        return pulumi.get(self, "port_ranges")

    @property
    @pulumi.getter(name="prefixListId")
    def prefix_list_id(self) -> str:
        return pulumi.get(self, "prefix_list_id")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> str:
        return pulumi.get(self, "security_group_id")


@pulumi.output_type
class GetNetworkInsightsAnalysisForwardPathComponentSecurityGroupRulePortRangeResult(dict):
    def __init__(__self__, *,
                 from_: int,
                 to: int):
        GetNetworkInsightsAnalysisForwardPathComponentSecurityGroupRulePortRangeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            from_=from_,
            to=to,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             from_: Optional[int] = None,
             to: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if from_ is None and 'from' in kwargs:
            from_ = kwargs['from']
        if from_ is None:
            raise TypeError("Missing 'from_' argument")
        if to is None:
            raise TypeError("Missing 'to' argument")

        _setter("from_", from_)
        _setter("to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> int:
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> int:
        return pulumi.get(self, "to")


@pulumi.output_type
class GetNetworkInsightsAnalysisForwardPathComponentSourceVpcResult(dict):
    def __init__(__self__, *,
                 arn: str,
                 id: str,
                 name: str):
        """
        :param str arn: ARN of the selected Network Insights Analysis.
        :param str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        GetNetworkInsightsAnalysisForwardPathComponentSourceVpcResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if arn is None:
            raise TypeError("Missing 'arn' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("arn", arn)
        _setter("id", id)
        _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisForwardPathComponentSubnetResult(dict):
    def __init__(__self__, *,
                 arn: str,
                 id: str,
                 name: str):
        """
        :param str arn: ARN of the selected Network Insights Analysis.
        :param str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        GetNetworkInsightsAnalysisForwardPathComponentSubnetResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if arn is None:
            raise TypeError("Missing 'arn' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("arn", arn)
        _setter("id", id)
        _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisForwardPathComponentTransitGatewayResult(dict):
    def __init__(__self__, *,
                 arn: str,
                 id: str,
                 name: str):
        """
        :param str arn: ARN of the selected Network Insights Analysis.
        :param str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        GetNetworkInsightsAnalysisForwardPathComponentTransitGatewayResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if arn is None:
            raise TypeError("Missing 'arn' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("arn", arn)
        _setter("id", id)
        _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisForwardPathComponentTransitGatewayRouteTableRouteResult(dict):
    def __init__(__self__, *,
                 attachment_id: str,
                 destination_cidr: str,
                 prefix_list_id: str,
                 resource_id: str,
                 resource_type: str,
                 route_origin: str,
                 state: str):
        GetNetworkInsightsAnalysisForwardPathComponentTransitGatewayRouteTableRouteResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            attachment_id=attachment_id,
            destination_cidr=destination_cidr,
            prefix_list_id=prefix_list_id,
            resource_id=resource_id,
            resource_type=resource_type,
            route_origin=route_origin,
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             attachment_id: Optional[str] = None,
             destination_cidr: Optional[str] = None,
             prefix_list_id: Optional[str] = None,
             resource_id: Optional[str] = None,
             resource_type: Optional[str] = None,
             route_origin: Optional[str] = None,
             state: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if attachment_id is None and 'attachmentId' in kwargs:
            attachment_id = kwargs['attachmentId']
        if attachment_id is None:
            raise TypeError("Missing 'attachment_id' argument")
        if destination_cidr is None and 'destinationCidr' in kwargs:
            destination_cidr = kwargs['destinationCidr']
        if destination_cidr is None:
            raise TypeError("Missing 'destination_cidr' argument")
        if prefix_list_id is None and 'prefixListId' in kwargs:
            prefix_list_id = kwargs['prefixListId']
        if prefix_list_id is None:
            raise TypeError("Missing 'prefix_list_id' argument")
        if resource_id is None and 'resourceId' in kwargs:
            resource_id = kwargs['resourceId']
        if resource_id is None:
            raise TypeError("Missing 'resource_id' argument")
        if resource_type is None and 'resourceType' in kwargs:
            resource_type = kwargs['resourceType']
        if resource_type is None:
            raise TypeError("Missing 'resource_type' argument")
        if route_origin is None and 'routeOrigin' in kwargs:
            route_origin = kwargs['routeOrigin']
        if route_origin is None:
            raise TypeError("Missing 'route_origin' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")

        _setter("attachment_id", attachment_id)
        _setter("destination_cidr", destination_cidr)
        _setter("prefix_list_id", prefix_list_id)
        _setter("resource_id", resource_id)
        _setter("resource_type", resource_type)
        _setter("route_origin", route_origin)
        _setter("state", state)

    @property
    @pulumi.getter(name="attachmentId")
    def attachment_id(self) -> str:
        return pulumi.get(self, "attachment_id")

    @property
    @pulumi.getter(name="destinationCidr")
    def destination_cidr(self) -> str:
        return pulumi.get(self, "destination_cidr")

    @property
    @pulumi.getter(name="prefixListId")
    def prefix_list_id(self) -> str:
        return pulumi.get(self, "prefix_list_id")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> str:
        return pulumi.get(self, "resource_id")

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> str:
        return pulumi.get(self, "resource_type")

    @property
    @pulumi.getter(name="routeOrigin")
    def route_origin(self) -> str:
        return pulumi.get(self, "route_origin")

    @property
    @pulumi.getter
    def state(self) -> str:
        return pulumi.get(self, "state")


@pulumi.output_type
class GetNetworkInsightsAnalysisForwardPathComponentVpcResult(dict):
    def __init__(__self__, *,
                 arn: str,
                 id: str,
                 name: str):
        """
        :param str arn: ARN of the selected Network Insights Analysis.
        :param str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        GetNetworkInsightsAnalysisForwardPathComponentVpcResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if arn is None:
            raise TypeError("Missing 'arn' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("arn", arn)
        _setter("id", id)
        _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisReturnPathComponentResult(dict):
    def __init__(__self__, *,
                 acl_rules: Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentAclRuleResult'],
                 additional_details: Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentAdditionalDetailResult'],
                 attached_tos: Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentAttachedToResult'],
                 components: Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentComponentResult'],
                 destination_vpcs: Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentDestinationVpcResult'],
                 inbound_headers: Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentInboundHeaderResult'],
                 outbound_headers: Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentOutboundHeaderResult'],
                 route_table_routes: Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentRouteTableRouteResult'],
                 security_group_rules: Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentSecurityGroupRuleResult'],
                 sequence_number: int,
                 source_vpcs: Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentSourceVpcResult'],
                 subnets: Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentSubnetResult'],
                 transit_gateway_route_table_routes: Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentTransitGatewayRouteTableRouteResult'],
                 transit_gateways: Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentTransitGatewayResult'],
                 vpcs: Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentVpcResult']):
        GetNetworkInsightsAnalysisReturnPathComponentResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            acl_rules=acl_rules,
            additional_details=additional_details,
            attached_tos=attached_tos,
            components=components,
            destination_vpcs=destination_vpcs,
            inbound_headers=inbound_headers,
            outbound_headers=outbound_headers,
            route_table_routes=route_table_routes,
            security_group_rules=security_group_rules,
            sequence_number=sequence_number,
            source_vpcs=source_vpcs,
            subnets=subnets,
            transit_gateway_route_table_routes=transit_gateway_route_table_routes,
            transit_gateways=transit_gateways,
            vpcs=vpcs,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             acl_rules: Optional[Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentAclRuleResult']] = None,
             additional_details: Optional[Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentAdditionalDetailResult']] = None,
             attached_tos: Optional[Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentAttachedToResult']] = None,
             components: Optional[Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentComponentResult']] = None,
             destination_vpcs: Optional[Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentDestinationVpcResult']] = None,
             inbound_headers: Optional[Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentInboundHeaderResult']] = None,
             outbound_headers: Optional[Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentOutboundHeaderResult']] = None,
             route_table_routes: Optional[Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentRouteTableRouteResult']] = None,
             security_group_rules: Optional[Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentSecurityGroupRuleResult']] = None,
             sequence_number: Optional[int] = None,
             source_vpcs: Optional[Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentSourceVpcResult']] = None,
             subnets: Optional[Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentSubnetResult']] = None,
             transit_gateway_route_table_routes: Optional[Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentTransitGatewayRouteTableRouteResult']] = None,
             transit_gateways: Optional[Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentTransitGatewayResult']] = None,
             vpcs: Optional[Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentVpcResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if acl_rules is None and 'aclRules' in kwargs:
            acl_rules = kwargs['aclRules']
        if acl_rules is None:
            raise TypeError("Missing 'acl_rules' argument")
        if additional_details is None and 'additionalDetails' in kwargs:
            additional_details = kwargs['additionalDetails']
        if additional_details is None:
            raise TypeError("Missing 'additional_details' argument")
        if attached_tos is None and 'attachedTos' in kwargs:
            attached_tos = kwargs['attachedTos']
        if attached_tos is None:
            raise TypeError("Missing 'attached_tos' argument")
        if components is None:
            raise TypeError("Missing 'components' argument")
        if destination_vpcs is None and 'destinationVpcs' in kwargs:
            destination_vpcs = kwargs['destinationVpcs']
        if destination_vpcs is None:
            raise TypeError("Missing 'destination_vpcs' argument")
        if inbound_headers is None and 'inboundHeaders' in kwargs:
            inbound_headers = kwargs['inboundHeaders']
        if inbound_headers is None:
            raise TypeError("Missing 'inbound_headers' argument")
        if outbound_headers is None and 'outboundHeaders' in kwargs:
            outbound_headers = kwargs['outboundHeaders']
        if outbound_headers is None:
            raise TypeError("Missing 'outbound_headers' argument")
        if route_table_routes is None and 'routeTableRoutes' in kwargs:
            route_table_routes = kwargs['routeTableRoutes']
        if route_table_routes is None:
            raise TypeError("Missing 'route_table_routes' argument")
        if security_group_rules is None and 'securityGroupRules' in kwargs:
            security_group_rules = kwargs['securityGroupRules']
        if security_group_rules is None:
            raise TypeError("Missing 'security_group_rules' argument")
        if sequence_number is None and 'sequenceNumber' in kwargs:
            sequence_number = kwargs['sequenceNumber']
        if sequence_number is None:
            raise TypeError("Missing 'sequence_number' argument")
        if source_vpcs is None and 'sourceVpcs' in kwargs:
            source_vpcs = kwargs['sourceVpcs']
        if source_vpcs is None:
            raise TypeError("Missing 'source_vpcs' argument")
        if subnets is None:
            raise TypeError("Missing 'subnets' argument")
        if transit_gateway_route_table_routes is None and 'transitGatewayRouteTableRoutes' in kwargs:
            transit_gateway_route_table_routes = kwargs['transitGatewayRouteTableRoutes']
        if transit_gateway_route_table_routes is None:
            raise TypeError("Missing 'transit_gateway_route_table_routes' argument")
        if transit_gateways is None and 'transitGateways' in kwargs:
            transit_gateways = kwargs['transitGateways']
        if transit_gateways is None:
            raise TypeError("Missing 'transit_gateways' argument")
        if vpcs is None:
            raise TypeError("Missing 'vpcs' argument")

        _setter("acl_rules", acl_rules)
        _setter("additional_details", additional_details)
        _setter("attached_tos", attached_tos)
        _setter("components", components)
        _setter("destination_vpcs", destination_vpcs)
        _setter("inbound_headers", inbound_headers)
        _setter("outbound_headers", outbound_headers)
        _setter("route_table_routes", route_table_routes)
        _setter("security_group_rules", security_group_rules)
        _setter("sequence_number", sequence_number)
        _setter("source_vpcs", source_vpcs)
        _setter("subnets", subnets)
        _setter("transit_gateway_route_table_routes", transit_gateway_route_table_routes)
        _setter("transit_gateways", transit_gateways)
        _setter("vpcs", vpcs)

    @property
    @pulumi.getter(name="aclRules")
    def acl_rules(self) -> Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentAclRuleResult']:
        return pulumi.get(self, "acl_rules")

    @property
    @pulumi.getter(name="additionalDetails")
    def additional_details(self) -> Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentAdditionalDetailResult']:
        return pulumi.get(self, "additional_details")

    @property
    @pulumi.getter(name="attachedTos")
    def attached_tos(self) -> Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentAttachedToResult']:
        return pulumi.get(self, "attached_tos")

    @property
    @pulumi.getter
    def components(self) -> Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentComponentResult']:
        return pulumi.get(self, "components")

    @property
    @pulumi.getter(name="destinationVpcs")
    def destination_vpcs(self) -> Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentDestinationVpcResult']:
        return pulumi.get(self, "destination_vpcs")

    @property
    @pulumi.getter(name="inboundHeaders")
    def inbound_headers(self) -> Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentInboundHeaderResult']:
        return pulumi.get(self, "inbound_headers")

    @property
    @pulumi.getter(name="outboundHeaders")
    def outbound_headers(self) -> Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentOutboundHeaderResult']:
        return pulumi.get(self, "outbound_headers")

    @property
    @pulumi.getter(name="routeTableRoutes")
    def route_table_routes(self) -> Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentRouteTableRouteResult']:
        return pulumi.get(self, "route_table_routes")

    @property
    @pulumi.getter(name="securityGroupRules")
    def security_group_rules(self) -> Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentSecurityGroupRuleResult']:
        return pulumi.get(self, "security_group_rules")

    @property
    @pulumi.getter(name="sequenceNumber")
    def sequence_number(self) -> int:
        return pulumi.get(self, "sequence_number")

    @property
    @pulumi.getter(name="sourceVpcs")
    def source_vpcs(self) -> Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentSourceVpcResult']:
        return pulumi.get(self, "source_vpcs")

    @property
    @pulumi.getter
    def subnets(self) -> Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentSubnetResult']:
        return pulumi.get(self, "subnets")

    @property
    @pulumi.getter(name="transitGatewayRouteTableRoutes")
    def transit_gateway_route_table_routes(self) -> Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentTransitGatewayRouteTableRouteResult']:
        return pulumi.get(self, "transit_gateway_route_table_routes")

    @property
    @pulumi.getter(name="transitGateways")
    def transit_gateways(self) -> Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentTransitGatewayResult']:
        return pulumi.get(self, "transit_gateways")

    @property
    @pulumi.getter
    def vpcs(self) -> Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentVpcResult']:
        return pulumi.get(self, "vpcs")


@pulumi.output_type
class GetNetworkInsightsAnalysisReturnPathComponentAclRuleResult(dict):
    def __init__(__self__, *,
                 cidr: str,
                 egress: bool,
                 port_ranges: Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentAclRulePortRangeResult'],
                 protocol: str,
                 rule_action: str,
                 rule_number: int):
        GetNetworkInsightsAnalysisReturnPathComponentAclRuleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cidr=cidr,
            egress=egress,
            port_ranges=port_ranges,
            protocol=protocol,
            rule_action=rule_action,
            rule_number=rule_number,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cidr: Optional[str] = None,
             egress: Optional[bool] = None,
             port_ranges: Optional[Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentAclRulePortRangeResult']] = None,
             protocol: Optional[str] = None,
             rule_action: Optional[str] = None,
             rule_number: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cidr is None:
            raise TypeError("Missing 'cidr' argument")
        if egress is None:
            raise TypeError("Missing 'egress' argument")
        if port_ranges is None and 'portRanges' in kwargs:
            port_ranges = kwargs['portRanges']
        if port_ranges is None:
            raise TypeError("Missing 'port_ranges' argument")
        if protocol is None:
            raise TypeError("Missing 'protocol' argument")
        if rule_action is None and 'ruleAction' in kwargs:
            rule_action = kwargs['ruleAction']
        if rule_action is None:
            raise TypeError("Missing 'rule_action' argument")
        if rule_number is None and 'ruleNumber' in kwargs:
            rule_number = kwargs['ruleNumber']
        if rule_number is None:
            raise TypeError("Missing 'rule_number' argument")

        _setter("cidr", cidr)
        _setter("egress", egress)
        _setter("port_ranges", port_ranges)
        _setter("protocol", protocol)
        _setter("rule_action", rule_action)
        _setter("rule_number", rule_number)

    @property
    @pulumi.getter
    def cidr(self) -> str:
        return pulumi.get(self, "cidr")

    @property
    @pulumi.getter
    def egress(self) -> bool:
        return pulumi.get(self, "egress")

    @property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentAclRulePortRangeResult']:
        return pulumi.get(self, "port_ranges")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="ruleAction")
    def rule_action(self) -> str:
        return pulumi.get(self, "rule_action")

    @property
    @pulumi.getter(name="ruleNumber")
    def rule_number(self) -> int:
        return pulumi.get(self, "rule_number")


@pulumi.output_type
class GetNetworkInsightsAnalysisReturnPathComponentAclRulePortRangeResult(dict):
    def __init__(__self__, *,
                 from_: int,
                 to: int):
        GetNetworkInsightsAnalysisReturnPathComponentAclRulePortRangeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            from_=from_,
            to=to,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             from_: Optional[int] = None,
             to: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if from_ is None and 'from' in kwargs:
            from_ = kwargs['from']
        if from_ is None:
            raise TypeError("Missing 'from_' argument")
        if to is None:
            raise TypeError("Missing 'to' argument")

        _setter("from_", from_)
        _setter("to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> int:
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> int:
        return pulumi.get(self, "to")


@pulumi.output_type
class GetNetworkInsightsAnalysisReturnPathComponentAdditionalDetailResult(dict):
    def __init__(__self__, *,
                 additional_detail_type: str,
                 components: Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentAdditionalDetailComponentResult']):
        GetNetworkInsightsAnalysisReturnPathComponentAdditionalDetailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            additional_detail_type=additional_detail_type,
            components=components,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             additional_detail_type: Optional[str] = None,
             components: Optional[Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentAdditionalDetailComponentResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if additional_detail_type is None and 'additionalDetailType' in kwargs:
            additional_detail_type = kwargs['additionalDetailType']
        if additional_detail_type is None:
            raise TypeError("Missing 'additional_detail_type' argument")
        if components is None:
            raise TypeError("Missing 'components' argument")

        _setter("additional_detail_type", additional_detail_type)
        _setter("components", components)

    @property
    @pulumi.getter(name="additionalDetailType")
    def additional_detail_type(self) -> str:
        return pulumi.get(self, "additional_detail_type")

    @property
    @pulumi.getter
    def components(self) -> Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentAdditionalDetailComponentResult']:
        return pulumi.get(self, "components")


@pulumi.output_type
class GetNetworkInsightsAnalysisReturnPathComponentAdditionalDetailComponentResult(dict):
    def __init__(__self__, *,
                 arn: str,
                 id: str,
                 name: str):
        """
        :param str arn: ARN of the selected Network Insights Analysis.
        :param str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        GetNetworkInsightsAnalysisReturnPathComponentAdditionalDetailComponentResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if arn is None:
            raise TypeError("Missing 'arn' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("arn", arn)
        _setter("id", id)
        _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisReturnPathComponentAttachedToResult(dict):
    def __init__(__self__, *,
                 arn: str,
                 id: str,
                 name: str):
        """
        :param str arn: ARN of the selected Network Insights Analysis.
        :param str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        GetNetworkInsightsAnalysisReturnPathComponentAttachedToResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if arn is None:
            raise TypeError("Missing 'arn' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("arn", arn)
        _setter("id", id)
        _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisReturnPathComponentComponentResult(dict):
    def __init__(__self__, *,
                 arn: str,
                 id: str,
                 name: str):
        """
        :param str arn: ARN of the selected Network Insights Analysis.
        :param str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        GetNetworkInsightsAnalysisReturnPathComponentComponentResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if arn is None:
            raise TypeError("Missing 'arn' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("arn", arn)
        _setter("id", id)
        _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisReturnPathComponentDestinationVpcResult(dict):
    def __init__(__self__, *,
                 arn: str,
                 id: str,
                 name: str):
        """
        :param str arn: ARN of the selected Network Insights Analysis.
        :param str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        GetNetworkInsightsAnalysisReturnPathComponentDestinationVpcResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if arn is None:
            raise TypeError("Missing 'arn' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("arn", arn)
        _setter("id", id)
        _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisReturnPathComponentInboundHeaderResult(dict):
    def __init__(__self__, *,
                 destination_addresses: Sequence[str],
                 destination_port_ranges: Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentInboundHeaderDestinationPortRangeResult'],
                 protocol: str,
                 source_addresses: Sequence[str],
                 source_port_ranges: Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentInboundHeaderSourcePortRangeResult']):
        GetNetworkInsightsAnalysisReturnPathComponentInboundHeaderResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination_addresses=destination_addresses,
            destination_port_ranges=destination_port_ranges,
            protocol=protocol,
            source_addresses=source_addresses,
            source_port_ranges=source_port_ranges,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination_addresses: Optional[Sequence[str]] = None,
             destination_port_ranges: Optional[Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentInboundHeaderDestinationPortRangeResult']] = None,
             protocol: Optional[str] = None,
             source_addresses: Optional[Sequence[str]] = None,
             source_port_ranges: Optional[Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentInboundHeaderSourcePortRangeResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if destination_addresses is None and 'destinationAddresses' in kwargs:
            destination_addresses = kwargs['destinationAddresses']
        if destination_addresses is None:
            raise TypeError("Missing 'destination_addresses' argument")
        if destination_port_ranges is None and 'destinationPortRanges' in kwargs:
            destination_port_ranges = kwargs['destinationPortRanges']
        if destination_port_ranges is None:
            raise TypeError("Missing 'destination_port_ranges' argument")
        if protocol is None:
            raise TypeError("Missing 'protocol' argument")
        if source_addresses is None and 'sourceAddresses' in kwargs:
            source_addresses = kwargs['sourceAddresses']
        if source_addresses is None:
            raise TypeError("Missing 'source_addresses' argument")
        if source_port_ranges is None and 'sourcePortRanges' in kwargs:
            source_port_ranges = kwargs['sourcePortRanges']
        if source_port_ranges is None:
            raise TypeError("Missing 'source_port_ranges' argument")

        _setter("destination_addresses", destination_addresses)
        _setter("destination_port_ranges", destination_port_ranges)
        _setter("protocol", protocol)
        _setter("source_addresses", source_addresses)
        _setter("source_port_ranges", source_port_ranges)

    @property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Sequence[str]:
        return pulumi.get(self, "destination_addresses")

    @property
    @pulumi.getter(name="destinationPortRanges")
    def destination_port_ranges(self) -> Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentInboundHeaderDestinationPortRangeResult']:
        return pulumi.get(self, "destination_port_ranges")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Sequence[str]:
        return pulumi.get(self, "source_addresses")

    @property
    @pulumi.getter(name="sourcePortRanges")
    def source_port_ranges(self) -> Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentInboundHeaderSourcePortRangeResult']:
        return pulumi.get(self, "source_port_ranges")


@pulumi.output_type
class GetNetworkInsightsAnalysisReturnPathComponentInboundHeaderDestinationPortRangeResult(dict):
    def __init__(__self__, *,
                 from_: int,
                 to: int):
        GetNetworkInsightsAnalysisReturnPathComponentInboundHeaderDestinationPortRangeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            from_=from_,
            to=to,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             from_: Optional[int] = None,
             to: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if from_ is None and 'from' in kwargs:
            from_ = kwargs['from']
        if from_ is None:
            raise TypeError("Missing 'from_' argument")
        if to is None:
            raise TypeError("Missing 'to' argument")

        _setter("from_", from_)
        _setter("to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> int:
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> int:
        return pulumi.get(self, "to")


@pulumi.output_type
class GetNetworkInsightsAnalysisReturnPathComponentInboundHeaderSourcePortRangeResult(dict):
    def __init__(__self__, *,
                 from_: int,
                 to: int):
        GetNetworkInsightsAnalysisReturnPathComponentInboundHeaderSourcePortRangeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            from_=from_,
            to=to,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             from_: Optional[int] = None,
             to: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if from_ is None and 'from' in kwargs:
            from_ = kwargs['from']
        if from_ is None:
            raise TypeError("Missing 'from_' argument")
        if to is None:
            raise TypeError("Missing 'to' argument")

        _setter("from_", from_)
        _setter("to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> int:
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> int:
        return pulumi.get(self, "to")


@pulumi.output_type
class GetNetworkInsightsAnalysisReturnPathComponentOutboundHeaderResult(dict):
    def __init__(__self__, *,
                 destination_addresses: Sequence[str],
                 destination_port_ranges: Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentOutboundHeaderDestinationPortRangeResult'],
                 protocol: str,
                 source_addresses: Sequence[str],
                 source_port_ranges: Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentOutboundHeaderSourcePortRangeResult']):
        GetNetworkInsightsAnalysisReturnPathComponentOutboundHeaderResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination_addresses=destination_addresses,
            destination_port_ranges=destination_port_ranges,
            protocol=protocol,
            source_addresses=source_addresses,
            source_port_ranges=source_port_ranges,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination_addresses: Optional[Sequence[str]] = None,
             destination_port_ranges: Optional[Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentOutboundHeaderDestinationPortRangeResult']] = None,
             protocol: Optional[str] = None,
             source_addresses: Optional[Sequence[str]] = None,
             source_port_ranges: Optional[Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentOutboundHeaderSourcePortRangeResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if destination_addresses is None and 'destinationAddresses' in kwargs:
            destination_addresses = kwargs['destinationAddresses']
        if destination_addresses is None:
            raise TypeError("Missing 'destination_addresses' argument")
        if destination_port_ranges is None and 'destinationPortRanges' in kwargs:
            destination_port_ranges = kwargs['destinationPortRanges']
        if destination_port_ranges is None:
            raise TypeError("Missing 'destination_port_ranges' argument")
        if protocol is None:
            raise TypeError("Missing 'protocol' argument")
        if source_addresses is None and 'sourceAddresses' in kwargs:
            source_addresses = kwargs['sourceAddresses']
        if source_addresses is None:
            raise TypeError("Missing 'source_addresses' argument")
        if source_port_ranges is None and 'sourcePortRanges' in kwargs:
            source_port_ranges = kwargs['sourcePortRanges']
        if source_port_ranges is None:
            raise TypeError("Missing 'source_port_ranges' argument")

        _setter("destination_addresses", destination_addresses)
        _setter("destination_port_ranges", destination_port_ranges)
        _setter("protocol", protocol)
        _setter("source_addresses", source_addresses)
        _setter("source_port_ranges", source_port_ranges)

    @property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Sequence[str]:
        return pulumi.get(self, "destination_addresses")

    @property
    @pulumi.getter(name="destinationPortRanges")
    def destination_port_ranges(self) -> Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentOutboundHeaderDestinationPortRangeResult']:
        return pulumi.get(self, "destination_port_ranges")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Sequence[str]:
        return pulumi.get(self, "source_addresses")

    @property
    @pulumi.getter(name="sourcePortRanges")
    def source_port_ranges(self) -> Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentOutboundHeaderSourcePortRangeResult']:
        return pulumi.get(self, "source_port_ranges")


@pulumi.output_type
class GetNetworkInsightsAnalysisReturnPathComponentOutboundHeaderDestinationPortRangeResult(dict):
    def __init__(__self__, *,
                 from_: int,
                 to: int):
        GetNetworkInsightsAnalysisReturnPathComponentOutboundHeaderDestinationPortRangeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            from_=from_,
            to=to,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             from_: Optional[int] = None,
             to: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if from_ is None and 'from' in kwargs:
            from_ = kwargs['from']
        if from_ is None:
            raise TypeError("Missing 'from_' argument")
        if to is None:
            raise TypeError("Missing 'to' argument")

        _setter("from_", from_)
        _setter("to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> int:
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> int:
        return pulumi.get(self, "to")


@pulumi.output_type
class GetNetworkInsightsAnalysisReturnPathComponentOutboundHeaderSourcePortRangeResult(dict):
    def __init__(__self__, *,
                 from_: int,
                 to: int):
        GetNetworkInsightsAnalysisReturnPathComponentOutboundHeaderSourcePortRangeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            from_=from_,
            to=to,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             from_: Optional[int] = None,
             to: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if from_ is None and 'from' in kwargs:
            from_ = kwargs['from']
        if from_ is None:
            raise TypeError("Missing 'from_' argument")
        if to is None:
            raise TypeError("Missing 'to' argument")

        _setter("from_", from_)
        _setter("to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> int:
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> int:
        return pulumi.get(self, "to")


@pulumi.output_type
class GetNetworkInsightsAnalysisReturnPathComponentRouteTableRouteResult(dict):
    def __init__(__self__, *,
                 destination_cidr: str,
                 destination_prefix_list_id: str,
                 egress_only_internet_gateway_id: str,
                 gateway_id: str,
                 instance_id: str,
                 nat_gateway_id: str,
                 network_interface_id: str,
                 origin: str,
                 transit_gateway_id: str,
                 vpc_peering_connection_id: str):
        GetNetworkInsightsAnalysisReturnPathComponentRouteTableRouteResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination_cidr=destination_cidr,
            destination_prefix_list_id=destination_prefix_list_id,
            egress_only_internet_gateway_id=egress_only_internet_gateway_id,
            gateway_id=gateway_id,
            instance_id=instance_id,
            nat_gateway_id=nat_gateway_id,
            network_interface_id=network_interface_id,
            origin=origin,
            transit_gateway_id=transit_gateway_id,
            vpc_peering_connection_id=vpc_peering_connection_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination_cidr: Optional[str] = None,
             destination_prefix_list_id: Optional[str] = None,
             egress_only_internet_gateway_id: Optional[str] = None,
             gateway_id: Optional[str] = None,
             instance_id: Optional[str] = None,
             nat_gateway_id: Optional[str] = None,
             network_interface_id: Optional[str] = None,
             origin: Optional[str] = None,
             transit_gateway_id: Optional[str] = None,
             vpc_peering_connection_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if destination_cidr is None and 'destinationCidr' in kwargs:
            destination_cidr = kwargs['destinationCidr']
        if destination_cidr is None:
            raise TypeError("Missing 'destination_cidr' argument")
        if destination_prefix_list_id is None and 'destinationPrefixListId' in kwargs:
            destination_prefix_list_id = kwargs['destinationPrefixListId']
        if destination_prefix_list_id is None:
            raise TypeError("Missing 'destination_prefix_list_id' argument")
        if egress_only_internet_gateway_id is None and 'egressOnlyInternetGatewayId' in kwargs:
            egress_only_internet_gateway_id = kwargs['egressOnlyInternetGatewayId']
        if egress_only_internet_gateway_id is None:
            raise TypeError("Missing 'egress_only_internet_gateway_id' argument")
        if gateway_id is None and 'gatewayId' in kwargs:
            gateway_id = kwargs['gatewayId']
        if gateway_id is None:
            raise TypeError("Missing 'gateway_id' argument")
        if instance_id is None and 'instanceId' in kwargs:
            instance_id = kwargs['instanceId']
        if instance_id is None:
            raise TypeError("Missing 'instance_id' argument")
        if nat_gateway_id is None and 'natGatewayId' in kwargs:
            nat_gateway_id = kwargs['natGatewayId']
        if nat_gateway_id is None:
            raise TypeError("Missing 'nat_gateway_id' argument")
        if network_interface_id is None and 'networkInterfaceId' in kwargs:
            network_interface_id = kwargs['networkInterfaceId']
        if network_interface_id is None:
            raise TypeError("Missing 'network_interface_id' argument")
        if origin is None:
            raise TypeError("Missing 'origin' argument")
        if transit_gateway_id is None and 'transitGatewayId' in kwargs:
            transit_gateway_id = kwargs['transitGatewayId']
        if transit_gateway_id is None:
            raise TypeError("Missing 'transit_gateway_id' argument")
        if vpc_peering_connection_id is None and 'vpcPeeringConnectionId' in kwargs:
            vpc_peering_connection_id = kwargs['vpcPeeringConnectionId']
        if vpc_peering_connection_id is None:
            raise TypeError("Missing 'vpc_peering_connection_id' argument")

        _setter("destination_cidr", destination_cidr)
        _setter("destination_prefix_list_id", destination_prefix_list_id)
        _setter("egress_only_internet_gateway_id", egress_only_internet_gateway_id)
        _setter("gateway_id", gateway_id)
        _setter("instance_id", instance_id)
        _setter("nat_gateway_id", nat_gateway_id)
        _setter("network_interface_id", network_interface_id)
        _setter("origin", origin)
        _setter("transit_gateway_id", transit_gateway_id)
        _setter("vpc_peering_connection_id", vpc_peering_connection_id)

    @property
    @pulumi.getter(name="destinationCidr")
    def destination_cidr(self) -> str:
        return pulumi.get(self, "destination_cidr")

    @property
    @pulumi.getter(name="destinationPrefixListId")
    def destination_prefix_list_id(self) -> str:
        return pulumi.get(self, "destination_prefix_list_id")

    @property
    @pulumi.getter(name="egressOnlyInternetGatewayId")
    def egress_only_internet_gateway_id(self) -> str:
        return pulumi.get(self, "egress_only_internet_gateway_id")

    @property
    @pulumi.getter(name="gatewayId")
    def gateway_id(self) -> str:
        return pulumi.get(self, "gateway_id")

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> str:
        return pulumi.get(self, "instance_id")

    @property
    @pulumi.getter(name="natGatewayId")
    def nat_gateway_id(self) -> str:
        return pulumi.get(self, "nat_gateway_id")

    @property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> str:
        return pulumi.get(self, "network_interface_id")

    @property
    @pulumi.getter
    def origin(self) -> str:
        return pulumi.get(self, "origin")

    @property
    @pulumi.getter(name="transitGatewayId")
    def transit_gateway_id(self) -> str:
        return pulumi.get(self, "transit_gateway_id")

    @property
    @pulumi.getter(name="vpcPeeringConnectionId")
    def vpc_peering_connection_id(self) -> str:
        return pulumi.get(self, "vpc_peering_connection_id")


@pulumi.output_type
class GetNetworkInsightsAnalysisReturnPathComponentSecurityGroupRuleResult(dict):
    def __init__(__self__, *,
                 cidr: str,
                 direction: str,
                 port_ranges: Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentSecurityGroupRulePortRangeResult'],
                 prefix_list_id: str,
                 protocol: str,
                 security_group_id: str):
        GetNetworkInsightsAnalysisReturnPathComponentSecurityGroupRuleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cidr=cidr,
            direction=direction,
            port_ranges=port_ranges,
            prefix_list_id=prefix_list_id,
            protocol=protocol,
            security_group_id=security_group_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cidr: Optional[str] = None,
             direction: Optional[str] = None,
             port_ranges: Optional[Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentSecurityGroupRulePortRangeResult']] = None,
             prefix_list_id: Optional[str] = None,
             protocol: Optional[str] = None,
             security_group_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cidr is None:
            raise TypeError("Missing 'cidr' argument")
        if direction is None:
            raise TypeError("Missing 'direction' argument")
        if port_ranges is None and 'portRanges' in kwargs:
            port_ranges = kwargs['portRanges']
        if port_ranges is None:
            raise TypeError("Missing 'port_ranges' argument")
        if prefix_list_id is None and 'prefixListId' in kwargs:
            prefix_list_id = kwargs['prefixListId']
        if prefix_list_id is None:
            raise TypeError("Missing 'prefix_list_id' argument")
        if protocol is None:
            raise TypeError("Missing 'protocol' argument")
        if security_group_id is None and 'securityGroupId' in kwargs:
            security_group_id = kwargs['securityGroupId']
        if security_group_id is None:
            raise TypeError("Missing 'security_group_id' argument")

        _setter("cidr", cidr)
        _setter("direction", direction)
        _setter("port_ranges", port_ranges)
        _setter("prefix_list_id", prefix_list_id)
        _setter("protocol", protocol)
        _setter("security_group_id", security_group_id)

    @property
    @pulumi.getter
    def cidr(self) -> str:
        return pulumi.get(self, "cidr")

    @property
    @pulumi.getter
    def direction(self) -> str:
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentSecurityGroupRulePortRangeResult']:
        return pulumi.get(self, "port_ranges")

    @property
    @pulumi.getter(name="prefixListId")
    def prefix_list_id(self) -> str:
        return pulumi.get(self, "prefix_list_id")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> str:
        return pulumi.get(self, "security_group_id")


@pulumi.output_type
class GetNetworkInsightsAnalysisReturnPathComponentSecurityGroupRulePortRangeResult(dict):
    def __init__(__self__, *,
                 from_: int,
                 to: int):
        GetNetworkInsightsAnalysisReturnPathComponentSecurityGroupRulePortRangeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            from_=from_,
            to=to,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             from_: Optional[int] = None,
             to: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if from_ is None and 'from' in kwargs:
            from_ = kwargs['from']
        if from_ is None:
            raise TypeError("Missing 'from_' argument")
        if to is None:
            raise TypeError("Missing 'to' argument")

        _setter("from_", from_)
        _setter("to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> int:
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> int:
        return pulumi.get(self, "to")


@pulumi.output_type
class GetNetworkInsightsAnalysisReturnPathComponentSourceVpcResult(dict):
    def __init__(__self__, *,
                 arn: str,
                 id: str,
                 name: str):
        """
        :param str arn: ARN of the selected Network Insights Analysis.
        :param str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        GetNetworkInsightsAnalysisReturnPathComponentSourceVpcResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if arn is None:
            raise TypeError("Missing 'arn' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("arn", arn)
        _setter("id", id)
        _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisReturnPathComponentSubnetResult(dict):
    def __init__(__self__, *,
                 arn: str,
                 id: str,
                 name: str):
        """
        :param str arn: ARN of the selected Network Insights Analysis.
        :param str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        GetNetworkInsightsAnalysisReturnPathComponentSubnetResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if arn is None:
            raise TypeError("Missing 'arn' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("arn", arn)
        _setter("id", id)
        _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisReturnPathComponentTransitGatewayResult(dict):
    def __init__(__self__, *,
                 arn: str,
                 id: str,
                 name: str):
        """
        :param str arn: ARN of the selected Network Insights Analysis.
        :param str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        GetNetworkInsightsAnalysisReturnPathComponentTransitGatewayResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if arn is None:
            raise TypeError("Missing 'arn' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("arn", arn)
        _setter("id", id)
        _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisReturnPathComponentTransitGatewayRouteTableRouteResult(dict):
    def __init__(__self__, *,
                 attachment_id: str,
                 destination_cidr: str,
                 prefix_list_id: str,
                 resource_id: str,
                 resource_type: str,
                 route_origin: str,
                 state: str):
        GetNetworkInsightsAnalysisReturnPathComponentTransitGatewayRouteTableRouteResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            attachment_id=attachment_id,
            destination_cidr=destination_cidr,
            prefix_list_id=prefix_list_id,
            resource_id=resource_id,
            resource_type=resource_type,
            route_origin=route_origin,
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             attachment_id: Optional[str] = None,
             destination_cidr: Optional[str] = None,
             prefix_list_id: Optional[str] = None,
             resource_id: Optional[str] = None,
             resource_type: Optional[str] = None,
             route_origin: Optional[str] = None,
             state: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if attachment_id is None and 'attachmentId' in kwargs:
            attachment_id = kwargs['attachmentId']
        if attachment_id is None:
            raise TypeError("Missing 'attachment_id' argument")
        if destination_cidr is None and 'destinationCidr' in kwargs:
            destination_cidr = kwargs['destinationCidr']
        if destination_cidr is None:
            raise TypeError("Missing 'destination_cidr' argument")
        if prefix_list_id is None and 'prefixListId' in kwargs:
            prefix_list_id = kwargs['prefixListId']
        if prefix_list_id is None:
            raise TypeError("Missing 'prefix_list_id' argument")
        if resource_id is None and 'resourceId' in kwargs:
            resource_id = kwargs['resourceId']
        if resource_id is None:
            raise TypeError("Missing 'resource_id' argument")
        if resource_type is None and 'resourceType' in kwargs:
            resource_type = kwargs['resourceType']
        if resource_type is None:
            raise TypeError("Missing 'resource_type' argument")
        if route_origin is None and 'routeOrigin' in kwargs:
            route_origin = kwargs['routeOrigin']
        if route_origin is None:
            raise TypeError("Missing 'route_origin' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")

        _setter("attachment_id", attachment_id)
        _setter("destination_cidr", destination_cidr)
        _setter("prefix_list_id", prefix_list_id)
        _setter("resource_id", resource_id)
        _setter("resource_type", resource_type)
        _setter("route_origin", route_origin)
        _setter("state", state)

    @property
    @pulumi.getter(name="attachmentId")
    def attachment_id(self) -> str:
        return pulumi.get(self, "attachment_id")

    @property
    @pulumi.getter(name="destinationCidr")
    def destination_cidr(self) -> str:
        return pulumi.get(self, "destination_cidr")

    @property
    @pulumi.getter(name="prefixListId")
    def prefix_list_id(self) -> str:
        return pulumi.get(self, "prefix_list_id")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> str:
        return pulumi.get(self, "resource_id")

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> str:
        return pulumi.get(self, "resource_type")

    @property
    @pulumi.getter(name="routeOrigin")
    def route_origin(self) -> str:
        return pulumi.get(self, "route_origin")

    @property
    @pulumi.getter
    def state(self) -> str:
        return pulumi.get(self, "state")


@pulumi.output_type
class GetNetworkInsightsAnalysisReturnPathComponentVpcResult(dict):
    def __init__(__self__, *,
                 arn: str,
                 id: str,
                 name: str):
        """
        :param str arn: ARN of the selected Network Insights Analysis.
        :param str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        GetNetworkInsightsAnalysisReturnPathComponentVpcResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if arn is None:
            raise TypeError("Missing 'arn' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("arn", arn)
        _setter("id", id)
        _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        ARN of the selected Network Insights Analysis.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsPathFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsPaths`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsPaths.html) API Reference.
        :param Sequence[str] values: Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
        """
        GetNetworkInsightsPathFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsPaths`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsPaths.html) API Reference.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetNetworkInterfaceAssociationResult(dict):
    def __init__(__self__, *,
                 allocation_id: str,
                 association_id: str,
                 carrier_ip: str,
                 customer_owned_ip: str,
                 ip_owner_id: str,
                 public_dns_name: str,
                 public_ip: str):
        """
        :param str allocation_id: Allocation ID.
        :param str association_id: Association ID.
        :param str carrier_ip: Carrier IP address associated with the network interface. This attribute is only set when the network interface is in a subnet which is associated with a Wavelength Zone.
        :param str customer_owned_ip: Customer-owned IP address.
        :param str ip_owner_id: ID of the Elastic IP address owner.
        :param str public_dns_name: Public DNS name.
        :param str public_ip: Address of the Elastic IP address bound to the network interface.
        """
        GetNetworkInterfaceAssociationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allocation_id=allocation_id,
            association_id=association_id,
            carrier_ip=carrier_ip,
            customer_owned_ip=customer_owned_ip,
            ip_owner_id=ip_owner_id,
            public_dns_name=public_dns_name,
            public_ip=public_ip,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allocation_id: Optional[str] = None,
             association_id: Optional[str] = None,
             carrier_ip: Optional[str] = None,
             customer_owned_ip: Optional[str] = None,
             ip_owner_id: Optional[str] = None,
             public_dns_name: Optional[str] = None,
             public_ip: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if allocation_id is None and 'allocationId' in kwargs:
            allocation_id = kwargs['allocationId']
        if allocation_id is None:
            raise TypeError("Missing 'allocation_id' argument")
        if association_id is None and 'associationId' in kwargs:
            association_id = kwargs['associationId']
        if association_id is None:
            raise TypeError("Missing 'association_id' argument")
        if carrier_ip is None and 'carrierIp' in kwargs:
            carrier_ip = kwargs['carrierIp']
        if carrier_ip is None:
            raise TypeError("Missing 'carrier_ip' argument")
        if customer_owned_ip is None and 'customerOwnedIp' in kwargs:
            customer_owned_ip = kwargs['customerOwnedIp']
        if customer_owned_ip is None:
            raise TypeError("Missing 'customer_owned_ip' argument")
        if ip_owner_id is None and 'ipOwnerId' in kwargs:
            ip_owner_id = kwargs['ipOwnerId']
        if ip_owner_id is None:
            raise TypeError("Missing 'ip_owner_id' argument")
        if public_dns_name is None and 'publicDnsName' in kwargs:
            public_dns_name = kwargs['publicDnsName']
        if public_dns_name is None:
            raise TypeError("Missing 'public_dns_name' argument")
        if public_ip is None and 'publicIp' in kwargs:
            public_ip = kwargs['publicIp']
        if public_ip is None:
            raise TypeError("Missing 'public_ip' argument")

        _setter("allocation_id", allocation_id)
        _setter("association_id", association_id)
        _setter("carrier_ip", carrier_ip)
        _setter("customer_owned_ip", customer_owned_ip)
        _setter("ip_owner_id", ip_owner_id)
        _setter("public_dns_name", public_dns_name)
        _setter("public_ip", public_ip)

    @property
    @pulumi.getter(name="allocationId")
    def allocation_id(self) -> str:
        """
        Allocation ID.
        """
        return pulumi.get(self, "allocation_id")

    @property
    @pulumi.getter(name="associationId")
    def association_id(self) -> str:
        """
        Association ID.
        """
        return pulumi.get(self, "association_id")

    @property
    @pulumi.getter(name="carrierIp")
    def carrier_ip(self) -> str:
        """
        Carrier IP address associated with the network interface. This attribute is only set when the network interface is in a subnet which is associated with a Wavelength Zone.
        """
        return pulumi.get(self, "carrier_ip")

    @property
    @pulumi.getter(name="customerOwnedIp")
    def customer_owned_ip(self) -> str:
        """
        Customer-owned IP address.
        """
        return pulumi.get(self, "customer_owned_ip")

    @property
    @pulumi.getter(name="ipOwnerId")
    def ip_owner_id(self) -> str:
        """
        ID of the Elastic IP address owner.
        """
        return pulumi.get(self, "ip_owner_id")

    @property
    @pulumi.getter(name="publicDnsName")
    def public_dns_name(self) -> str:
        """
        Public DNS name.
        """
        return pulumi.get(self, "public_dns_name")

    @property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> str:
        """
        Address of the Elastic IP address bound to the network interface.
        """
        return pulumi.get(self, "public_ip")


@pulumi.output_type
class GetNetworkInterfaceAttachmentResult(dict):
    def __init__(__self__, *,
                 attachment_id: str,
                 device_index: int,
                 instance_id: str,
                 instance_owner_id: str):
        GetNetworkInterfaceAttachmentResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            attachment_id=attachment_id,
            device_index=device_index,
            instance_id=instance_id,
            instance_owner_id=instance_owner_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             attachment_id: Optional[str] = None,
             device_index: Optional[int] = None,
             instance_id: Optional[str] = None,
             instance_owner_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if attachment_id is None and 'attachmentId' in kwargs:
            attachment_id = kwargs['attachmentId']
        if attachment_id is None:
            raise TypeError("Missing 'attachment_id' argument")
        if device_index is None and 'deviceIndex' in kwargs:
            device_index = kwargs['deviceIndex']
        if device_index is None:
            raise TypeError("Missing 'device_index' argument")
        if instance_id is None and 'instanceId' in kwargs:
            instance_id = kwargs['instanceId']
        if instance_id is None:
            raise TypeError("Missing 'instance_id' argument")
        if instance_owner_id is None and 'instanceOwnerId' in kwargs:
            instance_owner_id = kwargs['instanceOwnerId']
        if instance_owner_id is None:
            raise TypeError("Missing 'instance_owner_id' argument")

        _setter("attachment_id", attachment_id)
        _setter("device_index", device_index)
        _setter("instance_id", instance_id)
        _setter("instance_owner_id", instance_owner_id)

    @property
    @pulumi.getter(name="attachmentId")
    def attachment_id(self) -> str:
        return pulumi.get(self, "attachment_id")

    @property
    @pulumi.getter(name="deviceIndex")
    def device_index(self) -> int:
        return pulumi.get(self, "device_index")

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> str:
        return pulumi.get(self, "instance_id")

    @property
    @pulumi.getter(name="instanceOwnerId")
    def instance_owner_id(self) -> str:
        return pulumi.get(self, "instance_owner_id")


@pulumi.output_type
class GetNetworkInterfaceFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        GetNetworkInterfaceFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetNetworkInterfacesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Name of the field to filter by, as defined by
               [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInterfaces.html).
        :param Sequence[str] values: Set of values that are accepted for the given field.
        """
        GetNetworkInterfacesFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the field to filter by, as defined by
        [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInterfaces.html).
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Set of values that are accepted for the given field.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetPrefixListFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Name of the filter field. Valid values can be found in the [EC2 DescribePrefixLists API Reference](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribePrefixLists.html).
        :param Sequence[str] values: Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
        """
        GetPrefixListFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the filter field. Valid values can be found in the [EC2 DescribePrefixLists API Reference](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribePrefixLists.html).
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetPublicIpv4PoolPoolAddressRangeResult(dict):
    def __init__(__self__, *,
                 address_count: int,
                 available_address_count: int,
                 first_address: str,
                 last_address: str):
        """
        :param int address_count: Number of addresses in the range.
        :param int available_address_count: Number of available addresses in the range.
        :param str first_address: First address in the range.
        :param str last_address: Last address in the range.
        """
        GetPublicIpv4PoolPoolAddressRangeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            address_count=address_count,
            available_address_count=available_address_count,
            first_address=first_address,
            last_address=last_address,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             address_count: Optional[int] = None,
             available_address_count: Optional[int] = None,
             first_address: Optional[str] = None,
             last_address: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if address_count is None and 'addressCount' in kwargs:
            address_count = kwargs['addressCount']
        if address_count is None:
            raise TypeError("Missing 'address_count' argument")
        if available_address_count is None and 'availableAddressCount' in kwargs:
            available_address_count = kwargs['availableAddressCount']
        if available_address_count is None:
            raise TypeError("Missing 'available_address_count' argument")
        if first_address is None and 'firstAddress' in kwargs:
            first_address = kwargs['firstAddress']
        if first_address is None:
            raise TypeError("Missing 'first_address' argument")
        if last_address is None and 'lastAddress' in kwargs:
            last_address = kwargs['lastAddress']
        if last_address is None:
            raise TypeError("Missing 'last_address' argument")

        _setter("address_count", address_count)
        _setter("available_address_count", available_address_count)
        _setter("first_address", first_address)
        _setter("last_address", last_address)

    @property
    @pulumi.getter(name="addressCount")
    def address_count(self) -> int:
        """
        Number of addresses in the range.
        """
        return pulumi.get(self, "address_count")

    @property
    @pulumi.getter(name="availableAddressCount")
    def available_address_count(self) -> int:
        """
        Number of available addresses in the range.
        """
        return pulumi.get(self, "available_address_count")

    @property
    @pulumi.getter(name="firstAddress")
    def first_address(self) -> str:
        """
        First address in the range.
        """
        return pulumi.get(self, "first_address")

    @property
    @pulumi.getter(name="lastAddress")
    def last_address(self) -> str:
        """
        Last address in the range.
        """
        return pulumi.get(self, "last_address")


@pulumi.output_type
class GetPublicIpv4PoolsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Name of the field to filter by, as defined by [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribePublicIpv4Pools.html).
        :param Sequence[str] values: Set of values that are accepted for the given field. Pool IDs will be selected if any one of the given values match.
        """
        GetPublicIpv4PoolsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the field to filter by, as defined by [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribePublicIpv4Pools.html).
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Set of values that are accepted for the given field. Pool IDs will be selected if any one of the given values match.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetRouteTableAssociationResult(dict):
    def __init__(__self__, *,
                 gateway_id: str,
                 main: bool,
                 route_table_association_id: str,
                 route_table_id: str,
                 subnet_id: str):
        """
        :param str gateway_id: ID of an Internet Gateway or Virtual Private Gateway which is connected to the Route Table (not exported if not passed as a parameter).
        :param bool main: Whether the association is due to the main route table.
        :param str route_table_association_id: Association ID.
        :param str route_table_id: ID of the specific Route Table to retrieve.
        :param str subnet_id: ID of a Subnet which is connected to the Route Table (not exported if not passed as a parameter).
        """
        GetRouteTableAssociationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            gateway_id=gateway_id,
            main=main,
            route_table_association_id=route_table_association_id,
            route_table_id=route_table_id,
            subnet_id=subnet_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             gateway_id: Optional[str] = None,
             main: Optional[bool] = None,
             route_table_association_id: Optional[str] = None,
             route_table_id: Optional[str] = None,
             subnet_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if gateway_id is None and 'gatewayId' in kwargs:
            gateway_id = kwargs['gatewayId']
        if gateway_id is None:
            raise TypeError("Missing 'gateway_id' argument")
        if main is None:
            raise TypeError("Missing 'main' argument")
        if route_table_association_id is None and 'routeTableAssociationId' in kwargs:
            route_table_association_id = kwargs['routeTableAssociationId']
        if route_table_association_id is None:
            raise TypeError("Missing 'route_table_association_id' argument")
        if route_table_id is None and 'routeTableId' in kwargs:
            route_table_id = kwargs['routeTableId']
        if route_table_id is None:
            raise TypeError("Missing 'route_table_id' argument")
        if subnet_id is None and 'subnetId' in kwargs:
            subnet_id = kwargs['subnetId']
        if subnet_id is None:
            raise TypeError("Missing 'subnet_id' argument")

        _setter("gateway_id", gateway_id)
        _setter("main", main)
        _setter("route_table_association_id", route_table_association_id)
        _setter("route_table_id", route_table_id)
        _setter("subnet_id", subnet_id)

    @property
    @pulumi.getter(name="gatewayId")
    def gateway_id(self) -> str:
        """
        ID of an Internet Gateway or Virtual Private Gateway which is connected to the Route Table (not exported if not passed as a parameter).
        """
        return pulumi.get(self, "gateway_id")

    @property
    @pulumi.getter
    def main(self) -> bool:
        """
        Whether the association is due to the main route table.
        """
        return pulumi.get(self, "main")

    @property
    @pulumi.getter(name="routeTableAssociationId")
    def route_table_association_id(self) -> str:
        """
        Association ID.
        """
        return pulumi.get(self, "route_table_association_id")

    @property
    @pulumi.getter(name="routeTableId")
    def route_table_id(self) -> str:
        """
        ID of the specific Route Table to retrieve.
        """
        return pulumi.get(self, "route_table_id")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        """
        ID of a Subnet which is connected to the Route Table (not exported if not passed as a parameter).
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class GetRouteTableFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Name of the field to filter by, as defined by [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeRouteTables.html).
        :param Sequence[str] values: Set of values that are accepted for the given field. A Route Table will be selected if any one of the given values matches.
        """
        GetRouteTableFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the field to filter by, as defined by [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeRouteTables.html).
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Set of values that are accepted for the given field. A Route Table will be selected if any one of the given values matches.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetRouteTableRouteResult(dict):
    def __init__(__self__, *,
                 carrier_gateway_id: str,
                 cidr_block: str,
                 core_network_arn: str,
                 destination_prefix_list_id: str,
                 egress_only_gateway_id: str,
                 gateway_id: str,
                 instance_id: str,
                 ipv6_cidr_block: str,
                 local_gateway_id: str,
                 nat_gateway_id: str,
                 network_interface_id: str,
                 transit_gateway_id: str,
                 vpc_endpoint_id: str,
                 vpc_peering_connection_id: str):
        """
        :param str carrier_gateway_id: ID of the Carrier Gateway.
        :param str cidr_block: CIDR block of the route.
        :param str core_network_arn: ARN of the core network.
        :param str destination_prefix_list_id: The ID of a managed prefix list destination of the route.
        :param str egress_only_gateway_id: ID of the Egress Only Internet Gateway.
        :param str gateway_id: ID of an Internet Gateway or Virtual Private Gateway which is connected to the Route Table (not exported if not passed as a parameter).
        :param str instance_id: EC2 instance ID.
        :param str ipv6_cidr_block: IPv6 CIDR block of the route.
        :param str local_gateway_id: Local Gateway ID.
        :param str nat_gateway_id: NAT Gateway ID.
        :param str network_interface_id: ID of the elastic network interface (eni) to use.
        :param str transit_gateway_id: EC2 Transit Gateway ID.
        :param str vpc_endpoint_id: VPC Endpoint ID.
        :param str vpc_peering_connection_id: VPC Peering ID.
        """
        GetRouteTableRouteResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            carrier_gateway_id=carrier_gateway_id,
            cidr_block=cidr_block,
            core_network_arn=core_network_arn,
            destination_prefix_list_id=destination_prefix_list_id,
            egress_only_gateway_id=egress_only_gateway_id,
            gateway_id=gateway_id,
            instance_id=instance_id,
            ipv6_cidr_block=ipv6_cidr_block,
            local_gateway_id=local_gateway_id,
            nat_gateway_id=nat_gateway_id,
            network_interface_id=network_interface_id,
            transit_gateway_id=transit_gateway_id,
            vpc_endpoint_id=vpc_endpoint_id,
            vpc_peering_connection_id=vpc_peering_connection_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             carrier_gateway_id: Optional[str] = None,
             cidr_block: Optional[str] = None,
             core_network_arn: Optional[str] = None,
             destination_prefix_list_id: Optional[str] = None,
             egress_only_gateway_id: Optional[str] = None,
             gateway_id: Optional[str] = None,
             instance_id: Optional[str] = None,
             ipv6_cidr_block: Optional[str] = None,
             local_gateway_id: Optional[str] = None,
             nat_gateway_id: Optional[str] = None,
             network_interface_id: Optional[str] = None,
             transit_gateway_id: Optional[str] = None,
             vpc_endpoint_id: Optional[str] = None,
             vpc_peering_connection_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if carrier_gateway_id is None and 'carrierGatewayId' in kwargs:
            carrier_gateway_id = kwargs['carrierGatewayId']
        if carrier_gateway_id is None:
            raise TypeError("Missing 'carrier_gateway_id' argument")
        if cidr_block is None and 'cidrBlock' in kwargs:
            cidr_block = kwargs['cidrBlock']
        if cidr_block is None:
            raise TypeError("Missing 'cidr_block' argument")
        if core_network_arn is None and 'coreNetworkArn' in kwargs:
            core_network_arn = kwargs['coreNetworkArn']
        if core_network_arn is None:
            raise TypeError("Missing 'core_network_arn' argument")
        if destination_prefix_list_id is None and 'destinationPrefixListId' in kwargs:
            destination_prefix_list_id = kwargs['destinationPrefixListId']
        if destination_prefix_list_id is None:
            raise TypeError("Missing 'destination_prefix_list_id' argument")
        if egress_only_gateway_id is None and 'egressOnlyGatewayId' in kwargs:
            egress_only_gateway_id = kwargs['egressOnlyGatewayId']
        if egress_only_gateway_id is None:
            raise TypeError("Missing 'egress_only_gateway_id' argument")
        if gateway_id is None and 'gatewayId' in kwargs:
            gateway_id = kwargs['gatewayId']
        if gateway_id is None:
            raise TypeError("Missing 'gateway_id' argument")
        if instance_id is None and 'instanceId' in kwargs:
            instance_id = kwargs['instanceId']
        if instance_id is None:
            raise TypeError("Missing 'instance_id' argument")
        if ipv6_cidr_block is None and 'ipv6CidrBlock' in kwargs:
            ipv6_cidr_block = kwargs['ipv6CidrBlock']
        if ipv6_cidr_block is None:
            raise TypeError("Missing 'ipv6_cidr_block' argument")
        if local_gateway_id is None and 'localGatewayId' in kwargs:
            local_gateway_id = kwargs['localGatewayId']
        if local_gateway_id is None:
            raise TypeError("Missing 'local_gateway_id' argument")
        if nat_gateway_id is None and 'natGatewayId' in kwargs:
            nat_gateway_id = kwargs['natGatewayId']
        if nat_gateway_id is None:
            raise TypeError("Missing 'nat_gateway_id' argument")
        if network_interface_id is None and 'networkInterfaceId' in kwargs:
            network_interface_id = kwargs['networkInterfaceId']
        if network_interface_id is None:
            raise TypeError("Missing 'network_interface_id' argument")
        if transit_gateway_id is None and 'transitGatewayId' in kwargs:
            transit_gateway_id = kwargs['transitGatewayId']
        if transit_gateway_id is None:
            raise TypeError("Missing 'transit_gateway_id' argument")
        if vpc_endpoint_id is None and 'vpcEndpointId' in kwargs:
            vpc_endpoint_id = kwargs['vpcEndpointId']
        if vpc_endpoint_id is None:
            raise TypeError("Missing 'vpc_endpoint_id' argument")
        if vpc_peering_connection_id is None and 'vpcPeeringConnectionId' in kwargs:
            vpc_peering_connection_id = kwargs['vpcPeeringConnectionId']
        if vpc_peering_connection_id is None:
            raise TypeError("Missing 'vpc_peering_connection_id' argument")

        _setter("carrier_gateway_id", carrier_gateway_id)
        _setter("cidr_block", cidr_block)
        _setter("core_network_arn", core_network_arn)
        _setter("destination_prefix_list_id", destination_prefix_list_id)
        _setter("egress_only_gateway_id", egress_only_gateway_id)
        _setter("gateway_id", gateway_id)
        _setter("instance_id", instance_id)
        _setter("ipv6_cidr_block", ipv6_cidr_block)
        _setter("local_gateway_id", local_gateway_id)
        _setter("nat_gateway_id", nat_gateway_id)
        _setter("network_interface_id", network_interface_id)
        _setter("transit_gateway_id", transit_gateway_id)
        _setter("vpc_endpoint_id", vpc_endpoint_id)
        _setter("vpc_peering_connection_id", vpc_peering_connection_id)

    @property
    @pulumi.getter(name="carrierGatewayId")
    def carrier_gateway_id(self) -> str:
        """
        ID of the Carrier Gateway.
        """
        return pulumi.get(self, "carrier_gateway_id")

    @property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> str:
        """
        CIDR block of the route.
        """
        return pulumi.get(self, "cidr_block")

    @property
    @pulumi.getter(name="coreNetworkArn")
    def core_network_arn(self) -> str:
        """
        ARN of the core network.
        """
        return pulumi.get(self, "core_network_arn")

    @property
    @pulumi.getter(name="destinationPrefixListId")
    def destination_prefix_list_id(self) -> str:
        """
        The ID of a managed prefix list destination of the route.
        """
        return pulumi.get(self, "destination_prefix_list_id")

    @property
    @pulumi.getter(name="egressOnlyGatewayId")
    def egress_only_gateway_id(self) -> str:
        """
        ID of the Egress Only Internet Gateway.
        """
        return pulumi.get(self, "egress_only_gateway_id")

    @property
    @pulumi.getter(name="gatewayId")
    def gateway_id(self) -> str:
        """
        ID of an Internet Gateway or Virtual Private Gateway which is connected to the Route Table (not exported if not passed as a parameter).
        """
        return pulumi.get(self, "gateway_id")

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> str:
        """
        EC2 instance ID.
        """
        return pulumi.get(self, "instance_id")

    @property
    @pulumi.getter(name="ipv6CidrBlock")
    def ipv6_cidr_block(self) -> str:
        """
        IPv6 CIDR block of the route.
        """
        return pulumi.get(self, "ipv6_cidr_block")

    @property
    @pulumi.getter(name="localGatewayId")
    def local_gateway_id(self) -> str:
        """
        Local Gateway ID.
        """
        return pulumi.get(self, "local_gateway_id")

    @property
    @pulumi.getter(name="natGatewayId")
    def nat_gateway_id(self) -> str:
        """
        NAT Gateway ID.
        """
        return pulumi.get(self, "nat_gateway_id")

    @property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> str:
        """
        ID of the elastic network interface (eni) to use.
        """
        return pulumi.get(self, "network_interface_id")

    @property
    @pulumi.getter(name="transitGatewayId")
    def transit_gateway_id(self) -> str:
        """
        EC2 Transit Gateway ID.
        """
        return pulumi.get(self, "transit_gateway_id")

    @property
    @pulumi.getter(name="vpcEndpointId")
    def vpc_endpoint_id(self) -> str:
        """
        VPC Endpoint ID.
        """
        return pulumi.get(self, "vpc_endpoint_id")

    @property
    @pulumi.getter(name="vpcPeeringConnectionId")
    def vpc_peering_connection_id(self) -> str:
        """
        VPC Peering ID.
        """
        return pulumi.get(self, "vpc_peering_connection_id")


@pulumi.output_type
class GetRouteTablesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Name of the field to filter by, as defined by
               [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeRouteTables.html).
        :param Sequence[str] values: Set of values that are accepted for the given field.
               A Route Table will be selected if any one of the given values matches.
        """
        GetRouteTablesFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the field to filter by, as defined by
        [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeRouteTables.html).
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Set of values that are accepted for the given field.
        A Route Table will be selected if any one of the given values matches.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetSecurityGroupFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Name of the field to filter by, as defined by
               [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeSecurityGroups.html).
        :param Sequence[str] values: Set of values that are accepted for the given field.
               A Security Group will be selected if any one of the given values matches.
        """
        GetSecurityGroupFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the field to filter by, as defined by
        [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeSecurityGroups.html).
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Set of values that are accepted for the given field.
        A Security Group will be selected if any one of the given values matches.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetSecurityGroupsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        GetSecurityGroupsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetSpotPriceFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Name of the filter.
        :param Sequence[str] values: List of one or more values for the filter.
        """
        GetSpotPriceFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the filter.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        List of one or more values for the filter.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetSubnetFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Name of the field to filter by, as defined by [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeSubnets.html).
        :param Sequence[str] values: Set of values that are accepted for the given field. A subnet will be selected if any one of the given values matches.
        """
        GetSubnetFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the field to filter by, as defined by [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeSubnets.html).
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Set of values that are accepted for the given field. A subnet will be selected if any one of the given values matches.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetSubnetsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Name of the field to filter by, as defined by
               [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeSubnets.html).
               For example, if matching against tag `Name`, use:
               
               ```python
               import pulumi
               import pulumi_aws as aws
               
               selected = aws.ec2.get_subnets(filters=[aws.ec2.GetSubnetsFilterArgs(
                   name="tag:Name",
                   values=[""],
               )])
               ```
        :param Sequence[str] values: Set of values that are accepted for the given field.
               Subnet IDs will be selected if any one of the given values match.
        """
        GetSubnetsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the field to filter by, as defined by
        [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeSubnets.html).
        For example, if matching against tag `Name`, use:

        ```python
        import pulumi
        import pulumi_aws as aws

        selected = aws.ec2.get_subnets(filters=[aws.ec2.GetSubnetsFilterArgs(
            name="tag:Name",
            values=[""],
        )])
        ```
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Set of values that are accepted for the given field.
        Subnet IDs will be selected if any one of the given values match.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetTransitGatewayRouteTablesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Name of the field to filter by, as defined by
               [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeTransitGatewayRouteTables.html).
        :param Sequence[str] values: Set of values that are accepted for the given field.
               A Transit Gateway Route Table will be selected if any one of the given values matches.
        """
        GetTransitGatewayRouteTablesFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the field to filter by, as defined by
        [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeTransitGatewayRouteTables.html).
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Set of values that are accepted for the given field.
        A Transit Gateway Route Table will be selected if any one of the given values matches.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetVpcCidrBlockAssociationResult(dict):
    def __init__(__self__, *,
                 association_id: str,
                 cidr_block: str,
                 state: str):
        """
        :param str association_id: Association ID for the IPv4 CIDR block.
        :param str cidr_block: Cidr block of the desired VPC.
        :param str state: Current state of the desired VPC.
               Can be either `"pending"` or `"available"`.
        """
        GetVpcCidrBlockAssociationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            association_id=association_id,
            cidr_block=cidr_block,
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             association_id: Optional[str] = None,
             cidr_block: Optional[str] = None,
             state: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if association_id is None and 'associationId' in kwargs:
            association_id = kwargs['associationId']
        if association_id is None:
            raise TypeError("Missing 'association_id' argument")
        if cidr_block is None and 'cidrBlock' in kwargs:
            cidr_block = kwargs['cidrBlock']
        if cidr_block is None:
            raise TypeError("Missing 'cidr_block' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")

        _setter("association_id", association_id)
        _setter("cidr_block", cidr_block)
        _setter("state", state)

    @property
    @pulumi.getter(name="associationId")
    def association_id(self) -> str:
        """
        Association ID for the IPv4 CIDR block.
        """
        return pulumi.get(self, "association_id")

    @property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> str:
        """
        Cidr block of the desired VPC.
        """
        return pulumi.get(self, "cidr_block")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        Current state of the desired VPC.
        Can be either `"pending"` or `"available"`.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetVpcDhcpOptionsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Name of the field to filter.
        :param Sequence[str] values: Set of values for filtering.
        """
        GetVpcDhcpOptionsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the field to filter.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Set of values for filtering.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetVpcEndpointDnsEntryResult(dict):
    def __init__(__self__, *,
                 dns_name: str,
                 hosted_zone_id: str):
        """
        :param str dns_name: DNS name.
        :param str hosted_zone_id: ID of the private hosted zone.
        """
        GetVpcEndpointDnsEntryResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dns_name=dns_name,
            hosted_zone_id=hosted_zone_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dns_name: Optional[str] = None,
             hosted_zone_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if dns_name is None and 'dnsName' in kwargs:
            dns_name = kwargs['dnsName']
        if dns_name is None:
            raise TypeError("Missing 'dns_name' argument")
        if hosted_zone_id is None and 'hostedZoneId' in kwargs:
            hosted_zone_id = kwargs['hostedZoneId']
        if hosted_zone_id is None:
            raise TypeError("Missing 'hosted_zone_id' argument")

        _setter("dns_name", dns_name)
        _setter("hosted_zone_id", hosted_zone_id)

    @property
    @pulumi.getter(name="dnsName")
    def dns_name(self) -> str:
        """
        DNS name.
        """
        return pulumi.get(self, "dns_name")

    @property
    @pulumi.getter(name="hostedZoneId")
    def hosted_zone_id(self) -> str:
        """
        ID of the private hosted zone.
        """
        return pulumi.get(self, "hosted_zone_id")


@pulumi.output_type
class GetVpcEndpointDnsOptionResult(dict):
    def __init__(__self__, *,
                 dns_record_ip_type: str,
                 private_dns_only_for_inbound_resolver_endpoint: bool):
        """
        :param str dns_record_ip_type: The DNS records created for the endpoint.
        :param bool private_dns_only_for_inbound_resolver_endpoint: Indicates whether to enable private DNS only for inbound endpoints.
        """
        GetVpcEndpointDnsOptionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dns_record_ip_type=dns_record_ip_type,
            private_dns_only_for_inbound_resolver_endpoint=private_dns_only_for_inbound_resolver_endpoint,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dns_record_ip_type: Optional[str] = None,
             private_dns_only_for_inbound_resolver_endpoint: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if dns_record_ip_type is None and 'dnsRecordIpType' in kwargs:
            dns_record_ip_type = kwargs['dnsRecordIpType']
        if dns_record_ip_type is None:
            raise TypeError("Missing 'dns_record_ip_type' argument")
        if private_dns_only_for_inbound_resolver_endpoint is None and 'privateDnsOnlyForInboundResolverEndpoint' in kwargs:
            private_dns_only_for_inbound_resolver_endpoint = kwargs['privateDnsOnlyForInboundResolverEndpoint']
        if private_dns_only_for_inbound_resolver_endpoint is None:
            raise TypeError("Missing 'private_dns_only_for_inbound_resolver_endpoint' argument")

        _setter("dns_record_ip_type", dns_record_ip_type)
        _setter("private_dns_only_for_inbound_resolver_endpoint", private_dns_only_for_inbound_resolver_endpoint)

    @property
    @pulumi.getter(name="dnsRecordIpType")
    def dns_record_ip_type(self) -> str:
        """
        The DNS records created for the endpoint.
        """
        return pulumi.get(self, "dns_record_ip_type")

    @property
    @pulumi.getter(name="privateDnsOnlyForInboundResolverEndpoint")
    def private_dns_only_for_inbound_resolver_endpoint(self) -> bool:
        """
        Indicates whether to enable private DNS only for inbound endpoints.
        """
        return pulumi.get(self, "private_dns_only_for_inbound_resolver_endpoint")


@pulumi.output_type
class GetVpcEndpointFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Name of the field to filter by, as defined by
               [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcEndpoints.html).
        :param Sequence[str] values: Set of values that are accepted for the given field.
               A VPC Endpoint will be selected if any one of the given values matches.
        """
        GetVpcEndpointFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the field to filter by, as defined by
        [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcEndpoints.html).
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Set of values that are accepted for the given field.
        A VPC Endpoint will be selected if any one of the given values matches.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetVpcEndpointServiceFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Name of the filter field. Valid values can be found in the [EC2 DescribeVpcEndpointServices API Reference](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcEndpointServices.html).
        :param Sequence[str] values: Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
        """
        GetVpcEndpointServiceFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the filter field. Valid values can be found in the [EC2 DescribeVpcEndpointServices API Reference](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcEndpointServices.html).
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetVpcFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Name of the field to filter by, as defined by
               [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcs.html).
        :param Sequence[str] values: Set of values that are accepted for the given field.
               A VPC will be selected if any one of the given values matches.
        """
        GetVpcFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the field to filter by, as defined by
        [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcs.html).
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Set of values that are accepted for the given field.
        A VPC will be selected if any one of the given values matches.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetVpcIamPoolCidrsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        GetVpcIamPoolCidrsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetVpcIamPoolCidrsIpamPoolCidrResult(dict):
    def __init__(__self__, *,
                 cidr: str,
                 state: str):
        """
        :param str cidr: A network CIDR.
        :param str state: The provisioning state of that CIDR.
        """
        GetVpcIamPoolCidrsIpamPoolCidrResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cidr=cidr,
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cidr: Optional[str] = None,
             state: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cidr is None:
            raise TypeError("Missing 'cidr' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")

        _setter("cidr", cidr)
        _setter("state", state)

    @property
    @pulumi.getter
    def cidr(self) -> str:
        """
        A network CIDR.
        """
        return pulumi.get(self, "cidr")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The provisioning state of that CIDR.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetVpcIamPoolFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: The name of the filter. Filter names are case-sensitive.
        :param Sequence[str] values: The filter values. Filter values are case-sensitive.
        """
        GetVpcIamPoolFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the filter. Filter names are case-sensitive.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        The filter values. Filter values are case-sensitive.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetVpcIamPoolsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: The name of the filter. Filter names are case-sensitive.
        :param Sequence[str] values: The filter values. Filter values are case-sensitive.
        """
        GetVpcIamPoolsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the filter. Filter names are case-sensitive.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        The filter values. Filter values are case-sensitive.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetVpcIamPoolsIpamPoolResult(dict):
    def __init__(__self__, *,
                 address_family: str,
                 allocation_default_netmask_length: int,
                 allocation_max_netmask_length: int,
                 allocation_min_netmask_length: int,
                 allocation_resource_tags: Mapping[str, str],
                 arn: str,
                 auto_import: bool,
                 aws_service: str,
                 description: str,
                 ipam_pool_id: str,
                 ipam_scope_id: str,
                 ipam_scope_type: str,
                 locale: str,
                 pool_depth: int,
                 publicly_advertisable: bool,
                 source_ipam_pool_id: str,
                 state: str,
                 tags: Mapping[str, str],
                 id: Optional[str] = None):
        """
        :param str address_family: IP protocol assigned to this pool.
        :param int allocation_default_netmask_length: A default netmask length for allocations added to this pool. If, for example, the CIDR assigned to this pool is `10.0.0.0/8` and you enter 16 here, new allocations will default to `10.0.0.0/16`.
        :param int allocation_max_netmask_length: The maximum netmask length that will be required for CIDR allocations in this pool.
        :param int allocation_min_netmask_length: The minimum netmask length that will be required for CIDR allocations in this pool.
        :param Mapping[str, str] allocation_resource_tags: Tags that are required to create resources in using this pool.
        :param str arn: ARN of the pool
        :param bool auto_import: If enabled, IPAM will continuously look for resources within the CIDR range of this pool and automatically import them as allocations into your IPAM.
        :param str aws_service: Limits which service in AWS that the pool can be used in. `ec2` for example, allows users to use space for Elastic IP addresses and VPCs.
        :param str description: Description for the IPAM pool.
        :param str ipam_scope_id: ID of the scope the pool belongs to.
        :param str locale: Locale is the Region where your pool is available for allocations. You can only create pools with locales that match the operating Regions of the IPAM. You can only create VPCs from a pool whose locale matches the VPC's Region.
        :param bool publicly_advertisable: Defines whether or not IPv6 pool space is publicly advertisable over the internet.
        :param str source_ipam_pool_id: ID of the source IPAM pool.
        :param Mapping[str, str] tags: Map of tags to assigned to the resource.
        :param str id: ID of the IPAM pool.
        """
        GetVpcIamPoolsIpamPoolResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            address_family=address_family,
            allocation_default_netmask_length=allocation_default_netmask_length,
            allocation_max_netmask_length=allocation_max_netmask_length,
            allocation_min_netmask_length=allocation_min_netmask_length,
            allocation_resource_tags=allocation_resource_tags,
            arn=arn,
            auto_import=auto_import,
            aws_service=aws_service,
            description=description,
            ipam_pool_id=ipam_pool_id,
            ipam_scope_id=ipam_scope_id,
            ipam_scope_type=ipam_scope_type,
            locale=locale,
            pool_depth=pool_depth,
            publicly_advertisable=publicly_advertisable,
            source_ipam_pool_id=source_ipam_pool_id,
            state=state,
            tags=tags,
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             address_family: Optional[str] = None,
             allocation_default_netmask_length: Optional[int] = None,
             allocation_max_netmask_length: Optional[int] = None,
             allocation_min_netmask_length: Optional[int] = None,
             allocation_resource_tags: Optional[Mapping[str, str]] = None,
             arn: Optional[str] = None,
             auto_import: Optional[bool] = None,
             aws_service: Optional[str] = None,
             description: Optional[str] = None,
             ipam_pool_id: Optional[str] = None,
             ipam_scope_id: Optional[str] = None,
             ipam_scope_type: Optional[str] = None,
             locale: Optional[str] = None,
             pool_depth: Optional[int] = None,
             publicly_advertisable: Optional[bool] = None,
             source_ipam_pool_id: Optional[str] = None,
             state: Optional[str] = None,
             tags: Optional[Mapping[str, str]] = None,
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if address_family is None and 'addressFamily' in kwargs:
            address_family = kwargs['addressFamily']
        if address_family is None:
            raise TypeError("Missing 'address_family' argument")
        if allocation_default_netmask_length is None and 'allocationDefaultNetmaskLength' in kwargs:
            allocation_default_netmask_length = kwargs['allocationDefaultNetmaskLength']
        if allocation_default_netmask_length is None:
            raise TypeError("Missing 'allocation_default_netmask_length' argument")
        if allocation_max_netmask_length is None and 'allocationMaxNetmaskLength' in kwargs:
            allocation_max_netmask_length = kwargs['allocationMaxNetmaskLength']
        if allocation_max_netmask_length is None:
            raise TypeError("Missing 'allocation_max_netmask_length' argument")
        if allocation_min_netmask_length is None and 'allocationMinNetmaskLength' in kwargs:
            allocation_min_netmask_length = kwargs['allocationMinNetmaskLength']
        if allocation_min_netmask_length is None:
            raise TypeError("Missing 'allocation_min_netmask_length' argument")
        if allocation_resource_tags is None and 'allocationResourceTags' in kwargs:
            allocation_resource_tags = kwargs['allocationResourceTags']
        if allocation_resource_tags is None:
            raise TypeError("Missing 'allocation_resource_tags' argument")
        if arn is None:
            raise TypeError("Missing 'arn' argument")
        if auto_import is None and 'autoImport' in kwargs:
            auto_import = kwargs['autoImport']
        if auto_import is None:
            raise TypeError("Missing 'auto_import' argument")
        if aws_service is None and 'awsService' in kwargs:
            aws_service = kwargs['awsService']
        if aws_service is None:
            raise TypeError("Missing 'aws_service' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if ipam_pool_id is None and 'ipamPoolId' in kwargs:
            ipam_pool_id = kwargs['ipamPoolId']
        if ipam_pool_id is None:
            raise TypeError("Missing 'ipam_pool_id' argument")
        if ipam_scope_id is None and 'ipamScopeId' in kwargs:
            ipam_scope_id = kwargs['ipamScopeId']
        if ipam_scope_id is None:
            raise TypeError("Missing 'ipam_scope_id' argument")
        if ipam_scope_type is None and 'ipamScopeType' in kwargs:
            ipam_scope_type = kwargs['ipamScopeType']
        if ipam_scope_type is None:
            raise TypeError("Missing 'ipam_scope_type' argument")
        if locale is None:
            raise TypeError("Missing 'locale' argument")
        if pool_depth is None and 'poolDepth' in kwargs:
            pool_depth = kwargs['poolDepth']
        if pool_depth is None:
            raise TypeError("Missing 'pool_depth' argument")
        if publicly_advertisable is None and 'publiclyAdvertisable' in kwargs:
            publicly_advertisable = kwargs['publiclyAdvertisable']
        if publicly_advertisable is None:
            raise TypeError("Missing 'publicly_advertisable' argument")
        if source_ipam_pool_id is None and 'sourceIpamPoolId' in kwargs:
            source_ipam_pool_id = kwargs['sourceIpamPoolId']
        if source_ipam_pool_id is None:
            raise TypeError("Missing 'source_ipam_pool_id' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if tags is None:
            raise TypeError("Missing 'tags' argument")

        _setter("address_family", address_family)
        _setter("allocation_default_netmask_length", allocation_default_netmask_length)
        _setter("allocation_max_netmask_length", allocation_max_netmask_length)
        _setter("allocation_min_netmask_length", allocation_min_netmask_length)
        _setter("allocation_resource_tags", allocation_resource_tags)
        _setter("arn", arn)
        _setter("auto_import", auto_import)
        _setter("aws_service", aws_service)
        _setter("description", description)
        _setter("ipam_pool_id", ipam_pool_id)
        _setter("ipam_scope_id", ipam_scope_id)
        _setter("ipam_scope_type", ipam_scope_type)
        _setter("locale", locale)
        _setter("pool_depth", pool_depth)
        _setter("publicly_advertisable", publicly_advertisable)
        _setter("source_ipam_pool_id", source_ipam_pool_id)
        _setter("state", state)
        _setter("tags", tags)
        if id is not None:
            _setter("id", id)

    @property
    @pulumi.getter(name="addressFamily")
    def address_family(self) -> str:
        """
        IP protocol assigned to this pool.
        """
        return pulumi.get(self, "address_family")

    @property
    @pulumi.getter(name="allocationDefaultNetmaskLength")
    def allocation_default_netmask_length(self) -> int:
        """
        A default netmask length for allocations added to this pool. If, for example, the CIDR assigned to this pool is `10.0.0.0/8` and you enter 16 here, new allocations will default to `10.0.0.0/16`.
        """
        return pulumi.get(self, "allocation_default_netmask_length")

    @property
    @pulumi.getter(name="allocationMaxNetmaskLength")
    def allocation_max_netmask_length(self) -> int:
        """
        The maximum netmask length that will be required for CIDR allocations in this pool.
        """
        return pulumi.get(self, "allocation_max_netmask_length")

    @property
    @pulumi.getter(name="allocationMinNetmaskLength")
    def allocation_min_netmask_length(self) -> int:
        """
        The minimum netmask length that will be required for CIDR allocations in this pool.
        """
        return pulumi.get(self, "allocation_min_netmask_length")

    @property
    @pulumi.getter(name="allocationResourceTags")
    def allocation_resource_tags(self) -> Mapping[str, str]:
        """
        Tags that are required to create resources in using this pool.
        """
        return pulumi.get(self, "allocation_resource_tags")

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        ARN of the pool
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="autoImport")
    def auto_import(self) -> bool:
        """
        If enabled, IPAM will continuously look for resources within the CIDR range of this pool and automatically import them as allocations into your IPAM.
        """
        return pulumi.get(self, "auto_import")

    @property
    @pulumi.getter(name="awsService")
    def aws_service(self) -> str:
        """
        Limits which service in AWS that the pool can be used in. `ec2` for example, allows users to use space for Elastic IP addresses and VPCs.
        """
        return pulumi.get(self, "aws_service")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Description for the IPAM pool.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="ipamPoolId")
    def ipam_pool_id(self) -> str:
        return pulumi.get(self, "ipam_pool_id")

    @property
    @pulumi.getter(name="ipamScopeId")
    def ipam_scope_id(self) -> str:
        """
        ID of the scope the pool belongs to.
        """
        return pulumi.get(self, "ipam_scope_id")

    @property
    @pulumi.getter(name="ipamScopeType")
    def ipam_scope_type(self) -> str:
        return pulumi.get(self, "ipam_scope_type")

    @property
    @pulumi.getter
    def locale(self) -> str:
        """
        Locale is the Region where your pool is available for allocations. You can only create pools with locales that match the operating Regions of the IPAM. You can only create VPCs from a pool whose locale matches the VPC's Region.
        """
        return pulumi.get(self, "locale")

    @property
    @pulumi.getter(name="poolDepth")
    def pool_depth(self) -> int:
        return pulumi.get(self, "pool_depth")

    @property
    @pulumi.getter(name="publiclyAdvertisable")
    def publicly_advertisable(self) -> bool:
        """
        Defines whether or not IPv6 pool space is publicly advertisable over the internet.
        """
        return pulumi.get(self, "publicly_advertisable")

    @property
    @pulumi.getter(name="sourceIpamPoolId")
    def source_ipam_pool_id(self) -> str:
        """
        ID of the source IPAM pool.
        """
        return pulumi.get(self, "source_ipam_pool_id")

    @property
    @pulumi.getter
    def state(self) -> str:
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def tags(self) -> Mapping[str, str]:
        """
        Map of tags to assigned to the resource.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the IPAM pool.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetVpcIpamPoolCidrsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        GetVpcIpamPoolCidrsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetVpcIpamPoolCidrsIpamPoolCidrResult(dict):
    def __init__(__self__, *,
                 cidr: str,
                 state: str):
        """
        :param str cidr: A network CIDR.
        :param str state: The provisioning state of that CIDR.
        """
        GetVpcIpamPoolCidrsIpamPoolCidrResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cidr=cidr,
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cidr: Optional[str] = None,
             state: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cidr is None:
            raise TypeError("Missing 'cidr' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")

        _setter("cidr", cidr)
        _setter("state", state)

    @property
    @pulumi.getter
    def cidr(self) -> str:
        """
        A network CIDR.
        """
        return pulumi.get(self, "cidr")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The provisioning state of that CIDR.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetVpcIpamPoolFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: The name of the filter. Filter names are case-sensitive.
        :param Sequence[str] values: The filter values. Filter values are case-sensitive.
        """
        GetVpcIpamPoolFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the filter. Filter names are case-sensitive.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        The filter values. Filter values are case-sensitive.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetVpcIpamPoolsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: The name of the filter. Filter names are case-sensitive.
        :param Sequence[str] values: The filter values. Filter values are case-sensitive.
        """
        GetVpcIpamPoolsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the filter. Filter names are case-sensitive.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        The filter values. Filter values are case-sensitive.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetVpcIpamPoolsIpamPoolResult(dict):
    def __init__(__self__, *,
                 address_family: str,
                 allocation_default_netmask_length: int,
                 allocation_max_netmask_length: int,
                 allocation_min_netmask_length: int,
                 allocation_resource_tags: Mapping[str, str],
                 arn: str,
                 auto_import: bool,
                 aws_service: str,
                 description: str,
                 ipam_pool_id: str,
                 ipam_scope_id: str,
                 ipam_scope_type: str,
                 locale: str,
                 pool_depth: int,
                 publicly_advertisable: bool,
                 source_ipam_pool_id: str,
                 state: str,
                 tags: Mapping[str, str],
                 id: Optional[str] = None):
        """
        :param str address_family: IP protocol assigned to this pool.
        :param int allocation_default_netmask_length: A default netmask length for allocations added to this pool. If, for example, the CIDR assigned to this pool is `10.0.0.0/8` and you enter 16 here, new allocations will default to `10.0.0.0/16`.
        :param int allocation_max_netmask_length: The maximum netmask length that will be required for CIDR allocations in this pool.
        :param int allocation_min_netmask_length: The minimum netmask length that will be required for CIDR allocations in this pool.
        :param Mapping[str, str] allocation_resource_tags: Tags that are required to create resources in using this pool.
        :param str arn: ARN of the pool
        :param bool auto_import: If enabled, IPAM will continuously look for resources within the CIDR range of this pool and automatically import them as allocations into your IPAM.
        :param str aws_service: Limits which service in AWS that the pool can be used in. `ec2` for example, allows users to use space for Elastic IP addresses and VPCs.
        :param str description: Description for the IPAM pool.
        :param str ipam_scope_id: ID of the scope the pool belongs to.
        :param str locale: Locale is the Region where your pool is available for allocations. You can only create pools with locales that match the operating Regions of the IPAM. You can only create VPCs from a pool whose locale matches the VPC's Region.
        :param bool publicly_advertisable: Defines whether or not IPv6 pool space is publicly advertisable over the internet.
        :param str source_ipam_pool_id: ID of the source IPAM pool.
        :param Mapping[str, str] tags: Map of tags to assigned to the resource.
        :param str id: ID of the IPAM pool.
        """
        GetVpcIpamPoolsIpamPoolResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            address_family=address_family,
            allocation_default_netmask_length=allocation_default_netmask_length,
            allocation_max_netmask_length=allocation_max_netmask_length,
            allocation_min_netmask_length=allocation_min_netmask_length,
            allocation_resource_tags=allocation_resource_tags,
            arn=arn,
            auto_import=auto_import,
            aws_service=aws_service,
            description=description,
            ipam_pool_id=ipam_pool_id,
            ipam_scope_id=ipam_scope_id,
            ipam_scope_type=ipam_scope_type,
            locale=locale,
            pool_depth=pool_depth,
            publicly_advertisable=publicly_advertisable,
            source_ipam_pool_id=source_ipam_pool_id,
            state=state,
            tags=tags,
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             address_family: Optional[str] = None,
             allocation_default_netmask_length: Optional[int] = None,
             allocation_max_netmask_length: Optional[int] = None,
             allocation_min_netmask_length: Optional[int] = None,
             allocation_resource_tags: Optional[Mapping[str, str]] = None,
             arn: Optional[str] = None,
             auto_import: Optional[bool] = None,
             aws_service: Optional[str] = None,
             description: Optional[str] = None,
             ipam_pool_id: Optional[str] = None,
             ipam_scope_id: Optional[str] = None,
             ipam_scope_type: Optional[str] = None,
             locale: Optional[str] = None,
             pool_depth: Optional[int] = None,
             publicly_advertisable: Optional[bool] = None,
             source_ipam_pool_id: Optional[str] = None,
             state: Optional[str] = None,
             tags: Optional[Mapping[str, str]] = None,
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if address_family is None and 'addressFamily' in kwargs:
            address_family = kwargs['addressFamily']
        if address_family is None:
            raise TypeError("Missing 'address_family' argument")
        if allocation_default_netmask_length is None and 'allocationDefaultNetmaskLength' in kwargs:
            allocation_default_netmask_length = kwargs['allocationDefaultNetmaskLength']
        if allocation_default_netmask_length is None:
            raise TypeError("Missing 'allocation_default_netmask_length' argument")
        if allocation_max_netmask_length is None and 'allocationMaxNetmaskLength' in kwargs:
            allocation_max_netmask_length = kwargs['allocationMaxNetmaskLength']
        if allocation_max_netmask_length is None:
            raise TypeError("Missing 'allocation_max_netmask_length' argument")
        if allocation_min_netmask_length is None and 'allocationMinNetmaskLength' in kwargs:
            allocation_min_netmask_length = kwargs['allocationMinNetmaskLength']
        if allocation_min_netmask_length is None:
            raise TypeError("Missing 'allocation_min_netmask_length' argument")
        if allocation_resource_tags is None and 'allocationResourceTags' in kwargs:
            allocation_resource_tags = kwargs['allocationResourceTags']
        if allocation_resource_tags is None:
            raise TypeError("Missing 'allocation_resource_tags' argument")
        if arn is None:
            raise TypeError("Missing 'arn' argument")
        if auto_import is None and 'autoImport' in kwargs:
            auto_import = kwargs['autoImport']
        if auto_import is None:
            raise TypeError("Missing 'auto_import' argument")
        if aws_service is None and 'awsService' in kwargs:
            aws_service = kwargs['awsService']
        if aws_service is None:
            raise TypeError("Missing 'aws_service' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if ipam_pool_id is None and 'ipamPoolId' in kwargs:
            ipam_pool_id = kwargs['ipamPoolId']
        if ipam_pool_id is None:
            raise TypeError("Missing 'ipam_pool_id' argument")
        if ipam_scope_id is None and 'ipamScopeId' in kwargs:
            ipam_scope_id = kwargs['ipamScopeId']
        if ipam_scope_id is None:
            raise TypeError("Missing 'ipam_scope_id' argument")
        if ipam_scope_type is None and 'ipamScopeType' in kwargs:
            ipam_scope_type = kwargs['ipamScopeType']
        if ipam_scope_type is None:
            raise TypeError("Missing 'ipam_scope_type' argument")
        if locale is None:
            raise TypeError("Missing 'locale' argument")
        if pool_depth is None and 'poolDepth' in kwargs:
            pool_depth = kwargs['poolDepth']
        if pool_depth is None:
            raise TypeError("Missing 'pool_depth' argument")
        if publicly_advertisable is None and 'publiclyAdvertisable' in kwargs:
            publicly_advertisable = kwargs['publiclyAdvertisable']
        if publicly_advertisable is None:
            raise TypeError("Missing 'publicly_advertisable' argument")
        if source_ipam_pool_id is None and 'sourceIpamPoolId' in kwargs:
            source_ipam_pool_id = kwargs['sourceIpamPoolId']
        if source_ipam_pool_id is None:
            raise TypeError("Missing 'source_ipam_pool_id' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if tags is None:
            raise TypeError("Missing 'tags' argument")

        _setter("address_family", address_family)
        _setter("allocation_default_netmask_length", allocation_default_netmask_length)
        _setter("allocation_max_netmask_length", allocation_max_netmask_length)
        _setter("allocation_min_netmask_length", allocation_min_netmask_length)
        _setter("allocation_resource_tags", allocation_resource_tags)
        _setter("arn", arn)
        _setter("auto_import", auto_import)
        _setter("aws_service", aws_service)
        _setter("description", description)
        _setter("ipam_pool_id", ipam_pool_id)
        _setter("ipam_scope_id", ipam_scope_id)
        _setter("ipam_scope_type", ipam_scope_type)
        _setter("locale", locale)
        _setter("pool_depth", pool_depth)
        _setter("publicly_advertisable", publicly_advertisable)
        _setter("source_ipam_pool_id", source_ipam_pool_id)
        _setter("state", state)
        _setter("tags", tags)
        if id is not None:
            _setter("id", id)

    @property
    @pulumi.getter(name="addressFamily")
    def address_family(self) -> str:
        """
        IP protocol assigned to this pool.
        """
        return pulumi.get(self, "address_family")

    @property
    @pulumi.getter(name="allocationDefaultNetmaskLength")
    def allocation_default_netmask_length(self) -> int:
        """
        A default netmask length for allocations added to this pool. If, for example, the CIDR assigned to this pool is `10.0.0.0/8` and you enter 16 here, new allocations will default to `10.0.0.0/16`.
        """
        return pulumi.get(self, "allocation_default_netmask_length")

    @property
    @pulumi.getter(name="allocationMaxNetmaskLength")
    def allocation_max_netmask_length(self) -> int:
        """
        The maximum netmask length that will be required for CIDR allocations in this pool.
        """
        return pulumi.get(self, "allocation_max_netmask_length")

    @property
    @pulumi.getter(name="allocationMinNetmaskLength")
    def allocation_min_netmask_length(self) -> int:
        """
        The minimum netmask length that will be required for CIDR allocations in this pool.
        """
        return pulumi.get(self, "allocation_min_netmask_length")

    @property
    @pulumi.getter(name="allocationResourceTags")
    def allocation_resource_tags(self) -> Mapping[str, str]:
        """
        Tags that are required to create resources in using this pool.
        """
        return pulumi.get(self, "allocation_resource_tags")

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        ARN of the pool
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="autoImport")
    def auto_import(self) -> bool:
        """
        If enabled, IPAM will continuously look for resources within the CIDR range of this pool and automatically import them as allocations into your IPAM.
        """
        return pulumi.get(self, "auto_import")

    @property
    @pulumi.getter(name="awsService")
    def aws_service(self) -> str:
        """
        Limits which service in AWS that the pool can be used in. `ec2` for example, allows users to use space for Elastic IP addresses and VPCs.
        """
        return pulumi.get(self, "aws_service")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Description for the IPAM pool.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="ipamPoolId")
    def ipam_pool_id(self) -> str:
        return pulumi.get(self, "ipam_pool_id")

    @property
    @pulumi.getter(name="ipamScopeId")
    def ipam_scope_id(self) -> str:
        """
        ID of the scope the pool belongs to.
        """
        return pulumi.get(self, "ipam_scope_id")

    @property
    @pulumi.getter(name="ipamScopeType")
    def ipam_scope_type(self) -> str:
        return pulumi.get(self, "ipam_scope_type")

    @property
    @pulumi.getter
    def locale(self) -> str:
        """
        Locale is the Region where your pool is available for allocations. You can only create pools with locales that match the operating Regions of the IPAM. You can only create VPCs from a pool whose locale matches the VPC's Region.
        """
        return pulumi.get(self, "locale")

    @property
    @pulumi.getter(name="poolDepth")
    def pool_depth(self) -> int:
        return pulumi.get(self, "pool_depth")

    @property
    @pulumi.getter(name="publiclyAdvertisable")
    def publicly_advertisable(self) -> bool:
        """
        Defines whether or not IPv6 pool space is publicly advertisable over the internet.
        """
        return pulumi.get(self, "publicly_advertisable")

    @property
    @pulumi.getter(name="sourceIpamPoolId")
    def source_ipam_pool_id(self) -> str:
        """
        ID of the source IPAM pool.
        """
        return pulumi.get(self, "source_ipam_pool_id")

    @property
    @pulumi.getter
    def state(self) -> str:
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def tags(self) -> Mapping[str, str]:
        """
        Map of tags to assigned to the resource.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the IPAM pool.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetVpcPeeringConnectionCidrBlockSetResult(dict):
    def __init__(__self__, *,
                 cidr_block: str):
        """
        :param str cidr_block: Primary CIDR block of the requester VPC of the specific VPC Peering Connection to retrieve.
        """
        GetVpcPeeringConnectionCidrBlockSetResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cidr_block=cidr_block,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cidr_block: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cidr_block is None and 'cidrBlock' in kwargs:
            cidr_block = kwargs['cidrBlock']
        if cidr_block is None:
            raise TypeError("Missing 'cidr_block' argument")

        _setter("cidr_block", cidr_block)

    @property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> str:
        """
        Primary CIDR block of the requester VPC of the specific VPC Peering Connection to retrieve.
        """
        return pulumi.get(self, "cidr_block")


@pulumi.output_type
class GetVpcPeeringConnectionFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Name of the field to filter by, as defined by
               [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcPeeringConnections.html).
        :param Sequence[str] values: Set of values that are accepted for the given field.
               A VPC Peering Connection will be selected if any one of the given values matches.
        """
        GetVpcPeeringConnectionFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the field to filter by, as defined by
        [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcPeeringConnections.html).
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Set of values that are accepted for the given field.
        A VPC Peering Connection will be selected if any one of the given values matches.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetVpcPeeringConnectionPeerCidrBlockSetResult(dict):
    def __init__(__self__, *,
                 cidr_block: str):
        """
        :param str cidr_block: Primary CIDR block of the requester VPC of the specific VPC Peering Connection to retrieve.
        """
        GetVpcPeeringConnectionPeerCidrBlockSetResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cidr_block=cidr_block,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cidr_block: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cidr_block is None and 'cidrBlock' in kwargs:
            cidr_block = kwargs['cidrBlock']
        if cidr_block is None:
            raise TypeError("Missing 'cidr_block' argument")

        _setter("cidr_block", cidr_block)

    @property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> str:
        """
        Primary CIDR block of the requester VPC of the specific VPC Peering Connection to retrieve.
        """
        return pulumi.get(self, "cidr_block")


@pulumi.output_type
class GetVpcPeeringConnectionsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Name of the field to filter by, as defined by
               [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcPeeringConnections.html).
        :param Sequence[str] values: Set of values that are accepted for the given field.
               A VPC Peering Connection will be selected if any one of the given values matches.
        """
        GetVpcPeeringConnectionsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the field to filter by, as defined by
        [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcPeeringConnections.html).
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Set of values that are accepted for the given field.
        A VPC Peering Connection will be selected if any one of the given values matches.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetVpcsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Name of the field to filter by, as defined by
               [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcs.html).
        :param Sequence[str] values: Set of values that are accepted for the given field.
               A VPC will be selected if any one of the given values matches.
        """
        GetVpcsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the field to filter by, as defined by
        [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcs.html).
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Set of values that are accepted for the given field.
        A VPC will be selected if any one of the given values matches.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetVpnGatewayFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Name of the field to filter by, as defined by
               [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpnGateways.html).
        :param Sequence[str] values: Set of values that are accepted for the given field.
               A VPN Gateway will be selected if any one of the given values matches.
        """
        GetVpnGatewayFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the field to filter by, as defined by
        [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpnGateways.html).
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Set of values that are accepted for the given field.
        A VPN Gateway will be selected if any one of the given values matches.
        """
        return pulumi.get(self, "values")


