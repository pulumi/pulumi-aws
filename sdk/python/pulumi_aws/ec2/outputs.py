# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AllowedImagesSettingsImageCriterion',
    'AllowedImagesSettingsImageCriterionCreationDateCondition',
    'AllowedImagesSettingsImageCriterionDeprecationTimeCondition',
    'AmiCopyEbsBlockDevice',
    'AmiCopyEphemeralBlockDevice',
    'AmiEbsBlockDevice',
    'AmiEphemeralBlockDevice',
    'AmiFromInstanceEbsBlockDevice',
    'AmiFromInstanceEphemeralBlockDevice',
    'CapacityBlockReservationTimeouts',
    'DefaultCreditSpecificationTimeouts',
    'DefaultNetworkAclEgress',
    'DefaultNetworkAclIngress',
    'DefaultRouteTableRoute',
    'DefaultSecurityGroupEgress',
    'DefaultSecurityGroupIngress',
    'EipDomainNameTimeouts',
    'EncryptionControlResourceExclusions',
    'EncryptionControlResourceExclusionsEgressOnlyInternetGateway',
    'EncryptionControlResourceExclusionsElasticFileSystem',
    'EncryptionControlResourceExclusionsInternetGateway',
    'EncryptionControlResourceExclusionsLambda',
    'EncryptionControlResourceExclusionsNatGateway',
    'EncryptionControlResourceExclusionsVirtualPrivateGateway',
    'EncryptionControlResourceExclusionsVpcLattice',
    'EncryptionControlResourceExclusionsVpcPeering',
    'EncryptionControlTimeouts',
    'FleetFleetInstanceSet',
    'FleetLaunchTemplateConfig',
    'FleetLaunchTemplateConfigLaunchTemplateSpecification',
    'FleetLaunchTemplateConfigOverride',
    'FleetLaunchTemplateConfigOverrideInstanceRequirements',
    'FleetLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorCount',
    'FleetLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorTotalMemoryMib',
    'FleetLaunchTemplateConfigOverrideInstanceRequirementsBaselineEbsBandwidthMbps',
    'FleetLaunchTemplateConfigOverrideInstanceRequirementsMemoryGibPerVcpu',
    'FleetLaunchTemplateConfigOverrideInstanceRequirementsMemoryMib',
    'FleetLaunchTemplateConfigOverrideInstanceRequirementsNetworkBandwidthGbps',
    'FleetLaunchTemplateConfigOverrideInstanceRequirementsNetworkInterfaceCount',
    'FleetLaunchTemplateConfigOverrideInstanceRequirementsTotalLocalStorageGb',
    'FleetLaunchTemplateConfigOverrideInstanceRequirementsVcpuCount',
    'FleetOnDemandOptions',
    'FleetOnDemandOptionsCapacityReservationOptions',
    'FleetSpotOptions',
    'FleetSpotOptionsMaintenanceStrategies',
    'FleetSpotOptionsMaintenanceStrategiesCapacityRebalance',
    'FleetTargetCapacitySpecification',
    'FlowLogDestinationOptions',
    'InstanceCapacityReservationSpecification',
    'InstanceCapacityReservationSpecificationCapacityReservationTarget',
    'InstanceCpuOptions',
    'InstanceCreditSpecification',
    'InstanceEbsBlockDevice',
    'InstanceEnclaveOptions',
    'InstanceEphemeralBlockDevice',
    'InstanceInstanceMarketOptions',
    'InstanceInstanceMarketOptionsSpotOptions',
    'InstanceLaunchTemplate',
    'InstanceMaintenanceOptions',
    'InstanceMetadataOptions',
    'InstanceNetworkInterface',
    'InstancePrimaryNetworkInterface',
    'InstancePrivateDnsNameOptions',
    'InstanceRootBlockDevice',
    'LaunchConfigurationEbsBlockDevice',
    'LaunchConfigurationEphemeralBlockDevice',
    'LaunchConfigurationMetadataOptions',
    'LaunchConfigurationRootBlockDevice',
    'LaunchTemplateBlockDeviceMapping',
    'LaunchTemplateBlockDeviceMappingEbs',
    'LaunchTemplateCapacityReservationSpecification',
    'LaunchTemplateCapacityReservationSpecificationCapacityReservationTarget',
    'LaunchTemplateCpuOptions',
    'LaunchTemplateCreditSpecification',
    'LaunchTemplateEnclaveOptions',
    'LaunchTemplateHibernationOptions',
    'LaunchTemplateIamInstanceProfile',
    'LaunchTemplateInstanceMarketOptions',
    'LaunchTemplateInstanceMarketOptionsSpotOptions',
    'LaunchTemplateInstanceRequirements',
    'LaunchTemplateInstanceRequirementsAcceleratorCount',
    'LaunchTemplateInstanceRequirementsAcceleratorTotalMemoryMib',
    'LaunchTemplateInstanceRequirementsBaselineEbsBandwidthMbps',
    'LaunchTemplateInstanceRequirementsMemoryGibPerVcpu',
    'LaunchTemplateInstanceRequirementsMemoryMib',
    'LaunchTemplateInstanceRequirementsNetworkBandwidthGbps',
    'LaunchTemplateInstanceRequirementsNetworkInterfaceCount',
    'LaunchTemplateInstanceRequirementsTotalLocalStorageGb',
    'LaunchTemplateInstanceRequirementsVcpuCount',
    'LaunchTemplateLicenseSpecification',
    'LaunchTemplateMaintenanceOptions',
    'LaunchTemplateMetadataOptions',
    'LaunchTemplateMonitoring',
    'LaunchTemplateNetworkInterface',
    'LaunchTemplateNetworkInterfaceConnectionTrackingSpecification',
    'LaunchTemplateNetworkInterfaceEnaSrdSpecification',
    'LaunchTemplateNetworkInterfaceEnaSrdSpecificationEnaSrdUdpSpecification',
    'LaunchTemplatePlacement',
    'LaunchTemplatePrivateDnsNameOptions',
    'LaunchTemplateTagSpecification',
    'ManagedPrefixListEntry',
    'NatGatewayAvailabilityZoneAddress',
    'NatGatewayEipAssociationTimeouts',
    'NatGatewayRegionalNatGatewayAddress',
    'NetworkAclEgress',
    'NetworkAclIngress',
    'NetworkInsightsAnalysisAlternatePathHint',
    'NetworkInsightsAnalysisExplanation',
    'NetworkInsightsAnalysisExplanationAcl',
    'NetworkInsightsAnalysisExplanationAclRule',
    'NetworkInsightsAnalysisExplanationAclRulePortRange',
    'NetworkInsightsAnalysisExplanationAttachedTo',
    'NetworkInsightsAnalysisExplanationClassicLoadBalancerListener',
    'NetworkInsightsAnalysisExplanationComponent',
    'NetworkInsightsAnalysisExplanationCustomerGateway',
    'NetworkInsightsAnalysisExplanationDestination',
    'NetworkInsightsAnalysisExplanationDestinationVpc',
    'NetworkInsightsAnalysisExplanationElasticLoadBalancerListener',
    'NetworkInsightsAnalysisExplanationIngressRouteTable',
    'NetworkInsightsAnalysisExplanationInternetGateway',
    'NetworkInsightsAnalysisExplanationLoadBalancerTargetGroup',
    'NetworkInsightsAnalysisExplanationNatGateway',
    'NetworkInsightsAnalysisExplanationNetworkInterface',
    'NetworkInsightsAnalysisExplanationPortRange',
    'NetworkInsightsAnalysisExplanationPrefixList',
    'NetworkInsightsAnalysisExplanationRouteTable',
    'NetworkInsightsAnalysisExplanationRouteTableRoute',
    'NetworkInsightsAnalysisExplanationSecurityGroup',
    'NetworkInsightsAnalysisExplanationSecurityGroupRule',
    'NetworkInsightsAnalysisExplanationSecurityGroupRulePortRange',
    'NetworkInsightsAnalysisExplanationSourceVpc',
    'NetworkInsightsAnalysisExplanationSubnet',
    'NetworkInsightsAnalysisExplanationSubnetRouteTable',
    'NetworkInsightsAnalysisExplanationTransitGateway',
    'NetworkInsightsAnalysisExplanationTransitGatewayAttachment',
    'NetworkInsightsAnalysisExplanationTransitGatewayRouteTable',
    'NetworkInsightsAnalysisExplanationTransitGatewayRouteTableRoute',
    'NetworkInsightsAnalysisExplanationVpc',
    'NetworkInsightsAnalysisExplanationVpcEndpoint',
    'NetworkInsightsAnalysisExplanationVpcPeeringConnection',
    'NetworkInsightsAnalysisExplanationVpnConnection',
    'NetworkInsightsAnalysisExplanationVpnGateway',
    'NetworkInsightsAnalysisForwardPathComponent',
    'NetworkInsightsAnalysisForwardPathComponentAclRule',
    'NetworkInsightsAnalysisForwardPathComponentAclRulePortRange',
    'NetworkInsightsAnalysisForwardPathComponentAdditionalDetail',
    'NetworkInsightsAnalysisForwardPathComponentAdditionalDetailComponent',
    'NetworkInsightsAnalysisForwardPathComponentAttachedTo',
    'NetworkInsightsAnalysisForwardPathComponentComponent',
    'NetworkInsightsAnalysisForwardPathComponentDestinationVpc',
    'NetworkInsightsAnalysisForwardPathComponentInboundHeader',
    'NetworkInsightsAnalysisForwardPathComponentInboundHeaderDestinationPortRange',
    'NetworkInsightsAnalysisForwardPathComponentInboundHeaderSourcePortRange',
    'NetworkInsightsAnalysisForwardPathComponentOutboundHeader',
    'NetworkInsightsAnalysisForwardPathComponentOutboundHeaderDestinationPortRange',
    'NetworkInsightsAnalysisForwardPathComponentOutboundHeaderSourcePortRange',
    'NetworkInsightsAnalysisForwardPathComponentRouteTableRoute',
    'NetworkInsightsAnalysisForwardPathComponentSecurityGroupRule',
    'NetworkInsightsAnalysisForwardPathComponentSecurityGroupRulePortRange',
    'NetworkInsightsAnalysisForwardPathComponentSourceVpc',
    'NetworkInsightsAnalysisForwardPathComponentSubnet',
    'NetworkInsightsAnalysisForwardPathComponentTransitGateway',
    'NetworkInsightsAnalysisForwardPathComponentTransitGatewayRouteTableRoute',
    'NetworkInsightsAnalysisForwardPathComponentVpc',
    'NetworkInsightsAnalysisReturnPathComponent',
    'NetworkInsightsAnalysisReturnPathComponentAclRule',
    'NetworkInsightsAnalysisReturnPathComponentAclRulePortRange',
    'NetworkInsightsAnalysisReturnPathComponentAdditionalDetail',
    'NetworkInsightsAnalysisReturnPathComponentAdditionalDetailComponent',
    'NetworkInsightsAnalysisReturnPathComponentAttachedTo',
    'NetworkInsightsAnalysisReturnPathComponentComponent',
    'NetworkInsightsAnalysisReturnPathComponentDestinationVpc',
    'NetworkInsightsAnalysisReturnPathComponentInboundHeader',
    'NetworkInsightsAnalysisReturnPathComponentInboundHeaderDestinationPortRange',
    'NetworkInsightsAnalysisReturnPathComponentInboundHeaderSourcePortRange',
    'NetworkInsightsAnalysisReturnPathComponentOutboundHeader',
    'NetworkInsightsAnalysisReturnPathComponentOutboundHeaderDestinationPortRange',
    'NetworkInsightsAnalysisReturnPathComponentOutboundHeaderSourcePortRange',
    'NetworkInsightsAnalysisReturnPathComponentRouteTableRoute',
    'NetworkInsightsAnalysisReturnPathComponentSecurityGroupRule',
    'NetworkInsightsAnalysisReturnPathComponentSecurityGroupRulePortRange',
    'NetworkInsightsAnalysisReturnPathComponentSourceVpc',
    'NetworkInsightsAnalysisReturnPathComponentSubnet',
    'NetworkInsightsAnalysisReturnPathComponentTransitGateway',
    'NetworkInsightsAnalysisReturnPathComponentTransitGatewayRouteTableRoute',
    'NetworkInsightsAnalysisReturnPathComponentVpc',
    'NetworkInsightsPathFilterAtDestination',
    'NetworkInsightsPathFilterAtDestinationDestinationPortRange',
    'NetworkInsightsPathFilterAtDestinationSourcePortRange',
    'NetworkInsightsPathFilterAtSource',
    'NetworkInsightsPathFilterAtSourceDestinationPortRange',
    'NetworkInsightsPathFilterAtSourceSourcePortRange',
    'NetworkInterfaceAttachment',
    'NetworkInterfacePermissionTimeouts',
    'PeeringConnectionOptionsAccepter',
    'PeeringConnectionOptionsRequester',
    'RouteTableRoute',
    'SecurityGroupEgress',
    'SecurityGroupIngress',
    'SpotFleetRequestLaunchSpecification',
    'SpotFleetRequestLaunchSpecificationEbsBlockDevice',
    'SpotFleetRequestLaunchSpecificationEphemeralBlockDevice',
    'SpotFleetRequestLaunchSpecificationRootBlockDevice',
    'SpotFleetRequestLaunchTemplateConfig',
    'SpotFleetRequestLaunchTemplateConfigLaunchTemplateSpecification',
    'SpotFleetRequestLaunchTemplateConfigOverride',
    'SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirements',
    'SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorCount',
    'SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorTotalMemoryMib',
    'SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsBaselineEbsBandwidthMbps',
    'SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsMemoryGibPerVcpu',
    'SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsMemoryMib',
    'SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsNetworkBandwidthGbps',
    'SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsNetworkInterfaceCount',
    'SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsTotalLocalStorageGb',
    'SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsVcpuCount',
    'SpotFleetRequestSpotMaintenanceStrategies',
    'SpotFleetRequestSpotMaintenanceStrategiesCapacityRebalance',
    'SpotInstanceRequestCapacityReservationSpecification',
    'SpotInstanceRequestCapacityReservationSpecificationCapacityReservationTarget',
    'SpotInstanceRequestCpuOptions',
    'SpotInstanceRequestCreditSpecification',
    'SpotInstanceRequestEbsBlockDevice',
    'SpotInstanceRequestEnclaveOptions',
    'SpotInstanceRequestEphemeralBlockDevice',
    'SpotInstanceRequestLaunchTemplate',
    'SpotInstanceRequestMaintenanceOptions',
    'SpotInstanceRequestMetadataOptions',
    'SpotInstanceRequestNetworkInterface',
    'SpotInstanceRequestPrimaryNetworkInterface',
    'SpotInstanceRequestPrivateDnsNameOptions',
    'SpotInstanceRequestRootBlockDevice',
    'TrafficMirrorFilterRuleDestinationPortRange',
    'TrafficMirrorFilterRuleSourcePortRange',
    'VpcBlockPublicAccessExclusionTimeouts',
    'VpcBlockPublicAccessOptionsTimeouts',
    'VpcEncryptionControlResourceExclusions',
    'VpcEncryptionControlResourceExclusionsEgressOnlyInternetGateway',
    'VpcEncryptionControlResourceExclusionsElasticFileSystem',
    'VpcEncryptionControlResourceExclusionsInternetGateway',
    'VpcEncryptionControlResourceExclusionsLambda',
    'VpcEncryptionControlResourceExclusionsNatGateway',
    'VpcEncryptionControlResourceExclusionsVirtualPrivateGateway',
    'VpcEncryptionControlResourceExclusionsVpcLattice',
    'VpcEncryptionControlResourceExclusionsVpcPeering',
    'VpcEncryptionControlTimeouts',
    'VpcEndpointDnsEntry',
    'VpcEndpointDnsOptions',
    'VpcEndpointServicePrivateDnsNameConfiguration',
    'VpcEndpointSubnetConfiguration',
    'VpcIpamOperatingRegion',
    'VpcIpamPoolCidrCidrAuthorizationContext',
    'VpcIpamResourceDiscoveryOperatingRegion',
    'VpcPeeringConnectionAccepter',
    'VpcPeeringConnectionAccepterAccepter',
    'VpcPeeringConnectionAccepterRequester',
    'VpcPeeringConnectionRequester',
    'VpnConnectionRoute',
    'VpnConnectionTunnel1LogOptions',
    'VpnConnectionTunnel1LogOptionsCloudwatchLogOptions',
    'VpnConnectionTunnel2LogOptions',
    'VpnConnectionTunnel2LogOptionsCloudwatchLogOptions',
    'VpnConnectionVgwTelemetry',
    'GetAmiBlockDeviceMappingResult',
    'GetAmiFilterResult',
    'GetAmiIdsFilterResult',
    'GetAmiProductCodeResult',
    'GetCoipPoolFilterResult',
    'GetCoipPoolsFilterResult',
    'GetCustomerGatewayFilterResult',
    'GetDedicatedHostFilterResult',
    'GetEipsFilterResult',
    'GetElasticIpFilterResult',
    'GetInstanceCreditSpecificationResult',
    'GetInstanceEbsBlockDeviceResult',
    'GetInstanceEnclaveOptionResult',
    'GetInstanceEphemeralBlockDeviceResult',
    'GetInstanceFilterResult',
    'GetInstanceMaintenanceOptionResult',
    'GetInstanceMetadataOptionResult',
    'GetInstancePrivateDnsNameOptionResult',
    'GetInstanceRootBlockDeviceResult',
    'GetInstanceTypeFpgaResult',
    'GetInstanceTypeGpusResult',
    'GetInstanceTypeInferenceAcceleratorResult',
    'GetInstanceTypeInstanceDiskResult',
    'GetInstanceTypeMediaAcceleratorResult',
    'GetInstanceTypeNetworkCardResult',
    'GetInstanceTypeNeuronDeviceResult',
    'GetInstanceTypeOfferingFilterResult',
    'GetInstanceTypeOfferingsFilterResult',
    'GetInstanceTypesFilterResult',
    'GetInstancesFilterResult',
    'GetInternetGatewayAttachmentResult',
    'GetInternetGatewayFilterResult',
    'GetKeyPairFilterResult',
    'GetLaunchConfigurationEbsBlockDeviceResult',
    'GetLaunchConfigurationEphemeralBlockDeviceResult',
    'GetLaunchConfigurationMetadataOptionResult',
    'GetLaunchConfigurationRootBlockDeviceResult',
    'GetLaunchTemplateBlockDeviceMappingResult',
    'GetLaunchTemplateBlockDeviceMappingEbResult',
    'GetLaunchTemplateCapacityReservationSpecificationResult',
    'GetLaunchTemplateCapacityReservationSpecificationCapacityReservationTargetResult',
    'GetLaunchTemplateCpuOptionResult',
    'GetLaunchTemplateCreditSpecificationResult',
    'GetLaunchTemplateEnclaveOptionResult',
    'GetLaunchTemplateFilterResult',
    'GetLaunchTemplateHibernationOptionResult',
    'GetLaunchTemplateIamInstanceProfileResult',
    'GetLaunchTemplateInstanceMarketOptionResult',
    'GetLaunchTemplateInstanceMarketOptionSpotOptionResult',
    'GetLaunchTemplateInstanceRequirementResult',
    'GetLaunchTemplateInstanceRequirementAcceleratorCountResult',
    'GetLaunchTemplateInstanceRequirementAcceleratorTotalMemoryMibResult',
    'GetLaunchTemplateInstanceRequirementBaselineEbsBandwidthMbpResult',
    'GetLaunchTemplateInstanceRequirementMemoryGibPerVcpusResult',
    'GetLaunchTemplateInstanceRequirementMemoryMibResult',
    'GetLaunchTemplateInstanceRequirementNetworkBandwidthGbpResult',
    'GetLaunchTemplateInstanceRequirementNetworkInterfaceCountResult',
    'GetLaunchTemplateInstanceRequirementTotalLocalStorageGbResult',
    'GetLaunchTemplateInstanceRequirementVcpuCountResult',
    'GetLaunchTemplateLicenseSpecificationResult',
    'GetLaunchTemplateMaintenanceOptionResult',
    'GetLaunchTemplateMetadataOptionResult',
    'GetLaunchTemplateMonitoringResult',
    'GetLaunchTemplateNetworkInterfaceResult',
    'GetLaunchTemplateNetworkInterfaceConnectionTrackingSpecificationResult',
    'GetLaunchTemplatePlacementResult',
    'GetLaunchTemplatePrivateDnsNameOptionResult',
    'GetLaunchTemplateTagSpecificationResult',
    'GetLocalGatewayFilterResult',
    'GetLocalGatewayRouteTableFilterResult',
    'GetLocalGatewayRouteTablesFilterResult',
    'GetLocalGatewayVirtualInterfaceFilterResult',
    'GetLocalGatewayVirtualInterfaceGroupFilterResult',
    'GetLocalGatewayVirtualInterfaceGroupsFilterResult',
    'GetLocalGatewaysFilterResult',
    'GetManagedPrefixListEntryResult',
    'GetManagedPrefixListFilterResult',
    'GetManagedPrefixListsFilterResult',
    'GetNatGatewayAvailabilityZoneAddressResult',
    'GetNatGatewayFilterResult',
    'GetNatGatewayRegionalNatGatewayAddressResult',
    'GetNatGatewaysFilterResult',
    'GetNetworkAclsFilterResult',
    'GetNetworkInsightsAnalysisAlternatePathHintResult',
    'GetNetworkInsightsAnalysisExplanationResult',
    'GetNetworkInsightsAnalysisExplanationAclResult',
    'GetNetworkInsightsAnalysisExplanationAclRuleResult',
    'GetNetworkInsightsAnalysisExplanationAclRulePortRangeResult',
    'GetNetworkInsightsAnalysisExplanationAttachedToResult',
    'GetNetworkInsightsAnalysisExplanationClassicLoadBalancerListenerResult',
    'GetNetworkInsightsAnalysisExplanationComponentResult',
    'GetNetworkInsightsAnalysisExplanationCustomerGatewayResult',
    'GetNetworkInsightsAnalysisExplanationDestinationResult',
    'GetNetworkInsightsAnalysisExplanationDestinationVpcResult',
    'GetNetworkInsightsAnalysisExplanationElasticLoadBalancerListenerResult',
    'GetNetworkInsightsAnalysisExplanationIngressRouteTableResult',
    'GetNetworkInsightsAnalysisExplanationInternetGatewayResult',
    'GetNetworkInsightsAnalysisExplanationLoadBalancerTargetGroupResult',
    'GetNetworkInsightsAnalysisExplanationNatGatewayResult',
    'GetNetworkInsightsAnalysisExplanationNetworkInterfaceResult',
    'GetNetworkInsightsAnalysisExplanationPortRangeResult',
    'GetNetworkInsightsAnalysisExplanationPrefixListResult',
    'GetNetworkInsightsAnalysisExplanationRouteTableResult',
    'GetNetworkInsightsAnalysisExplanationRouteTableRouteResult',
    'GetNetworkInsightsAnalysisExplanationSecurityGroupResult',
    'GetNetworkInsightsAnalysisExplanationSecurityGroupRuleResult',
    'GetNetworkInsightsAnalysisExplanationSecurityGroupRulePortRangeResult',
    'GetNetworkInsightsAnalysisExplanationSourceVpcResult',
    'GetNetworkInsightsAnalysisExplanationSubnetResult',
    'GetNetworkInsightsAnalysisExplanationSubnetRouteTableResult',
    'GetNetworkInsightsAnalysisExplanationTransitGatewayResult',
    'GetNetworkInsightsAnalysisExplanationTransitGatewayAttachmentResult',
    'GetNetworkInsightsAnalysisExplanationTransitGatewayRouteTableResult',
    'GetNetworkInsightsAnalysisExplanationTransitGatewayRouteTableRouteResult',
    'GetNetworkInsightsAnalysisExplanationVpcResult',
    'GetNetworkInsightsAnalysisExplanationVpcEndpointResult',
    'GetNetworkInsightsAnalysisExplanationVpcPeeringConnectionResult',
    'GetNetworkInsightsAnalysisExplanationVpnConnectionResult',
    'GetNetworkInsightsAnalysisExplanationVpnGatewayResult',
    'GetNetworkInsightsAnalysisFilterResult',
    'GetNetworkInsightsAnalysisForwardPathComponentResult',
    'GetNetworkInsightsAnalysisForwardPathComponentAclRuleResult',
    'GetNetworkInsightsAnalysisForwardPathComponentAclRulePortRangeResult',
    'GetNetworkInsightsAnalysisForwardPathComponentAdditionalDetailResult',
    'GetNetworkInsightsAnalysisForwardPathComponentAdditionalDetailComponentResult',
    'GetNetworkInsightsAnalysisForwardPathComponentAttachedToResult',
    'GetNetworkInsightsAnalysisForwardPathComponentComponentResult',
    'GetNetworkInsightsAnalysisForwardPathComponentDestinationVpcResult',
    'GetNetworkInsightsAnalysisForwardPathComponentInboundHeaderResult',
    'GetNetworkInsightsAnalysisForwardPathComponentInboundHeaderDestinationPortRangeResult',
    'GetNetworkInsightsAnalysisForwardPathComponentInboundHeaderSourcePortRangeResult',
    'GetNetworkInsightsAnalysisForwardPathComponentOutboundHeaderResult',
    'GetNetworkInsightsAnalysisForwardPathComponentOutboundHeaderDestinationPortRangeResult',
    'GetNetworkInsightsAnalysisForwardPathComponentOutboundHeaderSourcePortRangeResult',
    'GetNetworkInsightsAnalysisForwardPathComponentRouteTableRouteResult',
    'GetNetworkInsightsAnalysisForwardPathComponentSecurityGroupRuleResult',
    'GetNetworkInsightsAnalysisForwardPathComponentSecurityGroupRulePortRangeResult',
    'GetNetworkInsightsAnalysisForwardPathComponentSourceVpcResult',
    'GetNetworkInsightsAnalysisForwardPathComponentSubnetResult',
    'GetNetworkInsightsAnalysisForwardPathComponentTransitGatewayResult',
    'GetNetworkInsightsAnalysisForwardPathComponentTransitGatewayRouteTableRouteResult',
    'GetNetworkInsightsAnalysisForwardPathComponentVpcResult',
    'GetNetworkInsightsAnalysisReturnPathComponentResult',
    'GetNetworkInsightsAnalysisReturnPathComponentAclRuleResult',
    'GetNetworkInsightsAnalysisReturnPathComponentAclRulePortRangeResult',
    'GetNetworkInsightsAnalysisReturnPathComponentAdditionalDetailResult',
    'GetNetworkInsightsAnalysisReturnPathComponentAdditionalDetailComponentResult',
    'GetNetworkInsightsAnalysisReturnPathComponentAttachedToResult',
    'GetNetworkInsightsAnalysisReturnPathComponentComponentResult',
    'GetNetworkInsightsAnalysisReturnPathComponentDestinationVpcResult',
    'GetNetworkInsightsAnalysisReturnPathComponentInboundHeaderResult',
    'GetNetworkInsightsAnalysisReturnPathComponentInboundHeaderDestinationPortRangeResult',
    'GetNetworkInsightsAnalysisReturnPathComponentInboundHeaderSourcePortRangeResult',
    'GetNetworkInsightsAnalysisReturnPathComponentOutboundHeaderResult',
    'GetNetworkInsightsAnalysisReturnPathComponentOutboundHeaderDestinationPortRangeResult',
    'GetNetworkInsightsAnalysisReturnPathComponentOutboundHeaderSourcePortRangeResult',
    'GetNetworkInsightsAnalysisReturnPathComponentRouteTableRouteResult',
    'GetNetworkInsightsAnalysisReturnPathComponentSecurityGroupRuleResult',
    'GetNetworkInsightsAnalysisReturnPathComponentSecurityGroupRulePortRangeResult',
    'GetNetworkInsightsAnalysisReturnPathComponentSourceVpcResult',
    'GetNetworkInsightsAnalysisReturnPathComponentSubnetResult',
    'GetNetworkInsightsAnalysisReturnPathComponentTransitGatewayResult',
    'GetNetworkInsightsAnalysisReturnPathComponentTransitGatewayRouteTableRouteResult',
    'GetNetworkInsightsAnalysisReturnPathComponentVpcResult',
    'GetNetworkInsightsPathFilterResult',
    'GetNetworkInsightsPathFilterAtDestinationResult',
    'GetNetworkInsightsPathFilterAtDestinationDestinationPortRangeResult',
    'GetNetworkInsightsPathFilterAtDestinationSourcePortRangeResult',
    'GetNetworkInsightsPathFilterAtSourceResult',
    'GetNetworkInsightsPathFilterAtSourceDestinationPortRangeResult',
    'GetNetworkInsightsPathFilterAtSourceSourcePortRangeResult',
    'GetNetworkInterfaceAssociationResult',
    'GetNetworkInterfaceAttachmentResult',
    'GetNetworkInterfaceFilterResult',
    'GetNetworkInterfacesFilterResult',
    'GetPrefixListFilterResult',
    'GetPublicIpv4PoolPoolAddressRangeResult',
    'GetPublicIpv4PoolsFilterResult',
    'GetRouteTableAssociationResult',
    'GetRouteTableFilterResult',
    'GetRouteTableRouteResult',
    'GetRouteTablesFilterResult',
    'GetSecurityGroupFilterResult',
    'GetSecurityGroupsFilterResult',
    'GetSpotPriceFilterResult',
    'GetSubnetFilterResult',
    'GetSubnetsFilterResult',
    'GetTransitGatewayRouteTablesFilterResult',
    'GetVpcCidrBlockAssociationResult',
    'GetVpcDhcpOptionsFilterResult',
    'GetVpcEndpointDnsEntryResult',
    'GetVpcEndpointDnsOptionResult',
    'GetVpcEndpointFilterResult',
    'GetVpcEndpointServiceFilterResult',
    'GetVpcFilterResult',
    'GetVpcIpamOperatingRegionResult',
    'GetVpcIpamPoolCidrsFilterResult',
    'GetVpcIpamPoolCidrsIpamPoolCidrResult',
    'GetVpcIpamPoolFilterResult',
    'GetVpcIpamPoolsFilterResult',
    'GetVpcIpamPoolsIpamPoolResult',
    'GetVpcIpamsFilterResult',
    'GetVpcIpamsIpamResult',
    'GetVpcIpamsIpamOperatingRegionResult',
    'GetVpcPeeringConnectionCidrBlockSetResult',
    'GetVpcPeeringConnectionFilterResult',
    'GetVpcPeeringConnectionIpv6CidrBlockSetResult',
    'GetVpcPeeringConnectionPeerCidrBlockSetResult',
    'GetVpcPeeringConnectionPeerIpv6CidrBlockSetResult',
    'GetVpcPeeringConnectionsFilterResult',
    'GetVpcsFilterResult',
    'GetVpnConnectionFilterResult',
    'GetVpnConnectionRouteResult',
    'GetVpnConnectionVgwTelemetryResult',
    'GetVpnGatewayFilterResult',
]

@pulumi.output_type
class AllowedImagesSettingsImageCriterion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "creationDateCondition":
            suggest = "creation_date_condition"
        elif key == "deprecationTimeCondition":
            suggest = "deprecation_time_condition"
        elif key == "imageNames":
            suggest = "image_names"
        elif key == "imageProviders":
            suggest = "image_providers"
        elif key == "marketplaceProductCodes":
            suggest = "marketplace_product_codes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AllowedImagesSettingsImageCriterion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AllowedImagesSettingsImageCriterion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AllowedImagesSettingsImageCriterion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 creation_date_condition: Optional['outputs.AllowedImagesSettingsImageCriterionCreationDateCondition'] = None,
                 deprecation_time_condition: Optional['outputs.AllowedImagesSettingsImageCriterionDeprecationTimeCondition'] = None,
                 image_names: Optional[Sequence[_builtins.str]] = None,
                 image_providers: Optional[Sequence[_builtins.str]] = None,
                 marketplace_product_codes: Optional[Sequence[_builtins.str]] = None):
        if creation_date_condition is not None:
            pulumi.set(__self__, "creation_date_condition", creation_date_condition)
        if deprecation_time_condition is not None:
            pulumi.set(__self__, "deprecation_time_condition", deprecation_time_condition)
        if image_names is not None:
            pulumi.set(__self__, "image_names", image_names)
        if image_providers is not None:
            pulumi.set(__self__, "image_providers", image_providers)
        if marketplace_product_codes is not None:
            pulumi.set(__self__, "marketplace_product_codes", marketplace_product_codes)

    @_builtins.property
    @pulumi.getter(name="creationDateCondition")
    def creation_date_condition(self) -> Optional['outputs.AllowedImagesSettingsImageCriterionCreationDateCondition']:
        return pulumi.get(self, "creation_date_condition")

    @_builtins.property
    @pulumi.getter(name="deprecationTimeCondition")
    def deprecation_time_condition(self) -> Optional['outputs.AllowedImagesSettingsImageCriterionDeprecationTimeCondition']:
        return pulumi.get(self, "deprecation_time_condition")

    @_builtins.property
    @pulumi.getter(name="imageNames")
    def image_names(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "image_names")

    @_builtins.property
    @pulumi.getter(name="imageProviders")
    def image_providers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "image_providers")

    @_builtins.property
    @pulumi.getter(name="marketplaceProductCodes")
    def marketplace_product_codes(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "marketplace_product_codes")


@pulumi.output_type
class AllowedImagesSettingsImageCriterionCreationDateCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maximumDaysSinceCreated":
            suggest = "maximum_days_since_created"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AllowedImagesSettingsImageCriterionCreationDateCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AllowedImagesSettingsImageCriterionCreationDateCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AllowedImagesSettingsImageCriterionCreationDateCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 maximum_days_since_created: Optional[_builtins.int] = None):
        if maximum_days_since_created is not None:
            pulumi.set(__self__, "maximum_days_since_created", maximum_days_since_created)

    @_builtins.property
    @pulumi.getter(name="maximumDaysSinceCreated")
    def maximum_days_since_created(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "maximum_days_since_created")


@pulumi.output_type
class AllowedImagesSettingsImageCriterionDeprecationTimeCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maximumDaysSinceDeprecated":
            suggest = "maximum_days_since_deprecated"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AllowedImagesSettingsImageCriterionDeprecationTimeCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AllowedImagesSettingsImageCriterionDeprecationTimeCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AllowedImagesSettingsImageCriterionDeprecationTimeCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 maximum_days_since_deprecated: Optional[_builtins.int] = None):
        if maximum_days_since_deprecated is not None:
            pulumi.set(__self__, "maximum_days_since_deprecated", maximum_days_since_deprecated)

    @_builtins.property
    @pulumi.getter(name="maximumDaysSinceDeprecated")
    def maximum_days_since_deprecated(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "maximum_days_since_deprecated")


@pulumi.output_type
class AmiCopyEbsBlockDevice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "deviceName":
            suggest = "device_name"
        elif key == "outpostArn":
            suggest = "outpost_arn"
        elif key == "snapshotId":
            suggest = "snapshot_id"
        elif key == "volumeSize":
            suggest = "volume_size"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AmiCopyEbsBlockDevice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AmiCopyEbsBlockDevice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AmiCopyEbsBlockDevice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delete_on_termination: Optional[_builtins.bool] = None,
                 device_name: Optional[_builtins.str] = None,
                 encrypted: Optional[_builtins.bool] = None,
                 iops: Optional[_builtins.int] = None,
                 outpost_arn: Optional[_builtins.str] = None,
                 snapshot_id: Optional[_builtins.str] = None,
                 throughput: Optional[_builtins.int] = None,
                 volume_size: Optional[_builtins.int] = None,
                 volume_type: Optional[_builtins.str] = None):
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if outpost_arn is not None:
            pulumi.set(__self__, "outpost_arn", outpost_arn)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "delete_on_termination")

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter
    def encrypted(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "encrypted")

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "iops")

    @_builtins.property
    @pulumi.getter(name="outpostArn")
    def outpost_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "outpost_arn")

    @_builtins.property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "snapshot_id")

    @_builtins.property
    @pulumi.getter
    def throughput(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "throughput")

    @_builtins.property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "volume_size")

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class AmiCopyEphemeralBlockDevice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "virtualName":
            suggest = "virtual_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AmiCopyEphemeralBlockDevice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AmiCopyEphemeralBlockDevice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AmiCopyEphemeralBlockDevice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_name: Optional[_builtins.str] = None,
                 virtual_name: Optional[_builtins.str] = None):
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if virtual_name is not None:
            pulumi.set(__self__, "virtual_name", virtual_name)

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "virtual_name")


@pulumi.output_type
class AmiEbsBlockDevice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "outpostArn":
            suggest = "outpost_arn"
        elif key == "snapshotId":
            suggest = "snapshot_id"
        elif key == "volumeSize":
            suggest = "volume_size"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AmiEbsBlockDevice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AmiEbsBlockDevice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AmiEbsBlockDevice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_name: _builtins.str,
                 delete_on_termination: Optional[_builtins.bool] = None,
                 encrypted: Optional[_builtins.bool] = None,
                 iops: Optional[_builtins.int] = None,
                 outpost_arn: Optional[_builtins.str] = None,
                 snapshot_id: Optional[_builtins.str] = None,
                 throughput: Optional[_builtins.int] = None,
                 volume_size: Optional[_builtins.int] = None,
                 volume_type: Optional[_builtins.str] = None):
        pulumi.set(__self__, "device_name", device_name)
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if outpost_arn is not None:
            pulumi.set(__self__, "outpost_arn", outpost_arn)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> _builtins.str:
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "delete_on_termination")

    @_builtins.property
    @pulumi.getter
    def encrypted(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "encrypted")

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "iops")

    @_builtins.property
    @pulumi.getter(name="outpostArn")
    def outpost_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "outpost_arn")

    @_builtins.property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "snapshot_id")

    @_builtins.property
    @pulumi.getter
    def throughput(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "throughput")

    @_builtins.property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "volume_size")

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class AmiEphemeralBlockDevice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "virtualName":
            suggest = "virtual_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AmiEphemeralBlockDevice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AmiEphemeralBlockDevice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AmiEphemeralBlockDevice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_name: _builtins.str,
                 virtual_name: _builtins.str):
        pulumi.set(__self__, "device_name", device_name)
        pulumi.set(__self__, "virtual_name", virtual_name)

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> _builtins.str:
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> _builtins.str:
        return pulumi.get(self, "virtual_name")


@pulumi.output_type
class AmiFromInstanceEbsBlockDevice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "deviceName":
            suggest = "device_name"
        elif key == "outpostArn":
            suggest = "outpost_arn"
        elif key == "snapshotId":
            suggest = "snapshot_id"
        elif key == "volumeSize":
            suggest = "volume_size"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AmiFromInstanceEbsBlockDevice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AmiFromInstanceEbsBlockDevice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AmiFromInstanceEbsBlockDevice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delete_on_termination: Optional[_builtins.bool] = None,
                 device_name: Optional[_builtins.str] = None,
                 encrypted: Optional[_builtins.bool] = None,
                 iops: Optional[_builtins.int] = None,
                 outpost_arn: Optional[_builtins.str] = None,
                 snapshot_id: Optional[_builtins.str] = None,
                 throughput: Optional[_builtins.int] = None,
                 volume_size: Optional[_builtins.int] = None,
                 volume_type: Optional[_builtins.str] = None):
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if outpost_arn is not None:
            pulumi.set(__self__, "outpost_arn", outpost_arn)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "delete_on_termination")

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter
    def encrypted(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "encrypted")

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "iops")

    @_builtins.property
    @pulumi.getter(name="outpostArn")
    def outpost_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "outpost_arn")

    @_builtins.property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "snapshot_id")

    @_builtins.property
    @pulumi.getter
    def throughput(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "throughput")

    @_builtins.property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "volume_size")

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class AmiFromInstanceEphemeralBlockDevice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "virtualName":
            suggest = "virtual_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AmiFromInstanceEphemeralBlockDevice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AmiFromInstanceEphemeralBlockDevice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AmiFromInstanceEphemeralBlockDevice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_name: Optional[_builtins.str] = None,
                 virtual_name: Optional[_builtins.str] = None):
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if virtual_name is not None:
            pulumi.set(__self__, "virtual_name", virtual_name)

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "virtual_name")


@pulumi.output_type
class CapacityBlockReservationTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[_builtins.str] = None):
        """
        :param _builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")


@pulumi.output_type
class DefaultCreditSpecificationTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[_builtins.str] = None,
                 update: Optional[_builtins.str] = None):
        """
        :param _builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param _builtins.str update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")


@pulumi.output_type
class DefaultNetworkAclEgress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromPort":
            suggest = "from_port"
        elif key == "ruleNo":
            suggest = "rule_no"
        elif key == "toPort":
            suggest = "to_port"
        elif key == "cidrBlock":
            suggest = "cidr_block"
        elif key == "icmpCode":
            suggest = "icmp_code"
        elif key == "icmpType":
            suggest = "icmp_type"
        elif key == "ipv6CidrBlock":
            suggest = "ipv6_cidr_block"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DefaultNetworkAclEgress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DefaultNetworkAclEgress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DefaultNetworkAclEgress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: _builtins.str,
                 from_port: _builtins.int,
                 protocol: _builtins.str,
                 rule_no: _builtins.int,
                 to_port: _builtins.int,
                 cidr_block: Optional[_builtins.str] = None,
                 icmp_code: Optional[_builtins.int] = None,
                 icmp_type: Optional[_builtins.int] = None,
                 ipv6_cidr_block: Optional[_builtins.str] = None):
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "from_port", from_port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "rule_no", rule_no)
        pulumi.set(__self__, "to_port", to_port)
        if cidr_block is not None:
            pulumi.set(__self__, "cidr_block", cidr_block)
        if icmp_code is not None:
            pulumi.set(__self__, "icmp_code", icmp_code)
        if icmp_type is not None:
            pulumi.set(__self__, "icmp_type", icmp_type)
        if ipv6_cidr_block is not None:
            pulumi.set(__self__, "ipv6_cidr_block", ipv6_cidr_block)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> _builtins.int:
        return pulumi.get(self, "from_port")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="ruleNo")
    def rule_no(self) -> _builtins.int:
        return pulumi.get(self, "rule_no")

    @_builtins.property
    @pulumi.getter(name="toPort")
    def to_port(self) -> _builtins.int:
        return pulumi.get(self, "to_port")

    @_builtins.property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cidr_block")

    @_builtins.property
    @pulumi.getter(name="icmpCode")
    def icmp_code(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "icmp_code")

    @_builtins.property
    @pulumi.getter(name="icmpType")
    def icmp_type(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "icmp_type")

    @_builtins.property
    @pulumi.getter(name="ipv6CidrBlock")
    def ipv6_cidr_block(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ipv6_cidr_block")


@pulumi.output_type
class DefaultNetworkAclIngress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromPort":
            suggest = "from_port"
        elif key == "ruleNo":
            suggest = "rule_no"
        elif key == "toPort":
            suggest = "to_port"
        elif key == "cidrBlock":
            suggest = "cidr_block"
        elif key == "icmpCode":
            suggest = "icmp_code"
        elif key == "icmpType":
            suggest = "icmp_type"
        elif key == "ipv6CidrBlock":
            suggest = "ipv6_cidr_block"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DefaultNetworkAclIngress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DefaultNetworkAclIngress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DefaultNetworkAclIngress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: _builtins.str,
                 from_port: _builtins.int,
                 protocol: _builtins.str,
                 rule_no: _builtins.int,
                 to_port: _builtins.int,
                 cidr_block: Optional[_builtins.str] = None,
                 icmp_code: Optional[_builtins.int] = None,
                 icmp_type: Optional[_builtins.int] = None,
                 ipv6_cidr_block: Optional[_builtins.str] = None):
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "from_port", from_port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "rule_no", rule_no)
        pulumi.set(__self__, "to_port", to_port)
        if cidr_block is not None:
            pulumi.set(__self__, "cidr_block", cidr_block)
        if icmp_code is not None:
            pulumi.set(__self__, "icmp_code", icmp_code)
        if icmp_type is not None:
            pulumi.set(__self__, "icmp_type", icmp_type)
        if ipv6_cidr_block is not None:
            pulumi.set(__self__, "ipv6_cidr_block", ipv6_cidr_block)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> _builtins.int:
        return pulumi.get(self, "from_port")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="ruleNo")
    def rule_no(self) -> _builtins.int:
        return pulumi.get(self, "rule_no")

    @_builtins.property
    @pulumi.getter(name="toPort")
    def to_port(self) -> _builtins.int:
        return pulumi.get(self, "to_port")

    @_builtins.property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cidr_block")

    @_builtins.property
    @pulumi.getter(name="icmpCode")
    def icmp_code(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "icmp_code")

    @_builtins.property
    @pulumi.getter(name="icmpType")
    def icmp_type(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "icmp_type")

    @_builtins.property
    @pulumi.getter(name="ipv6CidrBlock")
    def ipv6_cidr_block(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ipv6_cidr_block")


@pulumi.output_type
class DefaultRouteTableRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cidrBlock":
            suggest = "cidr_block"
        elif key == "coreNetworkArn":
            suggest = "core_network_arn"
        elif key == "destinationPrefixListId":
            suggest = "destination_prefix_list_id"
        elif key == "egressOnlyGatewayId":
            suggest = "egress_only_gateway_id"
        elif key == "gatewayId":
            suggest = "gateway_id"
        elif key == "instanceId":
            suggest = "instance_id"
        elif key == "ipv6CidrBlock":
            suggest = "ipv6_cidr_block"
        elif key == "natGatewayId":
            suggest = "nat_gateway_id"
        elif key == "networkInterfaceId":
            suggest = "network_interface_id"
        elif key == "transitGatewayId":
            suggest = "transit_gateway_id"
        elif key == "vpcEndpointId":
            suggest = "vpc_endpoint_id"
        elif key == "vpcPeeringConnectionId":
            suggest = "vpc_peering_connection_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DefaultRouteTableRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DefaultRouteTableRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DefaultRouteTableRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cidr_block: Optional[_builtins.str] = None,
                 core_network_arn: Optional[_builtins.str] = None,
                 destination_prefix_list_id: Optional[_builtins.str] = None,
                 egress_only_gateway_id: Optional[_builtins.str] = None,
                 gateway_id: Optional[_builtins.str] = None,
                 instance_id: Optional[_builtins.str] = None,
                 ipv6_cidr_block: Optional[_builtins.str] = None,
                 nat_gateway_id: Optional[_builtins.str] = None,
                 network_interface_id: Optional[_builtins.str] = None,
                 transit_gateway_id: Optional[_builtins.str] = None,
                 vpc_endpoint_id: Optional[_builtins.str] = None,
                 vpc_peering_connection_id: Optional[_builtins.str] = None):
        if cidr_block is not None:
            pulumi.set(__self__, "cidr_block", cidr_block)
        if core_network_arn is not None:
            pulumi.set(__self__, "core_network_arn", core_network_arn)
        if destination_prefix_list_id is not None:
            pulumi.set(__self__, "destination_prefix_list_id", destination_prefix_list_id)
        if egress_only_gateway_id is not None:
            pulumi.set(__self__, "egress_only_gateway_id", egress_only_gateway_id)
        if gateway_id is not None:
            pulumi.set(__self__, "gateway_id", gateway_id)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if ipv6_cidr_block is not None:
            pulumi.set(__self__, "ipv6_cidr_block", ipv6_cidr_block)
        if nat_gateway_id is not None:
            pulumi.set(__self__, "nat_gateway_id", nat_gateway_id)
        if network_interface_id is not None:
            pulumi.set(__self__, "network_interface_id", network_interface_id)
        if transit_gateway_id is not None:
            pulumi.set(__self__, "transit_gateway_id", transit_gateway_id)
        if vpc_endpoint_id is not None:
            pulumi.set(__self__, "vpc_endpoint_id", vpc_endpoint_id)
        if vpc_peering_connection_id is not None:
            pulumi.set(__self__, "vpc_peering_connection_id", vpc_peering_connection_id)

    @_builtins.property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cidr_block")

    @_builtins.property
    @pulumi.getter(name="coreNetworkArn")
    def core_network_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "core_network_arn")

    @_builtins.property
    @pulumi.getter(name="destinationPrefixListId")
    def destination_prefix_list_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "destination_prefix_list_id")

    @_builtins.property
    @pulumi.getter(name="egressOnlyGatewayId")
    def egress_only_gateway_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "egress_only_gateway_id")

    @_builtins.property
    @pulumi.getter(name="gatewayId")
    def gateway_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "gateway_id")

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "instance_id")

    @_builtins.property
    @pulumi.getter(name="ipv6CidrBlock")
    def ipv6_cidr_block(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ipv6_cidr_block")

    @_builtins.property
    @pulumi.getter(name="natGatewayId")
    def nat_gateway_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "nat_gateway_id")

    @_builtins.property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "network_interface_id")

    @_builtins.property
    @pulumi.getter(name="transitGatewayId")
    def transit_gateway_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "transit_gateway_id")

    @_builtins.property
    @pulumi.getter(name="vpcEndpointId")
    def vpc_endpoint_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "vpc_endpoint_id")

    @_builtins.property
    @pulumi.getter(name="vpcPeeringConnectionId")
    def vpc_peering_connection_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "vpc_peering_connection_id")


@pulumi.output_type
class DefaultSecurityGroupEgress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromPort":
            suggest = "from_port"
        elif key == "toPort":
            suggest = "to_port"
        elif key == "cidrBlocks":
            suggest = "cidr_blocks"
        elif key == "ipv6CidrBlocks":
            suggest = "ipv6_cidr_blocks"
        elif key == "prefixListIds":
            suggest = "prefix_list_ids"
        elif key == "securityGroups":
            suggest = "security_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DefaultSecurityGroupEgress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DefaultSecurityGroupEgress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DefaultSecurityGroupEgress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_port: _builtins.int,
                 protocol: _builtins.str,
                 to_port: _builtins.int,
                 cidr_blocks: Optional[Sequence[_builtins.str]] = None,
                 description: Optional[_builtins.str] = None,
                 ipv6_cidr_blocks: Optional[Sequence[_builtins.str]] = None,
                 prefix_list_ids: Optional[Sequence[_builtins.str]] = None,
                 security_groups: Optional[Sequence[_builtins.str]] = None,
                 self: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "from_port", from_port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "to_port", to_port)
        if cidr_blocks is not None:
            pulumi.set(__self__, "cidr_blocks", cidr_blocks)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if ipv6_cidr_blocks is not None:
            pulumi.set(__self__, "ipv6_cidr_blocks", ipv6_cidr_blocks)
        if prefix_list_ids is not None:
            pulumi.set(__self__, "prefix_list_ids", prefix_list_ids)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if self is not None:
            pulumi.set(__self__, "self", self)

    @_builtins.property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> _builtins.int:
        return pulumi.get(self, "from_port")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="toPort")
    def to_port(self) -> _builtins.int:
        return pulumi.get(self, "to_port")

    @_builtins.property
    @pulumi.getter(name="cidrBlocks")
    def cidr_blocks(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "cidr_blocks")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="ipv6CidrBlocks")
    def ipv6_cidr_blocks(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "ipv6_cidr_blocks")

    @_builtins.property
    @pulumi.getter(name="prefixListIds")
    def prefix_list_ids(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "prefix_list_ids")

    @_builtins.property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "security_groups")

    @_builtins.property
    @pulumi.getter
    def self(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "self")


@pulumi.output_type
class DefaultSecurityGroupIngress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromPort":
            suggest = "from_port"
        elif key == "toPort":
            suggest = "to_port"
        elif key == "cidrBlocks":
            suggest = "cidr_blocks"
        elif key == "ipv6CidrBlocks":
            suggest = "ipv6_cidr_blocks"
        elif key == "prefixListIds":
            suggest = "prefix_list_ids"
        elif key == "securityGroups":
            suggest = "security_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DefaultSecurityGroupIngress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DefaultSecurityGroupIngress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DefaultSecurityGroupIngress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_port: _builtins.int,
                 protocol: _builtins.str,
                 to_port: _builtins.int,
                 cidr_blocks: Optional[Sequence[_builtins.str]] = None,
                 description: Optional[_builtins.str] = None,
                 ipv6_cidr_blocks: Optional[Sequence[_builtins.str]] = None,
                 prefix_list_ids: Optional[Sequence[_builtins.str]] = None,
                 security_groups: Optional[Sequence[_builtins.str]] = None,
                 self: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "from_port", from_port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "to_port", to_port)
        if cidr_blocks is not None:
            pulumi.set(__self__, "cidr_blocks", cidr_blocks)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if ipv6_cidr_blocks is not None:
            pulumi.set(__self__, "ipv6_cidr_blocks", ipv6_cidr_blocks)
        if prefix_list_ids is not None:
            pulumi.set(__self__, "prefix_list_ids", prefix_list_ids)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if self is not None:
            pulumi.set(__self__, "self", self)

    @_builtins.property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> _builtins.int:
        return pulumi.get(self, "from_port")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="toPort")
    def to_port(self) -> _builtins.int:
        return pulumi.get(self, "to_port")

    @_builtins.property
    @pulumi.getter(name="cidrBlocks")
    def cidr_blocks(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "cidr_blocks")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="ipv6CidrBlocks")
    def ipv6_cidr_blocks(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "ipv6_cidr_blocks")

    @_builtins.property
    @pulumi.getter(name="prefixListIds")
    def prefix_list_ids(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "prefix_list_ids")

    @_builtins.property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "security_groups")

    @_builtins.property
    @pulumi.getter
    def self(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "self")


@pulumi.output_type
class EipDomainNameTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[_builtins.str] = None,
                 delete: Optional[_builtins.str] = None,
                 update: Optional[_builtins.str] = None):
        """
        :param _builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param _builtins.str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param _builtins.str update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")


@pulumi.output_type
class EncryptionControlResourceExclusions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "egressOnlyInternetGateway":
            suggest = "egress_only_internet_gateway"
        elif key == "elasticFileSystem":
            suggest = "elastic_file_system"
        elif key == "internetGateway":
            suggest = "internet_gateway"
        elif key == "lambda":
            suggest = "lambda_"
        elif key == "natGateway":
            suggest = "nat_gateway"
        elif key == "virtualPrivateGateway":
            suggest = "virtual_private_gateway"
        elif key == "vpcLattice":
            suggest = "vpc_lattice"
        elif key == "vpcPeering":
            suggest = "vpc_peering"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EncryptionControlResourceExclusions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EncryptionControlResourceExclusions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EncryptionControlResourceExclusions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 egress_only_internet_gateway: 'outputs.EncryptionControlResourceExclusionsEgressOnlyInternetGateway',
                 elastic_file_system: 'outputs.EncryptionControlResourceExclusionsElasticFileSystem',
                 internet_gateway: 'outputs.EncryptionControlResourceExclusionsInternetGateway',
                 lambda_: 'outputs.EncryptionControlResourceExclusionsLambda',
                 nat_gateway: 'outputs.EncryptionControlResourceExclusionsNatGateway',
                 virtual_private_gateway: 'outputs.EncryptionControlResourceExclusionsVirtualPrivateGateway',
                 vpc_lattice: 'outputs.EncryptionControlResourceExclusionsVpcLattice',
                 vpc_peering: 'outputs.EncryptionControlResourceExclusionsVpcPeering'):
        pulumi.set(__self__, "egress_only_internet_gateway", egress_only_internet_gateway)
        pulumi.set(__self__, "elastic_file_system", elastic_file_system)
        pulumi.set(__self__, "internet_gateway", internet_gateway)
        pulumi.set(__self__, "lambda_", lambda_)
        pulumi.set(__self__, "nat_gateway", nat_gateway)
        pulumi.set(__self__, "virtual_private_gateway", virtual_private_gateway)
        pulumi.set(__self__, "vpc_lattice", vpc_lattice)
        pulumi.set(__self__, "vpc_peering", vpc_peering)

    @_builtins.property
    @pulumi.getter(name="egressOnlyInternetGateway")
    def egress_only_internet_gateway(self) -> 'outputs.EncryptionControlResourceExclusionsEgressOnlyInternetGateway':
        return pulumi.get(self, "egress_only_internet_gateway")

    @_builtins.property
    @pulumi.getter(name="elasticFileSystem")
    def elastic_file_system(self) -> 'outputs.EncryptionControlResourceExclusionsElasticFileSystem':
        return pulumi.get(self, "elastic_file_system")

    @_builtins.property
    @pulumi.getter(name="internetGateway")
    def internet_gateway(self) -> 'outputs.EncryptionControlResourceExclusionsInternetGateway':
        return pulumi.get(self, "internet_gateway")

    @_builtins.property
    @pulumi.getter(name="lambda")
    def lambda_(self) -> 'outputs.EncryptionControlResourceExclusionsLambda':
        return pulumi.get(self, "lambda_")

    @_builtins.property
    @pulumi.getter(name="natGateway")
    def nat_gateway(self) -> 'outputs.EncryptionControlResourceExclusionsNatGateway':
        return pulumi.get(self, "nat_gateway")

    @_builtins.property
    @pulumi.getter(name="virtualPrivateGateway")
    def virtual_private_gateway(self) -> 'outputs.EncryptionControlResourceExclusionsVirtualPrivateGateway':
        return pulumi.get(self, "virtual_private_gateway")

    @_builtins.property
    @pulumi.getter(name="vpcLattice")
    def vpc_lattice(self) -> 'outputs.EncryptionControlResourceExclusionsVpcLattice':
        return pulumi.get(self, "vpc_lattice")

    @_builtins.property
    @pulumi.getter(name="vpcPeering")
    def vpc_peering(self) -> 'outputs.EncryptionControlResourceExclusionsVpcPeering':
        return pulumi.get(self, "vpc_peering")


@pulumi.output_type
class EncryptionControlResourceExclusionsEgressOnlyInternetGateway(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "stateMessage":
            suggest = "state_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EncryptionControlResourceExclusionsEgressOnlyInternetGateway. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EncryptionControlResourceExclusionsEgressOnlyInternetGateway.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EncryptionControlResourceExclusionsEgressOnlyInternetGateway.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 state: _builtins.str,
                 state_message: _builtins.str):
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "state_message", state_message)

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="stateMessage")
    def state_message(self) -> _builtins.str:
        return pulumi.get(self, "state_message")


@pulumi.output_type
class EncryptionControlResourceExclusionsElasticFileSystem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "stateMessage":
            suggest = "state_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EncryptionControlResourceExclusionsElasticFileSystem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EncryptionControlResourceExclusionsElasticFileSystem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EncryptionControlResourceExclusionsElasticFileSystem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 state: _builtins.str,
                 state_message: _builtins.str):
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "state_message", state_message)

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="stateMessage")
    def state_message(self) -> _builtins.str:
        return pulumi.get(self, "state_message")


@pulumi.output_type
class EncryptionControlResourceExclusionsInternetGateway(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "stateMessage":
            suggest = "state_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EncryptionControlResourceExclusionsInternetGateway. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EncryptionControlResourceExclusionsInternetGateway.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EncryptionControlResourceExclusionsInternetGateway.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 state: _builtins.str,
                 state_message: _builtins.str):
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "state_message", state_message)

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="stateMessage")
    def state_message(self) -> _builtins.str:
        return pulumi.get(self, "state_message")


@pulumi.output_type
class EncryptionControlResourceExclusionsLambda(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "stateMessage":
            suggest = "state_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EncryptionControlResourceExclusionsLambda. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EncryptionControlResourceExclusionsLambda.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EncryptionControlResourceExclusionsLambda.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 state: _builtins.str,
                 state_message: _builtins.str):
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "state_message", state_message)

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="stateMessage")
    def state_message(self) -> _builtins.str:
        return pulumi.get(self, "state_message")


@pulumi.output_type
class EncryptionControlResourceExclusionsNatGateway(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "stateMessage":
            suggest = "state_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EncryptionControlResourceExclusionsNatGateway. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EncryptionControlResourceExclusionsNatGateway.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EncryptionControlResourceExclusionsNatGateway.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 state: _builtins.str,
                 state_message: _builtins.str):
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "state_message", state_message)

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="stateMessage")
    def state_message(self) -> _builtins.str:
        return pulumi.get(self, "state_message")


@pulumi.output_type
class EncryptionControlResourceExclusionsVirtualPrivateGateway(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "stateMessage":
            suggest = "state_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EncryptionControlResourceExclusionsVirtualPrivateGateway. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EncryptionControlResourceExclusionsVirtualPrivateGateway.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EncryptionControlResourceExclusionsVirtualPrivateGateway.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 state: _builtins.str,
                 state_message: _builtins.str):
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "state_message", state_message)

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="stateMessage")
    def state_message(self) -> _builtins.str:
        return pulumi.get(self, "state_message")


@pulumi.output_type
class EncryptionControlResourceExclusionsVpcLattice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "stateMessage":
            suggest = "state_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EncryptionControlResourceExclusionsVpcLattice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EncryptionControlResourceExclusionsVpcLattice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EncryptionControlResourceExclusionsVpcLattice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 state: _builtins.str,
                 state_message: _builtins.str):
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "state_message", state_message)

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="stateMessage")
    def state_message(self) -> _builtins.str:
        return pulumi.get(self, "state_message")


@pulumi.output_type
class EncryptionControlResourceExclusionsVpcPeering(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "stateMessage":
            suggest = "state_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EncryptionControlResourceExclusionsVpcPeering. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EncryptionControlResourceExclusionsVpcPeering.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EncryptionControlResourceExclusionsVpcPeering.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 state: _builtins.str,
                 state_message: _builtins.str):
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "state_message", state_message)

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="stateMessage")
    def state_message(self) -> _builtins.str:
        return pulumi.get(self, "state_message")


@pulumi.output_type
class EncryptionControlTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[_builtins.str] = None,
                 delete: Optional[_builtins.str] = None,
                 update: Optional[_builtins.str] = None):
        """
        :param _builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param _builtins.str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param _builtins.str update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")


@pulumi.output_type
class FleetFleetInstanceSet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceIds":
            suggest = "instance_ids"
        elif key == "instanceType":
            suggest = "instance_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FleetFleetInstanceSet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FleetFleetInstanceSet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FleetFleetInstanceSet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_ids: Optional[Sequence[_builtins.str]] = None,
                 instance_type: Optional[_builtins.str] = None,
                 lifecycle: Optional[_builtins.str] = None,
                 platform: Optional[_builtins.str] = None):
        if instance_ids is not None:
            pulumi.set(__self__, "instance_ids", instance_ids)
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if lifecycle is not None:
            pulumi.set(__self__, "lifecycle", lifecycle)
        if platform is not None:
            pulumi.set(__self__, "platform", platform)

    @_builtins.property
    @pulumi.getter(name="instanceIds")
    def instance_ids(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "instance_ids")

    @_builtins.property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "instance_type")

    @_builtins.property
    @pulumi.getter
    def lifecycle(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "lifecycle")

    @_builtins.property
    @pulumi.getter
    def platform(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "platform")


@pulumi.output_type
class FleetLaunchTemplateConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "launchTemplateSpecification":
            suggest = "launch_template_specification"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FleetLaunchTemplateConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FleetLaunchTemplateConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FleetLaunchTemplateConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 launch_template_specification: Optional['outputs.FleetLaunchTemplateConfigLaunchTemplateSpecification'] = None,
                 overrides: Optional[Sequence['outputs.FleetLaunchTemplateConfigOverride']] = None):
        if launch_template_specification is not None:
            pulumi.set(__self__, "launch_template_specification", launch_template_specification)
        if overrides is not None:
            pulumi.set(__self__, "overrides", overrides)

    @_builtins.property
    @pulumi.getter(name="launchTemplateSpecification")
    def launch_template_specification(self) -> Optional['outputs.FleetLaunchTemplateConfigLaunchTemplateSpecification']:
        return pulumi.get(self, "launch_template_specification")

    @_builtins.property
    @pulumi.getter
    def overrides(self) -> Optional[Sequence['outputs.FleetLaunchTemplateConfigOverride']]:
        return pulumi.get(self, "overrides")


@pulumi.output_type
class FleetLaunchTemplateConfigLaunchTemplateSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "launchTemplateId":
            suggest = "launch_template_id"
        elif key == "launchTemplateName":
            suggest = "launch_template_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FleetLaunchTemplateConfigLaunchTemplateSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FleetLaunchTemplateConfigLaunchTemplateSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FleetLaunchTemplateConfigLaunchTemplateSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 version: _builtins.str,
                 launch_template_id: Optional[_builtins.str] = None,
                 launch_template_name: Optional[_builtins.str] = None):
        pulumi.set(__self__, "version", version)
        if launch_template_id is not None:
            pulumi.set(__self__, "launch_template_id", launch_template_id)
        if launch_template_name is not None:
            pulumi.set(__self__, "launch_template_name", launch_template_name)

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        return pulumi.get(self, "version")

    @_builtins.property
    @pulumi.getter(name="launchTemplateId")
    def launch_template_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "launch_template_id")

    @_builtins.property
    @pulumi.getter(name="launchTemplateName")
    def launch_template_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "launch_template_name")


@pulumi.output_type
class FleetLaunchTemplateConfigOverride(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "instanceRequirements":
            suggest = "instance_requirements"
        elif key == "instanceType":
            suggest = "instance_type"
        elif key == "maxPrice":
            suggest = "max_price"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "weightedCapacity":
            suggest = "weighted_capacity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FleetLaunchTemplateConfigOverride. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FleetLaunchTemplateConfigOverride.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FleetLaunchTemplateConfigOverride.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_zone: Optional[_builtins.str] = None,
                 instance_requirements: Optional['outputs.FleetLaunchTemplateConfigOverrideInstanceRequirements'] = None,
                 instance_type: Optional[_builtins.str] = None,
                 max_price: Optional[_builtins.str] = None,
                 priority: Optional[_builtins.float] = None,
                 subnet_id: Optional[_builtins.str] = None,
                 weighted_capacity: Optional[_builtins.float] = None):
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if instance_requirements is not None:
            pulumi.set(__self__, "instance_requirements", instance_requirements)
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if max_price is not None:
            pulumi.set(__self__, "max_price", max_price)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if weighted_capacity is not None:
            pulumi.set(__self__, "weighted_capacity", weighted_capacity)

    @_builtins.property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "availability_zone")

    @_builtins.property
    @pulumi.getter(name="instanceRequirements")
    def instance_requirements(self) -> Optional['outputs.FleetLaunchTemplateConfigOverrideInstanceRequirements']:
        return pulumi.get(self, "instance_requirements")

    @_builtins.property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "instance_type")

    @_builtins.property
    @pulumi.getter(name="maxPrice")
    def max_price(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "max_price")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter(name="weightedCapacity")
    def weighted_capacity(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "weighted_capacity")


@pulumi.output_type
class FleetLaunchTemplateConfigOverrideInstanceRequirements(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "memoryMib":
            suggest = "memory_mib"
        elif key == "vcpuCount":
            suggest = "vcpu_count"
        elif key == "acceleratorCount":
            suggest = "accelerator_count"
        elif key == "acceleratorManufacturers":
            suggest = "accelerator_manufacturers"
        elif key == "acceleratorNames":
            suggest = "accelerator_names"
        elif key == "acceleratorTotalMemoryMib":
            suggest = "accelerator_total_memory_mib"
        elif key == "acceleratorTypes":
            suggest = "accelerator_types"
        elif key == "allowedInstanceTypes":
            suggest = "allowed_instance_types"
        elif key == "bareMetal":
            suggest = "bare_metal"
        elif key == "baselineEbsBandwidthMbps":
            suggest = "baseline_ebs_bandwidth_mbps"
        elif key == "burstablePerformance":
            suggest = "burstable_performance"
        elif key == "cpuManufacturers":
            suggest = "cpu_manufacturers"
        elif key == "excludedInstanceTypes":
            suggest = "excluded_instance_types"
        elif key == "instanceGenerations":
            suggest = "instance_generations"
        elif key == "localStorage":
            suggest = "local_storage"
        elif key == "localStorageTypes":
            suggest = "local_storage_types"
        elif key == "maxSpotPriceAsPercentageOfOptimalOnDemandPrice":
            suggest = "max_spot_price_as_percentage_of_optimal_on_demand_price"
        elif key == "memoryGibPerVcpu":
            suggest = "memory_gib_per_vcpu"
        elif key == "networkBandwidthGbps":
            suggest = "network_bandwidth_gbps"
        elif key == "networkInterfaceCount":
            suggest = "network_interface_count"
        elif key == "onDemandMaxPricePercentageOverLowestPrice":
            suggest = "on_demand_max_price_percentage_over_lowest_price"
        elif key == "requireHibernateSupport":
            suggest = "require_hibernate_support"
        elif key == "spotMaxPricePercentageOverLowestPrice":
            suggest = "spot_max_price_percentage_over_lowest_price"
        elif key == "totalLocalStorageGb":
            suggest = "total_local_storage_gb"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FleetLaunchTemplateConfigOverrideInstanceRequirements. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FleetLaunchTemplateConfigOverrideInstanceRequirements.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FleetLaunchTemplateConfigOverrideInstanceRequirements.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 memory_mib: 'outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsMemoryMib',
                 vcpu_count: 'outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsVcpuCount',
                 accelerator_count: Optional['outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorCount'] = None,
                 accelerator_manufacturers: Optional[Sequence[_builtins.str]] = None,
                 accelerator_names: Optional[Sequence[_builtins.str]] = None,
                 accelerator_total_memory_mib: Optional['outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorTotalMemoryMib'] = None,
                 accelerator_types: Optional[Sequence[_builtins.str]] = None,
                 allowed_instance_types: Optional[Sequence[_builtins.str]] = None,
                 bare_metal: Optional[_builtins.str] = None,
                 baseline_ebs_bandwidth_mbps: Optional['outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsBaselineEbsBandwidthMbps'] = None,
                 burstable_performance: Optional[_builtins.str] = None,
                 cpu_manufacturers: Optional[Sequence[_builtins.str]] = None,
                 excluded_instance_types: Optional[Sequence[_builtins.str]] = None,
                 instance_generations: Optional[Sequence[_builtins.str]] = None,
                 local_storage: Optional[_builtins.str] = None,
                 local_storage_types: Optional[Sequence[_builtins.str]] = None,
                 max_spot_price_as_percentage_of_optimal_on_demand_price: Optional[_builtins.int] = None,
                 memory_gib_per_vcpu: Optional['outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsMemoryGibPerVcpu'] = None,
                 network_bandwidth_gbps: Optional['outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsNetworkBandwidthGbps'] = None,
                 network_interface_count: Optional['outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsNetworkInterfaceCount'] = None,
                 on_demand_max_price_percentage_over_lowest_price: Optional[_builtins.int] = None,
                 require_hibernate_support: Optional[_builtins.bool] = None,
                 spot_max_price_percentage_over_lowest_price: Optional[_builtins.int] = None,
                 total_local_storage_gb: Optional['outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsTotalLocalStorageGb'] = None):
        pulumi.set(__self__, "memory_mib", memory_mib)
        pulumi.set(__self__, "vcpu_count", vcpu_count)
        if accelerator_count is not None:
            pulumi.set(__self__, "accelerator_count", accelerator_count)
        if accelerator_manufacturers is not None:
            pulumi.set(__self__, "accelerator_manufacturers", accelerator_manufacturers)
        if accelerator_names is not None:
            pulumi.set(__self__, "accelerator_names", accelerator_names)
        if accelerator_total_memory_mib is not None:
            pulumi.set(__self__, "accelerator_total_memory_mib", accelerator_total_memory_mib)
        if accelerator_types is not None:
            pulumi.set(__self__, "accelerator_types", accelerator_types)
        if allowed_instance_types is not None:
            pulumi.set(__self__, "allowed_instance_types", allowed_instance_types)
        if bare_metal is not None:
            pulumi.set(__self__, "bare_metal", bare_metal)
        if baseline_ebs_bandwidth_mbps is not None:
            pulumi.set(__self__, "baseline_ebs_bandwidth_mbps", baseline_ebs_bandwidth_mbps)
        if burstable_performance is not None:
            pulumi.set(__self__, "burstable_performance", burstable_performance)
        if cpu_manufacturers is not None:
            pulumi.set(__self__, "cpu_manufacturers", cpu_manufacturers)
        if excluded_instance_types is not None:
            pulumi.set(__self__, "excluded_instance_types", excluded_instance_types)
        if instance_generations is not None:
            pulumi.set(__self__, "instance_generations", instance_generations)
        if local_storage is not None:
            pulumi.set(__self__, "local_storage", local_storage)
        if local_storage_types is not None:
            pulumi.set(__self__, "local_storage_types", local_storage_types)
        if max_spot_price_as_percentage_of_optimal_on_demand_price is not None:
            pulumi.set(__self__, "max_spot_price_as_percentage_of_optimal_on_demand_price", max_spot_price_as_percentage_of_optimal_on_demand_price)
        if memory_gib_per_vcpu is not None:
            pulumi.set(__self__, "memory_gib_per_vcpu", memory_gib_per_vcpu)
        if network_bandwidth_gbps is not None:
            pulumi.set(__self__, "network_bandwidth_gbps", network_bandwidth_gbps)
        if network_interface_count is not None:
            pulumi.set(__self__, "network_interface_count", network_interface_count)
        if on_demand_max_price_percentage_over_lowest_price is not None:
            pulumi.set(__self__, "on_demand_max_price_percentage_over_lowest_price", on_demand_max_price_percentage_over_lowest_price)
        if require_hibernate_support is not None:
            pulumi.set(__self__, "require_hibernate_support", require_hibernate_support)
        if spot_max_price_percentage_over_lowest_price is not None:
            pulumi.set(__self__, "spot_max_price_percentage_over_lowest_price", spot_max_price_percentage_over_lowest_price)
        if total_local_storage_gb is not None:
            pulumi.set(__self__, "total_local_storage_gb", total_local_storage_gb)

    @_builtins.property
    @pulumi.getter(name="memoryMib")
    def memory_mib(self) -> 'outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsMemoryMib':
        return pulumi.get(self, "memory_mib")

    @_builtins.property
    @pulumi.getter(name="vcpuCount")
    def vcpu_count(self) -> 'outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsVcpuCount':
        return pulumi.get(self, "vcpu_count")

    @_builtins.property
    @pulumi.getter(name="acceleratorCount")
    def accelerator_count(self) -> Optional['outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorCount']:
        return pulumi.get(self, "accelerator_count")

    @_builtins.property
    @pulumi.getter(name="acceleratorManufacturers")
    def accelerator_manufacturers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "accelerator_manufacturers")

    @_builtins.property
    @pulumi.getter(name="acceleratorNames")
    def accelerator_names(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "accelerator_names")

    @_builtins.property
    @pulumi.getter(name="acceleratorTotalMemoryMib")
    def accelerator_total_memory_mib(self) -> Optional['outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorTotalMemoryMib']:
        return pulumi.get(self, "accelerator_total_memory_mib")

    @_builtins.property
    @pulumi.getter(name="acceleratorTypes")
    def accelerator_types(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "accelerator_types")

    @_builtins.property
    @pulumi.getter(name="allowedInstanceTypes")
    def allowed_instance_types(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "allowed_instance_types")

    @_builtins.property
    @pulumi.getter(name="bareMetal")
    def bare_metal(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "bare_metal")

    @_builtins.property
    @pulumi.getter(name="baselineEbsBandwidthMbps")
    def baseline_ebs_bandwidth_mbps(self) -> Optional['outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsBaselineEbsBandwidthMbps']:
        return pulumi.get(self, "baseline_ebs_bandwidth_mbps")

    @_builtins.property
    @pulumi.getter(name="burstablePerformance")
    def burstable_performance(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "burstable_performance")

    @_builtins.property
    @pulumi.getter(name="cpuManufacturers")
    def cpu_manufacturers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "cpu_manufacturers")

    @_builtins.property
    @pulumi.getter(name="excludedInstanceTypes")
    def excluded_instance_types(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excluded_instance_types")

    @_builtins.property
    @pulumi.getter(name="instanceGenerations")
    def instance_generations(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "instance_generations")

    @_builtins.property
    @pulumi.getter(name="localStorage")
    def local_storage(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "local_storage")

    @_builtins.property
    @pulumi.getter(name="localStorageTypes")
    def local_storage_types(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "local_storage_types")

    @_builtins.property
    @pulumi.getter(name="maxSpotPriceAsPercentageOfOptimalOnDemandPrice")
    def max_spot_price_as_percentage_of_optimal_on_demand_price(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max_spot_price_as_percentage_of_optimal_on_demand_price")

    @_builtins.property
    @pulumi.getter(name="memoryGibPerVcpu")
    def memory_gib_per_vcpu(self) -> Optional['outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsMemoryGibPerVcpu']:
        return pulumi.get(self, "memory_gib_per_vcpu")

    @_builtins.property
    @pulumi.getter(name="networkBandwidthGbps")
    def network_bandwidth_gbps(self) -> Optional['outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsNetworkBandwidthGbps']:
        return pulumi.get(self, "network_bandwidth_gbps")

    @_builtins.property
    @pulumi.getter(name="networkInterfaceCount")
    def network_interface_count(self) -> Optional['outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsNetworkInterfaceCount']:
        return pulumi.get(self, "network_interface_count")

    @_builtins.property
    @pulumi.getter(name="onDemandMaxPricePercentageOverLowestPrice")
    def on_demand_max_price_percentage_over_lowest_price(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "on_demand_max_price_percentage_over_lowest_price")

    @_builtins.property
    @pulumi.getter(name="requireHibernateSupport")
    def require_hibernate_support(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "require_hibernate_support")

    @_builtins.property
    @pulumi.getter(name="spotMaxPricePercentageOverLowestPrice")
    def spot_max_price_percentage_over_lowest_price(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "spot_max_price_percentage_over_lowest_price")

    @_builtins.property
    @pulumi.getter(name="totalLocalStorageGb")
    def total_local_storage_gb(self) -> Optional['outputs.FleetLaunchTemplateConfigOverrideInstanceRequirementsTotalLocalStorageGb']:
        return pulumi.get(self, "total_local_storage_gb")


@pulumi.output_type
class FleetLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorCount(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.int] = None,
                 min: Optional[_builtins.int] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "min")


@pulumi.output_type
class FleetLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorTotalMemoryMib(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.int] = None,
                 min: Optional[_builtins.int] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "min")


@pulumi.output_type
class FleetLaunchTemplateConfigOverrideInstanceRequirementsBaselineEbsBandwidthMbps(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.int] = None,
                 min: Optional[_builtins.int] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "min")


@pulumi.output_type
class FleetLaunchTemplateConfigOverrideInstanceRequirementsMemoryGibPerVcpu(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.float] = None,
                 min: Optional[_builtins.float] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "min")


@pulumi.output_type
class FleetLaunchTemplateConfigOverrideInstanceRequirementsMemoryMib(dict):
    def __init__(__self__, *,
                 min: _builtins.int,
                 max: Optional[_builtins.int] = None):
        pulumi.set(__self__, "min", min)
        if max is not None:
            pulumi.set(__self__, "max", max)

    @_builtins.property
    @pulumi.getter
    def min(self) -> _builtins.int:
        return pulumi.get(self, "min")

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max")


@pulumi.output_type
class FleetLaunchTemplateConfigOverrideInstanceRequirementsNetworkBandwidthGbps(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.float] = None,
                 min: Optional[_builtins.float] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "min")


@pulumi.output_type
class FleetLaunchTemplateConfigOverrideInstanceRequirementsNetworkInterfaceCount(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.int] = None,
                 min: Optional[_builtins.int] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "min")


@pulumi.output_type
class FleetLaunchTemplateConfigOverrideInstanceRequirementsTotalLocalStorageGb(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.float] = None,
                 min: Optional[_builtins.float] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "min")


@pulumi.output_type
class FleetLaunchTemplateConfigOverrideInstanceRequirementsVcpuCount(dict):
    def __init__(__self__, *,
                 min: _builtins.int,
                 max: Optional[_builtins.int] = None):
        pulumi.set(__self__, "min", min)
        if max is not None:
            pulumi.set(__self__, "max", max)

    @_builtins.property
    @pulumi.getter
    def min(self) -> _builtins.int:
        return pulumi.get(self, "min")

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max")


@pulumi.output_type
class FleetOnDemandOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allocationStrategy":
            suggest = "allocation_strategy"
        elif key == "capacityReservationOptions":
            suggest = "capacity_reservation_options"
        elif key == "maxTotalPrice":
            suggest = "max_total_price"
        elif key == "minTargetCapacity":
            suggest = "min_target_capacity"
        elif key == "singleAvailabilityZone":
            suggest = "single_availability_zone"
        elif key == "singleInstanceType":
            suggest = "single_instance_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FleetOnDemandOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FleetOnDemandOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FleetOnDemandOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allocation_strategy: Optional[_builtins.str] = None,
                 capacity_reservation_options: Optional['outputs.FleetOnDemandOptionsCapacityReservationOptions'] = None,
                 max_total_price: Optional[_builtins.str] = None,
                 min_target_capacity: Optional[_builtins.int] = None,
                 single_availability_zone: Optional[_builtins.bool] = None,
                 single_instance_type: Optional[_builtins.bool] = None):
        if allocation_strategy is not None:
            pulumi.set(__self__, "allocation_strategy", allocation_strategy)
        if capacity_reservation_options is not None:
            pulumi.set(__self__, "capacity_reservation_options", capacity_reservation_options)
        if max_total_price is not None:
            pulumi.set(__self__, "max_total_price", max_total_price)
        if min_target_capacity is not None:
            pulumi.set(__self__, "min_target_capacity", min_target_capacity)
        if single_availability_zone is not None:
            pulumi.set(__self__, "single_availability_zone", single_availability_zone)
        if single_instance_type is not None:
            pulumi.set(__self__, "single_instance_type", single_instance_type)

    @_builtins.property
    @pulumi.getter(name="allocationStrategy")
    def allocation_strategy(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "allocation_strategy")

    @_builtins.property
    @pulumi.getter(name="capacityReservationOptions")
    def capacity_reservation_options(self) -> Optional['outputs.FleetOnDemandOptionsCapacityReservationOptions']:
        return pulumi.get(self, "capacity_reservation_options")

    @_builtins.property
    @pulumi.getter(name="maxTotalPrice")
    def max_total_price(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "max_total_price")

    @_builtins.property
    @pulumi.getter(name="minTargetCapacity")
    def min_target_capacity(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "min_target_capacity")

    @_builtins.property
    @pulumi.getter(name="singleAvailabilityZone")
    def single_availability_zone(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "single_availability_zone")

    @_builtins.property
    @pulumi.getter(name="singleInstanceType")
    def single_instance_type(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "single_instance_type")


@pulumi.output_type
class FleetOnDemandOptionsCapacityReservationOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "usageStrategy":
            suggest = "usage_strategy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FleetOnDemandOptionsCapacityReservationOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FleetOnDemandOptionsCapacityReservationOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FleetOnDemandOptionsCapacityReservationOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 usage_strategy: Optional[_builtins.str] = None):
        if usage_strategy is not None:
            pulumi.set(__self__, "usage_strategy", usage_strategy)

    @_builtins.property
    @pulumi.getter(name="usageStrategy")
    def usage_strategy(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "usage_strategy")


@pulumi.output_type
class FleetSpotOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allocationStrategy":
            suggest = "allocation_strategy"
        elif key == "instanceInterruptionBehavior":
            suggest = "instance_interruption_behavior"
        elif key == "instancePoolsToUseCount":
            suggest = "instance_pools_to_use_count"
        elif key == "maintenanceStrategies":
            suggest = "maintenance_strategies"
        elif key == "maxTotalPrice":
            suggest = "max_total_price"
        elif key == "minTargetCapacity":
            suggest = "min_target_capacity"
        elif key == "singleAvailabilityZone":
            suggest = "single_availability_zone"
        elif key == "singleInstanceType":
            suggest = "single_instance_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FleetSpotOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FleetSpotOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FleetSpotOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allocation_strategy: Optional[_builtins.str] = None,
                 instance_interruption_behavior: Optional[_builtins.str] = None,
                 instance_pools_to_use_count: Optional[_builtins.int] = None,
                 maintenance_strategies: Optional['outputs.FleetSpotOptionsMaintenanceStrategies'] = None,
                 max_total_price: Optional[_builtins.str] = None,
                 min_target_capacity: Optional[_builtins.int] = None,
                 single_availability_zone: Optional[_builtins.bool] = None,
                 single_instance_type: Optional[_builtins.bool] = None):
        if allocation_strategy is not None:
            pulumi.set(__self__, "allocation_strategy", allocation_strategy)
        if instance_interruption_behavior is not None:
            pulumi.set(__self__, "instance_interruption_behavior", instance_interruption_behavior)
        if instance_pools_to_use_count is not None:
            pulumi.set(__self__, "instance_pools_to_use_count", instance_pools_to_use_count)
        if maintenance_strategies is not None:
            pulumi.set(__self__, "maintenance_strategies", maintenance_strategies)
        if max_total_price is not None:
            pulumi.set(__self__, "max_total_price", max_total_price)
        if min_target_capacity is not None:
            pulumi.set(__self__, "min_target_capacity", min_target_capacity)
        if single_availability_zone is not None:
            pulumi.set(__self__, "single_availability_zone", single_availability_zone)
        if single_instance_type is not None:
            pulumi.set(__self__, "single_instance_type", single_instance_type)

    @_builtins.property
    @pulumi.getter(name="allocationStrategy")
    def allocation_strategy(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "allocation_strategy")

    @_builtins.property
    @pulumi.getter(name="instanceInterruptionBehavior")
    def instance_interruption_behavior(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "instance_interruption_behavior")

    @_builtins.property
    @pulumi.getter(name="instancePoolsToUseCount")
    def instance_pools_to_use_count(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "instance_pools_to_use_count")

    @_builtins.property
    @pulumi.getter(name="maintenanceStrategies")
    def maintenance_strategies(self) -> Optional['outputs.FleetSpotOptionsMaintenanceStrategies']:
        return pulumi.get(self, "maintenance_strategies")

    @_builtins.property
    @pulumi.getter(name="maxTotalPrice")
    def max_total_price(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "max_total_price")

    @_builtins.property
    @pulumi.getter(name="minTargetCapacity")
    def min_target_capacity(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "min_target_capacity")

    @_builtins.property
    @pulumi.getter(name="singleAvailabilityZone")
    def single_availability_zone(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "single_availability_zone")

    @_builtins.property
    @pulumi.getter(name="singleInstanceType")
    def single_instance_type(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "single_instance_type")


@pulumi.output_type
class FleetSpotOptionsMaintenanceStrategies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capacityRebalance":
            suggest = "capacity_rebalance"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FleetSpotOptionsMaintenanceStrategies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FleetSpotOptionsMaintenanceStrategies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FleetSpotOptionsMaintenanceStrategies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capacity_rebalance: Optional['outputs.FleetSpotOptionsMaintenanceStrategiesCapacityRebalance'] = None):
        if capacity_rebalance is not None:
            pulumi.set(__self__, "capacity_rebalance", capacity_rebalance)

    @_builtins.property
    @pulumi.getter(name="capacityRebalance")
    def capacity_rebalance(self) -> Optional['outputs.FleetSpotOptionsMaintenanceStrategiesCapacityRebalance']:
        return pulumi.get(self, "capacity_rebalance")


@pulumi.output_type
class FleetSpotOptionsMaintenanceStrategiesCapacityRebalance(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "replacementStrategy":
            suggest = "replacement_strategy"
        elif key == "terminationDelay":
            suggest = "termination_delay"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FleetSpotOptionsMaintenanceStrategiesCapacityRebalance. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FleetSpotOptionsMaintenanceStrategiesCapacityRebalance.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FleetSpotOptionsMaintenanceStrategiesCapacityRebalance.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 replacement_strategy: Optional[_builtins.str] = None,
                 termination_delay: Optional[_builtins.int] = None):
        if replacement_strategy is not None:
            pulumi.set(__self__, "replacement_strategy", replacement_strategy)
        if termination_delay is not None:
            pulumi.set(__self__, "termination_delay", termination_delay)

    @_builtins.property
    @pulumi.getter(name="replacementStrategy")
    def replacement_strategy(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "replacement_strategy")

    @_builtins.property
    @pulumi.getter(name="terminationDelay")
    def termination_delay(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "termination_delay")


@pulumi.output_type
class FleetTargetCapacitySpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultTargetCapacityType":
            suggest = "default_target_capacity_type"
        elif key == "totalTargetCapacity":
            suggest = "total_target_capacity"
        elif key == "onDemandTargetCapacity":
            suggest = "on_demand_target_capacity"
        elif key == "spotTargetCapacity":
            suggest = "spot_target_capacity"
        elif key == "targetCapacityUnitType":
            suggest = "target_capacity_unit_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FleetTargetCapacitySpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FleetTargetCapacitySpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FleetTargetCapacitySpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_target_capacity_type: _builtins.str,
                 total_target_capacity: _builtins.int,
                 on_demand_target_capacity: Optional[_builtins.int] = None,
                 spot_target_capacity: Optional[_builtins.int] = None,
                 target_capacity_unit_type: Optional[_builtins.str] = None):
        pulumi.set(__self__, "default_target_capacity_type", default_target_capacity_type)
        pulumi.set(__self__, "total_target_capacity", total_target_capacity)
        if on_demand_target_capacity is not None:
            pulumi.set(__self__, "on_demand_target_capacity", on_demand_target_capacity)
        if spot_target_capacity is not None:
            pulumi.set(__self__, "spot_target_capacity", spot_target_capacity)
        if target_capacity_unit_type is not None:
            pulumi.set(__self__, "target_capacity_unit_type", target_capacity_unit_type)

    @_builtins.property
    @pulumi.getter(name="defaultTargetCapacityType")
    def default_target_capacity_type(self) -> _builtins.str:
        return pulumi.get(self, "default_target_capacity_type")

    @_builtins.property
    @pulumi.getter(name="totalTargetCapacity")
    def total_target_capacity(self) -> _builtins.int:
        return pulumi.get(self, "total_target_capacity")

    @_builtins.property
    @pulumi.getter(name="onDemandTargetCapacity")
    def on_demand_target_capacity(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "on_demand_target_capacity")

    @_builtins.property
    @pulumi.getter(name="spotTargetCapacity")
    def spot_target_capacity(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "spot_target_capacity")

    @_builtins.property
    @pulumi.getter(name="targetCapacityUnitType")
    def target_capacity_unit_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "target_capacity_unit_type")


@pulumi.output_type
class FlowLogDestinationOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fileFormat":
            suggest = "file_format"
        elif key == "hiveCompatiblePartitions":
            suggest = "hive_compatible_partitions"
        elif key == "perHourPartition":
            suggest = "per_hour_partition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowLogDestinationOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowLogDestinationOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowLogDestinationOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 file_format: Optional[_builtins.str] = None,
                 hive_compatible_partitions: Optional[_builtins.bool] = None,
                 per_hour_partition: Optional[_builtins.bool] = None):
        if file_format is not None:
            pulumi.set(__self__, "file_format", file_format)
        if hive_compatible_partitions is not None:
            pulumi.set(__self__, "hive_compatible_partitions", hive_compatible_partitions)
        if per_hour_partition is not None:
            pulumi.set(__self__, "per_hour_partition", per_hour_partition)

    @_builtins.property
    @pulumi.getter(name="fileFormat")
    def file_format(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "file_format")

    @_builtins.property
    @pulumi.getter(name="hiveCompatiblePartitions")
    def hive_compatible_partitions(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "hive_compatible_partitions")

    @_builtins.property
    @pulumi.getter(name="perHourPartition")
    def per_hour_partition(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "per_hour_partition")


@pulumi.output_type
class InstanceCapacityReservationSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capacityReservationPreference":
            suggest = "capacity_reservation_preference"
        elif key == "capacityReservationTarget":
            suggest = "capacity_reservation_target"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceCapacityReservationSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceCapacityReservationSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceCapacityReservationSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capacity_reservation_preference: Optional[_builtins.str] = None,
                 capacity_reservation_target: Optional['outputs.InstanceCapacityReservationSpecificationCapacityReservationTarget'] = None):
        if capacity_reservation_preference is not None:
            pulumi.set(__self__, "capacity_reservation_preference", capacity_reservation_preference)
        if capacity_reservation_target is not None:
            pulumi.set(__self__, "capacity_reservation_target", capacity_reservation_target)

    @_builtins.property
    @pulumi.getter(name="capacityReservationPreference")
    def capacity_reservation_preference(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "capacity_reservation_preference")

    @_builtins.property
    @pulumi.getter(name="capacityReservationTarget")
    def capacity_reservation_target(self) -> Optional['outputs.InstanceCapacityReservationSpecificationCapacityReservationTarget']:
        return pulumi.get(self, "capacity_reservation_target")


@pulumi.output_type
class InstanceCapacityReservationSpecificationCapacityReservationTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capacityReservationId":
            suggest = "capacity_reservation_id"
        elif key == "capacityReservationResourceGroupArn":
            suggest = "capacity_reservation_resource_group_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceCapacityReservationSpecificationCapacityReservationTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceCapacityReservationSpecificationCapacityReservationTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceCapacityReservationSpecificationCapacityReservationTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capacity_reservation_id: Optional[_builtins.str] = None,
                 capacity_reservation_resource_group_arn: Optional[_builtins.str] = None):
        if capacity_reservation_id is not None:
            pulumi.set(__self__, "capacity_reservation_id", capacity_reservation_id)
        if capacity_reservation_resource_group_arn is not None:
            pulumi.set(__self__, "capacity_reservation_resource_group_arn", capacity_reservation_resource_group_arn)

    @_builtins.property
    @pulumi.getter(name="capacityReservationId")
    def capacity_reservation_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "capacity_reservation_id")

    @_builtins.property
    @pulumi.getter(name="capacityReservationResourceGroupArn")
    def capacity_reservation_resource_group_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "capacity_reservation_resource_group_arn")


@pulumi.output_type
class InstanceCpuOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "amdSevSnp":
            suggest = "amd_sev_snp"
        elif key == "coreCount":
            suggest = "core_count"
        elif key == "threadsPerCore":
            suggest = "threads_per_core"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceCpuOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceCpuOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceCpuOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 amd_sev_snp: Optional[_builtins.str] = None,
                 core_count: Optional[_builtins.int] = None,
                 threads_per_core: Optional[_builtins.int] = None):
        if amd_sev_snp is not None:
            pulumi.set(__self__, "amd_sev_snp", amd_sev_snp)
        if core_count is not None:
            pulumi.set(__self__, "core_count", core_count)
        if threads_per_core is not None:
            pulumi.set(__self__, "threads_per_core", threads_per_core)

    @_builtins.property
    @pulumi.getter(name="amdSevSnp")
    def amd_sev_snp(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "amd_sev_snp")

    @_builtins.property
    @pulumi.getter(name="coreCount")
    def core_count(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "core_count")

    @_builtins.property
    @pulumi.getter(name="threadsPerCore")
    def threads_per_core(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "threads_per_core")


@pulumi.output_type
class InstanceCreditSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cpuCredits":
            suggest = "cpu_credits"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceCreditSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceCreditSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceCreditSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu_credits: Optional[_builtins.str] = None):
        if cpu_credits is not None:
            pulumi.set(__self__, "cpu_credits", cpu_credits)

    @_builtins.property
    @pulumi.getter(name="cpuCredits")
    def cpu_credits(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cpu_credits")


@pulumi.output_type
class InstanceEbsBlockDevice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "snapshotId":
            suggest = "snapshot_id"
        elif key == "tagsAll":
            suggest = "tags_all"
        elif key == "volumeId":
            suggest = "volume_id"
        elif key == "volumeSize":
            suggest = "volume_size"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceEbsBlockDevice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceEbsBlockDevice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceEbsBlockDevice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_name: _builtins.str,
                 delete_on_termination: Optional[_builtins.bool] = None,
                 encrypted: Optional[_builtins.bool] = None,
                 iops: Optional[_builtins.int] = None,
                 kms_key_id: Optional[_builtins.str] = None,
                 snapshot_id: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 tags_all: Optional[Mapping[str, _builtins.str]] = None,
                 throughput: Optional[_builtins.int] = None,
                 volume_id: Optional[_builtins.str] = None,
                 volume_size: Optional[_builtins.int] = None,
                 volume_type: Optional[_builtins.str] = None):
        pulumi.set(__self__, "device_name", device_name)
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tags_all is not None:
            pulumi.set(__self__, "tags_all", tags_all)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)
        if volume_id is not None:
            pulumi.set(__self__, "volume_id", volume_id)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> _builtins.str:
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "delete_on_termination")

    @_builtins.property
    @pulumi.getter
    def encrypted(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "encrypted")

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "iops")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "snapshot_id")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="tagsAll")
    def tags_all(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "tags_all")

    @_builtins.property
    @pulumi.getter
    def throughput(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "throughput")

    @_builtins.property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "volume_id")

    @_builtins.property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "volume_size")

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class InstanceEnclaveOptions(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class InstanceEphemeralBlockDevice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "noDevice":
            suggest = "no_device"
        elif key == "virtualName":
            suggest = "virtual_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceEphemeralBlockDevice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceEphemeralBlockDevice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceEphemeralBlockDevice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_name: _builtins.str,
                 no_device: Optional[_builtins.bool] = None,
                 virtual_name: Optional[_builtins.str] = None):
        pulumi.set(__self__, "device_name", device_name)
        if no_device is not None:
            pulumi.set(__self__, "no_device", no_device)
        if virtual_name is not None:
            pulumi.set(__self__, "virtual_name", virtual_name)

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> _builtins.str:
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter(name="noDevice")
    def no_device(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "no_device")

    @_builtins.property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "virtual_name")


@pulumi.output_type
class InstanceInstanceMarketOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "marketType":
            suggest = "market_type"
        elif key == "spotOptions":
            suggest = "spot_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceInstanceMarketOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceInstanceMarketOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceInstanceMarketOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 market_type: Optional[_builtins.str] = None,
                 spot_options: Optional['outputs.InstanceInstanceMarketOptionsSpotOptions'] = None):
        if market_type is not None:
            pulumi.set(__self__, "market_type", market_type)
        if spot_options is not None:
            pulumi.set(__self__, "spot_options", spot_options)

    @_builtins.property
    @pulumi.getter(name="marketType")
    def market_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "market_type")

    @_builtins.property
    @pulumi.getter(name="spotOptions")
    def spot_options(self) -> Optional['outputs.InstanceInstanceMarketOptionsSpotOptions']:
        return pulumi.get(self, "spot_options")


@pulumi.output_type
class InstanceInstanceMarketOptionsSpotOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceInterruptionBehavior":
            suggest = "instance_interruption_behavior"
        elif key == "maxPrice":
            suggest = "max_price"
        elif key == "spotInstanceType":
            suggest = "spot_instance_type"
        elif key == "validUntil":
            suggest = "valid_until"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceInstanceMarketOptionsSpotOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceInstanceMarketOptionsSpotOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceInstanceMarketOptionsSpotOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_interruption_behavior: Optional[_builtins.str] = None,
                 max_price: Optional[_builtins.str] = None,
                 spot_instance_type: Optional[_builtins.str] = None,
                 valid_until: Optional[_builtins.str] = None):
        if instance_interruption_behavior is not None:
            pulumi.set(__self__, "instance_interruption_behavior", instance_interruption_behavior)
        if max_price is not None:
            pulumi.set(__self__, "max_price", max_price)
        if spot_instance_type is not None:
            pulumi.set(__self__, "spot_instance_type", spot_instance_type)
        if valid_until is not None:
            pulumi.set(__self__, "valid_until", valid_until)

    @_builtins.property
    @pulumi.getter(name="instanceInterruptionBehavior")
    def instance_interruption_behavior(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "instance_interruption_behavior")

    @_builtins.property
    @pulumi.getter(name="maxPrice")
    def max_price(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "max_price")

    @_builtins.property
    @pulumi.getter(name="spotInstanceType")
    def spot_instance_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "spot_instance_type")

    @_builtins.property
    @pulumi.getter(name="validUntil")
    def valid_until(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "valid_until")


@pulumi.output_type
class InstanceLaunchTemplate(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 version: Optional[_builtins.str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "version")


@pulumi.output_type
class InstanceMaintenanceOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoRecovery":
            suggest = "auto_recovery"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceMaintenanceOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceMaintenanceOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceMaintenanceOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_recovery: Optional[_builtins.str] = None):
        if auto_recovery is not None:
            pulumi.set(__self__, "auto_recovery", auto_recovery)

    @_builtins.property
    @pulumi.getter(name="autoRecovery")
    def auto_recovery(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "auto_recovery")


@pulumi.output_type
class InstanceMetadataOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpEndpoint":
            suggest = "http_endpoint"
        elif key == "httpProtocolIpv6":
            suggest = "http_protocol_ipv6"
        elif key == "httpPutResponseHopLimit":
            suggest = "http_put_response_hop_limit"
        elif key == "httpTokens":
            suggest = "http_tokens"
        elif key == "instanceMetadataTags":
            suggest = "instance_metadata_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceMetadataOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceMetadataOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceMetadataOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_endpoint: Optional[_builtins.str] = None,
                 http_protocol_ipv6: Optional[_builtins.str] = None,
                 http_put_response_hop_limit: Optional[_builtins.int] = None,
                 http_tokens: Optional[_builtins.str] = None,
                 instance_metadata_tags: Optional[_builtins.str] = None):
        if http_endpoint is not None:
            pulumi.set(__self__, "http_endpoint", http_endpoint)
        if http_protocol_ipv6 is not None:
            pulumi.set(__self__, "http_protocol_ipv6", http_protocol_ipv6)
        if http_put_response_hop_limit is not None:
            pulumi.set(__self__, "http_put_response_hop_limit", http_put_response_hop_limit)
        if http_tokens is not None:
            pulumi.set(__self__, "http_tokens", http_tokens)
        if instance_metadata_tags is not None:
            pulumi.set(__self__, "instance_metadata_tags", instance_metadata_tags)

    @_builtins.property
    @pulumi.getter(name="httpEndpoint")
    def http_endpoint(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "http_endpoint")

    @_builtins.property
    @pulumi.getter(name="httpProtocolIpv6")
    def http_protocol_ipv6(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "http_protocol_ipv6")

    @_builtins.property
    @pulumi.getter(name="httpPutResponseHopLimit")
    def http_put_response_hop_limit(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "http_put_response_hop_limit")

    @_builtins.property
    @pulumi.getter(name="httpTokens")
    def http_tokens(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "http_tokens")

    @_builtins.property
    @pulumi.getter(name="instanceMetadataTags")
    def instance_metadata_tags(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "instance_metadata_tags")


@pulumi.output_type
class InstanceNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceIndex":
            suggest = "device_index"
        elif key == "networkInterfaceId":
            suggest = "network_interface_id"
        elif key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "networkCardIndex":
            suggest = "network_card_index"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_index: _builtins.int,
                 network_interface_id: _builtins.str,
                 delete_on_termination: Optional[_builtins.bool] = None,
                 network_card_index: Optional[_builtins.int] = None):
        pulumi.set(__self__, "device_index", device_index)
        pulumi.set(__self__, "network_interface_id", network_interface_id)
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if network_card_index is not None:
            pulumi.set(__self__, "network_card_index", network_card_index)

    @_builtins.property
    @pulumi.getter(name="deviceIndex")
    def device_index(self) -> _builtins.int:
        return pulumi.get(self, "device_index")

    @_builtins.property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> _builtins.str:
        return pulumi.get(self, "network_interface_id")

    @_builtins.property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "delete_on_termination")

    @_builtins.property
    @pulumi.getter(name="networkCardIndex")
    def network_card_index(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "network_card_index")


@pulumi.output_type
class InstancePrimaryNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkInterfaceId":
            suggest = "network_interface_id"
        elif key == "deleteOnTermination":
            suggest = "delete_on_termination"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstancePrimaryNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstancePrimaryNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstancePrimaryNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 network_interface_id: _builtins.str,
                 delete_on_termination: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "network_interface_id", network_interface_id)
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)

    @_builtins.property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> _builtins.str:
        return pulumi.get(self, "network_interface_id")

    @_builtins.property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "delete_on_termination")


@pulumi.output_type
class InstancePrivateDnsNameOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableResourceNameDnsARecord":
            suggest = "enable_resource_name_dns_a_record"
        elif key == "enableResourceNameDnsAaaaRecord":
            suggest = "enable_resource_name_dns_aaaa_record"
        elif key == "hostnameType":
            suggest = "hostname_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstancePrivateDnsNameOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstancePrivateDnsNameOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstancePrivateDnsNameOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_resource_name_dns_a_record: Optional[_builtins.bool] = None,
                 enable_resource_name_dns_aaaa_record: Optional[_builtins.bool] = None,
                 hostname_type: Optional[_builtins.str] = None):
        if enable_resource_name_dns_a_record is not None:
            pulumi.set(__self__, "enable_resource_name_dns_a_record", enable_resource_name_dns_a_record)
        if enable_resource_name_dns_aaaa_record is not None:
            pulumi.set(__self__, "enable_resource_name_dns_aaaa_record", enable_resource_name_dns_aaaa_record)
        if hostname_type is not None:
            pulumi.set(__self__, "hostname_type", hostname_type)

    @_builtins.property
    @pulumi.getter(name="enableResourceNameDnsARecord")
    def enable_resource_name_dns_a_record(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enable_resource_name_dns_a_record")

    @_builtins.property
    @pulumi.getter(name="enableResourceNameDnsAaaaRecord")
    def enable_resource_name_dns_aaaa_record(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enable_resource_name_dns_aaaa_record")

    @_builtins.property
    @pulumi.getter(name="hostnameType")
    def hostname_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "hostname_type")


@pulumi.output_type
class InstanceRootBlockDevice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "deviceName":
            suggest = "device_name"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "tagsAll":
            suggest = "tags_all"
        elif key == "volumeId":
            suggest = "volume_id"
        elif key == "volumeSize":
            suggest = "volume_size"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceRootBlockDevice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceRootBlockDevice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceRootBlockDevice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delete_on_termination: Optional[_builtins.bool] = None,
                 device_name: Optional[_builtins.str] = None,
                 encrypted: Optional[_builtins.bool] = None,
                 iops: Optional[_builtins.int] = None,
                 kms_key_id: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 tags_all: Optional[Mapping[str, _builtins.str]] = None,
                 throughput: Optional[_builtins.int] = None,
                 volume_id: Optional[_builtins.str] = None,
                 volume_size: Optional[_builtins.int] = None,
                 volume_type: Optional[_builtins.str] = None):
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tags_all is not None:
            pulumi.set(__self__, "tags_all", tags_all)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)
        if volume_id is not None:
            pulumi.set(__self__, "volume_id", volume_id)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "delete_on_termination")

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter
    def encrypted(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "encrypted")

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "iops")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="tagsAll")
    def tags_all(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "tags_all")

    @_builtins.property
    @pulumi.getter
    def throughput(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "throughput")

    @_builtins.property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "volume_id")

    @_builtins.property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "volume_size")

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class LaunchConfigurationEbsBlockDevice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "noDevice":
            suggest = "no_device"
        elif key == "snapshotId":
            suggest = "snapshot_id"
        elif key == "volumeSize":
            suggest = "volume_size"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchConfigurationEbsBlockDevice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchConfigurationEbsBlockDevice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchConfigurationEbsBlockDevice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_name: _builtins.str,
                 delete_on_termination: Optional[_builtins.bool] = None,
                 encrypted: Optional[_builtins.bool] = None,
                 iops: Optional[_builtins.int] = None,
                 no_device: Optional[_builtins.bool] = None,
                 snapshot_id: Optional[_builtins.str] = None,
                 throughput: Optional[_builtins.int] = None,
                 volume_size: Optional[_builtins.int] = None,
                 volume_type: Optional[_builtins.str] = None):
        pulumi.set(__self__, "device_name", device_name)
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if no_device is not None:
            pulumi.set(__self__, "no_device", no_device)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> _builtins.str:
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "delete_on_termination")

    @_builtins.property
    @pulumi.getter
    def encrypted(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "encrypted")

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "iops")

    @_builtins.property
    @pulumi.getter(name="noDevice")
    def no_device(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "no_device")

    @_builtins.property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "snapshot_id")

    @_builtins.property
    @pulumi.getter
    def throughput(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "throughput")

    @_builtins.property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "volume_size")

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class LaunchConfigurationEphemeralBlockDevice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "noDevice":
            suggest = "no_device"
        elif key == "virtualName":
            suggest = "virtual_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchConfigurationEphemeralBlockDevice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchConfigurationEphemeralBlockDevice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchConfigurationEphemeralBlockDevice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_name: _builtins.str,
                 no_device: Optional[_builtins.bool] = None,
                 virtual_name: Optional[_builtins.str] = None):
        pulumi.set(__self__, "device_name", device_name)
        if no_device is not None:
            pulumi.set(__self__, "no_device", no_device)
        if virtual_name is not None:
            pulumi.set(__self__, "virtual_name", virtual_name)

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> _builtins.str:
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter(name="noDevice")
    def no_device(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "no_device")

    @_builtins.property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "virtual_name")


@pulumi.output_type
class LaunchConfigurationMetadataOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpEndpoint":
            suggest = "http_endpoint"
        elif key == "httpPutResponseHopLimit":
            suggest = "http_put_response_hop_limit"
        elif key == "httpTokens":
            suggest = "http_tokens"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchConfigurationMetadataOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchConfigurationMetadataOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchConfigurationMetadataOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_endpoint: Optional[_builtins.str] = None,
                 http_put_response_hop_limit: Optional[_builtins.int] = None,
                 http_tokens: Optional[_builtins.str] = None):
        if http_endpoint is not None:
            pulumi.set(__self__, "http_endpoint", http_endpoint)
        if http_put_response_hop_limit is not None:
            pulumi.set(__self__, "http_put_response_hop_limit", http_put_response_hop_limit)
        if http_tokens is not None:
            pulumi.set(__self__, "http_tokens", http_tokens)

    @_builtins.property
    @pulumi.getter(name="httpEndpoint")
    def http_endpoint(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "http_endpoint")

    @_builtins.property
    @pulumi.getter(name="httpPutResponseHopLimit")
    def http_put_response_hop_limit(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "http_put_response_hop_limit")

    @_builtins.property
    @pulumi.getter(name="httpTokens")
    def http_tokens(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "http_tokens")


@pulumi.output_type
class LaunchConfigurationRootBlockDevice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "volumeSize":
            suggest = "volume_size"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchConfigurationRootBlockDevice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchConfigurationRootBlockDevice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchConfigurationRootBlockDevice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delete_on_termination: Optional[_builtins.bool] = None,
                 encrypted: Optional[_builtins.bool] = None,
                 iops: Optional[_builtins.int] = None,
                 throughput: Optional[_builtins.int] = None,
                 volume_size: Optional[_builtins.int] = None,
                 volume_type: Optional[_builtins.str] = None):
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "delete_on_termination")

    @_builtins.property
    @pulumi.getter
    def encrypted(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "encrypted")

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "iops")

    @_builtins.property
    @pulumi.getter
    def throughput(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "throughput")

    @_builtins.property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "volume_size")

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class LaunchTemplateBlockDeviceMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "noDevice":
            suggest = "no_device"
        elif key == "virtualName":
            suggest = "virtual_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateBlockDeviceMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateBlockDeviceMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateBlockDeviceMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_name: Optional[_builtins.str] = None,
                 ebs: Optional['outputs.LaunchTemplateBlockDeviceMappingEbs'] = None,
                 no_device: Optional[_builtins.str] = None,
                 virtual_name: Optional[_builtins.str] = None):
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if ebs is not None:
            pulumi.set(__self__, "ebs", ebs)
        if no_device is not None:
            pulumi.set(__self__, "no_device", no_device)
        if virtual_name is not None:
            pulumi.set(__self__, "virtual_name", virtual_name)

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter
    def ebs(self) -> Optional['outputs.LaunchTemplateBlockDeviceMappingEbs']:
        return pulumi.get(self, "ebs")

    @_builtins.property
    @pulumi.getter(name="noDevice")
    def no_device(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "no_device")

    @_builtins.property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "virtual_name")


@pulumi.output_type
class LaunchTemplateBlockDeviceMappingEbs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "snapshotId":
            suggest = "snapshot_id"
        elif key == "volumeInitializationRate":
            suggest = "volume_initialization_rate"
        elif key == "volumeSize":
            suggest = "volume_size"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateBlockDeviceMappingEbs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateBlockDeviceMappingEbs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateBlockDeviceMappingEbs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delete_on_termination: Optional[_builtins.str] = None,
                 encrypted: Optional[_builtins.str] = None,
                 iops: Optional[_builtins.int] = None,
                 kms_key_id: Optional[_builtins.str] = None,
                 snapshot_id: Optional[_builtins.str] = None,
                 throughput: Optional[_builtins.int] = None,
                 volume_initialization_rate: Optional[_builtins.int] = None,
                 volume_size: Optional[_builtins.int] = None,
                 volume_type: Optional[_builtins.str] = None):
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)
        if volume_initialization_rate is not None:
            pulumi.set(__self__, "volume_initialization_rate", volume_initialization_rate)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "delete_on_termination")

    @_builtins.property
    @pulumi.getter
    def encrypted(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "encrypted")

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "iops")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "snapshot_id")

    @_builtins.property
    @pulumi.getter
    def throughput(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "throughput")

    @_builtins.property
    @pulumi.getter(name="volumeInitializationRate")
    def volume_initialization_rate(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "volume_initialization_rate")

    @_builtins.property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "volume_size")

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class LaunchTemplateCapacityReservationSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capacityReservationPreference":
            suggest = "capacity_reservation_preference"
        elif key == "capacityReservationTarget":
            suggest = "capacity_reservation_target"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateCapacityReservationSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateCapacityReservationSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateCapacityReservationSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capacity_reservation_preference: Optional[_builtins.str] = None,
                 capacity_reservation_target: Optional['outputs.LaunchTemplateCapacityReservationSpecificationCapacityReservationTarget'] = None):
        if capacity_reservation_preference is not None:
            pulumi.set(__self__, "capacity_reservation_preference", capacity_reservation_preference)
        if capacity_reservation_target is not None:
            pulumi.set(__self__, "capacity_reservation_target", capacity_reservation_target)

    @_builtins.property
    @pulumi.getter(name="capacityReservationPreference")
    def capacity_reservation_preference(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "capacity_reservation_preference")

    @_builtins.property
    @pulumi.getter(name="capacityReservationTarget")
    def capacity_reservation_target(self) -> Optional['outputs.LaunchTemplateCapacityReservationSpecificationCapacityReservationTarget']:
        return pulumi.get(self, "capacity_reservation_target")


@pulumi.output_type
class LaunchTemplateCapacityReservationSpecificationCapacityReservationTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capacityReservationId":
            suggest = "capacity_reservation_id"
        elif key == "capacityReservationResourceGroupArn":
            suggest = "capacity_reservation_resource_group_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateCapacityReservationSpecificationCapacityReservationTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateCapacityReservationSpecificationCapacityReservationTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateCapacityReservationSpecificationCapacityReservationTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capacity_reservation_id: Optional[_builtins.str] = None,
                 capacity_reservation_resource_group_arn: Optional[_builtins.str] = None):
        if capacity_reservation_id is not None:
            pulumi.set(__self__, "capacity_reservation_id", capacity_reservation_id)
        if capacity_reservation_resource_group_arn is not None:
            pulumi.set(__self__, "capacity_reservation_resource_group_arn", capacity_reservation_resource_group_arn)

    @_builtins.property
    @pulumi.getter(name="capacityReservationId")
    def capacity_reservation_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "capacity_reservation_id")

    @_builtins.property
    @pulumi.getter(name="capacityReservationResourceGroupArn")
    def capacity_reservation_resource_group_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "capacity_reservation_resource_group_arn")


@pulumi.output_type
class LaunchTemplateCpuOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "amdSevSnp":
            suggest = "amd_sev_snp"
        elif key == "coreCount":
            suggest = "core_count"
        elif key == "threadsPerCore":
            suggest = "threads_per_core"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateCpuOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateCpuOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateCpuOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 amd_sev_snp: Optional[_builtins.str] = None,
                 core_count: Optional[_builtins.int] = None,
                 threads_per_core: Optional[_builtins.int] = None):
        if amd_sev_snp is not None:
            pulumi.set(__self__, "amd_sev_snp", amd_sev_snp)
        if core_count is not None:
            pulumi.set(__self__, "core_count", core_count)
        if threads_per_core is not None:
            pulumi.set(__self__, "threads_per_core", threads_per_core)

    @_builtins.property
    @pulumi.getter(name="amdSevSnp")
    def amd_sev_snp(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "amd_sev_snp")

    @_builtins.property
    @pulumi.getter(name="coreCount")
    def core_count(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "core_count")

    @_builtins.property
    @pulumi.getter(name="threadsPerCore")
    def threads_per_core(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "threads_per_core")


@pulumi.output_type
class LaunchTemplateCreditSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cpuCredits":
            suggest = "cpu_credits"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateCreditSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateCreditSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateCreditSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu_credits: Optional[_builtins.str] = None):
        if cpu_credits is not None:
            pulumi.set(__self__, "cpu_credits", cpu_credits)

    @_builtins.property
    @pulumi.getter(name="cpuCredits")
    def cpu_credits(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cpu_credits")


@pulumi.output_type
class LaunchTemplateEnclaveOptions(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class LaunchTemplateHibernationOptions(dict):
    def __init__(__self__, *,
                 configured: _builtins.bool):
        pulumi.set(__self__, "configured", configured)

    @_builtins.property
    @pulumi.getter
    def configured(self) -> _builtins.bool:
        return pulumi.get(self, "configured")


@pulumi.output_type
class LaunchTemplateIamInstanceProfile(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class LaunchTemplateInstanceMarketOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "marketType":
            suggest = "market_type"
        elif key == "spotOptions":
            suggest = "spot_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateInstanceMarketOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateInstanceMarketOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateInstanceMarketOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 market_type: Optional[_builtins.str] = None,
                 spot_options: Optional['outputs.LaunchTemplateInstanceMarketOptionsSpotOptions'] = None):
        if market_type is not None:
            pulumi.set(__self__, "market_type", market_type)
        if spot_options is not None:
            pulumi.set(__self__, "spot_options", spot_options)

    @_builtins.property
    @pulumi.getter(name="marketType")
    def market_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "market_type")

    @_builtins.property
    @pulumi.getter(name="spotOptions")
    def spot_options(self) -> Optional['outputs.LaunchTemplateInstanceMarketOptionsSpotOptions']:
        return pulumi.get(self, "spot_options")


@pulumi.output_type
class LaunchTemplateInstanceMarketOptionsSpotOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blockDurationMinutes":
            suggest = "block_duration_minutes"
        elif key == "instanceInterruptionBehavior":
            suggest = "instance_interruption_behavior"
        elif key == "maxPrice":
            suggest = "max_price"
        elif key == "spotInstanceType":
            suggest = "spot_instance_type"
        elif key == "validUntil":
            suggest = "valid_until"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateInstanceMarketOptionsSpotOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateInstanceMarketOptionsSpotOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateInstanceMarketOptionsSpotOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 block_duration_minutes: Optional[_builtins.int] = None,
                 instance_interruption_behavior: Optional[_builtins.str] = None,
                 max_price: Optional[_builtins.str] = None,
                 spot_instance_type: Optional[_builtins.str] = None,
                 valid_until: Optional[_builtins.str] = None):
        if block_duration_minutes is not None:
            pulumi.set(__self__, "block_duration_minutes", block_duration_minutes)
        if instance_interruption_behavior is not None:
            pulumi.set(__self__, "instance_interruption_behavior", instance_interruption_behavior)
        if max_price is not None:
            pulumi.set(__self__, "max_price", max_price)
        if spot_instance_type is not None:
            pulumi.set(__self__, "spot_instance_type", spot_instance_type)
        if valid_until is not None:
            pulumi.set(__self__, "valid_until", valid_until)

    @_builtins.property
    @pulumi.getter(name="blockDurationMinutes")
    def block_duration_minutes(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "block_duration_minutes")

    @_builtins.property
    @pulumi.getter(name="instanceInterruptionBehavior")
    def instance_interruption_behavior(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "instance_interruption_behavior")

    @_builtins.property
    @pulumi.getter(name="maxPrice")
    def max_price(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "max_price")

    @_builtins.property
    @pulumi.getter(name="spotInstanceType")
    def spot_instance_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "spot_instance_type")

    @_builtins.property
    @pulumi.getter(name="validUntil")
    def valid_until(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "valid_until")


@pulumi.output_type
class LaunchTemplateInstanceRequirements(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "memoryMib":
            suggest = "memory_mib"
        elif key == "vcpuCount":
            suggest = "vcpu_count"
        elif key == "acceleratorCount":
            suggest = "accelerator_count"
        elif key == "acceleratorManufacturers":
            suggest = "accelerator_manufacturers"
        elif key == "acceleratorNames":
            suggest = "accelerator_names"
        elif key == "acceleratorTotalMemoryMib":
            suggest = "accelerator_total_memory_mib"
        elif key == "acceleratorTypes":
            suggest = "accelerator_types"
        elif key == "allowedInstanceTypes":
            suggest = "allowed_instance_types"
        elif key == "bareMetal":
            suggest = "bare_metal"
        elif key == "baselineEbsBandwidthMbps":
            suggest = "baseline_ebs_bandwidth_mbps"
        elif key == "burstablePerformance":
            suggest = "burstable_performance"
        elif key == "cpuManufacturers":
            suggest = "cpu_manufacturers"
        elif key == "excludedInstanceTypes":
            suggest = "excluded_instance_types"
        elif key == "instanceGenerations":
            suggest = "instance_generations"
        elif key == "localStorage":
            suggest = "local_storage"
        elif key == "localStorageTypes":
            suggest = "local_storage_types"
        elif key == "maxSpotPriceAsPercentageOfOptimalOnDemandPrice":
            suggest = "max_spot_price_as_percentage_of_optimal_on_demand_price"
        elif key == "memoryGibPerVcpu":
            suggest = "memory_gib_per_vcpu"
        elif key == "networkBandwidthGbps":
            suggest = "network_bandwidth_gbps"
        elif key == "networkInterfaceCount":
            suggest = "network_interface_count"
        elif key == "onDemandMaxPricePercentageOverLowestPrice":
            suggest = "on_demand_max_price_percentage_over_lowest_price"
        elif key == "requireHibernateSupport":
            suggest = "require_hibernate_support"
        elif key == "spotMaxPricePercentageOverLowestPrice":
            suggest = "spot_max_price_percentage_over_lowest_price"
        elif key == "totalLocalStorageGb":
            suggest = "total_local_storage_gb"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateInstanceRequirements. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateInstanceRequirements.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateInstanceRequirements.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 memory_mib: 'outputs.LaunchTemplateInstanceRequirementsMemoryMib',
                 vcpu_count: 'outputs.LaunchTemplateInstanceRequirementsVcpuCount',
                 accelerator_count: Optional['outputs.LaunchTemplateInstanceRequirementsAcceleratorCount'] = None,
                 accelerator_manufacturers: Optional[Sequence[_builtins.str]] = None,
                 accelerator_names: Optional[Sequence[_builtins.str]] = None,
                 accelerator_total_memory_mib: Optional['outputs.LaunchTemplateInstanceRequirementsAcceleratorTotalMemoryMib'] = None,
                 accelerator_types: Optional[Sequence[_builtins.str]] = None,
                 allowed_instance_types: Optional[Sequence[_builtins.str]] = None,
                 bare_metal: Optional[_builtins.str] = None,
                 baseline_ebs_bandwidth_mbps: Optional['outputs.LaunchTemplateInstanceRequirementsBaselineEbsBandwidthMbps'] = None,
                 burstable_performance: Optional[_builtins.str] = None,
                 cpu_manufacturers: Optional[Sequence[_builtins.str]] = None,
                 excluded_instance_types: Optional[Sequence[_builtins.str]] = None,
                 instance_generations: Optional[Sequence[_builtins.str]] = None,
                 local_storage: Optional[_builtins.str] = None,
                 local_storage_types: Optional[Sequence[_builtins.str]] = None,
                 max_spot_price_as_percentage_of_optimal_on_demand_price: Optional[_builtins.int] = None,
                 memory_gib_per_vcpu: Optional['outputs.LaunchTemplateInstanceRequirementsMemoryGibPerVcpu'] = None,
                 network_bandwidth_gbps: Optional['outputs.LaunchTemplateInstanceRequirementsNetworkBandwidthGbps'] = None,
                 network_interface_count: Optional['outputs.LaunchTemplateInstanceRequirementsNetworkInterfaceCount'] = None,
                 on_demand_max_price_percentage_over_lowest_price: Optional[_builtins.int] = None,
                 require_hibernate_support: Optional[_builtins.bool] = None,
                 spot_max_price_percentage_over_lowest_price: Optional[_builtins.int] = None,
                 total_local_storage_gb: Optional['outputs.LaunchTemplateInstanceRequirementsTotalLocalStorageGb'] = None):
        pulumi.set(__self__, "memory_mib", memory_mib)
        pulumi.set(__self__, "vcpu_count", vcpu_count)
        if accelerator_count is not None:
            pulumi.set(__self__, "accelerator_count", accelerator_count)
        if accelerator_manufacturers is not None:
            pulumi.set(__self__, "accelerator_manufacturers", accelerator_manufacturers)
        if accelerator_names is not None:
            pulumi.set(__self__, "accelerator_names", accelerator_names)
        if accelerator_total_memory_mib is not None:
            pulumi.set(__self__, "accelerator_total_memory_mib", accelerator_total_memory_mib)
        if accelerator_types is not None:
            pulumi.set(__self__, "accelerator_types", accelerator_types)
        if allowed_instance_types is not None:
            pulumi.set(__self__, "allowed_instance_types", allowed_instance_types)
        if bare_metal is not None:
            pulumi.set(__self__, "bare_metal", bare_metal)
        if baseline_ebs_bandwidth_mbps is not None:
            pulumi.set(__self__, "baseline_ebs_bandwidth_mbps", baseline_ebs_bandwidth_mbps)
        if burstable_performance is not None:
            pulumi.set(__self__, "burstable_performance", burstable_performance)
        if cpu_manufacturers is not None:
            pulumi.set(__self__, "cpu_manufacturers", cpu_manufacturers)
        if excluded_instance_types is not None:
            pulumi.set(__self__, "excluded_instance_types", excluded_instance_types)
        if instance_generations is not None:
            pulumi.set(__self__, "instance_generations", instance_generations)
        if local_storage is not None:
            pulumi.set(__self__, "local_storage", local_storage)
        if local_storage_types is not None:
            pulumi.set(__self__, "local_storage_types", local_storage_types)
        if max_spot_price_as_percentage_of_optimal_on_demand_price is not None:
            pulumi.set(__self__, "max_spot_price_as_percentage_of_optimal_on_demand_price", max_spot_price_as_percentage_of_optimal_on_demand_price)
        if memory_gib_per_vcpu is not None:
            pulumi.set(__self__, "memory_gib_per_vcpu", memory_gib_per_vcpu)
        if network_bandwidth_gbps is not None:
            pulumi.set(__self__, "network_bandwidth_gbps", network_bandwidth_gbps)
        if network_interface_count is not None:
            pulumi.set(__self__, "network_interface_count", network_interface_count)
        if on_demand_max_price_percentage_over_lowest_price is not None:
            pulumi.set(__self__, "on_demand_max_price_percentage_over_lowest_price", on_demand_max_price_percentage_over_lowest_price)
        if require_hibernate_support is not None:
            pulumi.set(__self__, "require_hibernate_support", require_hibernate_support)
        if spot_max_price_percentage_over_lowest_price is not None:
            pulumi.set(__self__, "spot_max_price_percentage_over_lowest_price", spot_max_price_percentage_over_lowest_price)
        if total_local_storage_gb is not None:
            pulumi.set(__self__, "total_local_storage_gb", total_local_storage_gb)

    @_builtins.property
    @pulumi.getter(name="memoryMib")
    def memory_mib(self) -> 'outputs.LaunchTemplateInstanceRequirementsMemoryMib':
        return pulumi.get(self, "memory_mib")

    @_builtins.property
    @pulumi.getter(name="vcpuCount")
    def vcpu_count(self) -> 'outputs.LaunchTemplateInstanceRequirementsVcpuCount':
        return pulumi.get(self, "vcpu_count")

    @_builtins.property
    @pulumi.getter(name="acceleratorCount")
    def accelerator_count(self) -> Optional['outputs.LaunchTemplateInstanceRequirementsAcceleratorCount']:
        return pulumi.get(self, "accelerator_count")

    @_builtins.property
    @pulumi.getter(name="acceleratorManufacturers")
    def accelerator_manufacturers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "accelerator_manufacturers")

    @_builtins.property
    @pulumi.getter(name="acceleratorNames")
    def accelerator_names(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "accelerator_names")

    @_builtins.property
    @pulumi.getter(name="acceleratorTotalMemoryMib")
    def accelerator_total_memory_mib(self) -> Optional['outputs.LaunchTemplateInstanceRequirementsAcceleratorTotalMemoryMib']:
        return pulumi.get(self, "accelerator_total_memory_mib")

    @_builtins.property
    @pulumi.getter(name="acceleratorTypes")
    def accelerator_types(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "accelerator_types")

    @_builtins.property
    @pulumi.getter(name="allowedInstanceTypes")
    def allowed_instance_types(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "allowed_instance_types")

    @_builtins.property
    @pulumi.getter(name="bareMetal")
    def bare_metal(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "bare_metal")

    @_builtins.property
    @pulumi.getter(name="baselineEbsBandwidthMbps")
    def baseline_ebs_bandwidth_mbps(self) -> Optional['outputs.LaunchTemplateInstanceRequirementsBaselineEbsBandwidthMbps']:
        return pulumi.get(self, "baseline_ebs_bandwidth_mbps")

    @_builtins.property
    @pulumi.getter(name="burstablePerformance")
    def burstable_performance(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "burstable_performance")

    @_builtins.property
    @pulumi.getter(name="cpuManufacturers")
    def cpu_manufacturers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "cpu_manufacturers")

    @_builtins.property
    @pulumi.getter(name="excludedInstanceTypes")
    def excluded_instance_types(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excluded_instance_types")

    @_builtins.property
    @pulumi.getter(name="instanceGenerations")
    def instance_generations(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "instance_generations")

    @_builtins.property
    @pulumi.getter(name="localStorage")
    def local_storage(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "local_storage")

    @_builtins.property
    @pulumi.getter(name="localStorageTypes")
    def local_storage_types(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "local_storage_types")

    @_builtins.property
    @pulumi.getter(name="maxSpotPriceAsPercentageOfOptimalOnDemandPrice")
    def max_spot_price_as_percentage_of_optimal_on_demand_price(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max_spot_price_as_percentage_of_optimal_on_demand_price")

    @_builtins.property
    @pulumi.getter(name="memoryGibPerVcpu")
    def memory_gib_per_vcpu(self) -> Optional['outputs.LaunchTemplateInstanceRequirementsMemoryGibPerVcpu']:
        return pulumi.get(self, "memory_gib_per_vcpu")

    @_builtins.property
    @pulumi.getter(name="networkBandwidthGbps")
    def network_bandwidth_gbps(self) -> Optional['outputs.LaunchTemplateInstanceRequirementsNetworkBandwidthGbps']:
        return pulumi.get(self, "network_bandwidth_gbps")

    @_builtins.property
    @pulumi.getter(name="networkInterfaceCount")
    def network_interface_count(self) -> Optional['outputs.LaunchTemplateInstanceRequirementsNetworkInterfaceCount']:
        return pulumi.get(self, "network_interface_count")

    @_builtins.property
    @pulumi.getter(name="onDemandMaxPricePercentageOverLowestPrice")
    def on_demand_max_price_percentage_over_lowest_price(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "on_demand_max_price_percentage_over_lowest_price")

    @_builtins.property
    @pulumi.getter(name="requireHibernateSupport")
    def require_hibernate_support(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "require_hibernate_support")

    @_builtins.property
    @pulumi.getter(name="spotMaxPricePercentageOverLowestPrice")
    def spot_max_price_percentage_over_lowest_price(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "spot_max_price_percentage_over_lowest_price")

    @_builtins.property
    @pulumi.getter(name="totalLocalStorageGb")
    def total_local_storage_gb(self) -> Optional['outputs.LaunchTemplateInstanceRequirementsTotalLocalStorageGb']:
        return pulumi.get(self, "total_local_storage_gb")


@pulumi.output_type
class LaunchTemplateInstanceRequirementsAcceleratorCount(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.int] = None,
                 min: Optional[_builtins.int] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "min")


@pulumi.output_type
class LaunchTemplateInstanceRequirementsAcceleratorTotalMemoryMib(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.int] = None,
                 min: Optional[_builtins.int] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "min")


@pulumi.output_type
class LaunchTemplateInstanceRequirementsBaselineEbsBandwidthMbps(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.int] = None,
                 min: Optional[_builtins.int] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "min")


@pulumi.output_type
class LaunchTemplateInstanceRequirementsMemoryGibPerVcpu(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.float] = None,
                 min: Optional[_builtins.float] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "min")


@pulumi.output_type
class LaunchTemplateInstanceRequirementsMemoryMib(dict):
    def __init__(__self__, *,
                 min: _builtins.int,
                 max: Optional[_builtins.int] = None):
        pulumi.set(__self__, "min", min)
        if max is not None:
            pulumi.set(__self__, "max", max)

    @_builtins.property
    @pulumi.getter
    def min(self) -> _builtins.int:
        return pulumi.get(self, "min")

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max")


@pulumi.output_type
class LaunchTemplateInstanceRequirementsNetworkBandwidthGbps(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.float] = None,
                 min: Optional[_builtins.float] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "min")


@pulumi.output_type
class LaunchTemplateInstanceRequirementsNetworkInterfaceCount(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.int] = None,
                 min: Optional[_builtins.int] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "min")


@pulumi.output_type
class LaunchTemplateInstanceRequirementsTotalLocalStorageGb(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.float] = None,
                 min: Optional[_builtins.float] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "min")


@pulumi.output_type
class LaunchTemplateInstanceRequirementsVcpuCount(dict):
    def __init__(__self__, *,
                 min: _builtins.int,
                 max: Optional[_builtins.int] = None):
        pulumi.set(__self__, "min", min)
        if max is not None:
            pulumi.set(__self__, "max", max)

    @_builtins.property
    @pulumi.getter
    def min(self) -> _builtins.int:
        return pulumi.get(self, "min")

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max")


@pulumi.output_type
class LaunchTemplateLicenseSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "licenseConfigurationArn":
            suggest = "license_configuration_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateLicenseSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateLicenseSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateLicenseSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 license_configuration_arn: _builtins.str):
        pulumi.set(__self__, "license_configuration_arn", license_configuration_arn)

    @_builtins.property
    @pulumi.getter(name="licenseConfigurationArn")
    def license_configuration_arn(self) -> _builtins.str:
        return pulumi.get(self, "license_configuration_arn")


@pulumi.output_type
class LaunchTemplateMaintenanceOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoRecovery":
            suggest = "auto_recovery"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateMaintenanceOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateMaintenanceOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateMaintenanceOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_recovery: Optional[_builtins.str] = None):
        if auto_recovery is not None:
            pulumi.set(__self__, "auto_recovery", auto_recovery)

    @_builtins.property
    @pulumi.getter(name="autoRecovery")
    def auto_recovery(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "auto_recovery")


@pulumi.output_type
class LaunchTemplateMetadataOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpEndpoint":
            suggest = "http_endpoint"
        elif key == "httpProtocolIpv6":
            suggest = "http_protocol_ipv6"
        elif key == "httpPutResponseHopLimit":
            suggest = "http_put_response_hop_limit"
        elif key == "httpTokens":
            suggest = "http_tokens"
        elif key == "instanceMetadataTags":
            suggest = "instance_metadata_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateMetadataOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateMetadataOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateMetadataOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_endpoint: Optional[_builtins.str] = None,
                 http_protocol_ipv6: Optional[_builtins.str] = None,
                 http_put_response_hop_limit: Optional[_builtins.int] = None,
                 http_tokens: Optional[_builtins.str] = None,
                 instance_metadata_tags: Optional[_builtins.str] = None):
        if http_endpoint is not None:
            pulumi.set(__self__, "http_endpoint", http_endpoint)
        if http_protocol_ipv6 is not None:
            pulumi.set(__self__, "http_protocol_ipv6", http_protocol_ipv6)
        if http_put_response_hop_limit is not None:
            pulumi.set(__self__, "http_put_response_hop_limit", http_put_response_hop_limit)
        if http_tokens is not None:
            pulumi.set(__self__, "http_tokens", http_tokens)
        if instance_metadata_tags is not None:
            pulumi.set(__self__, "instance_metadata_tags", instance_metadata_tags)

    @_builtins.property
    @pulumi.getter(name="httpEndpoint")
    def http_endpoint(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "http_endpoint")

    @_builtins.property
    @pulumi.getter(name="httpProtocolIpv6")
    def http_protocol_ipv6(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "http_protocol_ipv6")

    @_builtins.property
    @pulumi.getter(name="httpPutResponseHopLimit")
    def http_put_response_hop_limit(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "http_put_response_hop_limit")

    @_builtins.property
    @pulumi.getter(name="httpTokens")
    def http_tokens(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "http_tokens")

    @_builtins.property
    @pulumi.getter(name="instanceMetadataTags")
    def instance_metadata_tags(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "instance_metadata_tags")


@pulumi.output_type
class LaunchTemplateMonitoring(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class LaunchTemplateNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "associateCarrierIpAddress":
            suggest = "associate_carrier_ip_address"
        elif key == "associatePublicIpAddress":
            suggest = "associate_public_ip_address"
        elif key == "connectionTrackingSpecification":
            suggest = "connection_tracking_specification"
        elif key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "deviceIndex":
            suggest = "device_index"
        elif key == "enaSrdSpecification":
            suggest = "ena_srd_specification"
        elif key == "interfaceType":
            suggest = "interface_type"
        elif key == "ipv4AddressCount":
            suggest = "ipv4_address_count"
        elif key == "ipv4Addresses":
            suggest = "ipv4_addresses"
        elif key == "ipv4PrefixCount":
            suggest = "ipv4_prefix_count"
        elif key == "ipv4Prefixes":
            suggest = "ipv4_prefixes"
        elif key == "ipv6AddressCount":
            suggest = "ipv6_address_count"
        elif key == "ipv6Addresses":
            suggest = "ipv6_addresses"
        elif key == "ipv6PrefixCount":
            suggest = "ipv6_prefix_count"
        elif key == "ipv6Prefixes":
            suggest = "ipv6_prefixes"
        elif key == "networkCardIndex":
            suggest = "network_card_index"
        elif key == "networkInterfaceId":
            suggest = "network_interface_id"
        elif key == "primaryIpv6":
            suggest = "primary_ipv6"
        elif key == "privateIpAddress":
            suggest = "private_ip_address"
        elif key == "securityGroups":
            suggest = "security_groups"
        elif key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 associate_carrier_ip_address: Optional[_builtins.str] = None,
                 associate_public_ip_address: Optional[_builtins.str] = None,
                 connection_tracking_specification: Optional['outputs.LaunchTemplateNetworkInterfaceConnectionTrackingSpecification'] = None,
                 delete_on_termination: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 device_index: Optional[_builtins.int] = None,
                 ena_srd_specification: Optional['outputs.LaunchTemplateNetworkInterfaceEnaSrdSpecification'] = None,
                 interface_type: Optional[_builtins.str] = None,
                 ipv4_address_count: Optional[_builtins.int] = None,
                 ipv4_addresses: Optional[Sequence[_builtins.str]] = None,
                 ipv4_prefix_count: Optional[_builtins.int] = None,
                 ipv4_prefixes: Optional[Sequence[_builtins.str]] = None,
                 ipv6_address_count: Optional[_builtins.int] = None,
                 ipv6_addresses: Optional[Sequence[_builtins.str]] = None,
                 ipv6_prefix_count: Optional[_builtins.int] = None,
                 ipv6_prefixes: Optional[Sequence[_builtins.str]] = None,
                 network_card_index: Optional[_builtins.int] = None,
                 network_interface_id: Optional[_builtins.str] = None,
                 primary_ipv6: Optional[_builtins.str] = None,
                 private_ip_address: Optional[_builtins.str] = None,
                 security_groups: Optional[Sequence[_builtins.str]] = None,
                 subnet_id: Optional[_builtins.str] = None):
        if associate_carrier_ip_address is not None:
            pulumi.set(__self__, "associate_carrier_ip_address", associate_carrier_ip_address)
        if associate_public_ip_address is not None:
            pulumi.set(__self__, "associate_public_ip_address", associate_public_ip_address)
        if connection_tracking_specification is not None:
            pulumi.set(__self__, "connection_tracking_specification", connection_tracking_specification)
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if device_index is not None:
            pulumi.set(__self__, "device_index", device_index)
        if ena_srd_specification is not None:
            pulumi.set(__self__, "ena_srd_specification", ena_srd_specification)
        if interface_type is not None:
            pulumi.set(__self__, "interface_type", interface_type)
        if ipv4_address_count is not None:
            pulumi.set(__self__, "ipv4_address_count", ipv4_address_count)
        if ipv4_addresses is not None:
            pulumi.set(__self__, "ipv4_addresses", ipv4_addresses)
        if ipv4_prefix_count is not None:
            pulumi.set(__self__, "ipv4_prefix_count", ipv4_prefix_count)
        if ipv4_prefixes is not None:
            pulumi.set(__self__, "ipv4_prefixes", ipv4_prefixes)
        if ipv6_address_count is not None:
            pulumi.set(__self__, "ipv6_address_count", ipv6_address_count)
        if ipv6_addresses is not None:
            pulumi.set(__self__, "ipv6_addresses", ipv6_addresses)
        if ipv6_prefix_count is not None:
            pulumi.set(__self__, "ipv6_prefix_count", ipv6_prefix_count)
        if ipv6_prefixes is not None:
            pulumi.set(__self__, "ipv6_prefixes", ipv6_prefixes)
        if network_card_index is not None:
            pulumi.set(__self__, "network_card_index", network_card_index)
        if network_interface_id is not None:
            pulumi.set(__self__, "network_interface_id", network_interface_id)
        if primary_ipv6 is not None:
            pulumi.set(__self__, "primary_ipv6", primary_ipv6)
        if private_ip_address is not None:
            pulumi.set(__self__, "private_ip_address", private_ip_address)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="associateCarrierIpAddress")
    def associate_carrier_ip_address(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "associate_carrier_ip_address")

    @_builtins.property
    @pulumi.getter(name="associatePublicIpAddress")
    def associate_public_ip_address(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "associate_public_ip_address")

    @_builtins.property
    @pulumi.getter(name="connectionTrackingSpecification")
    def connection_tracking_specification(self) -> Optional['outputs.LaunchTemplateNetworkInterfaceConnectionTrackingSpecification']:
        return pulumi.get(self, "connection_tracking_specification")

    @_builtins.property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "delete_on_termination")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="deviceIndex")
    def device_index(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "device_index")

    @_builtins.property
    @pulumi.getter(name="enaSrdSpecification")
    def ena_srd_specification(self) -> Optional['outputs.LaunchTemplateNetworkInterfaceEnaSrdSpecification']:
        return pulumi.get(self, "ena_srd_specification")

    @_builtins.property
    @pulumi.getter(name="interfaceType")
    def interface_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "interface_type")

    @_builtins.property
    @pulumi.getter(name="ipv4AddressCount")
    def ipv4_address_count(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "ipv4_address_count")

    @_builtins.property
    @pulumi.getter(name="ipv4Addresses")
    def ipv4_addresses(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "ipv4_addresses")

    @_builtins.property
    @pulumi.getter(name="ipv4PrefixCount")
    def ipv4_prefix_count(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "ipv4_prefix_count")

    @_builtins.property
    @pulumi.getter(name="ipv4Prefixes")
    def ipv4_prefixes(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "ipv4_prefixes")

    @_builtins.property
    @pulumi.getter(name="ipv6AddressCount")
    def ipv6_address_count(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "ipv6_address_count")

    @_builtins.property
    @pulumi.getter(name="ipv6Addresses")
    def ipv6_addresses(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "ipv6_addresses")

    @_builtins.property
    @pulumi.getter(name="ipv6PrefixCount")
    def ipv6_prefix_count(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "ipv6_prefix_count")

    @_builtins.property
    @pulumi.getter(name="ipv6Prefixes")
    def ipv6_prefixes(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "ipv6_prefixes")

    @_builtins.property
    @pulumi.getter(name="networkCardIndex")
    def network_card_index(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "network_card_index")

    @_builtins.property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "network_interface_id")

    @_builtins.property
    @pulumi.getter(name="primaryIpv6")
    def primary_ipv6(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "primary_ipv6")

    @_builtins.property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "private_ip_address")

    @_builtins.property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "security_groups")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class LaunchTemplateNetworkInterfaceConnectionTrackingSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tcpEstablishedTimeout":
            suggest = "tcp_established_timeout"
        elif key == "udpStreamTimeout":
            suggest = "udp_stream_timeout"
        elif key == "udpTimeout":
            suggest = "udp_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateNetworkInterfaceConnectionTrackingSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateNetworkInterfaceConnectionTrackingSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateNetworkInterfaceConnectionTrackingSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tcp_established_timeout: Optional[_builtins.int] = None,
                 udp_stream_timeout: Optional[_builtins.int] = None,
                 udp_timeout: Optional[_builtins.int] = None):
        if tcp_established_timeout is not None:
            pulumi.set(__self__, "tcp_established_timeout", tcp_established_timeout)
        if udp_stream_timeout is not None:
            pulumi.set(__self__, "udp_stream_timeout", udp_stream_timeout)
        if udp_timeout is not None:
            pulumi.set(__self__, "udp_timeout", udp_timeout)

    @_builtins.property
    @pulumi.getter(name="tcpEstablishedTimeout")
    def tcp_established_timeout(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "tcp_established_timeout")

    @_builtins.property
    @pulumi.getter(name="udpStreamTimeout")
    def udp_stream_timeout(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "udp_stream_timeout")

    @_builtins.property
    @pulumi.getter(name="udpTimeout")
    def udp_timeout(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "udp_timeout")


@pulumi.output_type
class LaunchTemplateNetworkInterfaceEnaSrdSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enaSrdEnabled":
            suggest = "ena_srd_enabled"
        elif key == "enaSrdUdpSpecification":
            suggest = "ena_srd_udp_specification"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateNetworkInterfaceEnaSrdSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateNetworkInterfaceEnaSrdSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateNetworkInterfaceEnaSrdSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ena_srd_enabled: Optional[_builtins.bool] = None,
                 ena_srd_udp_specification: Optional['outputs.LaunchTemplateNetworkInterfaceEnaSrdSpecificationEnaSrdUdpSpecification'] = None):
        if ena_srd_enabled is not None:
            pulumi.set(__self__, "ena_srd_enabled", ena_srd_enabled)
        if ena_srd_udp_specification is not None:
            pulumi.set(__self__, "ena_srd_udp_specification", ena_srd_udp_specification)

    @_builtins.property
    @pulumi.getter(name="enaSrdEnabled")
    def ena_srd_enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "ena_srd_enabled")

    @_builtins.property
    @pulumi.getter(name="enaSrdUdpSpecification")
    def ena_srd_udp_specification(self) -> Optional['outputs.LaunchTemplateNetworkInterfaceEnaSrdSpecificationEnaSrdUdpSpecification']:
        return pulumi.get(self, "ena_srd_udp_specification")


@pulumi.output_type
class LaunchTemplateNetworkInterfaceEnaSrdSpecificationEnaSrdUdpSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enaSrdUdpEnabled":
            suggest = "ena_srd_udp_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateNetworkInterfaceEnaSrdSpecificationEnaSrdUdpSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateNetworkInterfaceEnaSrdSpecificationEnaSrdUdpSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateNetworkInterfaceEnaSrdSpecificationEnaSrdUdpSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ena_srd_udp_enabled: Optional[_builtins.bool] = None):
        if ena_srd_udp_enabled is not None:
            pulumi.set(__self__, "ena_srd_udp_enabled", ena_srd_udp_enabled)

    @_builtins.property
    @pulumi.getter(name="enaSrdUdpEnabled")
    def ena_srd_udp_enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "ena_srd_udp_enabled")


@pulumi.output_type
class LaunchTemplatePlacement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "groupId":
            suggest = "group_id"
        elif key == "groupName":
            suggest = "group_name"
        elif key == "hostId":
            suggest = "host_id"
        elif key == "hostResourceGroupArn":
            suggest = "host_resource_group_arn"
        elif key == "partitionNumber":
            suggest = "partition_number"
        elif key == "spreadDomain":
            suggest = "spread_domain"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplatePlacement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplatePlacement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplatePlacement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 affinity: Optional[_builtins.str] = None,
                 availability_zone: Optional[_builtins.str] = None,
                 group_id: Optional[_builtins.str] = None,
                 group_name: Optional[_builtins.str] = None,
                 host_id: Optional[_builtins.str] = None,
                 host_resource_group_arn: Optional[_builtins.str] = None,
                 partition_number: Optional[_builtins.int] = None,
                 spread_domain: Optional[_builtins.str] = None,
                 tenancy: Optional[_builtins.str] = None):
        if affinity is not None:
            pulumi.set(__self__, "affinity", affinity)
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if group_name is not None:
            pulumi.set(__self__, "group_name", group_name)
        if host_id is not None:
            pulumi.set(__self__, "host_id", host_id)
        if host_resource_group_arn is not None:
            pulumi.set(__self__, "host_resource_group_arn", host_resource_group_arn)
        if partition_number is not None:
            pulumi.set(__self__, "partition_number", partition_number)
        if spread_domain is not None:
            pulumi.set(__self__, "spread_domain", spread_domain)
        if tenancy is not None:
            pulumi.set(__self__, "tenancy", tenancy)

    @_builtins.property
    @pulumi.getter
    def affinity(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "affinity")

    @_builtins.property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "availability_zone")

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "group_id")

    @_builtins.property
    @pulumi.getter(name="groupName")
    def group_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "group_name")

    @_builtins.property
    @pulumi.getter(name="hostId")
    def host_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "host_id")

    @_builtins.property
    @pulumi.getter(name="hostResourceGroupArn")
    def host_resource_group_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "host_resource_group_arn")

    @_builtins.property
    @pulumi.getter(name="partitionNumber")
    def partition_number(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "partition_number")

    @_builtins.property
    @pulumi.getter(name="spreadDomain")
    def spread_domain(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "spread_domain")

    @_builtins.property
    @pulumi.getter
    def tenancy(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "tenancy")


@pulumi.output_type
class LaunchTemplatePrivateDnsNameOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableResourceNameDnsARecord":
            suggest = "enable_resource_name_dns_a_record"
        elif key == "enableResourceNameDnsAaaaRecord":
            suggest = "enable_resource_name_dns_aaaa_record"
        elif key == "hostnameType":
            suggest = "hostname_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplatePrivateDnsNameOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplatePrivateDnsNameOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplatePrivateDnsNameOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_resource_name_dns_a_record: Optional[_builtins.bool] = None,
                 enable_resource_name_dns_aaaa_record: Optional[_builtins.bool] = None,
                 hostname_type: Optional[_builtins.str] = None):
        if enable_resource_name_dns_a_record is not None:
            pulumi.set(__self__, "enable_resource_name_dns_a_record", enable_resource_name_dns_a_record)
        if enable_resource_name_dns_aaaa_record is not None:
            pulumi.set(__self__, "enable_resource_name_dns_aaaa_record", enable_resource_name_dns_aaaa_record)
        if hostname_type is not None:
            pulumi.set(__self__, "hostname_type", hostname_type)

    @_builtins.property
    @pulumi.getter(name="enableResourceNameDnsARecord")
    def enable_resource_name_dns_a_record(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enable_resource_name_dns_a_record")

    @_builtins.property
    @pulumi.getter(name="enableResourceNameDnsAaaaRecord")
    def enable_resource_name_dns_aaaa_record(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enable_resource_name_dns_aaaa_record")

    @_builtins.property
    @pulumi.getter(name="hostnameType")
    def hostname_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "hostname_type")


@pulumi.output_type
class LaunchTemplateTagSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceType":
            suggest = "resource_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateTagSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateTagSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateTagSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_type: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "resource_type")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "tags")


@pulumi.output_type
class ManagedPrefixListEntry(dict):
    def __init__(__self__, *,
                 cidr: _builtins.str,
                 description: Optional[_builtins.str] = None):
        pulumi.set(__self__, "cidr", cidr)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def cidr(self) -> _builtins.str:
        return pulumi.get(self, "cidr")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class NatGatewayAvailabilityZoneAddress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allocationIds":
            suggest = "allocation_ids"
        elif key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "availabilityZoneId":
            suggest = "availability_zone_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NatGatewayAvailabilityZoneAddress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NatGatewayAvailabilityZoneAddress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NatGatewayAvailabilityZoneAddress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allocation_ids: Optional[Sequence[_builtins.str]] = None,
                 availability_zone: Optional[_builtins.str] = None,
                 availability_zone_id: Optional[_builtins.str] = None):
        if allocation_ids is not None:
            pulumi.set(__self__, "allocation_ids", allocation_ids)
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if availability_zone_id is not None:
            pulumi.set(__self__, "availability_zone_id", availability_zone_id)

    @_builtins.property
    @pulumi.getter(name="allocationIds")
    def allocation_ids(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "allocation_ids")

    @_builtins.property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "availability_zone")

    @_builtins.property
    @pulumi.getter(name="availabilityZoneId")
    def availability_zone_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "availability_zone_id")


@pulumi.output_type
class NatGatewayEipAssociationTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[_builtins.str] = None,
                 delete: Optional[_builtins.str] = None):
        """
        :param _builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param _builtins.str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")


@pulumi.output_type
class NatGatewayRegionalNatGatewayAddress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allocationId":
            suggest = "allocation_id"
        elif key == "associationId":
            suggest = "association_id"
        elif key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "availabilityZoneId":
            suggest = "availability_zone_id"
        elif key == "networkInterfaceId":
            suggest = "network_interface_id"
        elif key == "publicIp":
            suggest = "public_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NatGatewayRegionalNatGatewayAddress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NatGatewayRegionalNatGatewayAddress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NatGatewayRegionalNatGatewayAddress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allocation_id: Optional[_builtins.str] = None,
                 association_id: Optional[_builtins.str] = None,
                 availability_zone: Optional[_builtins.str] = None,
                 availability_zone_id: Optional[_builtins.str] = None,
                 network_interface_id: Optional[_builtins.str] = None,
                 public_ip: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None):
        if allocation_id is not None:
            pulumi.set(__self__, "allocation_id", allocation_id)
        if association_id is not None:
            pulumi.set(__self__, "association_id", association_id)
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if availability_zone_id is not None:
            pulumi.set(__self__, "availability_zone_id", availability_zone_id)
        if network_interface_id is not None:
            pulumi.set(__self__, "network_interface_id", network_interface_id)
        if public_ip is not None:
            pulumi.set(__self__, "public_ip", public_ip)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="allocationId")
    def allocation_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "allocation_id")

    @_builtins.property
    @pulumi.getter(name="associationId")
    def association_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "association_id")

    @_builtins.property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "availability_zone")

    @_builtins.property
    @pulumi.getter(name="availabilityZoneId")
    def availability_zone_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "availability_zone_id")

    @_builtins.property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "network_interface_id")

    @_builtins.property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "public_ip")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "status")


@pulumi.output_type
class NetworkAclEgress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromPort":
            suggest = "from_port"
        elif key == "ruleNo":
            suggest = "rule_no"
        elif key == "toPort":
            suggest = "to_port"
        elif key == "cidrBlock":
            suggest = "cidr_block"
        elif key == "icmpCode":
            suggest = "icmp_code"
        elif key == "icmpType":
            suggest = "icmp_type"
        elif key == "ipv6CidrBlock":
            suggest = "ipv6_cidr_block"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkAclEgress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkAclEgress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkAclEgress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: _builtins.str,
                 from_port: _builtins.int,
                 protocol: _builtins.str,
                 rule_no: _builtins.int,
                 to_port: _builtins.int,
                 cidr_block: Optional[_builtins.str] = None,
                 icmp_code: Optional[_builtins.int] = None,
                 icmp_type: Optional[_builtins.int] = None,
                 ipv6_cidr_block: Optional[_builtins.str] = None):
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "from_port", from_port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "rule_no", rule_no)
        pulumi.set(__self__, "to_port", to_port)
        if cidr_block is not None:
            pulumi.set(__self__, "cidr_block", cidr_block)
        if icmp_code is not None:
            pulumi.set(__self__, "icmp_code", icmp_code)
        if icmp_type is not None:
            pulumi.set(__self__, "icmp_type", icmp_type)
        if ipv6_cidr_block is not None:
            pulumi.set(__self__, "ipv6_cidr_block", ipv6_cidr_block)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> _builtins.int:
        return pulumi.get(self, "from_port")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="ruleNo")
    def rule_no(self) -> _builtins.int:
        return pulumi.get(self, "rule_no")

    @_builtins.property
    @pulumi.getter(name="toPort")
    def to_port(self) -> _builtins.int:
        return pulumi.get(self, "to_port")

    @_builtins.property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cidr_block")

    @_builtins.property
    @pulumi.getter(name="icmpCode")
    def icmp_code(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "icmp_code")

    @_builtins.property
    @pulumi.getter(name="icmpType")
    def icmp_type(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "icmp_type")

    @_builtins.property
    @pulumi.getter(name="ipv6CidrBlock")
    def ipv6_cidr_block(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ipv6_cidr_block")


@pulumi.output_type
class NetworkAclIngress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromPort":
            suggest = "from_port"
        elif key == "ruleNo":
            suggest = "rule_no"
        elif key == "toPort":
            suggest = "to_port"
        elif key == "cidrBlock":
            suggest = "cidr_block"
        elif key == "icmpCode":
            suggest = "icmp_code"
        elif key == "icmpType":
            suggest = "icmp_type"
        elif key == "ipv6CidrBlock":
            suggest = "ipv6_cidr_block"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkAclIngress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkAclIngress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkAclIngress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: _builtins.str,
                 from_port: _builtins.int,
                 protocol: _builtins.str,
                 rule_no: _builtins.int,
                 to_port: _builtins.int,
                 cidr_block: Optional[_builtins.str] = None,
                 icmp_code: Optional[_builtins.int] = None,
                 icmp_type: Optional[_builtins.int] = None,
                 ipv6_cidr_block: Optional[_builtins.str] = None):
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "from_port", from_port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "rule_no", rule_no)
        pulumi.set(__self__, "to_port", to_port)
        if cidr_block is not None:
            pulumi.set(__self__, "cidr_block", cidr_block)
        if icmp_code is not None:
            pulumi.set(__self__, "icmp_code", icmp_code)
        if icmp_type is not None:
            pulumi.set(__self__, "icmp_type", icmp_type)
        if ipv6_cidr_block is not None:
            pulumi.set(__self__, "ipv6_cidr_block", ipv6_cidr_block)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> _builtins.int:
        return pulumi.get(self, "from_port")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="ruleNo")
    def rule_no(self) -> _builtins.int:
        return pulumi.get(self, "rule_no")

    @_builtins.property
    @pulumi.getter(name="toPort")
    def to_port(self) -> _builtins.int:
        return pulumi.get(self, "to_port")

    @_builtins.property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cidr_block")

    @_builtins.property
    @pulumi.getter(name="icmpCode")
    def icmp_code(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "icmp_code")

    @_builtins.property
    @pulumi.getter(name="icmpType")
    def icmp_type(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "icmp_type")

    @_builtins.property
    @pulumi.getter(name="ipv6CidrBlock")
    def ipv6_cidr_block(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ipv6_cidr_block")


@pulumi.output_type
class NetworkInsightsAnalysisAlternatePathHint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "componentArn":
            suggest = "component_arn"
        elif key == "componentId":
            suggest = "component_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisAlternatePathHint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisAlternatePathHint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisAlternatePathHint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 component_arn: Optional[_builtins.str] = None,
                 component_id: Optional[_builtins.str] = None):
        if component_arn is not None:
            pulumi.set(__self__, "component_arn", component_arn)
        if component_id is not None:
            pulumi.set(__self__, "component_id", component_id)

    @_builtins.property
    @pulumi.getter(name="componentArn")
    def component_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "component_arn")

    @_builtins.property
    @pulumi.getter(name="componentId")
    def component_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "component_id")


@pulumi.output_type
class NetworkInsightsAnalysisExplanation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aclRules":
            suggest = "acl_rules"
        elif key == "attachedTos":
            suggest = "attached_tos"
        elif key == "availabilityZones":
            suggest = "availability_zones"
        elif key == "classicLoadBalancerListeners":
            suggest = "classic_load_balancer_listeners"
        elif key == "customerGateways":
            suggest = "customer_gateways"
        elif key == "destinationVpcs":
            suggest = "destination_vpcs"
        elif key == "elasticLoadBalancerListeners":
            suggest = "elastic_load_balancer_listeners"
        elif key == "explanationCode":
            suggest = "explanation_code"
        elif key == "ingressRouteTables":
            suggest = "ingress_route_tables"
        elif key == "internetGateways":
            suggest = "internet_gateways"
        elif key == "loadBalancerArn":
            suggest = "load_balancer_arn"
        elif key == "loadBalancerListenerPort":
            suggest = "load_balancer_listener_port"
        elif key == "loadBalancerTargetGroup":
            suggest = "load_balancer_target_group"
        elif key == "loadBalancerTargetGroups":
            suggest = "load_balancer_target_groups"
        elif key == "loadBalancerTargetPort":
            suggest = "load_balancer_target_port"
        elif key == "missingComponent":
            suggest = "missing_component"
        elif key == "natGateways":
            suggest = "nat_gateways"
        elif key == "networkInterfaces":
            suggest = "network_interfaces"
        elif key == "packetField":
            suggest = "packet_field"
        elif key == "portRanges":
            suggest = "port_ranges"
        elif key == "prefixLists":
            suggest = "prefix_lists"
        elif key == "routeTableRoutes":
            suggest = "route_table_routes"
        elif key == "routeTables":
            suggest = "route_tables"
        elif key == "securityGroup":
            suggest = "security_group"
        elif key == "securityGroupRules":
            suggest = "security_group_rules"
        elif key == "securityGroups":
            suggest = "security_groups"
        elif key == "sourceVpcs":
            suggest = "source_vpcs"
        elif key == "subnetRouteTables":
            suggest = "subnet_route_tables"
        elif key == "transitGatewayAttachments":
            suggest = "transit_gateway_attachments"
        elif key == "transitGatewayRouteTableRoutes":
            suggest = "transit_gateway_route_table_routes"
        elif key == "transitGatewayRouteTables":
            suggest = "transit_gateway_route_tables"
        elif key == "transitGateways":
            suggest = "transit_gateways"
        elif key == "vpcEndpoints":
            suggest = "vpc_endpoints"
        elif key == "vpcPeeringConnections":
            suggest = "vpc_peering_connections"
        elif key == "vpnConnections":
            suggest = "vpn_connections"
        elif key == "vpnGateways":
            suggest = "vpn_gateways"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisExplanation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisExplanation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisExplanation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 acl_rules: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationAclRule']] = None,
                 acls: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationAcl']] = None,
                 address: Optional[_builtins.str] = None,
                 addresses: Optional[Sequence[_builtins.str]] = None,
                 attached_tos: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationAttachedTo']] = None,
                 availability_zones: Optional[Sequence[_builtins.str]] = None,
                 cidrs: Optional[Sequence[_builtins.str]] = None,
                 classic_load_balancer_listeners: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationClassicLoadBalancerListener']] = None,
                 components: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationComponent']] = None,
                 customer_gateways: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationCustomerGateway']] = None,
                 destination_vpcs: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationDestinationVpc']] = None,
                 destinations: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationDestination']] = None,
                 direction: Optional[_builtins.str] = None,
                 elastic_load_balancer_listeners: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationElasticLoadBalancerListener']] = None,
                 explanation_code: Optional[_builtins.str] = None,
                 ingress_route_tables: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationIngressRouteTable']] = None,
                 internet_gateways: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationInternetGateway']] = None,
                 load_balancer_arn: Optional[_builtins.str] = None,
                 load_balancer_listener_port: Optional[_builtins.int] = None,
                 load_balancer_target_group: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationLoadBalancerTargetGroup']] = None,
                 load_balancer_target_groups: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationLoadBalancerTargetGroup']] = None,
                 load_balancer_target_port: Optional[_builtins.int] = None,
                 missing_component: Optional[_builtins.str] = None,
                 nat_gateways: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationNatGateway']] = None,
                 network_interfaces: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationNetworkInterface']] = None,
                 packet_field: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_ranges: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationPortRange']] = None,
                 prefix_lists: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationPrefixList']] = None,
                 protocols: Optional[Sequence[_builtins.str]] = None,
                 route_table_routes: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationRouteTableRoute']] = None,
                 route_tables: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationRouteTable']] = None,
                 security_group: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationSecurityGroup']] = None,
                 security_group_rules: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationSecurityGroupRule']] = None,
                 security_groups: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationSecurityGroup']] = None,
                 source_vpcs: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationSourceVpc']] = None,
                 state: Optional[_builtins.str] = None,
                 subnet_route_tables: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationSubnetRouteTable']] = None,
                 subnets: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationSubnet']] = None,
                 transit_gateway_attachments: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationTransitGatewayAttachment']] = None,
                 transit_gateway_route_table_routes: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationTransitGatewayRouteTableRoute']] = None,
                 transit_gateway_route_tables: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationTransitGatewayRouteTable']] = None,
                 transit_gateways: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationTransitGateway']] = None,
                 vpc_endpoints: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationVpcEndpoint']] = None,
                 vpc_peering_connections: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationVpcPeeringConnection']] = None,
                 vpcs: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationVpc']] = None,
                 vpn_connections: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationVpnConnection']] = None,
                 vpn_gateways: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationVpnGateway']] = None):
        if acl_rules is not None:
            pulumi.set(__self__, "acl_rules", acl_rules)
        if acls is not None:
            pulumi.set(__self__, "acls", acls)
        if address is not None:
            pulumi.set(__self__, "address", address)
        if addresses is not None:
            pulumi.set(__self__, "addresses", addresses)
        if attached_tos is not None:
            pulumi.set(__self__, "attached_tos", attached_tos)
        if availability_zones is not None:
            pulumi.set(__self__, "availability_zones", availability_zones)
        if cidrs is not None:
            pulumi.set(__self__, "cidrs", cidrs)
        if classic_load_balancer_listeners is not None:
            pulumi.set(__self__, "classic_load_balancer_listeners", classic_load_balancer_listeners)
        if components is not None:
            pulumi.set(__self__, "components", components)
        if customer_gateways is not None:
            pulumi.set(__self__, "customer_gateways", customer_gateways)
        if destination_vpcs is not None:
            pulumi.set(__self__, "destination_vpcs", destination_vpcs)
        if destinations is not None:
            pulumi.set(__self__, "destinations", destinations)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if elastic_load_balancer_listeners is not None:
            pulumi.set(__self__, "elastic_load_balancer_listeners", elastic_load_balancer_listeners)
        if explanation_code is not None:
            pulumi.set(__self__, "explanation_code", explanation_code)
        if ingress_route_tables is not None:
            pulumi.set(__self__, "ingress_route_tables", ingress_route_tables)
        if internet_gateways is not None:
            pulumi.set(__self__, "internet_gateways", internet_gateways)
        if load_balancer_arn is not None:
            pulumi.set(__self__, "load_balancer_arn", load_balancer_arn)
        if load_balancer_listener_port is not None:
            pulumi.set(__self__, "load_balancer_listener_port", load_balancer_listener_port)
        if load_balancer_target_group is not None:
            pulumi.set(__self__, "load_balancer_target_group", load_balancer_target_group)
        if load_balancer_target_groups is not None:
            pulumi.set(__self__, "load_balancer_target_groups", load_balancer_target_groups)
        if load_balancer_target_port is not None:
            pulumi.set(__self__, "load_balancer_target_port", load_balancer_target_port)
        if missing_component is not None:
            pulumi.set(__self__, "missing_component", missing_component)
        if nat_gateways is not None:
            pulumi.set(__self__, "nat_gateways", nat_gateways)
        if network_interfaces is not None:
            pulumi.set(__self__, "network_interfaces", network_interfaces)
        if packet_field is not None:
            pulumi.set(__self__, "packet_field", packet_field)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_ranges is not None:
            pulumi.set(__self__, "port_ranges", port_ranges)
        if prefix_lists is not None:
            pulumi.set(__self__, "prefix_lists", prefix_lists)
        if protocols is not None:
            pulumi.set(__self__, "protocols", protocols)
        if route_table_routes is not None:
            pulumi.set(__self__, "route_table_routes", route_table_routes)
        if route_tables is not None:
            pulumi.set(__self__, "route_tables", route_tables)
        if security_group is not None:
            pulumi.set(__self__, "security_group", security_group)
        if security_group_rules is not None:
            pulumi.set(__self__, "security_group_rules", security_group_rules)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if source_vpcs is not None:
            pulumi.set(__self__, "source_vpcs", source_vpcs)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if subnet_route_tables is not None:
            pulumi.set(__self__, "subnet_route_tables", subnet_route_tables)
        if subnets is not None:
            pulumi.set(__self__, "subnets", subnets)
        if transit_gateway_attachments is not None:
            pulumi.set(__self__, "transit_gateway_attachments", transit_gateway_attachments)
        if transit_gateway_route_table_routes is not None:
            pulumi.set(__self__, "transit_gateway_route_table_routes", transit_gateway_route_table_routes)
        if transit_gateway_route_tables is not None:
            pulumi.set(__self__, "transit_gateway_route_tables", transit_gateway_route_tables)
        if transit_gateways is not None:
            pulumi.set(__self__, "transit_gateways", transit_gateways)
        if vpc_endpoints is not None:
            pulumi.set(__self__, "vpc_endpoints", vpc_endpoints)
        if vpc_peering_connections is not None:
            pulumi.set(__self__, "vpc_peering_connections", vpc_peering_connections)
        if vpcs is not None:
            pulumi.set(__self__, "vpcs", vpcs)
        if vpn_connections is not None:
            pulumi.set(__self__, "vpn_connections", vpn_connections)
        if vpn_gateways is not None:
            pulumi.set(__self__, "vpn_gateways", vpn_gateways)

    @_builtins.property
    @pulumi.getter(name="aclRules")
    def acl_rules(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationAclRule']]:
        return pulumi.get(self, "acl_rules")

    @_builtins.property
    @pulumi.getter
    def acls(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationAcl']]:
        return pulumi.get(self, "acls")

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def addresses(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "addresses")

    @_builtins.property
    @pulumi.getter(name="attachedTos")
    def attached_tos(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationAttachedTo']]:
        return pulumi.get(self, "attached_tos")

    @_builtins.property
    @pulumi.getter(name="availabilityZones")
    def availability_zones(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "availability_zones")

    @_builtins.property
    @pulumi.getter
    def cidrs(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "cidrs")

    @_builtins.property
    @pulumi.getter(name="classicLoadBalancerListeners")
    def classic_load_balancer_listeners(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationClassicLoadBalancerListener']]:
        return pulumi.get(self, "classic_load_balancer_listeners")

    @_builtins.property
    @pulumi.getter
    def components(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationComponent']]:
        return pulumi.get(self, "components")

    @_builtins.property
    @pulumi.getter(name="customerGateways")
    def customer_gateways(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationCustomerGateway']]:
        return pulumi.get(self, "customer_gateways")

    @_builtins.property
    @pulumi.getter(name="destinationVpcs")
    def destination_vpcs(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationDestinationVpc']]:
        return pulumi.get(self, "destination_vpcs")

    @_builtins.property
    @pulumi.getter
    def destinations(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationDestination']]:
        return pulumi.get(self, "destinations")

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "direction")

    @_builtins.property
    @pulumi.getter(name="elasticLoadBalancerListeners")
    def elastic_load_balancer_listeners(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationElasticLoadBalancerListener']]:
        return pulumi.get(self, "elastic_load_balancer_listeners")

    @_builtins.property
    @pulumi.getter(name="explanationCode")
    def explanation_code(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "explanation_code")

    @_builtins.property
    @pulumi.getter(name="ingressRouteTables")
    def ingress_route_tables(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationIngressRouteTable']]:
        return pulumi.get(self, "ingress_route_tables")

    @_builtins.property
    @pulumi.getter(name="internetGateways")
    def internet_gateways(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationInternetGateway']]:
        return pulumi.get(self, "internet_gateways")

    @_builtins.property
    @pulumi.getter(name="loadBalancerArn")
    def load_balancer_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "load_balancer_arn")

    @_builtins.property
    @pulumi.getter(name="loadBalancerListenerPort")
    def load_balancer_listener_port(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "load_balancer_listener_port")

    @_builtins.property
    @pulumi.getter(name="loadBalancerTargetGroup")
    def load_balancer_target_group(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationLoadBalancerTargetGroup']]:
        return pulumi.get(self, "load_balancer_target_group")

    @_builtins.property
    @pulumi.getter(name="loadBalancerTargetGroups")
    def load_balancer_target_groups(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationLoadBalancerTargetGroup']]:
        return pulumi.get(self, "load_balancer_target_groups")

    @_builtins.property
    @pulumi.getter(name="loadBalancerTargetPort")
    def load_balancer_target_port(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "load_balancer_target_port")

    @_builtins.property
    @pulumi.getter(name="missingComponent")
    def missing_component(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "missing_component")

    @_builtins.property
    @pulumi.getter(name="natGateways")
    def nat_gateways(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationNatGateway']]:
        return pulumi.get(self, "nat_gateways")

    @_builtins.property
    @pulumi.getter(name="networkInterfaces")
    def network_interfaces(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationNetworkInterface']]:
        return pulumi.get(self, "network_interfaces")

    @_builtins.property
    @pulumi.getter(name="packetField")
    def packet_field(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "packet_field")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationPortRange']]:
        return pulumi.get(self, "port_ranges")

    @_builtins.property
    @pulumi.getter(name="prefixLists")
    def prefix_lists(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationPrefixList']]:
        return pulumi.get(self, "prefix_lists")

    @_builtins.property
    @pulumi.getter
    def protocols(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "protocols")

    @_builtins.property
    @pulumi.getter(name="routeTableRoutes")
    def route_table_routes(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationRouteTableRoute']]:
        return pulumi.get(self, "route_table_routes")

    @_builtins.property
    @pulumi.getter(name="routeTables")
    def route_tables(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationRouteTable']]:
        return pulumi.get(self, "route_tables")

    @_builtins.property
    @pulumi.getter(name="securityGroup")
    def security_group(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationSecurityGroup']]:
        return pulumi.get(self, "security_group")

    @_builtins.property
    @pulumi.getter(name="securityGroupRules")
    def security_group_rules(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationSecurityGroupRule']]:
        return pulumi.get(self, "security_group_rules")

    @_builtins.property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationSecurityGroup']]:
        return pulumi.get(self, "security_groups")

    @_builtins.property
    @pulumi.getter(name="sourceVpcs")
    def source_vpcs(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationSourceVpc']]:
        return pulumi.get(self, "source_vpcs")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="subnetRouteTables")
    def subnet_route_tables(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationSubnetRouteTable']]:
        return pulumi.get(self, "subnet_route_tables")

    @_builtins.property
    @pulumi.getter
    def subnets(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationSubnet']]:
        return pulumi.get(self, "subnets")

    @_builtins.property
    @pulumi.getter(name="transitGatewayAttachments")
    def transit_gateway_attachments(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationTransitGatewayAttachment']]:
        return pulumi.get(self, "transit_gateway_attachments")

    @_builtins.property
    @pulumi.getter(name="transitGatewayRouteTableRoutes")
    def transit_gateway_route_table_routes(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationTransitGatewayRouteTableRoute']]:
        return pulumi.get(self, "transit_gateway_route_table_routes")

    @_builtins.property
    @pulumi.getter(name="transitGatewayRouteTables")
    def transit_gateway_route_tables(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationTransitGatewayRouteTable']]:
        return pulumi.get(self, "transit_gateway_route_tables")

    @_builtins.property
    @pulumi.getter(name="transitGateways")
    def transit_gateways(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationTransitGateway']]:
        return pulumi.get(self, "transit_gateways")

    @_builtins.property
    @pulumi.getter(name="vpcEndpoints")
    def vpc_endpoints(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationVpcEndpoint']]:
        return pulumi.get(self, "vpc_endpoints")

    @_builtins.property
    @pulumi.getter(name="vpcPeeringConnections")
    def vpc_peering_connections(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationVpcPeeringConnection']]:
        return pulumi.get(self, "vpc_peering_connections")

    @_builtins.property
    @pulumi.getter
    def vpcs(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationVpc']]:
        return pulumi.get(self, "vpcs")

    @_builtins.property
    @pulumi.getter(name="vpnConnections")
    def vpn_connections(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationVpnConnection']]:
        return pulumi.get(self, "vpn_connections")

    @_builtins.property
    @pulumi.getter(name="vpnGateways")
    def vpn_gateways(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationVpnGateway']]:
        return pulumi.get(self, "vpn_gateways")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationAcl(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationAclRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portRanges":
            suggest = "port_ranges"
        elif key == "ruleAction":
            suggest = "rule_action"
        elif key == "ruleNumber":
            suggest = "rule_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisExplanationAclRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisExplanationAclRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisExplanationAclRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cidr: Optional[_builtins.str] = None,
                 egress: Optional[_builtins.bool] = None,
                 port_ranges: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationAclRulePortRange']] = None,
                 protocol: Optional[_builtins.str] = None,
                 rule_action: Optional[_builtins.str] = None,
                 rule_number: Optional[_builtins.int] = None):
        if cidr is not None:
            pulumi.set(__self__, "cidr", cidr)
        if egress is not None:
            pulumi.set(__self__, "egress", egress)
        if port_ranges is not None:
            pulumi.set(__self__, "port_ranges", port_ranges)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if rule_action is not None:
            pulumi.set(__self__, "rule_action", rule_action)
        if rule_number is not None:
            pulumi.set(__self__, "rule_number", rule_number)

    @_builtins.property
    @pulumi.getter
    def cidr(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cidr")

    @_builtins.property
    @pulumi.getter
    def egress(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "egress")

    @_builtins.property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationAclRulePortRange']]:
        return pulumi.get(self, "port_ranges")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="ruleAction")
    def rule_action(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "rule_action")

    @_builtins.property
    @pulumi.getter(name="ruleNumber")
    def rule_number(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "rule_number")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationAclRulePortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisExplanationAclRulePortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisExplanationAclRulePortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisExplanationAclRulePortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: Optional[_builtins.int] = None,
                 to: Optional[_builtins.int] = None):
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "to")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationAttachedTo(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationClassicLoadBalancerListener(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instancePort":
            suggest = "instance_port"
        elif key == "loadBalancerPort":
            suggest = "load_balancer_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisExplanationClassicLoadBalancerListener. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisExplanationClassicLoadBalancerListener.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisExplanationClassicLoadBalancerListener.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_port: Optional[_builtins.int] = None,
                 load_balancer_port: Optional[_builtins.int] = None):
        if instance_port is not None:
            pulumi.set(__self__, "instance_port", instance_port)
        if load_balancer_port is not None:
            pulumi.set(__self__, "load_balancer_port", load_balancer_port)

    @_builtins.property
    @pulumi.getter(name="instancePort")
    def instance_port(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "instance_port")

    @_builtins.property
    @pulumi.getter(name="loadBalancerPort")
    def load_balancer_port(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "load_balancer_port")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationComponent(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationCustomerGateway(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationDestination(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationDestinationVpc(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationElasticLoadBalancerListener(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationIngressRouteTable(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationInternetGateway(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationLoadBalancerTargetGroup(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationNatGateway(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationNetworkInterface(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationPortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisExplanationPortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisExplanationPortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisExplanationPortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: Optional[_builtins.int] = None,
                 to: Optional[_builtins.int] = None):
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "to")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationPrefixList(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationRouteTable(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationRouteTableRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationCidr":
            suggest = "destination_cidr"
        elif key == "destinationPrefixListId":
            suggest = "destination_prefix_list_id"
        elif key == "egressOnlyInternetGatewayId":
            suggest = "egress_only_internet_gateway_id"
        elif key == "gatewayId":
            suggest = "gateway_id"
        elif key == "instanceId":
            suggest = "instance_id"
        elif key == "natGatewayId":
            suggest = "nat_gateway_id"
        elif key == "networkInterfaceId":
            suggest = "network_interface_id"
        elif key == "transitGatewayId":
            suggest = "transit_gateway_id"
        elif key == "vpcPeeringConnectionId":
            suggest = "vpc_peering_connection_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisExplanationRouteTableRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisExplanationRouteTableRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisExplanationRouteTableRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_cidr: Optional[_builtins.str] = None,
                 destination_prefix_list_id: Optional[_builtins.str] = None,
                 egress_only_internet_gateway_id: Optional[_builtins.str] = None,
                 gateway_id: Optional[_builtins.str] = None,
                 instance_id: Optional[_builtins.str] = None,
                 nat_gateway_id: Optional[_builtins.str] = None,
                 network_interface_id: Optional[_builtins.str] = None,
                 origin: Optional[_builtins.str] = None,
                 transit_gateway_id: Optional[_builtins.str] = None,
                 vpc_peering_connection_id: Optional[_builtins.str] = None):
        if destination_cidr is not None:
            pulumi.set(__self__, "destination_cidr", destination_cidr)
        if destination_prefix_list_id is not None:
            pulumi.set(__self__, "destination_prefix_list_id", destination_prefix_list_id)
        if egress_only_internet_gateway_id is not None:
            pulumi.set(__self__, "egress_only_internet_gateway_id", egress_only_internet_gateway_id)
        if gateway_id is not None:
            pulumi.set(__self__, "gateway_id", gateway_id)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if nat_gateway_id is not None:
            pulumi.set(__self__, "nat_gateway_id", nat_gateway_id)
        if network_interface_id is not None:
            pulumi.set(__self__, "network_interface_id", network_interface_id)
        if origin is not None:
            pulumi.set(__self__, "origin", origin)
        if transit_gateway_id is not None:
            pulumi.set(__self__, "transit_gateway_id", transit_gateway_id)
        if vpc_peering_connection_id is not None:
            pulumi.set(__self__, "vpc_peering_connection_id", vpc_peering_connection_id)

    @_builtins.property
    @pulumi.getter(name="destinationCidr")
    def destination_cidr(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "destination_cidr")

    @_builtins.property
    @pulumi.getter(name="destinationPrefixListId")
    def destination_prefix_list_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "destination_prefix_list_id")

    @_builtins.property
    @pulumi.getter(name="egressOnlyInternetGatewayId")
    def egress_only_internet_gateway_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "egress_only_internet_gateway_id")

    @_builtins.property
    @pulumi.getter(name="gatewayId")
    def gateway_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "gateway_id")

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "instance_id")

    @_builtins.property
    @pulumi.getter(name="natGatewayId")
    def nat_gateway_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "nat_gateway_id")

    @_builtins.property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "network_interface_id")

    @_builtins.property
    @pulumi.getter
    def origin(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "origin")

    @_builtins.property
    @pulumi.getter(name="transitGatewayId")
    def transit_gateway_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "transit_gateway_id")

    @_builtins.property
    @pulumi.getter(name="vpcPeeringConnectionId")
    def vpc_peering_connection_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "vpc_peering_connection_id")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationSecurityGroup(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationSecurityGroupRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portRanges":
            suggest = "port_ranges"
        elif key == "prefixListId":
            suggest = "prefix_list_id"
        elif key == "securityGroupId":
            suggest = "security_group_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisExplanationSecurityGroupRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisExplanationSecurityGroupRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisExplanationSecurityGroupRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cidr: Optional[_builtins.str] = None,
                 direction: Optional[_builtins.str] = None,
                 port_ranges: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationSecurityGroupRulePortRange']] = None,
                 prefix_list_id: Optional[_builtins.str] = None,
                 protocol: Optional[_builtins.str] = None,
                 security_group_id: Optional[_builtins.str] = None):
        if cidr is not None:
            pulumi.set(__self__, "cidr", cidr)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if port_ranges is not None:
            pulumi.set(__self__, "port_ranges", port_ranges)
        if prefix_list_id is not None:
            pulumi.set(__self__, "prefix_list_id", prefix_list_id)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if security_group_id is not None:
            pulumi.set(__self__, "security_group_id", security_group_id)

    @_builtins.property
    @pulumi.getter
    def cidr(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cidr")

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "direction")

    @_builtins.property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanationSecurityGroupRulePortRange']]:
        return pulumi.get(self, "port_ranges")

    @_builtins.property
    @pulumi.getter(name="prefixListId")
    def prefix_list_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_list_id")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "security_group_id")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationSecurityGroupRulePortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisExplanationSecurityGroupRulePortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisExplanationSecurityGroupRulePortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisExplanationSecurityGroupRulePortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: Optional[_builtins.int] = None,
                 to: Optional[_builtins.int] = None):
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "to")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationSourceVpc(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationSubnet(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationSubnetRouteTable(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationTransitGateway(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationTransitGatewayAttachment(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationTransitGatewayRouteTable(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationTransitGatewayRouteTableRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attachmentId":
            suggest = "attachment_id"
        elif key == "destinationCidr":
            suggest = "destination_cidr"
        elif key == "prefixListId":
            suggest = "prefix_list_id"
        elif key == "resourceId":
            suggest = "resource_id"
        elif key == "resourceType":
            suggest = "resource_type"
        elif key == "routeOrigin":
            suggest = "route_origin"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisExplanationTransitGatewayRouteTableRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisExplanationTransitGatewayRouteTableRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisExplanationTransitGatewayRouteTableRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attachment_id: Optional[_builtins.str] = None,
                 destination_cidr: Optional[_builtins.str] = None,
                 prefix_list_id: Optional[_builtins.str] = None,
                 resource_id: Optional[_builtins.str] = None,
                 resource_type: Optional[_builtins.str] = None,
                 route_origin: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None):
        if attachment_id is not None:
            pulumi.set(__self__, "attachment_id", attachment_id)
        if destination_cidr is not None:
            pulumi.set(__self__, "destination_cidr", destination_cidr)
        if prefix_list_id is not None:
            pulumi.set(__self__, "prefix_list_id", prefix_list_id)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)
        if route_origin is not None:
            pulumi.set(__self__, "route_origin", route_origin)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="attachmentId")
    def attachment_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "attachment_id")

    @_builtins.property
    @pulumi.getter(name="destinationCidr")
    def destination_cidr(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "destination_cidr")

    @_builtins.property
    @pulumi.getter(name="prefixListId")
    def prefix_list_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_list_id")

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "resource_id")

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "resource_type")

    @_builtins.property
    @pulumi.getter(name="routeOrigin")
    def route_origin(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "route_origin")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "state")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationVpc(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationVpcEndpoint(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationVpcPeeringConnection(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationVpnConnection(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisExplanationVpnGateway(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisForwardPathComponent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aclRules":
            suggest = "acl_rules"
        elif key == "additionalDetails":
            suggest = "additional_details"
        elif key == "attachedTos":
            suggest = "attached_tos"
        elif key == "destinationVpcs":
            suggest = "destination_vpcs"
        elif key == "inboundHeaders":
            suggest = "inbound_headers"
        elif key == "outboundHeaders":
            suggest = "outbound_headers"
        elif key == "routeTableRoutes":
            suggest = "route_table_routes"
        elif key == "securityGroupRules":
            suggest = "security_group_rules"
        elif key == "sequenceNumber":
            suggest = "sequence_number"
        elif key == "sourceVpcs":
            suggest = "source_vpcs"
        elif key == "transitGatewayRouteTableRoutes":
            suggest = "transit_gateway_route_table_routes"
        elif key == "transitGateways":
            suggest = "transit_gateways"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisForwardPathComponent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisForwardPathComponent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisForwardPathComponent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 acl_rules: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentAclRule']] = None,
                 additional_details: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentAdditionalDetail']] = None,
                 attached_tos: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentAttachedTo']] = None,
                 components: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentComponent']] = None,
                 destination_vpcs: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentDestinationVpc']] = None,
                 inbound_headers: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentInboundHeader']] = None,
                 outbound_headers: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentOutboundHeader']] = None,
                 route_table_routes: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentRouteTableRoute']] = None,
                 security_group_rules: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentSecurityGroupRule']] = None,
                 sequence_number: Optional[_builtins.int] = None,
                 source_vpcs: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentSourceVpc']] = None,
                 subnets: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentSubnet']] = None,
                 transit_gateway_route_table_routes: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentTransitGatewayRouteTableRoute']] = None,
                 transit_gateways: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentTransitGateway']] = None,
                 vpcs: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentVpc']] = None):
        if acl_rules is not None:
            pulumi.set(__self__, "acl_rules", acl_rules)
        if additional_details is not None:
            pulumi.set(__self__, "additional_details", additional_details)
        if attached_tos is not None:
            pulumi.set(__self__, "attached_tos", attached_tos)
        if components is not None:
            pulumi.set(__self__, "components", components)
        if destination_vpcs is not None:
            pulumi.set(__self__, "destination_vpcs", destination_vpcs)
        if inbound_headers is not None:
            pulumi.set(__self__, "inbound_headers", inbound_headers)
        if outbound_headers is not None:
            pulumi.set(__self__, "outbound_headers", outbound_headers)
        if route_table_routes is not None:
            pulumi.set(__self__, "route_table_routes", route_table_routes)
        if security_group_rules is not None:
            pulumi.set(__self__, "security_group_rules", security_group_rules)
        if sequence_number is not None:
            pulumi.set(__self__, "sequence_number", sequence_number)
        if source_vpcs is not None:
            pulumi.set(__self__, "source_vpcs", source_vpcs)
        if subnets is not None:
            pulumi.set(__self__, "subnets", subnets)
        if transit_gateway_route_table_routes is not None:
            pulumi.set(__self__, "transit_gateway_route_table_routes", transit_gateway_route_table_routes)
        if transit_gateways is not None:
            pulumi.set(__self__, "transit_gateways", transit_gateways)
        if vpcs is not None:
            pulumi.set(__self__, "vpcs", vpcs)

    @_builtins.property
    @pulumi.getter(name="aclRules")
    def acl_rules(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentAclRule']]:
        return pulumi.get(self, "acl_rules")

    @_builtins.property
    @pulumi.getter(name="additionalDetails")
    def additional_details(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentAdditionalDetail']]:
        return pulumi.get(self, "additional_details")

    @_builtins.property
    @pulumi.getter(name="attachedTos")
    def attached_tos(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentAttachedTo']]:
        return pulumi.get(self, "attached_tos")

    @_builtins.property
    @pulumi.getter
    def components(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentComponent']]:
        return pulumi.get(self, "components")

    @_builtins.property
    @pulumi.getter(name="destinationVpcs")
    def destination_vpcs(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentDestinationVpc']]:
        return pulumi.get(self, "destination_vpcs")

    @_builtins.property
    @pulumi.getter(name="inboundHeaders")
    def inbound_headers(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentInboundHeader']]:
        return pulumi.get(self, "inbound_headers")

    @_builtins.property
    @pulumi.getter(name="outboundHeaders")
    def outbound_headers(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentOutboundHeader']]:
        return pulumi.get(self, "outbound_headers")

    @_builtins.property
    @pulumi.getter(name="routeTableRoutes")
    def route_table_routes(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentRouteTableRoute']]:
        return pulumi.get(self, "route_table_routes")

    @_builtins.property
    @pulumi.getter(name="securityGroupRules")
    def security_group_rules(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentSecurityGroupRule']]:
        return pulumi.get(self, "security_group_rules")

    @_builtins.property
    @pulumi.getter(name="sequenceNumber")
    def sequence_number(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "sequence_number")

    @_builtins.property
    @pulumi.getter(name="sourceVpcs")
    def source_vpcs(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentSourceVpc']]:
        return pulumi.get(self, "source_vpcs")

    @_builtins.property
    @pulumi.getter
    def subnets(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentSubnet']]:
        return pulumi.get(self, "subnets")

    @_builtins.property
    @pulumi.getter(name="transitGatewayRouteTableRoutes")
    def transit_gateway_route_table_routes(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentTransitGatewayRouteTableRoute']]:
        return pulumi.get(self, "transit_gateway_route_table_routes")

    @_builtins.property
    @pulumi.getter(name="transitGateways")
    def transit_gateways(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentTransitGateway']]:
        return pulumi.get(self, "transit_gateways")

    @_builtins.property
    @pulumi.getter
    def vpcs(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentVpc']]:
        return pulumi.get(self, "vpcs")


@pulumi.output_type
class NetworkInsightsAnalysisForwardPathComponentAclRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portRanges":
            suggest = "port_ranges"
        elif key == "ruleAction":
            suggest = "rule_action"
        elif key == "ruleNumber":
            suggest = "rule_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisForwardPathComponentAclRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisForwardPathComponentAclRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisForwardPathComponentAclRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cidr: Optional[_builtins.str] = None,
                 egress: Optional[_builtins.bool] = None,
                 port_ranges: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentAclRulePortRange']] = None,
                 protocol: Optional[_builtins.str] = None,
                 rule_action: Optional[_builtins.str] = None,
                 rule_number: Optional[_builtins.int] = None):
        if cidr is not None:
            pulumi.set(__self__, "cidr", cidr)
        if egress is not None:
            pulumi.set(__self__, "egress", egress)
        if port_ranges is not None:
            pulumi.set(__self__, "port_ranges", port_ranges)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if rule_action is not None:
            pulumi.set(__self__, "rule_action", rule_action)
        if rule_number is not None:
            pulumi.set(__self__, "rule_number", rule_number)

    @_builtins.property
    @pulumi.getter
    def cidr(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cidr")

    @_builtins.property
    @pulumi.getter
    def egress(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "egress")

    @_builtins.property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentAclRulePortRange']]:
        return pulumi.get(self, "port_ranges")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="ruleAction")
    def rule_action(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "rule_action")

    @_builtins.property
    @pulumi.getter(name="ruleNumber")
    def rule_number(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "rule_number")


@pulumi.output_type
class NetworkInsightsAnalysisForwardPathComponentAclRulePortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisForwardPathComponentAclRulePortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisForwardPathComponentAclRulePortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisForwardPathComponentAclRulePortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: Optional[_builtins.int] = None,
                 to: Optional[_builtins.int] = None):
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "to")


@pulumi.output_type
class NetworkInsightsAnalysisForwardPathComponentAdditionalDetail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalDetailType":
            suggest = "additional_detail_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisForwardPathComponentAdditionalDetail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisForwardPathComponentAdditionalDetail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisForwardPathComponentAdditionalDetail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_detail_type: Optional[_builtins.str] = None,
                 components: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentAdditionalDetailComponent']] = None):
        if additional_detail_type is not None:
            pulumi.set(__self__, "additional_detail_type", additional_detail_type)
        if components is not None:
            pulumi.set(__self__, "components", components)

    @_builtins.property
    @pulumi.getter(name="additionalDetailType")
    def additional_detail_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "additional_detail_type")

    @_builtins.property
    @pulumi.getter
    def components(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentAdditionalDetailComponent']]:
        return pulumi.get(self, "components")


@pulumi.output_type
class NetworkInsightsAnalysisForwardPathComponentAdditionalDetailComponent(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisForwardPathComponentAttachedTo(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisForwardPathComponentComponent(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisForwardPathComponentDestinationVpc(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisForwardPathComponentInboundHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationAddresses":
            suggest = "destination_addresses"
        elif key == "destinationPortRanges":
            suggest = "destination_port_ranges"
        elif key == "sourceAddresses":
            suggest = "source_addresses"
        elif key == "sourcePortRanges":
            suggest = "source_port_ranges"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisForwardPathComponentInboundHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisForwardPathComponentInboundHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisForwardPathComponentInboundHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_addresses: Optional[Sequence[_builtins.str]] = None,
                 destination_port_ranges: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentInboundHeaderDestinationPortRange']] = None,
                 protocol: Optional[_builtins.str] = None,
                 source_addresses: Optional[Sequence[_builtins.str]] = None,
                 source_port_ranges: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentInboundHeaderSourcePortRange']] = None):
        if destination_addresses is not None:
            pulumi.set(__self__, "destination_addresses", destination_addresses)
        if destination_port_ranges is not None:
            pulumi.set(__self__, "destination_port_ranges", destination_port_ranges)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if source_addresses is not None:
            pulumi.set(__self__, "source_addresses", source_addresses)
        if source_port_ranges is not None:
            pulumi.set(__self__, "source_port_ranges", source_port_ranges)

    @_builtins.property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "destination_addresses")

    @_builtins.property
    @pulumi.getter(name="destinationPortRanges")
    def destination_port_ranges(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentInboundHeaderDestinationPortRange']]:
        return pulumi.get(self, "destination_port_ranges")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "source_addresses")

    @_builtins.property
    @pulumi.getter(name="sourcePortRanges")
    def source_port_ranges(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentInboundHeaderSourcePortRange']]:
        return pulumi.get(self, "source_port_ranges")


@pulumi.output_type
class NetworkInsightsAnalysisForwardPathComponentInboundHeaderDestinationPortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisForwardPathComponentInboundHeaderDestinationPortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisForwardPathComponentInboundHeaderDestinationPortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisForwardPathComponentInboundHeaderDestinationPortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: Optional[_builtins.int] = None,
                 to: Optional[_builtins.int] = None):
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "to")


@pulumi.output_type
class NetworkInsightsAnalysisForwardPathComponentInboundHeaderSourcePortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisForwardPathComponentInboundHeaderSourcePortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisForwardPathComponentInboundHeaderSourcePortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisForwardPathComponentInboundHeaderSourcePortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: Optional[_builtins.int] = None,
                 to: Optional[_builtins.int] = None):
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "to")


@pulumi.output_type
class NetworkInsightsAnalysisForwardPathComponentOutboundHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationAddresses":
            suggest = "destination_addresses"
        elif key == "destinationPortRanges":
            suggest = "destination_port_ranges"
        elif key == "sourceAddresses":
            suggest = "source_addresses"
        elif key == "sourcePortRanges":
            suggest = "source_port_ranges"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisForwardPathComponentOutboundHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisForwardPathComponentOutboundHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisForwardPathComponentOutboundHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_addresses: Optional[Sequence[_builtins.str]] = None,
                 destination_port_ranges: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentOutboundHeaderDestinationPortRange']] = None,
                 protocol: Optional[_builtins.str] = None,
                 source_addresses: Optional[Sequence[_builtins.str]] = None,
                 source_port_ranges: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentOutboundHeaderSourcePortRange']] = None):
        if destination_addresses is not None:
            pulumi.set(__self__, "destination_addresses", destination_addresses)
        if destination_port_ranges is not None:
            pulumi.set(__self__, "destination_port_ranges", destination_port_ranges)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if source_addresses is not None:
            pulumi.set(__self__, "source_addresses", source_addresses)
        if source_port_ranges is not None:
            pulumi.set(__self__, "source_port_ranges", source_port_ranges)

    @_builtins.property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "destination_addresses")

    @_builtins.property
    @pulumi.getter(name="destinationPortRanges")
    def destination_port_ranges(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentOutboundHeaderDestinationPortRange']]:
        return pulumi.get(self, "destination_port_ranges")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "source_addresses")

    @_builtins.property
    @pulumi.getter(name="sourcePortRanges")
    def source_port_ranges(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentOutboundHeaderSourcePortRange']]:
        return pulumi.get(self, "source_port_ranges")


@pulumi.output_type
class NetworkInsightsAnalysisForwardPathComponentOutboundHeaderDestinationPortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisForwardPathComponentOutboundHeaderDestinationPortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisForwardPathComponentOutboundHeaderDestinationPortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisForwardPathComponentOutboundHeaderDestinationPortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: Optional[_builtins.int] = None,
                 to: Optional[_builtins.int] = None):
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "to")


@pulumi.output_type
class NetworkInsightsAnalysisForwardPathComponentOutboundHeaderSourcePortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisForwardPathComponentOutboundHeaderSourcePortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisForwardPathComponentOutboundHeaderSourcePortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisForwardPathComponentOutboundHeaderSourcePortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: Optional[_builtins.int] = None,
                 to: Optional[_builtins.int] = None):
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "to")


@pulumi.output_type
class NetworkInsightsAnalysisForwardPathComponentRouteTableRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationCidr":
            suggest = "destination_cidr"
        elif key == "destinationPrefixListId":
            suggest = "destination_prefix_list_id"
        elif key == "egressOnlyInternetGatewayId":
            suggest = "egress_only_internet_gateway_id"
        elif key == "gatewayId":
            suggest = "gateway_id"
        elif key == "instanceId":
            suggest = "instance_id"
        elif key == "natGatewayId":
            suggest = "nat_gateway_id"
        elif key == "networkInterfaceId":
            suggest = "network_interface_id"
        elif key == "transitGatewayId":
            suggest = "transit_gateway_id"
        elif key == "vpcPeeringConnectionId":
            suggest = "vpc_peering_connection_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisForwardPathComponentRouteTableRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisForwardPathComponentRouteTableRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisForwardPathComponentRouteTableRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_cidr: Optional[_builtins.str] = None,
                 destination_prefix_list_id: Optional[_builtins.str] = None,
                 egress_only_internet_gateway_id: Optional[_builtins.str] = None,
                 gateway_id: Optional[_builtins.str] = None,
                 instance_id: Optional[_builtins.str] = None,
                 nat_gateway_id: Optional[_builtins.str] = None,
                 network_interface_id: Optional[_builtins.str] = None,
                 origin: Optional[_builtins.str] = None,
                 transit_gateway_id: Optional[_builtins.str] = None,
                 vpc_peering_connection_id: Optional[_builtins.str] = None):
        if destination_cidr is not None:
            pulumi.set(__self__, "destination_cidr", destination_cidr)
        if destination_prefix_list_id is not None:
            pulumi.set(__self__, "destination_prefix_list_id", destination_prefix_list_id)
        if egress_only_internet_gateway_id is not None:
            pulumi.set(__self__, "egress_only_internet_gateway_id", egress_only_internet_gateway_id)
        if gateway_id is not None:
            pulumi.set(__self__, "gateway_id", gateway_id)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if nat_gateway_id is not None:
            pulumi.set(__self__, "nat_gateway_id", nat_gateway_id)
        if network_interface_id is not None:
            pulumi.set(__self__, "network_interface_id", network_interface_id)
        if origin is not None:
            pulumi.set(__self__, "origin", origin)
        if transit_gateway_id is not None:
            pulumi.set(__self__, "transit_gateway_id", transit_gateway_id)
        if vpc_peering_connection_id is not None:
            pulumi.set(__self__, "vpc_peering_connection_id", vpc_peering_connection_id)

    @_builtins.property
    @pulumi.getter(name="destinationCidr")
    def destination_cidr(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "destination_cidr")

    @_builtins.property
    @pulumi.getter(name="destinationPrefixListId")
    def destination_prefix_list_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "destination_prefix_list_id")

    @_builtins.property
    @pulumi.getter(name="egressOnlyInternetGatewayId")
    def egress_only_internet_gateway_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "egress_only_internet_gateway_id")

    @_builtins.property
    @pulumi.getter(name="gatewayId")
    def gateway_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "gateway_id")

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "instance_id")

    @_builtins.property
    @pulumi.getter(name="natGatewayId")
    def nat_gateway_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "nat_gateway_id")

    @_builtins.property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "network_interface_id")

    @_builtins.property
    @pulumi.getter
    def origin(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "origin")

    @_builtins.property
    @pulumi.getter(name="transitGatewayId")
    def transit_gateway_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "transit_gateway_id")

    @_builtins.property
    @pulumi.getter(name="vpcPeeringConnectionId")
    def vpc_peering_connection_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "vpc_peering_connection_id")


@pulumi.output_type
class NetworkInsightsAnalysisForwardPathComponentSecurityGroupRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portRanges":
            suggest = "port_ranges"
        elif key == "prefixListId":
            suggest = "prefix_list_id"
        elif key == "securityGroupId":
            suggest = "security_group_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisForwardPathComponentSecurityGroupRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisForwardPathComponentSecurityGroupRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisForwardPathComponentSecurityGroupRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cidr: Optional[_builtins.str] = None,
                 direction: Optional[_builtins.str] = None,
                 port_ranges: Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentSecurityGroupRulePortRange']] = None,
                 prefix_list_id: Optional[_builtins.str] = None,
                 protocol: Optional[_builtins.str] = None,
                 security_group_id: Optional[_builtins.str] = None):
        if cidr is not None:
            pulumi.set(__self__, "cidr", cidr)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if port_ranges is not None:
            pulumi.set(__self__, "port_ranges", port_ranges)
        if prefix_list_id is not None:
            pulumi.set(__self__, "prefix_list_id", prefix_list_id)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if security_group_id is not None:
            pulumi.set(__self__, "security_group_id", security_group_id)

    @_builtins.property
    @pulumi.getter
    def cidr(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cidr")

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "direction")

    @_builtins.property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisForwardPathComponentSecurityGroupRulePortRange']]:
        return pulumi.get(self, "port_ranges")

    @_builtins.property
    @pulumi.getter(name="prefixListId")
    def prefix_list_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_list_id")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "security_group_id")


@pulumi.output_type
class NetworkInsightsAnalysisForwardPathComponentSecurityGroupRulePortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisForwardPathComponentSecurityGroupRulePortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisForwardPathComponentSecurityGroupRulePortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisForwardPathComponentSecurityGroupRulePortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: Optional[_builtins.int] = None,
                 to: Optional[_builtins.int] = None):
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "to")


@pulumi.output_type
class NetworkInsightsAnalysisForwardPathComponentSourceVpc(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisForwardPathComponentSubnet(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisForwardPathComponentTransitGateway(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisForwardPathComponentTransitGatewayRouteTableRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attachmentId":
            suggest = "attachment_id"
        elif key == "destinationCidr":
            suggest = "destination_cidr"
        elif key == "prefixListId":
            suggest = "prefix_list_id"
        elif key == "resourceId":
            suggest = "resource_id"
        elif key == "resourceType":
            suggest = "resource_type"
        elif key == "routeOrigin":
            suggest = "route_origin"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisForwardPathComponentTransitGatewayRouteTableRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisForwardPathComponentTransitGatewayRouteTableRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisForwardPathComponentTransitGatewayRouteTableRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attachment_id: Optional[_builtins.str] = None,
                 destination_cidr: Optional[_builtins.str] = None,
                 prefix_list_id: Optional[_builtins.str] = None,
                 resource_id: Optional[_builtins.str] = None,
                 resource_type: Optional[_builtins.str] = None,
                 route_origin: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None):
        if attachment_id is not None:
            pulumi.set(__self__, "attachment_id", attachment_id)
        if destination_cidr is not None:
            pulumi.set(__self__, "destination_cidr", destination_cidr)
        if prefix_list_id is not None:
            pulumi.set(__self__, "prefix_list_id", prefix_list_id)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)
        if route_origin is not None:
            pulumi.set(__self__, "route_origin", route_origin)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="attachmentId")
    def attachment_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "attachment_id")

    @_builtins.property
    @pulumi.getter(name="destinationCidr")
    def destination_cidr(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "destination_cidr")

    @_builtins.property
    @pulumi.getter(name="prefixListId")
    def prefix_list_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_list_id")

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "resource_id")

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "resource_type")

    @_builtins.property
    @pulumi.getter(name="routeOrigin")
    def route_origin(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "route_origin")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "state")


@pulumi.output_type
class NetworkInsightsAnalysisForwardPathComponentVpc(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisReturnPathComponent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aclRules":
            suggest = "acl_rules"
        elif key == "additionalDetails":
            suggest = "additional_details"
        elif key == "attachedTos":
            suggest = "attached_tos"
        elif key == "destinationVpcs":
            suggest = "destination_vpcs"
        elif key == "inboundHeaders":
            suggest = "inbound_headers"
        elif key == "outboundHeaders":
            suggest = "outbound_headers"
        elif key == "routeTableRoutes":
            suggest = "route_table_routes"
        elif key == "securityGroupRules":
            suggest = "security_group_rules"
        elif key == "sequenceNumber":
            suggest = "sequence_number"
        elif key == "sourceVpcs":
            suggest = "source_vpcs"
        elif key == "transitGatewayRouteTableRoutes":
            suggest = "transit_gateway_route_table_routes"
        elif key == "transitGateways":
            suggest = "transit_gateways"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisReturnPathComponent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisReturnPathComponent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisReturnPathComponent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 acl_rules: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentAclRule']] = None,
                 additional_details: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentAdditionalDetail']] = None,
                 attached_tos: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentAttachedTo']] = None,
                 components: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentComponent']] = None,
                 destination_vpcs: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentDestinationVpc']] = None,
                 inbound_headers: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentInboundHeader']] = None,
                 outbound_headers: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentOutboundHeader']] = None,
                 route_table_routes: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentRouteTableRoute']] = None,
                 security_group_rules: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentSecurityGroupRule']] = None,
                 sequence_number: Optional[_builtins.int] = None,
                 source_vpcs: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentSourceVpc']] = None,
                 subnets: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentSubnet']] = None,
                 transit_gateway_route_table_routes: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentTransitGatewayRouteTableRoute']] = None,
                 transit_gateways: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentTransitGateway']] = None,
                 vpcs: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentVpc']] = None):
        if acl_rules is not None:
            pulumi.set(__self__, "acl_rules", acl_rules)
        if additional_details is not None:
            pulumi.set(__self__, "additional_details", additional_details)
        if attached_tos is not None:
            pulumi.set(__self__, "attached_tos", attached_tos)
        if components is not None:
            pulumi.set(__self__, "components", components)
        if destination_vpcs is not None:
            pulumi.set(__self__, "destination_vpcs", destination_vpcs)
        if inbound_headers is not None:
            pulumi.set(__self__, "inbound_headers", inbound_headers)
        if outbound_headers is not None:
            pulumi.set(__self__, "outbound_headers", outbound_headers)
        if route_table_routes is not None:
            pulumi.set(__self__, "route_table_routes", route_table_routes)
        if security_group_rules is not None:
            pulumi.set(__self__, "security_group_rules", security_group_rules)
        if sequence_number is not None:
            pulumi.set(__self__, "sequence_number", sequence_number)
        if source_vpcs is not None:
            pulumi.set(__self__, "source_vpcs", source_vpcs)
        if subnets is not None:
            pulumi.set(__self__, "subnets", subnets)
        if transit_gateway_route_table_routes is not None:
            pulumi.set(__self__, "transit_gateway_route_table_routes", transit_gateway_route_table_routes)
        if transit_gateways is not None:
            pulumi.set(__self__, "transit_gateways", transit_gateways)
        if vpcs is not None:
            pulumi.set(__self__, "vpcs", vpcs)

    @_builtins.property
    @pulumi.getter(name="aclRules")
    def acl_rules(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentAclRule']]:
        return pulumi.get(self, "acl_rules")

    @_builtins.property
    @pulumi.getter(name="additionalDetails")
    def additional_details(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentAdditionalDetail']]:
        return pulumi.get(self, "additional_details")

    @_builtins.property
    @pulumi.getter(name="attachedTos")
    def attached_tos(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentAttachedTo']]:
        return pulumi.get(self, "attached_tos")

    @_builtins.property
    @pulumi.getter
    def components(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentComponent']]:
        return pulumi.get(self, "components")

    @_builtins.property
    @pulumi.getter(name="destinationVpcs")
    def destination_vpcs(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentDestinationVpc']]:
        return pulumi.get(self, "destination_vpcs")

    @_builtins.property
    @pulumi.getter(name="inboundHeaders")
    def inbound_headers(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentInboundHeader']]:
        return pulumi.get(self, "inbound_headers")

    @_builtins.property
    @pulumi.getter(name="outboundHeaders")
    def outbound_headers(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentOutboundHeader']]:
        return pulumi.get(self, "outbound_headers")

    @_builtins.property
    @pulumi.getter(name="routeTableRoutes")
    def route_table_routes(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentRouteTableRoute']]:
        return pulumi.get(self, "route_table_routes")

    @_builtins.property
    @pulumi.getter(name="securityGroupRules")
    def security_group_rules(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentSecurityGroupRule']]:
        return pulumi.get(self, "security_group_rules")

    @_builtins.property
    @pulumi.getter(name="sequenceNumber")
    def sequence_number(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "sequence_number")

    @_builtins.property
    @pulumi.getter(name="sourceVpcs")
    def source_vpcs(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentSourceVpc']]:
        return pulumi.get(self, "source_vpcs")

    @_builtins.property
    @pulumi.getter
    def subnets(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentSubnet']]:
        return pulumi.get(self, "subnets")

    @_builtins.property
    @pulumi.getter(name="transitGatewayRouteTableRoutes")
    def transit_gateway_route_table_routes(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentTransitGatewayRouteTableRoute']]:
        return pulumi.get(self, "transit_gateway_route_table_routes")

    @_builtins.property
    @pulumi.getter(name="transitGateways")
    def transit_gateways(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentTransitGateway']]:
        return pulumi.get(self, "transit_gateways")

    @_builtins.property
    @pulumi.getter
    def vpcs(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentVpc']]:
        return pulumi.get(self, "vpcs")


@pulumi.output_type
class NetworkInsightsAnalysisReturnPathComponentAclRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portRanges":
            suggest = "port_ranges"
        elif key == "ruleAction":
            suggest = "rule_action"
        elif key == "ruleNumber":
            suggest = "rule_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisReturnPathComponentAclRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisReturnPathComponentAclRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisReturnPathComponentAclRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cidr: Optional[_builtins.str] = None,
                 egress: Optional[_builtins.bool] = None,
                 port_ranges: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentAclRulePortRange']] = None,
                 protocol: Optional[_builtins.str] = None,
                 rule_action: Optional[_builtins.str] = None,
                 rule_number: Optional[_builtins.int] = None):
        if cidr is not None:
            pulumi.set(__self__, "cidr", cidr)
        if egress is not None:
            pulumi.set(__self__, "egress", egress)
        if port_ranges is not None:
            pulumi.set(__self__, "port_ranges", port_ranges)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if rule_action is not None:
            pulumi.set(__self__, "rule_action", rule_action)
        if rule_number is not None:
            pulumi.set(__self__, "rule_number", rule_number)

    @_builtins.property
    @pulumi.getter
    def cidr(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cidr")

    @_builtins.property
    @pulumi.getter
    def egress(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "egress")

    @_builtins.property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentAclRulePortRange']]:
        return pulumi.get(self, "port_ranges")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="ruleAction")
    def rule_action(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "rule_action")

    @_builtins.property
    @pulumi.getter(name="ruleNumber")
    def rule_number(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "rule_number")


@pulumi.output_type
class NetworkInsightsAnalysisReturnPathComponentAclRulePortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisReturnPathComponentAclRulePortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisReturnPathComponentAclRulePortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisReturnPathComponentAclRulePortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: Optional[_builtins.int] = None,
                 to: Optional[_builtins.int] = None):
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "to")


@pulumi.output_type
class NetworkInsightsAnalysisReturnPathComponentAdditionalDetail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalDetailType":
            suggest = "additional_detail_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisReturnPathComponentAdditionalDetail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisReturnPathComponentAdditionalDetail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisReturnPathComponentAdditionalDetail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_detail_type: Optional[_builtins.str] = None,
                 components: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentAdditionalDetailComponent']] = None):
        if additional_detail_type is not None:
            pulumi.set(__self__, "additional_detail_type", additional_detail_type)
        if components is not None:
            pulumi.set(__self__, "components", components)

    @_builtins.property
    @pulumi.getter(name="additionalDetailType")
    def additional_detail_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "additional_detail_type")

    @_builtins.property
    @pulumi.getter
    def components(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentAdditionalDetailComponent']]:
        return pulumi.get(self, "components")


@pulumi.output_type
class NetworkInsightsAnalysisReturnPathComponentAdditionalDetailComponent(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisReturnPathComponentAttachedTo(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisReturnPathComponentComponent(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisReturnPathComponentDestinationVpc(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisReturnPathComponentInboundHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationAddresses":
            suggest = "destination_addresses"
        elif key == "destinationPortRanges":
            suggest = "destination_port_ranges"
        elif key == "sourceAddresses":
            suggest = "source_addresses"
        elif key == "sourcePortRanges":
            suggest = "source_port_ranges"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisReturnPathComponentInboundHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisReturnPathComponentInboundHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisReturnPathComponentInboundHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_addresses: Optional[Sequence[_builtins.str]] = None,
                 destination_port_ranges: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentInboundHeaderDestinationPortRange']] = None,
                 protocol: Optional[_builtins.str] = None,
                 source_addresses: Optional[Sequence[_builtins.str]] = None,
                 source_port_ranges: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentInboundHeaderSourcePortRange']] = None):
        if destination_addresses is not None:
            pulumi.set(__self__, "destination_addresses", destination_addresses)
        if destination_port_ranges is not None:
            pulumi.set(__self__, "destination_port_ranges", destination_port_ranges)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if source_addresses is not None:
            pulumi.set(__self__, "source_addresses", source_addresses)
        if source_port_ranges is not None:
            pulumi.set(__self__, "source_port_ranges", source_port_ranges)

    @_builtins.property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "destination_addresses")

    @_builtins.property
    @pulumi.getter(name="destinationPortRanges")
    def destination_port_ranges(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentInboundHeaderDestinationPortRange']]:
        return pulumi.get(self, "destination_port_ranges")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "source_addresses")

    @_builtins.property
    @pulumi.getter(name="sourcePortRanges")
    def source_port_ranges(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentInboundHeaderSourcePortRange']]:
        return pulumi.get(self, "source_port_ranges")


@pulumi.output_type
class NetworkInsightsAnalysisReturnPathComponentInboundHeaderDestinationPortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisReturnPathComponentInboundHeaderDestinationPortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisReturnPathComponentInboundHeaderDestinationPortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisReturnPathComponentInboundHeaderDestinationPortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: Optional[_builtins.int] = None,
                 to: Optional[_builtins.int] = None):
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "to")


@pulumi.output_type
class NetworkInsightsAnalysisReturnPathComponentInboundHeaderSourcePortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisReturnPathComponentInboundHeaderSourcePortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisReturnPathComponentInboundHeaderSourcePortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisReturnPathComponentInboundHeaderSourcePortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: Optional[_builtins.int] = None,
                 to: Optional[_builtins.int] = None):
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "to")


@pulumi.output_type
class NetworkInsightsAnalysisReturnPathComponentOutboundHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationAddresses":
            suggest = "destination_addresses"
        elif key == "destinationPortRanges":
            suggest = "destination_port_ranges"
        elif key == "sourceAddresses":
            suggest = "source_addresses"
        elif key == "sourcePortRanges":
            suggest = "source_port_ranges"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisReturnPathComponentOutboundHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisReturnPathComponentOutboundHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisReturnPathComponentOutboundHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_addresses: Optional[Sequence[_builtins.str]] = None,
                 destination_port_ranges: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentOutboundHeaderDestinationPortRange']] = None,
                 protocol: Optional[_builtins.str] = None,
                 source_addresses: Optional[Sequence[_builtins.str]] = None,
                 source_port_ranges: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentOutboundHeaderSourcePortRange']] = None):
        if destination_addresses is not None:
            pulumi.set(__self__, "destination_addresses", destination_addresses)
        if destination_port_ranges is not None:
            pulumi.set(__self__, "destination_port_ranges", destination_port_ranges)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if source_addresses is not None:
            pulumi.set(__self__, "source_addresses", source_addresses)
        if source_port_ranges is not None:
            pulumi.set(__self__, "source_port_ranges", source_port_ranges)

    @_builtins.property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "destination_addresses")

    @_builtins.property
    @pulumi.getter(name="destinationPortRanges")
    def destination_port_ranges(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentOutboundHeaderDestinationPortRange']]:
        return pulumi.get(self, "destination_port_ranges")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "source_addresses")

    @_builtins.property
    @pulumi.getter(name="sourcePortRanges")
    def source_port_ranges(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentOutboundHeaderSourcePortRange']]:
        return pulumi.get(self, "source_port_ranges")


@pulumi.output_type
class NetworkInsightsAnalysisReturnPathComponentOutboundHeaderDestinationPortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisReturnPathComponentOutboundHeaderDestinationPortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisReturnPathComponentOutboundHeaderDestinationPortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisReturnPathComponentOutboundHeaderDestinationPortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: Optional[_builtins.int] = None,
                 to: Optional[_builtins.int] = None):
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "to")


@pulumi.output_type
class NetworkInsightsAnalysisReturnPathComponentOutboundHeaderSourcePortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisReturnPathComponentOutboundHeaderSourcePortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisReturnPathComponentOutboundHeaderSourcePortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisReturnPathComponentOutboundHeaderSourcePortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: Optional[_builtins.int] = None,
                 to: Optional[_builtins.int] = None):
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "to")


@pulumi.output_type
class NetworkInsightsAnalysisReturnPathComponentRouteTableRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationCidr":
            suggest = "destination_cidr"
        elif key == "destinationPrefixListId":
            suggest = "destination_prefix_list_id"
        elif key == "egressOnlyInternetGatewayId":
            suggest = "egress_only_internet_gateway_id"
        elif key == "gatewayId":
            suggest = "gateway_id"
        elif key == "instanceId":
            suggest = "instance_id"
        elif key == "natGatewayId":
            suggest = "nat_gateway_id"
        elif key == "networkInterfaceId":
            suggest = "network_interface_id"
        elif key == "transitGatewayId":
            suggest = "transit_gateway_id"
        elif key == "vpcPeeringConnectionId":
            suggest = "vpc_peering_connection_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisReturnPathComponentRouteTableRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisReturnPathComponentRouteTableRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisReturnPathComponentRouteTableRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_cidr: Optional[_builtins.str] = None,
                 destination_prefix_list_id: Optional[_builtins.str] = None,
                 egress_only_internet_gateway_id: Optional[_builtins.str] = None,
                 gateway_id: Optional[_builtins.str] = None,
                 instance_id: Optional[_builtins.str] = None,
                 nat_gateway_id: Optional[_builtins.str] = None,
                 network_interface_id: Optional[_builtins.str] = None,
                 origin: Optional[_builtins.str] = None,
                 transit_gateway_id: Optional[_builtins.str] = None,
                 vpc_peering_connection_id: Optional[_builtins.str] = None):
        if destination_cidr is not None:
            pulumi.set(__self__, "destination_cidr", destination_cidr)
        if destination_prefix_list_id is not None:
            pulumi.set(__self__, "destination_prefix_list_id", destination_prefix_list_id)
        if egress_only_internet_gateway_id is not None:
            pulumi.set(__self__, "egress_only_internet_gateway_id", egress_only_internet_gateway_id)
        if gateway_id is not None:
            pulumi.set(__self__, "gateway_id", gateway_id)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if nat_gateway_id is not None:
            pulumi.set(__self__, "nat_gateway_id", nat_gateway_id)
        if network_interface_id is not None:
            pulumi.set(__self__, "network_interface_id", network_interface_id)
        if origin is not None:
            pulumi.set(__self__, "origin", origin)
        if transit_gateway_id is not None:
            pulumi.set(__self__, "transit_gateway_id", transit_gateway_id)
        if vpc_peering_connection_id is not None:
            pulumi.set(__self__, "vpc_peering_connection_id", vpc_peering_connection_id)

    @_builtins.property
    @pulumi.getter(name="destinationCidr")
    def destination_cidr(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "destination_cidr")

    @_builtins.property
    @pulumi.getter(name="destinationPrefixListId")
    def destination_prefix_list_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "destination_prefix_list_id")

    @_builtins.property
    @pulumi.getter(name="egressOnlyInternetGatewayId")
    def egress_only_internet_gateway_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "egress_only_internet_gateway_id")

    @_builtins.property
    @pulumi.getter(name="gatewayId")
    def gateway_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "gateway_id")

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "instance_id")

    @_builtins.property
    @pulumi.getter(name="natGatewayId")
    def nat_gateway_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "nat_gateway_id")

    @_builtins.property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "network_interface_id")

    @_builtins.property
    @pulumi.getter
    def origin(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "origin")

    @_builtins.property
    @pulumi.getter(name="transitGatewayId")
    def transit_gateway_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "transit_gateway_id")

    @_builtins.property
    @pulumi.getter(name="vpcPeeringConnectionId")
    def vpc_peering_connection_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "vpc_peering_connection_id")


@pulumi.output_type
class NetworkInsightsAnalysisReturnPathComponentSecurityGroupRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portRanges":
            suggest = "port_ranges"
        elif key == "prefixListId":
            suggest = "prefix_list_id"
        elif key == "securityGroupId":
            suggest = "security_group_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisReturnPathComponentSecurityGroupRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisReturnPathComponentSecurityGroupRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisReturnPathComponentSecurityGroupRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cidr: Optional[_builtins.str] = None,
                 direction: Optional[_builtins.str] = None,
                 port_ranges: Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentSecurityGroupRulePortRange']] = None,
                 prefix_list_id: Optional[_builtins.str] = None,
                 protocol: Optional[_builtins.str] = None,
                 security_group_id: Optional[_builtins.str] = None):
        if cidr is not None:
            pulumi.set(__self__, "cidr", cidr)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if port_ranges is not None:
            pulumi.set(__self__, "port_ranges", port_ranges)
        if prefix_list_id is not None:
            pulumi.set(__self__, "prefix_list_id", prefix_list_id)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if security_group_id is not None:
            pulumi.set(__self__, "security_group_id", security_group_id)

    @_builtins.property
    @pulumi.getter
    def cidr(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cidr")

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "direction")

    @_builtins.property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisReturnPathComponentSecurityGroupRulePortRange']]:
        return pulumi.get(self, "port_ranges")

    @_builtins.property
    @pulumi.getter(name="prefixListId")
    def prefix_list_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_list_id")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "security_group_id")


@pulumi.output_type
class NetworkInsightsAnalysisReturnPathComponentSecurityGroupRulePortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisReturnPathComponentSecurityGroupRulePortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisReturnPathComponentSecurityGroupRulePortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisReturnPathComponentSecurityGroupRulePortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: Optional[_builtins.int] = None,
                 to: Optional[_builtins.int] = None):
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "to")


@pulumi.output_type
class NetworkInsightsAnalysisReturnPathComponentSourceVpc(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisReturnPathComponentSubnet(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisReturnPathComponentTransitGateway(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsAnalysisReturnPathComponentTransitGatewayRouteTableRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attachmentId":
            suggest = "attachment_id"
        elif key == "destinationCidr":
            suggest = "destination_cidr"
        elif key == "prefixListId":
            suggest = "prefix_list_id"
        elif key == "resourceId":
            suggest = "resource_id"
        elif key == "resourceType":
            suggest = "resource_type"
        elif key == "routeOrigin":
            suggest = "route_origin"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisReturnPathComponentTransitGatewayRouteTableRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisReturnPathComponentTransitGatewayRouteTableRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisReturnPathComponentTransitGatewayRouteTableRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attachment_id: Optional[_builtins.str] = None,
                 destination_cidr: Optional[_builtins.str] = None,
                 prefix_list_id: Optional[_builtins.str] = None,
                 resource_id: Optional[_builtins.str] = None,
                 resource_type: Optional[_builtins.str] = None,
                 route_origin: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None):
        if attachment_id is not None:
            pulumi.set(__self__, "attachment_id", attachment_id)
        if destination_cidr is not None:
            pulumi.set(__self__, "destination_cidr", destination_cidr)
        if prefix_list_id is not None:
            pulumi.set(__self__, "prefix_list_id", prefix_list_id)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)
        if route_origin is not None:
            pulumi.set(__self__, "route_origin", route_origin)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="attachmentId")
    def attachment_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "attachment_id")

    @_builtins.property
    @pulumi.getter(name="destinationCidr")
    def destination_cidr(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "destination_cidr")

    @_builtins.property
    @pulumi.getter(name="prefixListId")
    def prefix_list_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_list_id")

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "resource_id")

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "resource_type")

    @_builtins.property
    @pulumi.getter(name="routeOrigin")
    def route_origin(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "route_origin")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "state")


@pulumi.output_type
class NetworkInsightsAnalysisReturnPathComponentVpc(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworkInsightsPathFilterAtDestination(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationAddress":
            suggest = "destination_address"
        elif key == "destinationPortRange":
            suggest = "destination_port_range"
        elif key == "sourceAddress":
            suggest = "source_address"
        elif key == "sourcePortRange":
            suggest = "source_port_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsPathFilterAtDestination. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsPathFilterAtDestination.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsPathFilterAtDestination.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_address: Optional[_builtins.str] = None,
                 destination_port_range: Optional['outputs.NetworkInsightsPathFilterAtDestinationDestinationPortRange'] = None,
                 source_address: Optional[_builtins.str] = None,
                 source_port_range: Optional['outputs.NetworkInsightsPathFilterAtDestinationSourcePortRange'] = None):
        if destination_address is not None:
            pulumi.set(__self__, "destination_address", destination_address)
        if destination_port_range is not None:
            pulumi.set(__self__, "destination_port_range", destination_port_range)
        if source_address is not None:
            pulumi.set(__self__, "source_address", source_address)
        if source_port_range is not None:
            pulumi.set(__self__, "source_port_range", source_port_range)

    @_builtins.property
    @pulumi.getter(name="destinationAddress")
    def destination_address(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "destination_address")

    @_builtins.property
    @pulumi.getter(name="destinationPortRange")
    def destination_port_range(self) -> Optional['outputs.NetworkInsightsPathFilterAtDestinationDestinationPortRange']:
        return pulumi.get(self, "destination_port_range")

    @_builtins.property
    @pulumi.getter(name="sourceAddress")
    def source_address(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "source_address")

    @_builtins.property
    @pulumi.getter(name="sourcePortRange")
    def source_port_range(self) -> Optional['outputs.NetworkInsightsPathFilterAtDestinationSourcePortRange']:
        return pulumi.get(self, "source_port_range")


@pulumi.output_type
class NetworkInsightsPathFilterAtDestinationDestinationPortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromPort":
            suggest = "from_port"
        elif key == "toPort":
            suggest = "to_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsPathFilterAtDestinationDestinationPortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsPathFilterAtDestinationDestinationPortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsPathFilterAtDestinationDestinationPortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_port: Optional[_builtins.int] = None,
                 to_port: Optional[_builtins.int] = None):
        if from_port is not None:
            pulumi.set(__self__, "from_port", from_port)
        if to_port is not None:
            pulumi.set(__self__, "to_port", to_port)

    @_builtins.property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "from_port")

    @_builtins.property
    @pulumi.getter(name="toPort")
    def to_port(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "to_port")


@pulumi.output_type
class NetworkInsightsPathFilterAtDestinationSourcePortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromPort":
            suggest = "from_port"
        elif key == "toPort":
            suggest = "to_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsPathFilterAtDestinationSourcePortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsPathFilterAtDestinationSourcePortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsPathFilterAtDestinationSourcePortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_port: Optional[_builtins.int] = None,
                 to_port: Optional[_builtins.int] = None):
        if from_port is not None:
            pulumi.set(__self__, "from_port", from_port)
        if to_port is not None:
            pulumi.set(__self__, "to_port", to_port)

    @_builtins.property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "from_port")

    @_builtins.property
    @pulumi.getter(name="toPort")
    def to_port(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "to_port")


@pulumi.output_type
class NetworkInsightsPathFilterAtSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationAddress":
            suggest = "destination_address"
        elif key == "destinationPortRange":
            suggest = "destination_port_range"
        elif key == "sourceAddress":
            suggest = "source_address"
        elif key == "sourcePortRange":
            suggest = "source_port_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsPathFilterAtSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsPathFilterAtSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsPathFilterAtSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_address: Optional[_builtins.str] = None,
                 destination_port_range: Optional['outputs.NetworkInsightsPathFilterAtSourceDestinationPortRange'] = None,
                 source_address: Optional[_builtins.str] = None,
                 source_port_range: Optional['outputs.NetworkInsightsPathFilterAtSourceSourcePortRange'] = None):
        if destination_address is not None:
            pulumi.set(__self__, "destination_address", destination_address)
        if destination_port_range is not None:
            pulumi.set(__self__, "destination_port_range", destination_port_range)
        if source_address is not None:
            pulumi.set(__self__, "source_address", source_address)
        if source_port_range is not None:
            pulumi.set(__self__, "source_port_range", source_port_range)

    @_builtins.property
    @pulumi.getter(name="destinationAddress")
    def destination_address(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "destination_address")

    @_builtins.property
    @pulumi.getter(name="destinationPortRange")
    def destination_port_range(self) -> Optional['outputs.NetworkInsightsPathFilterAtSourceDestinationPortRange']:
        return pulumi.get(self, "destination_port_range")

    @_builtins.property
    @pulumi.getter(name="sourceAddress")
    def source_address(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "source_address")

    @_builtins.property
    @pulumi.getter(name="sourcePortRange")
    def source_port_range(self) -> Optional['outputs.NetworkInsightsPathFilterAtSourceSourcePortRange']:
        return pulumi.get(self, "source_port_range")


@pulumi.output_type
class NetworkInsightsPathFilterAtSourceDestinationPortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromPort":
            suggest = "from_port"
        elif key == "toPort":
            suggest = "to_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsPathFilterAtSourceDestinationPortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsPathFilterAtSourceDestinationPortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsPathFilterAtSourceDestinationPortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_port: Optional[_builtins.int] = None,
                 to_port: Optional[_builtins.int] = None):
        if from_port is not None:
            pulumi.set(__self__, "from_port", from_port)
        if to_port is not None:
            pulumi.set(__self__, "to_port", to_port)

    @_builtins.property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "from_port")

    @_builtins.property
    @pulumi.getter(name="toPort")
    def to_port(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "to_port")


@pulumi.output_type
class NetworkInsightsPathFilterAtSourceSourcePortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromPort":
            suggest = "from_port"
        elif key == "toPort":
            suggest = "to_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsPathFilterAtSourceSourcePortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsPathFilterAtSourceSourcePortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsPathFilterAtSourceSourcePortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_port: Optional[_builtins.int] = None,
                 to_port: Optional[_builtins.int] = None):
        if from_port is not None:
            pulumi.set(__self__, "from_port", from_port)
        if to_port is not None:
            pulumi.set(__self__, "to_port", to_port)

    @_builtins.property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "from_port")

    @_builtins.property
    @pulumi.getter(name="toPort")
    def to_port(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "to_port")


@pulumi.output_type
class NetworkInterfaceAttachment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceIndex":
            suggest = "device_index"
        elif key == "attachmentId":
            suggest = "attachment_id"
        elif key == "networkCardIndex":
            suggest = "network_card_index"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInterfaceAttachment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInterfaceAttachment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInterfaceAttachment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_index: _builtins.int,
                 instance: _builtins.str,
                 attachment_id: Optional[_builtins.str] = None,
                 network_card_index: Optional[_builtins.int] = None):
        pulumi.set(__self__, "device_index", device_index)
        pulumi.set(__self__, "instance", instance)
        if attachment_id is not None:
            pulumi.set(__self__, "attachment_id", attachment_id)
        if network_card_index is not None:
            pulumi.set(__self__, "network_card_index", network_card_index)

    @_builtins.property
    @pulumi.getter(name="deviceIndex")
    def device_index(self) -> _builtins.int:
        return pulumi.get(self, "device_index")

    @_builtins.property
    @pulumi.getter
    def instance(self) -> _builtins.str:
        return pulumi.get(self, "instance")

    @_builtins.property
    @pulumi.getter(name="attachmentId")
    def attachment_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "attachment_id")

    @_builtins.property
    @pulumi.getter(name="networkCardIndex")
    def network_card_index(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "network_card_index")


@pulumi.output_type
class NetworkInterfacePermissionTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[_builtins.str] = None,
                 delete: Optional[_builtins.str] = None):
        """
        :param _builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param _builtins.str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")


@pulumi.output_type
class PeeringConnectionOptionsAccepter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowRemoteVpcDnsResolution":
            suggest = "allow_remote_vpc_dns_resolution"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PeeringConnectionOptionsAccepter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PeeringConnectionOptionsAccepter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PeeringConnectionOptionsAccepter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_remote_vpc_dns_resolution: Optional[_builtins.bool] = None):
        if allow_remote_vpc_dns_resolution is not None:
            pulumi.set(__self__, "allow_remote_vpc_dns_resolution", allow_remote_vpc_dns_resolution)

    @_builtins.property
    @pulumi.getter(name="allowRemoteVpcDnsResolution")
    def allow_remote_vpc_dns_resolution(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "allow_remote_vpc_dns_resolution")


@pulumi.output_type
class PeeringConnectionOptionsRequester(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowRemoteVpcDnsResolution":
            suggest = "allow_remote_vpc_dns_resolution"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PeeringConnectionOptionsRequester. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PeeringConnectionOptionsRequester.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PeeringConnectionOptionsRequester.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_remote_vpc_dns_resolution: Optional[_builtins.bool] = None):
        if allow_remote_vpc_dns_resolution is not None:
            pulumi.set(__self__, "allow_remote_vpc_dns_resolution", allow_remote_vpc_dns_resolution)

    @_builtins.property
    @pulumi.getter(name="allowRemoteVpcDnsResolution")
    def allow_remote_vpc_dns_resolution(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "allow_remote_vpc_dns_resolution")


@pulumi.output_type
class RouteTableRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "carrierGatewayId":
            suggest = "carrier_gateway_id"
        elif key == "cidrBlock":
            suggest = "cidr_block"
        elif key == "coreNetworkArn":
            suggest = "core_network_arn"
        elif key == "destinationPrefixListId":
            suggest = "destination_prefix_list_id"
        elif key == "egressOnlyGatewayId":
            suggest = "egress_only_gateway_id"
        elif key == "gatewayId":
            suggest = "gateway_id"
        elif key == "ipv6CidrBlock":
            suggest = "ipv6_cidr_block"
        elif key == "localGatewayId":
            suggest = "local_gateway_id"
        elif key == "natGatewayId":
            suggest = "nat_gateway_id"
        elif key == "networkInterfaceId":
            suggest = "network_interface_id"
        elif key == "transitGatewayId":
            suggest = "transit_gateway_id"
        elif key == "vpcEndpointId":
            suggest = "vpc_endpoint_id"
        elif key == "vpcPeeringConnectionId":
            suggest = "vpc_peering_connection_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RouteTableRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RouteTableRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RouteTableRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 carrier_gateway_id: Optional[_builtins.str] = None,
                 cidr_block: Optional[_builtins.str] = None,
                 core_network_arn: Optional[_builtins.str] = None,
                 destination_prefix_list_id: Optional[_builtins.str] = None,
                 egress_only_gateway_id: Optional[_builtins.str] = None,
                 gateway_id: Optional[_builtins.str] = None,
                 ipv6_cidr_block: Optional[_builtins.str] = None,
                 local_gateway_id: Optional[_builtins.str] = None,
                 nat_gateway_id: Optional[_builtins.str] = None,
                 network_interface_id: Optional[_builtins.str] = None,
                 transit_gateway_id: Optional[_builtins.str] = None,
                 vpc_endpoint_id: Optional[_builtins.str] = None,
                 vpc_peering_connection_id: Optional[_builtins.str] = None):
        if carrier_gateway_id is not None:
            pulumi.set(__self__, "carrier_gateway_id", carrier_gateway_id)
        if cidr_block is not None:
            pulumi.set(__self__, "cidr_block", cidr_block)
        if core_network_arn is not None:
            pulumi.set(__self__, "core_network_arn", core_network_arn)
        if destination_prefix_list_id is not None:
            pulumi.set(__self__, "destination_prefix_list_id", destination_prefix_list_id)
        if egress_only_gateway_id is not None:
            pulumi.set(__self__, "egress_only_gateway_id", egress_only_gateway_id)
        if gateway_id is not None:
            pulumi.set(__self__, "gateway_id", gateway_id)
        if ipv6_cidr_block is not None:
            pulumi.set(__self__, "ipv6_cidr_block", ipv6_cidr_block)
        if local_gateway_id is not None:
            pulumi.set(__self__, "local_gateway_id", local_gateway_id)
        if nat_gateway_id is not None:
            pulumi.set(__self__, "nat_gateway_id", nat_gateway_id)
        if network_interface_id is not None:
            pulumi.set(__self__, "network_interface_id", network_interface_id)
        if transit_gateway_id is not None:
            pulumi.set(__self__, "transit_gateway_id", transit_gateway_id)
        if vpc_endpoint_id is not None:
            pulumi.set(__self__, "vpc_endpoint_id", vpc_endpoint_id)
        if vpc_peering_connection_id is not None:
            pulumi.set(__self__, "vpc_peering_connection_id", vpc_peering_connection_id)

    @_builtins.property
    @pulumi.getter(name="carrierGatewayId")
    def carrier_gateway_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "carrier_gateway_id")

    @_builtins.property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cidr_block")

    @_builtins.property
    @pulumi.getter(name="coreNetworkArn")
    def core_network_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "core_network_arn")

    @_builtins.property
    @pulumi.getter(name="destinationPrefixListId")
    def destination_prefix_list_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "destination_prefix_list_id")

    @_builtins.property
    @pulumi.getter(name="egressOnlyGatewayId")
    def egress_only_gateway_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "egress_only_gateway_id")

    @_builtins.property
    @pulumi.getter(name="gatewayId")
    def gateway_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "gateway_id")

    @_builtins.property
    @pulumi.getter(name="ipv6CidrBlock")
    def ipv6_cidr_block(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ipv6_cidr_block")

    @_builtins.property
    @pulumi.getter(name="localGatewayId")
    def local_gateway_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "local_gateway_id")

    @_builtins.property
    @pulumi.getter(name="natGatewayId")
    def nat_gateway_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "nat_gateway_id")

    @_builtins.property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "network_interface_id")

    @_builtins.property
    @pulumi.getter(name="transitGatewayId")
    def transit_gateway_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "transit_gateway_id")

    @_builtins.property
    @pulumi.getter(name="vpcEndpointId")
    def vpc_endpoint_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "vpc_endpoint_id")

    @_builtins.property
    @pulumi.getter(name="vpcPeeringConnectionId")
    def vpc_peering_connection_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "vpc_peering_connection_id")


@pulumi.output_type
class SecurityGroupEgress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromPort":
            suggest = "from_port"
        elif key == "toPort":
            suggest = "to_port"
        elif key == "cidrBlocks":
            suggest = "cidr_blocks"
        elif key == "ipv6CidrBlocks":
            suggest = "ipv6_cidr_blocks"
        elif key == "prefixListIds":
            suggest = "prefix_list_ids"
        elif key == "securityGroups":
            suggest = "security_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityGroupEgress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityGroupEgress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityGroupEgress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_port: _builtins.int,
                 protocol: _builtins.str,
                 to_port: _builtins.int,
                 cidr_blocks: Optional[Sequence[_builtins.str]] = None,
                 description: Optional[_builtins.str] = None,
                 ipv6_cidr_blocks: Optional[Sequence[_builtins.str]] = None,
                 prefix_list_ids: Optional[Sequence[_builtins.str]] = None,
                 security_groups: Optional[Sequence[_builtins.str]] = None,
                 self: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "from_port", from_port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "to_port", to_port)
        if cidr_blocks is not None:
            pulumi.set(__self__, "cidr_blocks", cidr_blocks)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if ipv6_cidr_blocks is not None:
            pulumi.set(__self__, "ipv6_cidr_blocks", ipv6_cidr_blocks)
        if prefix_list_ids is not None:
            pulumi.set(__self__, "prefix_list_ids", prefix_list_ids)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if self is not None:
            pulumi.set(__self__, "self", self)

    @_builtins.property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> _builtins.int:
        return pulumi.get(self, "from_port")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="toPort")
    def to_port(self) -> _builtins.int:
        return pulumi.get(self, "to_port")

    @_builtins.property
    @pulumi.getter(name="cidrBlocks")
    def cidr_blocks(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "cidr_blocks")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="ipv6CidrBlocks")
    def ipv6_cidr_blocks(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "ipv6_cidr_blocks")

    @_builtins.property
    @pulumi.getter(name="prefixListIds")
    def prefix_list_ids(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "prefix_list_ids")

    @_builtins.property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "security_groups")

    @_builtins.property
    @pulumi.getter
    def self(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "self")


@pulumi.output_type
class SecurityGroupIngress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromPort":
            suggest = "from_port"
        elif key == "toPort":
            suggest = "to_port"
        elif key == "cidrBlocks":
            suggest = "cidr_blocks"
        elif key == "ipv6CidrBlocks":
            suggest = "ipv6_cidr_blocks"
        elif key == "prefixListIds":
            suggest = "prefix_list_ids"
        elif key == "securityGroups":
            suggest = "security_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityGroupIngress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityGroupIngress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityGroupIngress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_port: _builtins.int,
                 protocol: _builtins.str,
                 to_port: _builtins.int,
                 cidr_blocks: Optional[Sequence[_builtins.str]] = None,
                 description: Optional[_builtins.str] = None,
                 ipv6_cidr_blocks: Optional[Sequence[_builtins.str]] = None,
                 prefix_list_ids: Optional[Sequence[_builtins.str]] = None,
                 security_groups: Optional[Sequence[_builtins.str]] = None,
                 self: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "from_port", from_port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "to_port", to_port)
        if cidr_blocks is not None:
            pulumi.set(__self__, "cidr_blocks", cidr_blocks)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if ipv6_cidr_blocks is not None:
            pulumi.set(__self__, "ipv6_cidr_blocks", ipv6_cidr_blocks)
        if prefix_list_ids is not None:
            pulumi.set(__self__, "prefix_list_ids", prefix_list_ids)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if self is not None:
            pulumi.set(__self__, "self", self)

    @_builtins.property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> _builtins.int:
        return pulumi.get(self, "from_port")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="toPort")
    def to_port(self) -> _builtins.int:
        return pulumi.get(self, "to_port")

    @_builtins.property
    @pulumi.getter(name="cidrBlocks")
    def cidr_blocks(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "cidr_blocks")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="ipv6CidrBlocks")
    def ipv6_cidr_blocks(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "ipv6_cidr_blocks")

    @_builtins.property
    @pulumi.getter(name="prefixListIds")
    def prefix_list_ids(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "prefix_list_ids")

    @_builtins.property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "security_groups")

    @_builtins.property
    @pulumi.getter
    def self(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "self")


@pulumi.output_type
class SpotFleetRequestLaunchSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceType":
            suggest = "instance_type"
        elif key == "associatePublicIpAddress":
            suggest = "associate_public_ip_address"
        elif key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "ebsBlockDevices":
            suggest = "ebs_block_devices"
        elif key == "ebsOptimized":
            suggest = "ebs_optimized"
        elif key == "ephemeralBlockDevices":
            suggest = "ephemeral_block_devices"
        elif key == "iamInstanceProfile":
            suggest = "iam_instance_profile"
        elif key == "iamInstanceProfileArn":
            suggest = "iam_instance_profile_arn"
        elif key == "keyName":
            suggest = "key_name"
        elif key == "placementGroup":
            suggest = "placement_group"
        elif key == "placementTenancy":
            suggest = "placement_tenancy"
        elif key == "rootBlockDevices":
            suggest = "root_block_devices"
        elif key == "spotPrice":
            suggest = "spot_price"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "userData":
            suggest = "user_data"
        elif key == "vpcSecurityGroupIds":
            suggest = "vpc_security_group_ids"
        elif key == "weightedCapacity":
            suggest = "weighted_capacity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetRequestLaunchSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetRequestLaunchSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetRequestLaunchSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ami: _builtins.str,
                 instance_type: _builtins.str,
                 associate_public_ip_address: Optional[_builtins.bool] = None,
                 availability_zone: Optional[_builtins.str] = None,
                 ebs_block_devices: Optional[Sequence['outputs.SpotFleetRequestLaunchSpecificationEbsBlockDevice']] = None,
                 ebs_optimized: Optional[_builtins.bool] = None,
                 ephemeral_block_devices: Optional[Sequence['outputs.SpotFleetRequestLaunchSpecificationEphemeralBlockDevice']] = None,
                 iam_instance_profile: Optional[_builtins.str] = None,
                 iam_instance_profile_arn: Optional[_builtins.str] = None,
                 key_name: Optional[_builtins.str] = None,
                 monitoring: Optional[_builtins.bool] = None,
                 placement_group: Optional[_builtins.str] = None,
                 placement_tenancy: Optional[_builtins.str] = None,
                 root_block_devices: Optional[Sequence['outputs.SpotFleetRequestLaunchSpecificationRootBlockDevice']] = None,
                 spot_price: Optional[_builtins.str] = None,
                 subnet_id: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 user_data: Optional[_builtins.str] = None,
                 vpc_security_group_ids: Optional[Sequence[_builtins.str]] = None,
                 weighted_capacity: Optional[_builtins.str] = None):
        pulumi.set(__self__, "ami", ami)
        pulumi.set(__self__, "instance_type", instance_type)
        if associate_public_ip_address is not None:
            pulumi.set(__self__, "associate_public_ip_address", associate_public_ip_address)
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if ebs_block_devices is not None:
            pulumi.set(__self__, "ebs_block_devices", ebs_block_devices)
        if ebs_optimized is not None:
            pulumi.set(__self__, "ebs_optimized", ebs_optimized)
        if ephemeral_block_devices is not None:
            pulumi.set(__self__, "ephemeral_block_devices", ephemeral_block_devices)
        if iam_instance_profile is not None:
            pulumi.set(__self__, "iam_instance_profile", iam_instance_profile)
        if iam_instance_profile_arn is not None:
            pulumi.set(__self__, "iam_instance_profile_arn", iam_instance_profile_arn)
        if key_name is not None:
            pulumi.set(__self__, "key_name", key_name)
        if monitoring is not None:
            pulumi.set(__self__, "monitoring", monitoring)
        if placement_group is not None:
            pulumi.set(__self__, "placement_group", placement_group)
        if placement_tenancy is not None:
            pulumi.set(__self__, "placement_tenancy", placement_tenancy)
        if root_block_devices is not None:
            pulumi.set(__self__, "root_block_devices", root_block_devices)
        if spot_price is not None:
            pulumi.set(__self__, "spot_price", spot_price)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if user_data is not None:
            pulumi.set(__self__, "user_data", user_data)
        if vpc_security_group_ids is not None:
            pulumi.set(__self__, "vpc_security_group_ids", vpc_security_group_ids)
        if weighted_capacity is not None:
            pulumi.set(__self__, "weighted_capacity", weighted_capacity)

    @_builtins.property
    @pulumi.getter
    def ami(self) -> _builtins.str:
        return pulumi.get(self, "ami")

    @_builtins.property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> _builtins.str:
        return pulumi.get(self, "instance_type")

    @_builtins.property
    @pulumi.getter(name="associatePublicIpAddress")
    def associate_public_ip_address(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "associate_public_ip_address")

    @_builtins.property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "availability_zone")

    @_builtins.property
    @pulumi.getter(name="ebsBlockDevices")
    def ebs_block_devices(self) -> Optional[Sequence['outputs.SpotFleetRequestLaunchSpecificationEbsBlockDevice']]:
        return pulumi.get(self, "ebs_block_devices")

    @_builtins.property
    @pulumi.getter(name="ebsOptimized")
    def ebs_optimized(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "ebs_optimized")

    @_builtins.property
    @pulumi.getter(name="ephemeralBlockDevices")
    def ephemeral_block_devices(self) -> Optional[Sequence['outputs.SpotFleetRequestLaunchSpecificationEphemeralBlockDevice']]:
        return pulumi.get(self, "ephemeral_block_devices")

    @_builtins.property
    @pulumi.getter(name="iamInstanceProfile")
    def iam_instance_profile(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "iam_instance_profile")

    @_builtins.property
    @pulumi.getter(name="iamInstanceProfileArn")
    def iam_instance_profile_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "iam_instance_profile_arn")

    @_builtins.property
    @pulumi.getter(name="keyName")
    def key_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "key_name")

    @_builtins.property
    @pulumi.getter
    def monitoring(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "monitoring")

    @_builtins.property
    @pulumi.getter(name="placementGroup")
    def placement_group(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "placement_group")

    @_builtins.property
    @pulumi.getter(name="placementTenancy")
    def placement_tenancy(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "placement_tenancy")

    @_builtins.property
    @pulumi.getter(name="rootBlockDevices")
    def root_block_devices(self) -> Optional[Sequence['outputs.SpotFleetRequestLaunchSpecificationRootBlockDevice']]:
        return pulumi.get(self, "root_block_devices")

    @_builtins.property
    @pulumi.getter(name="spotPrice")
    def spot_price(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "spot_price")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="userData")
    def user_data(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "user_data")

    @_builtins.property
    @pulumi.getter(name="vpcSecurityGroupIds")
    def vpc_security_group_ids(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "vpc_security_group_ids")

    @_builtins.property
    @pulumi.getter(name="weightedCapacity")
    def weighted_capacity(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "weighted_capacity")


@pulumi.output_type
class SpotFleetRequestLaunchSpecificationEbsBlockDevice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "snapshotId":
            suggest = "snapshot_id"
        elif key == "volumeSize":
            suggest = "volume_size"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetRequestLaunchSpecificationEbsBlockDevice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetRequestLaunchSpecificationEbsBlockDevice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetRequestLaunchSpecificationEbsBlockDevice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_name: _builtins.str,
                 delete_on_termination: Optional[_builtins.bool] = None,
                 encrypted: Optional[_builtins.bool] = None,
                 iops: Optional[_builtins.int] = None,
                 kms_key_id: Optional[_builtins.str] = None,
                 snapshot_id: Optional[_builtins.str] = None,
                 throughput: Optional[_builtins.int] = None,
                 volume_size: Optional[_builtins.int] = None,
                 volume_type: Optional[_builtins.str] = None):
        pulumi.set(__self__, "device_name", device_name)
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> _builtins.str:
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "delete_on_termination")

    @_builtins.property
    @pulumi.getter
    def encrypted(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "encrypted")

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "iops")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "snapshot_id")

    @_builtins.property
    @pulumi.getter
    def throughput(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "throughput")

    @_builtins.property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "volume_size")

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class SpotFleetRequestLaunchSpecificationEphemeralBlockDevice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "virtualName":
            suggest = "virtual_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetRequestLaunchSpecificationEphemeralBlockDevice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetRequestLaunchSpecificationEphemeralBlockDevice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetRequestLaunchSpecificationEphemeralBlockDevice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_name: _builtins.str,
                 virtual_name: _builtins.str):
        pulumi.set(__self__, "device_name", device_name)
        pulumi.set(__self__, "virtual_name", virtual_name)

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> _builtins.str:
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> _builtins.str:
        return pulumi.get(self, "virtual_name")


@pulumi.output_type
class SpotFleetRequestLaunchSpecificationRootBlockDevice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "volumeSize":
            suggest = "volume_size"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetRequestLaunchSpecificationRootBlockDevice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetRequestLaunchSpecificationRootBlockDevice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetRequestLaunchSpecificationRootBlockDevice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delete_on_termination: Optional[_builtins.bool] = None,
                 encrypted: Optional[_builtins.bool] = None,
                 iops: Optional[_builtins.int] = None,
                 kms_key_id: Optional[_builtins.str] = None,
                 throughput: Optional[_builtins.int] = None,
                 volume_size: Optional[_builtins.int] = None,
                 volume_type: Optional[_builtins.str] = None):
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "delete_on_termination")

    @_builtins.property
    @pulumi.getter
    def encrypted(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "encrypted")

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "iops")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter
    def throughput(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "throughput")

    @_builtins.property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "volume_size")

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class SpotFleetRequestLaunchTemplateConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "launchTemplateSpecification":
            suggest = "launch_template_specification"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetRequestLaunchTemplateConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetRequestLaunchTemplateConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetRequestLaunchTemplateConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 launch_template_specification: 'outputs.SpotFleetRequestLaunchTemplateConfigLaunchTemplateSpecification',
                 overrides: Optional[Sequence['outputs.SpotFleetRequestLaunchTemplateConfigOverride']] = None):
        pulumi.set(__self__, "launch_template_specification", launch_template_specification)
        if overrides is not None:
            pulumi.set(__self__, "overrides", overrides)

    @_builtins.property
    @pulumi.getter(name="launchTemplateSpecification")
    def launch_template_specification(self) -> 'outputs.SpotFleetRequestLaunchTemplateConfigLaunchTemplateSpecification':
        return pulumi.get(self, "launch_template_specification")

    @_builtins.property
    @pulumi.getter
    def overrides(self) -> Optional[Sequence['outputs.SpotFleetRequestLaunchTemplateConfigOverride']]:
        return pulumi.get(self, "overrides")


@pulumi.output_type
class SpotFleetRequestLaunchTemplateConfigLaunchTemplateSpecification(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 version: Optional[_builtins.str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "version")


@pulumi.output_type
class SpotFleetRequestLaunchTemplateConfigOverride(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "instanceRequirements":
            suggest = "instance_requirements"
        elif key == "instanceType":
            suggest = "instance_type"
        elif key == "spotPrice":
            suggest = "spot_price"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "weightedCapacity":
            suggest = "weighted_capacity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetRequestLaunchTemplateConfigOverride. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetRequestLaunchTemplateConfigOverride.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetRequestLaunchTemplateConfigOverride.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_zone: Optional[_builtins.str] = None,
                 instance_requirements: Optional['outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirements'] = None,
                 instance_type: Optional[_builtins.str] = None,
                 priority: Optional[_builtins.float] = None,
                 spot_price: Optional[_builtins.str] = None,
                 subnet_id: Optional[_builtins.str] = None,
                 weighted_capacity: Optional[_builtins.float] = None):
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if instance_requirements is not None:
            pulumi.set(__self__, "instance_requirements", instance_requirements)
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if spot_price is not None:
            pulumi.set(__self__, "spot_price", spot_price)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if weighted_capacity is not None:
            pulumi.set(__self__, "weighted_capacity", weighted_capacity)

    @_builtins.property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "availability_zone")

    @_builtins.property
    @pulumi.getter(name="instanceRequirements")
    def instance_requirements(self) -> Optional['outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirements']:
        return pulumi.get(self, "instance_requirements")

    @_builtins.property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "instance_type")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter(name="spotPrice")
    def spot_price(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "spot_price")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter(name="weightedCapacity")
    def weighted_capacity(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "weighted_capacity")


@pulumi.output_type
class SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirements(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acceleratorCount":
            suggest = "accelerator_count"
        elif key == "acceleratorManufacturers":
            suggest = "accelerator_manufacturers"
        elif key == "acceleratorNames":
            suggest = "accelerator_names"
        elif key == "acceleratorTotalMemoryMib":
            suggest = "accelerator_total_memory_mib"
        elif key == "acceleratorTypes":
            suggest = "accelerator_types"
        elif key == "allowedInstanceTypes":
            suggest = "allowed_instance_types"
        elif key == "bareMetal":
            suggest = "bare_metal"
        elif key == "baselineEbsBandwidthMbps":
            suggest = "baseline_ebs_bandwidth_mbps"
        elif key == "burstablePerformance":
            suggest = "burstable_performance"
        elif key == "cpuManufacturers":
            suggest = "cpu_manufacturers"
        elif key == "excludedInstanceTypes":
            suggest = "excluded_instance_types"
        elif key == "instanceGenerations":
            suggest = "instance_generations"
        elif key == "localStorage":
            suggest = "local_storage"
        elif key == "localStorageTypes":
            suggest = "local_storage_types"
        elif key == "memoryGibPerVcpu":
            suggest = "memory_gib_per_vcpu"
        elif key == "memoryMib":
            suggest = "memory_mib"
        elif key == "networkBandwidthGbps":
            suggest = "network_bandwidth_gbps"
        elif key == "networkInterfaceCount":
            suggest = "network_interface_count"
        elif key == "onDemandMaxPricePercentageOverLowestPrice":
            suggest = "on_demand_max_price_percentage_over_lowest_price"
        elif key == "requireHibernateSupport":
            suggest = "require_hibernate_support"
        elif key == "spotMaxPricePercentageOverLowestPrice":
            suggest = "spot_max_price_percentage_over_lowest_price"
        elif key == "totalLocalStorageGb":
            suggest = "total_local_storage_gb"
        elif key == "vcpuCount":
            suggest = "vcpu_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirements. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirements.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirements.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 accelerator_count: Optional['outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorCount'] = None,
                 accelerator_manufacturers: Optional[Sequence[_builtins.str]] = None,
                 accelerator_names: Optional[Sequence[_builtins.str]] = None,
                 accelerator_total_memory_mib: Optional['outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorTotalMemoryMib'] = None,
                 accelerator_types: Optional[Sequence[_builtins.str]] = None,
                 allowed_instance_types: Optional[Sequence[_builtins.str]] = None,
                 bare_metal: Optional[_builtins.str] = None,
                 baseline_ebs_bandwidth_mbps: Optional['outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsBaselineEbsBandwidthMbps'] = None,
                 burstable_performance: Optional[_builtins.str] = None,
                 cpu_manufacturers: Optional[Sequence[_builtins.str]] = None,
                 excluded_instance_types: Optional[Sequence[_builtins.str]] = None,
                 instance_generations: Optional[Sequence[_builtins.str]] = None,
                 local_storage: Optional[_builtins.str] = None,
                 local_storage_types: Optional[Sequence[_builtins.str]] = None,
                 memory_gib_per_vcpu: Optional['outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsMemoryGibPerVcpu'] = None,
                 memory_mib: Optional['outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsMemoryMib'] = None,
                 network_bandwidth_gbps: Optional['outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsNetworkBandwidthGbps'] = None,
                 network_interface_count: Optional['outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsNetworkInterfaceCount'] = None,
                 on_demand_max_price_percentage_over_lowest_price: Optional[_builtins.int] = None,
                 require_hibernate_support: Optional[_builtins.bool] = None,
                 spot_max_price_percentage_over_lowest_price: Optional[_builtins.int] = None,
                 total_local_storage_gb: Optional['outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsTotalLocalStorageGb'] = None,
                 vcpu_count: Optional['outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsVcpuCount'] = None):
        if accelerator_count is not None:
            pulumi.set(__self__, "accelerator_count", accelerator_count)
        if accelerator_manufacturers is not None:
            pulumi.set(__self__, "accelerator_manufacturers", accelerator_manufacturers)
        if accelerator_names is not None:
            pulumi.set(__self__, "accelerator_names", accelerator_names)
        if accelerator_total_memory_mib is not None:
            pulumi.set(__self__, "accelerator_total_memory_mib", accelerator_total_memory_mib)
        if accelerator_types is not None:
            pulumi.set(__self__, "accelerator_types", accelerator_types)
        if allowed_instance_types is not None:
            pulumi.set(__self__, "allowed_instance_types", allowed_instance_types)
        if bare_metal is not None:
            pulumi.set(__self__, "bare_metal", bare_metal)
        if baseline_ebs_bandwidth_mbps is not None:
            pulumi.set(__self__, "baseline_ebs_bandwidth_mbps", baseline_ebs_bandwidth_mbps)
        if burstable_performance is not None:
            pulumi.set(__self__, "burstable_performance", burstable_performance)
        if cpu_manufacturers is not None:
            pulumi.set(__self__, "cpu_manufacturers", cpu_manufacturers)
        if excluded_instance_types is not None:
            pulumi.set(__self__, "excluded_instance_types", excluded_instance_types)
        if instance_generations is not None:
            pulumi.set(__self__, "instance_generations", instance_generations)
        if local_storage is not None:
            pulumi.set(__self__, "local_storage", local_storage)
        if local_storage_types is not None:
            pulumi.set(__self__, "local_storage_types", local_storage_types)
        if memory_gib_per_vcpu is not None:
            pulumi.set(__self__, "memory_gib_per_vcpu", memory_gib_per_vcpu)
        if memory_mib is not None:
            pulumi.set(__self__, "memory_mib", memory_mib)
        if network_bandwidth_gbps is not None:
            pulumi.set(__self__, "network_bandwidth_gbps", network_bandwidth_gbps)
        if network_interface_count is not None:
            pulumi.set(__self__, "network_interface_count", network_interface_count)
        if on_demand_max_price_percentage_over_lowest_price is not None:
            pulumi.set(__self__, "on_demand_max_price_percentage_over_lowest_price", on_demand_max_price_percentage_over_lowest_price)
        if require_hibernate_support is not None:
            pulumi.set(__self__, "require_hibernate_support", require_hibernate_support)
        if spot_max_price_percentage_over_lowest_price is not None:
            pulumi.set(__self__, "spot_max_price_percentage_over_lowest_price", spot_max_price_percentage_over_lowest_price)
        if total_local_storage_gb is not None:
            pulumi.set(__self__, "total_local_storage_gb", total_local_storage_gb)
        if vcpu_count is not None:
            pulumi.set(__self__, "vcpu_count", vcpu_count)

    @_builtins.property
    @pulumi.getter(name="acceleratorCount")
    def accelerator_count(self) -> Optional['outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorCount']:
        return pulumi.get(self, "accelerator_count")

    @_builtins.property
    @pulumi.getter(name="acceleratorManufacturers")
    def accelerator_manufacturers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "accelerator_manufacturers")

    @_builtins.property
    @pulumi.getter(name="acceleratorNames")
    def accelerator_names(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "accelerator_names")

    @_builtins.property
    @pulumi.getter(name="acceleratorTotalMemoryMib")
    def accelerator_total_memory_mib(self) -> Optional['outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorTotalMemoryMib']:
        return pulumi.get(self, "accelerator_total_memory_mib")

    @_builtins.property
    @pulumi.getter(name="acceleratorTypes")
    def accelerator_types(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "accelerator_types")

    @_builtins.property
    @pulumi.getter(name="allowedInstanceTypes")
    def allowed_instance_types(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "allowed_instance_types")

    @_builtins.property
    @pulumi.getter(name="bareMetal")
    def bare_metal(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "bare_metal")

    @_builtins.property
    @pulumi.getter(name="baselineEbsBandwidthMbps")
    def baseline_ebs_bandwidth_mbps(self) -> Optional['outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsBaselineEbsBandwidthMbps']:
        return pulumi.get(self, "baseline_ebs_bandwidth_mbps")

    @_builtins.property
    @pulumi.getter(name="burstablePerformance")
    def burstable_performance(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "burstable_performance")

    @_builtins.property
    @pulumi.getter(name="cpuManufacturers")
    def cpu_manufacturers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "cpu_manufacturers")

    @_builtins.property
    @pulumi.getter(name="excludedInstanceTypes")
    def excluded_instance_types(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excluded_instance_types")

    @_builtins.property
    @pulumi.getter(name="instanceGenerations")
    def instance_generations(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "instance_generations")

    @_builtins.property
    @pulumi.getter(name="localStorage")
    def local_storage(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "local_storage")

    @_builtins.property
    @pulumi.getter(name="localStorageTypes")
    def local_storage_types(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "local_storage_types")

    @_builtins.property
    @pulumi.getter(name="memoryGibPerVcpu")
    def memory_gib_per_vcpu(self) -> Optional['outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsMemoryGibPerVcpu']:
        return pulumi.get(self, "memory_gib_per_vcpu")

    @_builtins.property
    @pulumi.getter(name="memoryMib")
    def memory_mib(self) -> Optional['outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsMemoryMib']:
        return pulumi.get(self, "memory_mib")

    @_builtins.property
    @pulumi.getter(name="networkBandwidthGbps")
    def network_bandwidth_gbps(self) -> Optional['outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsNetworkBandwidthGbps']:
        return pulumi.get(self, "network_bandwidth_gbps")

    @_builtins.property
    @pulumi.getter(name="networkInterfaceCount")
    def network_interface_count(self) -> Optional['outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsNetworkInterfaceCount']:
        return pulumi.get(self, "network_interface_count")

    @_builtins.property
    @pulumi.getter(name="onDemandMaxPricePercentageOverLowestPrice")
    def on_demand_max_price_percentage_over_lowest_price(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "on_demand_max_price_percentage_over_lowest_price")

    @_builtins.property
    @pulumi.getter(name="requireHibernateSupport")
    def require_hibernate_support(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "require_hibernate_support")

    @_builtins.property
    @pulumi.getter(name="spotMaxPricePercentageOverLowestPrice")
    def spot_max_price_percentage_over_lowest_price(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "spot_max_price_percentage_over_lowest_price")

    @_builtins.property
    @pulumi.getter(name="totalLocalStorageGb")
    def total_local_storage_gb(self) -> Optional['outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsTotalLocalStorageGb']:
        return pulumi.get(self, "total_local_storage_gb")

    @_builtins.property
    @pulumi.getter(name="vcpuCount")
    def vcpu_count(self) -> Optional['outputs.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsVcpuCount']:
        return pulumi.get(self, "vcpu_count")


@pulumi.output_type
class SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorCount(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.int] = None,
                 min: Optional[_builtins.int] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "min")


@pulumi.output_type
class SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorTotalMemoryMib(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.int] = None,
                 min: Optional[_builtins.int] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "min")


@pulumi.output_type
class SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsBaselineEbsBandwidthMbps(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.int] = None,
                 min: Optional[_builtins.int] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "min")


@pulumi.output_type
class SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsMemoryGibPerVcpu(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.float] = None,
                 min: Optional[_builtins.float] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "min")


@pulumi.output_type
class SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsMemoryMib(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.int] = None,
                 min: Optional[_builtins.int] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "min")


@pulumi.output_type
class SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsNetworkBandwidthGbps(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.float] = None,
                 min: Optional[_builtins.float] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "min")


@pulumi.output_type
class SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsNetworkInterfaceCount(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.int] = None,
                 min: Optional[_builtins.int] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "min")


@pulumi.output_type
class SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsTotalLocalStorageGb(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.float] = None,
                 min: Optional[_builtins.float] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "min")


@pulumi.output_type
class SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsVcpuCount(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.int] = None,
                 min: Optional[_builtins.int] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "min")


@pulumi.output_type
class SpotFleetRequestSpotMaintenanceStrategies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capacityRebalance":
            suggest = "capacity_rebalance"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetRequestSpotMaintenanceStrategies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetRequestSpotMaintenanceStrategies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetRequestSpotMaintenanceStrategies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capacity_rebalance: Optional['outputs.SpotFleetRequestSpotMaintenanceStrategiesCapacityRebalance'] = None):
        if capacity_rebalance is not None:
            pulumi.set(__self__, "capacity_rebalance", capacity_rebalance)

    @_builtins.property
    @pulumi.getter(name="capacityRebalance")
    def capacity_rebalance(self) -> Optional['outputs.SpotFleetRequestSpotMaintenanceStrategiesCapacityRebalance']:
        return pulumi.get(self, "capacity_rebalance")


@pulumi.output_type
class SpotFleetRequestSpotMaintenanceStrategiesCapacityRebalance(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "replacementStrategy":
            suggest = "replacement_strategy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetRequestSpotMaintenanceStrategiesCapacityRebalance. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetRequestSpotMaintenanceStrategiesCapacityRebalance.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetRequestSpotMaintenanceStrategiesCapacityRebalance.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 replacement_strategy: Optional[_builtins.str] = None):
        if replacement_strategy is not None:
            pulumi.set(__self__, "replacement_strategy", replacement_strategy)

    @_builtins.property
    @pulumi.getter(name="replacementStrategy")
    def replacement_strategy(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "replacement_strategy")


@pulumi.output_type
class SpotInstanceRequestCapacityReservationSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capacityReservationPreference":
            suggest = "capacity_reservation_preference"
        elif key == "capacityReservationTarget":
            suggest = "capacity_reservation_target"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotInstanceRequestCapacityReservationSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotInstanceRequestCapacityReservationSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotInstanceRequestCapacityReservationSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capacity_reservation_preference: Optional[_builtins.str] = None,
                 capacity_reservation_target: Optional['outputs.SpotInstanceRequestCapacityReservationSpecificationCapacityReservationTarget'] = None):
        if capacity_reservation_preference is not None:
            pulumi.set(__self__, "capacity_reservation_preference", capacity_reservation_preference)
        if capacity_reservation_target is not None:
            pulumi.set(__self__, "capacity_reservation_target", capacity_reservation_target)

    @_builtins.property
    @pulumi.getter(name="capacityReservationPreference")
    def capacity_reservation_preference(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "capacity_reservation_preference")

    @_builtins.property
    @pulumi.getter(name="capacityReservationTarget")
    def capacity_reservation_target(self) -> Optional['outputs.SpotInstanceRequestCapacityReservationSpecificationCapacityReservationTarget']:
        return pulumi.get(self, "capacity_reservation_target")


@pulumi.output_type
class SpotInstanceRequestCapacityReservationSpecificationCapacityReservationTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capacityReservationId":
            suggest = "capacity_reservation_id"
        elif key == "capacityReservationResourceGroupArn":
            suggest = "capacity_reservation_resource_group_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotInstanceRequestCapacityReservationSpecificationCapacityReservationTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotInstanceRequestCapacityReservationSpecificationCapacityReservationTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotInstanceRequestCapacityReservationSpecificationCapacityReservationTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capacity_reservation_id: Optional[_builtins.str] = None,
                 capacity_reservation_resource_group_arn: Optional[_builtins.str] = None):
        if capacity_reservation_id is not None:
            pulumi.set(__self__, "capacity_reservation_id", capacity_reservation_id)
        if capacity_reservation_resource_group_arn is not None:
            pulumi.set(__self__, "capacity_reservation_resource_group_arn", capacity_reservation_resource_group_arn)

    @_builtins.property
    @pulumi.getter(name="capacityReservationId")
    def capacity_reservation_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "capacity_reservation_id")

    @_builtins.property
    @pulumi.getter(name="capacityReservationResourceGroupArn")
    def capacity_reservation_resource_group_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "capacity_reservation_resource_group_arn")


@pulumi.output_type
class SpotInstanceRequestCpuOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "amdSevSnp":
            suggest = "amd_sev_snp"
        elif key == "coreCount":
            suggest = "core_count"
        elif key == "threadsPerCore":
            suggest = "threads_per_core"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotInstanceRequestCpuOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotInstanceRequestCpuOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotInstanceRequestCpuOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 amd_sev_snp: Optional[_builtins.str] = None,
                 core_count: Optional[_builtins.int] = None,
                 threads_per_core: Optional[_builtins.int] = None):
        if amd_sev_snp is not None:
            pulumi.set(__self__, "amd_sev_snp", amd_sev_snp)
        if core_count is not None:
            pulumi.set(__self__, "core_count", core_count)
        if threads_per_core is not None:
            pulumi.set(__self__, "threads_per_core", threads_per_core)

    @_builtins.property
    @pulumi.getter(name="amdSevSnp")
    def amd_sev_snp(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "amd_sev_snp")

    @_builtins.property
    @pulumi.getter(name="coreCount")
    def core_count(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "core_count")

    @_builtins.property
    @pulumi.getter(name="threadsPerCore")
    def threads_per_core(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "threads_per_core")


@pulumi.output_type
class SpotInstanceRequestCreditSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cpuCredits":
            suggest = "cpu_credits"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotInstanceRequestCreditSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotInstanceRequestCreditSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotInstanceRequestCreditSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu_credits: Optional[_builtins.str] = None):
        if cpu_credits is not None:
            pulumi.set(__self__, "cpu_credits", cpu_credits)

    @_builtins.property
    @pulumi.getter(name="cpuCredits")
    def cpu_credits(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cpu_credits")


@pulumi.output_type
class SpotInstanceRequestEbsBlockDevice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "snapshotId":
            suggest = "snapshot_id"
        elif key == "tagsAll":
            suggest = "tags_all"
        elif key == "volumeId":
            suggest = "volume_id"
        elif key == "volumeSize":
            suggest = "volume_size"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotInstanceRequestEbsBlockDevice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotInstanceRequestEbsBlockDevice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotInstanceRequestEbsBlockDevice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_name: _builtins.str,
                 delete_on_termination: Optional[_builtins.bool] = None,
                 encrypted: Optional[_builtins.bool] = None,
                 iops: Optional[_builtins.int] = None,
                 kms_key_id: Optional[_builtins.str] = None,
                 snapshot_id: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 tags_all: Optional[Mapping[str, _builtins.str]] = None,
                 throughput: Optional[_builtins.int] = None,
                 volume_id: Optional[_builtins.str] = None,
                 volume_size: Optional[_builtins.int] = None,
                 volume_type: Optional[_builtins.str] = None):
        pulumi.set(__self__, "device_name", device_name)
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tags_all is not None:
            pulumi.set(__self__, "tags_all", tags_all)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)
        if volume_id is not None:
            pulumi.set(__self__, "volume_id", volume_id)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> _builtins.str:
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "delete_on_termination")

    @_builtins.property
    @pulumi.getter
    def encrypted(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "encrypted")

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "iops")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "snapshot_id")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="tagsAll")
    def tags_all(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "tags_all")

    @_builtins.property
    @pulumi.getter
    def throughput(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "throughput")

    @_builtins.property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "volume_id")

    @_builtins.property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "volume_size")

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class SpotInstanceRequestEnclaveOptions(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class SpotInstanceRequestEphemeralBlockDevice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "noDevice":
            suggest = "no_device"
        elif key == "virtualName":
            suggest = "virtual_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotInstanceRequestEphemeralBlockDevice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotInstanceRequestEphemeralBlockDevice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotInstanceRequestEphemeralBlockDevice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_name: _builtins.str,
                 no_device: Optional[_builtins.bool] = None,
                 virtual_name: Optional[_builtins.str] = None):
        pulumi.set(__self__, "device_name", device_name)
        if no_device is not None:
            pulumi.set(__self__, "no_device", no_device)
        if virtual_name is not None:
            pulumi.set(__self__, "virtual_name", virtual_name)

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> _builtins.str:
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter(name="noDevice")
    def no_device(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "no_device")

    @_builtins.property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "virtual_name")


@pulumi.output_type
class SpotInstanceRequestLaunchTemplate(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 version: Optional[_builtins.str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "version")


@pulumi.output_type
class SpotInstanceRequestMaintenanceOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoRecovery":
            suggest = "auto_recovery"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotInstanceRequestMaintenanceOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotInstanceRequestMaintenanceOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotInstanceRequestMaintenanceOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_recovery: Optional[_builtins.str] = None):
        if auto_recovery is not None:
            pulumi.set(__self__, "auto_recovery", auto_recovery)

    @_builtins.property
    @pulumi.getter(name="autoRecovery")
    def auto_recovery(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "auto_recovery")


@pulumi.output_type
class SpotInstanceRequestMetadataOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpEndpoint":
            suggest = "http_endpoint"
        elif key == "httpProtocolIpv6":
            suggest = "http_protocol_ipv6"
        elif key == "httpPutResponseHopLimit":
            suggest = "http_put_response_hop_limit"
        elif key == "httpTokens":
            suggest = "http_tokens"
        elif key == "instanceMetadataTags":
            suggest = "instance_metadata_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotInstanceRequestMetadataOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotInstanceRequestMetadataOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotInstanceRequestMetadataOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_endpoint: Optional[_builtins.str] = None,
                 http_protocol_ipv6: Optional[_builtins.str] = None,
                 http_put_response_hop_limit: Optional[_builtins.int] = None,
                 http_tokens: Optional[_builtins.str] = None,
                 instance_metadata_tags: Optional[_builtins.str] = None):
        if http_endpoint is not None:
            pulumi.set(__self__, "http_endpoint", http_endpoint)
        if http_protocol_ipv6 is not None:
            pulumi.set(__self__, "http_protocol_ipv6", http_protocol_ipv6)
        if http_put_response_hop_limit is not None:
            pulumi.set(__self__, "http_put_response_hop_limit", http_put_response_hop_limit)
        if http_tokens is not None:
            pulumi.set(__self__, "http_tokens", http_tokens)
        if instance_metadata_tags is not None:
            pulumi.set(__self__, "instance_metadata_tags", instance_metadata_tags)

    @_builtins.property
    @pulumi.getter(name="httpEndpoint")
    def http_endpoint(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "http_endpoint")

    @_builtins.property
    @pulumi.getter(name="httpProtocolIpv6")
    def http_protocol_ipv6(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "http_protocol_ipv6")

    @_builtins.property
    @pulumi.getter(name="httpPutResponseHopLimit")
    def http_put_response_hop_limit(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "http_put_response_hop_limit")

    @_builtins.property
    @pulumi.getter(name="httpTokens")
    def http_tokens(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "http_tokens")

    @_builtins.property
    @pulumi.getter(name="instanceMetadataTags")
    def instance_metadata_tags(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "instance_metadata_tags")


@pulumi.output_type
class SpotInstanceRequestNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceIndex":
            suggest = "device_index"
        elif key == "networkInterfaceId":
            suggest = "network_interface_id"
        elif key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "networkCardIndex":
            suggest = "network_card_index"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotInstanceRequestNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotInstanceRequestNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotInstanceRequestNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_index: _builtins.int,
                 network_interface_id: _builtins.str,
                 delete_on_termination: Optional[_builtins.bool] = None,
                 network_card_index: Optional[_builtins.int] = None):
        pulumi.set(__self__, "device_index", device_index)
        pulumi.set(__self__, "network_interface_id", network_interface_id)
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if network_card_index is not None:
            pulumi.set(__self__, "network_card_index", network_card_index)

    @_builtins.property
    @pulumi.getter(name="deviceIndex")
    def device_index(self) -> _builtins.int:
        return pulumi.get(self, "device_index")

    @_builtins.property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> _builtins.str:
        return pulumi.get(self, "network_interface_id")

    @_builtins.property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "delete_on_termination")

    @_builtins.property
    @pulumi.getter(name="networkCardIndex")
    def network_card_index(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "network_card_index")


@pulumi.output_type
class SpotInstanceRequestPrimaryNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "networkInterfaceId":
            suggest = "network_interface_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotInstanceRequestPrimaryNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotInstanceRequestPrimaryNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotInstanceRequestPrimaryNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delete_on_termination: Optional[_builtins.bool] = None,
                 network_interface_id: Optional[_builtins.str] = None):
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if network_interface_id is not None:
            pulumi.set(__self__, "network_interface_id", network_interface_id)

    @_builtins.property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "delete_on_termination")

    @_builtins.property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "network_interface_id")


@pulumi.output_type
class SpotInstanceRequestPrivateDnsNameOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableResourceNameDnsARecord":
            suggest = "enable_resource_name_dns_a_record"
        elif key == "enableResourceNameDnsAaaaRecord":
            suggest = "enable_resource_name_dns_aaaa_record"
        elif key == "hostnameType":
            suggest = "hostname_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotInstanceRequestPrivateDnsNameOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotInstanceRequestPrivateDnsNameOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotInstanceRequestPrivateDnsNameOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_resource_name_dns_a_record: Optional[_builtins.bool] = None,
                 enable_resource_name_dns_aaaa_record: Optional[_builtins.bool] = None,
                 hostname_type: Optional[_builtins.str] = None):
        if enable_resource_name_dns_a_record is not None:
            pulumi.set(__self__, "enable_resource_name_dns_a_record", enable_resource_name_dns_a_record)
        if enable_resource_name_dns_aaaa_record is not None:
            pulumi.set(__self__, "enable_resource_name_dns_aaaa_record", enable_resource_name_dns_aaaa_record)
        if hostname_type is not None:
            pulumi.set(__self__, "hostname_type", hostname_type)

    @_builtins.property
    @pulumi.getter(name="enableResourceNameDnsARecord")
    def enable_resource_name_dns_a_record(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enable_resource_name_dns_a_record")

    @_builtins.property
    @pulumi.getter(name="enableResourceNameDnsAaaaRecord")
    def enable_resource_name_dns_aaaa_record(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enable_resource_name_dns_aaaa_record")

    @_builtins.property
    @pulumi.getter(name="hostnameType")
    def hostname_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "hostname_type")


@pulumi.output_type
class SpotInstanceRequestRootBlockDevice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "deviceName":
            suggest = "device_name"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "tagsAll":
            suggest = "tags_all"
        elif key == "volumeId":
            suggest = "volume_id"
        elif key == "volumeSize":
            suggest = "volume_size"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotInstanceRequestRootBlockDevice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotInstanceRequestRootBlockDevice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotInstanceRequestRootBlockDevice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delete_on_termination: Optional[_builtins.bool] = None,
                 device_name: Optional[_builtins.str] = None,
                 encrypted: Optional[_builtins.bool] = None,
                 iops: Optional[_builtins.int] = None,
                 kms_key_id: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 tags_all: Optional[Mapping[str, _builtins.str]] = None,
                 throughput: Optional[_builtins.int] = None,
                 volume_id: Optional[_builtins.str] = None,
                 volume_size: Optional[_builtins.int] = None,
                 volume_type: Optional[_builtins.str] = None):
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tags_all is not None:
            pulumi.set(__self__, "tags_all", tags_all)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)
        if volume_id is not None:
            pulumi.set(__self__, "volume_id", volume_id)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "delete_on_termination")

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter
    def encrypted(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "encrypted")

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "iops")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="tagsAll")
    def tags_all(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "tags_all")

    @_builtins.property
    @pulumi.getter
    def throughput(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "throughput")

    @_builtins.property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "volume_id")

    @_builtins.property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "volume_size")

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class TrafficMirrorFilterRuleDestinationPortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromPort":
            suggest = "from_port"
        elif key == "toPort":
            suggest = "to_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TrafficMirrorFilterRuleDestinationPortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TrafficMirrorFilterRuleDestinationPortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TrafficMirrorFilterRuleDestinationPortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_port: Optional[_builtins.int] = None,
                 to_port: Optional[_builtins.int] = None):
        if from_port is not None:
            pulumi.set(__self__, "from_port", from_port)
        if to_port is not None:
            pulumi.set(__self__, "to_port", to_port)

    @_builtins.property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "from_port")

    @_builtins.property
    @pulumi.getter(name="toPort")
    def to_port(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "to_port")


@pulumi.output_type
class TrafficMirrorFilterRuleSourcePortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromPort":
            suggest = "from_port"
        elif key == "toPort":
            suggest = "to_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TrafficMirrorFilterRuleSourcePortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TrafficMirrorFilterRuleSourcePortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TrafficMirrorFilterRuleSourcePortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_port: Optional[_builtins.int] = None,
                 to_port: Optional[_builtins.int] = None):
        if from_port is not None:
            pulumi.set(__self__, "from_port", from_port)
        if to_port is not None:
            pulumi.set(__self__, "to_port", to_port)

    @_builtins.property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "from_port")

    @_builtins.property
    @pulumi.getter(name="toPort")
    def to_port(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "to_port")


@pulumi.output_type
class VpcBlockPublicAccessExclusionTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[_builtins.str] = None,
                 delete: Optional[_builtins.str] = None,
                 update: Optional[_builtins.str] = None):
        """
        :param _builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param _builtins.str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param _builtins.str update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")


@pulumi.output_type
class VpcBlockPublicAccessOptionsTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[_builtins.str] = None,
                 delete: Optional[_builtins.str] = None,
                 update: Optional[_builtins.str] = None):
        """
        :param _builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param _builtins.str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param _builtins.str update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")


@pulumi.output_type
class VpcEncryptionControlResourceExclusions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "egressOnlyInternetGateway":
            suggest = "egress_only_internet_gateway"
        elif key == "elasticFileSystem":
            suggest = "elastic_file_system"
        elif key == "internetGateway":
            suggest = "internet_gateway"
        elif key == "lambda":
            suggest = "lambda_"
        elif key == "natGateway":
            suggest = "nat_gateway"
        elif key == "virtualPrivateGateway":
            suggest = "virtual_private_gateway"
        elif key == "vpcLattice":
            suggest = "vpc_lattice"
        elif key == "vpcPeering":
            suggest = "vpc_peering"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcEncryptionControlResourceExclusions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcEncryptionControlResourceExclusions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcEncryptionControlResourceExclusions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 egress_only_internet_gateway: 'outputs.VpcEncryptionControlResourceExclusionsEgressOnlyInternetGateway',
                 elastic_file_system: 'outputs.VpcEncryptionControlResourceExclusionsElasticFileSystem',
                 internet_gateway: 'outputs.VpcEncryptionControlResourceExclusionsInternetGateway',
                 lambda_: 'outputs.VpcEncryptionControlResourceExclusionsLambda',
                 nat_gateway: 'outputs.VpcEncryptionControlResourceExclusionsNatGateway',
                 virtual_private_gateway: 'outputs.VpcEncryptionControlResourceExclusionsVirtualPrivateGateway',
                 vpc_lattice: 'outputs.VpcEncryptionControlResourceExclusionsVpcLattice',
                 vpc_peering: 'outputs.VpcEncryptionControlResourceExclusionsVpcPeering'):
        pulumi.set(__self__, "egress_only_internet_gateway", egress_only_internet_gateway)
        pulumi.set(__self__, "elastic_file_system", elastic_file_system)
        pulumi.set(__self__, "internet_gateway", internet_gateway)
        pulumi.set(__self__, "lambda_", lambda_)
        pulumi.set(__self__, "nat_gateway", nat_gateway)
        pulumi.set(__self__, "virtual_private_gateway", virtual_private_gateway)
        pulumi.set(__self__, "vpc_lattice", vpc_lattice)
        pulumi.set(__self__, "vpc_peering", vpc_peering)

    @_builtins.property
    @pulumi.getter(name="egressOnlyInternetGateway")
    def egress_only_internet_gateway(self) -> 'outputs.VpcEncryptionControlResourceExclusionsEgressOnlyInternetGateway':
        return pulumi.get(self, "egress_only_internet_gateway")

    @_builtins.property
    @pulumi.getter(name="elasticFileSystem")
    def elastic_file_system(self) -> 'outputs.VpcEncryptionControlResourceExclusionsElasticFileSystem':
        return pulumi.get(self, "elastic_file_system")

    @_builtins.property
    @pulumi.getter(name="internetGateway")
    def internet_gateway(self) -> 'outputs.VpcEncryptionControlResourceExclusionsInternetGateway':
        return pulumi.get(self, "internet_gateway")

    @_builtins.property
    @pulumi.getter(name="lambda")
    def lambda_(self) -> 'outputs.VpcEncryptionControlResourceExclusionsLambda':
        return pulumi.get(self, "lambda_")

    @_builtins.property
    @pulumi.getter(name="natGateway")
    def nat_gateway(self) -> 'outputs.VpcEncryptionControlResourceExclusionsNatGateway':
        return pulumi.get(self, "nat_gateway")

    @_builtins.property
    @pulumi.getter(name="virtualPrivateGateway")
    def virtual_private_gateway(self) -> 'outputs.VpcEncryptionControlResourceExclusionsVirtualPrivateGateway':
        return pulumi.get(self, "virtual_private_gateway")

    @_builtins.property
    @pulumi.getter(name="vpcLattice")
    def vpc_lattice(self) -> 'outputs.VpcEncryptionControlResourceExclusionsVpcLattice':
        return pulumi.get(self, "vpc_lattice")

    @_builtins.property
    @pulumi.getter(name="vpcPeering")
    def vpc_peering(self) -> 'outputs.VpcEncryptionControlResourceExclusionsVpcPeering':
        return pulumi.get(self, "vpc_peering")


@pulumi.output_type
class VpcEncryptionControlResourceExclusionsEgressOnlyInternetGateway(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "stateMessage":
            suggest = "state_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcEncryptionControlResourceExclusionsEgressOnlyInternetGateway. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcEncryptionControlResourceExclusionsEgressOnlyInternetGateway.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcEncryptionControlResourceExclusionsEgressOnlyInternetGateway.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 state: _builtins.str,
                 state_message: _builtins.str):
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "state_message", state_message)

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="stateMessage")
    def state_message(self) -> _builtins.str:
        return pulumi.get(self, "state_message")


@pulumi.output_type
class VpcEncryptionControlResourceExclusionsElasticFileSystem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "stateMessage":
            suggest = "state_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcEncryptionControlResourceExclusionsElasticFileSystem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcEncryptionControlResourceExclusionsElasticFileSystem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcEncryptionControlResourceExclusionsElasticFileSystem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 state: _builtins.str,
                 state_message: _builtins.str):
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "state_message", state_message)

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="stateMessage")
    def state_message(self) -> _builtins.str:
        return pulumi.get(self, "state_message")


@pulumi.output_type
class VpcEncryptionControlResourceExclusionsInternetGateway(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "stateMessage":
            suggest = "state_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcEncryptionControlResourceExclusionsInternetGateway. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcEncryptionControlResourceExclusionsInternetGateway.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcEncryptionControlResourceExclusionsInternetGateway.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 state: _builtins.str,
                 state_message: _builtins.str):
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "state_message", state_message)

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="stateMessage")
    def state_message(self) -> _builtins.str:
        return pulumi.get(self, "state_message")


@pulumi.output_type
class VpcEncryptionControlResourceExclusionsLambda(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "stateMessage":
            suggest = "state_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcEncryptionControlResourceExclusionsLambda. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcEncryptionControlResourceExclusionsLambda.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcEncryptionControlResourceExclusionsLambda.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 state: _builtins.str,
                 state_message: _builtins.str):
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "state_message", state_message)

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="stateMessage")
    def state_message(self) -> _builtins.str:
        return pulumi.get(self, "state_message")


@pulumi.output_type
class VpcEncryptionControlResourceExclusionsNatGateway(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "stateMessage":
            suggest = "state_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcEncryptionControlResourceExclusionsNatGateway. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcEncryptionControlResourceExclusionsNatGateway.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcEncryptionControlResourceExclusionsNatGateway.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 state: _builtins.str,
                 state_message: _builtins.str):
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "state_message", state_message)

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="stateMessage")
    def state_message(self) -> _builtins.str:
        return pulumi.get(self, "state_message")


@pulumi.output_type
class VpcEncryptionControlResourceExclusionsVirtualPrivateGateway(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "stateMessage":
            suggest = "state_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcEncryptionControlResourceExclusionsVirtualPrivateGateway. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcEncryptionControlResourceExclusionsVirtualPrivateGateway.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcEncryptionControlResourceExclusionsVirtualPrivateGateway.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 state: _builtins.str,
                 state_message: _builtins.str):
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "state_message", state_message)

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="stateMessage")
    def state_message(self) -> _builtins.str:
        return pulumi.get(self, "state_message")


@pulumi.output_type
class VpcEncryptionControlResourceExclusionsVpcLattice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "stateMessage":
            suggest = "state_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcEncryptionControlResourceExclusionsVpcLattice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcEncryptionControlResourceExclusionsVpcLattice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcEncryptionControlResourceExclusionsVpcLattice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 state: _builtins.str,
                 state_message: _builtins.str):
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "state_message", state_message)

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="stateMessage")
    def state_message(self) -> _builtins.str:
        return pulumi.get(self, "state_message")


@pulumi.output_type
class VpcEncryptionControlResourceExclusionsVpcPeering(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "stateMessage":
            suggest = "state_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcEncryptionControlResourceExclusionsVpcPeering. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcEncryptionControlResourceExclusionsVpcPeering.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcEncryptionControlResourceExclusionsVpcPeering.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 state: _builtins.str,
                 state_message: _builtins.str):
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "state_message", state_message)

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="stateMessage")
    def state_message(self) -> _builtins.str:
        return pulumi.get(self, "state_message")


@pulumi.output_type
class VpcEncryptionControlTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[_builtins.str] = None,
                 delete: Optional[_builtins.str] = None,
                 update: Optional[_builtins.str] = None):
        """
        :param _builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param _builtins.str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param _builtins.str update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")


@pulumi.output_type
class VpcEndpointDnsEntry(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsName":
            suggest = "dns_name"
        elif key == "hostedZoneId":
            suggest = "hosted_zone_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcEndpointDnsEntry. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcEndpointDnsEntry.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcEndpointDnsEntry.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dns_name: Optional[_builtins.str] = None,
                 hosted_zone_id: Optional[_builtins.str] = None):
        if dns_name is not None:
            pulumi.set(__self__, "dns_name", dns_name)
        if hosted_zone_id is not None:
            pulumi.set(__self__, "hosted_zone_id", hosted_zone_id)

    @_builtins.property
    @pulumi.getter(name="dnsName")
    def dns_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "dns_name")

    @_builtins.property
    @pulumi.getter(name="hostedZoneId")
    def hosted_zone_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "hosted_zone_id")


@pulumi.output_type
class VpcEndpointDnsOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsRecordIpType":
            suggest = "dns_record_ip_type"
        elif key == "privateDnsOnlyForInboundResolverEndpoint":
            suggest = "private_dns_only_for_inbound_resolver_endpoint"
        elif key == "privateDnsPreference":
            suggest = "private_dns_preference"
        elif key == "privateDnsSpecifiedDomains":
            suggest = "private_dns_specified_domains"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcEndpointDnsOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcEndpointDnsOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcEndpointDnsOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dns_record_ip_type: Optional[_builtins.str] = None,
                 private_dns_only_for_inbound_resolver_endpoint: Optional[_builtins.bool] = None,
                 private_dns_preference: Optional[_builtins.str] = None,
                 private_dns_specified_domains: Optional[Sequence[_builtins.str]] = None):
        if dns_record_ip_type is not None:
            pulumi.set(__self__, "dns_record_ip_type", dns_record_ip_type)
        if private_dns_only_for_inbound_resolver_endpoint is not None:
            pulumi.set(__self__, "private_dns_only_for_inbound_resolver_endpoint", private_dns_only_for_inbound_resolver_endpoint)
        if private_dns_preference is not None:
            pulumi.set(__self__, "private_dns_preference", private_dns_preference)
        if private_dns_specified_domains is not None:
            pulumi.set(__self__, "private_dns_specified_domains", private_dns_specified_domains)

    @_builtins.property
    @pulumi.getter(name="dnsRecordIpType")
    def dns_record_ip_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "dns_record_ip_type")

    @_builtins.property
    @pulumi.getter(name="privateDnsOnlyForInboundResolverEndpoint")
    def private_dns_only_for_inbound_resolver_endpoint(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "private_dns_only_for_inbound_resolver_endpoint")

    @_builtins.property
    @pulumi.getter(name="privateDnsPreference")
    def private_dns_preference(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "private_dns_preference")

    @_builtins.property
    @pulumi.getter(name="privateDnsSpecifiedDomains")
    def private_dns_specified_domains(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "private_dns_specified_domains")


@pulumi.output_type
class VpcEndpointServicePrivateDnsNameConfiguration(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class VpcEndpointSubnetConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcEndpointSubnetConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcEndpointSubnetConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcEndpointSubnetConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ipv4: Optional[_builtins.str] = None,
                 ipv6: Optional[_builtins.str] = None,
                 subnet_id: Optional[_builtins.str] = None):
        if ipv4 is not None:
            pulumi.set(__self__, "ipv4", ipv4)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter
    def ipv4(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ipv4")

    @_builtins.property
    @pulumi.getter
    def ipv6(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ipv6")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class VpcIpamOperatingRegion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "regionName":
            suggest = "region_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcIpamOperatingRegion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcIpamOperatingRegion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcIpamOperatingRegion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 region_name: _builtins.str):
        pulumi.set(__self__, "region_name", region_name)

    @_builtins.property
    @pulumi.getter(name="regionName")
    def region_name(self) -> _builtins.str:
        return pulumi.get(self, "region_name")


@pulumi.output_type
class VpcIpamPoolCidrCidrAuthorizationContext(dict):
    def __init__(__self__, *,
                 message: Optional[_builtins.str] = None,
                 signature: Optional[_builtins.str] = None):
        if message is not None:
            pulumi.set(__self__, "message", message)
        if signature is not None:
            pulumi.set(__self__, "signature", signature)

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter
    def signature(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "signature")


@pulumi.output_type
class VpcIpamResourceDiscoveryOperatingRegion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "regionName":
            suggest = "region_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcIpamResourceDiscoveryOperatingRegion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcIpamResourceDiscoveryOperatingRegion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcIpamResourceDiscoveryOperatingRegion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 region_name: _builtins.str):
        pulumi.set(__self__, "region_name", region_name)

    @_builtins.property
    @pulumi.getter(name="regionName")
    def region_name(self) -> _builtins.str:
        return pulumi.get(self, "region_name")


@pulumi.output_type
class VpcPeeringConnectionAccepter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowRemoteVpcDnsResolution":
            suggest = "allow_remote_vpc_dns_resolution"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcPeeringConnectionAccepter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcPeeringConnectionAccepter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcPeeringConnectionAccepter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_remote_vpc_dns_resolution: Optional[_builtins.bool] = None):
        if allow_remote_vpc_dns_resolution is not None:
            pulumi.set(__self__, "allow_remote_vpc_dns_resolution", allow_remote_vpc_dns_resolution)

    @_builtins.property
    @pulumi.getter(name="allowRemoteVpcDnsResolution")
    def allow_remote_vpc_dns_resolution(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "allow_remote_vpc_dns_resolution")


@pulumi.output_type
class VpcPeeringConnectionAccepterAccepter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowRemoteVpcDnsResolution":
            suggest = "allow_remote_vpc_dns_resolution"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcPeeringConnectionAccepterAccepter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcPeeringConnectionAccepterAccepter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcPeeringConnectionAccepterAccepter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_remote_vpc_dns_resolution: Optional[_builtins.bool] = None):
        if allow_remote_vpc_dns_resolution is not None:
            pulumi.set(__self__, "allow_remote_vpc_dns_resolution", allow_remote_vpc_dns_resolution)

    @_builtins.property
    @pulumi.getter(name="allowRemoteVpcDnsResolution")
    def allow_remote_vpc_dns_resolution(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "allow_remote_vpc_dns_resolution")


@pulumi.output_type
class VpcPeeringConnectionAccepterRequester(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowRemoteVpcDnsResolution":
            suggest = "allow_remote_vpc_dns_resolution"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcPeeringConnectionAccepterRequester. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcPeeringConnectionAccepterRequester.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcPeeringConnectionAccepterRequester.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_remote_vpc_dns_resolution: Optional[_builtins.bool] = None):
        if allow_remote_vpc_dns_resolution is not None:
            pulumi.set(__self__, "allow_remote_vpc_dns_resolution", allow_remote_vpc_dns_resolution)

    @_builtins.property
    @pulumi.getter(name="allowRemoteVpcDnsResolution")
    def allow_remote_vpc_dns_resolution(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "allow_remote_vpc_dns_resolution")


@pulumi.output_type
class VpcPeeringConnectionRequester(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowRemoteVpcDnsResolution":
            suggest = "allow_remote_vpc_dns_resolution"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcPeeringConnectionRequester. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcPeeringConnectionRequester.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcPeeringConnectionRequester.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_remote_vpc_dns_resolution: Optional[_builtins.bool] = None):
        if allow_remote_vpc_dns_resolution is not None:
            pulumi.set(__self__, "allow_remote_vpc_dns_resolution", allow_remote_vpc_dns_resolution)

    @_builtins.property
    @pulumi.getter(name="allowRemoteVpcDnsResolution")
    def allow_remote_vpc_dns_resolution(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "allow_remote_vpc_dns_resolution")


@pulumi.output_type
class VpnConnectionRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationCidrBlock":
            suggest = "destination_cidr_block"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpnConnectionRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpnConnectionRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpnConnectionRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_cidr_block: Optional[_builtins.str] = None,
                 source: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None):
        if destination_cidr_block is not None:
            pulumi.set(__self__, "destination_cidr_block", destination_cidr_block)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="destinationCidrBlock")
    def destination_cidr_block(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "destination_cidr_block")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "state")


@pulumi.output_type
class VpnConnectionTunnel1LogOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudwatchLogOptions":
            suggest = "cloudwatch_log_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpnConnectionTunnel1LogOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpnConnectionTunnel1LogOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpnConnectionTunnel1LogOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloudwatch_log_options: Optional['outputs.VpnConnectionTunnel1LogOptionsCloudwatchLogOptions'] = None):
        if cloudwatch_log_options is not None:
            pulumi.set(__self__, "cloudwatch_log_options", cloudwatch_log_options)

    @_builtins.property
    @pulumi.getter(name="cloudwatchLogOptions")
    def cloudwatch_log_options(self) -> Optional['outputs.VpnConnectionTunnel1LogOptionsCloudwatchLogOptions']:
        return pulumi.get(self, "cloudwatch_log_options")


@pulumi.output_type
class VpnConnectionTunnel1LogOptionsCloudwatchLogOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bgpLogEnabled":
            suggest = "bgp_log_enabled"
        elif key == "bgpLogGroupArn":
            suggest = "bgp_log_group_arn"
        elif key == "bgpLogOutputFormat":
            suggest = "bgp_log_output_format"
        elif key == "logEnabled":
            suggest = "log_enabled"
        elif key == "logGroupArn":
            suggest = "log_group_arn"
        elif key == "logOutputFormat":
            suggest = "log_output_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpnConnectionTunnel1LogOptionsCloudwatchLogOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpnConnectionTunnel1LogOptionsCloudwatchLogOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpnConnectionTunnel1LogOptionsCloudwatchLogOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bgp_log_enabled: Optional[_builtins.bool] = None,
                 bgp_log_group_arn: Optional[_builtins.str] = None,
                 bgp_log_output_format: Optional[_builtins.str] = None,
                 log_enabled: Optional[_builtins.bool] = None,
                 log_group_arn: Optional[_builtins.str] = None,
                 log_output_format: Optional[_builtins.str] = None):
        if bgp_log_enabled is not None:
            pulumi.set(__self__, "bgp_log_enabled", bgp_log_enabled)
        if bgp_log_group_arn is not None:
            pulumi.set(__self__, "bgp_log_group_arn", bgp_log_group_arn)
        if bgp_log_output_format is not None:
            pulumi.set(__self__, "bgp_log_output_format", bgp_log_output_format)
        if log_enabled is not None:
            pulumi.set(__self__, "log_enabled", log_enabled)
        if log_group_arn is not None:
            pulumi.set(__self__, "log_group_arn", log_group_arn)
        if log_output_format is not None:
            pulumi.set(__self__, "log_output_format", log_output_format)

    @_builtins.property
    @pulumi.getter(name="bgpLogEnabled")
    def bgp_log_enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "bgp_log_enabled")

    @_builtins.property
    @pulumi.getter(name="bgpLogGroupArn")
    def bgp_log_group_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "bgp_log_group_arn")

    @_builtins.property
    @pulumi.getter(name="bgpLogOutputFormat")
    def bgp_log_output_format(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "bgp_log_output_format")

    @_builtins.property
    @pulumi.getter(name="logEnabled")
    def log_enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "log_enabled")

    @_builtins.property
    @pulumi.getter(name="logGroupArn")
    def log_group_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "log_group_arn")

    @_builtins.property
    @pulumi.getter(name="logOutputFormat")
    def log_output_format(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "log_output_format")


@pulumi.output_type
class VpnConnectionTunnel2LogOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudwatchLogOptions":
            suggest = "cloudwatch_log_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpnConnectionTunnel2LogOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpnConnectionTunnel2LogOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpnConnectionTunnel2LogOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloudwatch_log_options: Optional['outputs.VpnConnectionTunnel2LogOptionsCloudwatchLogOptions'] = None):
        if cloudwatch_log_options is not None:
            pulumi.set(__self__, "cloudwatch_log_options", cloudwatch_log_options)

    @_builtins.property
    @pulumi.getter(name="cloudwatchLogOptions")
    def cloudwatch_log_options(self) -> Optional['outputs.VpnConnectionTunnel2LogOptionsCloudwatchLogOptions']:
        return pulumi.get(self, "cloudwatch_log_options")


@pulumi.output_type
class VpnConnectionTunnel2LogOptionsCloudwatchLogOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bgpLogEnabled":
            suggest = "bgp_log_enabled"
        elif key == "bgpLogGroupArn":
            suggest = "bgp_log_group_arn"
        elif key == "bgpLogOutputFormat":
            suggest = "bgp_log_output_format"
        elif key == "logEnabled":
            suggest = "log_enabled"
        elif key == "logGroupArn":
            suggest = "log_group_arn"
        elif key == "logOutputFormat":
            suggest = "log_output_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpnConnectionTunnel2LogOptionsCloudwatchLogOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpnConnectionTunnel2LogOptionsCloudwatchLogOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpnConnectionTunnel2LogOptionsCloudwatchLogOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bgp_log_enabled: Optional[_builtins.bool] = None,
                 bgp_log_group_arn: Optional[_builtins.str] = None,
                 bgp_log_output_format: Optional[_builtins.str] = None,
                 log_enabled: Optional[_builtins.bool] = None,
                 log_group_arn: Optional[_builtins.str] = None,
                 log_output_format: Optional[_builtins.str] = None):
        if bgp_log_enabled is not None:
            pulumi.set(__self__, "bgp_log_enabled", bgp_log_enabled)
        if bgp_log_group_arn is not None:
            pulumi.set(__self__, "bgp_log_group_arn", bgp_log_group_arn)
        if bgp_log_output_format is not None:
            pulumi.set(__self__, "bgp_log_output_format", bgp_log_output_format)
        if log_enabled is not None:
            pulumi.set(__self__, "log_enabled", log_enabled)
        if log_group_arn is not None:
            pulumi.set(__self__, "log_group_arn", log_group_arn)
        if log_output_format is not None:
            pulumi.set(__self__, "log_output_format", log_output_format)

    @_builtins.property
    @pulumi.getter(name="bgpLogEnabled")
    def bgp_log_enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "bgp_log_enabled")

    @_builtins.property
    @pulumi.getter(name="bgpLogGroupArn")
    def bgp_log_group_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "bgp_log_group_arn")

    @_builtins.property
    @pulumi.getter(name="bgpLogOutputFormat")
    def bgp_log_output_format(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "bgp_log_output_format")

    @_builtins.property
    @pulumi.getter(name="logEnabled")
    def log_enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "log_enabled")

    @_builtins.property
    @pulumi.getter(name="logGroupArn")
    def log_group_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "log_group_arn")

    @_builtins.property
    @pulumi.getter(name="logOutputFormat")
    def log_output_format(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "log_output_format")


@pulumi.output_type
class VpnConnectionVgwTelemetry(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acceptedRouteCount":
            suggest = "accepted_route_count"
        elif key == "certificateArn":
            suggest = "certificate_arn"
        elif key == "lastStatusChange":
            suggest = "last_status_change"
        elif key == "outsideIpAddress":
            suggest = "outside_ip_address"
        elif key == "statusMessage":
            suggest = "status_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpnConnectionVgwTelemetry. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpnConnectionVgwTelemetry.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpnConnectionVgwTelemetry.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 accepted_route_count: Optional[_builtins.int] = None,
                 certificate_arn: Optional[_builtins.str] = None,
                 last_status_change: Optional[_builtins.str] = None,
                 outside_ip_address: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None,
                 status_message: Optional[_builtins.str] = None):
        if accepted_route_count is not None:
            pulumi.set(__self__, "accepted_route_count", accepted_route_count)
        if certificate_arn is not None:
            pulumi.set(__self__, "certificate_arn", certificate_arn)
        if last_status_change is not None:
            pulumi.set(__self__, "last_status_change", last_status_change)
        if outside_ip_address is not None:
            pulumi.set(__self__, "outside_ip_address", outside_ip_address)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if status_message is not None:
            pulumi.set(__self__, "status_message", status_message)

    @_builtins.property
    @pulumi.getter(name="acceptedRouteCount")
    def accepted_route_count(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "accepted_route_count")

    @_builtins.property
    @pulumi.getter(name="certificateArn")
    def certificate_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "certificate_arn")

    @_builtins.property
    @pulumi.getter(name="lastStatusChange")
    def last_status_change(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "last_status_change")

    @_builtins.property
    @pulumi.getter(name="outsideIpAddress")
    def outside_ip_address(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "outside_ip_address")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="statusMessage")
    def status_message(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "status_message")


@pulumi.output_type
class GetAmiBlockDeviceMappingResult(dict):
    def __init__(__self__, *,
                 device_name: _builtins.str,
                 ebs: Mapping[str, _builtins.str],
                 no_device: _builtins.str,
                 virtual_name: _builtins.str):
        pulumi.set(__self__, "device_name", device_name)
        pulumi.set(__self__, "ebs", ebs)
        pulumi.set(__self__, "no_device", no_device)
        pulumi.set(__self__, "virtual_name", virtual_name)

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> _builtins.str:
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter
    def ebs(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "ebs")

    @_builtins.property
    @pulumi.getter(name="noDevice")
    def no_device(self) -> _builtins.str:
        return pulumi.get(self, "no_device")

    @_builtins.property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> _builtins.str:
        return pulumi.get(self, "virtual_name")


@pulumi.output_type
class GetAmiFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetAmiIdsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetAmiProductCodeResult(dict):
    def __init__(__self__, *,
                 product_code_id: _builtins.str,
                 product_code_type: _builtins.str):
        pulumi.set(__self__, "product_code_id", product_code_id)
        pulumi.set(__self__, "product_code_type", product_code_type)

    @_builtins.property
    @pulumi.getter(name="productCodeId")
    def product_code_id(self) -> _builtins.str:
        return pulumi.get(self, "product_code_id")

    @_builtins.property
    @pulumi.getter(name="productCodeType")
    def product_code_type(self) -> _builtins.str:
        return pulumi.get(self, "product_code_type")


@pulumi.output_type
class GetCoipPoolFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCoipPoolsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCustomerGatewayFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetDedicatedHostFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetEipsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetElasticIpFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetInstanceCreditSpecificationResult(dict):
    def __init__(__self__, *,
                 cpu_credits: _builtins.str):
        pulumi.set(__self__, "cpu_credits", cpu_credits)

    @_builtins.property
    @pulumi.getter(name="cpuCredits")
    def cpu_credits(self) -> _builtins.str:
        return pulumi.get(self, "cpu_credits")


@pulumi.output_type
class GetInstanceEbsBlockDeviceResult(dict):
    def __init__(__self__, *,
                 delete_on_termination: _builtins.bool,
                 device_name: _builtins.str,
                 encrypted: _builtins.bool,
                 iops: _builtins.int,
                 kms_key_id: _builtins.str,
                 snapshot_id: _builtins.str,
                 tags: Mapping[str, _builtins.str],
                 throughput: _builtins.int,
                 volume_id: _builtins.str,
                 volume_size: _builtins.int,
                 volume_type: _builtins.str):
        pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        pulumi.set(__self__, "device_name", device_name)
        pulumi.set(__self__, "encrypted", encrypted)
        pulumi.set(__self__, "iops", iops)
        pulumi.set(__self__, "kms_key_id", kms_key_id)
        pulumi.set(__self__, "snapshot_id", snapshot_id)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "throughput", throughput)
        pulumi.set(__self__, "volume_id", volume_id)
        pulumi.set(__self__, "volume_size", volume_size)
        pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> _builtins.bool:
        return pulumi.get(self, "delete_on_termination")

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> _builtins.str:
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter
    def encrypted(self) -> _builtins.bool:
        return pulumi.get(self, "encrypted")

    @_builtins.property
    @pulumi.getter
    def iops(self) -> _builtins.int:
        return pulumi.get(self, "iops")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> _builtins.str:
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> _builtins.str:
        return pulumi.get(self, "snapshot_id")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def throughput(self) -> _builtins.int:
        return pulumi.get(self, "throughput")

    @_builtins.property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> _builtins.str:
        return pulumi.get(self, "volume_id")

    @_builtins.property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> _builtins.int:
        return pulumi.get(self, "volume_size")

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> _builtins.str:
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class GetInstanceEnclaveOptionResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool):
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetInstanceEphemeralBlockDeviceResult(dict):
    def __init__(__self__, *,
                 device_name: _builtins.str,
                 no_device: Optional[_builtins.bool] = None,
                 virtual_name: Optional[_builtins.str] = None):
        pulumi.set(__self__, "device_name", device_name)
        if no_device is not None:
            pulumi.set(__self__, "no_device", no_device)
        if virtual_name is not None:
            pulumi.set(__self__, "virtual_name", virtual_name)

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> _builtins.str:
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter(name="noDevice")
    def no_device(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "no_device")

    @_builtins.property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "virtual_name")


@pulumi.output_type
class GetInstanceFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetInstanceMaintenanceOptionResult(dict):
    def __init__(__self__, *,
                 auto_recovery: _builtins.str):
        pulumi.set(__self__, "auto_recovery", auto_recovery)

    @_builtins.property
    @pulumi.getter(name="autoRecovery")
    def auto_recovery(self) -> _builtins.str:
        return pulumi.get(self, "auto_recovery")


@pulumi.output_type
class GetInstanceMetadataOptionResult(dict):
    def __init__(__self__, *,
                 http_endpoint: _builtins.str,
                 http_protocol_ipv6: _builtins.str,
                 http_put_response_hop_limit: _builtins.int,
                 http_tokens: _builtins.str,
                 instance_metadata_tags: _builtins.str):
        pulumi.set(__self__, "http_endpoint", http_endpoint)
        pulumi.set(__self__, "http_protocol_ipv6", http_protocol_ipv6)
        pulumi.set(__self__, "http_put_response_hop_limit", http_put_response_hop_limit)
        pulumi.set(__self__, "http_tokens", http_tokens)
        pulumi.set(__self__, "instance_metadata_tags", instance_metadata_tags)

    @_builtins.property
    @pulumi.getter(name="httpEndpoint")
    def http_endpoint(self) -> _builtins.str:
        return pulumi.get(self, "http_endpoint")

    @_builtins.property
    @pulumi.getter(name="httpProtocolIpv6")
    def http_protocol_ipv6(self) -> _builtins.str:
        return pulumi.get(self, "http_protocol_ipv6")

    @_builtins.property
    @pulumi.getter(name="httpPutResponseHopLimit")
    def http_put_response_hop_limit(self) -> _builtins.int:
        return pulumi.get(self, "http_put_response_hop_limit")

    @_builtins.property
    @pulumi.getter(name="httpTokens")
    def http_tokens(self) -> _builtins.str:
        return pulumi.get(self, "http_tokens")

    @_builtins.property
    @pulumi.getter(name="instanceMetadataTags")
    def instance_metadata_tags(self) -> _builtins.str:
        return pulumi.get(self, "instance_metadata_tags")


@pulumi.output_type
class GetInstancePrivateDnsNameOptionResult(dict):
    def __init__(__self__, *,
                 enable_resource_name_dns_a_record: _builtins.bool,
                 enable_resource_name_dns_aaaa_record: _builtins.bool,
                 hostname_type: _builtins.str):
        pulumi.set(__self__, "enable_resource_name_dns_a_record", enable_resource_name_dns_a_record)
        pulumi.set(__self__, "enable_resource_name_dns_aaaa_record", enable_resource_name_dns_aaaa_record)
        pulumi.set(__self__, "hostname_type", hostname_type)

    @_builtins.property
    @pulumi.getter(name="enableResourceNameDnsARecord")
    def enable_resource_name_dns_a_record(self) -> _builtins.bool:
        return pulumi.get(self, "enable_resource_name_dns_a_record")

    @_builtins.property
    @pulumi.getter(name="enableResourceNameDnsAaaaRecord")
    def enable_resource_name_dns_aaaa_record(self) -> _builtins.bool:
        return pulumi.get(self, "enable_resource_name_dns_aaaa_record")

    @_builtins.property
    @pulumi.getter(name="hostnameType")
    def hostname_type(self) -> _builtins.str:
        return pulumi.get(self, "hostname_type")


@pulumi.output_type
class GetInstanceRootBlockDeviceResult(dict):
    def __init__(__self__, *,
                 delete_on_termination: _builtins.bool,
                 device_name: _builtins.str,
                 encrypted: _builtins.bool,
                 iops: _builtins.int,
                 kms_key_id: _builtins.str,
                 tags: Mapping[str, _builtins.str],
                 throughput: _builtins.int,
                 volume_id: _builtins.str,
                 volume_size: _builtins.int,
                 volume_type: _builtins.str):
        pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        pulumi.set(__self__, "device_name", device_name)
        pulumi.set(__self__, "encrypted", encrypted)
        pulumi.set(__self__, "iops", iops)
        pulumi.set(__self__, "kms_key_id", kms_key_id)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "throughput", throughput)
        pulumi.set(__self__, "volume_id", volume_id)
        pulumi.set(__self__, "volume_size", volume_size)
        pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> _builtins.bool:
        return pulumi.get(self, "delete_on_termination")

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> _builtins.str:
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter
    def encrypted(self) -> _builtins.bool:
        return pulumi.get(self, "encrypted")

    @_builtins.property
    @pulumi.getter
    def iops(self) -> _builtins.int:
        return pulumi.get(self, "iops")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> _builtins.str:
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def throughput(self) -> _builtins.int:
        return pulumi.get(self, "throughput")

    @_builtins.property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> _builtins.str:
        return pulumi.get(self, "volume_id")

    @_builtins.property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> _builtins.int:
        return pulumi.get(self, "volume_size")

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> _builtins.str:
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class GetInstanceTypeFpgaResult(dict):
    def __init__(__self__, *,
                 count: _builtins.int,
                 manufacturer: _builtins.str,
                 memory_size: _builtins.int,
                 name: _builtins.str):
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "manufacturer", manufacturer)
        pulumi.set(__self__, "memory_size", memory_size)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def count(self) -> _builtins.int:
        return pulumi.get(self, "count")

    @_builtins.property
    @pulumi.getter
    def manufacturer(self) -> _builtins.str:
        return pulumi.get(self, "manufacturer")

    @_builtins.property
    @pulumi.getter(name="memorySize")
    def memory_size(self) -> _builtins.int:
        return pulumi.get(self, "memory_size")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetInstanceTypeGpusResult(dict):
    def __init__(__self__, *,
                 count: _builtins.int,
                 manufacturer: _builtins.str,
                 memory_size: _builtins.int,
                 name: _builtins.str):
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "manufacturer", manufacturer)
        pulumi.set(__self__, "memory_size", memory_size)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def count(self) -> _builtins.int:
        return pulumi.get(self, "count")

    @_builtins.property
    @pulumi.getter
    def manufacturer(self) -> _builtins.str:
        return pulumi.get(self, "manufacturer")

    @_builtins.property
    @pulumi.getter(name="memorySize")
    def memory_size(self) -> _builtins.int:
        return pulumi.get(self, "memory_size")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetInstanceTypeInferenceAcceleratorResult(dict):
    def __init__(__self__, *,
                 count: _builtins.int,
                 manufacturer: _builtins.str,
                 memory_size: _builtins.int,
                 name: _builtins.str):
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "manufacturer", manufacturer)
        pulumi.set(__self__, "memory_size", memory_size)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def count(self) -> _builtins.int:
        return pulumi.get(self, "count")

    @_builtins.property
    @pulumi.getter
    def manufacturer(self) -> _builtins.str:
        return pulumi.get(self, "manufacturer")

    @_builtins.property
    @pulumi.getter(name="memorySize")
    def memory_size(self) -> _builtins.int:
        return pulumi.get(self, "memory_size")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetInstanceTypeInstanceDiskResult(dict):
    def __init__(__self__, *,
                 count: _builtins.int,
                 size: _builtins.int,
                 type: _builtins.str):
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def count(self) -> _builtins.int:
        return pulumi.get(self, "count")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.int:
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetInstanceTypeMediaAcceleratorResult(dict):
    def __init__(__self__, *,
                 count: _builtins.int,
                 manufacturer: _builtins.str,
                 memory_size: _builtins.int,
                 name: _builtins.str):
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "manufacturer", manufacturer)
        pulumi.set(__self__, "memory_size", memory_size)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def count(self) -> _builtins.int:
        return pulumi.get(self, "count")

    @_builtins.property
    @pulumi.getter
    def manufacturer(self) -> _builtins.str:
        return pulumi.get(self, "manufacturer")

    @_builtins.property
    @pulumi.getter(name="memorySize")
    def memory_size(self) -> _builtins.int:
        return pulumi.get(self, "memory_size")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetInstanceTypeNetworkCardResult(dict):
    def __init__(__self__, *,
                 baseline_bandwidth: _builtins.float,
                 index: _builtins.int,
                 maximum_interfaces: _builtins.int,
                 peak_bandwidth: _builtins.float,
                 performance: _builtins.str):
        pulumi.set(__self__, "baseline_bandwidth", baseline_bandwidth)
        pulumi.set(__self__, "index", index)
        pulumi.set(__self__, "maximum_interfaces", maximum_interfaces)
        pulumi.set(__self__, "peak_bandwidth", peak_bandwidth)
        pulumi.set(__self__, "performance", performance)

    @_builtins.property
    @pulumi.getter(name="baselineBandwidth")
    def baseline_bandwidth(self) -> _builtins.float:
        return pulumi.get(self, "baseline_bandwidth")

    @_builtins.property
    @pulumi.getter
    def index(self) -> _builtins.int:
        return pulumi.get(self, "index")

    @_builtins.property
    @pulumi.getter(name="maximumInterfaces")
    def maximum_interfaces(self) -> _builtins.int:
        return pulumi.get(self, "maximum_interfaces")

    @_builtins.property
    @pulumi.getter(name="peakBandwidth")
    def peak_bandwidth(self) -> _builtins.float:
        return pulumi.get(self, "peak_bandwidth")

    @_builtins.property
    @pulumi.getter
    def performance(self) -> _builtins.str:
        return pulumi.get(self, "performance")


@pulumi.output_type
class GetInstanceTypeNeuronDeviceResult(dict):
    def __init__(__self__, *,
                 core_count: _builtins.int,
                 core_version: _builtins.int,
                 count: _builtins.int,
                 memory_size: _builtins.int,
                 name: _builtins.str):
        pulumi.set(__self__, "core_count", core_count)
        pulumi.set(__self__, "core_version", core_version)
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "memory_size", memory_size)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="coreCount")
    def core_count(self) -> _builtins.int:
        return pulumi.get(self, "core_count")

    @_builtins.property
    @pulumi.getter(name="coreVersion")
    def core_version(self) -> _builtins.int:
        return pulumi.get(self, "core_version")

    @_builtins.property
    @pulumi.getter
    def count(self) -> _builtins.int:
        return pulumi.get(self, "count")

    @_builtins.property
    @pulumi.getter(name="memorySize")
    def memory_size(self) -> _builtins.int:
        return pulumi.get(self, "memory_size")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetInstanceTypeOfferingFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetInstanceTypeOfferingsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetInstanceTypesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetInstancesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetInternetGatewayAttachmentResult(dict):
    def __init__(__self__, *,
                 state: _builtins.str,
                 vpc_id: _builtins.str):
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "vpc_id", vpc_id)

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> _builtins.str:
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class GetInternetGatewayFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetKeyPairFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetLaunchConfigurationEbsBlockDeviceResult(dict):
    def __init__(__self__, *,
                 delete_on_termination: _builtins.bool,
                 device_name: _builtins.str,
                 encrypted: _builtins.bool,
                 iops: _builtins.int,
                 no_device: _builtins.bool,
                 snapshot_id: _builtins.str,
                 throughput: _builtins.int,
                 volume_size: _builtins.int,
                 volume_type: _builtins.str):
        pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        pulumi.set(__self__, "device_name", device_name)
        pulumi.set(__self__, "encrypted", encrypted)
        pulumi.set(__self__, "iops", iops)
        pulumi.set(__self__, "no_device", no_device)
        pulumi.set(__self__, "snapshot_id", snapshot_id)
        pulumi.set(__self__, "throughput", throughput)
        pulumi.set(__self__, "volume_size", volume_size)
        pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> _builtins.bool:
        return pulumi.get(self, "delete_on_termination")

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> _builtins.str:
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter
    def encrypted(self) -> _builtins.bool:
        return pulumi.get(self, "encrypted")

    @_builtins.property
    @pulumi.getter
    def iops(self) -> _builtins.int:
        return pulumi.get(self, "iops")

    @_builtins.property
    @pulumi.getter(name="noDevice")
    def no_device(self) -> _builtins.bool:
        return pulumi.get(self, "no_device")

    @_builtins.property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> _builtins.str:
        return pulumi.get(self, "snapshot_id")

    @_builtins.property
    @pulumi.getter
    def throughput(self) -> _builtins.int:
        return pulumi.get(self, "throughput")

    @_builtins.property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> _builtins.int:
        return pulumi.get(self, "volume_size")

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> _builtins.str:
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class GetLaunchConfigurationEphemeralBlockDeviceResult(dict):
    def __init__(__self__, *,
                 device_name: _builtins.str,
                 virtual_name: _builtins.str):
        pulumi.set(__self__, "device_name", device_name)
        pulumi.set(__self__, "virtual_name", virtual_name)

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> _builtins.str:
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> _builtins.str:
        return pulumi.get(self, "virtual_name")


@pulumi.output_type
class GetLaunchConfigurationMetadataOptionResult(dict):
    def __init__(__self__, *,
                 http_endpoint: _builtins.str,
                 http_put_response_hop_limit: _builtins.int,
                 http_tokens: _builtins.str):
        pulumi.set(__self__, "http_endpoint", http_endpoint)
        pulumi.set(__self__, "http_put_response_hop_limit", http_put_response_hop_limit)
        pulumi.set(__self__, "http_tokens", http_tokens)

    @_builtins.property
    @pulumi.getter(name="httpEndpoint")
    def http_endpoint(self) -> _builtins.str:
        return pulumi.get(self, "http_endpoint")

    @_builtins.property
    @pulumi.getter(name="httpPutResponseHopLimit")
    def http_put_response_hop_limit(self) -> _builtins.int:
        return pulumi.get(self, "http_put_response_hop_limit")

    @_builtins.property
    @pulumi.getter(name="httpTokens")
    def http_tokens(self) -> _builtins.str:
        return pulumi.get(self, "http_tokens")


@pulumi.output_type
class GetLaunchConfigurationRootBlockDeviceResult(dict):
    def __init__(__self__, *,
                 delete_on_termination: _builtins.bool,
                 encrypted: _builtins.bool,
                 iops: _builtins.int,
                 throughput: _builtins.int,
                 volume_size: _builtins.int,
                 volume_type: _builtins.str):
        pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        pulumi.set(__self__, "encrypted", encrypted)
        pulumi.set(__self__, "iops", iops)
        pulumi.set(__self__, "throughput", throughput)
        pulumi.set(__self__, "volume_size", volume_size)
        pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> _builtins.bool:
        return pulumi.get(self, "delete_on_termination")

    @_builtins.property
    @pulumi.getter
    def encrypted(self) -> _builtins.bool:
        return pulumi.get(self, "encrypted")

    @_builtins.property
    @pulumi.getter
    def iops(self) -> _builtins.int:
        return pulumi.get(self, "iops")

    @_builtins.property
    @pulumi.getter
    def throughput(self) -> _builtins.int:
        return pulumi.get(self, "throughput")

    @_builtins.property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> _builtins.int:
        return pulumi.get(self, "volume_size")

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> _builtins.str:
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class GetLaunchTemplateBlockDeviceMappingResult(dict):
    def __init__(__self__, *,
                 device_name: _builtins.str,
                 ebs: Sequence['outputs.GetLaunchTemplateBlockDeviceMappingEbResult'],
                 no_device: _builtins.str,
                 virtual_name: _builtins.str):
        pulumi.set(__self__, "device_name", device_name)
        pulumi.set(__self__, "ebs", ebs)
        pulumi.set(__self__, "no_device", no_device)
        pulumi.set(__self__, "virtual_name", virtual_name)

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> _builtins.str:
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter
    def ebs(self) -> Sequence['outputs.GetLaunchTemplateBlockDeviceMappingEbResult']:
        return pulumi.get(self, "ebs")

    @_builtins.property
    @pulumi.getter(name="noDevice")
    def no_device(self) -> _builtins.str:
        return pulumi.get(self, "no_device")

    @_builtins.property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> _builtins.str:
        return pulumi.get(self, "virtual_name")


@pulumi.output_type
class GetLaunchTemplateBlockDeviceMappingEbResult(dict):
    def __init__(__self__, *,
                 delete_on_termination: _builtins.str,
                 encrypted: _builtins.str,
                 iops: _builtins.int,
                 kms_key_id: _builtins.str,
                 snapshot_id: _builtins.str,
                 throughput: _builtins.int,
                 volume_initialization_rate: _builtins.int,
                 volume_size: _builtins.int,
                 volume_type: _builtins.str):
        pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        pulumi.set(__self__, "encrypted", encrypted)
        pulumi.set(__self__, "iops", iops)
        pulumi.set(__self__, "kms_key_id", kms_key_id)
        pulumi.set(__self__, "snapshot_id", snapshot_id)
        pulumi.set(__self__, "throughput", throughput)
        pulumi.set(__self__, "volume_initialization_rate", volume_initialization_rate)
        pulumi.set(__self__, "volume_size", volume_size)
        pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> _builtins.str:
        return pulumi.get(self, "delete_on_termination")

    @_builtins.property
    @pulumi.getter
    def encrypted(self) -> _builtins.str:
        return pulumi.get(self, "encrypted")

    @_builtins.property
    @pulumi.getter
    def iops(self) -> _builtins.int:
        return pulumi.get(self, "iops")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> _builtins.str:
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> _builtins.str:
        return pulumi.get(self, "snapshot_id")

    @_builtins.property
    @pulumi.getter
    def throughput(self) -> _builtins.int:
        return pulumi.get(self, "throughput")

    @_builtins.property
    @pulumi.getter(name="volumeInitializationRate")
    def volume_initialization_rate(self) -> _builtins.int:
        return pulumi.get(self, "volume_initialization_rate")

    @_builtins.property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> _builtins.int:
        return pulumi.get(self, "volume_size")

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> _builtins.str:
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class GetLaunchTemplateCapacityReservationSpecificationResult(dict):
    def __init__(__self__, *,
                 capacity_reservation_preference: _builtins.str,
                 capacity_reservation_targets: Sequence['outputs.GetLaunchTemplateCapacityReservationSpecificationCapacityReservationTargetResult']):
        pulumi.set(__self__, "capacity_reservation_preference", capacity_reservation_preference)
        pulumi.set(__self__, "capacity_reservation_targets", capacity_reservation_targets)

    @_builtins.property
    @pulumi.getter(name="capacityReservationPreference")
    def capacity_reservation_preference(self) -> _builtins.str:
        return pulumi.get(self, "capacity_reservation_preference")

    @_builtins.property
    @pulumi.getter(name="capacityReservationTargets")
    def capacity_reservation_targets(self) -> Sequence['outputs.GetLaunchTemplateCapacityReservationSpecificationCapacityReservationTargetResult']:
        return pulumi.get(self, "capacity_reservation_targets")


@pulumi.output_type
class GetLaunchTemplateCapacityReservationSpecificationCapacityReservationTargetResult(dict):
    def __init__(__self__, *,
                 capacity_reservation_id: _builtins.str,
                 capacity_reservation_resource_group_arn: _builtins.str):
        pulumi.set(__self__, "capacity_reservation_id", capacity_reservation_id)
        pulumi.set(__self__, "capacity_reservation_resource_group_arn", capacity_reservation_resource_group_arn)

    @_builtins.property
    @pulumi.getter(name="capacityReservationId")
    def capacity_reservation_id(self) -> _builtins.str:
        return pulumi.get(self, "capacity_reservation_id")

    @_builtins.property
    @pulumi.getter(name="capacityReservationResourceGroupArn")
    def capacity_reservation_resource_group_arn(self) -> _builtins.str:
        return pulumi.get(self, "capacity_reservation_resource_group_arn")


@pulumi.output_type
class GetLaunchTemplateCpuOptionResult(dict):
    def __init__(__self__, *,
                 amd_sev_snp: _builtins.str,
                 core_count: _builtins.int,
                 threads_per_core: _builtins.int):
        pulumi.set(__self__, "amd_sev_snp", amd_sev_snp)
        pulumi.set(__self__, "core_count", core_count)
        pulumi.set(__self__, "threads_per_core", threads_per_core)

    @_builtins.property
    @pulumi.getter(name="amdSevSnp")
    def amd_sev_snp(self) -> _builtins.str:
        return pulumi.get(self, "amd_sev_snp")

    @_builtins.property
    @pulumi.getter(name="coreCount")
    def core_count(self) -> _builtins.int:
        return pulumi.get(self, "core_count")

    @_builtins.property
    @pulumi.getter(name="threadsPerCore")
    def threads_per_core(self) -> _builtins.int:
        return pulumi.get(self, "threads_per_core")


@pulumi.output_type
class GetLaunchTemplateCreditSpecificationResult(dict):
    def __init__(__self__, *,
                 cpu_credits: _builtins.str):
        pulumi.set(__self__, "cpu_credits", cpu_credits)

    @_builtins.property
    @pulumi.getter(name="cpuCredits")
    def cpu_credits(self) -> _builtins.str:
        return pulumi.get(self, "cpu_credits")


@pulumi.output_type
class GetLaunchTemplateEnclaveOptionResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool):
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetLaunchTemplateFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetLaunchTemplateHibernationOptionResult(dict):
    def __init__(__self__, *,
                 configured: _builtins.bool):
        pulumi.set(__self__, "configured", configured)

    @_builtins.property
    @pulumi.getter
    def configured(self) -> _builtins.bool:
        return pulumi.get(self, "configured")


@pulumi.output_type
class GetLaunchTemplateIamInstanceProfileResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 name: _builtins.str):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetLaunchTemplateInstanceMarketOptionResult(dict):
    def __init__(__self__, *,
                 market_type: _builtins.str,
                 spot_options: Sequence['outputs.GetLaunchTemplateInstanceMarketOptionSpotOptionResult']):
        pulumi.set(__self__, "market_type", market_type)
        pulumi.set(__self__, "spot_options", spot_options)

    @_builtins.property
    @pulumi.getter(name="marketType")
    def market_type(self) -> _builtins.str:
        return pulumi.get(self, "market_type")

    @_builtins.property
    @pulumi.getter(name="spotOptions")
    def spot_options(self) -> Sequence['outputs.GetLaunchTemplateInstanceMarketOptionSpotOptionResult']:
        return pulumi.get(self, "spot_options")


@pulumi.output_type
class GetLaunchTemplateInstanceMarketOptionSpotOptionResult(dict):
    def __init__(__self__, *,
                 block_duration_minutes: _builtins.int,
                 instance_interruption_behavior: _builtins.str,
                 max_price: _builtins.str,
                 spot_instance_type: _builtins.str,
                 valid_until: _builtins.str):
        pulumi.set(__self__, "block_duration_minutes", block_duration_minutes)
        pulumi.set(__self__, "instance_interruption_behavior", instance_interruption_behavior)
        pulumi.set(__self__, "max_price", max_price)
        pulumi.set(__self__, "spot_instance_type", spot_instance_type)
        pulumi.set(__self__, "valid_until", valid_until)

    @_builtins.property
    @pulumi.getter(name="blockDurationMinutes")
    def block_duration_minutes(self) -> _builtins.int:
        return pulumi.get(self, "block_duration_minutes")

    @_builtins.property
    @pulumi.getter(name="instanceInterruptionBehavior")
    def instance_interruption_behavior(self) -> _builtins.str:
        return pulumi.get(self, "instance_interruption_behavior")

    @_builtins.property
    @pulumi.getter(name="maxPrice")
    def max_price(self) -> _builtins.str:
        return pulumi.get(self, "max_price")

    @_builtins.property
    @pulumi.getter(name="spotInstanceType")
    def spot_instance_type(self) -> _builtins.str:
        return pulumi.get(self, "spot_instance_type")

    @_builtins.property
    @pulumi.getter(name="validUntil")
    def valid_until(self) -> _builtins.str:
        return pulumi.get(self, "valid_until")


@pulumi.output_type
class GetLaunchTemplateInstanceRequirementResult(dict):
    def __init__(__self__, *,
                 accelerator_counts: Sequence['outputs.GetLaunchTemplateInstanceRequirementAcceleratorCountResult'],
                 accelerator_manufacturers: Sequence[_builtins.str],
                 accelerator_names: Sequence[_builtins.str],
                 accelerator_total_memory_mibs: Sequence['outputs.GetLaunchTemplateInstanceRequirementAcceleratorTotalMemoryMibResult'],
                 accelerator_types: Sequence[_builtins.str],
                 allowed_instance_types: Sequence[_builtins.str],
                 bare_metal: _builtins.str,
                 baseline_ebs_bandwidth_mbps: Sequence['outputs.GetLaunchTemplateInstanceRequirementBaselineEbsBandwidthMbpResult'],
                 burstable_performance: _builtins.str,
                 cpu_manufacturers: Sequence[_builtins.str],
                 excluded_instance_types: Sequence[_builtins.str],
                 instance_generations: Sequence[_builtins.str],
                 local_storage: _builtins.str,
                 local_storage_types: Sequence[_builtins.str],
                 max_spot_price_as_percentage_of_optimal_on_demand_price: _builtins.int,
                 memory_gib_per_vcpus: Sequence['outputs.GetLaunchTemplateInstanceRequirementMemoryGibPerVcpusResult'],
                 memory_mibs: Sequence['outputs.GetLaunchTemplateInstanceRequirementMemoryMibResult'],
                 network_bandwidth_gbps: Sequence['outputs.GetLaunchTemplateInstanceRequirementNetworkBandwidthGbpResult'],
                 network_interface_counts: Sequence['outputs.GetLaunchTemplateInstanceRequirementNetworkInterfaceCountResult'],
                 on_demand_max_price_percentage_over_lowest_price: _builtins.int,
                 require_hibernate_support: _builtins.bool,
                 spot_max_price_percentage_over_lowest_price: _builtins.int,
                 total_local_storage_gbs: Sequence['outputs.GetLaunchTemplateInstanceRequirementTotalLocalStorageGbResult'],
                 vcpu_counts: Sequence['outputs.GetLaunchTemplateInstanceRequirementVcpuCountResult']):
        pulumi.set(__self__, "accelerator_counts", accelerator_counts)
        pulumi.set(__self__, "accelerator_manufacturers", accelerator_manufacturers)
        pulumi.set(__self__, "accelerator_names", accelerator_names)
        pulumi.set(__self__, "accelerator_total_memory_mibs", accelerator_total_memory_mibs)
        pulumi.set(__self__, "accelerator_types", accelerator_types)
        pulumi.set(__self__, "allowed_instance_types", allowed_instance_types)
        pulumi.set(__self__, "bare_metal", bare_metal)
        pulumi.set(__self__, "baseline_ebs_bandwidth_mbps", baseline_ebs_bandwidth_mbps)
        pulumi.set(__self__, "burstable_performance", burstable_performance)
        pulumi.set(__self__, "cpu_manufacturers", cpu_manufacturers)
        pulumi.set(__self__, "excluded_instance_types", excluded_instance_types)
        pulumi.set(__self__, "instance_generations", instance_generations)
        pulumi.set(__self__, "local_storage", local_storage)
        pulumi.set(__self__, "local_storage_types", local_storage_types)
        pulumi.set(__self__, "max_spot_price_as_percentage_of_optimal_on_demand_price", max_spot_price_as_percentage_of_optimal_on_demand_price)
        pulumi.set(__self__, "memory_gib_per_vcpus", memory_gib_per_vcpus)
        pulumi.set(__self__, "memory_mibs", memory_mibs)
        pulumi.set(__self__, "network_bandwidth_gbps", network_bandwidth_gbps)
        pulumi.set(__self__, "network_interface_counts", network_interface_counts)
        pulumi.set(__self__, "on_demand_max_price_percentage_over_lowest_price", on_demand_max_price_percentage_over_lowest_price)
        pulumi.set(__self__, "require_hibernate_support", require_hibernate_support)
        pulumi.set(__self__, "spot_max_price_percentage_over_lowest_price", spot_max_price_percentage_over_lowest_price)
        pulumi.set(__self__, "total_local_storage_gbs", total_local_storage_gbs)
        pulumi.set(__self__, "vcpu_counts", vcpu_counts)

    @_builtins.property
    @pulumi.getter(name="acceleratorCounts")
    def accelerator_counts(self) -> Sequence['outputs.GetLaunchTemplateInstanceRequirementAcceleratorCountResult']:
        return pulumi.get(self, "accelerator_counts")

    @_builtins.property
    @pulumi.getter(name="acceleratorManufacturers")
    def accelerator_manufacturers(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "accelerator_manufacturers")

    @_builtins.property
    @pulumi.getter(name="acceleratorNames")
    def accelerator_names(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "accelerator_names")

    @_builtins.property
    @pulumi.getter(name="acceleratorTotalMemoryMibs")
    def accelerator_total_memory_mibs(self) -> Sequence['outputs.GetLaunchTemplateInstanceRequirementAcceleratorTotalMemoryMibResult']:
        return pulumi.get(self, "accelerator_total_memory_mibs")

    @_builtins.property
    @pulumi.getter(name="acceleratorTypes")
    def accelerator_types(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "accelerator_types")

    @_builtins.property
    @pulumi.getter(name="allowedInstanceTypes")
    def allowed_instance_types(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "allowed_instance_types")

    @_builtins.property
    @pulumi.getter(name="bareMetal")
    def bare_metal(self) -> _builtins.str:
        return pulumi.get(self, "bare_metal")

    @_builtins.property
    @pulumi.getter(name="baselineEbsBandwidthMbps")
    def baseline_ebs_bandwidth_mbps(self) -> Sequence['outputs.GetLaunchTemplateInstanceRequirementBaselineEbsBandwidthMbpResult']:
        return pulumi.get(self, "baseline_ebs_bandwidth_mbps")

    @_builtins.property
    @pulumi.getter(name="burstablePerformance")
    def burstable_performance(self) -> _builtins.str:
        return pulumi.get(self, "burstable_performance")

    @_builtins.property
    @pulumi.getter(name="cpuManufacturers")
    def cpu_manufacturers(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "cpu_manufacturers")

    @_builtins.property
    @pulumi.getter(name="excludedInstanceTypes")
    def excluded_instance_types(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "excluded_instance_types")

    @_builtins.property
    @pulumi.getter(name="instanceGenerations")
    def instance_generations(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "instance_generations")

    @_builtins.property
    @pulumi.getter(name="localStorage")
    def local_storage(self) -> _builtins.str:
        return pulumi.get(self, "local_storage")

    @_builtins.property
    @pulumi.getter(name="localStorageTypes")
    def local_storage_types(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "local_storage_types")

    @_builtins.property
    @pulumi.getter(name="maxSpotPriceAsPercentageOfOptimalOnDemandPrice")
    def max_spot_price_as_percentage_of_optimal_on_demand_price(self) -> _builtins.int:
        return pulumi.get(self, "max_spot_price_as_percentage_of_optimal_on_demand_price")

    @_builtins.property
    @pulumi.getter(name="memoryGibPerVcpus")
    def memory_gib_per_vcpus(self) -> Sequence['outputs.GetLaunchTemplateInstanceRequirementMemoryGibPerVcpusResult']:
        return pulumi.get(self, "memory_gib_per_vcpus")

    @_builtins.property
    @pulumi.getter(name="memoryMibs")
    def memory_mibs(self) -> Sequence['outputs.GetLaunchTemplateInstanceRequirementMemoryMibResult']:
        return pulumi.get(self, "memory_mibs")

    @_builtins.property
    @pulumi.getter(name="networkBandwidthGbps")
    def network_bandwidth_gbps(self) -> Sequence['outputs.GetLaunchTemplateInstanceRequirementNetworkBandwidthGbpResult']:
        return pulumi.get(self, "network_bandwidth_gbps")

    @_builtins.property
    @pulumi.getter(name="networkInterfaceCounts")
    def network_interface_counts(self) -> Sequence['outputs.GetLaunchTemplateInstanceRequirementNetworkInterfaceCountResult']:
        return pulumi.get(self, "network_interface_counts")

    @_builtins.property
    @pulumi.getter(name="onDemandMaxPricePercentageOverLowestPrice")
    def on_demand_max_price_percentage_over_lowest_price(self) -> _builtins.int:
        return pulumi.get(self, "on_demand_max_price_percentage_over_lowest_price")

    @_builtins.property
    @pulumi.getter(name="requireHibernateSupport")
    def require_hibernate_support(self) -> _builtins.bool:
        return pulumi.get(self, "require_hibernate_support")

    @_builtins.property
    @pulumi.getter(name="spotMaxPricePercentageOverLowestPrice")
    def spot_max_price_percentage_over_lowest_price(self) -> _builtins.int:
        return pulumi.get(self, "spot_max_price_percentage_over_lowest_price")

    @_builtins.property
    @pulumi.getter(name="totalLocalStorageGbs")
    def total_local_storage_gbs(self) -> Sequence['outputs.GetLaunchTemplateInstanceRequirementTotalLocalStorageGbResult']:
        return pulumi.get(self, "total_local_storage_gbs")

    @_builtins.property
    @pulumi.getter(name="vcpuCounts")
    def vcpu_counts(self) -> Sequence['outputs.GetLaunchTemplateInstanceRequirementVcpuCountResult']:
        return pulumi.get(self, "vcpu_counts")


@pulumi.output_type
class GetLaunchTemplateInstanceRequirementAcceleratorCountResult(dict):
    def __init__(__self__, *,
                 max: _builtins.int,
                 min: _builtins.int):
        pulumi.set(__self__, "max", max)
        pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> _builtins.int:
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> _builtins.int:
        return pulumi.get(self, "min")


@pulumi.output_type
class GetLaunchTemplateInstanceRequirementAcceleratorTotalMemoryMibResult(dict):
    def __init__(__self__, *,
                 max: _builtins.int,
                 min: _builtins.int):
        pulumi.set(__self__, "max", max)
        pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> _builtins.int:
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> _builtins.int:
        return pulumi.get(self, "min")


@pulumi.output_type
class GetLaunchTemplateInstanceRequirementBaselineEbsBandwidthMbpResult(dict):
    def __init__(__self__, *,
                 max: _builtins.int,
                 min: _builtins.int):
        pulumi.set(__self__, "max", max)
        pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> _builtins.int:
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> _builtins.int:
        return pulumi.get(self, "min")


@pulumi.output_type
class GetLaunchTemplateInstanceRequirementMemoryGibPerVcpusResult(dict):
    def __init__(__self__, *,
                 max: _builtins.float,
                 min: _builtins.float):
        pulumi.set(__self__, "max", max)
        pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> _builtins.float:
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> _builtins.float:
        return pulumi.get(self, "min")


@pulumi.output_type
class GetLaunchTemplateInstanceRequirementMemoryMibResult(dict):
    def __init__(__self__, *,
                 max: _builtins.int,
                 min: _builtins.int):
        pulumi.set(__self__, "max", max)
        pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> _builtins.int:
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> _builtins.int:
        return pulumi.get(self, "min")


@pulumi.output_type
class GetLaunchTemplateInstanceRequirementNetworkBandwidthGbpResult(dict):
    def __init__(__self__, *,
                 max: _builtins.float,
                 min: _builtins.float):
        pulumi.set(__self__, "max", max)
        pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> _builtins.float:
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> _builtins.float:
        return pulumi.get(self, "min")


@pulumi.output_type
class GetLaunchTemplateInstanceRequirementNetworkInterfaceCountResult(dict):
    def __init__(__self__, *,
                 max: _builtins.int,
                 min: _builtins.int):
        pulumi.set(__self__, "max", max)
        pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> _builtins.int:
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> _builtins.int:
        return pulumi.get(self, "min")


@pulumi.output_type
class GetLaunchTemplateInstanceRequirementTotalLocalStorageGbResult(dict):
    def __init__(__self__, *,
                 max: _builtins.float,
                 min: _builtins.float):
        pulumi.set(__self__, "max", max)
        pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> _builtins.float:
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> _builtins.float:
        return pulumi.get(self, "min")


@pulumi.output_type
class GetLaunchTemplateInstanceRequirementVcpuCountResult(dict):
    def __init__(__self__, *,
                 max: _builtins.int,
                 min: _builtins.int):
        pulumi.set(__self__, "max", max)
        pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> _builtins.int:
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> _builtins.int:
        return pulumi.get(self, "min")


@pulumi.output_type
class GetLaunchTemplateLicenseSpecificationResult(dict):
    def __init__(__self__, *,
                 license_configuration_arn: _builtins.str):
        pulumi.set(__self__, "license_configuration_arn", license_configuration_arn)

    @_builtins.property
    @pulumi.getter(name="licenseConfigurationArn")
    def license_configuration_arn(self) -> _builtins.str:
        return pulumi.get(self, "license_configuration_arn")


@pulumi.output_type
class GetLaunchTemplateMaintenanceOptionResult(dict):
    def __init__(__self__, *,
                 auto_recovery: _builtins.str):
        pulumi.set(__self__, "auto_recovery", auto_recovery)

    @_builtins.property
    @pulumi.getter(name="autoRecovery")
    def auto_recovery(self) -> _builtins.str:
        return pulumi.get(self, "auto_recovery")


@pulumi.output_type
class GetLaunchTemplateMetadataOptionResult(dict):
    def __init__(__self__, *,
                 http_endpoint: _builtins.str,
                 http_protocol_ipv6: _builtins.str,
                 http_put_response_hop_limit: _builtins.int,
                 http_tokens: _builtins.str,
                 instance_metadata_tags: _builtins.str):
        pulumi.set(__self__, "http_endpoint", http_endpoint)
        pulumi.set(__self__, "http_protocol_ipv6", http_protocol_ipv6)
        pulumi.set(__self__, "http_put_response_hop_limit", http_put_response_hop_limit)
        pulumi.set(__self__, "http_tokens", http_tokens)
        pulumi.set(__self__, "instance_metadata_tags", instance_metadata_tags)

    @_builtins.property
    @pulumi.getter(name="httpEndpoint")
    def http_endpoint(self) -> _builtins.str:
        return pulumi.get(self, "http_endpoint")

    @_builtins.property
    @pulumi.getter(name="httpProtocolIpv6")
    def http_protocol_ipv6(self) -> _builtins.str:
        return pulumi.get(self, "http_protocol_ipv6")

    @_builtins.property
    @pulumi.getter(name="httpPutResponseHopLimit")
    def http_put_response_hop_limit(self) -> _builtins.int:
        return pulumi.get(self, "http_put_response_hop_limit")

    @_builtins.property
    @pulumi.getter(name="httpTokens")
    def http_tokens(self) -> _builtins.str:
        return pulumi.get(self, "http_tokens")

    @_builtins.property
    @pulumi.getter(name="instanceMetadataTags")
    def instance_metadata_tags(self) -> _builtins.str:
        return pulumi.get(self, "instance_metadata_tags")


@pulumi.output_type
class GetLaunchTemplateMonitoringResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool):
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetLaunchTemplateNetworkInterfaceResult(dict):
    def __init__(__self__, *,
                 associate_carrier_ip_address: _builtins.str,
                 connection_tracking_specifications: Sequence['outputs.GetLaunchTemplateNetworkInterfaceConnectionTrackingSpecificationResult'],
                 description: _builtins.str,
                 device_index: _builtins.int,
                 interface_type: _builtins.str,
                 ipv4_address_count: _builtins.int,
                 ipv4_addresses: Sequence[_builtins.str],
                 ipv4_prefix_count: _builtins.int,
                 ipv4_prefixes: Sequence[_builtins.str],
                 ipv6_address_count: _builtins.int,
                 ipv6_addresses: Sequence[_builtins.str],
                 ipv6_prefix_count: _builtins.int,
                 ipv6_prefixes: Sequence[_builtins.str],
                 network_card_index: _builtins.int,
                 network_interface_id: _builtins.str,
                 primary_ipv6: _builtins.str,
                 private_ip_address: _builtins.str,
                 security_groups: Sequence[_builtins.str],
                 subnet_id: _builtins.str,
                 associate_public_ip_address: Optional[_builtins.bool] = None,
                 delete_on_termination: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "associate_carrier_ip_address", associate_carrier_ip_address)
        pulumi.set(__self__, "connection_tracking_specifications", connection_tracking_specifications)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "device_index", device_index)
        pulumi.set(__self__, "interface_type", interface_type)
        pulumi.set(__self__, "ipv4_address_count", ipv4_address_count)
        pulumi.set(__self__, "ipv4_addresses", ipv4_addresses)
        pulumi.set(__self__, "ipv4_prefix_count", ipv4_prefix_count)
        pulumi.set(__self__, "ipv4_prefixes", ipv4_prefixes)
        pulumi.set(__self__, "ipv6_address_count", ipv6_address_count)
        pulumi.set(__self__, "ipv6_addresses", ipv6_addresses)
        pulumi.set(__self__, "ipv6_prefix_count", ipv6_prefix_count)
        pulumi.set(__self__, "ipv6_prefixes", ipv6_prefixes)
        pulumi.set(__self__, "network_card_index", network_card_index)
        pulumi.set(__self__, "network_interface_id", network_interface_id)
        pulumi.set(__self__, "primary_ipv6", primary_ipv6)
        pulumi.set(__self__, "private_ip_address", private_ip_address)
        pulumi.set(__self__, "security_groups", security_groups)
        pulumi.set(__self__, "subnet_id", subnet_id)
        if associate_public_ip_address is not None:
            pulumi.set(__self__, "associate_public_ip_address", associate_public_ip_address)
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)

    @_builtins.property
    @pulumi.getter(name="associateCarrierIpAddress")
    def associate_carrier_ip_address(self) -> _builtins.str:
        return pulumi.get(self, "associate_carrier_ip_address")

    @_builtins.property
    @pulumi.getter(name="connectionTrackingSpecifications")
    def connection_tracking_specifications(self) -> Sequence['outputs.GetLaunchTemplateNetworkInterfaceConnectionTrackingSpecificationResult']:
        return pulumi.get(self, "connection_tracking_specifications")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="deviceIndex")
    def device_index(self) -> _builtins.int:
        return pulumi.get(self, "device_index")

    @_builtins.property
    @pulumi.getter(name="interfaceType")
    def interface_type(self) -> _builtins.str:
        return pulumi.get(self, "interface_type")

    @_builtins.property
    @pulumi.getter(name="ipv4AddressCount")
    def ipv4_address_count(self) -> _builtins.int:
        return pulumi.get(self, "ipv4_address_count")

    @_builtins.property
    @pulumi.getter(name="ipv4Addresses")
    def ipv4_addresses(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "ipv4_addresses")

    @_builtins.property
    @pulumi.getter(name="ipv4PrefixCount")
    def ipv4_prefix_count(self) -> _builtins.int:
        return pulumi.get(self, "ipv4_prefix_count")

    @_builtins.property
    @pulumi.getter(name="ipv4Prefixes")
    def ipv4_prefixes(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "ipv4_prefixes")

    @_builtins.property
    @pulumi.getter(name="ipv6AddressCount")
    def ipv6_address_count(self) -> _builtins.int:
        return pulumi.get(self, "ipv6_address_count")

    @_builtins.property
    @pulumi.getter(name="ipv6Addresses")
    def ipv6_addresses(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "ipv6_addresses")

    @_builtins.property
    @pulumi.getter(name="ipv6PrefixCount")
    def ipv6_prefix_count(self) -> _builtins.int:
        return pulumi.get(self, "ipv6_prefix_count")

    @_builtins.property
    @pulumi.getter(name="ipv6Prefixes")
    def ipv6_prefixes(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "ipv6_prefixes")

    @_builtins.property
    @pulumi.getter(name="networkCardIndex")
    def network_card_index(self) -> _builtins.int:
        return pulumi.get(self, "network_card_index")

    @_builtins.property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> _builtins.str:
        return pulumi.get(self, "network_interface_id")

    @_builtins.property
    @pulumi.getter(name="primaryIpv6")
    def primary_ipv6(self) -> _builtins.str:
        return pulumi.get(self, "primary_ipv6")

    @_builtins.property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> _builtins.str:
        return pulumi.get(self, "private_ip_address")

    @_builtins.property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "security_groups")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter(name="associatePublicIpAddress")
    def associate_public_ip_address(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "associate_public_ip_address")

    @_builtins.property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "delete_on_termination")


@pulumi.output_type
class GetLaunchTemplateNetworkInterfaceConnectionTrackingSpecificationResult(dict):
    def __init__(__self__, *,
                 tcp_established_timeout: _builtins.int,
                 udp_stream_timeout: _builtins.int,
                 udp_timeout: _builtins.int):
        pulumi.set(__self__, "tcp_established_timeout", tcp_established_timeout)
        pulumi.set(__self__, "udp_stream_timeout", udp_stream_timeout)
        pulumi.set(__self__, "udp_timeout", udp_timeout)

    @_builtins.property
    @pulumi.getter(name="tcpEstablishedTimeout")
    def tcp_established_timeout(self) -> _builtins.int:
        return pulumi.get(self, "tcp_established_timeout")

    @_builtins.property
    @pulumi.getter(name="udpStreamTimeout")
    def udp_stream_timeout(self) -> _builtins.int:
        return pulumi.get(self, "udp_stream_timeout")

    @_builtins.property
    @pulumi.getter(name="udpTimeout")
    def udp_timeout(self) -> _builtins.int:
        return pulumi.get(self, "udp_timeout")


@pulumi.output_type
class GetLaunchTemplatePlacementResult(dict):
    def __init__(__self__, *,
                 affinity: _builtins.str,
                 availability_zone: _builtins.str,
                 group_id: _builtins.str,
                 group_name: _builtins.str,
                 host_id: _builtins.str,
                 host_resource_group_arn: _builtins.str,
                 partition_number: _builtins.int,
                 spread_domain: _builtins.str,
                 tenancy: _builtins.str):
        pulumi.set(__self__, "affinity", affinity)
        pulumi.set(__self__, "availability_zone", availability_zone)
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "group_name", group_name)
        pulumi.set(__self__, "host_id", host_id)
        pulumi.set(__self__, "host_resource_group_arn", host_resource_group_arn)
        pulumi.set(__self__, "partition_number", partition_number)
        pulumi.set(__self__, "spread_domain", spread_domain)
        pulumi.set(__self__, "tenancy", tenancy)

    @_builtins.property
    @pulumi.getter
    def affinity(self) -> _builtins.str:
        return pulumi.get(self, "affinity")

    @_builtins.property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> _builtins.str:
        return pulumi.get(self, "availability_zone")

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> _builtins.str:
        return pulumi.get(self, "group_id")

    @_builtins.property
    @pulumi.getter(name="groupName")
    def group_name(self) -> _builtins.str:
        return pulumi.get(self, "group_name")

    @_builtins.property
    @pulumi.getter(name="hostId")
    def host_id(self) -> _builtins.str:
        return pulumi.get(self, "host_id")

    @_builtins.property
    @pulumi.getter(name="hostResourceGroupArn")
    def host_resource_group_arn(self) -> _builtins.str:
        return pulumi.get(self, "host_resource_group_arn")

    @_builtins.property
    @pulumi.getter(name="partitionNumber")
    def partition_number(self) -> _builtins.int:
        return pulumi.get(self, "partition_number")

    @_builtins.property
    @pulumi.getter(name="spreadDomain")
    def spread_domain(self) -> _builtins.str:
        return pulumi.get(self, "spread_domain")

    @_builtins.property
    @pulumi.getter
    def tenancy(self) -> _builtins.str:
        return pulumi.get(self, "tenancy")


@pulumi.output_type
class GetLaunchTemplatePrivateDnsNameOptionResult(dict):
    def __init__(__self__, *,
                 enable_resource_name_dns_a_record: _builtins.bool,
                 enable_resource_name_dns_aaaa_record: _builtins.bool,
                 hostname_type: _builtins.str):
        pulumi.set(__self__, "enable_resource_name_dns_a_record", enable_resource_name_dns_a_record)
        pulumi.set(__self__, "enable_resource_name_dns_aaaa_record", enable_resource_name_dns_aaaa_record)
        pulumi.set(__self__, "hostname_type", hostname_type)

    @_builtins.property
    @pulumi.getter(name="enableResourceNameDnsARecord")
    def enable_resource_name_dns_a_record(self) -> _builtins.bool:
        return pulumi.get(self, "enable_resource_name_dns_a_record")

    @_builtins.property
    @pulumi.getter(name="enableResourceNameDnsAaaaRecord")
    def enable_resource_name_dns_aaaa_record(self) -> _builtins.bool:
        return pulumi.get(self, "enable_resource_name_dns_aaaa_record")

    @_builtins.property
    @pulumi.getter(name="hostnameType")
    def hostname_type(self) -> _builtins.str:
        return pulumi.get(self, "hostname_type")


@pulumi.output_type
class GetLaunchTemplateTagSpecificationResult(dict):
    def __init__(__self__, *,
                 resource_type: _builtins.str,
                 tags: Mapping[str, _builtins.str]):
        pulumi.set(__self__, "resource_type", resource_type)
        pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> _builtins.str:
        return pulumi.get(self, "resource_type")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetLocalGatewayFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetLocalGatewayRouteTableFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetLocalGatewayRouteTablesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetLocalGatewayVirtualInterfaceFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetLocalGatewayVirtualInterfaceGroupFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetLocalGatewayVirtualInterfaceGroupsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetLocalGatewaysFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetManagedPrefixListEntryResult(dict):
    def __init__(__self__, *,
                 cidr: _builtins.str,
                 description: _builtins.str):
        pulumi.set(__self__, "cidr", cidr)
        pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def cidr(self) -> _builtins.str:
        return pulumi.get(self, "cidr")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        return pulumi.get(self, "description")


@pulumi.output_type
class GetManagedPrefixListFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetManagedPrefixListsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetNatGatewayAvailabilityZoneAddressResult(dict):
    def __init__(__self__, *,
                 allocation_ids: Sequence[_builtins.str],
                 availability_zone: _builtins.str,
                 availability_zone_id: _builtins.str):
        pulumi.set(__self__, "allocation_ids", allocation_ids)
        pulumi.set(__self__, "availability_zone", availability_zone)
        pulumi.set(__self__, "availability_zone_id", availability_zone_id)

    @_builtins.property
    @pulumi.getter(name="allocationIds")
    def allocation_ids(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "allocation_ids")

    @_builtins.property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> _builtins.str:
        return pulumi.get(self, "availability_zone")

    @_builtins.property
    @pulumi.getter(name="availabilityZoneId")
    def availability_zone_id(self) -> _builtins.str:
        return pulumi.get(self, "availability_zone_id")


@pulumi.output_type
class GetNatGatewayFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetNatGatewayRegionalNatGatewayAddressResult(dict):
    def __init__(__self__, *,
                 allocation_id: _builtins.str,
                 association_id: _builtins.str,
                 availability_zone: _builtins.str,
                 availability_zone_id: _builtins.str,
                 network_interface_id: _builtins.str,
                 public_ip: _builtins.str,
                 status: _builtins.str):
        pulumi.set(__self__, "allocation_id", allocation_id)
        pulumi.set(__self__, "association_id", association_id)
        pulumi.set(__self__, "availability_zone", availability_zone)
        pulumi.set(__self__, "availability_zone_id", availability_zone_id)
        pulumi.set(__self__, "network_interface_id", network_interface_id)
        pulumi.set(__self__, "public_ip", public_ip)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="allocationId")
    def allocation_id(self) -> _builtins.str:
        return pulumi.get(self, "allocation_id")

    @_builtins.property
    @pulumi.getter(name="associationId")
    def association_id(self) -> _builtins.str:
        return pulumi.get(self, "association_id")

    @_builtins.property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> _builtins.str:
        return pulumi.get(self, "availability_zone")

    @_builtins.property
    @pulumi.getter(name="availabilityZoneId")
    def availability_zone_id(self) -> _builtins.str:
        return pulumi.get(self, "availability_zone_id")

    @_builtins.property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> _builtins.str:
        return pulumi.get(self, "network_interface_id")

    @_builtins.property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> _builtins.str:
        return pulumi.get(self, "public_ip")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        return pulumi.get(self, "status")


@pulumi.output_type
class GetNatGatewaysFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetNetworkAclsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetNetworkInsightsAnalysisAlternatePathHintResult(dict):
    def __init__(__self__, *,
                 component_arn: _builtins.str,
                 component_id: _builtins.str):
        pulumi.set(__self__, "component_arn", component_arn)
        pulumi.set(__self__, "component_id", component_id)

    @_builtins.property
    @pulumi.getter(name="componentArn")
    def component_arn(self) -> _builtins.str:
        return pulumi.get(self, "component_arn")

    @_builtins.property
    @pulumi.getter(name="componentId")
    def component_id(self) -> _builtins.str:
        return pulumi.get(self, "component_id")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationResult(dict):
    def __init__(__self__, *,
                 acl_rules: Sequence['outputs.GetNetworkInsightsAnalysisExplanationAclRuleResult'],
                 acls: Sequence['outputs.GetNetworkInsightsAnalysisExplanationAclResult'],
                 address: _builtins.str,
                 addresses: Sequence[_builtins.str],
                 attached_tos: Sequence['outputs.GetNetworkInsightsAnalysisExplanationAttachedToResult'],
                 availability_zones: Sequence[_builtins.str],
                 cidrs: Sequence[_builtins.str],
                 classic_load_balancer_listeners: Sequence['outputs.GetNetworkInsightsAnalysisExplanationClassicLoadBalancerListenerResult'],
                 components: Sequence['outputs.GetNetworkInsightsAnalysisExplanationComponentResult'],
                 customer_gateways: Sequence['outputs.GetNetworkInsightsAnalysisExplanationCustomerGatewayResult'],
                 destination_vpcs: Sequence['outputs.GetNetworkInsightsAnalysisExplanationDestinationVpcResult'],
                 destinations: Sequence['outputs.GetNetworkInsightsAnalysisExplanationDestinationResult'],
                 direction: _builtins.str,
                 elastic_load_balancer_listeners: Sequence['outputs.GetNetworkInsightsAnalysisExplanationElasticLoadBalancerListenerResult'],
                 explanation_code: _builtins.str,
                 ingress_route_tables: Sequence['outputs.GetNetworkInsightsAnalysisExplanationIngressRouteTableResult'],
                 internet_gateways: Sequence['outputs.GetNetworkInsightsAnalysisExplanationInternetGatewayResult'],
                 load_balancer_arn: _builtins.str,
                 load_balancer_listener_port: _builtins.int,
                 load_balancer_target_group: Sequence['outputs.GetNetworkInsightsAnalysisExplanationLoadBalancerTargetGroupResult'],
                 load_balancer_target_groups: Sequence['outputs.GetNetworkInsightsAnalysisExplanationLoadBalancerTargetGroupResult'],
                 load_balancer_target_port: _builtins.int,
                 missing_component: _builtins.str,
                 nat_gateways: Sequence['outputs.GetNetworkInsightsAnalysisExplanationNatGatewayResult'],
                 network_interfaces: Sequence['outputs.GetNetworkInsightsAnalysisExplanationNetworkInterfaceResult'],
                 packet_field: _builtins.str,
                 port: _builtins.int,
                 port_ranges: Sequence['outputs.GetNetworkInsightsAnalysisExplanationPortRangeResult'],
                 prefix_lists: Sequence['outputs.GetNetworkInsightsAnalysisExplanationPrefixListResult'],
                 protocols: Sequence[_builtins.str],
                 route_table_routes: Sequence['outputs.GetNetworkInsightsAnalysisExplanationRouteTableRouteResult'],
                 route_tables: Sequence['outputs.GetNetworkInsightsAnalysisExplanationRouteTableResult'],
                 security_group: Sequence['outputs.GetNetworkInsightsAnalysisExplanationSecurityGroupResult'],
                 security_group_rules: Sequence['outputs.GetNetworkInsightsAnalysisExplanationSecurityGroupRuleResult'],
                 security_groups: Sequence['outputs.GetNetworkInsightsAnalysisExplanationSecurityGroupResult'],
                 source_vpcs: Sequence['outputs.GetNetworkInsightsAnalysisExplanationSourceVpcResult'],
                 state: _builtins.str,
                 subnet_route_tables: Sequence['outputs.GetNetworkInsightsAnalysisExplanationSubnetRouteTableResult'],
                 subnets: Sequence['outputs.GetNetworkInsightsAnalysisExplanationSubnetResult'],
                 transit_gateway_attachments: Sequence['outputs.GetNetworkInsightsAnalysisExplanationTransitGatewayAttachmentResult'],
                 transit_gateway_route_table_routes: Sequence['outputs.GetNetworkInsightsAnalysisExplanationTransitGatewayRouteTableRouteResult'],
                 transit_gateway_route_tables: Sequence['outputs.GetNetworkInsightsAnalysisExplanationTransitGatewayRouteTableResult'],
                 transit_gateways: Sequence['outputs.GetNetworkInsightsAnalysisExplanationTransitGatewayResult'],
                 vpc_endpoints: Sequence['outputs.GetNetworkInsightsAnalysisExplanationVpcEndpointResult'],
                 vpc_peering_connections: Sequence['outputs.GetNetworkInsightsAnalysisExplanationVpcPeeringConnectionResult'],
                 vpcs: Sequence['outputs.GetNetworkInsightsAnalysisExplanationVpcResult'],
                 vpn_connections: Sequence['outputs.GetNetworkInsightsAnalysisExplanationVpnConnectionResult'],
                 vpn_gateways: Sequence['outputs.GetNetworkInsightsAnalysisExplanationVpnGatewayResult']):
        pulumi.set(__self__, "acl_rules", acl_rules)
        pulumi.set(__self__, "acls", acls)
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "addresses", addresses)
        pulumi.set(__self__, "attached_tos", attached_tos)
        pulumi.set(__self__, "availability_zones", availability_zones)
        pulumi.set(__self__, "cidrs", cidrs)
        pulumi.set(__self__, "classic_load_balancer_listeners", classic_load_balancer_listeners)
        pulumi.set(__self__, "components", components)
        pulumi.set(__self__, "customer_gateways", customer_gateways)
        pulumi.set(__self__, "destination_vpcs", destination_vpcs)
        pulumi.set(__self__, "destinations", destinations)
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "elastic_load_balancer_listeners", elastic_load_balancer_listeners)
        pulumi.set(__self__, "explanation_code", explanation_code)
        pulumi.set(__self__, "ingress_route_tables", ingress_route_tables)
        pulumi.set(__self__, "internet_gateways", internet_gateways)
        pulumi.set(__self__, "load_balancer_arn", load_balancer_arn)
        pulumi.set(__self__, "load_balancer_listener_port", load_balancer_listener_port)
        pulumi.set(__self__, "load_balancer_target_group", load_balancer_target_group)
        pulumi.set(__self__, "load_balancer_target_groups", load_balancer_target_groups)
        pulumi.set(__self__, "load_balancer_target_port", load_balancer_target_port)
        pulumi.set(__self__, "missing_component", missing_component)
        pulumi.set(__self__, "nat_gateways", nat_gateways)
        pulumi.set(__self__, "network_interfaces", network_interfaces)
        pulumi.set(__self__, "packet_field", packet_field)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "port_ranges", port_ranges)
        pulumi.set(__self__, "prefix_lists", prefix_lists)
        pulumi.set(__self__, "protocols", protocols)
        pulumi.set(__self__, "route_table_routes", route_table_routes)
        pulumi.set(__self__, "route_tables", route_tables)
        pulumi.set(__self__, "security_group", security_group)
        pulumi.set(__self__, "security_group_rules", security_group_rules)
        pulumi.set(__self__, "security_groups", security_groups)
        pulumi.set(__self__, "source_vpcs", source_vpcs)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "subnet_route_tables", subnet_route_tables)
        pulumi.set(__self__, "subnets", subnets)
        pulumi.set(__self__, "transit_gateway_attachments", transit_gateway_attachments)
        pulumi.set(__self__, "transit_gateway_route_table_routes", transit_gateway_route_table_routes)
        pulumi.set(__self__, "transit_gateway_route_tables", transit_gateway_route_tables)
        pulumi.set(__self__, "transit_gateways", transit_gateways)
        pulumi.set(__self__, "vpc_endpoints", vpc_endpoints)
        pulumi.set(__self__, "vpc_peering_connections", vpc_peering_connections)
        pulumi.set(__self__, "vpcs", vpcs)
        pulumi.set(__self__, "vpn_connections", vpn_connections)
        pulumi.set(__self__, "vpn_gateways", vpn_gateways)

    @_builtins.property
    @pulumi.getter(name="aclRules")
    def acl_rules(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationAclRuleResult']:
        return pulumi.get(self, "acl_rules")

    @_builtins.property
    @pulumi.getter
    def acls(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationAclResult']:
        return pulumi.get(self, "acls")

    @_builtins.property
    @pulumi.getter
    def address(self) -> _builtins.str:
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def addresses(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "addresses")

    @_builtins.property
    @pulumi.getter(name="attachedTos")
    def attached_tos(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationAttachedToResult']:
        return pulumi.get(self, "attached_tos")

    @_builtins.property
    @pulumi.getter(name="availabilityZones")
    def availability_zones(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "availability_zones")

    @_builtins.property
    @pulumi.getter
    def cidrs(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "cidrs")

    @_builtins.property
    @pulumi.getter(name="classicLoadBalancerListeners")
    def classic_load_balancer_listeners(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationClassicLoadBalancerListenerResult']:
        return pulumi.get(self, "classic_load_balancer_listeners")

    @_builtins.property
    @pulumi.getter
    def components(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationComponentResult']:
        return pulumi.get(self, "components")

    @_builtins.property
    @pulumi.getter(name="customerGateways")
    def customer_gateways(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationCustomerGatewayResult']:
        return pulumi.get(self, "customer_gateways")

    @_builtins.property
    @pulumi.getter(name="destinationVpcs")
    def destination_vpcs(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationDestinationVpcResult']:
        return pulumi.get(self, "destination_vpcs")

    @_builtins.property
    @pulumi.getter
    def destinations(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationDestinationResult']:
        return pulumi.get(self, "destinations")

    @_builtins.property
    @pulumi.getter
    def direction(self) -> _builtins.str:
        return pulumi.get(self, "direction")

    @_builtins.property
    @pulumi.getter(name="elasticLoadBalancerListeners")
    def elastic_load_balancer_listeners(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationElasticLoadBalancerListenerResult']:
        return pulumi.get(self, "elastic_load_balancer_listeners")

    @_builtins.property
    @pulumi.getter(name="explanationCode")
    def explanation_code(self) -> _builtins.str:
        return pulumi.get(self, "explanation_code")

    @_builtins.property
    @pulumi.getter(name="ingressRouteTables")
    def ingress_route_tables(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationIngressRouteTableResult']:
        return pulumi.get(self, "ingress_route_tables")

    @_builtins.property
    @pulumi.getter(name="internetGateways")
    def internet_gateways(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationInternetGatewayResult']:
        return pulumi.get(self, "internet_gateways")

    @_builtins.property
    @pulumi.getter(name="loadBalancerArn")
    def load_balancer_arn(self) -> _builtins.str:
        return pulumi.get(self, "load_balancer_arn")

    @_builtins.property
    @pulumi.getter(name="loadBalancerListenerPort")
    def load_balancer_listener_port(self) -> _builtins.int:
        return pulumi.get(self, "load_balancer_listener_port")

    @_builtins.property
    @pulumi.getter(name="loadBalancerTargetGroup")
    def load_balancer_target_group(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationLoadBalancerTargetGroupResult']:
        return pulumi.get(self, "load_balancer_target_group")

    @_builtins.property
    @pulumi.getter(name="loadBalancerTargetGroups")
    def load_balancer_target_groups(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationLoadBalancerTargetGroupResult']:
        return pulumi.get(self, "load_balancer_target_groups")

    @_builtins.property
    @pulumi.getter(name="loadBalancerTargetPort")
    def load_balancer_target_port(self) -> _builtins.int:
        return pulumi.get(self, "load_balancer_target_port")

    @_builtins.property
    @pulumi.getter(name="missingComponent")
    def missing_component(self) -> _builtins.str:
        return pulumi.get(self, "missing_component")

    @_builtins.property
    @pulumi.getter(name="natGateways")
    def nat_gateways(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationNatGatewayResult']:
        return pulumi.get(self, "nat_gateways")

    @_builtins.property
    @pulumi.getter(name="networkInterfaces")
    def network_interfaces(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationNetworkInterfaceResult']:
        return pulumi.get(self, "network_interfaces")

    @_builtins.property
    @pulumi.getter(name="packetField")
    def packet_field(self) -> _builtins.str:
        return pulumi.get(self, "packet_field")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationPortRangeResult']:
        return pulumi.get(self, "port_ranges")

    @_builtins.property
    @pulumi.getter(name="prefixLists")
    def prefix_lists(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationPrefixListResult']:
        return pulumi.get(self, "prefix_lists")

    @_builtins.property
    @pulumi.getter
    def protocols(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "protocols")

    @_builtins.property
    @pulumi.getter(name="routeTableRoutes")
    def route_table_routes(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationRouteTableRouteResult']:
        return pulumi.get(self, "route_table_routes")

    @_builtins.property
    @pulumi.getter(name="routeTables")
    def route_tables(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationRouteTableResult']:
        return pulumi.get(self, "route_tables")

    @_builtins.property
    @pulumi.getter(name="securityGroup")
    def security_group(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationSecurityGroupResult']:
        return pulumi.get(self, "security_group")

    @_builtins.property
    @pulumi.getter(name="securityGroupRules")
    def security_group_rules(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationSecurityGroupRuleResult']:
        return pulumi.get(self, "security_group_rules")

    @_builtins.property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationSecurityGroupResult']:
        return pulumi.get(self, "security_groups")

    @_builtins.property
    @pulumi.getter(name="sourceVpcs")
    def source_vpcs(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationSourceVpcResult']:
        return pulumi.get(self, "source_vpcs")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="subnetRouteTables")
    def subnet_route_tables(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationSubnetRouteTableResult']:
        return pulumi.get(self, "subnet_route_tables")

    @_builtins.property
    @pulumi.getter
    def subnets(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationSubnetResult']:
        return pulumi.get(self, "subnets")

    @_builtins.property
    @pulumi.getter(name="transitGatewayAttachments")
    def transit_gateway_attachments(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationTransitGatewayAttachmentResult']:
        return pulumi.get(self, "transit_gateway_attachments")

    @_builtins.property
    @pulumi.getter(name="transitGatewayRouteTableRoutes")
    def transit_gateway_route_table_routes(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationTransitGatewayRouteTableRouteResult']:
        return pulumi.get(self, "transit_gateway_route_table_routes")

    @_builtins.property
    @pulumi.getter(name="transitGatewayRouteTables")
    def transit_gateway_route_tables(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationTransitGatewayRouteTableResult']:
        return pulumi.get(self, "transit_gateway_route_tables")

    @_builtins.property
    @pulumi.getter(name="transitGateways")
    def transit_gateways(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationTransitGatewayResult']:
        return pulumi.get(self, "transit_gateways")

    @_builtins.property
    @pulumi.getter(name="vpcEndpoints")
    def vpc_endpoints(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationVpcEndpointResult']:
        return pulumi.get(self, "vpc_endpoints")

    @_builtins.property
    @pulumi.getter(name="vpcPeeringConnections")
    def vpc_peering_connections(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationVpcPeeringConnectionResult']:
        return pulumi.get(self, "vpc_peering_connections")

    @_builtins.property
    @pulumi.getter
    def vpcs(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationVpcResult']:
        return pulumi.get(self, "vpcs")

    @_builtins.property
    @pulumi.getter(name="vpnConnections")
    def vpn_connections(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationVpnConnectionResult']:
        return pulumi.get(self, "vpn_connections")

    @_builtins.property
    @pulumi.getter(name="vpnGateways")
    def vpn_gateways(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationVpnGatewayResult']:
        return pulumi.get(self, "vpn_gateways")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationAclResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationAclRuleResult(dict):
    def __init__(__self__, *,
                 cidr: _builtins.str,
                 egress: _builtins.bool,
                 port_ranges: Sequence['outputs.GetNetworkInsightsAnalysisExplanationAclRulePortRangeResult'],
                 protocol: _builtins.str,
                 rule_action: _builtins.str,
                 rule_number: _builtins.int):
        pulumi.set(__self__, "cidr", cidr)
        pulumi.set(__self__, "egress", egress)
        pulumi.set(__self__, "port_ranges", port_ranges)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "rule_action", rule_action)
        pulumi.set(__self__, "rule_number", rule_number)

    @_builtins.property
    @pulumi.getter
    def cidr(self) -> _builtins.str:
        return pulumi.get(self, "cidr")

    @_builtins.property
    @pulumi.getter
    def egress(self) -> _builtins.bool:
        return pulumi.get(self, "egress")

    @_builtins.property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationAclRulePortRangeResult']:
        return pulumi.get(self, "port_ranges")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="ruleAction")
    def rule_action(self) -> _builtins.str:
        return pulumi.get(self, "rule_action")

    @_builtins.property
    @pulumi.getter(name="ruleNumber")
    def rule_number(self) -> _builtins.int:
        return pulumi.get(self, "rule_number")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationAclRulePortRangeResult(dict):
    def __init__(__self__, *,
                 from_: _builtins.int,
                 to: _builtins.int):
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> _builtins.int:
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> _builtins.int:
        return pulumi.get(self, "to")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationAttachedToResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationClassicLoadBalancerListenerResult(dict):
    def __init__(__self__, *,
                 instance_port: _builtins.int,
                 load_balancer_port: _builtins.int):
        pulumi.set(__self__, "instance_port", instance_port)
        pulumi.set(__self__, "load_balancer_port", load_balancer_port)

    @_builtins.property
    @pulumi.getter(name="instancePort")
    def instance_port(self) -> _builtins.int:
        return pulumi.get(self, "instance_port")

    @_builtins.property
    @pulumi.getter(name="loadBalancerPort")
    def load_balancer_port(self) -> _builtins.int:
        return pulumi.get(self, "load_balancer_port")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationComponentResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationCustomerGatewayResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationDestinationResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationDestinationVpcResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationElasticLoadBalancerListenerResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationIngressRouteTableResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationInternetGatewayResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationLoadBalancerTargetGroupResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationNatGatewayResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationNetworkInterfaceResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationPortRangeResult(dict):
    def __init__(__self__, *,
                 from_: _builtins.int,
                 to: _builtins.int):
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> _builtins.int:
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> _builtins.int:
        return pulumi.get(self, "to")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationPrefixListResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationRouteTableResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationRouteTableRouteResult(dict):
    def __init__(__self__, *,
                 destination_cidr: _builtins.str,
                 destination_prefix_list_id: _builtins.str,
                 egress_only_internet_gateway_id: _builtins.str,
                 gateway_id: _builtins.str,
                 instance_id: _builtins.str,
                 nat_gateway_id: _builtins.str,
                 network_interface_id: _builtins.str,
                 origin: _builtins.str,
                 transit_gateway_id: _builtins.str,
                 vpc_peering_connection_id: _builtins.str):
        pulumi.set(__self__, "destination_cidr", destination_cidr)
        pulumi.set(__self__, "destination_prefix_list_id", destination_prefix_list_id)
        pulumi.set(__self__, "egress_only_internet_gateway_id", egress_only_internet_gateway_id)
        pulumi.set(__self__, "gateway_id", gateway_id)
        pulumi.set(__self__, "instance_id", instance_id)
        pulumi.set(__self__, "nat_gateway_id", nat_gateway_id)
        pulumi.set(__self__, "network_interface_id", network_interface_id)
        pulumi.set(__self__, "origin", origin)
        pulumi.set(__self__, "transit_gateway_id", transit_gateway_id)
        pulumi.set(__self__, "vpc_peering_connection_id", vpc_peering_connection_id)

    @_builtins.property
    @pulumi.getter(name="destinationCidr")
    def destination_cidr(self) -> _builtins.str:
        return pulumi.get(self, "destination_cidr")

    @_builtins.property
    @pulumi.getter(name="destinationPrefixListId")
    def destination_prefix_list_id(self) -> _builtins.str:
        return pulumi.get(self, "destination_prefix_list_id")

    @_builtins.property
    @pulumi.getter(name="egressOnlyInternetGatewayId")
    def egress_only_internet_gateway_id(self) -> _builtins.str:
        return pulumi.get(self, "egress_only_internet_gateway_id")

    @_builtins.property
    @pulumi.getter(name="gatewayId")
    def gateway_id(self) -> _builtins.str:
        return pulumi.get(self, "gateway_id")

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> _builtins.str:
        return pulumi.get(self, "instance_id")

    @_builtins.property
    @pulumi.getter(name="natGatewayId")
    def nat_gateway_id(self) -> _builtins.str:
        return pulumi.get(self, "nat_gateway_id")

    @_builtins.property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> _builtins.str:
        return pulumi.get(self, "network_interface_id")

    @_builtins.property
    @pulumi.getter
    def origin(self) -> _builtins.str:
        return pulumi.get(self, "origin")

    @_builtins.property
    @pulumi.getter(name="transitGatewayId")
    def transit_gateway_id(self) -> _builtins.str:
        return pulumi.get(self, "transit_gateway_id")

    @_builtins.property
    @pulumi.getter(name="vpcPeeringConnectionId")
    def vpc_peering_connection_id(self) -> _builtins.str:
        return pulumi.get(self, "vpc_peering_connection_id")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationSecurityGroupResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationSecurityGroupRuleResult(dict):
    def __init__(__self__, *,
                 cidr: _builtins.str,
                 direction: _builtins.str,
                 port_ranges: Sequence['outputs.GetNetworkInsightsAnalysisExplanationSecurityGroupRulePortRangeResult'],
                 prefix_list_id: _builtins.str,
                 protocol: _builtins.str,
                 security_group_id: _builtins.str):
        pulumi.set(__self__, "cidr", cidr)
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "port_ranges", port_ranges)
        pulumi.set(__self__, "prefix_list_id", prefix_list_id)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "security_group_id", security_group_id)

    @_builtins.property
    @pulumi.getter
    def cidr(self) -> _builtins.str:
        return pulumi.get(self, "cidr")

    @_builtins.property
    @pulumi.getter
    def direction(self) -> _builtins.str:
        return pulumi.get(self, "direction")

    @_builtins.property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Sequence['outputs.GetNetworkInsightsAnalysisExplanationSecurityGroupRulePortRangeResult']:
        return pulumi.get(self, "port_ranges")

    @_builtins.property
    @pulumi.getter(name="prefixListId")
    def prefix_list_id(self) -> _builtins.str:
        return pulumi.get(self, "prefix_list_id")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> _builtins.str:
        return pulumi.get(self, "security_group_id")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationSecurityGroupRulePortRangeResult(dict):
    def __init__(__self__, *,
                 from_: _builtins.int,
                 to: _builtins.int):
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> _builtins.int:
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> _builtins.int:
        return pulumi.get(self, "to")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationSourceVpcResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationSubnetResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationSubnetRouteTableResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationTransitGatewayResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationTransitGatewayAttachmentResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationTransitGatewayRouteTableResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationTransitGatewayRouteTableRouteResult(dict):
    def __init__(__self__, *,
                 attachment_id: _builtins.str,
                 destination_cidr: _builtins.str,
                 prefix_list_id: _builtins.str,
                 resource_id: _builtins.str,
                 resource_type: _builtins.str,
                 route_origin: _builtins.str,
                 state: _builtins.str):
        pulumi.set(__self__, "attachment_id", attachment_id)
        pulumi.set(__self__, "destination_cidr", destination_cidr)
        pulumi.set(__self__, "prefix_list_id", prefix_list_id)
        pulumi.set(__self__, "resource_id", resource_id)
        pulumi.set(__self__, "resource_type", resource_type)
        pulumi.set(__self__, "route_origin", route_origin)
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="attachmentId")
    def attachment_id(self) -> _builtins.str:
        return pulumi.get(self, "attachment_id")

    @_builtins.property
    @pulumi.getter(name="destinationCidr")
    def destination_cidr(self) -> _builtins.str:
        return pulumi.get(self, "destination_cidr")

    @_builtins.property
    @pulumi.getter(name="prefixListId")
    def prefix_list_id(self) -> _builtins.str:
        return pulumi.get(self, "prefix_list_id")

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> _builtins.str:
        return pulumi.get(self, "resource_id")

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> _builtins.str:
        return pulumi.get(self, "resource_type")

    @_builtins.property
    @pulumi.getter(name="routeOrigin")
    def route_origin(self) -> _builtins.str:
        return pulumi.get(self, "route_origin")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        return pulumi.get(self, "state")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationVpcResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationVpcEndpointResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationVpcPeeringConnectionResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationVpnConnectionResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisExplanationVpnGatewayResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetNetworkInsightsAnalysisForwardPathComponentResult(dict):
    def __init__(__self__, *,
                 acl_rules: Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentAclRuleResult'],
                 additional_details: Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentAdditionalDetailResult'],
                 attached_tos: Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentAttachedToResult'],
                 components: Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentComponentResult'],
                 destination_vpcs: Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentDestinationVpcResult'],
                 inbound_headers: Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentInboundHeaderResult'],
                 outbound_headers: Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentOutboundHeaderResult'],
                 route_table_routes: Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentRouteTableRouteResult'],
                 security_group_rules: Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentSecurityGroupRuleResult'],
                 sequence_number: _builtins.int,
                 source_vpcs: Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentSourceVpcResult'],
                 subnets: Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentSubnetResult'],
                 transit_gateway_route_table_routes: Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentTransitGatewayRouteTableRouteResult'],
                 transit_gateways: Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentTransitGatewayResult'],
                 vpcs: Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentVpcResult']):
        pulumi.set(__self__, "acl_rules", acl_rules)
        pulumi.set(__self__, "additional_details", additional_details)
        pulumi.set(__self__, "attached_tos", attached_tos)
        pulumi.set(__self__, "components", components)
        pulumi.set(__self__, "destination_vpcs", destination_vpcs)
        pulumi.set(__self__, "inbound_headers", inbound_headers)
        pulumi.set(__self__, "outbound_headers", outbound_headers)
        pulumi.set(__self__, "route_table_routes", route_table_routes)
        pulumi.set(__self__, "security_group_rules", security_group_rules)
        pulumi.set(__self__, "sequence_number", sequence_number)
        pulumi.set(__self__, "source_vpcs", source_vpcs)
        pulumi.set(__self__, "subnets", subnets)
        pulumi.set(__self__, "transit_gateway_route_table_routes", transit_gateway_route_table_routes)
        pulumi.set(__self__, "transit_gateways", transit_gateways)
        pulumi.set(__self__, "vpcs", vpcs)

    @_builtins.property
    @pulumi.getter(name="aclRules")
    def acl_rules(self) -> Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentAclRuleResult']:
        return pulumi.get(self, "acl_rules")

    @_builtins.property
    @pulumi.getter(name="additionalDetails")
    def additional_details(self) -> Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentAdditionalDetailResult']:
        return pulumi.get(self, "additional_details")

    @_builtins.property
    @pulumi.getter(name="attachedTos")
    def attached_tos(self) -> Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentAttachedToResult']:
        return pulumi.get(self, "attached_tos")

    @_builtins.property
    @pulumi.getter
    def components(self) -> Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentComponentResult']:
        return pulumi.get(self, "components")

    @_builtins.property
    @pulumi.getter(name="destinationVpcs")
    def destination_vpcs(self) -> Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentDestinationVpcResult']:
        return pulumi.get(self, "destination_vpcs")

    @_builtins.property
    @pulumi.getter(name="inboundHeaders")
    def inbound_headers(self) -> Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentInboundHeaderResult']:
        return pulumi.get(self, "inbound_headers")

    @_builtins.property
    @pulumi.getter(name="outboundHeaders")
    def outbound_headers(self) -> Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentOutboundHeaderResult']:
        return pulumi.get(self, "outbound_headers")

    @_builtins.property
    @pulumi.getter(name="routeTableRoutes")
    def route_table_routes(self) -> Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentRouteTableRouteResult']:
        return pulumi.get(self, "route_table_routes")

    @_builtins.property
    @pulumi.getter(name="securityGroupRules")
    def security_group_rules(self) -> Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentSecurityGroupRuleResult']:
        return pulumi.get(self, "security_group_rules")

    @_builtins.property
    @pulumi.getter(name="sequenceNumber")
    def sequence_number(self) -> _builtins.int:
        return pulumi.get(self, "sequence_number")

    @_builtins.property
    @pulumi.getter(name="sourceVpcs")
    def source_vpcs(self) -> Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentSourceVpcResult']:
        return pulumi.get(self, "source_vpcs")

    @_builtins.property
    @pulumi.getter
    def subnets(self) -> Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentSubnetResult']:
        return pulumi.get(self, "subnets")

    @_builtins.property
    @pulumi.getter(name="transitGatewayRouteTableRoutes")
    def transit_gateway_route_table_routes(self) -> Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentTransitGatewayRouteTableRouteResult']:
        return pulumi.get(self, "transit_gateway_route_table_routes")

    @_builtins.property
    @pulumi.getter(name="transitGateways")
    def transit_gateways(self) -> Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentTransitGatewayResult']:
        return pulumi.get(self, "transit_gateways")

    @_builtins.property
    @pulumi.getter
    def vpcs(self) -> Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentVpcResult']:
        return pulumi.get(self, "vpcs")


@pulumi.output_type
class GetNetworkInsightsAnalysisForwardPathComponentAclRuleResult(dict):
    def __init__(__self__, *,
                 cidr: _builtins.str,
                 egress: _builtins.bool,
                 port_ranges: Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentAclRulePortRangeResult'],
                 protocol: _builtins.str,
                 rule_action: _builtins.str,
                 rule_number: _builtins.int):
        pulumi.set(__self__, "cidr", cidr)
        pulumi.set(__self__, "egress", egress)
        pulumi.set(__self__, "port_ranges", port_ranges)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "rule_action", rule_action)
        pulumi.set(__self__, "rule_number", rule_number)

    @_builtins.property
    @pulumi.getter
    def cidr(self) -> _builtins.str:
        return pulumi.get(self, "cidr")

    @_builtins.property
    @pulumi.getter
    def egress(self) -> _builtins.bool:
        return pulumi.get(self, "egress")

    @_builtins.property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentAclRulePortRangeResult']:
        return pulumi.get(self, "port_ranges")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="ruleAction")
    def rule_action(self) -> _builtins.str:
        return pulumi.get(self, "rule_action")

    @_builtins.property
    @pulumi.getter(name="ruleNumber")
    def rule_number(self) -> _builtins.int:
        return pulumi.get(self, "rule_number")


@pulumi.output_type
class GetNetworkInsightsAnalysisForwardPathComponentAclRulePortRangeResult(dict):
    def __init__(__self__, *,
                 from_: _builtins.int,
                 to: _builtins.int):
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> _builtins.int:
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> _builtins.int:
        return pulumi.get(self, "to")


@pulumi.output_type
class GetNetworkInsightsAnalysisForwardPathComponentAdditionalDetailResult(dict):
    def __init__(__self__, *,
                 additional_detail_type: _builtins.str,
                 components: Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentAdditionalDetailComponentResult']):
        pulumi.set(__self__, "additional_detail_type", additional_detail_type)
        pulumi.set(__self__, "components", components)

    @_builtins.property
    @pulumi.getter(name="additionalDetailType")
    def additional_detail_type(self) -> _builtins.str:
        return pulumi.get(self, "additional_detail_type")

    @_builtins.property
    @pulumi.getter
    def components(self) -> Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentAdditionalDetailComponentResult']:
        return pulumi.get(self, "components")


@pulumi.output_type
class GetNetworkInsightsAnalysisForwardPathComponentAdditionalDetailComponentResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisForwardPathComponentAttachedToResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisForwardPathComponentComponentResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisForwardPathComponentDestinationVpcResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisForwardPathComponentInboundHeaderResult(dict):
    def __init__(__self__, *,
                 destination_addresses: Sequence[_builtins.str],
                 destination_port_ranges: Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentInboundHeaderDestinationPortRangeResult'],
                 protocol: _builtins.str,
                 source_addresses: Sequence[_builtins.str],
                 source_port_ranges: Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentInboundHeaderSourcePortRangeResult']):
        pulumi.set(__self__, "destination_addresses", destination_addresses)
        pulumi.set(__self__, "destination_port_ranges", destination_port_ranges)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "source_addresses", source_addresses)
        pulumi.set(__self__, "source_port_ranges", source_port_ranges)

    @_builtins.property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "destination_addresses")

    @_builtins.property
    @pulumi.getter(name="destinationPortRanges")
    def destination_port_ranges(self) -> Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentInboundHeaderDestinationPortRangeResult']:
        return pulumi.get(self, "destination_port_ranges")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "source_addresses")

    @_builtins.property
    @pulumi.getter(name="sourcePortRanges")
    def source_port_ranges(self) -> Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentInboundHeaderSourcePortRangeResult']:
        return pulumi.get(self, "source_port_ranges")


@pulumi.output_type
class GetNetworkInsightsAnalysisForwardPathComponentInboundHeaderDestinationPortRangeResult(dict):
    def __init__(__self__, *,
                 from_: _builtins.int,
                 to: _builtins.int):
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> _builtins.int:
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> _builtins.int:
        return pulumi.get(self, "to")


@pulumi.output_type
class GetNetworkInsightsAnalysisForwardPathComponentInboundHeaderSourcePortRangeResult(dict):
    def __init__(__self__, *,
                 from_: _builtins.int,
                 to: _builtins.int):
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> _builtins.int:
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> _builtins.int:
        return pulumi.get(self, "to")


@pulumi.output_type
class GetNetworkInsightsAnalysisForwardPathComponentOutboundHeaderResult(dict):
    def __init__(__self__, *,
                 destination_addresses: Sequence[_builtins.str],
                 destination_port_ranges: Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentOutboundHeaderDestinationPortRangeResult'],
                 protocol: _builtins.str,
                 source_addresses: Sequence[_builtins.str],
                 source_port_ranges: Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentOutboundHeaderSourcePortRangeResult']):
        pulumi.set(__self__, "destination_addresses", destination_addresses)
        pulumi.set(__self__, "destination_port_ranges", destination_port_ranges)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "source_addresses", source_addresses)
        pulumi.set(__self__, "source_port_ranges", source_port_ranges)

    @_builtins.property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "destination_addresses")

    @_builtins.property
    @pulumi.getter(name="destinationPortRanges")
    def destination_port_ranges(self) -> Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentOutboundHeaderDestinationPortRangeResult']:
        return pulumi.get(self, "destination_port_ranges")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "source_addresses")

    @_builtins.property
    @pulumi.getter(name="sourcePortRanges")
    def source_port_ranges(self) -> Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentOutboundHeaderSourcePortRangeResult']:
        return pulumi.get(self, "source_port_ranges")


@pulumi.output_type
class GetNetworkInsightsAnalysisForwardPathComponentOutboundHeaderDestinationPortRangeResult(dict):
    def __init__(__self__, *,
                 from_: _builtins.int,
                 to: _builtins.int):
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> _builtins.int:
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> _builtins.int:
        return pulumi.get(self, "to")


@pulumi.output_type
class GetNetworkInsightsAnalysisForwardPathComponentOutboundHeaderSourcePortRangeResult(dict):
    def __init__(__self__, *,
                 from_: _builtins.int,
                 to: _builtins.int):
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> _builtins.int:
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> _builtins.int:
        return pulumi.get(self, "to")


@pulumi.output_type
class GetNetworkInsightsAnalysisForwardPathComponentRouteTableRouteResult(dict):
    def __init__(__self__, *,
                 destination_cidr: _builtins.str,
                 destination_prefix_list_id: _builtins.str,
                 egress_only_internet_gateway_id: _builtins.str,
                 gateway_id: _builtins.str,
                 instance_id: _builtins.str,
                 nat_gateway_id: _builtins.str,
                 network_interface_id: _builtins.str,
                 origin: _builtins.str,
                 transit_gateway_id: _builtins.str,
                 vpc_peering_connection_id: _builtins.str):
        pulumi.set(__self__, "destination_cidr", destination_cidr)
        pulumi.set(__self__, "destination_prefix_list_id", destination_prefix_list_id)
        pulumi.set(__self__, "egress_only_internet_gateway_id", egress_only_internet_gateway_id)
        pulumi.set(__self__, "gateway_id", gateway_id)
        pulumi.set(__self__, "instance_id", instance_id)
        pulumi.set(__self__, "nat_gateway_id", nat_gateway_id)
        pulumi.set(__self__, "network_interface_id", network_interface_id)
        pulumi.set(__self__, "origin", origin)
        pulumi.set(__self__, "transit_gateway_id", transit_gateway_id)
        pulumi.set(__self__, "vpc_peering_connection_id", vpc_peering_connection_id)

    @_builtins.property
    @pulumi.getter(name="destinationCidr")
    def destination_cidr(self) -> _builtins.str:
        return pulumi.get(self, "destination_cidr")

    @_builtins.property
    @pulumi.getter(name="destinationPrefixListId")
    def destination_prefix_list_id(self) -> _builtins.str:
        return pulumi.get(self, "destination_prefix_list_id")

    @_builtins.property
    @pulumi.getter(name="egressOnlyInternetGatewayId")
    def egress_only_internet_gateway_id(self) -> _builtins.str:
        return pulumi.get(self, "egress_only_internet_gateway_id")

    @_builtins.property
    @pulumi.getter(name="gatewayId")
    def gateway_id(self) -> _builtins.str:
        return pulumi.get(self, "gateway_id")

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> _builtins.str:
        return pulumi.get(self, "instance_id")

    @_builtins.property
    @pulumi.getter(name="natGatewayId")
    def nat_gateway_id(self) -> _builtins.str:
        return pulumi.get(self, "nat_gateway_id")

    @_builtins.property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> _builtins.str:
        return pulumi.get(self, "network_interface_id")

    @_builtins.property
    @pulumi.getter
    def origin(self) -> _builtins.str:
        return pulumi.get(self, "origin")

    @_builtins.property
    @pulumi.getter(name="transitGatewayId")
    def transit_gateway_id(self) -> _builtins.str:
        return pulumi.get(self, "transit_gateway_id")

    @_builtins.property
    @pulumi.getter(name="vpcPeeringConnectionId")
    def vpc_peering_connection_id(self) -> _builtins.str:
        return pulumi.get(self, "vpc_peering_connection_id")


@pulumi.output_type
class GetNetworkInsightsAnalysisForwardPathComponentSecurityGroupRuleResult(dict):
    def __init__(__self__, *,
                 cidr: _builtins.str,
                 direction: _builtins.str,
                 port_ranges: Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentSecurityGroupRulePortRangeResult'],
                 prefix_list_id: _builtins.str,
                 protocol: _builtins.str,
                 security_group_id: _builtins.str):
        pulumi.set(__self__, "cidr", cidr)
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "port_ranges", port_ranges)
        pulumi.set(__self__, "prefix_list_id", prefix_list_id)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "security_group_id", security_group_id)

    @_builtins.property
    @pulumi.getter
    def cidr(self) -> _builtins.str:
        return pulumi.get(self, "cidr")

    @_builtins.property
    @pulumi.getter
    def direction(self) -> _builtins.str:
        return pulumi.get(self, "direction")

    @_builtins.property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Sequence['outputs.GetNetworkInsightsAnalysisForwardPathComponentSecurityGroupRulePortRangeResult']:
        return pulumi.get(self, "port_ranges")

    @_builtins.property
    @pulumi.getter(name="prefixListId")
    def prefix_list_id(self) -> _builtins.str:
        return pulumi.get(self, "prefix_list_id")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> _builtins.str:
        return pulumi.get(self, "security_group_id")


@pulumi.output_type
class GetNetworkInsightsAnalysisForwardPathComponentSecurityGroupRulePortRangeResult(dict):
    def __init__(__self__, *,
                 from_: _builtins.int,
                 to: _builtins.int):
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> _builtins.int:
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> _builtins.int:
        return pulumi.get(self, "to")


@pulumi.output_type
class GetNetworkInsightsAnalysisForwardPathComponentSourceVpcResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisForwardPathComponentSubnetResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisForwardPathComponentTransitGatewayResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisForwardPathComponentTransitGatewayRouteTableRouteResult(dict):
    def __init__(__self__, *,
                 attachment_id: _builtins.str,
                 destination_cidr: _builtins.str,
                 prefix_list_id: _builtins.str,
                 resource_id: _builtins.str,
                 resource_type: _builtins.str,
                 route_origin: _builtins.str,
                 state: _builtins.str):
        pulumi.set(__self__, "attachment_id", attachment_id)
        pulumi.set(__self__, "destination_cidr", destination_cidr)
        pulumi.set(__self__, "prefix_list_id", prefix_list_id)
        pulumi.set(__self__, "resource_id", resource_id)
        pulumi.set(__self__, "resource_type", resource_type)
        pulumi.set(__self__, "route_origin", route_origin)
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="attachmentId")
    def attachment_id(self) -> _builtins.str:
        return pulumi.get(self, "attachment_id")

    @_builtins.property
    @pulumi.getter(name="destinationCidr")
    def destination_cidr(self) -> _builtins.str:
        return pulumi.get(self, "destination_cidr")

    @_builtins.property
    @pulumi.getter(name="prefixListId")
    def prefix_list_id(self) -> _builtins.str:
        return pulumi.get(self, "prefix_list_id")

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> _builtins.str:
        return pulumi.get(self, "resource_id")

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> _builtins.str:
        return pulumi.get(self, "resource_type")

    @_builtins.property
    @pulumi.getter(name="routeOrigin")
    def route_origin(self) -> _builtins.str:
        return pulumi.get(self, "route_origin")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        return pulumi.get(self, "state")


@pulumi.output_type
class GetNetworkInsightsAnalysisForwardPathComponentVpcResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisReturnPathComponentResult(dict):
    def __init__(__self__, *,
                 acl_rules: Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentAclRuleResult'],
                 additional_details: Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentAdditionalDetailResult'],
                 attached_tos: Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentAttachedToResult'],
                 components: Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentComponentResult'],
                 destination_vpcs: Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentDestinationVpcResult'],
                 inbound_headers: Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentInboundHeaderResult'],
                 outbound_headers: Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentOutboundHeaderResult'],
                 route_table_routes: Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentRouteTableRouteResult'],
                 security_group_rules: Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentSecurityGroupRuleResult'],
                 sequence_number: _builtins.int,
                 source_vpcs: Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentSourceVpcResult'],
                 subnets: Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentSubnetResult'],
                 transit_gateway_route_table_routes: Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentTransitGatewayRouteTableRouteResult'],
                 transit_gateways: Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentTransitGatewayResult'],
                 vpcs: Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentVpcResult']):
        pulumi.set(__self__, "acl_rules", acl_rules)
        pulumi.set(__self__, "additional_details", additional_details)
        pulumi.set(__self__, "attached_tos", attached_tos)
        pulumi.set(__self__, "components", components)
        pulumi.set(__self__, "destination_vpcs", destination_vpcs)
        pulumi.set(__self__, "inbound_headers", inbound_headers)
        pulumi.set(__self__, "outbound_headers", outbound_headers)
        pulumi.set(__self__, "route_table_routes", route_table_routes)
        pulumi.set(__self__, "security_group_rules", security_group_rules)
        pulumi.set(__self__, "sequence_number", sequence_number)
        pulumi.set(__self__, "source_vpcs", source_vpcs)
        pulumi.set(__self__, "subnets", subnets)
        pulumi.set(__self__, "transit_gateway_route_table_routes", transit_gateway_route_table_routes)
        pulumi.set(__self__, "transit_gateways", transit_gateways)
        pulumi.set(__self__, "vpcs", vpcs)

    @_builtins.property
    @pulumi.getter(name="aclRules")
    def acl_rules(self) -> Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentAclRuleResult']:
        return pulumi.get(self, "acl_rules")

    @_builtins.property
    @pulumi.getter(name="additionalDetails")
    def additional_details(self) -> Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentAdditionalDetailResult']:
        return pulumi.get(self, "additional_details")

    @_builtins.property
    @pulumi.getter(name="attachedTos")
    def attached_tos(self) -> Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentAttachedToResult']:
        return pulumi.get(self, "attached_tos")

    @_builtins.property
    @pulumi.getter
    def components(self) -> Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentComponentResult']:
        return pulumi.get(self, "components")

    @_builtins.property
    @pulumi.getter(name="destinationVpcs")
    def destination_vpcs(self) -> Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentDestinationVpcResult']:
        return pulumi.get(self, "destination_vpcs")

    @_builtins.property
    @pulumi.getter(name="inboundHeaders")
    def inbound_headers(self) -> Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentInboundHeaderResult']:
        return pulumi.get(self, "inbound_headers")

    @_builtins.property
    @pulumi.getter(name="outboundHeaders")
    def outbound_headers(self) -> Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentOutboundHeaderResult']:
        return pulumi.get(self, "outbound_headers")

    @_builtins.property
    @pulumi.getter(name="routeTableRoutes")
    def route_table_routes(self) -> Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentRouteTableRouteResult']:
        return pulumi.get(self, "route_table_routes")

    @_builtins.property
    @pulumi.getter(name="securityGroupRules")
    def security_group_rules(self) -> Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentSecurityGroupRuleResult']:
        return pulumi.get(self, "security_group_rules")

    @_builtins.property
    @pulumi.getter(name="sequenceNumber")
    def sequence_number(self) -> _builtins.int:
        return pulumi.get(self, "sequence_number")

    @_builtins.property
    @pulumi.getter(name="sourceVpcs")
    def source_vpcs(self) -> Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentSourceVpcResult']:
        return pulumi.get(self, "source_vpcs")

    @_builtins.property
    @pulumi.getter
    def subnets(self) -> Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentSubnetResult']:
        return pulumi.get(self, "subnets")

    @_builtins.property
    @pulumi.getter(name="transitGatewayRouteTableRoutes")
    def transit_gateway_route_table_routes(self) -> Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentTransitGatewayRouteTableRouteResult']:
        return pulumi.get(self, "transit_gateway_route_table_routes")

    @_builtins.property
    @pulumi.getter(name="transitGateways")
    def transit_gateways(self) -> Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentTransitGatewayResult']:
        return pulumi.get(self, "transit_gateways")

    @_builtins.property
    @pulumi.getter
    def vpcs(self) -> Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentVpcResult']:
        return pulumi.get(self, "vpcs")


@pulumi.output_type
class GetNetworkInsightsAnalysisReturnPathComponentAclRuleResult(dict):
    def __init__(__self__, *,
                 cidr: _builtins.str,
                 egress: _builtins.bool,
                 port_ranges: Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentAclRulePortRangeResult'],
                 protocol: _builtins.str,
                 rule_action: _builtins.str,
                 rule_number: _builtins.int):
        pulumi.set(__self__, "cidr", cidr)
        pulumi.set(__self__, "egress", egress)
        pulumi.set(__self__, "port_ranges", port_ranges)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "rule_action", rule_action)
        pulumi.set(__self__, "rule_number", rule_number)

    @_builtins.property
    @pulumi.getter
    def cidr(self) -> _builtins.str:
        return pulumi.get(self, "cidr")

    @_builtins.property
    @pulumi.getter
    def egress(self) -> _builtins.bool:
        return pulumi.get(self, "egress")

    @_builtins.property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentAclRulePortRangeResult']:
        return pulumi.get(self, "port_ranges")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="ruleAction")
    def rule_action(self) -> _builtins.str:
        return pulumi.get(self, "rule_action")

    @_builtins.property
    @pulumi.getter(name="ruleNumber")
    def rule_number(self) -> _builtins.int:
        return pulumi.get(self, "rule_number")


@pulumi.output_type
class GetNetworkInsightsAnalysisReturnPathComponentAclRulePortRangeResult(dict):
    def __init__(__self__, *,
                 from_: _builtins.int,
                 to: _builtins.int):
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> _builtins.int:
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> _builtins.int:
        return pulumi.get(self, "to")


@pulumi.output_type
class GetNetworkInsightsAnalysisReturnPathComponentAdditionalDetailResult(dict):
    def __init__(__self__, *,
                 additional_detail_type: _builtins.str,
                 components: Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentAdditionalDetailComponentResult']):
        pulumi.set(__self__, "additional_detail_type", additional_detail_type)
        pulumi.set(__self__, "components", components)

    @_builtins.property
    @pulumi.getter(name="additionalDetailType")
    def additional_detail_type(self) -> _builtins.str:
        return pulumi.get(self, "additional_detail_type")

    @_builtins.property
    @pulumi.getter
    def components(self) -> Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentAdditionalDetailComponentResult']:
        return pulumi.get(self, "components")


@pulumi.output_type
class GetNetworkInsightsAnalysisReturnPathComponentAdditionalDetailComponentResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisReturnPathComponentAttachedToResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisReturnPathComponentComponentResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisReturnPathComponentDestinationVpcResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisReturnPathComponentInboundHeaderResult(dict):
    def __init__(__self__, *,
                 destination_addresses: Sequence[_builtins.str],
                 destination_port_ranges: Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentInboundHeaderDestinationPortRangeResult'],
                 protocol: _builtins.str,
                 source_addresses: Sequence[_builtins.str],
                 source_port_ranges: Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentInboundHeaderSourcePortRangeResult']):
        pulumi.set(__self__, "destination_addresses", destination_addresses)
        pulumi.set(__self__, "destination_port_ranges", destination_port_ranges)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "source_addresses", source_addresses)
        pulumi.set(__self__, "source_port_ranges", source_port_ranges)

    @_builtins.property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "destination_addresses")

    @_builtins.property
    @pulumi.getter(name="destinationPortRanges")
    def destination_port_ranges(self) -> Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentInboundHeaderDestinationPortRangeResult']:
        return pulumi.get(self, "destination_port_ranges")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "source_addresses")

    @_builtins.property
    @pulumi.getter(name="sourcePortRanges")
    def source_port_ranges(self) -> Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentInboundHeaderSourcePortRangeResult']:
        return pulumi.get(self, "source_port_ranges")


@pulumi.output_type
class GetNetworkInsightsAnalysisReturnPathComponentInboundHeaderDestinationPortRangeResult(dict):
    def __init__(__self__, *,
                 from_: _builtins.int,
                 to: _builtins.int):
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> _builtins.int:
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> _builtins.int:
        return pulumi.get(self, "to")


@pulumi.output_type
class GetNetworkInsightsAnalysisReturnPathComponentInboundHeaderSourcePortRangeResult(dict):
    def __init__(__self__, *,
                 from_: _builtins.int,
                 to: _builtins.int):
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> _builtins.int:
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> _builtins.int:
        return pulumi.get(self, "to")


@pulumi.output_type
class GetNetworkInsightsAnalysisReturnPathComponentOutboundHeaderResult(dict):
    def __init__(__self__, *,
                 destination_addresses: Sequence[_builtins.str],
                 destination_port_ranges: Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentOutboundHeaderDestinationPortRangeResult'],
                 protocol: _builtins.str,
                 source_addresses: Sequence[_builtins.str],
                 source_port_ranges: Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentOutboundHeaderSourcePortRangeResult']):
        pulumi.set(__self__, "destination_addresses", destination_addresses)
        pulumi.set(__self__, "destination_port_ranges", destination_port_ranges)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "source_addresses", source_addresses)
        pulumi.set(__self__, "source_port_ranges", source_port_ranges)

    @_builtins.property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "destination_addresses")

    @_builtins.property
    @pulumi.getter(name="destinationPortRanges")
    def destination_port_ranges(self) -> Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentOutboundHeaderDestinationPortRangeResult']:
        return pulumi.get(self, "destination_port_ranges")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "source_addresses")

    @_builtins.property
    @pulumi.getter(name="sourcePortRanges")
    def source_port_ranges(self) -> Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentOutboundHeaderSourcePortRangeResult']:
        return pulumi.get(self, "source_port_ranges")


@pulumi.output_type
class GetNetworkInsightsAnalysisReturnPathComponentOutboundHeaderDestinationPortRangeResult(dict):
    def __init__(__self__, *,
                 from_: _builtins.int,
                 to: _builtins.int):
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> _builtins.int:
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> _builtins.int:
        return pulumi.get(self, "to")


@pulumi.output_type
class GetNetworkInsightsAnalysisReturnPathComponentOutboundHeaderSourcePortRangeResult(dict):
    def __init__(__self__, *,
                 from_: _builtins.int,
                 to: _builtins.int):
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> _builtins.int:
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> _builtins.int:
        return pulumi.get(self, "to")


@pulumi.output_type
class GetNetworkInsightsAnalysisReturnPathComponentRouteTableRouteResult(dict):
    def __init__(__self__, *,
                 destination_cidr: _builtins.str,
                 destination_prefix_list_id: _builtins.str,
                 egress_only_internet_gateway_id: _builtins.str,
                 gateway_id: _builtins.str,
                 instance_id: _builtins.str,
                 nat_gateway_id: _builtins.str,
                 network_interface_id: _builtins.str,
                 origin: _builtins.str,
                 transit_gateway_id: _builtins.str,
                 vpc_peering_connection_id: _builtins.str):
        pulumi.set(__self__, "destination_cidr", destination_cidr)
        pulumi.set(__self__, "destination_prefix_list_id", destination_prefix_list_id)
        pulumi.set(__self__, "egress_only_internet_gateway_id", egress_only_internet_gateway_id)
        pulumi.set(__self__, "gateway_id", gateway_id)
        pulumi.set(__self__, "instance_id", instance_id)
        pulumi.set(__self__, "nat_gateway_id", nat_gateway_id)
        pulumi.set(__self__, "network_interface_id", network_interface_id)
        pulumi.set(__self__, "origin", origin)
        pulumi.set(__self__, "transit_gateway_id", transit_gateway_id)
        pulumi.set(__self__, "vpc_peering_connection_id", vpc_peering_connection_id)

    @_builtins.property
    @pulumi.getter(name="destinationCidr")
    def destination_cidr(self) -> _builtins.str:
        return pulumi.get(self, "destination_cidr")

    @_builtins.property
    @pulumi.getter(name="destinationPrefixListId")
    def destination_prefix_list_id(self) -> _builtins.str:
        return pulumi.get(self, "destination_prefix_list_id")

    @_builtins.property
    @pulumi.getter(name="egressOnlyInternetGatewayId")
    def egress_only_internet_gateway_id(self) -> _builtins.str:
        return pulumi.get(self, "egress_only_internet_gateway_id")

    @_builtins.property
    @pulumi.getter(name="gatewayId")
    def gateway_id(self) -> _builtins.str:
        return pulumi.get(self, "gateway_id")

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> _builtins.str:
        return pulumi.get(self, "instance_id")

    @_builtins.property
    @pulumi.getter(name="natGatewayId")
    def nat_gateway_id(self) -> _builtins.str:
        return pulumi.get(self, "nat_gateway_id")

    @_builtins.property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> _builtins.str:
        return pulumi.get(self, "network_interface_id")

    @_builtins.property
    @pulumi.getter
    def origin(self) -> _builtins.str:
        return pulumi.get(self, "origin")

    @_builtins.property
    @pulumi.getter(name="transitGatewayId")
    def transit_gateway_id(self) -> _builtins.str:
        return pulumi.get(self, "transit_gateway_id")

    @_builtins.property
    @pulumi.getter(name="vpcPeeringConnectionId")
    def vpc_peering_connection_id(self) -> _builtins.str:
        return pulumi.get(self, "vpc_peering_connection_id")


@pulumi.output_type
class GetNetworkInsightsAnalysisReturnPathComponentSecurityGroupRuleResult(dict):
    def __init__(__self__, *,
                 cidr: _builtins.str,
                 direction: _builtins.str,
                 port_ranges: Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentSecurityGroupRulePortRangeResult'],
                 prefix_list_id: _builtins.str,
                 protocol: _builtins.str,
                 security_group_id: _builtins.str):
        pulumi.set(__self__, "cidr", cidr)
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "port_ranges", port_ranges)
        pulumi.set(__self__, "prefix_list_id", prefix_list_id)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "security_group_id", security_group_id)

    @_builtins.property
    @pulumi.getter
    def cidr(self) -> _builtins.str:
        return pulumi.get(self, "cidr")

    @_builtins.property
    @pulumi.getter
    def direction(self) -> _builtins.str:
        return pulumi.get(self, "direction")

    @_builtins.property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Sequence['outputs.GetNetworkInsightsAnalysisReturnPathComponentSecurityGroupRulePortRangeResult']:
        return pulumi.get(self, "port_ranges")

    @_builtins.property
    @pulumi.getter(name="prefixListId")
    def prefix_list_id(self) -> _builtins.str:
        return pulumi.get(self, "prefix_list_id")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> _builtins.str:
        return pulumi.get(self, "security_group_id")


@pulumi.output_type
class GetNetworkInsightsAnalysisReturnPathComponentSecurityGroupRulePortRangeResult(dict):
    def __init__(__self__, *,
                 from_: _builtins.int,
                 to: _builtins.int):
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> _builtins.int:
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> _builtins.int:
        return pulumi.get(self, "to")


@pulumi.output_type
class GetNetworkInsightsAnalysisReturnPathComponentSourceVpcResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisReturnPathComponentSubnetResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisReturnPathComponentTransitGatewayResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsAnalysisReturnPathComponentTransitGatewayRouteTableRouteResult(dict):
    def __init__(__self__, *,
                 attachment_id: _builtins.str,
                 destination_cidr: _builtins.str,
                 prefix_list_id: _builtins.str,
                 resource_id: _builtins.str,
                 resource_type: _builtins.str,
                 route_origin: _builtins.str,
                 state: _builtins.str):
        pulumi.set(__self__, "attachment_id", attachment_id)
        pulumi.set(__self__, "destination_cidr", destination_cidr)
        pulumi.set(__self__, "prefix_list_id", prefix_list_id)
        pulumi.set(__self__, "resource_id", resource_id)
        pulumi.set(__self__, "resource_type", resource_type)
        pulumi.set(__self__, "route_origin", route_origin)
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="attachmentId")
    def attachment_id(self) -> _builtins.str:
        return pulumi.get(self, "attachment_id")

    @_builtins.property
    @pulumi.getter(name="destinationCidr")
    def destination_cidr(self) -> _builtins.str:
        return pulumi.get(self, "destination_cidr")

    @_builtins.property
    @pulumi.getter(name="prefixListId")
    def prefix_list_id(self) -> _builtins.str:
        return pulumi.get(self, "prefix_list_id")

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> _builtins.str:
        return pulumi.get(self, "resource_id")

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> _builtins.str:
        return pulumi.get(self, "resource_type")

    @_builtins.property
    @pulumi.getter(name="routeOrigin")
    def route_origin(self) -> _builtins.str:
        return pulumi.get(self, "route_origin")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        return pulumi.get(self, "state")


@pulumi.output_type
class GetNetworkInsightsAnalysisReturnPathComponentVpcResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworkInsightsPathFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetNetworkInsightsPathFilterAtDestinationResult(dict):
    def __init__(__self__, *,
                 destination_address: _builtins.str,
                 destination_port_ranges: Sequence['outputs.GetNetworkInsightsPathFilterAtDestinationDestinationPortRangeResult'],
                 source_address: _builtins.str,
                 source_port_ranges: Sequence['outputs.GetNetworkInsightsPathFilterAtDestinationSourcePortRangeResult']):
        pulumi.set(__self__, "destination_address", destination_address)
        pulumi.set(__self__, "destination_port_ranges", destination_port_ranges)
        pulumi.set(__self__, "source_address", source_address)
        pulumi.set(__self__, "source_port_ranges", source_port_ranges)

    @_builtins.property
    @pulumi.getter(name="destinationAddress")
    def destination_address(self) -> _builtins.str:
        return pulumi.get(self, "destination_address")

    @_builtins.property
    @pulumi.getter(name="destinationPortRanges")
    def destination_port_ranges(self) -> Sequence['outputs.GetNetworkInsightsPathFilterAtDestinationDestinationPortRangeResult']:
        return pulumi.get(self, "destination_port_ranges")

    @_builtins.property
    @pulumi.getter(name="sourceAddress")
    def source_address(self) -> _builtins.str:
        return pulumi.get(self, "source_address")

    @_builtins.property
    @pulumi.getter(name="sourcePortRanges")
    def source_port_ranges(self) -> Sequence['outputs.GetNetworkInsightsPathFilterAtDestinationSourcePortRangeResult']:
        return pulumi.get(self, "source_port_ranges")


@pulumi.output_type
class GetNetworkInsightsPathFilterAtDestinationDestinationPortRangeResult(dict):
    def __init__(__self__, *,
                 from_port: _builtins.int,
                 to_port: _builtins.int):
        pulumi.set(__self__, "from_port", from_port)
        pulumi.set(__self__, "to_port", to_port)

    @_builtins.property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> _builtins.int:
        return pulumi.get(self, "from_port")

    @_builtins.property
    @pulumi.getter(name="toPort")
    def to_port(self) -> _builtins.int:
        return pulumi.get(self, "to_port")


@pulumi.output_type
class GetNetworkInsightsPathFilterAtDestinationSourcePortRangeResult(dict):
    def __init__(__self__, *,
                 from_port: _builtins.int,
                 to_port: _builtins.int):
        pulumi.set(__self__, "from_port", from_port)
        pulumi.set(__self__, "to_port", to_port)

    @_builtins.property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> _builtins.int:
        return pulumi.get(self, "from_port")

    @_builtins.property
    @pulumi.getter(name="toPort")
    def to_port(self) -> _builtins.int:
        return pulumi.get(self, "to_port")


@pulumi.output_type
class GetNetworkInsightsPathFilterAtSourceResult(dict):
    def __init__(__self__, *,
                 destination_address: _builtins.str,
                 destination_port_ranges: Sequence['outputs.GetNetworkInsightsPathFilterAtSourceDestinationPortRangeResult'],
                 source_address: _builtins.str,
                 source_port_ranges: Sequence['outputs.GetNetworkInsightsPathFilterAtSourceSourcePortRangeResult']):
        pulumi.set(__self__, "destination_address", destination_address)
        pulumi.set(__self__, "destination_port_ranges", destination_port_ranges)
        pulumi.set(__self__, "source_address", source_address)
        pulumi.set(__self__, "source_port_ranges", source_port_ranges)

    @_builtins.property
    @pulumi.getter(name="destinationAddress")
    def destination_address(self) -> _builtins.str:
        return pulumi.get(self, "destination_address")

    @_builtins.property
    @pulumi.getter(name="destinationPortRanges")
    def destination_port_ranges(self) -> Sequence['outputs.GetNetworkInsightsPathFilterAtSourceDestinationPortRangeResult']:
        return pulumi.get(self, "destination_port_ranges")

    @_builtins.property
    @pulumi.getter(name="sourceAddress")
    def source_address(self) -> _builtins.str:
        return pulumi.get(self, "source_address")

    @_builtins.property
    @pulumi.getter(name="sourcePortRanges")
    def source_port_ranges(self) -> Sequence['outputs.GetNetworkInsightsPathFilterAtSourceSourcePortRangeResult']:
        return pulumi.get(self, "source_port_ranges")


@pulumi.output_type
class GetNetworkInsightsPathFilterAtSourceDestinationPortRangeResult(dict):
    def __init__(__self__, *,
                 from_port: _builtins.int,
                 to_port: _builtins.int):
        pulumi.set(__self__, "from_port", from_port)
        pulumi.set(__self__, "to_port", to_port)

    @_builtins.property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> _builtins.int:
        return pulumi.get(self, "from_port")

    @_builtins.property
    @pulumi.getter(name="toPort")
    def to_port(self) -> _builtins.int:
        return pulumi.get(self, "to_port")


@pulumi.output_type
class GetNetworkInsightsPathFilterAtSourceSourcePortRangeResult(dict):
    def __init__(__self__, *,
                 from_port: _builtins.int,
                 to_port: _builtins.int):
        pulumi.set(__self__, "from_port", from_port)
        pulumi.set(__self__, "to_port", to_port)

    @_builtins.property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> _builtins.int:
        return pulumi.get(self, "from_port")

    @_builtins.property
    @pulumi.getter(name="toPort")
    def to_port(self) -> _builtins.int:
        return pulumi.get(self, "to_port")


@pulumi.output_type
class GetNetworkInterfaceAssociationResult(dict):
    def __init__(__self__, *,
                 allocation_id: _builtins.str,
                 association_id: _builtins.str,
                 carrier_ip: _builtins.str,
                 customer_owned_ip: _builtins.str,
                 ip_owner_id: _builtins.str,
                 public_dns_name: _builtins.str,
                 public_ip: _builtins.str):
        pulumi.set(__self__, "allocation_id", allocation_id)
        pulumi.set(__self__, "association_id", association_id)
        pulumi.set(__self__, "carrier_ip", carrier_ip)
        pulumi.set(__self__, "customer_owned_ip", customer_owned_ip)
        pulumi.set(__self__, "ip_owner_id", ip_owner_id)
        pulumi.set(__self__, "public_dns_name", public_dns_name)
        pulumi.set(__self__, "public_ip", public_ip)

    @_builtins.property
    @pulumi.getter(name="allocationId")
    def allocation_id(self) -> _builtins.str:
        return pulumi.get(self, "allocation_id")

    @_builtins.property
    @pulumi.getter(name="associationId")
    def association_id(self) -> _builtins.str:
        return pulumi.get(self, "association_id")

    @_builtins.property
    @pulumi.getter(name="carrierIp")
    def carrier_ip(self) -> _builtins.str:
        return pulumi.get(self, "carrier_ip")

    @_builtins.property
    @pulumi.getter(name="customerOwnedIp")
    def customer_owned_ip(self) -> _builtins.str:
        return pulumi.get(self, "customer_owned_ip")

    @_builtins.property
    @pulumi.getter(name="ipOwnerId")
    def ip_owner_id(self) -> _builtins.str:
        return pulumi.get(self, "ip_owner_id")

    @_builtins.property
    @pulumi.getter(name="publicDnsName")
    def public_dns_name(self) -> _builtins.str:
        return pulumi.get(self, "public_dns_name")

    @_builtins.property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> _builtins.str:
        return pulumi.get(self, "public_ip")


@pulumi.output_type
class GetNetworkInterfaceAttachmentResult(dict):
    def __init__(__self__, *,
                 attachment_id: _builtins.str,
                 device_index: _builtins.int,
                 instance_id: _builtins.str,
                 instance_owner_id: _builtins.str,
                 network_card_index: _builtins.int):
        pulumi.set(__self__, "attachment_id", attachment_id)
        pulumi.set(__self__, "device_index", device_index)
        pulumi.set(__self__, "instance_id", instance_id)
        pulumi.set(__self__, "instance_owner_id", instance_owner_id)
        pulumi.set(__self__, "network_card_index", network_card_index)

    @_builtins.property
    @pulumi.getter(name="attachmentId")
    def attachment_id(self) -> _builtins.str:
        return pulumi.get(self, "attachment_id")

    @_builtins.property
    @pulumi.getter(name="deviceIndex")
    def device_index(self) -> _builtins.int:
        return pulumi.get(self, "device_index")

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> _builtins.str:
        return pulumi.get(self, "instance_id")

    @_builtins.property
    @pulumi.getter(name="instanceOwnerId")
    def instance_owner_id(self) -> _builtins.str:
        return pulumi.get(self, "instance_owner_id")

    @_builtins.property
    @pulumi.getter(name="networkCardIndex")
    def network_card_index(self) -> _builtins.int:
        return pulumi.get(self, "network_card_index")


@pulumi.output_type
class GetNetworkInterfaceFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetNetworkInterfacesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetPrefixListFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetPublicIpv4PoolPoolAddressRangeResult(dict):
    def __init__(__self__, *,
                 address_count: _builtins.int,
                 available_address_count: _builtins.int,
                 first_address: _builtins.str,
                 last_address: _builtins.str):
        pulumi.set(__self__, "address_count", address_count)
        pulumi.set(__self__, "available_address_count", available_address_count)
        pulumi.set(__self__, "first_address", first_address)
        pulumi.set(__self__, "last_address", last_address)

    @_builtins.property
    @pulumi.getter(name="addressCount")
    def address_count(self) -> _builtins.int:
        return pulumi.get(self, "address_count")

    @_builtins.property
    @pulumi.getter(name="availableAddressCount")
    def available_address_count(self) -> _builtins.int:
        return pulumi.get(self, "available_address_count")

    @_builtins.property
    @pulumi.getter(name="firstAddress")
    def first_address(self) -> _builtins.str:
        return pulumi.get(self, "first_address")

    @_builtins.property
    @pulumi.getter(name="lastAddress")
    def last_address(self) -> _builtins.str:
        return pulumi.get(self, "last_address")


@pulumi.output_type
class GetPublicIpv4PoolsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetRouteTableAssociationResult(dict):
    def __init__(__self__, *,
                 gateway_id: _builtins.str,
                 main: _builtins.bool,
                 route_table_association_id: _builtins.str,
                 route_table_id: _builtins.str,
                 subnet_id: _builtins.str):
        pulumi.set(__self__, "gateway_id", gateway_id)
        pulumi.set(__self__, "main", main)
        pulumi.set(__self__, "route_table_association_id", route_table_association_id)
        pulumi.set(__self__, "route_table_id", route_table_id)
        pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="gatewayId")
    def gateway_id(self) -> _builtins.str:
        return pulumi.get(self, "gateway_id")

    @_builtins.property
    @pulumi.getter
    def main(self) -> _builtins.bool:
        return pulumi.get(self, "main")

    @_builtins.property
    @pulumi.getter(name="routeTableAssociationId")
    def route_table_association_id(self) -> _builtins.str:
        return pulumi.get(self, "route_table_association_id")

    @_builtins.property
    @pulumi.getter(name="routeTableId")
    def route_table_id(self) -> _builtins.str:
        return pulumi.get(self, "route_table_id")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class GetRouteTableFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetRouteTableRouteResult(dict):
    def __init__(__self__, *,
                 carrier_gateway_id: _builtins.str,
                 cidr_block: _builtins.str,
                 core_network_arn: _builtins.str,
                 destination_prefix_list_id: _builtins.str,
                 egress_only_gateway_id: _builtins.str,
                 gateway_id: _builtins.str,
                 instance_id: _builtins.str,
                 ipv6_cidr_block: _builtins.str,
                 local_gateway_id: _builtins.str,
                 nat_gateway_id: _builtins.str,
                 network_interface_id: _builtins.str,
                 transit_gateway_id: _builtins.str,
                 vpc_endpoint_id: _builtins.str,
                 vpc_peering_connection_id: _builtins.str):
        pulumi.set(__self__, "carrier_gateway_id", carrier_gateway_id)
        pulumi.set(__self__, "cidr_block", cidr_block)
        pulumi.set(__self__, "core_network_arn", core_network_arn)
        pulumi.set(__self__, "destination_prefix_list_id", destination_prefix_list_id)
        pulumi.set(__self__, "egress_only_gateway_id", egress_only_gateway_id)
        pulumi.set(__self__, "gateway_id", gateway_id)
        pulumi.set(__self__, "instance_id", instance_id)
        pulumi.set(__self__, "ipv6_cidr_block", ipv6_cidr_block)
        pulumi.set(__self__, "local_gateway_id", local_gateway_id)
        pulumi.set(__self__, "nat_gateway_id", nat_gateway_id)
        pulumi.set(__self__, "network_interface_id", network_interface_id)
        pulumi.set(__self__, "transit_gateway_id", transit_gateway_id)
        pulumi.set(__self__, "vpc_endpoint_id", vpc_endpoint_id)
        pulumi.set(__self__, "vpc_peering_connection_id", vpc_peering_connection_id)

    @_builtins.property
    @pulumi.getter(name="carrierGatewayId")
    def carrier_gateway_id(self) -> _builtins.str:
        return pulumi.get(self, "carrier_gateway_id")

    @_builtins.property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> _builtins.str:
        return pulumi.get(self, "cidr_block")

    @_builtins.property
    @pulumi.getter(name="coreNetworkArn")
    def core_network_arn(self) -> _builtins.str:
        return pulumi.get(self, "core_network_arn")

    @_builtins.property
    @pulumi.getter(name="destinationPrefixListId")
    def destination_prefix_list_id(self) -> _builtins.str:
        return pulumi.get(self, "destination_prefix_list_id")

    @_builtins.property
    @pulumi.getter(name="egressOnlyGatewayId")
    def egress_only_gateway_id(self) -> _builtins.str:
        return pulumi.get(self, "egress_only_gateway_id")

    @_builtins.property
    @pulumi.getter(name="gatewayId")
    def gateway_id(self) -> _builtins.str:
        return pulumi.get(self, "gateway_id")

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> _builtins.str:
        return pulumi.get(self, "instance_id")

    @_builtins.property
    @pulumi.getter(name="ipv6CidrBlock")
    def ipv6_cidr_block(self) -> _builtins.str:
        return pulumi.get(self, "ipv6_cidr_block")

    @_builtins.property
    @pulumi.getter(name="localGatewayId")
    def local_gateway_id(self) -> _builtins.str:
        return pulumi.get(self, "local_gateway_id")

    @_builtins.property
    @pulumi.getter(name="natGatewayId")
    def nat_gateway_id(self) -> _builtins.str:
        return pulumi.get(self, "nat_gateway_id")

    @_builtins.property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> _builtins.str:
        return pulumi.get(self, "network_interface_id")

    @_builtins.property
    @pulumi.getter(name="transitGatewayId")
    def transit_gateway_id(self) -> _builtins.str:
        return pulumi.get(self, "transit_gateway_id")

    @_builtins.property
    @pulumi.getter(name="vpcEndpointId")
    def vpc_endpoint_id(self) -> _builtins.str:
        return pulumi.get(self, "vpc_endpoint_id")

    @_builtins.property
    @pulumi.getter(name="vpcPeeringConnectionId")
    def vpc_peering_connection_id(self) -> _builtins.str:
        return pulumi.get(self, "vpc_peering_connection_id")


@pulumi.output_type
class GetRouteTablesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetSecurityGroupFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetSecurityGroupsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetSpotPriceFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetSubnetFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetSubnetsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetTransitGatewayRouteTablesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetVpcCidrBlockAssociationResult(dict):
    def __init__(__self__, *,
                 association_id: _builtins.str,
                 cidr_block: _builtins.str,
                 state: _builtins.str):
        pulumi.set(__self__, "association_id", association_id)
        pulumi.set(__self__, "cidr_block", cidr_block)
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="associationId")
    def association_id(self) -> _builtins.str:
        return pulumi.get(self, "association_id")

    @_builtins.property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> _builtins.str:
        return pulumi.get(self, "cidr_block")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        return pulumi.get(self, "state")


@pulumi.output_type
class GetVpcDhcpOptionsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetVpcEndpointDnsEntryResult(dict):
    def __init__(__self__, *,
                 dns_name: _builtins.str,
                 hosted_zone_id: _builtins.str):
        pulumi.set(__self__, "dns_name", dns_name)
        pulumi.set(__self__, "hosted_zone_id", hosted_zone_id)

    @_builtins.property
    @pulumi.getter(name="dnsName")
    def dns_name(self) -> _builtins.str:
        return pulumi.get(self, "dns_name")

    @_builtins.property
    @pulumi.getter(name="hostedZoneId")
    def hosted_zone_id(self) -> _builtins.str:
        return pulumi.get(self, "hosted_zone_id")


@pulumi.output_type
class GetVpcEndpointDnsOptionResult(dict):
    def __init__(__self__, *,
                 dns_record_ip_type: _builtins.str,
                 private_dns_only_for_inbound_resolver_endpoint: _builtins.bool,
                 private_dns_preference: _builtins.str,
                 private_dns_specified_domains: Sequence[_builtins.str]):
        pulumi.set(__self__, "dns_record_ip_type", dns_record_ip_type)
        pulumi.set(__self__, "private_dns_only_for_inbound_resolver_endpoint", private_dns_only_for_inbound_resolver_endpoint)
        pulumi.set(__self__, "private_dns_preference", private_dns_preference)
        pulumi.set(__self__, "private_dns_specified_domains", private_dns_specified_domains)

    @_builtins.property
    @pulumi.getter(name="dnsRecordIpType")
    def dns_record_ip_type(self) -> _builtins.str:
        return pulumi.get(self, "dns_record_ip_type")

    @_builtins.property
    @pulumi.getter(name="privateDnsOnlyForInboundResolverEndpoint")
    def private_dns_only_for_inbound_resolver_endpoint(self) -> _builtins.bool:
        return pulumi.get(self, "private_dns_only_for_inbound_resolver_endpoint")

    @_builtins.property
    @pulumi.getter(name="privateDnsPreference")
    def private_dns_preference(self) -> _builtins.str:
        return pulumi.get(self, "private_dns_preference")

    @_builtins.property
    @pulumi.getter(name="privateDnsSpecifiedDomains")
    def private_dns_specified_domains(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "private_dns_specified_domains")


@pulumi.output_type
class GetVpcEndpointFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetVpcEndpointServiceFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetVpcFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetVpcIpamOperatingRegionResult(dict):
    def __init__(__self__, *,
                 region_name: _builtins.str):
        pulumi.set(__self__, "region_name", region_name)

    @_builtins.property
    @pulumi.getter(name="regionName")
    def region_name(self) -> _builtins.str:
        return pulumi.get(self, "region_name")


@pulumi.output_type
class GetVpcIpamPoolCidrsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetVpcIpamPoolCidrsIpamPoolCidrResult(dict):
    def __init__(__self__, *,
                 cidr: _builtins.str,
                 state: _builtins.str):
        pulumi.set(__self__, "cidr", cidr)
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def cidr(self) -> _builtins.str:
        return pulumi.get(self, "cidr")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        return pulumi.get(self, "state")


@pulumi.output_type
class GetVpcIpamPoolFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetVpcIpamPoolsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetVpcIpamPoolsIpamPoolResult(dict):
    def __init__(__self__, *,
                 address_family: _builtins.str,
                 allocation_default_netmask_length: _builtins.int,
                 allocation_max_netmask_length: _builtins.int,
                 allocation_min_netmask_length: _builtins.int,
                 allocation_resource_tags: Mapping[str, _builtins.str],
                 arn: _builtins.str,
                 auto_import: _builtins.bool,
                 aws_service: _builtins.str,
                 description: _builtins.str,
                 id: _builtins.str,
                 ipam_scope_id: _builtins.str,
                 ipam_scope_type: _builtins.str,
                 locale: _builtins.str,
                 pool_depth: _builtins.int,
                 publicly_advertisable: _builtins.bool,
                 source_ipam_pool_id: _builtins.str,
                 state: _builtins.str,
                 tags: Mapping[str, _builtins.str]):
        pulumi.set(__self__, "address_family", address_family)
        pulumi.set(__self__, "allocation_default_netmask_length", allocation_default_netmask_length)
        pulumi.set(__self__, "allocation_max_netmask_length", allocation_max_netmask_length)
        pulumi.set(__self__, "allocation_min_netmask_length", allocation_min_netmask_length)
        pulumi.set(__self__, "allocation_resource_tags", allocation_resource_tags)
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "auto_import", auto_import)
        pulumi.set(__self__, "aws_service", aws_service)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ipam_scope_id", ipam_scope_id)
        pulumi.set(__self__, "ipam_scope_type", ipam_scope_type)
        pulumi.set(__self__, "locale", locale)
        pulumi.set(__self__, "pool_depth", pool_depth)
        pulumi.set(__self__, "publicly_advertisable", publicly_advertisable)
        pulumi.set(__self__, "source_ipam_pool_id", source_ipam_pool_id)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="addressFamily")
    def address_family(self) -> _builtins.str:
        return pulumi.get(self, "address_family")

    @_builtins.property
    @pulumi.getter(name="allocationDefaultNetmaskLength")
    def allocation_default_netmask_length(self) -> _builtins.int:
        return pulumi.get(self, "allocation_default_netmask_length")

    @_builtins.property
    @pulumi.getter(name="allocationMaxNetmaskLength")
    def allocation_max_netmask_length(self) -> _builtins.int:
        return pulumi.get(self, "allocation_max_netmask_length")

    @_builtins.property
    @pulumi.getter(name="allocationMinNetmaskLength")
    def allocation_min_netmask_length(self) -> _builtins.int:
        return pulumi.get(self, "allocation_min_netmask_length")

    @_builtins.property
    @pulumi.getter(name="allocationResourceTags")
    def allocation_resource_tags(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "allocation_resource_tags")

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter(name="autoImport")
    def auto_import(self) -> _builtins.bool:
        return pulumi.get(self, "auto_import")

    @_builtins.property
    @pulumi.getter(name="awsService")
    def aws_service(self) -> _builtins.str:
        return pulumi.get(self, "aws_service")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="ipamScopeId")
    def ipam_scope_id(self) -> _builtins.str:
        return pulumi.get(self, "ipam_scope_id")

    @_builtins.property
    @pulumi.getter(name="ipamScopeType")
    def ipam_scope_type(self) -> _builtins.str:
        return pulumi.get(self, "ipam_scope_type")

    @_builtins.property
    @pulumi.getter
    def locale(self) -> _builtins.str:
        return pulumi.get(self, "locale")

    @_builtins.property
    @pulumi.getter(name="poolDepth")
    def pool_depth(self) -> _builtins.int:
        return pulumi.get(self, "pool_depth")

    @_builtins.property
    @pulumi.getter(name="publiclyAdvertisable")
    def publicly_advertisable(self) -> _builtins.bool:
        return pulumi.get(self, "publicly_advertisable")

    @_builtins.property
    @pulumi.getter(name="sourceIpamPoolId")
    def source_ipam_pool_id(self) -> _builtins.str:
        return pulumi.get(self, "source_ipam_pool_id")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetVpcIpamsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetVpcIpamsIpamResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 default_resource_discovery_association_id: _builtins.str,
                 default_resource_discovery_id: _builtins.str,
                 description: _builtins.str,
                 enable_private_gua: _builtins.bool,
                 id: _builtins.str,
                 ipam_region: _builtins.str,
                 metered_account: _builtins.str,
                 operating_regions: Sequence['outputs.GetVpcIpamsIpamOperatingRegionResult'],
                 owner_id: _builtins.str,
                 private_default_scope_id: _builtins.str,
                 public_default_scope_id: _builtins.str,
                 resource_discovery_association_count: _builtins.int,
                 scope_count: _builtins.int,
                 state: _builtins.str,
                 state_message: _builtins.str,
                 tier: _builtins.str):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "default_resource_discovery_association_id", default_resource_discovery_association_id)
        pulumi.set(__self__, "default_resource_discovery_id", default_resource_discovery_id)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "enable_private_gua", enable_private_gua)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ipam_region", ipam_region)
        pulumi.set(__self__, "metered_account", metered_account)
        pulumi.set(__self__, "operating_regions", operating_regions)
        pulumi.set(__self__, "owner_id", owner_id)
        pulumi.set(__self__, "private_default_scope_id", private_default_scope_id)
        pulumi.set(__self__, "public_default_scope_id", public_default_scope_id)
        pulumi.set(__self__, "resource_discovery_association_count", resource_discovery_association_count)
        pulumi.set(__self__, "scope_count", scope_count)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "state_message", state_message)
        pulumi.set(__self__, "tier", tier)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter(name="defaultResourceDiscoveryAssociationId")
    def default_resource_discovery_association_id(self) -> _builtins.str:
        return pulumi.get(self, "default_resource_discovery_association_id")

    @_builtins.property
    @pulumi.getter(name="defaultResourceDiscoveryId")
    def default_resource_discovery_id(self) -> _builtins.str:
        return pulumi.get(self, "default_resource_discovery_id")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="enablePrivateGua")
    def enable_private_gua(self) -> _builtins.bool:
        return pulumi.get(self, "enable_private_gua")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="ipamRegion")
    def ipam_region(self) -> _builtins.str:
        return pulumi.get(self, "ipam_region")

    @_builtins.property
    @pulumi.getter(name="meteredAccount")
    def metered_account(self) -> _builtins.str:
        return pulumi.get(self, "metered_account")

    @_builtins.property
    @pulumi.getter(name="operatingRegions")
    def operating_regions(self) -> Sequence['outputs.GetVpcIpamsIpamOperatingRegionResult']:
        return pulumi.get(self, "operating_regions")

    @_builtins.property
    @pulumi.getter(name="ownerId")
    def owner_id(self) -> _builtins.str:
        return pulumi.get(self, "owner_id")

    @_builtins.property
    @pulumi.getter(name="privateDefaultScopeId")
    def private_default_scope_id(self) -> _builtins.str:
        return pulumi.get(self, "private_default_scope_id")

    @_builtins.property
    @pulumi.getter(name="publicDefaultScopeId")
    def public_default_scope_id(self) -> _builtins.str:
        return pulumi.get(self, "public_default_scope_id")

    @_builtins.property
    @pulumi.getter(name="resourceDiscoveryAssociationCount")
    def resource_discovery_association_count(self) -> _builtins.int:
        return pulumi.get(self, "resource_discovery_association_count")

    @_builtins.property
    @pulumi.getter(name="scopeCount")
    def scope_count(self) -> _builtins.int:
        return pulumi.get(self, "scope_count")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="stateMessage")
    def state_message(self) -> _builtins.str:
        return pulumi.get(self, "state_message")

    @_builtins.property
    @pulumi.getter
    def tier(self) -> _builtins.str:
        return pulumi.get(self, "tier")


@pulumi.output_type
class GetVpcIpamsIpamOperatingRegionResult(dict):
    def __init__(__self__, *,
                 region_name: _builtins.str):
        pulumi.set(__self__, "region_name", region_name)

    @_builtins.property
    @pulumi.getter(name="regionName")
    def region_name(self) -> _builtins.str:
        return pulumi.get(self, "region_name")


@pulumi.output_type
class GetVpcPeeringConnectionCidrBlockSetResult(dict):
    def __init__(__self__, *,
                 cidr_block: _builtins.str):
        pulumi.set(__self__, "cidr_block", cidr_block)

    @_builtins.property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> _builtins.str:
        return pulumi.get(self, "cidr_block")


@pulumi.output_type
class GetVpcPeeringConnectionFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetVpcPeeringConnectionIpv6CidrBlockSetResult(dict):
    def __init__(__self__, *,
                 ipv6_cidr_block: _builtins.str):
        pulumi.set(__self__, "ipv6_cidr_block", ipv6_cidr_block)

    @_builtins.property
    @pulumi.getter(name="ipv6CidrBlock")
    def ipv6_cidr_block(self) -> _builtins.str:
        return pulumi.get(self, "ipv6_cidr_block")


@pulumi.output_type
class GetVpcPeeringConnectionPeerCidrBlockSetResult(dict):
    def __init__(__self__, *,
                 cidr_block: _builtins.str):
        pulumi.set(__self__, "cidr_block", cidr_block)

    @_builtins.property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> _builtins.str:
        return pulumi.get(self, "cidr_block")


@pulumi.output_type
class GetVpcPeeringConnectionPeerIpv6CidrBlockSetResult(dict):
    def __init__(__self__, *,
                 ipv6_cidr_block: _builtins.str):
        pulumi.set(__self__, "ipv6_cidr_block", ipv6_cidr_block)

    @_builtins.property
    @pulumi.getter(name="ipv6CidrBlock")
    def ipv6_cidr_block(self) -> _builtins.str:
        return pulumi.get(self, "ipv6_cidr_block")


@pulumi.output_type
class GetVpcPeeringConnectionsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetVpcsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetVpnConnectionFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetVpnConnectionRouteResult(dict):
    def __init__(__self__, *,
                 destination_cidr_block: _builtins.str,
                 source: _builtins.str,
                 state: _builtins.str):
        pulumi.set(__self__, "destination_cidr_block", destination_cidr_block)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="destinationCidrBlock")
    def destination_cidr_block(self) -> _builtins.str:
        return pulumi.get(self, "destination_cidr_block")

    @_builtins.property
    @pulumi.getter
    def source(self) -> _builtins.str:
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        return pulumi.get(self, "state")


@pulumi.output_type
class GetVpnConnectionVgwTelemetryResult(dict):
    def __init__(__self__, *,
                 accepted_route_count: _builtins.int,
                 last_status_change: _builtins.str,
                 outside_ip_address: _builtins.str,
                 status: _builtins.str,
                 status_message: _builtins.str):
        pulumi.set(__self__, "accepted_route_count", accepted_route_count)
        pulumi.set(__self__, "last_status_change", last_status_change)
        pulumi.set(__self__, "outside_ip_address", outside_ip_address)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "status_message", status_message)

    @_builtins.property
    @pulumi.getter(name="acceptedRouteCount")
    def accepted_route_count(self) -> _builtins.int:
        return pulumi.get(self, "accepted_route_count")

    @_builtins.property
    @pulumi.getter(name="lastStatusChange")
    def last_status_change(self) -> _builtins.str:
        return pulumi.get(self, "last_status_change")

    @_builtins.property
    @pulumi.getter(name="outsideIpAddress")
    def outside_ip_address(self) -> _builtins.str:
        return pulumi.get(self, "outside_ip_address")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="statusMessage")
    def status_message(self) -> _builtins.str:
        return pulumi.get(self, "status_message")


@pulumi.output_type
class GetVpnGatewayFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


