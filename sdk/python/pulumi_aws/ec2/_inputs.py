# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from ._enums import *

__all__ = [
    'AmiCopyEbsBlockDeviceArgs',
    'AmiCopyEphemeralBlockDeviceArgs',
    'AmiEbsBlockDeviceArgs',
    'AmiEphemeralBlockDeviceArgs',
    'AmiFromInstanceEbsBlockDeviceArgs',
    'AmiFromInstanceEphemeralBlockDeviceArgs',
    'DefaultNetworkAclEgressArgs',
    'DefaultNetworkAclIngressArgs',
    'DefaultRouteTableRouteArgs',
    'DefaultSecurityGroupEgressArgs',
    'DefaultSecurityGroupIngressArgs',
    'FleetLaunchTemplateConfigArgs',
    'FleetLaunchTemplateConfigLaunchTemplateSpecificationArgs',
    'FleetLaunchTemplateConfigOverrideArgs',
    'FleetOnDemandOptionsArgs',
    'FleetSpotOptionsArgs',
    'FleetSpotOptionsMaintenanceStrategiesArgs',
    'FleetSpotOptionsMaintenanceStrategiesCapacityRebalanceArgs',
    'FleetTargetCapacitySpecificationArgs',
    'FlowLogDestinationOptionsArgs',
    'InstanceCapacityReservationSpecificationArgs',
    'InstanceCapacityReservationSpecificationCapacityReservationTargetArgs',
    'InstanceCreditSpecificationArgs',
    'InstanceEbsBlockDeviceArgs',
    'InstanceEnclaveOptionsArgs',
    'InstanceEphemeralBlockDeviceArgs',
    'InstanceLaunchTemplateArgs',
    'InstanceMetadataOptionsArgs',
    'InstanceNetworkInterfaceArgs',
    'InstanceRootBlockDeviceArgs',
    'LaunchConfigurationEbsBlockDeviceArgs',
    'LaunchConfigurationEphemeralBlockDeviceArgs',
    'LaunchConfigurationMetadataOptionsArgs',
    'LaunchConfigurationRootBlockDeviceArgs',
    'LaunchTemplateBlockDeviceMappingArgs',
    'LaunchTemplateBlockDeviceMappingEbsArgs',
    'LaunchTemplateCapacityReservationSpecificationArgs',
    'LaunchTemplateCapacityReservationSpecificationCapacityReservationTargetArgs',
    'LaunchTemplateCpuOptionsArgs',
    'LaunchTemplateCreditSpecificationArgs',
    'LaunchTemplateElasticGpuSpecificationArgs',
    'LaunchTemplateElasticInferenceAcceleratorArgs',
    'LaunchTemplateEnclaveOptionsArgs',
    'LaunchTemplateHibernationOptionsArgs',
    'LaunchTemplateIamInstanceProfileArgs',
    'LaunchTemplateInstanceMarketOptionsArgs',
    'LaunchTemplateInstanceMarketOptionsSpotOptionsArgs',
    'LaunchTemplateLicenseSpecificationArgs',
    'LaunchTemplateMetadataOptionsArgs',
    'LaunchTemplateMonitoringArgs',
    'LaunchTemplateNetworkInterfaceArgs',
    'LaunchTemplatePlacementArgs',
    'LaunchTemplateTagSpecificationArgs',
    'ManagedPrefixListEntryArgs',
    'NetworkAclEgressArgs',
    'NetworkAclIngressArgs',
    'NetworkInterfaceAttachmentArgs',
    'PeeringConnectionOptionsAccepterArgs',
    'PeeringConnectionOptionsRequesterArgs',
    'RouteTableRouteArgs',
    'SecurityGroupEgressArgs',
    'SecurityGroupIngressArgs',
    'SpotFleetRequestLaunchSpecificationArgs',
    'SpotFleetRequestLaunchSpecificationEbsBlockDeviceArgs',
    'SpotFleetRequestLaunchSpecificationEphemeralBlockDeviceArgs',
    'SpotFleetRequestLaunchSpecificationRootBlockDeviceArgs',
    'SpotFleetRequestLaunchTemplateConfigArgs',
    'SpotFleetRequestLaunchTemplateConfigLaunchTemplateSpecificationArgs',
    'SpotFleetRequestLaunchTemplateConfigOverrideArgs',
    'SpotFleetRequestSpotMaintenanceStrategiesArgs',
    'SpotFleetRequestSpotMaintenanceStrategiesCapacityRebalanceArgs',
    'SpotInstanceRequestCapacityReservationSpecificationArgs',
    'SpotInstanceRequestCapacityReservationSpecificationCapacityReservationTargetArgs',
    'SpotInstanceRequestCreditSpecificationArgs',
    'SpotInstanceRequestEbsBlockDeviceArgs',
    'SpotInstanceRequestEnclaveOptionsArgs',
    'SpotInstanceRequestEphemeralBlockDeviceArgs',
    'SpotInstanceRequestLaunchTemplateArgs',
    'SpotInstanceRequestMetadataOptionsArgs',
    'SpotInstanceRequestNetworkInterfaceArgs',
    'SpotInstanceRequestRootBlockDeviceArgs',
    'TrafficMirrorFilterRuleDestinationPortRangeArgs',
    'TrafficMirrorFilterRuleSourcePortRangeArgs',
    'VpcEndpointDnsEntryArgs',
    'VpcEndpointServicePrivateDnsNameConfigurationArgs',
    'VpcPeeringConnectionAccepterArgs',
    'VpcPeeringConnectionAccepterAccepterArgs',
    'VpcPeeringConnectionAccepterRequesterArgs',
    'VpcPeeringConnectionRequesterArgs',
    'VpnConnectionRouteArgs',
    'VpnConnectionVgwTelemetryArgs',
    'GetAmiFilterArgs',
    'GetAmiIdsFilterArgs',
    'GetCoipPoolFilterArgs',
    'GetCoipPoolsFilterArgs',
    'GetCustomerGatewayFilterArgs',
    'GetDedicatedHostFilterArgs',
    'GetElasticIpFilterArgs',
    'GetInstanceFilterArgs',
    'GetInstanceTypeFpgaArgs',
    'GetInstanceTypeGpusArgs',
    'GetInstanceTypeInferenceAcceleratorArgs',
    'GetInstanceTypeInstanceDiskArgs',
    'GetInstanceTypeOfferingFilterArgs',
    'GetInstanceTypeOfferingsFilterArgs',
    'GetInstancesFilterArgs',
    'GetInternetGatewayFilterArgs',
    'GetLaunchTemplateFilterArgs',
    'GetLocalGatewayFilterArgs',
    'GetLocalGatewayRouteTableFilterArgs',
    'GetLocalGatewayRouteTablesFilterArgs',
    'GetLocalGatewayVirtualInterfaceFilterArgs',
    'GetLocalGatewayVirtualInterfaceGroupFilterArgs',
    'GetLocalGatewayVirtualInterfaceGroupsFilterArgs',
    'GetLocalGatewaysFilterArgs',
    'GetManagedPrefixListFilterArgs',
    'GetNatGatewayFilterArgs',
    'GetNetworkAclsFilterArgs',
    'GetNetworkInterfaceFilterArgs',
    'GetNetworkInterfacesFilterArgs',
    'GetPrefixListFilterArgs',
    'GetRouteTableFilterArgs',
    'GetRouteTablesFilterArgs',
    'GetSecurityGroupFilterArgs',
    'GetSecurityGroupsFilterArgs',
    'GetSpotPriceFilterArgs',
    'GetSubnetFilterArgs',
    'GetSubnetIdsFilterArgs',
    'GetSubnetsFilterArgs',
    'GetTransitGatewayRouteTablesFilterArgs',
    'GetVpcDhcpOptionsFilterArgs',
    'GetVpcEndpointFilterArgs',
    'GetVpcEndpointServiceFilterArgs',
    'GetVpcFilterArgs',
    'GetVpcPeeringConnectionFilterArgs',
    'GetVpcPeeringConnectionsFilterArgs',
    'GetVpcsFilterArgs',
    'GetVpnGatewayFilterArgs',
]

@pulumi.input_type
class AmiCopyEbsBlockDeviceArgs:
    def __init__(__self__, *,
                 delete_on_termination: Optional[pulumi.Input[bool]] = None,
                 device_name: Optional[pulumi.Input[str]] = None,
                 encrypted: Optional[pulumi.Input[bool]] = None,
                 iops: Optional[pulumi.Input[int]] = None,
                 snapshot_id: Optional[pulumi.Input[str]] = None,
                 throughput: Optional[pulumi.Input[int]] = None,
                 volume_size: Optional[pulumi.Input[int]] = None,
                 volume_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] delete_on_termination: Boolean controlling whether the EBS volumes created to
               support each created instance will be deleted once that instance is terminated.
        :param pulumi.Input[str] device_name: The path at which the device is exposed to created instances.
        :param pulumi.Input[bool] encrypted: Boolean controlling whether the created EBS volumes will be encrypted. Can't be used with `snapshot_id`.
        :param pulumi.Input[int] iops: Number of I/O operations per second the
               created volumes will support.
        :param pulumi.Input[str] snapshot_id: The id of an EBS snapshot that will be used to initialize the created
               EBS volumes. If set, the `volume_size` attribute must be at least as large as the referenced
               snapshot.
        :param pulumi.Input[int] throughput: The throughput that the EBS volume supports, in MiB/s. Only valid for `volume_type` of `gp3`.
        :param pulumi.Input[int] volume_size: The size of created volumes in GiB.
               If `snapshot_id` is set and `volume_size` is omitted then the volume will have the same size
               as the selected snapshot.
        :param pulumi.Input[str] volume_type: The type of EBS volume to create. Can be `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1` or `st1` (Default: `standard`).
        """
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean controlling whether the EBS volumes created to
        support each created instance will be deleted once that instance is terminated.
        """
        return pulumi.get(self, "delete_on_termination")

    @delete_on_termination.setter
    def delete_on_termination(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delete_on_termination", value)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[pulumi.Input[str]]:
        """
        The path at which the device is exposed to created instances.
        """
        return pulumi.get(self, "device_name")

    @device_name.setter
    def device_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "device_name", value)

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean controlling whether the created EBS volumes will be encrypted. Can't be used with `snapshot_id`.
        """
        return pulumi.get(self, "encrypted")

    @encrypted.setter
    def encrypted(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "encrypted", value)

    @property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[int]]:
        """
        Number of I/O operations per second the
        created volumes will support.
        """
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "iops", value)

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[pulumi.Input[str]]:
        """
        The id of an EBS snapshot that will be used to initialize the created
        EBS volumes. If set, the `volume_size` attribute must be at least as large as the referenced
        snapshot.
        """
        return pulumi.get(self, "snapshot_id")

    @snapshot_id.setter
    def snapshot_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "snapshot_id", value)

    @property
    @pulumi.getter
    def throughput(self) -> Optional[pulumi.Input[int]]:
        """
        The throughput that the EBS volume supports, in MiB/s. Only valid for `volume_type` of `gp3`.
        """
        return pulumi.get(self, "throughput")

    @throughput.setter
    def throughput(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "throughput", value)

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[pulumi.Input[int]]:
        """
        The size of created volumes in GiB.
        If `snapshot_id` is set and `volume_size` is omitted then the volume will have the same size
        as the selected snapshot.
        """
        return pulumi.get(self, "volume_size")

    @volume_size.setter
    def volume_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "volume_size", value)

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of EBS volume to create. Can be `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1` or `st1` (Default: `standard`).
        """
        return pulumi.get(self, "volume_type")

    @volume_type.setter
    def volume_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volume_type", value)


@pulumi.input_type
class AmiCopyEphemeralBlockDeviceArgs:
    def __init__(__self__, *,
                 device_name: Optional[pulumi.Input[str]] = None,
                 virtual_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] device_name: The path at which the device is exposed to created instances.
        :param pulumi.Input[str] virtual_name: A name for the ephemeral device, of the form "ephemeralN" where
               *N* is a volume number starting from zero.
        """
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if virtual_name is not None:
            pulumi.set(__self__, "virtual_name", virtual_name)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[pulumi.Input[str]]:
        """
        The path at which the device is exposed to created instances.
        """
        return pulumi.get(self, "device_name")

    @device_name.setter
    def device_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "device_name", value)

    @property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> Optional[pulumi.Input[str]]:
        """
        A name for the ephemeral device, of the form "ephemeralN" where
        *N* is a volume number starting from zero.
        """
        return pulumi.get(self, "virtual_name")

    @virtual_name.setter
    def virtual_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "virtual_name", value)


@pulumi.input_type
class AmiEbsBlockDeviceArgs:
    def __init__(__self__, *,
                 device_name: pulumi.Input[str],
                 delete_on_termination: Optional[pulumi.Input[bool]] = None,
                 encrypted: Optional[pulumi.Input[bool]] = None,
                 iops: Optional[pulumi.Input[int]] = None,
                 snapshot_id: Optional[pulumi.Input[str]] = None,
                 throughput: Optional[pulumi.Input[int]] = None,
                 volume_size: Optional[pulumi.Input[int]] = None,
                 volume_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] device_name: The path at which the device is exposed to created instances.
        :param pulumi.Input[bool] delete_on_termination: Boolean controlling whether the EBS volumes created to
               support each created instance will be deleted once that instance is terminated.
        :param pulumi.Input[bool] encrypted: Boolean controlling whether the created EBS volumes will be encrypted. Can't be used with `snapshot_id`.
        :param pulumi.Input[int] iops: Number of I/O operations per second the
               created volumes will support.
        :param pulumi.Input[str] snapshot_id: The id of an EBS snapshot that will be used to initialize the created
               EBS volumes. If set, the `volume_size` attribute must be at least as large as the referenced
               snapshot.
        :param pulumi.Input[int] throughput: The throughput that the EBS volume supports, in MiB/s. Only valid for `volume_type` of `gp3`.
        :param pulumi.Input[int] volume_size: The size of created volumes in GiB.
               If `snapshot_id` is set and `volume_size` is omitted then the volume will have the same size
               as the selected snapshot.
        :param pulumi.Input[str] volume_type: The type of EBS volume to create. Can be `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1` or `st1` (Default: `standard`).
        """
        pulumi.set(__self__, "device_name", device_name)
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> pulumi.Input[str]:
        """
        The path at which the device is exposed to created instances.
        """
        return pulumi.get(self, "device_name")

    @device_name.setter
    def device_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "device_name", value)

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean controlling whether the EBS volumes created to
        support each created instance will be deleted once that instance is terminated.
        """
        return pulumi.get(self, "delete_on_termination")

    @delete_on_termination.setter
    def delete_on_termination(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delete_on_termination", value)

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean controlling whether the created EBS volumes will be encrypted. Can't be used with `snapshot_id`.
        """
        return pulumi.get(self, "encrypted")

    @encrypted.setter
    def encrypted(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "encrypted", value)

    @property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[int]]:
        """
        Number of I/O operations per second the
        created volumes will support.
        """
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "iops", value)

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[pulumi.Input[str]]:
        """
        The id of an EBS snapshot that will be used to initialize the created
        EBS volumes. If set, the `volume_size` attribute must be at least as large as the referenced
        snapshot.
        """
        return pulumi.get(self, "snapshot_id")

    @snapshot_id.setter
    def snapshot_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "snapshot_id", value)

    @property
    @pulumi.getter
    def throughput(self) -> Optional[pulumi.Input[int]]:
        """
        The throughput that the EBS volume supports, in MiB/s. Only valid for `volume_type` of `gp3`.
        """
        return pulumi.get(self, "throughput")

    @throughput.setter
    def throughput(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "throughput", value)

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[pulumi.Input[int]]:
        """
        The size of created volumes in GiB.
        If `snapshot_id` is set and `volume_size` is omitted then the volume will have the same size
        as the selected snapshot.
        """
        return pulumi.get(self, "volume_size")

    @volume_size.setter
    def volume_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "volume_size", value)

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of EBS volume to create. Can be `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1` or `st1` (Default: `standard`).
        """
        return pulumi.get(self, "volume_type")

    @volume_type.setter
    def volume_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volume_type", value)


@pulumi.input_type
class AmiEphemeralBlockDeviceArgs:
    def __init__(__self__, *,
                 device_name: pulumi.Input[str],
                 virtual_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] device_name: The path at which the device is exposed to created instances.
        :param pulumi.Input[str] virtual_name: A name for the ephemeral device, of the form "ephemeralN" where
               *N* is a volume number starting from zero.
        """
        pulumi.set(__self__, "device_name", device_name)
        pulumi.set(__self__, "virtual_name", virtual_name)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> pulumi.Input[str]:
        """
        The path at which the device is exposed to created instances.
        """
        return pulumi.get(self, "device_name")

    @device_name.setter
    def device_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "device_name", value)

    @property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> pulumi.Input[str]:
        """
        A name for the ephemeral device, of the form "ephemeralN" where
        *N* is a volume number starting from zero.
        """
        return pulumi.get(self, "virtual_name")

    @virtual_name.setter
    def virtual_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "virtual_name", value)


@pulumi.input_type
class AmiFromInstanceEbsBlockDeviceArgs:
    def __init__(__self__, *,
                 delete_on_termination: Optional[pulumi.Input[bool]] = None,
                 device_name: Optional[pulumi.Input[str]] = None,
                 encrypted: Optional[pulumi.Input[bool]] = None,
                 iops: Optional[pulumi.Input[int]] = None,
                 snapshot_id: Optional[pulumi.Input[str]] = None,
                 throughput: Optional[pulumi.Input[int]] = None,
                 volume_size: Optional[pulumi.Input[int]] = None,
                 volume_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] delete_on_termination: Boolean controlling whether the EBS volumes created to
               support each created instance will be deleted once that instance is terminated.
        :param pulumi.Input[str] device_name: The path at which the device is exposed to created instances.
        :param pulumi.Input[bool] encrypted: Boolean controlling whether the created EBS volumes will be encrypted. Can't be used with `snapshot_id`.
        :param pulumi.Input[int] iops: Number of I/O operations per second the
               created volumes will support.
        :param pulumi.Input[str] snapshot_id: The id of an EBS snapshot that will be used to initialize the created
               EBS volumes. If set, the `volume_size` attribute must be at least as large as the referenced
               snapshot.
        :param pulumi.Input[int] throughput: The throughput that the EBS volume supports, in MiB/s. Only valid for `volume_type` of `gp3`.
        :param pulumi.Input[int] volume_size: The size of created volumes in GiB.
               If `snapshot_id` is set and `volume_size` is omitted then the volume will have the same size
               as the selected snapshot.
        :param pulumi.Input[str] volume_type: The type of EBS volume to create. Can be `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1` or `st1` (Default: `standard`).
        """
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean controlling whether the EBS volumes created to
        support each created instance will be deleted once that instance is terminated.
        """
        return pulumi.get(self, "delete_on_termination")

    @delete_on_termination.setter
    def delete_on_termination(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delete_on_termination", value)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[pulumi.Input[str]]:
        """
        The path at which the device is exposed to created instances.
        """
        return pulumi.get(self, "device_name")

    @device_name.setter
    def device_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "device_name", value)

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean controlling whether the created EBS volumes will be encrypted. Can't be used with `snapshot_id`.
        """
        return pulumi.get(self, "encrypted")

    @encrypted.setter
    def encrypted(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "encrypted", value)

    @property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[int]]:
        """
        Number of I/O operations per second the
        created volumes will support.
        """
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "iops", value)

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[pulumi.Input[str]]:
        """
        The id of an EBS snapshot that will be used to initialize the created
        EBS volumes. If set, the `volume_size` attribute must be at least as large as the referenced
        snapshot.
        """
        return pulumi.get(self, "snapshot_id")

    @snapshot_id.setter
    def snapshot_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "snapshot_id", value)

    @property
    @pulumi.getter
    def throughput(self) -> Optional[pulumi.Input[int]]:
        """
        The throughput that the EBS volume supports, in MiB/s. Only valid for `volume_type` of `gp3`.
        """
        return pulumi.get(self, "throughput")

    @throughput.setter
    def throughput(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "throughput", value)

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[pulumi.Input[int]]:
        """
        The size of created volumes in GiB.
        If `snapshot_id` is set and `volume_size` is omitted then the volume will have the same size
        as the selected snapshot.
        """
        return pulumi.get(self, "volume_size")

    @volume_size.setter
    def volume_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "volume_size", value)

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of EBS volume to create. Can be `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1` or `st1` (Default: `standard`).
        """
        return pulumi.get(self, "volume_type")

    @volume_type.setter
    def volume_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volume_type", value)


@pulumi.input_type
class AmiFromInstanceEphemeralBlockDeviceArgs:
    def __init__(__self__, *,
                 device_name: Optional[pulumi.Input[str]] = None,
                 virtual_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] device_name: The path at which the device is exposed to created instances.
        :param pulumi.Input[str] virtual_name: A name for the ephemeral device, of the form "ephemeralN" where
               *N* is a volume number starting from zero.
        """
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if virtual_name is not None:
            pulumi.set(__self__, "virtual_name", virtual_name)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[pulumi.Input[str]]:
        """
        The path at which the device is exposed to created instances.
        """
        return pulumi.get(self, "device_name")

    @device_name.setter
    def device_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "device_name", value)

    @property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> Optional[pulumi.Input[str]]:
        """
        A name for the ephemeral device, of the form "ephemeralN" where
        *N* is a volume number starting from zero.
        """
        return pulumi.get(self, "virtual_name")

    @virtual_name.setter
    def virtual_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "virtual_name", value)


@pulumi.input_type
class DefaultNetworkAclEgressArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 from_port: pulumi.Input[int],
                 protocol: pulumi.Input[str],
                 rule_no: pulumi.Input[int],
                 to_port: pulumi.Input[int],
                 cidr_block: Optional[pulumi.Input[str]] = None,
                 icmp_code: Optional[pulumi.Input[int]] = None,
                 icmp_type: Optional[pulumi.Input[int]] = None,
                 ipv6_cidr_block: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: The action to take.
        :param pulumi.Input[int] from_port: The from port to match.
        :param pulumi.Input[str] protocol: The protocol to match. If using the -1 'all' protocol, you must specify a from and to port of 0.
        :param pulumi.Input[int] rule_no: The rule number. Used for ordering.
        :param pulumi.Input[int] to_port: The to port to match.
        :param pulumi.Input[str] cidr_block: The CIDR block to match. This must be a valid network mask.
        :param pulumi.Input[int] icmp_code: The ICMP type code to be used. Default 0.
        :param pulumi.Input[int] icmp_type: The ICMP type to be used. Default 0.
        :param pulumi.Input[str] ipv6_cidr_block: The IPv6 CIDR block.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "from_port", from_port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "rule_no", rule_no)
        pulumi.set(__self__, "to_port", to_port)
        if cidr_block is not None:
            pulumi.set(__self__, "cidr_block", cidr_block)
        if icmp_code is not None:
            pulumi.set(__self__, "icmp_code", icmp_code)
        if icmp_type is not None:
            pulumi.set(__self__, "icmp_type", icmp_type)
        if ipv6_cidr_block is not None:
            pulumi.set(__self__, "ipv6_cidr_block", ipv6_cidr_block)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        The action to take.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> pulumi.Input[int]:
        """
        The from port to match.
        """
        return pulumi.get(self, "from_port")

    @from_port.setter
    def from_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "from_port", value)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        The protocol to match. If using the -1 'all' protocol, you must specify a from and to port of 0.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="ruleNo")
    def rule_no(self) -> pulumi.Input[int]:
        """
        The rule number. Used for ordering.
        """
        return pulumi.get(self, "rule_no")

    @rule_no.setter
    def rule_no(self, value: pulumi.Input[int]):
        pulumi.set(self, "rule_no", value)

    @property
    @pulumi.getter(name="toPort")
    def to_port(self) -> pulumi.Input[int]:
        """
        The to port to match.
        """
        return pulumi.get(self, "to_port")

    @to_port.setter
    def to_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "to_port", value)

    @property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> Optional[pulumi.Input[str]]:
        """
        The CIDR block to match. This must be a valid network mask.
        """
        return pulumi.get(self, "cidr_block")

    @cidr_block.setter
    def cidr_block(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cidr_block", value)

    @property
    @pulumi.getter(name="icmpCode")
    def icmp_code(self) -> Optional[pulumi.Input[int]]:
        """
        The ICMP type code to be used. Default 0.
        """
        return pulumi.get(self, "icmp_code")

    @icmp_code.setter
    def icmp_code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "icmp_code", value)

    @property
    @pulumi.getter(name="icmpType")
    def icmp_type(self) -> Optional[pulumi.Input[int]]:
        """
        The ICMP type to be used. Default 0.
        """
        return pulumi.get(self, "icmp_type")

    @icmp_type.setter
    def icmp_type(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "icmp_type", value)

    @property
    @pulumi.getter(name="ipv6CidrBlock")
    def ipv6_cidr_block(self) -> Optional[pulumi.Input[str]]:
        """
        The IPv6 CIDR block.
        """
        return pulumi.get(self, "ipv6_cidr_block")

    @ipv6_cidr_block.setter
    def ipv6_cidr_block(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv6_cidr_block", value)


@pulumi.input_type
class DefaultNetworkAclIngressArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 from_port: pulumi.Input[int],
                 protocol: pulumi.Input[str],
                 rule_no: pulumi.Input[int],
                 to_port: pulumi.Input[int],
                 cidr_block: Optional[pulumi.Input[str]] = None,
                 icmp_code: Optional[pulumi.Input[int]] = None,
                 icmp_type: Optional[pulumi.Input[int]] = None,
                 ipv6_cidr_block: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: The action to take.
        :param pulumi.Input[int] from_port: The from port to match.
        :param pulumi.Input[str] protocol: The protocol to match. If using the -1 'all' protocol, you must specify a from and to port of 0.
        :param pulumi.Input[int] rule_no: The rule number. Used for ordering.
        :param pulumi.Input[int] to_port: The to port to match.
        :param pulumi.Input[str] cidr_block: The CIDR block to match. This must be a valid network mask.
        :param pulumi.Input[int] icmp_code: The ICMP type code to be used. Default 0.
        :param pulumi.Input[int] icmp_type: The ICMP type to be used. Default 0.
        :param pulumi.Input[str] ipv6_cidr_block: The IPv6 CIDR block.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "from_port", from_port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "rule_no", rule_no)
        pulumi.set(__self__, "to_port", to_port)
        if cidr_block is not None:
            pulumi.set(__self__, "cidr_block", cidr_block)
        if icmp_code is not None:
            pulumi.set(__self__, "icmp_code", icmp_code)
        if icmp_type is not None:
            pulumi.set(__self__, "icmp_type", icmp_type)
        if ipv6_cidr_block is not None:
            pulumi.set(__self__, "ipv6_cidr_block", ipv6_cidr_block)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        The action to take.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> pulumi.Input[int]:
        """
        The from port to match.
        """
        return pulumi.get(self, "from_port")

    @from_port.setter
    def from_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "from_port", value)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        The protocol to match. If using the -1 'all' protocol, you must specify a from and to port of 0.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="ruleNo")
    def rule_no(self) -> pulumi.Input[int]:
        """
        The rule number. Used for ordering.
        """
        return pulumi.get(self, "rule_no")

    @rule_no.setter
    def rule_no(self, value: pulumi.Input[int]):
        pulumi.set(self, "rule_no", value)

    @property
    @pulumi.getter(name="toPort")
    def to_port(self) -> pulumi.Input[int]:
        """
        The to port to match.
        """
        return pulumi.get(self, "to_port")

    @to_port.setter
    def to_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "to_port", value)

    @property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> Optional[pulumi.Input[str]]:
        """
        The CIDR block to match. This must be a valid network mask.
        """
        return pulumi.get(self, "cidr_block")

    @cidr_block.setter
    def cidr_block(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cidr_block", value)

    @property
    @pulumi.getter(name="icmpCode")
    def icmp_code(self) -> Optional[pulumi.Input[int]]:
        """
        The ICMP type code to be used. Default 0.
        """
        return pulumi.get(self, "icmp_code")

    @icmp_code.setter
    def icmp_code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "icmp_code", value)

    @property
    @pulumi.getter(name="icmpType")
    def icmp_type(self) -> Optional[pulumi.Input[int]]:
        """
        The ICMP type to be used. Default 0.
        """
        return pulumi.get(self, "icmp_type")

    @icmp_type.setter
    def icmp_type(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "icmp_type", value)

    @property
    @pulumi.getter(name="ipv6CidrBlock")
    def ipv6_cidr_block(self) -> Optional[pulumi.Input[str]]:
        """
        The IPv6 CIDR block.
        """
        return pulumi.get(self, "ipv6_cidr_block")

    @ipv6_cidr_block.setter
    def ipv6_cidr_block(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv6_cidr_block", value)


@pulumi.input_type
class DefaultRouteTableRouteArgs:
    def __init__(__self__, *,
                 cidr_block: Optional[pulumi.Input[str]] = None,
                 destination_prefix_list_id: Optional[pulumi.Input[str]] = None,
                 egress_only_gateway_id: Optional[pulumi.Input[str]] = None,
                 gateway_id: Optional[pulumi.Input[str]] = None,
                 instance_id: Optional[pulumi.Input[str]] = None,
                 ipv6_cidr_block: Optional[pulumi.Input[str]] = None,
                 nat_gateway_id: Optional[pulumi.Input[str]] = None,
                 network_interface_id: Optional[pulumi.Input[str]] = None,
                 transit_gateway_id: Optional[pulumi.Input[str]] = None,
                 vpc_endpoint_id: Optional[pulumi.Input[str]] = None,
                 vpc_peering_connection_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cidr_block: The CIDR block of the route.
        :param pulumi.Input[str] destination_prefix_list_id: The ID of a managed prefix list destination of the route.
        :param pulumi.Input[str] egress_only_gateway_id: Identifier of a VPC Egress Only Internet Gateway.
        :param pulumi.Input[str] gateway_id: Identifier of a VPC internet gateway or a virtual private gateway.
        :param pulumi.Input[str] instance_id: Identifier of an EC2 instance.
        :param pulumi.Input[str] ipv6_cidr_block: The Ipv6 CIDR block of the route
        :param pulumi.Input[str] nat_gateway_id: Identifier of a VPC NAT gateway.
        :param pulumi.Input[str] network_interface_id: Identifier of an EC2 network interface.
        :param pulumi.Input[str] transit_gateway_id: Identifier of an EC2 Transit Gateway.
        :param pulumi.Input[str] vpc_endpoint_id: Identifier of a VPC Endpoint. This route must be removed prior to VPC Endpoint deletion.
        :param pulumi.Input[str] vpc_peering_connection_id: Identifier of a VPC peering connection.
        """
        if cidr_block is not None:
            pulumi.set(__self__, "cidr_block", cidr_block)
        if destination_prefix_list_id is not None:
            pulumi.set(__self__, "destination_prefix_list_id", destination_prefix_list_id)
        if egress_only_gateway_id is not None:
            pulumi.set(__self__, "egress_only_gateway_id", egress_only_gateway_id)
        if gateway_id is not None:
            pulumi.set(__self__, "gateway_id", gateway_id)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if ipv6_cidr_block is not None:
            pulumi.set(__self__, "ipv6_cidr_block", ipv6_cidr_block)
        if nat_gateway_id is not None:
            pulumi.set(__self__, "nat_gateway_id", nat_gateway_id)
        if network_interface_id is not None:
            pulumi.set(__self__, "network_interface_id", network_interface_id)
        if transit_gateway_id is not None:
            pulumi.set(__self__, "transit_gateway_id", transit_gateway_id)
        if vpc_endpoint_id is not None:
            pulumi.set(__self__, "vpc_endpoint_id", vpc_endpoint_id)
        if vpc_peering_connection_id is not None:
            pulumi.set(__self__, "vpc_peering_connection_id", vpc_peering_connection_id)

    @property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> Optional[pulumi.Input[str]]:
        """
        The CIDR block of the route.
        """
        return pulumi.get(self, "cidr_block")

    @cidr_block.setter
    def cidr_block(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cidr_block", value)

    @property
    @pulumi.getter(name="destinationPrefixListId")
    def destination_prefix_list_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of a managed prefix list destination of the route.
        """
        return pulumi.get(self, "destination_prefix_list_id")

    @destination_prefix_list_id.setter
    def destination_prefix_list_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination_prefix_list_id", value)

    @property
    @pulumi.getter(name="egressOnlyGatewayId")
    def egress_only_gateway_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier of a VPC Egress Only Internet Gateway.
        """
        return pulumi.get(self, "egress_only_gateway_id")

    @egress_only_gateway_id.setter
    def egress_only_gateway_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "egress_only_gateway_id", value)

    @property
    @pulumi.getter(name="gatewayId")
    def gateway_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier of a VPC internet gateway or a virtual private gateway.
        """
        return pulumi.get(self, "gateway_id")

    @gateway_id.setter
    def gateway_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gateway_id", value)

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier of an EC2 instance.
        """
        return pulumi.get(self, "instance_id")

    @instance_id.setter
    def instance_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance_id", value)

    @property
    @pulumi.getter(name="ipv6CidrBlock")
    def ipv6_cidr_block(self) -> Optional[pulumi.Input[str]]:
        """
        The Ipv6 CIDR block of the route
        """
        return pulumi.get(self, "ipv6_cidr_block")

    @ipv6_cidr_block.setter
    def ipv6_cidr_block(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv6_cidr_block", value)

    @property
    @pulumi.getter(name="natGatewayId")
    def nat_gateway_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier of a VPC NAT gateway.
        """
        return pulumi.get(self, "nat_gateway_id")

    @nat_gateway_id.setter
    def nat_gateway_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "nat_gateway_id", value)

    @property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier of an EC2 network interface.
        """
        return pulumi.get(self, "network_interface_id")

    @network_interface_id.setter
    def network_interface_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_interface_id", value)

    @property
    @pulumi.getter(name="transitGatewayId")
    def transit_gateway_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier of an EC2 Transit Gateway.
        """
        return pulumi.get(self, "transit_gateway_id")

    @transit_gateway_id.setter
    def transit_gateway_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "transit_gateway_id", value)

    @property
    @pulumi.getter(name="vpcEndpointId")
    def vpc_endpoint_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier of a VPC Endpoint. This route must be removed prior to VPC Endpoint deletion.
        """
        return pulumi.get(self, "vpc_endpoint_id")

    @vpc_endpoint_id.setter
    def vpc_endpoint_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vpc_endpoint_id", value)

    @property
    @pulumi.getter(name="vpcPeeringConnectionId")
    def vpc_peering_connection_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier of a VPC peering connection.
        """
        return pulumi.get(self, "vpc_peering_connection_id")

    @vpc_peering_connection_id.setter
    def vpc_peering_connection_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vpc_peering_connection_id", value)


@pulumi.input_type
class DefaultSecurityGroupEgressArgs:
    def __init__(__self__, *,
                 from_port: pulumi.Input[int],
                 protocol: pulumi.Input[str],
                 to_port: pulumi.Input[int],
                 cidr_blocks: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 ipv6_cidr_blocks: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 prefix_list_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 security_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 self: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[int] from_port: Start port (or ICMP type number if protocol is `icmp`)
        :param pulumi.Input[str] protocol: Protocol. If you select a protocol of "-1" (semantically equivalent to `all`, which is not a valid value here), you must specify a `from_port` and `to_port` equal to `0`. If not `icmp`, `tcp`, `udp`, or `-1` use the [protocol number](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml).
        :param pulumi.Input[int] to_port: End range port (or ICMP code if protocol is `icmp`).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] cidr_blocks: List of CIDR blocks.
        :param pulumi.Input[str] description: Description of this rule.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ipv6_cidr_blocks: List of IPv6 CIDR blocks.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] prefix_list_ids: List of prefix list IDs (for allowing access to VPC endpoints)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_groups: List of security group Group Names if using EC2-Classic, or Group IDs if using a VPC.
        :param pulumi.Input[bool] self: Whether the security group itself will be added as a source to this egress rule.
        """
        pulumi.set(__self__, "from_port", from_port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "to_port", to_port)
        if cidr_blocks is not None:
            pulumi.set(__self__, "cidr_blocks", cidr_blocks)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if ipv6_cidr_blocks is not None:
            pulumi.set(__self__, "ipv6_cidr_blocks", ipv6_cidr_blocks)
        if prefix_list_ids is not None:
            pulumi.set(__self__, "prefix_list_ids", prefix_list_ids)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if self is not None:
            pulumi.set(__self__, "self", self)

    @property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> pulumi.Input[int]:
        """
        Start port (or ICMP type number if protocol is `icmp`)
        """
        return pulumi.get(self, "from_port")

    @from_port.setter
    def from_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "from_port", value)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        Protocol. If you select a protocol of "-1" (semantically equivalent to `all`, which is not a valid value here), you must specify a `from_port` and `to_port` equal to `0`. If not `icmp`, `tcp`, `udp`, or `-1` use the [protocol number](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml).
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="toPort")
    def to_port(self) -> pulumi.Input[int]:
        """
        End range port (or ICMP code if protocol is `icmp`).
        """
        return pulumi.get(self, "to_port")

    @to_port.setter
    def to_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "to_port", value)

    @property
    @pulumi.getter(name="cidrBlocks")
    def cidr_blocks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of CIDR blocks.
        """
        return pulumi.get(self, "cidr_blocks")

    @cidr_blocks.setter
    def cidr_blocks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "cidr_blocks", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Description of this rule.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="ipv6CidrBlocks")
    def ipv6_cidr_blocks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of IPv6 CIDR blocks.
        """
        return pulumi.get(self, "ipv6_cidr_blocks")

    @ipv6_cidr_blocks.setter
    def ipv6_cidr_blocks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ipv6_cidr_blocks", value)

    @property
    @pulumi.getter(name="prefixListIds")
    def prefix_list_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of prefix list IDs (for allowing access to VPC endpoints)
        """
        return pulumi.get(self, "prefix_list_ids")

    @prefix_list_ids.setter
    def prefix_list_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "prefix_list_ids", value)

    @property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of security group Group Names if using EC2-Classic, or Group IDs if using a VPC.
        """
        return pulumi.get(self, "security_groups")

    @security_groups.setter
    def security_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "security_groups", value)

    @property
    @pulumi.getter
    def self(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the security group itself will be added as a source to this egress rule.
        """
        return pulumi.get(self, "self")

    @self.setter
    def self(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "self", value)


@pulumi.input_type
class DefaultSecurityGroupIngressArgs:
    def __init__(__self__, *,
                 from_port: pulumi.Input[int],
                 protocol: pulumi.Input[str],
                 to_port: pulumi.Input[int],
                 cidr_blocks: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 ipv6_cidr_blocks: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 prefix_list_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 security_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 self: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[int] from_port: Start port (or ICMP type number if protocol is `icmp`)
        :param pulumi.Input[str] protocol: Protocol. If you select a protocol of "-1" (semantically equivalent to `all`, which is not a valid value here), you must specify a `from_port` and `to_port` equal to `0`. If not `icmp`, `tcp`, `udp`, or `-1` use the [protocol number](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml).
        :param pulumi.Input[int] to_port: End range port (or ICMP code if protocol is `icmp`).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] cidr_blocks: List of CIDR blocks.
        :param pulumi.Input[str] description: Description of this rule.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ipv6_cidr_blocks: List of IPv6 CIDR blocks.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] prefix_list_ids: List of prefix list IDs (for allowing access to VPC endpoints)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_groups: List of security group Group Names if using EC2-Classic, or Group IDs if using a VPC.
        :param pulumi.Input[bool] self: Whether the security group itself will be added as a source to this egress rule.
        """
        pulumi.set(__self__, "from_port", from_port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "to_port", to_port)
        if cidr_blocks is not None:
            pulumi.set(__self__, "cidr_blocks", cidr_blocks)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if ipv6_cidr_blocks is not None:
            pulumi.set(__self__, "ipv6_cidr_blocks", ipv6_cidr_blocks)
        if prefix_list_ids is not None:
            pulumi.set(__self__, "prefix_list_ids", prefix_list_ids)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if self is not None:
            pulumi.set(__self__, "self", self)

    @property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> pulumi.Input[int]:
        """
        Start port (or ICMP type number if protocol is `icmp`)
        """
        return pulumi.get(self, "from_port")

    @from_port.setter
    def from_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "from_port", value)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        Protocol. If you select a protocol of "-1" (semantically equivalent to `all`, which is not a valid value here), you must specify a `from_port` and `to_port` equal to `0`. If not `icmp`, `tcp`, `udp`, or `-1` use the [protocol number](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml).
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="toPort")
    def to_port(self) -> pulumi.Input[int]:
        """
        End range port (or ICMP code if protocol is `icmp`).
        """
        return pulumi.get(self, "to_port")

    @to_port.setter
    def to_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "to_port", value)

    @property
    @pulumi.getter(name="cidrBlocks")
    def cidr_blocks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of CIDR blocks.
        """
        return pulumi.get(self, "cidr_blocks")

    @cidr_blocks.setter
    def cidr_blocks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "cidr_blocks", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Description of this rule.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="ipv6CidrBlocks")
    def ipv6_cidr_blocks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of IPv6 CIDR blocks.
        """
        return pulumi.get(self, "ipv6_cidr_blocks")

    @ipv6_cidr_blocks.setter
    def ipv6_cidr_blocks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ipv6_cidr_blocks", value)

    @property
    @pulumi.getter(name="prefixListIds")
    def prefix_list_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of prefix list IDs (for allowing access to VPC endpoints)
        """
        return pulumi.get(self, "prefix_list_ids")

    @prefix_list_ids.setter
    def prefix_list_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "prefix_list_ids", value)

    @property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of security group Group Names if using EC2-Classic, or Group IDs if using a VPC.
        """
        return pulumi.get(self, "security_groups")

    @security_groups.setter
    def security_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "security_groups", value)

    @property
    @pulumi.getter
    def self(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the security group itself will be added as a source to this egress rule.
        """
        return pulumi.get(self, "self")

    @self.setter
    def self(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "self", value)


@pulumi.input_type
class FleetLaunchTemplateConfigArgs:
    def __init__(__self__, *,
                 launch_template_specification: pulumi.Input['FleetLaunchTemplateConfigLaunchTemplateSpecificationArgs'],
                 overrides: Optional[pulumi.Input[Sequence[pulumi.Input['FleetLaunchTemplateConfigOverrideArgs']]]] = None):
        """
        :param pulumi.Input['FleetLaunchTemplateConfigLaunchTemplateSpecificationArgs'] launch_template_specification: Nested argument containing EC2 Launch Template to use. Defined below.
        :param pulumi.Input[Sequence[pulumi.Input['FleetLaunchTemplateConfigOverrideArgs']]] overrides: Nested argument(s) containing parameters to override the same parameters in the Launch Template. Defined below.
        """
        pulumi.set(__self__, "launch_template_specification", launch_template_specification)
        if overrides is not None:
            pulumi.set(__self__, "overrides", overrides)

    @property
    @pulumi.getter(name="launchTemplateSpecification")
    def launch_template_specification(self) -> pulumi.Input['FleetLaunchTemplateConfigLaunchTemplateSpecificationArgs']:
        """
        Nested argument containing EC2 Launch Template to use. Defined below.
        """
        return pulumi.get(self, "launch_template_specification")

    @launch_template_specification.setter
    def launch_template_specification(self, value: pulumi.Input['FleetLaunchTemplateConfigLaunchTemplateSpecificationArgs']):
        pulumi.set(self, "launch_template_specification", value)

    @property
    @pulumi.getter
    def overrides(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FleetLaunchTemplateConfigOverrideArgs']]]]:
        """
        Nested argument(s) containing parameters to override the same parameters in the Launch Template. Defined below.
        """
        return pulumi.get(self, "overrides")

    @overrides.setter
    def overrides(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FleetLaunchTemplateConfigOverrideArgs']]]]):
        pulumi.set(self, "overrides", value)


@pulumi.input_type
class FleetLaunchTemplateConfigLaunchTemplateSpecificationArgs:
    def __init__(__self__, *,
                 version: pulumi.Input[str],
                 launch_template_id: Optional[pulumi.Input[str]] = None,
                 launch_template_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] version: Version number of the launch template.
        :param pulumi.Input[str] launch_template_id: ID of the launch template.
        :param pulumi.Input[str] launch_template_name: Name of the launch template.
        """
        pulumi.set(__self__, "version", version)
        if launch_template_id is not None:
            pulumi.set(__self__, "launch_template_id", launch_template_id)
        if launch_template_name is not None:
            pulumi.set(__self__, "launch_template_name", launch_template_name)

    @property
    @pulumi.getter
    def version(self) -> pulumi.Input[str]:
        """
        Version number of the launch template.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[str]):
        pulumi.set(self, "version", value)

    @property
    @pulumi.getter(name="launchTemplateId")
    def launch_template_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the launch template.
        """
        return pulumi.get(self, "launch_template_id")

    @launch_template_id.setter
    def launch_template_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "launch_template_id", value)

    @property
    @pulumi.getter(name="launchTemplateName")
    def launch_template_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the launch template.
        """
        return pulumi.get(self, "launch_template_name")

    @launch_template_name.setter
    def launch_template_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "launch_template_name", value)


@pulumi.input_type
class FleetLaunchTemplateConfigOverrideArgs:
    def __init__(__self__, *,
                 availability_zone: Optional[pulumi.Input[str]] = None,
                 instance_type: Optional[pulumi.Input[str]] = None,
                 max_price: Optional[pulumi.Input[str]] = None,
                 priority: Optional[pulumi.Input[float]] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None,
                 weighted_capacity: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[str] availability_zone: Availability Zone in which to launch the instances.
        :param pulumi.Input[str] instance_type: Instance type.
        :param pulumi.Input[str] max_price: Maximum price per unit hour that you are willing to pay for a Spot Instance.
        :param pulumi.Input[float] priority: Priority for the launch template override. If `on_demand_options` `allocation_strategy` is set to `prioritized`, EC2 Fleet uses priority to determine which launch template override to use first in fulfilling On-Demand capacity. The highest priority is launched first. The lower the number, the higher the priority. If no number is set, the launch template override has the lowest priority. Valid values are whole numbers starting at 0.
        :param pulumi.Input[str] subnet_id: ID of the subnet in which to launch the instances.
        :param pulumi.Input[float] weighted_capacity: Number of units provided by the specified instance type.
        """
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if max_price is not None:
            pulumi.set(__self__, "max_price", max_price)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if weighted_capacity is not None:
            pulumi.set(__self__, "weighted_capacity", weighted_capacity)

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[pulumi.Input[str]]:
        """
        Availability Zone in which to launch the instances.
        """
        return pulumi.get(self, "availability_zone")

    @availability_zone.setter
    def availability_zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability_zone", value)

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[pulumi.Input[str]]:
        """
        Instance type.
        """
        return pulumi.get(self, "instance_type")

    @instance_type.setter
    def instance_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance_type", value)

    @property
    @pulumi.getter(name="maxPrice")
    def max_price(self) -> Optional[pulumi.Input[str]]:
        """
        Maximum price per unit hour that you are willing to pay for a Spot Instance.
        """
        return pulumi.get(self, "max_price")

    @max_price.setter
    def max_price(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_price", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[float]]:
        """
        Priority for the launch template override. If `on_demand_options` `allocation_strategy` is set to `prioritized`, EC2 Fleet uses priority to determine which launch template override to use first in fulfilling On-Demand capacity. The highest priority is launched first. The lower the number, the higher the priority. If no number is set, the launch template override has the lowest priority. Valid values are whole numbers starting at 0.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the subnet in which to launch the instances.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter(name="weightedCapacity")
    def weighted_capacity(self) -> Optional[pulumi.Input[float]]:
        """
        Number of units provided by the specified instance type.
        """
        return pulumi.get(self, "weighted_capacity")

    @weighted_capacity.setter
    def weighted_capacity(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "weighted_capacity", value)


@pulumi.input_type
class FleetOnDemandOptionsArgs:
    def __init__(__self__, *,
                 allocation_strategy: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] allocation_strategy: How to allocate the target capacity across the Spot pools. Valid values: `diversified`, `lowestPrice`. Default: `lowestPrice`.
        """
        if allocation_strategy is not None:
            pulumi.set(__self__, "allocation_strategy", allocation_strategy)

    @property
    @pulumi.getter(name="allocationStrategy")
    def allocation_strategy(self) -> Optional[pulumi.Input[str]]:
        """
        How to allocate the target capacity across the Spot pools. Valid values: `diversified`, `lowestPrice`. Default: `lowestPrice`.
        """
        return pulumi.get(self, "allocation_strategy")

    @allocation_strategy.setter
    def allocation_strategy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "allocation_strategy", value)


@pulumi.input_type
class FleetSpotOptionsArgs:
    def __init__(__self__, *,
                 allocation_strategy: Optional[pulumi.Input[str]] = None,
                 instance_interruption_behavior: Optional[pulumi.Input[str]] = None,
                 instance_pools_to_use_count: Optional[pulumi.Input[int]] = None,
                 maintenance_strategies: Optional[pulumi.Input['FleetSpotOptionsMaintenanceStrategiesArgs']] = None):
        """
        :param pulumi.Input[str] allocation_strategy: How to allocate the target capacity across the Spot pools. Valid values: `diversified`, `lowestPrice`. Default: `lowestPrice`.
        :param pulumi.Input[str] instance_interruption_behavior: Behavior when a Spot Instance is interrupted. Valid values: `hibernate`, `stop`, `terminate`. Default: `terminate`.
        :param pulumi.Input[int] instance_pools_to_use_count: Number of Spot pools across which to allocate your target Spot capacity. Valid only when Spot `allocation_strategy` is set to `lowestPrice`. Default: `1`.
        :param pulumi.Input['FleetSpotOptionsMaintenanceStrategiesArgs'] maintenance_strategies: Nested argument containing maintenance strategies for managing your Spot Instances that are at an elevated risk of being interrupted. Defined below.
        """
        if allocation_strategy is not None:
            pulumi.set(__self__, "allocation_strategy", allocation_strategy)
        if instance_interruption_behavior is not None:
            pulumi.set(__self__, "instance_interruption_behavior", instance_interruption_behavior)
        if instance_pools_to_use_count is not None:
            pulumi.set(__self__, "instance_pools_to_use_count", instance_pools_to_use_count)
        if maintenance_strategies is not None:
            pulumi.set(__self__, "maintenance_strategies", maintenance_strategies)

    @property
    @pulumi.getter(name="allocationStrategy")
    def allocation_strategy(self) -> Optional[pulumi.Input[str]]:
        """
        How to allocate the target capacity across the Spot pools. Valid values: `diversified`, `lowestPrice`. Default: `lowestPrice`.
        """
        return pulumi.get(self, "allocation_strategy")

    @allocation_strategy.setter
    def allocation_strategy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "allocation_strategy", value)

    @property
    @pulumi.getter(name="instanceInterruptionBehavior")
    def instance_interruption_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        Behavior when a Spot Instance is interrupted. Valid values: `hibernate`, `stop`, `terminate`. Default: `terminate`.
        """
        return pulumi.get(self, "instance_interruption_behavior")

    @instance_interruption_behavior.setter
    def instance_interruption_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance_interruption_behavior", value)

    @property
    @pulumi.getter(name="instancePoolsToUseCount")
    def instance_pools_to_use_count(self) -> Optional[pulumi.Input[int]]:
        """
        Number of Spot pools across which to allocate your target Spot capacity. Valid only when Spot `allocation_strategy` is set to `lowestPrice`. Default: `1`.
        """
        return pulumi.get(self, "instance_pools_to_use_count")

    @instance_pools_to_use_count.setter
    def instance_pools_to_use_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "instance_pools_to_use_count", value)

    @property
    @pulumi.getter(name="maintenanceStrategies")
    def maintenance_strategies(self) -> Optional[pulumi.Input['FleetSpotOptionsMaintenanceStrategiesArgs']]:
        """
        Nested argument containing maintenance strategies for managing your Spot Instances that are at an elevated risk of being interrupted. Defined below.
        """
        return pulumi.get(self, "maintenance_strategies")

    @maintenance_strategies.setter
    def maintenance_strategies(self, value: Optional[pulumi.Input['FleetSpotOptionsMaintenanceStrategiesArgs']]):
        pulumi.set(self, "maintenance_strategies", value)


@pulumi.input_type
class FleetSpotOptionsMaintenanceStrategiesArgs:
    def __init__(__self__, *,
                 capacity_rebalance: Optional[pulumi.Input['FleetSpotOptionsMaintenanceStrategiesCapacityRebalanceArgs']] = None):
        """
        :param pulumi.Input['FleetSpotOptionsMaintenanceStrategiesCapacityRebalanceArgs'] capacity_rebalance: Nested argument containing the capacity rebalance for your fleet request. Defined below.
        """
        if capacity_rebalance is not None:
            pulumi.set(__self__, "capacity_rebalance", capacity_rebalance)

    @property
    @pulumi.getter(name="capacityRebalance")
    def capacity_rebalance(self) -> Optional[pulumi.Input['FleetSpotOptionsMaintenanceStrategiesCapacityRebalanceArgs']]:
        """
        Nested argument containing the capacity rebalance for your fleet request. Defined below.
        """
        return pulumi.get(self, "capacity_rebalance")

    @capacity_rebalance.setter
    def capacity_rebalance(self, value: Optional[pulumi.Input['FleetSpotOptionsMaintenanceStrategiesCapacityRebalanceArgs']]):
        pulumi.set(self, "capacity_rebalance", value)


@pulumi.input_type
class FleetSpotOptionsMaintenanceStrategiesCapacityRebalanceArgs:
    def __init__(__self__, *,
                 replacement_strategy: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] replacement_strategy: The replacement strategy to use. Only available for fleets of `type` set to `maintain`. Valid values: `launch`.
        """
        if replacement_strategy is not None:
            pulumi.set(__self__, "replacement_strategy", replacement_strategy)

    @property
    @pulumi.getter(name="replacementStrategy")
    def replacement_strategy(self) -> Optional[pulumi.Input[str]]:
        """
        The replacement strategy to use. Only available for fleets of `type` set to `maintain`. Valid values: `launch`.
        """
        return pulumi.get(self, "replacement_strategy")

    @replacement_strategy.setter
    def replacement_strategy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "replacement_strategy", value)


@pulumi.input_type
class FleetTargetCapacitySpecificationArgs:
    def __init__(__self__, *,
                 default_target_capacity_type: pulumi.Input[str],
                 total_target_capacity: pulumi.Input[int],
                 on_demand_target_capacity: Optional[pulumi.Input[int]] = None,
                 spot_target_capacity: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] default_target_capacity_type: Default target capacity type. Valid values: `on-demand`, `spot`.
        :param pulumi.Input[int] total_target_capacity: The number of units to request, filled using `default_target_capacity_type`.
        :param pulumi.Input[int] on_demand_target_capacity: The number of On-Demand units to request.
        :param pulumi.Input[int] spot_target_capacity: The number of Spot units to request.
        """
        pulumi.set(__self__, "default_target_capacity_type", default_target_capacity_type)
        pulumi.set(__self__, "total_target_capacity", total_target_capacity)
        if on_demand_target_capacity is not None:
            pulumi.set(__self__, "on_demand_target_capacity", on_demand_target_capacity)
        if spot_target_capacity is not None:
            pulumi.set(__self__, "spot_target_capacity", spot_target_capacity)

    @property
    @pulumi.getter(name="defaultTargetCapacityType")
    def default_target_capacity_type(self) -> pulumi.Input[str]:
        """
        Default target capacity type. Valid values: `on-demand`, `spot`.
        """
        return pulumi.get(self, "default_target_capacity_type")

    @default_target_capacity_type.setter
    def default_target_capacity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "default_target_capacity_type", value)

    @property
    @pulumi.getter(name="totalTargetCapacity")
    def total_target_capacity(self) -> pulumi.Input[int]:
        """
        The number of units to request, filled using `default_target_capacity_type`.
        """
        return pulumi.get(self, "total_target_capacity")

    @total_target_capacity.setter
    def total_target_capacity(self, value: pulumi.Input[int]):
        pulumi.set(self, "total_target_capacity", value)

    @property
    @pulumi.getter(name="onDemandTargetCapacity")
    def on_demand_target_capacity(self) -> Optional[pulumi.Input[int]]:
        """
        The number of On-Demand units to request.
        """
        return pulumi.get(self, "on_demand_target_capacity")

    @on_demand_target_capacity.setter
    def on_demand_target_capacity(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "on_demand_target_capacity", value)

    @property
    @pulumi.getter(name="spotTargetCapacity")
    def spot_target_capacity(self) -> Optional[pulumi.Input[int]]:
        """
        The number of Spot units to request.
        """
        return pulumi.get(self, "spot_target_capacity")

    @spot_target_capacity.setter
    def spot_target_capacity(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "spot_target_capacity", value)


@pulumi.input_type
class FlowLogDestinationOptionsArgs:
    def __init__(__self__, *,
                 file_format: Optional[pulumi.Input[str]] = None,
                 hive_compatible_partitions: Optional[pulumi.Input[bool]] = None,
                 per_hour_partition: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] file_format: The format for the flow log. Default value: `plain-text`. Valid values: `plain-text`, `parquet`.
        :param pulumi.Input[bool] hive_compatible_partitions: Indicates whether to use Hive-compatible prefixes for flow logs stored in Amazon S3. Default value: `false`.
        :param pulumi.Input[bool] per_hour_partition: Indicates whether to partition the flow log per hour. This reduces the cost and response time for queries. Default value: `false`.
        """
        if file_format is not None:
            pulumi.set(__self__, "file_format", file_format)
        if hive_compatible_partitions is not None:
            pulumi.set(__self__, "hive_compatible_partitions", hive_compatible_partitions)
        if per_hour_partition is not None:
            pulumi.set(__self__, "per_hour_partition", per_hour_partition)

    @property
    @pulumi.getter(name="fileFormat")
    def file_format(self) -> Optional[pulumi.Input[str]]:
        """
        The format for the flow log. Default value: `plain-text`. Valid values: `plain-text`, `parquet`.
        """
        return pulumi.get(self, "file_format")

    @file_format.setter
    def file_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "file_format", value)

    @property
    @pulumi.getter(name="hiveCompatiblePartitions")
    def hive_compatible_partitions(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether to use Hive-compatible prefixes for flow logs stored in Amazon S3. Default value: `false`.
        """
        return pulumi.get(self, "hive_compatible_partitions")

    @hive_compatible_partitions.setter
    def hive_compatible_partitions(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "hive_compatible_partitions", value)

    @property
    @pulumi.getter(name="perHourPartition")
    def per_hour_partition(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether to partition the flow log per hour. This reduces the cost and response time for queries. Default value: `false`.
        """
        return pulumi.get(self, "per_hour_partition")

    @per_hour_partition.setter
    def per_hour_partition(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "per_hour_partition", value)


@pulumi.input_type
class InstanceCapacityReservationSpecificationArgs:
    def __init__(__self__, *,
                 capacity_reservation_preference: Optional[pulumi.Input[str]] = None,
                 capacity_reservation_target: Optional[pulumi.Input['InstanceCapacityReservationSpecificationCapacityReservationTargetArgs']] = None):
        """
        :param pulumi.Input[str] capacity_reservation_preference: Indicates the instance's Capacity Reservation preferences. Can be `"open"` or `"none"`. (Default: `"open"`).
        :param pulumi.Input['InstanceCapacityReservationSpecificationCapacityReservationTargetArgs'] capacity_reservation_target: Information about the target Capacity Reservation. See Capacity Reservation Target below for more details.
        """
        if capacity_reservation_preference is not None:
            pulumi.set(__self__, "capacity_reservation_preference", capacity_reservation_preference)
        if capacity_reservation_target is not None:
            pulumi.set(__self__, "capacity_reservation_target", capacity_reservation_target)

    @property
    @pulumi.getter(name="capacityReservationPreference")
    def capacity_reservation_preference(self) -> Optional[pulumi.Input[str]]:
        """
        Indicates the instance's Capacity Reservation preferences. Can be `"open"` or `"none"`. (Default: `"open"`).
        """
        return pulumi.get(self, "capacity_reservation_preference")

    @capacity_reservation_preference.setter
    def capacity_reservation_preference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "capacity_reservation_preference", value)

    @property
    @pulumi.getter(name="capacityReservationTarget")
    def capacity_reservation_target(self) -> Optional[pulumi.Input['InstanceCapacityReservationSpecificationCapacityReservationTargetArgs']]:
        """
        Information about the target Capacity Reservation. See Capacity Reservation Target below for more details.
        """
        return pulumi.get(self, "capacity_reservation_target")

    @capacity_reservation_target.setter
    def capacity_reservation_target(self, value: Optional[pulumi.Input['InstanceCapacityReservationSpecificationCapacityReservationTargetArgs']]):
        pulumi.set(self, "capacity_reservation_target", value)


@pulumi.input_type
class InstanceCapacityReservationSpecificationCapacityReservationTargetArgs:
    def __init__(__self__, *,
                 capacity_reservation_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] capacity_reservation_id: The ID of the Capacity Reservation in which to run the instance.
        """
        if capacity_reservation_id is not None:
            pulumi.set(__self__, "capacity_reservation_id", capacity_reservation_id)

    @property
    @pulumi.getter(name="capacityReservationId")
    def capacity_reservation_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Capacity Reservation in which to run the instance.
        """
        return pulumi.get(self, "capacity_reservation_id")

    @capacity_reservation_id.setter
    def capacity_reservation_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "capacity_reservation_id", value)


@pulumi.input_type
class InstanceCreditSpecificationArgs:
    def __init__(__self__, *,
                 cpu_credits: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cpu_credits: Credit option for CPU usage. Valid values include `standard` or `unlimited`. T3 instances are launched as unlimited by default. T2 instances are launched as standard by default.
        """
        if cpu_credits is not None:
            pulumi.set(__self__, "cpu_credits", cpu_credits)

    @property
    @pulumi.getter(name="cpuCredits")
    def cpu_credits(self) -> Optional[pulumi.Input[str]]:
        """
        Credit option for CPU usage. Valid values include `standard` or `unlimited`. T3 instances are launched as unlimited by default. T2 instances are launched as standard by default.
        """
        return pulumi.get(self, "cpu_credits")

    @cpu_credits.setter
    def cpu_credits(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cpu_credits", value)


@pulumi.input_type
class InstanceEbsBlockDeviceArgs:
    def __init__(__self__, *,
                 device_name: pulumi.Input[str],
                 delete_on_termination: Optional[pulumi.Input[bool]] = None,
                 encrypted: Optional[pulumi.Input[bool]] = None,
                 iops: Optional[pulumi.Input[int]] = None,
                 kms_key_id: Optional[pulumi.Input[str]] = None,
                 snapshot_id: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 throughput: Optional[pulumi.Input[int]] = None,
                 volume_id: Optional[pulumi.Input[str]] = None,
                 volume_size: Optional[pulumi.Input[int]] = None,
                 volume_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] device_name: Name of the device to mount.
        :param pulumi.Input[bool] delete_on_termination: Whether the volume should be destroyed on instance termination. Defaults to `true`.
        :param pulumi.Input[bool] encrypted: Enables [EBS encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html) on the volume. Defaults to `false`. Cannot be used with `snapshot_id`. Must be configured to perform drift detection.
        :param pulumi.Input[int] iops: Amount of provisioned [IOPS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-io-characteristics.html). Only valid for volume_type of `io1`, `io2` or `gp3`.
        :param pulumi.Input[str] kms_key_id: Amazon Resource Name (ARN) of the KMS Key to use when encrypting the volume. Must be configured to perform drift detection.
        :param pulumi.Input[str] snapshot_id: Snapshot ID to mount.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] tags: A map of tags to assign to the device.
        :param pulumi.Input[int] throughput: Throughput to provision for a volume in mebibytes per second (MiB/s). This is only valid for `volume_type` of `gp3`.
        :param pulumi.Input[str] volume_id: ID of the volume. For example, the ID can be accessed like this, `aws_instance.web.root_block_device.0.volume_id`.
        :param pulumi.Input[int] volume_size: Size of the volume in gibibytes (GiB).
        :param pulumi.Input[str] volume_type: Type of volume. Valid values include `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1`, or `st1`. Defaults to `gp2`.
        """
        pulumi.set(__self__, "device_name", device_name)
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)
        if volume_id is not None:
            pulumi.set(__self__, "volume_id", volume_id)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> pulumi.Input[str]:
        """
        Name of the device to mount.
        """
        return pulumi.get(self, "device_name")

    @device_name.setter
    def device_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "device_name", value)

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the volume should be destroyed on instance termination. Defaults to `true`.
        """
        return pulumi.get(self, "delete_on_termination")

    @delete_on_termination.setter
    def delete_on_termination(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delete_on_termination", value)

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables [EBS encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html) on the volume. Defaults to `false`. Cannot be used with `snapshot_id`. Must be configured to perform drift detection.
        """
        return pulumi.get(self, "encrypted")

    @encrypted.setter
    def encrypted(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "encrypted", value)

    @property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[int]]:
        """
        Amount of provisioned [IOPS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-io-characteristics.html). Only valid for volume_type of `io1`, `io2` or `gp3`.
        """
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "iops", value)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        Amazon Resource Name (ARN) of the KMS Key to use when encrypting the volume. Must be configured to perform drift detection.
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_id", value)

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[pulumi.Input[str]]:
        """
        Snapshot ID to mount.
        """
        return pulumi.get(self, "snapshot_id")

    @snapshot_id.setter
    def snapshot_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "snapshot_id", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A map of tags to assign to the device.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter
    def throughput(self) -> Optional[pulumi.Input[int]]:
        """
        Throughput to provision for a volume in mebibytes per second (MiB/s). This is only valid for `volume_type` of `gp3`.
        """
        return pulumi.get(self, "throughput")

    @throughput.setter
    def throughput(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "throughput", value)

    @property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the volume. For example, the ID can be accessed like this, `aws_instance.web.root_block_device.0.volume_id`.
        """
        return pulumi.get(self, "volume_id")

    @volume_id.setter
    def volume_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volume_id", value)

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[pulumi.Input[int]]:
        """
        Size of the volume in gibibytes (GiB).
        """
        return pulumi.get(self, "volume_size")

    @volume_size.setter
    def volume_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "volume_size", value)

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of volume. Valid values include `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1`, or `st1`. Defaults to `gp2`.
        """
        return pulumi.get(self, "volume_type")

    @volume_type.setter
    def volume_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volume_type", value)


@pulumi.input_type
class InstanceEnclaveOptionsArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: Whether Nitro Enclaves will be enabled on the instance. Defaults to `false`.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether Nitro Enclaves will be enabled on the instance. Defaults to `false`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class InstanceEphemeralBlockDeviceArgs:
    def __init__(__self__, *,
                 device_name: pulumi.Input[str],
                 no_device: Optional[pulumi.Input[bool]] = None,
                 virtual_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] device_name: The name of the block device to mount on the instance.
        :param pulumi.Input[bool] no_device: Suppresses the specified device included in the AMI's block device mapping.
        :param pulumi.Input[str] virtual_name: [Instance Store Device Name](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#InstanceStoreDeviceNames) (e.g. `ephemeral0`).
        """
        pulumi.set(__self__, "device_name", device_name)
        if no_device is not None:
            pulumi.set(__self__, "no_device", no_device)
        if virtual_name is not None:
            pulumi.set(__self__, "virtual_name", virtual_name)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> pulumi.Input[str]:
        """
        The name of the block device to mount on the instance.
        """
        return pulumi.get(self, "device_name")

    @device_name.setter
    def device_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "device_name", value)

    @property
    @pulumi.getter(name="noDevice")
    def no_device(self) -> Optional[pulumi.Input[bool]]:
        """
        Suppresses the specified device included in the AMI's block device mapping.
        """
        return pulumi.get(self, "no_device")

    @no_device.setter
    def no_device(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_device", value)

    @property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> Optional[pulumi.Input[str]]:
        """
        [Instance Store Device Name](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#InstanceStoreDeviceNames) (e.g. `ephemeral0`).
        """
        return pulumi.get(self, "virtual_name")

    @virtual_name.setter
    def virtual_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "virtual_name", value)


@pulumi.input_type
class InstanceLaunchTemplateArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: The ID of the launch template. Conflicts with `name`.
        :param pulumi.Input[str] name: The name of the launch template. Conflicts with `id`.
        :param pulumi.Input[str] version: Template version. Can be a specific version number, `$Latest` or `$Default`. The default value is `$Default`.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the launch template. Conflicts with `name`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the launch template. Conflicts with `id`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Template version. Can be a specific version number, `$Latest` or `$Default`. The default value is `$Default`.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class InstanceMetadataOptionsArgs:
    def __init__(__self__, *,
                 http_endpoint: Optional[pulumi.Input[str]] = None,
                 http_put_response_hop_limit: Optional[pulumi.Input[int]] = None,
                 http_tokens: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] http_endpoint: Whether the metadata service is available. Valid values include `enabled` or `disabled`. Defaults to `enabled`.
        :param pulumi.Input[int] http_put_response_hop_limit: Desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel. Valid values are integer from `1` to `64`. Defaults to `1`.
        :param pulumi.Input[str] http_tokens: Whether or not the metadata service requires session tokens, also referred to as _Instance Metadata Service Version 2 (IMDSv2)_. Valid values include `optional` or `required`. Defaults to `optional`.
        """
        if http_endpoint is not None:
            pulumi.set(__self__, "http_endpoint", http_endpoint)
        if http_put_response_hop_limit is not None:
            pulumi.set(__self__, "http_put_response_hop_limit", http_put_response_hop_limit)
        if http_tokens is not None:
            pulumi.set(__self__, "http_tokens", http_tokens)

    @property
    @pulumi.getter(name="httpEndpoint")
    def http_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        Whether the metadata service is available. Valid values include `enabled` or `disabled`. Defaults to `enabled`.
        """
        return pulumi.get(self, "http_endpoint")

    @http_endpoint.setter
    def http_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_endpoint", value)

    @property
    @pulumi.getter(name="httpPutResponseHopLimit")
    def http_put_response_hop_limit(self) -> Optional[pulumi.Input[int]]:
        """
        Desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel. Valid values are integer from `1` to `64`. Defaults to `1`.
        """
        return pulumi.get(self, "http_put_response_hop_limit")

    @http_put_response_hop_limit.setter
    def http_put_response_hop_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "http_put_response_hop_limit", value)

    @property
    @pulumi.getter(name="httpTokens")
    def http_tokens(self) -> Optional[pulumi.Input[str]]:
        """
        Whether or not the metadata service requires session tokens, also referred to as _Instance Metadata Service Version 2 (IMDSv2)_. Valid values include `optional` or `required`. Defaults to `optional`.
        """
        return pulumi.get(self, "http_tokens")

    @http_tokens.setter
    def http_tokens(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_tokens", value)


@pulumi.input_type
class InstanceNetworkInterfaceArgs:
    def __init__(__self__, *,
                 device_index: pulumi.Input[int],
                 network_interface_id: pulumi.Input[str],
                 delete_on_termination: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[int] device_index: Integer index of the network interface attachment. Limited by instance type.
        :param pulumi.Input[str] network_interface_id: ID of the network interface to attach.
        :param pulumi.Input[bool] delete_on_termination: Whether or not to delete the network interface on instance termination. Defaults to `false`. Currently, the only valid value is `false`, as this is only supported when creating new network interfaces when launching an instance.
        """
        pulumi.set(__self__, "device_index", device_index)
        pulumi.set(__self__, "network_interface_id", network_interface_id)
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)

    @property
    @pulumi.getter(name="deviceIndex")
    def device_index(self) -> pulumi.Input[int]:
        """
        Integer index of the network interface attachment. Limited by instance type.
        """
        return pulumi.get(self, "device_index")

    @device_index.setter
    def device_index(self, value: pulumi.Input[int]):
        pulumi.set(self, "device_index", value)

    @property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> pulumi.Input[str]:
        """
        ID of the network interface to attach.
        """
        return pulumi.get(self, "network_interface_id")

    @network_interface_id.setter
    def network_interface_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "network_interface_id", value)

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not to delete the network interface on instance termination. Defaults to `false`. Currently, the only valid value is `false`, as this is only supported when creating new network interfaces when launching an instance.
        """
        return pulumi.get(self, "delete_on_termination")

    @delete_on_termination.setter
    def delete_on_termination(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delete_on_termination", value)


@pulumi.input_type
class InstanceRootBlockDeviceArgs:
    def __init__(__self__, *,
                 delete_on_termination: Optional[pulumi.Input[bool]] = None,
                 device_name: Optional[pulumi.Input[str]] = None,
                 encrypted: Optional[pulumi.Input[bool]] = None,
                 iops: Optional[pulumi.Input[int]] = None,
                 kms_key_id: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 throughput: Optional[pulumi.Input[int]] = None,
                 volume_id: Optional[pulumi.Input[str]] = None,
                 volume_size: Optional[pulumi.Input[int]] = None,
                 volume_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] delete_on_termination: Whether the volume should be destroyed on instance termination. Defaults to `true`.
        :param pulumi.Input[str] device_name: Name of the device to mount.
        :param pulumi.Input[bool] encrypted: Whether to enable volume encryption. Defaults to `false`. Must be configured to perform drift detection.
        :param pulumi.Input[int] iops: Amount of provisioned [IOPS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-io-characteristics.html). Only valid for volume_type of `io1`, `io2` or `gp3`.
        :param pulumi.Input[str] kms_key_id: Amazon Resource Name (ARN) of the KMS Key to use when encrypting the volume. Must be configured to perform drift detection.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] tags: A map of tags to assign to the device.
        :param pulumi.Input[int] throughput: Throughput to provision for a volume in mebibytes per second (MiB/s). This is only valid for `volume_type` of `gp3`.
        :param pulumi.Input[str] volume_id: ID of the volume. For example, the ID can be accessed like this, `aws_instance.web.root_block_device.0.volume_id`.
        :param pulumi.Input[int] volume_size: Size of the volume in gibibytes (GiB).
        :param pulumi.Input[str] volume_type: Type of volume. Valid values include `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1`, or `st1`. Defaults to `gp2`.
        """
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)
        if volume_id is not None:
            pulumi.set(__self__, "volume_id", volume_id)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the volume should be destroyed on instance termination. Defaults to `true`.
        """
        return pulumi.get(self, "delete_on_termination")

    @delete_on_termination.setter
    def delete_on_termination(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delete_on_termination", value)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the device to mount.
        """
        return pulumi.get(self, "device_name")

    @device_name.setter
    def device_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "device_name", value)

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to enable volume encryption. Defaults to `false`. Must be configured to perform drift detection.
        """
        return pulumi.get(self, "encrypted")

    @encrypted.setter
    def encrypted(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "encrypted", value)

    @property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[int]]:
        """
        Amount of provisioned [IOPS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-io-characteristics.html). Only valid for volume_type of `io1`, `io2` or `gp3`.
        """
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "iops", value)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        Amazon Resource Name (ARN) of the KMS Key to use when encrypting the volume. Must be configured to perform drift detection.
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_id", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A map of tags to assign to the device.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter
    def throughput(self) -> Optional[pulumi.Input[int]]:
        """
        Throughput to provision for a volume in mebibytes per second (MiB/s). This is only valid for `volume_type` of `gp3`.
        """
        return pulumi.get(self, "throughput")

    @throughput.setter
    def throughput(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "throughput", value)

    @property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the volume. For example, the ID can be accessed like this, `aws_instance.web.root_block_device.0.volume_id`.
        """
        return pulumi.get(self, "volume_id")

    @volume_id.setter
    def volume_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volume_id", value)

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[pulumi.Input[int]]:
        """
        Size of the volume in gibibytes (GiB).
        """
        return pulumi.get(self, "volume_size")

    @volume_size.setter
    def volume_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "volume_size", value)

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of volume. Valid values include `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1`, or `st1`. Defaults to `gp2`.
        """
        return pulumi.get(self, "volume_type")

    @volume_type.setter
    def volume_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volume_type", value)


@pulumi.input_type
class LaunchConfigurationEbsBlockDeviceArgs:
    def __init__(__self__, *,
                 device_name: pulumi.Input[str],
                 delete_on_termination: Optional[pulumi.Input[bool]] = None,
                 encrypted: Optional[pulumi.Input[bool]] = None,
                 iops: Optional[pulumi.Input[int]] = None,
                 no_device: Optional[pulumi.Input[bool]] = None,
                 snapshot_id: Optional[pulumi.Input[str]] = None,
                 throughput: Optional[pulumi.Input[int]] = None,
                 volume_size: Optional[pulumi.Input[int]] = None,
                 volume_type: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "device_name", device_name)
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if no_device is not None:
            pulumi.set(__self__, "no_device", no_device)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "device_name")

    @device_name.setter
    def device_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "device_name", value)

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "delete_on_termination")

    @delete_on_termination.setter
    def delete_on_termination(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delete_on_termination", value)

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "encrypted")

    @encrypted.setter
    def encrypted(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "encrypted", value)

    @property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "iops", value)

    @property
    @pulumi.getter(name="noDevice")
    def no_device(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "no_device")

    @no_device.setter
    def no_device(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_device", value)

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "snapshot_id")

    @snapshot_id.setter
    def snapshot_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "snapshot_id", value)

    @property
    @pulumi.getter
    def throughput(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "throughput")

    @throughput.setter
    def throughput(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "throughput", value)

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "volume_size")

    @volume_size.setter
    def volume_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "volume_size", value)

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "volume_type")

    @volume_type.setter
    def volume_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volume_type", value)


@pulumi.input_type
class LaunchConfigurationEphemeralBlockDeviceArgs:
    def __init__(__self__, *,
                 device_name: pulumi.Input[str],
                 virtual_name: pulumi.Input[str]):
        pulumi.set(__self__, "device_name", device_name)
        pulumi.set(__self__, "virtual_name", virtual_name)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "device_name")

    @device_name.setter
    def device_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "device_name", value)

    @property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "virtual_name")

    @virtual_name.setter
    def virtual_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "virtual_name", value)


@pulumi.input_type
class LaunchConfigurationMetadataOptionsArgs:
    def __init__(__self__, *,
                 http_endpoint: Optional[pulumi.Input[str]] = None,
                 http_put_response_hop_limit: Optional[pulumi.Input[int]] = None,
                 http_tokens: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] http_endpoint: The state of the metadata service: `enabled`, `disabled`.
        :param pulumi.Input[int] http_put_response_hop_limit: The desired HTTP PUT response hop limit for instance metadata requests.
        :param pulumi.Input[str] http_tokens: If session tokens are required: `optional`, `required`.
        """
        if http_endpoint is not None:
            pulumi.set(__self__, "http_endpoint", http_endpoint)
        if http_put_response_hop_limit is not None:
            pulumi.set(__self__, "http_put_response_hop_limit", http_put_response_hop_limit)
        if http_tokens is not None:
            pulumi.set(__self__, "http_tokens", http_tokens)

    @property
    @pulumi.getter(name="httpEndpoint")
    def http_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        The state of the metadata service: `enabled`, `disabled`.
        """
        return pulumi.get(self, "http_endpoint")

    @http_endpoint.setter
    def http_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_endpoint", value)

    @property
    @pulumi.getter(name="httpPutResponseHopLimit")
    def http_put_response_hop_limit(self) -> Optional[pulumi.Input[int]]:
        """
        The desired HTTP PUT response hop limit for instance metadata requests.
        """
        return pulumi.get(self, "http_put_response_hop_limit")

    @http_put_response_hop_limit.setter
    def http_put_response_hop_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "http_put_response_hop_limit", value)

    @property
    @pulumi.getter(name="httpTokens")
    def http_tokens(self) -> Optional[pulumi.Input[str]]:
        """
        If session tokens are required: `optional`, `required`.
        """
        return pulumi.get(self, "http_tokens")

    @http_tokens.setter
    def http_tokens(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_tokens", value)


@pulumi.input_type
class LaunchConfigurationRootBlockDeviceArgs:
    def __init__(__self__, *,
                 delete_on_termination: Optional[pulumi.Input[bool]] = None,
                 encrypted: Optional[pulumi.Input[bool]] = None,
                 iops: Optional[pulumi.Input[int]] = None,
                 throughput: Optional[pulumi.Input[int]] = None,
                 volume_size: Optional[pulumi.Input[int]] = None,
                 volume_type: Optional[pulumi.Input[str]] = None):
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "delete_on_termination")

    @delete_on_termination.setter
    def delete_on_termination(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delete_on_termination", value)

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "encrypted")

    @encrypted.setter
    def encrypted(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "encrypted", value)

    @property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "iops", value)

    @property
    @pulumi.getter
    def throughput(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "throughput")

    @throughput.setter
    def throughput(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "throughput", value)

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "volume_size")

    @volume_size.setter
    def volume_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "volume_size", value)

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "volume_type")

    @volume_type.setter
    def volume_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volume_type", value)


@pulumi.input_type
class LaunchTemplateBlockDeviceMappingArgs:
    def __init__(__self__, *,
                 device_name: Optional[pulumi.Input[str]] = None,
                 ebs: Optional[pulumi.Input['LaunchTemplateBlockDeviceMappingEbsArgs']] = None,
                 no_device: Optional[pulumi.Input[str]] = None,
                 virtual_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] device_name: The name of the device to mount.
        :param pulumi.Input['LaunchTemplateBlockDeviceMappingEbsArgs'] ebs: Configure EBS volume properties.
        :param pulumi.Input[str] no_device: Suppresses the specified device included in the AMI's block device mapping.
        :param pulumi.Input[str] virtual_name: The [Instance Store Device
               Name](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#InstanceStoreDeviceNames)
               (e.g. `"ephemeral0"`).
        """
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if ebs is not None:
            pulumi.set(__self__, "ebs", ebs)
        if no_device is not None:
            pulumi.set(__self__, "no_device", no_device)
        if virtual_name is not None:
            pulumi.set(__self__, "virtual_name", virtual_name)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the device to mount.
        """
        return pulumi.get(self, "device_name")

    @device_name.setter
    def device_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "device_name", value)

    @property
    @pulumi.getter
    def ebs(self) -> Optional[pulumi.Input['LaunchTemplateBlockDeviceMappingEbsArgs']]:
        """
        Configure EBS volume properties.
        """
        return pulumi.get(self, "ebs")

    @ebs.setter
    def ebs(self, value: Optional[pulumi.Input['LaunchTemplateBlockDeviceMappingEbsArgs']]):
        pulumi.set(self, "ebs", value)

    @property
    @pulumi.getter(name="noDevice")
    def no_device(self) -> Optional[pulumi.Input[str]]:
        """
        Suppresses the specified device included in the AMI's block device mapping.
        """
        return pulumi.get(self, "no_device")

    @no_device.setter
    def no_device(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "no_device", value)

    @property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> Optional[pulumi.Input[str]]:
        """
        The [Instance Store Device
        Name](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#InstanceStoreDeviceNames)
        (e.g. `"ephemeral0"`).
        """
        return pulumi.get(self, "virtual_name")

    @virtual_name.setter
    def virtual_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "virtual_name", value)


@pulumi.input_type
class LaunchTemplateBlockDeviceMappingEbsArgs:
    def __init__(__self__, *,
                 delete_on_termination: Optional[pulumi.Input[str]] = None,
                 encrypted: Optional[pulumi.Input[str]] = None,
                 iops: Optional[pulumi.Input[int]] = None,
                 kms_key_id: Optional[pulumi.Input[str]] = None,
                 snapshot_id: Optional[pulumi.Input[str]] = None,
                 throughput: Optional[pulumi.Input[int]] = None,
                 volume_size: Optional[pulumi.Input[int]] = None,
                 volume_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] delete_on_termination: Whether the volume should be destroyed on instance termination. Defaults to `false` if not set. See [Preserving Amazon EBS Volumes on Instance Termination](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/terminating-instances.html#preserving-volumes-on-termination) for more information.
        :param pulumi.Input[str] encrypted: Enables [EBS encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html)
               on the volume (Default: `false`). Cannot be used with `snapshot_id`.
        :param pulumi.Input[int] iops: The amount of provisioned
               [IOPS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-io-characteristics.html).
               This must be set with a `volume_type` of `"io1/io2"`.
        :param pulumi.Input[str] kms_key_id: The ARN of the AWS Key Management Service (AWS KMS) customer master key (CMK) to use when creating the encrypted volume.
               `encrypted` must be set to `true` when this is set.
        :param pulumi.Input[str] snapshot_id: The Snapshot ID to mount.
        :param pulumi.Input[int] throughput: The throughput to provision for a `gp3` volume in MiB/s (specified as an integer, e.g. 500), with a maximum of 1,000 MiB/s.
        :param pulumi.Input[int] volume_size: The size of the volume in gigabytes.
        :param pulumi.Input[str] volume_type: The volume type. Can be `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1` or `st1` (Default: `gp2`).
        """
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[pulumi.Input[str]]:
        """
        Whether the volume should be destroyed on instance termination. Defaults to `false` if not set. See [Preserving Amazon EBS Volumes on Instance Termination](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/terminating-instances.html#preserving-volumes-on-termination) for more information.
        """
        return pulumi.get(self, "delete_on_termination")

    @delete_on_termination.setter
    def delete_on_termination(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delete_on_termination", value)

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[pulumi.Input[str]]:
        """
        Enables [EBS encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html)
        on the volume (Default: `false`). Cannot be used with `snapshot_id`.
        """
        return pulumi.get(self, "encrypted")

    @encrypted.setter
    def encrypted(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encrypted", value)

    @property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[int]]:
        """
        The amount of provisioned
        [IOPS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-io-characteristics.html).
        This must be set with a `volume_type` of `"io1/io2"`.
        """
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "iops", value)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ARN of the AWS Key Management Service (AWS KMS) customer master key (CMK) to use when creating the encrypted volume.
        `encrypted` must be set to `true` when this is set.
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_id", value)

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Snapshot ID to mount.
        """
        return pulumi.get(self, "snapshot_id")

    @snapshot_id.setter
    def snapshot_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "snapshot_id", value)

    @property
    @pulumi.getter
    def throughput(self) -> Optional[pulumi.Input[int]]:
        """
        The throughput to provision for a `gp3` volume in MiB/s (specified as an integer, e.g. 500), with a maximum of 1,000 MiB/s.
        """
        return pulumi.get(self, "throughput")

    @throughput.setter
    def throughput(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "throughput", value)

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[pulumi.Input[int]]:
        """
        The size of the volume in gigabytes.
        """
        return pulumi.get(self, "volume_size")

    @volume_size.setter
    def volume_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "volume_size", value)

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[pulumi.Input[str]]:
        """
        The volume type. Can be `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1` or `st1` (Default: `gp2`).
        """
        return pulumi.get(self, "volume_type")

    @volume_type.setter
    def volume_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volume_type", value)


@pulumi.input_type
class LaunchTemplateCapacityReservationSpecificationArgs:
    def __init__(__self__, *,
                 capacity_reservation_preference: Optional[pulumi.Input[str]] = None,
                 capacity_reservation_target: Optional[pulumi.Input['LaunchTemplateCapacityReservationSpecificationCapacityReservationTargetArgs']] = None):
        """
        :param pulumi.Input[str] capacity_reservation_preference: Indicates the instance's Capacity Reservation preferences. Can be `open` or `none`. (Default `none`).
        :param pulumi.Input['LaunchTemplateCapacityReservationSpecificationCapacityReservationTargetArgs'] capacity_reservation_target: Used to target a specific Capacity Reservation:
        """
        if capacity_reservation_preference is not None:
            pulumi.set(__self__, "capacity_reservation_preference", capacity_reservation_preference)
        if capacity_reservation_target is not None:
            pulumi.set(__self__, "capacity_reservation_target", capacity_reservation_target)

    @property
    @pulumi.getter(name="capacityReservationPreference")
    def capacity_reservation_preference(self) -> Optional[pulumi.Input[str]]:
        """
        Indicates the instance's Capacity Reservation preferences. Can be `open` or `none`. (Default `none`).
        """
        return pulumi.get(self, "capacity_reservation_preference")

    @capacity_reservation_preference.setter
    def capacity_reservation_preference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "capacity_reservation_preference", value)

    @property
    @pulumi.getter(name="capacityReservationTarget")
    def capacity_reservation_target(self) -> Optional[pulumi.Input['LaunchTemplateCapacityReservationSpecificationCapacityReservationTargetArgs']]:
        """
        Used to target a specific Capacity Reservation:
        """
        return pulumi.get(self, "capacity_reservation_target")

    @capacity_reservation_target.setter
    def capacity_reservation_target(self, value: Optional[pulumi.Input['LaunchTemplateCapacityReservationSpecificationCapacityReservationTargetArgs']]):
        pulumi.set(self, "capacity_reservation_target", value)


@pulumi.input_type
class LaunchTemplateCapacityReservationSpecificationCapacityReservationTargetArgs:
    def __init__(__self__, *,
                 capacity_reservation_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] capacity_reservation_id: The ID of the Capacity Reservation to target.
        """
        if capacity_reservation_id is not None:
            pulumi.set(__self__, "capacity_reservation_id", capacity_reservation_id)

    @property
    @pulumi.getter(name="capacityReservationId")
    def capacity_reservation_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Capacity Reservation to target.
        """
        return pulumi.get(self, "capacity_reservation_id")

    @capacity_reservation_id.setter
    def capacity_reservation_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "capacity_reservation_id", value)


@pulumi.input_type
class LaunchTemplateCpuOptionsArgs:
    def __init__(__self__, *,
                 core_count: Optional[pulumi.Input[int]] = None,
                 threads_per_core: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] core_count: The number of CPU cores for the instance.
        :param pulumi.Input[int] threads_per_core: The number of threads per CPU core. To disable Intel Hyper-Threading Technology for the instance, specify a value of 1.
               Otherwise, specify the default value of 2.
        """
        if core_count is not None:
            pulumi.set(__self__, "core_count", core_count)
        if threads_per_core is not None:
            pulumi.set(__self__, "threads_per_core", threads_per_core)

    @property
    @pulumi.getter(name="coreCount")
    def core_count(self) -> Optional[pulumi.Input[int]]:
        """
        The number of CPU cores for the instance.
        """
        return pulumi.get(self, "core_count")

    @core_count.setter
    def core_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "core_count", value)

    @property
    @pulumi.getter(name="threadsPerCore")
    def threads_per_core(self) -> Optional[pulumi.Input[int]]:
        """
        The number of threads per CPU core. To disable Intel Hyper-Threading Technology for the instance, specify a value of 1.
        Otherwise, specify the default value of 2.
        """
        return pulumi.get(self, "threads_per_core")

    @threads_per_core.setter
    def threads_per_core(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "threads_per_core", value)


@pulumi.input_type
class LaunchTemplateCreditSpecificationArgs:
    def __init__(__self__, *,
                 cpu_credits: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cpu_credits: The credit option for CPU usage. Can be `"standard"` or `"unlimited"`. T3 instances are launched as unlimited by default. T2 instances are launched as standard by default.
        """
        if cpu_credits is not None:
            pulumi.set(__self__, "cpu_credits", cpu_credits)

    @property
    @pulumi.getter(name="cpuCredits")
    def cpu_credits(self) -> Optional[pulumi.Input[str]]:
        """
        The credit option for CPU usage. Can be `"standard"` or `"unlimited"`. T3 instances are launched as unlimited by default. T2 instances are launched as standard by default.
        """
        return pulumi.get(self, "cpu_credits")

    @cpu_credits.setter
    def cpu_credits(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cpu_credits", value)


@pulumi.input_type
class LaunchTemplateElasticGpuSpecificationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] type: The [Elastic GPU Type](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/elastic-gpus.html#elastic-gpus-basics)
        """
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The [Elastic GPU Type](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/elastic-gpus.html#elastic-gpus-basics)
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class LaunchTemplateElasticInferenceAcceleratorArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] type: Accelerator type.
        """
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Accelerator type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class LaunchTemplateEnclaveOptionsArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If set to `true`, Nitro Enclaves will be enabled on the instance.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set to `true`, Nitro Enclaves will be enabled on the instance.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class LaunchTemplateHibernationOptionsArgs:
    def __init__(__self__, *,
                 configured: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] configured: If set to `true`, the launched EC2 instance will hibernation enabled.
        """
        pulumi.set(__self__, "configured", configured)

    @property
    @pulumi.getter
    def configured(self) -> pulumi.Input[bool]:
        """
        If set to `true`, the launched EC2 instance will hibernation enabled.
        """
        return pulumi.get(self, "configured")

    @configured.setter
    def configured(self, value: pulumi.Input[bool]):
        pulumi.set(self, "configured", value)


@pulumi.input_type
class LaunchTemplateIamInstanceProfileArgs:
    def __init__(__self__, *,
                 arn: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] arn: The Amazon Resource Name (ARN) of the instance profile.
        :param pulumi.Input[str] name: The name of the instance profile.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def arn(self) -> Optional[pulumi.Input[str]]:
        """
        The Amazon Resource Name (ARN) of the instance profile.
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "arn", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the instance profile.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class LaunchTemplateInstanceMarketOptionsArgs:
    def __init__(__self__, *,
                 market_type: Optional[pulumi.Input[str]] = None,
                 spot_options: Optional[pulumi.Input['LaunchTemplateInstanceMarketOptionsSpotOptionsArgs']] = None):
        """
        :param pulumi.Input[str] market_type: The market type. Can be `spot`.
        :param pulumi.Input['LaunchTemplateInstanceMarketOptionsSpotOptionsArgs'] spot_options: The options for [Spot Instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-spot-instances.html)
        """
        if market_type is not None:
            pulumi.set(__self__, "market_type", market_type)
        if spot_options is not None:
            pulumi.set(__self__, "spot_options", spot_options)

    @property
    @pulumi.getter(name="marketType")
    def market_type(self) -> Optional[pulumi.Input[str]]:
        """
        The market type. Can be `spot`.
        """
        return pulumi.get(self, "market_type")

    @market_type.setter
    def market_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "market_type", value)

    @property
    @pulumi.getter(name="spotOptions")
    def spot_options(self) -> Optional[pulumi.Input['LaunchTemplateInstanceMarketOptionsSpotOptionsArgs']]:
        """
        The options for [Spot Instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-spot-instances.html)
        """
        return pulumi.get(self, "spot_options")

    @spot_options.setter
    def spot_options(self, value: Optional[pulumi.Input['LaunchTemplateInstanceMarketOptionsSpotOptionsArgs']]):
        pulumi.set(self, "spot_options", value)


@pulumi.input_type
class LaunchTemplateInstanceMarketOptionsSpotOptionsArgs:
    def __init__(__self__, *,
                 block_duration_minutes: Optional[pulumi.Input[int]] = None,
                 instance_interruption_behavior: Optional[pulumi.Input[str]] = None,
                 max_price: Optional[pulumi.Input[str]] = None,
                 spot_instance_type: Optional[pulumi.Input[str]] = None,
                 valid_until: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] block_duration_minutes: The required duration in minutes. This value must be a multiple of 60.
        :param pulumi.Input[str] instance_interruption_behavior: The behavior when a Spot Instance is interrupted. Can be `hibernate`,
               `stop`, or `terminate`. (Default: `terminate`).
        :param pulumi.Input[str] max_price: The maximum hourly price you're willing to pay for the Spot Instances.
        :param pulumi.Input[str] spot_instance_type: The Spot Instance request type. Can be `one-time`, or `persistent`.
        :param pulumi.Input[str] valid_until: The end date of the request.
        """
        if block_duration_minutes is not None:
            pulumi.set(__self__, "block_duration_minutes", block_duration_minutes)
        if instance_interruption_behavior is not None:
            pulumi.set(__self__, "instance_interruption_behavior", instance_interruption_behavior)
        if max_price is not None:
            pulumi.set(__self__, "max_price", max_price)
        if spot_instance_type is not None:
            pulumi.set(__self__, "spot_instance_type", spot_instance_type)
        if valid_until is not None:
            pulumi.set(__self__, "valid_until", valid_until)

    @property
    @pulumi.getter(name="blockDurationMinutes")
    def block_duration_minutes(self) -> Optional[pulumi.Input[int]]:
        """
        The required duration in minutes. This value must be a multiple of 60.
        """
        return pulumi.get(self, "block_duration_minutes")

    @block_duration_minutes.setter
    def block_duration_minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "block_duration_minutes", value)

    @property
    @pulumi.getter(name="instanceInterruptionBehavior")
    def instance_interruption_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        The behavior when a Spot Instance is interrupted. Can be `hibernate`,
        `stop`, or `terminate`. (Default: `terminate`).
        """
        return pulumi.get(self, "instance_interruption_behavior")

    @instance_interruption_behavior.setter
    def instance_interruption_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance_interruption_behavior", value)

    @property
    @pulumi.getter(name="maxPrice")
    def max_price(self) -> Optional[pulumi.Input[str]]:
        """
        The maximum hourly price you're willing to pay for the Spot Instances.
        """
        return pulumi.get(self, "max_price")

    @max_price.setter
    def max_price(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_price", value)

    @property
    @pulumi.getter(name="spotInstanceType")
    def spot_instance_type(self) -> Optional[pulumi.Input[str]]:
        """
        The Spot Instance request type. Can be `one-time`, or `persistent`.
        """
        return pulumi.get(self, "spot_instance_type")

    @spot_instance_type.setter
    def spot_instance_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "spot_instance_type", value)

    @property
    @pulumi.getter(name="validUntil")
    def valid_until(self) -> Optional[pulumi.Input[str]]:
        """
        The end date of the request.
        """
        return pulumi.get(self, "valid_until")

    @valid_until.setter
    def valid_until(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "valid_until", value)


@pulumi.input_type
class LaunchTemplateLicenseSpecificationArgs:
    def __init__(__self__, *,
                 license_configuration_arn: pulumi.Input[str]):
        """
        :param pulumi.Input[str] license_configuration_arn: ARN of the license configuration.
        """
        pulumi.set(__self__, "license_configuration_arn", license_configuration_arn)

    @property
    @pulumi.getter(name="licenseConfigurationArn")
    def license_configuration_arn(self) -> pulumi.Input[str]:
        """
        ARN of the license configuration.
        """
        return pulumi.get(self, "license_configuration_arn")

    @license_configuration_arn.setter
    def license_configuration_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "license_configuration_arn", value)


@pulumi.input_type
class LaunchTemplateMetadataOptionsArgs:
    def __init__(__self__, *,
                 http_endpoint: Optional[pulumi.Input[str]] = None,
                 http_protocol_ipv6: Optional[pulumi.Input[str]] = None,
                 http_put_response_hop_limit: Optional[pulumi.Input[int]] = None,
                 http_tokens: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] http_endpoint: Whether the metadata service is available. Can be `"enabled"` or `"disabled"`. (Default: `"enabled"`).
        :param pulumi.Input[str] http_protocol_ipv6: Enables or disables the IPv6 endpoint for the instance metadata service. (Default: `disabled`).
        :param pulumi.Input[int] http_put_response_hop_limit: The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel. Can be an integer from `1` to `64`. (Default: `1`).
        :param pulumi.Input[str] http_tokens: Whether or not the metadata service requires session tokens, also referred to as _Instance Metadata Service Version 2 (IMDSv2)_. Can be `"optional"` or `"required"`. (Default: `"optional"`).
        """
        if http_endpoint is not None:
            pulumi.set(__self__, "http_endpoint", http_endpoint)
        if http_protocol_ipv6 is not None:
            pulumi.set(__self__, "http_protocol_ipv6", http_protocol_ipv6)
        if http_put_response_hop_limit is not None:
            pulumi.set(__self__, "http_put_response_hop_limit", http_put_response_hop_limit)
        if http_tokens is not None:
            pulumi.set(__self__, "http_tokens", http_tokens)

    @property
    @pulumi.getter(name="httpEndpoint")
    def http_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        Whether the metadata service is available. Can be `"enabled"` or `"disabled"`. (Default: `"enabled"`).
        """
        return pulumi.get(self, "http_endpoint")

    @http_endpoint.setter
    def http_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_endpoint", value)

    @property
    @pulumi.getter(name="httpProtocolIpv6")
    def http_protocol_ipv6(self) -> Optional[pulumi.Input[str]]:
        """
        Enables or disables the IPv6 endpoint for the instance metadata service. (Default: `disabled`).
        """
        return pulumi.get(self, "http_protocol_ipv6")

    @http_protocol_ipv6.setter
    def http_protocol_ipv6(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_protocol_ipv6", value)

    @property
    @pulumi.getter(name="httpPutResponseHopLimit")
    def http_put_response_hop_limit(self) -> Optional[pulumi.Input[int]]:
        """
        The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel. Can be an integer from `1` to `64`. (Default: `1`).
        """
        return pulumi.get(self, "http_put_response_hop_limit")

    @http_put_response_hop_limit.setter
    def http_put_response_hop_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "http_put_response_hop_limit", value)

    @property
    @pulumi.getter(name="httpTokens")
    def http_tokens(self) -> Optional[pulumi.Input[str]]:
        """
        Whether or not the metadata service requires session tokens, also referred to as _Instance Metadata Service Version 2 (IMDSv2)_. Can be `"optional"` or `"required"`. (Default: `"optional"`).
        """
        return pulumi.get(self, "http_tokens")

    @http_tokens.setter
    def http_tokens(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_tokens", value)


@pulumi.input_type
class LaunchTemplateMonitoringArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If `true`, the launched EC2 instance will have detailed monitoring enabled.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If `true`, the launched EC2 instance will have detailed monitoring enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class LaunchTemplateNetworkInterfaceArgs:
    def __init__(__self__, *,
                 associate_carrier_ip_address: Optional[pulumi.Input[str]] = None,
                 associate_public_ip_address: Optional[pulumi.Input[str]] = None,
                 delete_on_termination: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 device_index: Optional[pulumi.Input[int]] = None,
                 interface_type: Optional[pulumi.Input[str]] = None,
                 ipv4_address_count: Optional[pulumi.Input[int]] = None,
                 ipv4_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ipv6_address_count: Optional[pulumi.Input[int]] = None,
                 ipv6_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 network_interface_id: Optional[pulumi.Input[str]] = None,
                 private_ip_address: Optional[pulumi.Input[str]] = None,
                 security_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] associate_carrier_ip_address: Associate a Carrier IP address with `eth0` for a new network interface. Use this option when you launch an instance in a Wavelength Zone and want to associate a Carrier IP address with the network interface. Boolean value.
        :param pulumi.Input[str] associate_public_ip_address: Associate a public ip address with the network interface.  Boolean value.
        :param pulumi.Input[str] delete_on_termination: Whether the network interface should be destroyed on instance termination. Defaults to `false` if not set.
        :param pulumi.Input[str] description: Description of the network interface.
        :param pulumi.Input[int] device_index: The integer index of the network interface attachment.
        :param pulumi.Input[str] interface_type: The type of network interface. To create an Elastic Fabric Adapter (EFA), specify `efa`.
        :param pulumi.Input[int] ipv4_address_count: The number of secondary private IPv4 addresses to assign to a network interface. Conflicts with `ipv4_addresses`
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ipv4_addresses: One or more private IPv4 addresses to associate. Conflicts with `ipv4_address_count`
        :param pulumi.Input[int] ipv6_address_count: The number of IPv6 addresses to assign to a network interface. Conflicts with `ipv6_addresses`
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ipv6_addresses: One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet. Conflicts with `ipv6_address_count`
        :param pulumi.Input[str] network_interface_id: The ID of the network interface to attach.
        :param pulumi.Input[str] private_ip_address: The primary private IPv4 address.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_groups: A list of security group IDs to associate.
        :param pulumi.Input[str] subnet_id: The VPC Subnet ID to associate.
        """
        if associate_carrier_ip_address is not None:
            pulumi.set(__self__, "associate_carrier_ip_address", associate_carrier_ip_address)
        if associate_public_ip_address is not None:
            pulumi.set(__self__, "associate_public_ip_address", associate_public_ip_address)
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if device_index is not None:
            pulumi.set(__self__, "device_index", device_index)
        if interface_type is not None:
            pulumi.set(__self__, "interface_type", interface_type)
        if ipv4_address_count is not None:
            pulumi.set(__self__, "ipv4_address_count", ipv4_address_count)
        if ipv4_addresses is not None:
            pulumi.set(__self__, "ipv4_addresses", ipv4_addresses)
        if ipv6_address_count is not None:
            pulumi.set(__self__, "ipv6_address_count", ipv6_address_count)
        if ipv6_addresses is not None:
            pulumi.set(__self__, "ipv6_addresses", ipv6_addresses)
        if network_interface_id is not None:
            pulumi.set(__self__, "network_interface_id", network_interface_id)
        if private_ip_address is not None:
            pulumi.set(__self__, "private_ip_address", private_ip_address)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter(name="associateCarrierIpAddress")
    def associate_carrier_ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        Associate a Carrier IP address with `eth0` for a new network interface. Use this option when you launch an instance in a Wavelength Zone and want to associate a Carrier IP address with the network interface. Boolean value.
        """
        return pulumi.get(self, "associate_carrier_ip_address")

    @associate_carrier_ip_address.setter
    def associate_carrier_ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "associate_carrier_ip_address", value)

    @property
    @pulumi.getter(name="associatePublicIpAddress")
    def associate_public_ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        Associate a public ip address with the network interface.  Boolean value.
        """
        return pulumi.get(self, "associate_public_ip_address")

    @associate_public_ip_address.setter
    def associate_public_ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "associate_public_ip_address", value)

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[pulumi.Input[str]]:
        """
        Whether the network interface should be destroyed on instance termination. Defaults to `false` if not set.
        """
        return pulumi.get(self, "delete_on_termination")

    @delete_on_termination.setter
    def delete_on_termination(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delete_on_termination", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Description of the network interface.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="deviceIndex")
    def device_index(self) -> Optional[pulumi.Input[int]]:
        """
        The integer index of the network interface attachment.
        """
        return pulumi.get(self, "device_index")

    @device_index.setter
    def device_index(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "device_index", value)

    @property
    @pulumi.getter(name="interfaceType")
    def interface_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of network interface. To create an Elastic Fabric Adapter (EFA), specify `efa`.
        """
        return pulumi.get(self, "interface_type")

    @interface_type.setter
    def interface_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "interface_type", value)

    @property
    @pulumi.getter(name="ipv4AddressCount")
    def ipv4_address_count(self) -> Optional[pulumi.Input[int]]:
        """
        The number of secondary private IPv4 addresses to assign to a network interface. Conflicts with `ipv4_addresses`
        """
        return pulumi.get(self, "ipv4_address_count")

    @ipv4_address_count.setter
    def ipv4_address_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ipv4_address_count", value)

    @property
    @pulumi.getter(name="ipv4Addresses")
    def ipv4_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        One or more private IPv4 addresses to associate. Conflicts with `ipv4_address_count`
        """
        return pulumi.get(self, "ipv4_addresses")

    @ipv4_addresses.setter
    def ipv4_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ipv4_addresses", value)

    @property
    @pulumi.getter(name="ipv6AddressCount")
    def ipv6_address_count(self) -> Optional[pulumi.Input[int]]:
        """
        The number of IPv6 addresses to assign to a network interface. Conflicts with `ipv6_addresses`
        """
        return pulumi.get(self, "ipv6_address_count")

    @ipv6_address_count.setter
    def ipv6_address_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ipv6_address_count", value)

    @property
    @pulumi.getter(name="ipv6Addresses")
    def ipv6_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet. Conflicts with `ipv6_address_count`
        """
        return pulumi.get(self, "ipv6_addresses")

    @ipv6_addresses.setter
    def ipv6_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ipv6_addresses", value)

    @property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the network interface to attach.
        """
        return pulumi.get(self, "network_interface_id")

    @network_interface_id.setter
    def network_interface_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_interface_id", value)

    @property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        The primary private IPv4 address.
        """
        return pulumi.get(self, "private_ip_address")

    @private_ip_address.setter
    def private_ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_ip_address", value)

    @property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of security group IDs to associate.
        """
        return pulumi.get(self, "security_groups")

    @security_groups.setter
    def security_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "security_groups", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The VPC Subnet ID to associate.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)


@pulumi.input_type
class LaunchTemplatePlacementArgs:
    def __init__(__self__, *,
                 affinity: Optional[pulumi.Input[str]] = None,
                 availability_zone: Optional[pulumi.Input[str]] = None,
                 group_name: Optional[pulumi.Input[str]] = None,
                 host_id: Optional[pulumi.Input[str]] = None,
                 host_resource_group_arn: Optional[pulumi.Input[str]] = None,
                 partition_number: Optional[pulumi.Input[int]] = None,
                 spread_domain: Optional[pulumi.Input[str]] = None,
                 tenancy: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] affinity: The affinity setting for an instance on a Dedicated Host.
        :param pulumi.Input[str] availability_zone: The Availability Zone for the instance.
        :param pulumi.Input[str] group_name: The name of the placement group for the instance.
        :param pulumi.Input[str] host_id: The ID of the Dedicated Host for the instance.
        :param pulumi.Input[str] host_resource_group_arn: The ARN of the Host Resource Group in which to launch instances.
        :param pulumi.Input[int] partition_number: The number of the partition the instance should launch in. Valid only if the placement group strategy is set to partition.
        :param pulumi.Input[str] spread_domain: Reserved for future use.
        :param pulumi.Input[str] tenancy: The tenancy of the instance (if the instance is running in a VPC). Can be `default`, `dedicated`, or `host`.
        """
        if affinity is not None:
            pulumi.set(__self__, "affinity", affinity)
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if group_name is not None:
            pulumi.set(__self__, "group_name", group_name)
        if host_id is not None:
            pulumi.set(__self__, "host_id", host_id)
        if host_resource_group_arn is not None:
            pulumi.set(__self__, "host_resource_group_arn", host_resource_group_arn)
        if partition_number is not None:
            pulumi.set(__self__, "partition_number", partition_number)
        if spread_domain is not None:
            pulumi.set(__self__, "spread_domain", spread_domain)
        if tenancy is not None:
            pulumi.set(__self__, "tenancy", tenancy)

    @property
    @pulumi.getter
    def affinity(self) -> Optional[pulumi.Input[str]]:
        """
        The affinity setting for an instance on a Dedicated Host.
        """
        return pulumi.get(self, "affinity")

    @affinity.setter
    def affinity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "affinity", value)

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[pulumi.Input[str]]:
        """
        The Availability Zone for the instance.
        """
        return pulumi.get(self, "availability_zone")

    @availability_zone.setter
    def availability_zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability_zone", value)

    @property
    @pulumi.getter(name="groupName")
    def group_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the placement group for the instance.
        """
        return pulumi.get(self, "group_name")

    @group_name.setter
    def group_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_name", value)

    @property
    @pulumi.getter(name="hostId")
    def host_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Dedicated Host for the instance.
        """
        return pulumi.get(self, "host_id")

    @host_id.setter
    def host_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host_id", value)

    @property
    @pulumi.getter(name="hostResourceGroupArn")
    def host_resource_group_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The ARN of the Host Resource Group in which to launch instances.
        """
        return pulumi.get(self, "host_resource_group_arn")

    @host_resource_group_arn.setter
    def host_resource_group_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host_resource_group_arn", value)

    @property
    @pulumi.getter(name="partitionNumber")
    def partition_number(self) -> Optional[pulumi.Input[int]]:
        """
        The number of the partition the instance should launch in. Valid only if the placement group strategy is set to partition.
        """
        return pulumi.get(self, "partition_number")

    @partition_number.setter
    def partition_number(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "partition_number", value)

    @property
    @pulumi.getter(name="spreadDomain")
    def spread_domain(self) -> Optional[pulumi.Input[str]]:
        """
        Reserved for future use.
        """
        return pulumi.get(self, "spread_domain")

    @spread_domain.setter
    def spread_domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "spread_domain", value)

    @property
    @pulumi.getter
    def tenancy(self) -> Optional[pulumi.Input[str]]:
        """
        The tenancy of the instance (if the instance is running in a VPC). Can be `default`, `dedicated`, or `host`.
        """
        return pulumi.get(self, "tenancy")

    @tenancy.setter
    def tenancy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenancy", value)


@pulumi.input_type
class LaunchTemplateTagSpecificationArgs:
    def __init__(__self__, *,
                 resource_type: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] resource_type: The type of resource to tag.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] tags: A map of tags to assign to the resource.
        """
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of resource to tag.
        """
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_type", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A map of tags to assign to the resource.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)


@pulumi.input_type
class ManagedPrefixListEntryArgs:
    def __init__(__self__, *,
                 cidr: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cidr: CIDR block of this entry.
        :param pulumi.Input[str] description: Description of this entry. Due to API limitations, updating only the description of an existing entry requires temporarily removing and re-adding the entry.
        """
        pulumi.set(__self__, "cidr", cidr)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def cidr(self) -> pulumi.Input[str]:
        """
        CIDR block of this entry.
        """
        return pulumi.get(self, "cidr")

    @cidr.setter
    def cidr(self, value: pulumi.Input[str]):
        pulumi.set(self, "cidr", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Description of this entry. Due to API limitations, updating only the description of an existing entry requires temporarily removing and re-adding the entry.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


@pulumi.input_type
class NetworkAclEgressArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 from_port: pulumi.Input[int],
                 protocol: pulumi.Input[str],
                 rule_no: pulumi.Input[int],
                 to_port: pulumi.Input[int],
                 cidr_block: Optional[pulumi.Input[str]] = None,
                 icmp_code: Optional[pulumi.Input[int]] = None,
                 icmp_type: Optional[pulumi.Input[int]] = None,
                 ipv6_cidr_block: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: The action to take.
        :param pulumi.Input[int] from_port: The from port to match.
        :param pulumi.Input[str] protocol: The protocol to match. If using the -1 'all'
               protocol, you must specify a from and to port of 0.
        :param pulumi.Input[int] rule_no: The rule number. Used for ordering.
        :param pulumi.Input[int] to_port: The to port to match.
        :param pulumi.Input[str] cidr_block: The CIDR block to match. This must be a
               valid network mask.
        :param pulumi.Input[int] icmp_code: The ICMP type code to be used. Default 0.
        :param pulumi.Input[int] icmp_type: The ICMP type to be used. Default 0.
        :param pulumi.Input[str] ipv6_cidr_block: The IPv6 CIDR block.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "from_port", from_port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "rule_no", rule_no)
        pulumi.set(__self__, "to_port", to_port)
        if cidr_block is not None:
            pulumi.set(__self__, "cidr_block", cidr_block)
        if icmp_code is not None:
            pulumi.set(__self__, "icmp_code", icmp_code)
        if icmp_type is not None:
            pulumi.set(__self__, "icmp_type", icmp_type)
        if ipv6_cidr_block is not None:
            pulumi.set(__self__, "ipv6_cidr_block", ipv6_cidr_block)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        The action to take.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> pulumi.Input[int]:
        """
        The from port to match.
        """
        return pulumi.get(self, "from_port")

    @from_port.setter
    def from_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "from_port", value)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        The protocol to match. If using the -1 'all'
        protocol, you must specify a from and to port of 0.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="ruleNo")
    def rule_no(self) -> pulumi.Input[int]:
        """
        The rule number. Used for ordering.
        """
        return pulumi.get(self, "rule_no")

    @rule_no.setter
    def rule_no(self, value: pulumi.Input[int]):
        pulumi.set(self, "rule_no", value)

    @property
    @pulumi.getter(name="toPort")
    def to_port(self) -> pulumi.Input[int]:
        """
        The to port to match.
        """
        return pulumi.get(self, "to_port")

    @to_port.setter
    def to_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "to_port", value)

    @property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> Optional[pulumi.Input[str]]:
        """
        The CIDR block to match. This must be a
        valid network mask.
        """
        return pulumi.get(self, "cidr_block")

    @cidr_block.setter
    def cidr_block(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cidr_block", value)

    @property
    @pulumi.getter(name="icmpCode")
    def icmp_code(self) -> Optional[pulumi.Input[int]]:
        """
        The ICMP type code to be used. Default 0.
        """
        return pulumi.get(self, "icmp_code")

    @icmp_code.setter
    def icmp_code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "icmp_code", value)

    @property
    @pulumi.getter(name="icmpType")
    def icmp_type(self) -> Optional[pulumi.Input[int]]:
        """
        The ICMP type to be used. Default 0.
        """
        return pulumi.get(self, "icmp_type")

    @icmp_type.setter
    def icmp_type(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "icmp_type", value)

    @property
    @pulumi.getter(name="ipv6CidrBlock")
    def ipv6_cidr_block(self) -> Optional[pulumi.Input[str]]:
        """
        The IPv6 CIDR block.
        """
        return pulumi.get(self, "ipv6_cidr_block")

    @ipv6_cidr_block.setter
    def ipv6_cidr_block(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv6_cidr_block", value)


@pulumi.input_type
class NetworkAclIngressArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 from_port: pulumi.Input[int],
                 protocol: pulumi.Input[str],
                 rule_no: pulumi.Input[int],
                 to_port: pulumi.Input[int],
                 cidr_block: Optional[pulumi.Input[str]] = None,
                 icmp_code: Optional[pulumi.Input[int]] = None,
                 icmp_type: Optional[pulumi.Input[int]] = None,
                 ipv6_cidr_block: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: The action to take.
        :param pulumi.Input[int] from_port: The from port to match.
        :param pulumi.Input[str] protocol: The protocol to match. If using the -1 'all'
               protocol, you must specify a from and to port of 0.
        :param pulumi.Input[int] rule_no: The rule number. Used for ordering.
        :param pulumi.Input[int] to_port: The to port to match.
        :param pulumi.Input[str] cidr_block: The CIDR block to match. This must be a
               valid network mask.
        :param pulumi.Input[int] icmp_code: The ICMP type code to be used. Default 0.
        :param pulumi.Input[int] icmp_type: The ICMP type to be used. Default 0.
        :param pulumi.Input[str] ipv6_cidr_block: The IPv6 CIDR block.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "from_port", from_port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "rule_no", rule_no)
        pulumi.set(__self__, "to_port", to_port)
        if cidr_block is not None:
            pulumi.set(__self__, "cidr_block", cidr_block)
        if icmp_code is not None:
            pulumi.set(__self__, "icmp_code", icmp_code)
        if icmp_type is not None:
            pulumi.set(__self__, "icmp_type", icmp_type)
        if ipv6_cidr_block is not None:
            pulumi.set(__self__, "ipv6_cidr_block", ipv6_cidr_block)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        The action to take.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> pulumi.Input[int]:
        """
        The from port to match.
        """
        return pulumi.get(self, "from_port")

    @from_port.setter
    def from_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "from_port", value)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        The protocol to match. If using the -1 'all'
        protocol, you must specify a from and to port of 0.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="ruleNo")
    def rule_no(self) -> pulumi.Input[int]:
        """
        The rule number. Used for ordering.
        """
        return pulumi.get(self, "rule_no")

    @rule_no.setter
    def rule_no(self, value: pulumi.Input[int]):
        pulumi.set(self, "rule_no", value)

    @property
    @pulumi.getter(name="toPort")
    def to_port(self) -> pulumi.Input[int]:
        """
        The to port to match.
        """
        return pulumi.get(self, "to_port")

    @to_port.setter
    def to_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "to_port", value)

    @property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> Optional[pulumi.Input[str]]:
        """
        The CIDR block to match. This must be a
        valid network mask.
        """
        return pulumi.get(self, "cidr_block")

    @cidr_block.setter
    def cidr_block(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cidr_block", value)

    @property
    @pulumi.getter(name="icmpCode")
    def icmp_code(self) -> Optional[pulumi.Input[int]]:
        """
        The ICMP type code to be used. Default 0.
        """
        return pulumi.get(self, "icmp_code")

    @icmp_code.setter
    def icmp_code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "icmp_code", value)

    @property
    @pulumi.getter(name="icmpType")
    def icmp_type(self) -> Optional[pulumi.Input[int]]:
        """
        The ICMP type to be used. Default 0.
        """
        return pulumi.get(self, "icmp_type")

    @icmp_type.setter
    def icmp_type(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "icmp_type", value)

    @property
    @pulumi.getter(name="ipv6CidrBlock")
    def ipv6_cidr_block(self) -> Optional[pulumi.Input[str]]:
        """
        The IPv6 CIDR block.
        """
        return pulumi.get(self, "ipv6_cidr_block")

    @ipv6_cidr_block.setter
    def ipv6_cidr_block(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv6_cidr_block", value)


@pulumi.input_type
class NetworkInterfaceAttachmentArgs:
    def __init__(__self__, *,
                 device_index: pulumi.Input[int],
                 instance: pulumi.Input[str],
                 attachment_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] device_index: Integer to define the devices index.
        :param pulumi.Input[str] instance: ID of the instance to attach to.
        """
        pulumi.set(__self__, "device_index", device_index)
        pulumi.set(__self__, "instance", instance)
        if attachment_id is not None:
            pulumi.set(__self__, "attachment_id", attachment_id)

    @property
    @pulumi.getter(name="deviceIndex")
    def device_index(self) -> pulumi.Input[int]:
        """
        Integer to define the devices index.
        """
        return pulumi.get(self, "device_index")

    @device_index.setter
    def device_index(self, value: pulumi.Input[int]):
        pulumi.set(self, "device_index", value)

    @property
    @pulumi.getter
    def instance(self) -> pulumi.Input[str]:
        """
        ID of the instance to attach to.
        """
        return pulumi.get(self, "instance")

    @instance.setter
    def instance(self, value: pulumi.Input[str]):
        pulumi.set(self, "instance", value)

    @property
    @pulumi.getter(name="attachmentId")
    def attachment_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "attachment_id")

    @attachment_id.setter
    def attachment_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "attachment_id", value)


@pulumi.input_type
class PeeringConnectionOptionsAccepterArgs:
    def __init__(__self__, *,
                 allow_classic_link_to_remote_vpc: Optional[pulumi.Input[bool]] = None,
                 allow_remote_vpc_dns_resolution: Optional[pulumi.Input[bool]] = None,
                 allow_vpc_to_remote_classic_link: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] allow_classic_link_to_remote_vpc: Allow a local linked EC2-Classic instance to communicate
               with instances in a peer VPC. This enables an outbound communication from the local ClassicLink connection
               to the remote VPC. This option is not supported for inter-region VPC peering.
        :param pulumi.Input[bool] allow_remote_vpc_dns_resolution: Allow a local VPC to resolve public DNS hostnames to
               private IP addresses when queried from instances in the peer VPC.
        :param pulumi.Input[bool] allow_vpc_to_remote_classic_link: Allow a local VPC to communicate with a linked EC2-Classic
               instance in a peer VPC. This enables an outbound communication from the local VPC to the remote ClassicLink
               connection. This option is not supported for inter-region VPC peering.
        """
        if allow_classic_link_to_remote_vpc is not None:
            pulumi.set(__self__, "allow_classic_link_to_remote_vpc", allow_classic_link_to_remote_vpc)
        if allow_remote_vpc_dns_resolution is not None:
            pulumi.set(__self__, "allow_remote_vpc_dns_resolution", allow_remote_vpc_dns_resolution)
        if allow_vpc_to_remote_classic_link is not None:
            pulumi.set(__self__, "allow_vpc_to_remote_classic_link", allow_vpc_to_remote_classic_link)

    @property
    @pulumi.getter(name="allowClassicLinkToRemoteVpc")
    def allow_classic_link_to_remote_vpc(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow a local linked EC2-Classic instance to communicate
        with instances in a peer VPC. This enables an outbound communication from the local ClassicLink connection
        to the remote VPC. This option is not supported for inter-region VPC peering.
        """
        return pulumi.get(self, "allow_classic_link_to_remote_vpc")

    @allow_classic_link_to_remote_vpc.setter
    def allow_classic_link_to_remote_vpc(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_classic_link_to_remote_vpc", value)

    @property
    @pulumi.getter(name="allowRemoteVpcDnsResolution")
    def allow_remote_vpc_dns_resolution(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow a local VPC to resolve public DNS hostnames to
        private IP addresses when queried from instances in the peer VPC.
        """
        return pulumi.get(self, "allow_remote_vpc_dns_resolution")

    @allow_remote_vpc_dns_resolution.setter
    def allow_remote_vpc_dns_resolution(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_remote_vpc_dns_resolution", value)

    @property
    @pulumi.getter(name="allowVpcToRemoteClassicLink")
    def allow_vpc_to_remote_classic_link(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow a local VPC to communicate with a linked EC2-Classic
        instance in a peer VPC. This enables an outbound communication from the local VPC to the remote ClassicLink
        connection. This option is not supported for inter-region VPC peering.
        """
        return pulumi.get(self, "allow_vpc_to_remote_classic_link")

    @allow_vpc_to_remote_classic_link.setter
    def allow_vpc_to_remote_classic_link(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_vpc_to_remote_classic_link", value)


@pulumi.input_type
class PeeringConnectionOptionsRequesterArgs:
    def __init__(__self__, *,
                 allow_classic_link_to_remote_vpc: Optional[pulumi.Input[bool]] = None,
                 allow_remote_vpc_dns_resolution: Optional[pulumi.Input[bool]] = None,
                 allow_vpc_to_remote_classic_link: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] allow_classic_link_to_remote_vpc: Allow a local linked EC2-Classic instance to communicate
               with instances in a peer VPC. This enables an outbound communication from the local ClassicLink connection
               to the remote VPC. This option is not supported for inter-region VPC peering.
        :param pulumi.Input[bool] allow_remote_vpc_dns_resolution: Allow a local VPC to resolve public DNS hostnames to
               private IP addresses when queried from instances in the peer VPC.
        :param pulumi.Input[bool] allow_vpc_to_remote_classic_link: Allow a local VPC to communicate with a linked EC2-Classic
               instance in a peer VPC. This enables an outbound communication from the local VPC to the remote ClassicLink
               connection. This option is not supported for inter-region VPC peering.
        """
        if allow_classic_link_to_remote_vpc is not None:
            pulumi.set(__self__, "allow_classic_link_to_remote_vpc", allow_classic_link_to_remote_vpc)
        if allow_remote_vpc_dns_resolution is not None:
            pulumi.set(__self__, "allow_remote_vpc_dns_resolution", allow_remote_vpc_dns_resolution)
        if allow_vpc_to_remote_classic_link is not None:
            pulumi.set(__self__, "allow_vpc_to_remote_classic_link", allow_vpc_to_remote_classic_link)

    @property
    @pulumi.getter(name="allowClassicLinkToRemoteVpc")
    def allow_classic_link_to_remote_vpc(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow a local linked EC2-Classic instance to communicate
        with instances in a peer VPC. This enables an outbound communication from the local ClassicLink connection
        to the remote VPC. This option is not supported for inter-region VPC peering.
        """
        return pulumi.get(self, "allow_classic_link_to_remote_vpc")

    @allow_classic_link_to_remote_vpc.setter
    def allow_classic_link_to_remote_vpc(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_classic_link_to_remote_vpc", value)

    @property
    @pulumi.getter(name="allowRemoteVpcDnsResolution")
    def allow_remote_vpc_dns_resolution(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow a local VPC to resolve public DNS hostnames to
        private IP addresses when queried from instances in the peer VPC.
        """
        return pulumi.get(self, "allow_remote_vpc_dns_resolution")

    @allow_remote_vpc_dns_resolution.setter
    def allow_remote_vpc_dns_resolution(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_remote_vpc_dns_resolution", value)

    @property
    @pulumi.getter(name="allowVpcToRemoteClassicLink")
    def allow_vpc_to_remote_classic_link(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow a local VPC to communicate with a linked EC2-Classic
        instance in a peer VPC. This enables an outbound communication from the local VPC to the remote ClassicLink
        connection. This option is not supported for inter-region VPC peering.
        """
        return pulumi.get(self, "allow_vpc_to_remote_classic_link")

    @allow_vpc_to_remote_classic_link.setter
    def allow_vpc_to_remote_classic_link(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_vpc_to_remote_classic_link", value)


@pulumi.input_type
class RouteTableRouteArgs:
    def __init__(__self__, *,
                 carrier_gateway_id: Optional[pulumi.Input[str]] = None,
                 cidr_block: Optional[pulumi.Input[str]] = None,
                 destination_prefix_list_id: Optional[pulumi.Input[str]] = None,
                 egress_only_gateway_id: Optional[pulumi.Input[str]] = None,
                 gateway_id: Optional[pulumi.Input[str]] = None,
                 instance_id: Optional[pulumi.Input[str]] = None,
                 ipv6_cidr_block: Optional[pulumi.Input[str]] = None,
                 local_gateway_id: Optional[pulumi.Input[str]] = None,
                 nat_gateway_id: Optional[pulumi.Input[str]] = None,
                 network_interface_id: Optional[pulumi.Input[str]] = None,
                 transit_gateway_id: Optional[pulumi.Input[str]] = None,
                 vpc_endpoint_id: Optional[pulumi.Input[str]] = None,
                 vpc_peering_connection_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] carrier_gateway_id: Identifier of a carrier gateway. This attribute can only be used when the VPC contains a subnet which is associated with a Wavelength Zone.
        :param pulumi.Input[str] cidr_block: The CIDR block of the route.
        :param pulumi.Input[str] destination_prefix_list_id: The ID of a managed prefix list destination of the route.
        :param pulumi.Input[str] egress_only_gateway_id: Identifier of a VPC Egress Only Internet Gateway.
        :param pulumi.Input[str] gateway_id: Identifier of a VPC internet gateway or a virtual private gateway.
        :param pulumi.Input[str] instance_id: Identifier of an EC2 instance.
        :param pulumi.Input[str] ipv6_cidr_block: The Ipv6 CIDR block of the route.
        :param pulumi.Input[str] local_gateway_id: Identifier of a Outpost local gateway.
        :param pulumi.Input[str] nat_gateway_id: Identifier of a VPC NAT gateway.
        :param pulumi.Input[str] network_interface_id: Identifier of an EC2 network interface.
        :param pulumi.Input[str] transit_gateway_id: Identifier of an EC2 Transit Gateway.
        :param pulumi.Input[str] vpc_endpoint_id: Identifier of a VPC Endpoint.
        :param pulumi.Input[str] vpc_peering_connection_id: Identifier of a VPC peering connection.
        """
        if carrier_gateway_id is not None:
            pulumi.set(__self__, "carrier_gateway_id", carrier_gateway_id)
        if cidr_block is not None:
            pulumi.set(__self__, "cidr_block", cidr_block)
        if destination_prefix_list_id is not None:
            pulumi.set(__self__, "destination_prefix_list_id", destination_prefix_list_id)
        if egress_only_gateway_id is not None:
            pulumi.set(__self__, "egress_only_gateway_id", egress_only_gateway_id)
        if gateway_id is not None:
            pulumi.set(__self__, "gateway_id", gateway_id)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if ipv6_cidr_block is not None:
            pulumi.set(__self__, "ipv6_cidr_block", ipv6_cidr_block)
        if local_gateway_id is not None:
            pulumi.set(__self__, "local_gateway_id", local_gateway_id)
        if nat_gateway_id is not None:
            pulumi.set(__self__, "nat_gateway_id", nat_gateway_id)
        if network_interface_id is not None:
            pulumi.set(__self__, "network_interface_id", network_interface_id)
        if transit_gateway_id is not None:
            pulumi.set(__self__, "transit_gateway_id", transit_gateway_id)
        if vpc_endpoint_id is not None:
            pulumi.set(__self__, "vpc_endpoint_id", vpc_endpoint_id)
        if vpc_peering_connection_id is not None:
            pulumi.set(__self__, "vpc_peering_connection_id", vpc_peering_connection_id)

    @property
    @pulumi.getter(name="carrierGatewayId")
    def carrier_gateway_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier of a carrier gateway. This attribute can only be used when the VPC contains a subnet which is associated with a Wavelength Zone.
        """
        return pulumi.get(self, "carrier_gateway_id")

    @carrier_gateway_id.setter
    def carrier_gateway_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "carrier_gateway_id", value)

    @property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> Optional[pulumi.Input[str]]:
        """
        The CIDR block of the route.
        """
        return pulumi.get(self, "cidr_block")

    @cidr_block.setter
    def cidr_block(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cidr_block", value)

    @property
    @pulumi.getter(name="destinationPrefixListId")
    def destination_prefix_list_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of a managed prefix list destination of the route.
        """
        return pulumi.get(self, "destination_prefix_list_id")

    @destination_prefix_list_id.setter
    def destination_prefix_list_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination_prefix_list_id", value)

    @property
    @pulumi.getter(name="egressOnlyGatewayId")
    def egress_only_gateway_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier of a VPC Egress Only Internet Gateway.
        """
        return pulumi.get(self, "egress_only_gateway_id")

    @egress_only_gateway_id.setter
    def egress_only_gateway_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "egress_only_gateway_id", value)

    @property
    @pulumi.getter(name="gatewayId")
    def gateway_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier of a VPC internet gateway or a virtual private gateway.
        """
        return pulumi.get(self, "gateway_id")

    @gateway_id.setter
    def gateway_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gateway_id", value)

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier of an EC2 instance.
        """
        return pulumi.get(self, "instance_id")

    @instance_id.setter
    def instance_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance_id", value)

    @property
    @pulumi.getter(name="ipv6CidrBlock")
    def ipv6_cidr_block(self) -> Optional[pulumi.Input[str]]:
        """
        The Ipv6 CIDR block of the route.
        """
        return pulumi.get(self, "ipv6_cidr_block")

    @ipv6_cidr_block.setter
    def ipv6_cidr_block(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv6_cidr_block", value)

    @property
    @pulumi.getter(name="localGatewayId")
    def local_gateway_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier of a Outpost local gateway.
        """
        return pulumi.get(self, "local_gateway_id")

    @local_gateway_id.setter
    def local_gateway_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "local_gateway_id", value)

    @property
    @pulumi.getter(name="natGatewayId")
    def nat_gateway_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier of a VPC NAT gateway.
        """
        return pulumi.get(self, "nat_gateway_id")

    @nat_gateway_id.setter
    def nat_gateway_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "nat_gateway_id", value)

    @property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier of an EC2 network interface.
        """
        return pulumi.get(self, "network_interface_id")

    @network_interface_id.setter
    def network_interface_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_interface_id", value)

    @property
    @pulumi.getter(name="transitGatewayId")
    def transit_gateway_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier of an EC2 Transit Gateway.
        """
        return pulumi.get(self, "transit_gateway_id")

    @transit_gateway_id.setter
    def transit_gateway_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "transit_gateway_id", value)

    @property
    @pulumi.getter(name="vpcEndpointId")
    def vpc_endpoint_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier of a VPC Endpoint.
        """
        return pulumi.get(self, "vpc_endpoint_id")

    @vpc_endpoint_id.setter
    def vpc_endpoint_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vpc_endpoint_id", value)

    @property
    @pulumi.getter(name="vpcPeeringConnectionId")
    def vpc_peering_connection_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier of a VPC peering connection.
        """
        return pulumi.get(self, "vpc_peering_connection_id")

    @vpc_peering_connection_id.setter
    def vpc_peering_connection_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vpc_peering_connection_id", value)


@pulumi.input_type
class SecurityGroupEgressArgs:
    def __init__(__self__, *,
                 from_port: pulumi.Input[int],
                 protocol: pulumi.Input[str],
                 to_port: pulumi.Input[int],
                 cidr_blocks: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 ipv6_cidr_blocks: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 prefix_list_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 security_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 self: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[int] from_port: Start port (or ICMP type number if protocol is `icmp`)
        :param pulumi.Input[str] protocol: Protocol. If you select a protocol of `-1` (semantically equivalent to `all`, which is not a valid value here), you must specify a `from_port` and `to_port` equal to 0.  The supported values are defined in the `IpProtocol` argument in the [IpPermission](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_IpPermission.html) API reference. This argument is normalized to a lowercase value.
        :param pulumi.Input[int] to_port: End range port (or ICMP code if protocol is `icmp`).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] cidr_blocks: List of CIDR blocks.
        :param pulumi.Input[str] description: Description of this egress rule.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ipv6_cidr_blocks: List of IPv6 CIDR blocks.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] prefix_list_ids: List of Prefix List IDs.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_groups: List of security group Group Names if using EC2-Classic, or Group IDs if using a VPC.
        :param pulumi.Input[bool] self: Whether the security group itself will be added as a source to this egress rule.
        """
        pulumi.set(__self__, "from_port", from_port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "to_port", to_port)
        if cidr_blocks is not None:
            pulumi.set(__self__, "cidr_blocks", cidr_blocks)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if ipv6_cidr_blocks is not None:
            pulumi.set(__self__, "ipv6_cidr_blocks", ipv6_cidr_blocks)
        if prefix_list_ids is not None:
            pulumi.set(__self__, "prefix_list_ids", prefix_list_ids)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if self is not None:
            pulumi.set(__self__, "self", self)

    @property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> pulumi.Input[int]:
        """
        Start port (or ICMP type number if protocol is `icmp`)
        """
        return pulumi.get(self, "from_port")

    @from_port.setter
    def from_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "from_port", value)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        Protocol. If you select a protocol of `-1` (semantically equivalent to `all`, which is not a valid value here), you must specify a `from_port` and `to_port` equal to 0.  The supported values are defined in the `IpProtocol` argument in the [IpPermission](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_IpPermission.html) API reference. This argument is normalized to a lowercase value.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="toPort")
    def to_port(self) -> pulumi.Input[int]:
        """
        End range port (or ICMP code if protocol is `icmp`).
        """
        return pulumi.get(self, "to_port")

    @to_port.setter
    def to_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "to_port", value)

    @property
    @pulumi.getter(name="cidrBlocks")
    def cidr_blocks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of CIDR blocks.
        """
        return pulumi.get(self, "cidr_blocks")

    @cidr_blocks.setter
    def cidr_blocks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "cidr_blocks", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Description of this egress rule.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="ipv6CidrBlocks")
    def ipv6_cidr_blocks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of IPv6 CIDR blocks.
        """
        return pulumi.get(self, "ipv6_cidr_blocks")

    @ipv6_cidr_blocks.setter
    def ipv6_cidr_blocks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ipv6_cidr_blocks", value)

    @property
    @pulumi.getter(name="prefixListIds")
    def prefix_list_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of Prefix List IDs.
        """
        return pulumi.get(self, "prefix_list_ids")

    @prefix_list_ids.setter
    def prefix_list_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "prefix_list_ids", value)

    @property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of security group Group Names if using EC2-Classic, or Group IDs if using a VPC.
        """
        return pulumi.get(self, "security_groups")

    @security_groups.setter
    def security_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "security_groups", value)

    @property
    @pulumi.getter
    def self(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the security group itself will be added as a source to this egress rule.
        """
        return pulumi.get(self, "self")

    @self.setter
    def self(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "self", value)


@pulumi.input_type
class SecurityGroupIngressArgs:
    def __init__(__self__, *,
                 from_port: pulumi.Input[int],
                 protocol: pulumi.Input[str],
                 to_port: pulumi.Input[int],
                 cidr_blocks: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 ipv6_cidr_blocks: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 prefix_list_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 security_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 self: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[int] from_port: Start port (or ICMP type number if protocol is `icmp`)
        :param pulumi.Input[str] protocol: Protocol. If you select a protocol of `-1` (semantically equivalent to `all`, which is not a valid value here), you must specify a `from_port` and `to_port` equal to 0.  The supported values are defined in the `IpProtocol` argument in the [IpPermission](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_IpPermission.html) API reference. This argument is normalized to a lowercase value.
        :param pulumi.Input[int] to_port: End range port (or ICMP code if protocol is `icmp`).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] cidr_blocks: List of CIDR blocks.
        :param pulumi.Input[str] description: Description of this egress rule.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ipv6_cidr_blocks: List of IPv6 CIDR blocks.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] prefix_list_ids: List of Prefix List IDs.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_groups: List of security group Group Names if using EC2-Classic, or Group IDs if using a VPC.
        :param pulumi.Input[bool] self: Whether the security group itself will be added as a source to this egress rule.
        """
        pulumi.set(__self__, "from_port", from_port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "to_port", to_port)
        if cidr_blocks is not None:
            pulumi.set(__self__, "cidr_blocks", cidr_blocks)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if ipv6_cidr_blocks is not None:
            pulumi.set(__self__, "ipv6_cidr_blocks", ipv6_cidr_blocks)
        if prefix_list_ids is not None:
            pulumi.set(__self__, "prefix_list_ids", prefix_list_ids)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if self is not None:
            pulumi.set(__self__, "self", self)

    @property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> pulumi.Input[int]:
        """
        Start port (or ICMP type number if protocol is `icmp`)
        """
        return pulumi.get(self, "from_port")

    @from_port.setter
    def from_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "from_port", value)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        Protocol. If you select a protocol of `-1` (semantically equivalent to `all`, which is not a valid value here), you must specify a `from_port` and `to_port` equal to 0.  The supported values are defined in the `IpProtocol` argument in the [IpPermission](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_IpPermission.html) API reference. This argument is normalized to a lowercase value.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="toPort")
    def to_port(self) -> pulumi.Input[int]:
        """
        End range port (or ICMP code if protocol is `icmp`).
        """
        return pulumi.get(self, "to_port")

    @to_port.setter
    def to_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "to_port", value)

    @property
    @pulumi.getter(name="cidrBlocks")
    def cidr_blocks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of CIDR blocks.
        """
        return pulumi.get(self, "cidr_blocks")

    @cidr_blocks.setter
    def cidr_blocks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "cidr_blocks", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Description of this egress rule.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="ipv6CidrBlocks")
    def ipv6_cidr_blocks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of IPv6 CIDR blocks.
        """
        return pulumi.get(self, "ipv6_cidr_blocks")

    @ipv6_cidr_blocks.setter
    def ipv6_cidr_blocks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ipv6_cidr_blocks", value)

    @property
    @pulumi.getter(name="prefixListIds")
    def prefix_list_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of Prefix List IDs.
        """
        return pulumi.get(self, "prefix_list_ids")

    @prefix_list_ids.setter
    def prefix_list_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "prefix_list_ids", value)

    @property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of security group Group Names if using EC2-Classic, or Group IDs if using a VPC.
        """
        return pulumi.get(self, "security_groups")

    @security_groups.setter
    def security_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "security_groups", value)

    @property
    @pulumi.getter
    def self(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the security group itself will be added as a source to this egress rule.
        """
        return pulumi.get(self, "self")

    @self.setter
    def self(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "self", value)


@pulumi.input_type
class SpotFleetRequestLaunchSpecificationArgs:
    def __init__(__self__, *,
                 ami: pulumi.Input[str],
                 instance_type: pulumi.Input[str],
                 associate_public_ip_address: Optional[pulumi.Input[bool]] = None,
                 availability_zone: Optional[pulumi.Input[str]] = None,
                 ebs_block_devices: Optional[pulumi.Input[Sequence[pulumi.Input['SpotFleetRequestLaunchSpecificationEbsBlockDeviceArgs']]]] = None,
                 ebs_optimized: Optional[pulumi.Input[bool]] = None,
                 ephemeral_block_devices: Optional[pulumi.Input[Sequence[pulumi.Input['SpotFleetRequestLaunchSpecificationEphemeralBlockDeviceArgs']]]] = None,
                 iam_instance_profile: Optional[pulumi.Input[str]] = None,
                 iam_instance_profile_arn: Optional[pulumi.Input[str]] = None,
                 key_name: Optional[pulumi.Input[str]] = None,
                 monitoring: Optional[pulumi.Input[bool]] = None,
                 placement_group: Optional[pulumi.Input[str]] = None,
                 placement_tenancy: Optional[pulumi.Input[str]] = None,
                 root_block_devices: Optional[pulumi.Input[Sequence[pulumi.Input['SpotFleetRequestLaunchSpecificationRootBlockDeviceArgs']]]] = None,
                 spot_price: Optional[pulumi.Input[str]] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 user_data: Optional[pulumi.Input[str]] = None,
                 vpc_security_group_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 weighted_capacity: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] instance_type: The type of instance to request.
        :param pulumi.Input[str] availability_zone: The availability zone in which to place the request.
        :param pulumi.Input[str] spot_price: The maximum spot bid for this override request.
        :param pulumi.Input[str] subnet_id: The subnet in which to launch the requested instance.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] tags: A map of tags to assign to the resource. .If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        :param pulumi.Input[str] weighted_capacity: The capacity added to the fleet by a fulfilled request.
        """
        pulumi.set(__self__, "ami", ami)
        pulumi.set(__self__, "instance_type", instance_type)
        if associate_public_ip_address is not None:
            pulumi.set(__self__, "associate_public_ip_address", associate_public_ip_address)
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if ebs_block_devices is not None:
            pulumi.set(__self__, "ebs_block_devices", ebs_block_devices)
        if ebs_optimized is not None:
            pulumi.set(__self__, "ebs_optimized", ebs_optimized)
        if ephemeral_block_devices is not None:
            pulumi.set(__self__, "ephemeral_block_devices", ephemeral_block_devices)
        if iam_instance_profile is not None:
            pulumi.set(__self__, "iam_instance_profile", iam_instance_profile)
        if iam_instance_profile_arn is not None:
            pulumi.set(__self__, "iam_instance_profile_arn", iam_instance_profile_arn)
        if key_name is not None:
            pulumi.set(__self__, "key_name", key_name)
        if monitoring is not None:
            pulumi.set(__self__, "monitoring", monitoring)
        if placement_group is not None:
            pulumi.set(__self__, "placement_group", placement_group)
        if placement_tenancy is not None:
            pulumi.set(__self__, "placement_tenancy", placement_tenancy)
        if root_block_devices is not None:
            pulumi.set(__self__, "root_block_devices", root_block_devices)
        if spot_price is not None:
            pulumi.set(__self__, "spot_price", spot_price)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if user_data is not None:
            pulumi.set(__self__, "user_data", user_data)
        if vpc_security_group_ids is not None:
            pulumi.set(__self__, "vpc_security_group_ids", vpc_security_group_ids)
        if weighted_capacity is not None:
            pulumi.set(__self__, "weighted_capacity", weighted_capacity)

    @property
    @pulumi.getter
    def ami(self) -> pulumi.Input[str]:
        return pulumi.get(self, "ami")

    @ami.setter
    def ami(self, value: pulumi.Input[str]):
        pulumi.set(self, "ami", value)

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> pulumi.Input[str]:
        """
        The type of instance to request.
        """
        return pulumi.get(self, "instance_type")

    @instance_type.setter
    def instance_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "instance_type", value)

    @property
    @pulumi.getter(name="associatePublicIpAddress")
    def associate_public_ip_address(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "associate_public_ip_address")

    @associate_public_ip_address.setter
    def associate_public_ip_address(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "associate_public_ip_address", value)

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[pulumi.Input[str]]:
        """
        The availability zone in which to place the request.
        """
        return pulumi.get(self, "availability_zone")

    @availability_zone.setter
    def availability_zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability_zone", value)

    @property
    @pulumi.getter(name="ebsBlockDevices")
    def ebs_block_devices(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SpotFleetRequestLaunchSpecificationEbsBlockDeviceArgs']]]]:
        return pulumi.get(self, "ebs_block_devices")

    @ebs_block_devices.setter
    def ebs_block_devices(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SpotFleetRequestLaunchSpecificationEbsBlockDeviceArgs']]]]):
        pulumi.set(self, "ebs_block_devices", value)

    @property
    @pulumi.getter(name="ebsOptimized")
    def ebs_optimized(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "ebs_optimized")

    @ebs_optimized.setter
    def ebs_optimized(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ebs_optimized", value)

    @property
    @pulumi.getter(name="ephemeralBlockDevices")
    def ephemeral_block_devices(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SpotFleetRequestLaunchSpecificationEphemeralBlockDeviceArgs']]]]:
        return pulumi.get(self, "ephemeral_block_devices")

    @ephemeral_block_devices.setter
    def ephemeral_block_devices(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SpotFleetRequestLaunchSpecificationEphemeralBlockDeviceArgs']]]]):
        pulumi.set(self, "ephemeral_block_devices", value)

    @property
    @pulumi.getter(name="iamInstanceProfile")
    def iam_instance_profile(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "iam_instance_profile")

    @iam_instance_profile.setter
    def iam_instance_profile(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "iam_instance_profile", value)

    @property
    @pulumi.getter(name="iamInstanceProfileArn")
    def iam_instance_profile_arn(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "iam_instance_profile_arn")

    @iam_instance_profile_arn.setter
    def iam_instance_profile_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "iam_instance_profile_arn", value)

    @property
    @pulumi.getter(name="keyName")
    def key_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key_name")

    @key_name.setter
    def key_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_name", value)

    @property
    @pulumi.getter
    def monitoring(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "monitoring")

    @monitoring.setter
    def monitoring(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "monitoring", value)

    @property
    @pulumi.getter(name="placementGroup")
    def placement_group(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "placement_group")

    @placement_group.setter
    def placement_group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "placement_group", value)

    @property
    @pulumi.getter(name="placementTenancy")
    def placement_tenancy(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "placement_tenancy")

    @placement_tenancy.setter
    def placement_tenancy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "placement_tenancy", value)

    @property
    @pulumi.getter(name="rootBlockDevices")
    def root_block_devices(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SpotFleetRequestLaunchSpecificationRootBlockDeviceArgs']]]]:
        return pulumi.get(self, "root_block_devices")

    @root_block_devices.setter
    def root_block_devices(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SpotFleetRequestLaunchSpecificationRootBlockDeviceArgs']]]]):
        pulumi.set(self, "root_block_devices", value)

    @property
    @pulumi.getter(name="spotPrice")
    def spot_price(self) -> Optional[pulumi.Input[str]]:
        """
        The maximum spot bid for this override request.
        """
        return pulumi.get(self, "spot_price")

    @spot_price.setter
    def spot_price(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "spot_price", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The subnet in which to launch the requested instance.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A map of tags to assign to the resource. .If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter(name="userData")
    def user_data(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "user_data")

    @user_data.setter
    def user_data(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_data", value)

    @property
    @pulumi.getter(name="vpcSecurityGroupIds")
    def vpc_security_group_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "vpc_security_group_ids")

    @vpc_security_group_ids.setter
    def vpc_security_group_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "vpc_security_group_ids", value)

    @property
    @pulumi.getter(name="weightedCapacity")
    def weighted_capacity(self) -> Optional[pulumi.Input[str]]:
        """
        The capacity added to the fleet by a fulfilled request.
        """
        return pulumi.get(self, "weighted_capacity")

    @weighted_capacity.setter
    def weighted_capacity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "weighted_capacity", value)


@pulumi.input_type
class SpotFleetRequestLaunchSpecificationEbsBlockDeviceArgs:
    def __init__(__self__, *,
                 device_name: pulumi.Input[str],
                 delete_on_termination: Optional[pulumi.Input[bool]] = None,
                 encrypted: Optional[pulumi.Input[bool]] = None,
                 iops: Optional[pulumi.Input[int]] = None,
                 kms_key_id: Optional[pulumi.Input[str]] = None,
                 snapshot_id: Optional[pulumi.Input[str]] = None,
                 throughput: Optional[pulumi.Input[int]] = None,
                 volume_size: Optional[pulumi.Input[int]] = None,
                 volume_type: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "device_name", device_name)
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "device_name")

    @device_name.setter
    def device_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "device_name", value)

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "delete_on_termination")

    @delete_on_termination.setter
    def delete_on_termination(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delete_on_termination", value)

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "encrypted")

    @encrypted.setter
    def encrypted(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "encrypted", value)

    @property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "iops", value)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_id", value)

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "snapshot_id")

    @snapshot_id.setter
    def snapshot_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "snapshot_id", value)

    @property
    @pulumi.getter
    def throughput(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "throughput")

    @throughput.setter
    def throughput(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "throughput", value)

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "volume_size")

    @volume_size.setter
    def volume_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "volume_size", value)

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "volume_type")

    @volume_type.setter
    def volume_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volume_type", value)


@pulumi.input_type
class SpotFleetRequestLaunchSpecificationEphemeralBlockDeviceArgs:
    def __init__(__self__, *,
                 device_name: pulumi.Input[str],
                 virtual_name: pulumi.Input[str]):
        pulumi.set(__self__, "device_name", device_name)
        pulumi.set(__self__, "virtual_name", virtual_name)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "device_name")

    @device_name.setter
    def device_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "device_name", value)

    @property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "virtual_name")

    @virtual_name.setter
    def virtual_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "virtual_name", value)


@pulumi.input_type
class SpotFleetRequestLaunchSpecificationRootBlockDeviceArgs:
    def __init__(__self__, *,
                 delete_on_termination: Optional[pulumi.Input[bool]] = None,
                 encrypted: Optional[pulumi.Input[bool]] = None,
                 iops: Optional[pulumi.Input[int]] = None,
                 kms_key_id: Optional[pulumi.Input[str]] = None,
                 throughput: Optional[pulumi.Input[int]] = None,
                 volume_size: Optional[pulumi.Input[int]] = None,
                 volume_type: Optional[pulumi.Input[str]] = None):
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "delete_on_termination")

    @delete_on_termination.setter
    def delete_on_termination(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delete_on_termination", value)

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "encrypted")

    @encrypted.setter
    def encrypted(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "encrypted", value)

    @property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "iops", value)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_id", value)

    @property
    @pulumi.getter
    def throughput(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "throughput")

    @throughput.setter
    def throughput(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "throughput", value)

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "volume_size")

    @volume_size.setter
    def volume_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "volume_size", value)

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "volume_type")

    @volume_type.setter
    def volume_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volume_type", value)


@pulumi.input_type
class SpotFleetRequestLaunchTemplateConfigArgs:
    def __init__(__self__, *,
                 launch_template_specification: pulumi.Input['SpotFleetRequestLaunchTemplateConfigLaunchTemplateSpecificationArgs'],
                 overrides: Optional[pulumi.Input[Sequence[pulumi.Input['SpotFleetRequestLaunchTemplateConfigOverrideArgs']]]] = None):
        """
        :param pulumi.Input['SpotFleetRequestLaunchTemplateConfigLaunchTemplateSpecificationArgs'] launch_template_specification: Launch template specification. See Launch Template Specification below for more details.
        :param pulumi.Input[Sequence[pulumi.Input['SpotFleetRequestLaunchTemplateConfigOverrideArgs']]] overrides: One or more override configurations. See Overrides below for more details.
        """
        pulumi.set(__self__, "launch_template_specification", launch_template_specification)
        if overrides is not None:
            pulumi.set(__self__, "overrides", overrides)

    @property
    @pulumi.getter(name="launchTemplateSpecification")
    def launch_template_specification(self) -> pulumi.Input['SpotFleetRequestLaunchTemplateConfigLaunchTemplateSpecificationArgs']:
        """
        Launch template specification. See Launch Template Specification below for more details.
        """
        return pulumi.get(self, "launch_template_specification")

    @launch_template_specification.setter
    def launch_template_specification(self, value: pulumi.Input['SpotFleetRequestLaunchTemplateConfigLaunchTemplateSpecificationArgs']):
        pulumi.set(self, "launch_template_specification", value)

    @property
    @pulumi.getter
    def overrides(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SpotFleetRequestLaunchTemplateConfigOverrideArgs']]]]:
        """
        One or more override configurations. See Overrides below for more details.
        """
        return pulumi.get(self, "overrides")

    @overrides.setter
    def overrides(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SpotFleetRequestLaunchTemplateConfigOverrideArgs']]]]):
        pulumi.set(self, "overrides", value)


@pulumi.input_type
class SpotFleetRequestLaunchTemplateConfigLaunchTemplateSpecificationArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: The ID of the launch template. Conflicts with `name`.
        :param pulumi.Input[str] name: The name of the launch template. Conflicts with `id`.
        :param pulumi.Input[str] version: Template version. Unlike the autoscaling equivalent, does not support `$Latest` or `$Default`, so use the launch_template resource's attribute, e.g. `"${aws_launch_template.foo.latest_version}"`. It will use the default version if omitted.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the launch template. Conflicts with `name`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the launch template. Conflicts with `id`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Template version. Unlike the autoscaling equivalent, does not support `$Latest` or `$Default`, so use the launch_template resource's attribute, e.g. `"${aws_launch_template.foo.latest_version}"`. It will use the default version if omitted.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class SpotFleetRequestLaunchTemplateConfigOverrideArgs:
    def __init__(__self__, *,
                 availability_zone: Optional[pulumi.Input[str]] = None,
                 instance_type: Optional[pulumi.Input[str]] = None,
                 priority: Optional[pulumi.Input[float]] = None,
                 spot_price: Optional[pulumi.Input[str]] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None,
                 weighted_capacity: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[str] availability_zone: The availability zone in which to place the request.
        :param pulumi.Input[str] instance_type: The type of instance to request.
        :param pulumi.Input[float] priority: The priority for the launch template override. The lower the number, the higher the priority. If no number is set, the launch template override has the lowest priority.
        :param pulumi.Input[str] spot_price: The maximum spot bid for this override request.
        :param pulumi.Input[str] subnet_id: The subnet in which to launch the requested instance.
        :param pulumi.Input[float] weighted_capacity: The capacity added to the fleet by a fulfilled request.
        """
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if spot_price is not None:
            pulumi.set(__self__, "spot_price", spot_price)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if weighted_capacity is not None:
            pulumi.set(__self__, "weighted_capacity", weighted_capacity)

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[pulumi.Input[str]]:
        """
        The availability zone in which to place the request.
        """
        return pulumi.get(self, "availability_zone")

    @availability_zone.setter
    def availability_zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability_zone", value)

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of instance to request.
        """
        return pulumi.get(self, "instance_type")

    @instance_type.setter
    def instance_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance_type", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[float]]:
        """
        The priority for the launch template override. The lower the number, the higher the priority. If no number is set, the launch template override has the lowest priority.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="spotPrice")
    def spot_price(self) -> Optional[pulumi.Input[str]]:
        """
        The maximum spot bid for this override request.
        """
        return pulumi.get(self, "spot_price")

    @spot_price.setter
    def spot_price(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "spot_price", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The subnet in which to launch the requested instance.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter(name="weightedCapacity")
    def weighted_capacity(self) -> Optional[pulumi.Input[float]]:
        """
        The capacity added to the fleet by a fulfilled request.
        """
        return pulumi.get(self, "weighted_capacity")

    @weighted_capacity.setter
    def weighted_capacity(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "weighted_capacity", value)


@pulumi.input_type
class SpotFleetRequestSpotMaintenanceStrategiesArgs:
    def __init__(__self__, *,
                 capacity_rebalance: Optional[pulumi.Input['SpotFleetRequestSpotMaintenanceStrategiesCapacityRebalanceArgs']] = None):
        """
        :param pulumi.Input['SpotFleetRequestSpotMaintenanceStrategiesCapacityRebalanceArgs'] capacity_rebalance: Nested argument containing the capacity rebalance for your fleet request. Defined below.
        """
        if capacity_rebalance is not None:
            pulumi.set(__self__, "capacity_rebalance", capacity_rebalance)

    @property
    @pulumi.getter(name="capacityRebalance")
    def capacity_rebalance(self) -> Optional[pulumi.Input['SpotFleetRequestSpotMaintenanceStrategiesCapacityRebalanceArgs']]:
        """
        Nested argument containing the capacity rebalance for your fleet request. Defined below.
        """
        return pulumi.get(self, "capacity_rebalance")

    @capacity_rebalance.setter
    def capacity_rebalance(self, value: Optional[pulumi.Input['SpotFleetRequestSpotMaintenanceStrategiesCapacityRebalanceArgs']]):
        pulumi.set(self, "capacity_rebalance", value)


@pulumi.input_type
class SpotFleetRequestSpotMaintenanceStrategiesCapacityRebalanceArgs:
    def __init__(__self__, *,
                 replacement_strategy: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] replacement_strategy: The replacement strategy to use. Only available for spot fleets with `fleet_type` set to `maintain`. Valid values: `launch`.
        """
        if replacement_strategy is not None:
            pulumi.set(__self__, "replacement_strategy", replacement_strategy)

    @property
    @pulumi.getter(name="replacementStrategy")
    def replacement_strategy(self) -> Optional[pulumi.Input[str]]:
        """
        The replacement strategy to use. Only available for spot fleets with `fleet_type` set to `maintain`. Valid values: `launch`.
        """
        return pulumi.get(self, "replacement_strategy")

    @replacement_strategy.setter
    def replacement_strategy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "replacement_strategy", value)


@pulumi.input_type
class SpotInstanceRequestCapacityReservationSpecificationArgs:
    def __init__(__self__, *,
                 capacity_reservation_preference: Optional[pulumi.Input[str]] = None,
                 capacity_reservation_target: Optional[pulumi.Input['SpotInstanceRequestCapacityReservationSpecificationCapacityReservationTargetArgs']] = None):
        """
        :param pulumi.Input[str] capacity_reservation_preference: Indicates the instance's Capacity Reservation preferences. Can be `"open"` or `"none"`. (Default: `"open"`).
        :param pulumi.Input['SpotInstanceRequestCapacityReservationSpecificationCapacityReservationTargetArgs'] capacity_reservation_target: Information about the target Capacity Reservation. See Capacity Reservation Target below for more details.
        """
        if capacity_reservation_preference is not None:
            pulumi.set(__self__, "capacity_reservation_preference", capacity_reservation_preference)
        if capacity_reservation_target is not None:
            pulumi.set(__self__, "capacity_reservation_target", capacity_reservation_target)

    @property
    @pulumi.getter(name="capacityReservationPreference")
    def capacity_reservation_preference(self) -> Optional[pulumi.Input[str]]:
        """
        Indicates the instance's Capacity Reservation preferences. Can be `"open"` or `"none"`. (Default: `"open"`).
        """
        return pulumi.get(self, "capacity_reservation_preference")

    @capacity_reservation_preference.setter
    def capacity_reservation_preference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "capacity_reservation_preference", value)

    @property
    @pulumi.getter(name="capacityReservationTarget")
    def capacity_reservation_target(self) -> Optional[pulumi.Input['SpotInstanceRequestCapacityReservationSpecificationCapacityReservationTargetArgs']]:
        """
        Information about the target Capacity Reservation. See Capacity Reservation Target below for more details.
        """
        return pulumi.get(self, "capacity_reservation_target")

    @capacity_reservation_target.setter
    def capacity_reservation_target(self, value: Optional[pulumi.Input['SpotInstanceRequestCapacityReservationSpecificationCapacityReservationTargetArgs']]):
        pulumi.set(self, "capacity_reservation_target", value)


@pulumi.input_type
class SpotInstanceRequestCapacityReservationSpecificationCapacityReservationTargetArgs:
    def __init__(__self__, *,
                 capacity_reservation_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] capacity_reservation_id: The ID of the Capacity Reservation in which to run the instance.
        """
        if capacity_reservation_id is not None:
            pulumi.set(__self__, "capacity_reservation_id", capacity_reservation_id)

    @property
    @pulumi.getter(name="capacityReservationId")
    def capacity_reservation_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Capacity Reservation in which to run the instance.
        """
        return pulumi.get(self, "capacity_reservation_id")

    @capacity_reservation_id.setter
    def capacity_reservation_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "capacity_reservation_id", value)


@pulumi.input_type
class SpotInstanceRequestCreditSpecificationArgs:
    def __init__(__self__, *,
                 cpu_credits: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cpu_credits: Credit option for CPU usage. Valid values include `standard` or `unlimited`. T3 instances are launched as unlimited by default. T2 instances are launched as standard by default.
        """
        if cpu_credits is not None:
            pulumi.set(__self__, "cpu_credits", cpu_credits)

    @property
    @pulumi.getter(name="cpuCredits")
    def cpu_credits(self) -> Optional[pulumi.Input[str]]:
        """
        Credit option for CPU usage. Valid values include `standard` or `unlimited`. T3 instances are launched as unlimited by default. T2 instances are launched as standard by default.
        """
        return pulumi.get(self, "cpu_credits")

    @cpu_credits.setter
    def cpu_credits(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cpu_credits", value)


@pulumi.input_type
class SpotInstanceRequestEbsBlockDeviceArgs:
    def __init__(__self__, *,
                 device_name: pulumi.Input[str],
                 delete_on_termination: Optional[pulumi.Input[bool]] = None,
                 encrypted: Optional[pulumi.Input[bool]] = None,
                 iops: Optional[pulumi.Input[int]] = None,
                 kms_key_id: Optional[pulumi.Input[str]] = None,
                 snapshot_id: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 throughput: Optional[pulumi.Input[int]] = None,
                 volume_id: Optional[pulumi.Input[str]] = None,
                 volume_size: Optional[pulumi.Input[int]] = None,
                 volume_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] device_name: Name of the device to mount.
        :param pulumi.Input[bool] delete_on_termination: Whether the volume should be destroyed on instance termination. Defaults to `true`.
        :param pulumi.Input[bool] encrypted: Enables [EBS encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html) on the volume. Defaults to `false`. Cannot be used with `snapshot_id`. Must be configured to perform drift detection.
        :param pulumi.Input[int] iops: Amount of provisioned [IOPS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-io-characteristics.html). Only valid for volume_type of `io1`, `io2` or `gp3`.
        :param pulumi.Input[str] kms_key_id: Amazon Resource Name (ARN) of the KMS Key to use when encrypting the volume. Must be configured to perform drift detection.
        :param pulumi.Input[str] snapshot_id: Snapshot ID to mount.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] tags: A map of tags to assign to the device.
        :param pulumi.Input[int] throughput: Throughput to provision for a volume in mebibytes per second (MiB/s). This is only valid for `volume_type` of `gp3`.
        :param pulumi.Input[int] volume_size: Size of the volume in gibibytes (GiB).
        :param pulumi.Input[str] volume_type: Type of volume. Valid values include `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1`, or `st1`. Defaults to `gp2`.
        """
        pulumi.set(__self__, "device_name", device_name)
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)
        if volume_id is not None:
            pulumi.set(__self__, "volume_id", volume_id)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> pulumi.Input[str]:
        """
        Name of the device to mount.
        """
        return pulumi.get(self, "device_name")

    @device_name.setter
    def device_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "device_name", value)

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the volume should be destroyed on instance termination. Defaults to `true`.
        """
        return pulumi.get(self, "delete_on_termination")

    @delete_on_termination.setter
    def delete_on_termination(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delete_on_termination", value)

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables [EBS encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html) on the volume. Defaults to `false`. Cannot be used with `snapshot_id`. Must be configured to perform drift detection.
        """
        return pulumi.get(self, "encrypted")

    @encrypted.setter
    def encrypted(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "encrypted", value)

    @property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[int]]:
        """
        Amount of provisioned [IOPS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-io-characteristics.html). Only valid for volume_type of `io1`, `io2` or `gp3`.
        """
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "iops", value)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        Amazon Resource Name (ARN) of the KMS Key to use when encrypting the volume. Must be configured to perform drift detection.
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_id", value)

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[pulumi.Input[str]]:
        """
        Snapshot ID to mount.
        """
        return pulumi.get(self, "snapshot_id")

    @snapshot_id.setter
    def snapshot_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "snapshot_id", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A map of tags to assign to the device.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter
    def throughput(self) -> Optional[pulumi.Input[int]]:
        """
        Throughput to provision for a volume in mebibytes per second (MiB/s). This is only valid for `volume_type` of `gp3`.
        """
        return pulumi.get(self, "throughput")

    @throughput.setter
    def throughput(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "throughput", value)

    @property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "volume_id")

    @volume_id.setter
    def volume_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volume_id", value)

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[pulumi.Input[int]]:
        """
        Size of the volume in gibibytes (GiB).
        """
        return pulumi.get(self, "volume_size")

    @volume_size.setter
    def volume_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "volume_size", value)

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of volume. Valid values include `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1`, or `st1`. Defaults to `gp2`.
        """
        return pulumi.get(self, "volume_type")

    @volume_type.setter
    def volume_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volume_type", value)


@pulumi.input_type
class SpotInstanceRequestEnclaveOptionsArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: Whether Nitro Enclaves will be enabled on the instance. Defaults to `false`.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether Nitro Enclaves will be enabled on the instance. Defaults to `false`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class SpotInstanceRequestEphemeralBlockDeviceArgs:
    def __init__(__self__, *,
                 device_name: pulumi.Input[str],
                 no_device: Optional[pulumi.Input[bool]] = None,
                 virtual_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] device_name: The name of the block device to mount on the instance.
        :param pulumi.Input[bool] no_device: Suppresses the specified device included in the AMI's block device mapping.
        :param pulumi.Input[str] virtual_name: [Instance Store Device Name](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#InstanceStoreDeviceNames) (e.g. `ephemeral0`).
        """
        pulumi.set(__self__, "device_name", device_name)
        if no_device is not None:
            pulumi.set(__self__, "no_device", no_device)
        if virtual_name is not None:
            pulumi.set(__self__, "virtual_name", virtual_name)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> pulumi.Input[str]:
        """
        The name of the block device to mount on the instance.
        """
        return pulumi.get(self, "device_name")

    @device_name.setter
    def device_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "device_name", value)

    @property
    @pulumi.getter(name="noDevice")
    def no_device(self) -> Optional[pulumi.Input[bool]]:
        """
        Suppresses the specified device included in the AMI's block device mapping.
        """
        return pulumi.get(self, "no_device")

    @no_device.setter
    def no_device(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_device", value)

    @property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> Optional[pulumi.Input[str]]:
        """
        [Instance Store Device Name](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#InstanceStoreDeviceNames) (e.g. `ephemeral0`).
        """
        return pulumi.get(self, "virtual_name")

    @virtual_name.setter
    def virtual_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "virtual_name", value)


@pulumi.input_type
class SpotInstanceRequestLaunchTemplateArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: The ID of the launch template. Conflicts with `name`.
        :param pulumi.Input[str] name: The name of the launch template. Conflicts with `id`.
        :param pulumi.Input[str] version: Template version. Can be a specific version number, `$Latest` or `$Default`. The default value is `$Default`.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the launch template. Conflicts with `name`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the launch template. Conflicts with `id`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Template version. Can be a specific version number, `$Latest` or `$Default`. The default value is `$Default`.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class SpotInstanceRequestMetadataOptionsArgs:
    def __init__(__self__, *,
                 http_endpoint: Optional[pulumi.Input[str]] = None,
                 http_put_response_hop_limit: Optional[pulumi.Input[int]] = None,
                 http_tokens: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] http_endpoint: Whether the metadata service is available. Valid values include `enabled` or `disabled`. Defaults to `enabled`.
        :param pulumi.Input[int] http_put_response_hop_limit: Desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel. Valid values are integer from `1` to `64`. Defaults to `1`.
        :param pulumi.Input[str] http_tokens: Whether or not the metadata service requires session tokens, also referred to as _Instance Metadata Service Version 2 (IMDSv2)_. Valid values include `optional` or `required`. Defaults to `optional`.
        """
        if http_endpoint is not None:
            pulumi.set(__self__, "http_endpoint", http_endpoint)
        if http_put_response_hop_limit is not None:
            pulumi.set(__self__, "http_put_response_hop_limit", http_put_response_hop_limit)
        if http_tokens is not None:
            pulumi.set(__self__, "http_tokens", http_tokens)

    @property
    @pulumi.getter(name="httpEndpoint")
    def http_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        Whether the metadata service is available. Valid values include `enabled` or `disabled`. Defaults to `enabled`.
        """
        return pulumi.get(self, "http_endpoint")

    @http_endpoint.setter
    def http_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_endpoint", value)

    @property
    @pulumi.getter(name="httpPutResponseHopLimit")
    def http_put_response_hop_limit(self) -> Optional[pulumi.Input[int]]:
        """
        Desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel. Valid values are integer from `1` to `64`. Defaults to `1`.
        """
        return pulumi.get(self, "http_put_response_hop_limit")

    @http_put_response_hop_limit.setter
    def http_put_response_hop_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "http_put_response_hop_limit", value)

    @property
    @pulumi.getter(name="httpTokens")
    def http_tokens(self) -> Optional[pulumi.Input[str]]:
        """
        Whether or not the metadata service requires session tokens, also referred to as _Instance Metadata Service Version 2 (IMDSv2)_. Valid values include `optional` or `required`. Defaults to `optional`.
        """
        return pulumi.get(self, "http_tokens")

    @http_tokens.setter
    def http_tokens(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_tokens", value)


@pulumi.input_type
class SpotInstanceRequestNetworkInterfaceArgs:
    def __init__(__self__, *,
                 device_index: pulumi.Input[int],
                 network_interface_id: pulumi.Input[str],
                 delete_on_termination: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[int] device_index: Integer index of the network interface attachment. Limited by instance type.
        :param pulumi.Input[str] network_interface_id: ID of the network interface to attach.
        :param pulumi.Input[bool] delete_on_termination: Whether or not to delete the network interface on instance termination. Defaults to `false`. Currently, the only valid value is `false`, as this is only supported when creating new network interfaces when launching an instance.
        """
        pulumi.set(__self__, "device_index", device_index)
        pulumi.set(__self__, "network_interface_id", network_interface_id)
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)

    @property
    @pulumi.getter(name="deviceIndex")
    def device_index(self) -> pulumi.Input[int]:
        """
        Integer index of the network interface attachment. Limited by instance type.
        """
        return pulumi.get(self, "device_index")

    @device_index.setter
    def device_index(self, value: pulumi.Input[int]):
        pulumi.set(self, "device_index", value)

    @property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> pulumi.Input[str]:
        """
        ID of the network interface to attach.
        """
        return pulumi.get(self, "network_interface_id")

    @network_interface_id.setter
    def network_interface_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "network_interface_id", value)

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not to delete the network interface on instance termination. Defaults to `false`. Currently, the only valid value is `false`, as this is only supported when creating new network interfaces when launching an instance.
        """
        return pulumi.get(self, "delete_on_termination")

    @delete_on_termination.setter
    def delete_on_termination(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delete_on_termination", value)


@pulumi.input_type
class SpotInstanceRequestRootBlockDeviceArgs:
    def __init__(__self__, *,
                 delete_on_termination: Optional[pulumi.Input[bool]] = None,
                 device_name: Optional[pulumi.Input[str]] = None,
                 encrypted: Optional[pulumi.Input[bool]] = None,
                 iops: Optional[pulumi.Input[int]] = None,
                 kms_key_id: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 throughput: Optional[pulumi.Input[int]] = None,
                 volume_id: Optional[pulumi.Input[str]] = None,
                 volume_size: Optional[pulumi.Input[int]] = None,
                 volume_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] delete_on_termination: Whether the volume should be destroyed on instance termination. Defaults to `true`.
        :param pulumi.Input[str] device_name: Name of the device to mount.
        :param pulumi.Input[bool] encrypted: Whether to enable volume encryption. Defaults to `false`. Must be configured to perform drift detection.
        :param pulumi.Input[int] iops: Amount of provisioned [IOPS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-io-characteristics.html). Only valid for volume_type of `io1`, `io2` or `gp3`.
        :param pulumi.Input[str] kms_key_id: Amazon Resource Name (ARN) of the KMS Key to use when encrypting the volume. Must be configured to perform drift detection.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] tags: A map of tags to assign to the device.
        :param pulumi.Input[int] throughput: Throughput to provision for a volume in mebibytes per second (MiB/s). This is only valid for `volume_type` of `gp3`.
        :param pulumi.Input[int] volume_size: Size of the volume in gibibytes (GiB).
        :param pulumi.Input[str] volume_type: Type of volume. Valid values include `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1`, or `st1`. Defaults to `gp2`.
        """
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)
        if volume_id is not None:
            pulumi.set(__self__, "volume_id", volume_id)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the volume should be destroyed on instance termination. Defaults to `true`.
        """
        return pulumi.get(self, "delete_on_termination")

    @delete_on_termination.setter
    def delete_on_termination(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delete_on_termination", value)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the device to mount.
        """
        return pulumi.get(self, "device_name")

    @device_name.setter
    def device_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "device_name", value)

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to enable volume encryption. Defaults to `false`. Must be configured to perform drift detection.
        """
        return pulumi.get(self, "encrypted")

    @encrypted.setter
    def encrypted(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "encrypted", value)

    @property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[int]]:
        """
        Amount of provisioned [IOPS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-io-characteristics.html). Only valid for volume_type of `io1`, `io2` or `gp3`.
        """
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "iops", value)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        Amazon Resource Name (ARN) of the KMS Key to use when encrypting the volume. Must be configured to perform drift detection.
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_id", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A map of tags to assign to the device.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter
    def throughput(self) -> Optional[pulumi.Input[int]]:
        """
        Throughput to provision for a volume in mebibytes per second (MiB/s). This is only valid for `volume_type` of `gp3`.
        """
        return pulumi.get(self, "throughput")

    @throughput.setter
    def throughput(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "throughput", value)

    @property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "volume_id")

    @volume_id.setter
    def volume_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volume_id", value)

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[pulumi.Input[int]]:
        """
        Size of the volume in gibibytes (GiB).
        """
        return pulumi.get(self, "volume_size")

    @volume_size.setter
    def volume_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "volume_size", value)

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of volume. Valid values include `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1`, or `st1`. Defaults to `gp2`.
        """
        return pulumi.get(self, "volume_type")

    @volume_type.setter
    def volume_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volume_type", value)


@pulumi.input_type
class TrafficMirrorFilterRuleDestinationPortRangeArgs:
    def __init__(__self__, *,
                 from_port: Optional[pulumi.Input[int]] = None,
                 to_port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] from_port: Starting port of the range
        :param pulumi.Input[int] to_port: Ending port of the range
        """
        if from_port is not None:
            pulumi.set(__self__, "from_port", from_port)
        if to_port is not None:
            pulumi.set(__self__, "to_port", to_port)

    @property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> Optional[pulumi.Input[int]]:
        """
        Starting port of the range
        """
        return pulumi.get(self, "from_port")

    @from_port.setter
    def from_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "from_port", value)

    @property
    @pulumi.getter(name="toPort")
    def to_port(self) -> Optional[pulumi.Input[int]]:
        """
        Ending port of the range
        """
        return pulumi.get(self, "to_port")

    @to_port.setter
    def to_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "to_port", value)


@pulumi.input_type
class TrafficMirrorFilterRuleSourcePortRangeArgs:
    def __init__(__self__, *,
                 from_port: Optional[pulumi.Input[int]] = None,
                 to_port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] from_port: Starting port of the range
        :param pulumi.Input[int] to_port: Ending port of the range
        """
        if from_port is not None:
            pulumi.set(__self__, "from_port", from_port)
        if to_port is not None:
            pulumi.set(__self__, "to_port", to_port)

    @property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> Optional[pulumi.Input[int]]:
        """
        Starting port of the range
        """
        return pulumi.get(self, "from_port")

    @from_port.setter
    def from_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "from_port", value)

    @property
    @pulumi.getter(name="toPort")
    def to_port(self) -> Optional[pulumi.Input[int]]:
        """
        Ending port of the range
        """
        return pulumi.get(self, "to_port")

    @to_port.setter
    def to_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "to_port", value)


@pulumi.input_type
class VpcEndpointDnsEntryArgs:
    def __init__(__self__, *,
                 dns_name: Optional[pulumi.Input[str]] = None,
                 hosted_zone_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] dns_name: The DNS name.
        :param pulumi.Input[str] hosted_zone_id: The ID of the private hosted zone.
        """
        if dns_name is not None:
            pulumi.set(__self__, "dns_name", dns_name)
        if hosted_zone_id is not None:
            pulumi.set(__self__, "hosted_zone_id", hosted_zone_id)

    @property
    @pulumi.getter(name="dnsName")
    def dns_name(self) -> Optional[pulumi.Input[str]]:
        """
        The DNS name.
        """
        return pulumi.get(self, "dns_name")

    @dns_name.setter
    def dns_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dns_name", value)

    @property
    @pulumi.getter(name="hostedZoneId")
    def hosted_zone_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the private hosted zone.
        """
        return pulumi.get(self, "hosted_zone_id")

    @hosted_zone_id.setter
    def hosted_zone_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hosted_zone_id", value)


@pulumi.input_type
class VpcEndpointServicePrivateDnsNameConfigurationArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the record subdomain the service provider needs to create.
        :param pulumi.Input[str] state: Verification state of the VPC endpoint service. Consumers of the endpoint service can use the private name only when the state is `verified`.
        :param pulumi.Input[str] type: Endpoint service verification type, for example `TXT`.
        :param pulumi.Input[str] value: Value the service provider adds to the private DNS name domain record before verification.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the record subdomain the service provider needs to create.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        Verification state of the VPC endpoint service. Consumers of the endpoint service can use the private name only when the state is `verified`.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Endpoint service verification type, for example `TXT`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value the service provider adds to the private DNS name domain record before verification.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class VpcPeeringConnectionAccepterArgs:
    def __init__(__self__, *,
                 allow_classic_link_to_remote_vpc: Optional[pulumi.Input[bool]] = None,
                 allow_remote_vpc_dns_resolution: Optional[pulumi.Input[bool]] = None,
                 allow_vpc_to_remote_classic_link: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] allow_classic_link_to_remote_vpc: Allow a local linked EC2-Classic instance to communicate
               with instances in a peer VPC. This enables an outbound communication from the local ClassicLink connection
               to the remote VPC.
        :param pulumi.Input[bool] allow_remote_vpc_dns_resolution: Allow a local VPC to resolve public DNS hostnames to
               private IP addresses when queried from instances in the peer VPC.
        :param pulumi.Input[bool] allow_vpc_to_remote_classic_link: Allow a local VPC to communicate with a linked EC2-Classic
               instance in a peer VPC. This enables an outbound communication from the local VPC to the remote ClassicLink
               connection.
        """
        if allow_classic_link_to_remote_vpc is not None:
            pulumi.set(__self__, "allow_classic_link_to_remote_vpc", allow_classic_link_to_remote_vpc)
        if allow_remote_vpc_dns_resolution is not None:
            pulumi.set(__self__, "allow_remote_vpc_dns_resolution", allow_remote_vpc_dns_resolution)
        if allow_vpc_to_remote_classic_link is not None:
            pulumi.set(__self__, "allow_vpc_to_remote_classic_link", allow_vpc_to_remote_classic_link)

    @property
    @pulumi.getter(name="allowClassicLinkToRemoteVpc")
    def allow_classic_link_to_remote_vpc(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow a local linked EC2-Classic instance to communicate
        with instances in a peer VPC. This enables an outbound communication from the local ClassicLink connection
        to the remote VPC.
        """
        return pulumi.get(self, "allow_classic_link_to_remote_vpc")

    @allow_classic_link_to_remote_vpc.setter
    def allow_classic_link_to_remote_vpc(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_classic_link_to_remote_vpc", value)

    @property
    @pulumi.getter(name="allowRemoteVpcDnsResolution")
    def allow_remote_vpc_dns_resolution(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow a local VPC to resolve public DNS hostnames to
        private IP addresses when queried from instances in the peer VPC.
        """
        return pulumi.get(self, "allow_remote_vpc_dns_resolution")

    @allow_remote_vpc_dns_resolution.setter
    def allow_remote_vpc_dns_resolution(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_remote_vpc_dns_resolution", value)

    @property
    @pulumi.getter(name="allowVpcToRemoteClassicLink")
    def allow_vpc_to_remote_classic_link(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow a local VPC to communicate with a linked EC2-Classic
        instance in a peer VPC. This enables an outbound communication from the local VPC to the remote ClassicLink
        connection.
        """
        return pulumi.get(self, "allow_vpc_to_remote_classic_link")

    @allow_vpc_to_remote_classic_link.setter
    def allow_vpc_to_remote_classic_link(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_vpc_to_remote_classic_link", value)


@pulumi.input_type
class VpcPeeringConnectionAccepterAccepterArgs:
    def __init__(__self__, *,
                 allow_classic_link_to_remote_vpc: Optional[pulumi.Input[bool]] = None,
                 allow_remote_vpc_dns_resolution: Optional[pulumi.Input[bool]] = None,
                 allow_vpc_to_remote_classic_link: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] allow_classic_link_to_remote_vpc: Indicates whether a local ClassicLink connection can communicate
               with the peer VPC over the VPC Peering Connection.
        :param pulumi.Input[bool] allow_remote_vpc_dns_resolution: Indicates whether a local VPC can resolve public DNS hostnames to
               private IP addresses when queried from instances in a peer VPC.
        :param pulumi.Input[bool] allow_vpc_to_remote_classic_link: Indicates whether a local VPC can communicate with a ClassicLink
               connection in the peer VPC over the VPC Peering Connection.
        """
        if allow_classic_link_to_remote_vpc is not None:
            pulumi.set(__self__, "allow_classic_link_to_remote_vpc", allow_classic_link_to_remote_vpc)
        if allow_remote_vpc_dns_resolution is not None:
            pulumi.set(__self__, "allow_remote_vpc_dns_resolution", allow_remote_vpc_dns_resolution)
        if allow_vpc_to_remote_classic_link is not None:
            pulumi.set(__self__, "allow_vpc_to_remote_classic_link", allow_vpc_to_remote_classic_link)

    @property
    @pulumi.getter(name="allowClassicLinkToRemoteVpc")
    def allow_classic_link_to_remote_vpc(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether a local ClassicLink connection can communicate
        with the peer VPC over the VPC Peering Connection.
        """
        return pulumi.get(self, "allow_classic_link_to_remote_vpc")

    @allow_classic_link_to_remote_vpc.setter
    def allow_classic_link_to_remote_vpc(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_classic_link_to_remote_vpc", value)

    @property
    @pulumi.getter(name="allowRemoteVpcDnsResolution")
    def allow_remote_vpc_dns_resolution(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether a local VPC can resolve public DNS hostnames to
        private IP addresses when queried from instances in a peer VPC.
        """
        return pulumi.get(self, "allow_remote_vpc_dns_resolution")

    @allow_remote_vpc_dns_resolution.setter
    def allow_remote_vpc_dns_resolution(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_remote_vpc_dns_resolution", value)

    @property
    @pulumi.getter(name="allowVpcToRemoteClassicLink")
    def allow_vpc_to_remote_classic_link(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether a local VPC can communicate with a ClassicLink
        connection in the peer VPC over the VPC Peering Connection.
        """
        return pulumi.get(self, "allow_vpc_to_remote_classic_link")

    @allow_vpc_to_remote_classic_link.setter
    def allow_vpc_to_remote_classic_link(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_vpc_to_remote_classic_link", value)


@pulumi.input_type
class VpcPeeringConnectionAccepterRequesterArgs:
    def __init__(__self__, *,
                 allow_classic_link_to_remote_vpc: Optional[pulumi.Input[bool]] = None,
                 allow_remote_vpc_dns_resolution: Optional[pulumi.Input[bool]] = None,
                 allow_vpc_to_remote_classic_link: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] allow_classic_link_to_remote_vpc: Indicates whether a local ClassicLink connection can communicate
               with the peer VPC over the VPC Peering Connection.
        :param pulumi.Input[bool] allow_remote_vpc_dns_resolution: Indicates whether a local VPC can resolve public DNS hostnames to
               private IP addresses when queried from instances in a peer VPC.
        :param pulumi.Input[bool] allow_vpc_to_remote_classic_link: Indicates whether a local VPC can communicate with a ClassicLink
               connection in the peer VPC over the VPC Peering Connection.
        """
        if allow_classic_link_to_remote_vpc is not None:
            pulumi.set(__self__, "allow_classic_link_to_remote_vpc", allow_classic_link_to_remote_vpc)
        if allow_remote_vpc_dns_resolution is not None:
            pulumi.set(__self__, "allow_remote_vpc_dns_resolution", allow_remote_vpc_dns_resolution)
        if allow_vpc_to_remote_classic_link is not None:
            pulumi.set(__self__, "allow_vpc_to_remote_classic_link", allow_vpc_to_remote_classic_link)

    @property
    @pulumi.getter(name="allowClassicLinkToRemoteVpc")
    def allow_classic_link_to_remote_vpc(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether a local ClassicLink connection can communicate
        with the peer VPC over the VPC Peering Connection.
        """
        return pulumi.get(self, "allow_classic_link_to_remote_vpc")

    @allow_classic_link_to_remote_vpc.setter
    def allow_classic_link_to_remote_vpc(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_classic_link_to_remote_vpc", value)

    @property
    @pulumi.getter(name="allowRemoteVpcDnsResolution")
    def allow_remote_vpc_dns_resolution(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether a local VPC can resolve public DNS hostnames to
        private IP addresses when queried from instances in a peer VPC.
        """
        return pulumi.get(self, "allow_remote_vpc_dns_resolution")

    @allow_remote_vpc_dns_resolution.setter
    def allow_remote_vpc_dns_resolution(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_remote_vpc_dns_resolution", value)

    @property
    @pulumi.getter(name="allowVpcToRemoteClassicLink")
    def allow_vpc_to_remote_classic_link(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether a local VPC can communicate with a ClassicLink
        connection in the peer VPC over the VPC Peering Connection.
        """
        return pulumi.get(self, "allow_vpc_to_remote_classic_link")

    @allow_vpc_to_remote_classic_link.setter
    def allow_vpc_to_remote_classic_link(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_vpc_to_remote_classic_link", value)


@pulumi.input_type
class VpcPeeringConnectionRequesterArgs:
    def __init__(__self__, *,
                 allow_classic_link_to_remote_vpc: Optional[pulumi.Input[bool]] = None,
                 allow_remote_vpc_dns_resolution: Optional[pulumi.Input[bool]] = None,
                 allow_vpc_to_remote_classic_link: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] allow_classic_link_to_remote_vpc: Allow a local linked EC2-Classic instance to communicate
               with instances in a peer VPC. This enables an outbound communication from the local ClassicLink connection
               to the remote VPC.
        :param pulumi.Input[bool] allow_remote_vpc_dns_resolution: Allow a local VPC to resolve public DNS hostnames to
               private IP addresses when queried from instances in the peer VPC.
        :param pulumi.Input[bool] allow_vpc_to_remote_classic_link: Allow a local VPC to communicate with a linked EC2-Classic
               instance in a peer VPC. This enables an outbound communication from the local VPC to the remote ClassicLink
               connection.
        """
        if allow_classic_link_to_remote_vpc is not None:
            pulumi.set(__self__, "allow_classic_link_to_remote_vpc", allow_classic_link_to_remote_vpc)
        if allow_remote_vpc_dns_resolution is not None:
            pulumi.set(__self__, "allow_remote_vpc_dns_resolution", allow_remote_vpc_dns_resolution)
        if allow_vpc_to_remote_classic_link is not None:
            pulumi.set(__self__, "allow_vpc_to_remote_classic_link", allow_vpc_to_remote_classic_link)

    @property
    @pulumi.getter(name="allowClassicLinkToRemoteVpc")
    def allow_classic_link_to_remote_vpc(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow a local linked EC2-Classic instance to communicate
        with instances in a peer VPC. This enables an outbound communication from the local ClassicLink connection
        to the remote VPC.
        """
        return pulumi.get(self, "allow_classic_link_to_remote_vpc")

    @allow_classic_link_to_remote_vpc.setter
    def allow_classic_link_to_remote_vpc(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_classic_link_to_remote_vpc", value)

    @property
    @pulumi.getter(name="allowRemoteVpcDnsResolution")
    def allow_remote_vpc_dns_resolution(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow a local VPC to resolve public DNS hostnames to
        private IP addresses when queried from instances in the peer VPC.
        """
        return pulumi.get(self, "allow_remote_vpc_dns_resolution")

    @allow_remote_vpc_dns_resolution.setter
    def allow_remote_vpc_dns_resolution(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_remote_vpc_dns_resolution", value)

    @property
    @pulumi.getter(name="allowVpcToRemoteClassicLink")
    def allow_vpc_to_remote_classic_link(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow a local VPC to communicate with a linked EC2-Classic
        instance in a peer VPC. This enables an outbound communication from the local VPC to the remote ClassicLink
        connection.
        """
        return pulumi.get(self, "allow_vpc_to_remote_classic_link")

    @allow_vpc_to_remote_classic_link.setter
    def allow_vpc_to_remote_classic_link(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_vpc_to_remote_classic_link", value)


@pulumi.input_type
class VpnConnectionRouteArgs:
    def __init__(__self__, *,
                 destination_cidr_block: Optional[pulumi.Input[str]] = None,
                 source: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None):
        if destination_cidr_block is not None:
            pulumi.set(__self__, "destination_cidr_block", destination_cidr_block)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="destinationCidrBlock")
    def destination_cidr_block(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "destination_cidr_block")

    @destination_cidr_block.setter
    def destination_cidr_block(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination_cidr_block", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)


@pulumi.input_type
class VpnConnectionVgwTelemetryArgs:
    def __init__(__self__, *,
                 accepted_route_count: Optional[pulumi.Input[int]] = None,
                 last_status_change: Optional[pulumi.Input[str]] = None,
                 outside_ip_address: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 status_message: Optional[pulumi.Input[str]] = None):
        if accepted_route_count is not None:
            pulumi.set(__self__, "accepted_route_count", accepted_route_count)
        if last_status_change is not None:
            pulumi.set(__self__, "last_status_change", last_status_change)
        if outside_ip_address is not None:
            pulumi.set(__self__, "outside_ip_address", outside_ip_address)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if status_message is not None:
            pulumi.set(__self__, "status_message", status_message)

    @property
    @pulumi.getter(name="acceptedRouteCount")
    def accepted_route_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "accepted_route_count")

    @accepted_route_count.setter
    def accepted_route_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "accepted_route_count", value)

    @property
    @pulumi.getter(name="lastStatusChange")
    def last_status_change(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "last_status_change")

    @last_status_change.setter
    def last_status_change(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_status_change", value)

    @property
    @pulumi.getter(name="outsideIpAddress")
    def outside_ip_address(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "outside_ip_address")

    @outside_ip_address.setter
    def outside_ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "outside_ip_address", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter(name="statusMessage")
    def status_message(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "status_message")

    @status_message.setter
    def status_message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status_message", value)


@pulumi.input_type
class GetAmiFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: The name of the AMI that was provided during image creation.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the AMI that was provided during image creation.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GetAmiIdsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GetCoipPoolFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: The name of the field to filter by, as defined by
               [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeCoipPools.html).
        :param Sequence[str] values: Set of values that are accepted for the given field.
               A COIP Pool will be selected if any one of the given values matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the field to filter by, as defined by
        [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeCoipPools.html).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Set of values that are accepted for the given field.
        A COIP Pool will be selected if any one of the given values matches.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GetCoipPoolsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: The name of the field to filter by, as defined by
               [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeCoipPools.html).
        :param Sequence[str] values: Set of values that are accepted for the given field.
               A COIP Pool will be selected if any one of the given values matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the field to filter by, as defined by
        [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeCoipPools.html).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Set of values that are accepted for the given field.
        A COIP Pool will be selected if any one of the given values matches.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GetCustomerGatewayFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GetDedicatedHostFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: The name of the field to filter by, as defined by [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeHosts.html).
        :param Sequence[str] values: Set of values that are accepted for the given field. A host will be selected if any one of the given values matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the field to filter by, as defined by [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeHosts.html).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Set of values that are accepted for the given field. A host will be selected if any one of the given values matches.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GetElasticIpFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GetInstanceFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GetInstanceTypeFpgaArgs:
    def __init__(__self__, *,
                 count: int,
                 manufacturer: str,
                 memory_size: int,
                 name: str):
        """
        :param int memory_size: Size of the instance memory, in MiB.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "manufacturer", manufacturer)
        pulumi.set(__self__, "memory_size", memory_size)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def count(self) -> int:
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: int):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def manufacturer(self) -> str:
        return pulumi.get(self, "manufacturer")

    @manufacturer.setter
    def manufacturer(self, value: str):
        pulumi.set(self, "manufacturer", value)

    @property
    @pulumi.getter(name="memorySize")
    def memory_size(self) -> int:
        """
        Size of the instance memory, in MiB.
        """
        return pulumi.get(self, "memory_size")

    @memory_size.setter
    def memory_size(self, value: int):
        pulumi.set(self, "memory_size", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)


@pulumi.input_type
class GetInstanceTypeGpusArgs:
    def __init__(__self__, *,
                 count: int,
                 manufacturer: str,
                 memory_size: int,
                 name: str):
        """
        :param int memory_size: Size of the instance memory, in MiB.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "manufacturer", manufacturer)
        pulumi.set(__self__, "memory_size", memory_size)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def count(self) -> int:
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: int):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def manufacturer(self) -> str:
        return pulumi.get(self, "manufacturer")

    @manufacturer.setter
    def manufacturer(self, value: str):
        pulumi.set(self, "manufacturer", value)

    @property
    @pulumi.getter(name="memorySize")
    def memory_size(self) -> int:
        """
        Size of the instance memory, in MiB.
        """
        return pulumi.get(self, "memory_size")

    @memory_size.setter
    def memory_size(self, value: int):
        pulumi.set(self, "memory_size", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)


@pulumi.input_type
class GetInstanceTypeInferenceAcceleratorArgs:
    def __init__(__self__, *,
                 count: int,
                 manufacturer: str,
                 name: str):
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "manufacturer", manufacturer)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def count(self) -> int:
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: int):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def manufacturer(self) -> str:
        return pulumi.get(self, "manufacturer")

    @manufacturer.setter
    def manufacturer(self, value: str):
        pulumi.set(self, "manufacturer", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)


@pulumi.input_type
class GetInstanceTypeInstanceDiskArgs:
    def __init__(__self__, *,
                 count: int,
                 size: int,
                 type: str):
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def count(self) -> int:
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: int):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def size(self) -> int:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: int):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: str):
        pulumi.set(self, "type", value)


@pulumi.input_type
class GetInstanceTypeOfferingFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Name of the filter. The `location` filter depends on the top-level `location_type` argument and if not specified, defaults to the current region.
        :param Sequence[str] values: List of one or more values for the filter.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the filter. The `location` filter depends on the top-level `location_type` argument and if not specified, defaults to the current region.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        List of one or more values for the filter.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GetInstanceTypeOfferingsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Name of the filter. The `location` filter depends on the top-level `location_type` argument and if not specified, defaults to the current region.
        :param Sequence[str] values: List of one or more values for the filter.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the filter. The `location` filter depends on the top-level `location_type` argument and if not specified, defaults to the current region.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        List of one or more values for the filter.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GetInstancesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GetInternetGatewayFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: The name of the field to filter by, as defined by
               [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeInternetGateways.html).
        :param Sequence[str] values: Set of values that are accepted for the given field.
               An Internet Gateway will be selected if any one of the given values matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the field to filter by, as defined by
        [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeInternetGateways.html).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Set of values that are accepted for the given field.
        An Internet Gateway will be selected if any one of the given values matches.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GetLaunchTemplateFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: The name of the filter field. Valid values can be found in the [EC2 DescribeLaunchTemplates API Reference](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeLaunchTemplates.html).
        :param Sequence[str] values: Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the filter field. Valid values can be found in the [EC2 DescribeLaunchTemplates API Reference](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeLaunchTemplates.html).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GetLocalGatewayFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: The name of the field to filter by, as defined by
               [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeLocalGateways.html).
        :param Sequence[str] values: Set of values that are accepted for the given field.
               A Local Gateway will be selected if any one of the given values matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the field to filter by, as defined by
        [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeLocalGateways.html).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Set of values that are accepted for the given field.
        A Local Gateway will be selected if any one of the given values matches.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GetLocalGatewayRouteTableFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: The name of the field to filter by, as defined by
               [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeLocalGatewayRouteTables.html).
        :param Sequence[str] values: Set of values that are accepted for the given field.
               A local gateway route table will be selected if any one of the given values matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the field to filter by, as defined by
        [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeLocalGatewayRouteTables.html).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Set of values that are accepted for the given field.
        A local gateway route table will be selected if any one of the given values matches.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GetLocalGatewayRouteTablesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: The name of the field to filter by, as defined by
               [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeLocalGatewayRouteTables.html).
        :param Sequence[str] values: Set of values that are accepted for the given field.
               A Local Gateway Route Table will be selected if any one of the given values matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the field to filter by, as defined by
        [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeLocalGatewayRouteTables.html).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Set of values that are accepted for the given field.
        A Local Gateway Route Table will be selected if any one of the given values matches.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GetLocalGatewayVirtualInterfaceFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Name of the filter.
        :param Sequence[str] values: List of one or more values for the filter.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the filter.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        List of one or more values for the filter.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GetLocalGatewayVirtualInterfaceGroupFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Name of the filter.
        :param Sequence[str] values: List of one or more values for the filter.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the filter.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        List of one or more values for the filter.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GetLocalGatewayVirtualInterfaceGroupsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Name of the filter.
        :param Sequence[str] values: List of one or more values for the filter.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the filter.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        List of one or more values for the filter.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GetLocalGatewaysFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: The name of the field to filter by, as defined by
               [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeLocalGateways.html).
        :param Sequence[str] values: Set of values that are accepted for the given field.
               A Local Gateway will be selected if any one of the given values matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the field to filter by, as defined by
        [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeLocalGateways.html).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Set of values that are accepted for the given field.
        A Local Gateway will be selected if any one of the given values matches.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GetManagedPrefixListFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: The name of the filter field. Valid values can be found in the EC2 [DescribeManagedPrefixLists](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeManagedPrefixLists.html) API Reference.
        :param Sequence[str] values: Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the filter field. Valid values can be found in the EC2 [DescribeManagedPrefixLists](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeManagedPrefixLists.html) API Reference.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GetNatGatewayFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: The name of the field to filter by, as defined by
               [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNatGateways.html).
        :param Sequence[str] values: Set of values that are accepted for the given field.
               An Nat Gateway will be selected if any one of the given values matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the field to filter by, as defined by
        [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNatGateways.html).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Set of values that are accepted for the given field.
        An Nat Gateway will be selected if any one of the given values matches.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GetNetworkAclsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: The name of the field to filter by, as defined by
               [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkAcls.html).
        :param Sequence[str] values: Set of values that are accepted for the given field.
               A VPC will be selected if any one of the given values matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the field to filter by, as defined by
        [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkAcls.html).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Set of values that are accepted for the given field.
        A VPC will be selected if any one of the given values matches.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GetNetworkInterfaceFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GetNetworkInterfacesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: The name of the field to filter by, as defined by
               [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInterfaces.html).
        :param Sequence[str] values: Set of values that are accepted for the given field.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the field to filter by, as defined by
        [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInterfaces.html).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Set of values that are accepted for the given field.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GetPrefixListFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: The name of the filter field. Valid values can be found in the [EC2 DescribePrefixLists API Reference](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribePrefixLists.html).
        :param Sequence[str] values: Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the filter field. Valid values can be found in the [EC2 DescribePrefixLists API Reference](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribePrefixLists.html).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GetRouteTableFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Name of the field to filter by, as defined by [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeRouteTables.html).
        :param Sequence[str] values: Set of values that are accepted for the given field. A Route Table will be selected if any one of the given values matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the field to filter by, as defined by [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeRouteTables.html).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Set of values that are accepted for the given field. A Route Table will be selected if any one of the given values matches.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GetRouteTablesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: The name of the field to filter by, as defined by
               [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeRouteTables.html).
        :param Sequence[str] values: Set of values that are accepted for the given field.
               A Route Table will be selected if any one of the given values matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the field to filter by, as defined by
        [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeRouteTables.html).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Set of values that are accepted for the given field.
        A Route Table will be selected if any one of the given values matches.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GetSecurityGroupFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: The name of the field to filter by, as defined by
               [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeSecurityGroups.html).
        :param Sequence[str] values: Set of values that are accepted for the given field.
               A Security Group will be selected if any one of the given values matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the field to filter by, as defined by
        [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeSecurityGroups.html).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Set of values that are accepted for the given field.
        A Security Group will be selected if any one of the given values matches.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GetSecurityGroupsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GetSpotPriceFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Name of the filter.
        :param Sequence[str] values: List of one or more values for the filter.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the filter.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        List of one or more values for the filter.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GetSubnetFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: The name of the field to filter by, as defined by [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeSubnets.html).
        :param Sequence[str] values: Set of values that are accepted for the given field. A subnet will be selected if any one of the given values matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the field to filter by, as defined by [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeSubnets.html).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Set of values that are accepted for the given field. A subnet will be selected if any one of the given values matches.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GetSubnetIdsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: The name of the field to filter by, as defined by
               [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeSubnets.html).
               For example, if matching against tag `Name`, use:
        :param Sequence[str] values: Set of values that are accepted for the given field.
               Subnet IDs will be selected if any one of the given values match.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the field to filter by, as defined by
        [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeSubnets.html).
        For example, if matching against tag `Name`, use:
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Set of values that are accepted for the given field.
        Subnet IDs will be selected if any one of the given values match.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GetSubnetsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: The name of the field to filter by, as defined by
               [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeSubnets.html).
               For example, if matching against tag `Name`, use:
        :param Sequence[str] values: Set of values that are accepted for the given field.
               Subnet IDs will be selected if any one of the given values match.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the field to filter by, as defined by
        [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeSubnets.html).
        For example, if matching against tag `Name`, use:
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Set of values that are accepted for the given field.
        Subnet IDs will be selected if any one of the given values match.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GetTransitGatewayRouteTablesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: The name of the field to filter by, as defined by
               [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeTransitGatewayRouteTables.html).
        :param Sequence[str] values: Set of values that are accepted for the given field.
               A Transit Gateway Route Table will be selected if any one of the given values matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the field to filter by, as defined by
        [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeTransitGatewayRouteTables.html).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Set of values that are accepted for the given field.
        A Transit Gateway Route Table will be selected if any one of the given values matches.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GetVpcDhcpOptionsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: The name of the field to filter.
        :param Sequence[str] values: Set of values for filtering.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the field to filter.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Set of values for filtering.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GetVpcEndpointFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: The name of the field to filter by, as defined by
               [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcEndpoints.html).
        :param Sequence[str] values: Set of values that are accepted for the given field.
               A VPC Endpoint will be selected if any one of the given values matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the field to filter by, as defined by
        [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcEndpoints.html).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Set of values that are accepted for the given field.
        A VPC Endpoint will be selected if any one of the given values matches.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GetVpcEndpointServiceFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: The name of the filter field. Valid values can be found in the [EC2 DescribeVpcEndpointServices API Reference](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcEndpointServices.html).
        :param Sequence[str] values: Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the filter field. Valid values can be found in the [EC2 DescribeVpcEndpointServices API Reference](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcEndpointServices.html).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GetVpcFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: The name of the field to filter by, as defined by
               [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcs.html).
        :param Sequence[str] values: Set of values that are accepted for the given field.
               A VPC will be selected if any one of the given values matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the field to filter by, as defined by
        [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcs.html).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Set of values that are accepted for the given field.
        A VPC will be selected if any one of the given values matches.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GetVpcPeeringConnectionFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: The name of the field to filter by, as defined by
               [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcPeeringConnections.html).
        :param Sequence[str] values: Set of values that are accepted for the given field.
               A VPC Peering Connection will be selected if any one of the given values matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the field to filter by, as defined by
        [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcPeeringConnections.html).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Set of values that are accepted for the given field.
        A VPC Peering Connection will be selected if any one of the given values matches.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GetVpcPeeringConnectionsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: The name of the field to filter by, as defined by
               [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcPeeringConnections.html).
        :param Sequence[str] values: Set of values that are accepted for the given field.
               A VPC Peering Connection will be selected if any one of the given values matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the field to filter by, as defined by
        [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcPeeringConnections.html).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Set of values that are accepted for the given field.
        A VPC Peering Connection will be selected if any one of the given values matches.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GetVpcsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: The name of the field to filter by, as defined by
               [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcs.html).
        :param Sequence[str] values: Set of values that are accepted for the given field.
               A VPC will be selected if any one of the given values matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the field to filter by, as defined by
        [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcs.html).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Set of values that are accepted for the given field.
        A VPC will be selected if any one of the given values matches.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GetVpnGatewayFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: The name of the field to filter by, as defined by
               [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpnGateways.html).
        :param Sequence[str] values: Set of values that are accepted for the given field.
               A VPN Gateway will be selected if any one of the given values matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the field to filter by, as defined by
        [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpnGateways.html).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Set of values that are accepted for the given field.
        A VPN Gateway will be selected if any one of the given values matches.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


