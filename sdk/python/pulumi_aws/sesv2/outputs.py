# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'AccountVdmAttributesDashboardAttributes',
    'AccountVdmAttributesGuardianAttributes',
    'ConfigurationSetDeliveryOptions',
    'ConfigurationSetEventDestinationEventDestination',
    'ConfigurationSetEventDestinationEventDestinationCloudWatchDestination',
    'ConfigurationSetEventDestinationEventDestinationCloudWatchDestinationDimensionConfiguration',
    'ConfigurationSetEventDestinationEventDestinationKinesisFirehoseDestination',
    'ConfigurationSetEventDestinationEventDestinationPinpointDestination',
    'ConfigurationSetEventDestinationEventDestinationSnsDestination',
    'ConfigurationSetReputationOptions',
    'ConfigurationSetSendingOptions',
    'ConfigurationSetSuppressionOptions',
    'ConfigurationSetTrackingOptions',
    'ConfigurationSetVdmOptions',
    'ConfigurationSetVdmOptionsDashboardOptions',
    'ConfigurationSetVdmOptionsGuardianOptions',
    'ContactListTopic',
    'EmailIdentityDkimSigningAttributes',
    'GetConfigurationSetDeliveryOptionResult',
    'GetConfigurationSetReputationOptionResult',
    'GetConfigurationSetSendingOptionResult',
    'GetConfigurationSetSuppressionOptionResult',
    'GetConfigurationSetTrackingOptionResult',
    'GetConfigurationSetVdmOptionResult',
    'GetConfigurationSetVdmOptionDashboardOptionResult',
    'GetConfigurationSetVdmOptionGuardianOptionResult',
    'GetDedicatedIpPoolDedicatedIpResult',
    'GetEmailIdentityDkimSigningAttributeResult',
]

@pulumi.output_type
class AccountVdmAttributesDashboardAttributes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "engagementMetrics":
            suggest = "engagement_metrics"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccountVdmAttributesDashboardAttributes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccountVdmAttributesDashboardAttributes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccountVdmAttributesDashboardAttributes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 engagement_metrics: Optional[str] = None):
        """
        :param str engagement_metrics: Specifies the status of your VDM engagement metrics collection. Valid values: `ENABLED`, `DISABLED`.
        """
        AccountVdmAttributesDashboardAttributes._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            engagement_metrics=engagement_metrics,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             engagement_metrics: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if engagement_metrics is None and 'engagementMetrics' in kwargs:
            engagement_metrics = kwargs['engagementMetrics']

        if engagement_metrics is not None:
            _setter("engagement_metrics", engagement_metrics)

    @property
    @pulumi.getter(name="engagementMetrics")
    def engagement_metrics(self) -> Optional[str]:
        """
        Specifies the status of your VDM engagement metrics collection. Valid values: `ENABLED`, `DISABLED`.
        """
        return pulumi.get(self, "engagement_metrics")


@pulumi.output_type
class AccountVdmAttributesGuardianAttributes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "optimizedSharedDelivery":
            suggest = "optimized_shared_delivery"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccountVdmAttributesGuardianAttributes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccountVdmAttributesGuardianAttributes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccountVdmAttributesGuardianAttributes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 optimized_shared_delivery: Optional[str] = None):
        """
        :param str optimized_shared_delivery: Specifies the status of your VDM optimized shared delivery. Valid values: `ENABLED`, `DISABLED`.
        """
        AccountVdmAttributesGuardianAttributes._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            optimized_shared_delivery=optimized_shared_delivery,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             optimized_shared_delivery: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if optimized_shared_delivery is None and 'optimizedSharedDelivery' in kwargs:
            optimized_shared_delivery = kwargs['optimizedSharedDelivery']

        if optimized_shared_delivery is not None:
            _setter("optimized_shared_delivery", optimized_shared_delivery)

    @property
    @pulumi.getter(name="optimizedSharedDelivery")
    def optimized_shared_delivery(self) -> Optional[str]:
        """
        Specifies the status of your VDM optimized shared delivery. Valid values: `ENABLED`, `DISABLED`.
        """
        return pulumi.get(self, "optimized_shared_delivery")


@pulumi.output_type
class ConfigurationSetDeliveryOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sendingPoolName":
            suggest = "sending_pool_name"
        elif key == "tlsPolicy":
            suggest = "tls_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfigurationSetDeliveryOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfigurationSetDeliveryOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfigurationSetDeliveryOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sending_pool_name: Optional[str] = None,
                 tls_policy: Optional[str] = None):
        """
        :param str sending_pool_name: The name of the dedicated IP pool to associate with the configuration set.
        :param str tls_policy: Specifies whether messages that use the configuration set are required to use Transport Layer Security (TLS). Valid values: `REQUIRE`, `OPTIONAL`.
        """
        ConfigurationSetDeliveryOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            sending_pool_name=sending_pool_name,
            tls_policy=tls_policy,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             sending_pool_name: Optional[str] = None,
             tls_policy: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if sending_pool_name is None and 'sendingPoolName' in kwargs:
            sending_pool_name = kwargs['sendingPoolName']
        if tls_policy is None and 'tlsPolicy' in kwargs:
            tls_policy = kwargs['tlsPolicy']

        if sending_pool_name is not None:
            _setter("sending_pool_name", sending_pool_name)
        if tls_policy is not None:
            _setter("tls_policy", tls_policy)

    @property
    @pulumi.getter(name="sendingPoolName")
    def sending_pool_name(self) -> Optional[str]:
        """
        The name of the dedicated IP pool to associate with the configuration set.
        """
        return pulumi.get(self, "sending_pool_name")

    @property
    @pulumi.getter(name="tlsPolicy")
    def tls_policy(self) -> Optional[str]:
        """
        Specifies whether messages that use the configuration set are required to use Transport Layer Security (TLS). Valid values: `REQUIRE`, `OPTIONAL`.
        """
        return pulumi.get(self, "tls_policy")


@pulumi.output_type
class ConfigurationSetEventDestinationEventDestination(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchingEventTypes":
            suggest = "matching_event_types"
        elif key == "cloudWatchDestination":
            suggest = "cloud_watch_destination"
        elif key == "kinesisFirehoseDestination":
            suggest = "kinesis_firehose_destination"
        elif key == "pinpointDestination":
            suggest = "pinpoint_destination"
        elif key == "snsDestination":
            suggest = "sns_destination"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfigurationSetEventDestinationEventDestination. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfigurationSetEventDestinationEventDestination.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfigurationSetEventDestinationEventDestination.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 matching_event_types: Sequence[str],
                 cloud_watch_destination: Optional['outputs.ConfigurationSetEventDestinationEventDestinationCloudWatchDestination'] = None,
                 enabled: Optional[bool] = None,
                 kinesis_firehose_destination: Optional['outputs.ConfigurationSetEventDestinationEventDestinationKinesisFirehoseDestination'] = None,
                 pinpoint_destination: Optional['outputs.ConfigurationSetEventDestinationEventDestinationPinpointDestination'] = None,
                 sns_destination: Optional['outputs.ConfigurationSetEventDestinationEventDestinationSnsDestination'] = None):
        """
        :param Sequence[str] matching_event_types: An array that specifies which events the Amazon SES API v2 should send to the destinations. Valid values: `SEND`, `REJECT`, `BOUNCE`, `COMPLAINT`, `DELIVERY`, `OPEN`, `CLICK`, `RENDERING_FAILURE`, `DELIVERY_DELAY`, `SUBSCRIPTION`.
               
               The following arguments are optional:
        :param 'ConfigurationSetEventDestinationEventDestinationCloudWatchDestinationArgs' cloud_watch_destination: An object that defines an Amazon CloudWatch destination for email events. See cloud_watch_destination below
        :param bool enabled: When the event destination is enabled, the specified event types are sent to the destinations. Default: `false`.
        :param 'ConfigurationSetEventDestinationEventDestinationKinesisFirehoseDestinationArgs' kinesis_firehose_destination: An object that defines an Amazon Kinesis Data Firehose destination for email events. See kinesis_firehose_destination below.
        :param 'ConfigurationSetEventDestinationEventDestinationPinpointDestinationArgs' pinpoint_destination: An object that defines an Amazon Pinpoint project destination for email events. See pinpoint_destination below.
        :param 'ConfigurationSetEventDestinationEventDestinationSnsDestinationArgs' sns_destination: An object that defines an Amazon SNS destination for email events. See sns_destination below.
        """
        ConfigurationSetEventDestinationEventDestination._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            matching_event_types=matching_event_types,
            cloud_watch_destination=cloud_watch_destination,
            enabled=enabled,
            kinesis_firehose_destination=kinesis_firehose_destination,
            pinpoint_destination=pinpoint_destination,
            sns_destination=sns_destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             matching_event_types: Optional[Sequence[str]] = None,
             cloud_watch_destination: Optional['outputs.ConfigurationSetEventDestinationEventDestinationCloudWatchDestination'] = None,
             enabled: Optional[bool] = None,
             kinesis_firehose_destination: Optional['outputs.ConfigurationSetEventDestinationEventDestinationKinesisFirehoseDestination'] = None,
             pinpoint_destination: Optional['outputs.ConfigurationSetEventDestinationEventDestinationPinpointDestination'] = None,
             sns_destination: Optional['outputs.ConfigurationSetEventDestinationEventDestinationSnsDestination'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if matching_event_types is None and 'matchingEventTypes' in kwargs:
            matching_event_types = kwargs['matchingEventTypes']
        if matching_event_types is None:
            raise TypeError("Missing 'matching_event_types' argument")
        if cloud_watch_destination is None and 'cloudWatchDestination' in kwargs:
            cloud_watch_destination = kwargs['cloudWatchDestination']
        if kinesis_firehose_destination is None and 'kinesisFirehoseDestination' in kwargs:
            kinesis_firehose_destination = kwargs['kinesisFirehoseDestination']
        if pinpoint_destination is None and 'pinpointDestination' in kwargs:
            pinpoint_destination = kwargs['pinpointDestination']
        if sns_destination is None and 'snsDestination' in kwargs:
            sns_destination = kwargs['snsDestination']

        _setter("matching_event_types", matching_event_types)
        if cloud_watch_destination is not None:
            _setter("cloud_watch_destination", cloud_watch_destination)
        if enabled is not None:
            _setter("enabled", enabled)
        if kinesis_firehose_destination is not None:
            _setter("kinesis_firehose_destination", kinesis_firehose_destination)
        if pinpoint_destination is not None:
            _setter("pinpoint_destination", pinpoint_destination)
        if sns_destination is not None:
            _setter("sns_destination", sns_destination)

    @property
    @pulumi.getter(name="matchingEventTypes")
    def matching_event_types(self) -> Sequence[str]:
        """
        An array that specifies which events the Amazon SES API v2 should send to the destinations. Valid values: `SEND`, `REJECT`, `BOUNCE`, `COMPLAINT`, `DELIVERY`, `OPEN`, `CLICK`, `RENDERING_FAILURE`, `DELIVERY_DELAY`, `SUBSCRIPTION`.

        The following arguments are optional:
        """
        return pulumi.get(self, "matching_event_types")

    @property
    @pulumi.getter(name="cloudWatchDestination")
    def cloud_watch_destination(self) -> Optional['outputs.ConfigurationSetEventDestinationEventDestinationCloudWatchDestination']:
        """
        An object that defines an Amazon CloudWatch destination for email events. See cloud_watch_destination below
        """
        return pulumi.get(self, "cloud_watch_destination")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        When the event destination is enabled, the specified event types are sent to the destinations. Default: `false`.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="kinesisFirehoseDestination")
    def kinesis_firehose_destination(self) -> Optional['outputs.ConfigurationSetEventDestinationEventDestinationKinesisFirehoseDestination']:
        """
        An object that defines an Amazon Kinesis Data Firehose destination for email events. See kinesis_firehose_destination below.
        """
        return pulumi.get(self, "kinesis_firehose_destination")

    @property
    @pulumi.getter(name="pinpointDestination")
    def pinpoint_destination(self) -> Optional['outputs.ConfigurationSetEventDestinationEventDestinationPinpointDestination']:
        """
        An object that defines an Amazon Pinpoint project destination for email events. See pinpoint_destination below.
        """
        return pulumi.get(self, "pinpoint_destination")

    @property
    @pulumi.getter(name="snsDestination")
    def sns_destination(self) -> Optional['outputs.ConfigurationSetEventDestinationEventDestinationSnsDestination']:
        """
        An object that defines an Amazon SNS destination for email events. See sns_destination below.
        """
        return pulumi.get(self, "sns_destination")


@pulumi.output_type
class ConfigurationSetEventDestinationEventDestinationCloudWatchDestination(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dimensionConfigurations":
            suggest = "dimension_configurations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfigurationSetEventDestinationEventDestinationCloudWatchDestination. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfigurationSetEventDestinationEventDestinationCloudWatchDestination.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfigurationSetEventDestinationEventDestinationCloudWatchDestination.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dimension_configurations: Sequence['outputs.ConfigurationSetEventDestinationEventDestinationCloudWatchDestinationDimensionConfiguration']):
        """
        :param Sequence['ConfigurationSetEventDestinationEventDestinationCloudWatchDestinationDimensionConfigurationArgs'] dimension_configurations: An array of objects that define the dimensions to use when you send email events to Amazon CloudWatch. See dimension_configuration below.
        """
        ConfigurationSetEventDestinationEventDestinationCloudWatchDestination._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dimension_configurations=dimension_configurations,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dimension_configurations: Optional[Sequence['outputs.ConfigurationSetEventDestinationEventDestinationCloudWatchDestinationDimensionConfiguration']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if dimension_configurations is None and 'dimensionConfigurations' in kwargs:
            dimension_configurations = kwargs['dimensionConfigurations']
        if dimension_configurations is None:
            raise TypeError("Missing 'dimension_configurations' argument")

        _setter("dimension_configurations", dimension_configurations)

    @property
    @pulumi.getter(name="dimensionConfigurations")
    def dimension_configurations(self) -> Sequence['outputs.ConfigurationSetEventDestinationEventDestinationCloudWatchDestinationDimensionConfiguration']:
        """
        An array of objects that define the dimensions to use when you send email events to Amazon CloudWatch. See dimension_configuration below.
        """
        return pulumi.get(self, "dimension_configurations")


@pulumi.output_type
class ConfigurationSetEventDestinationEventDestinationCloudWatchDestinationDimensionConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultDimensionValue":
            suggest = "default_dimension_value"
        elif key == "dimensionName":
            suggest = "dimension_name"
        elif key == "dimensionValueSource":
            suggest = "dimension_value_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfigurationSetEventDestinationEventDestinationCloudWatchDestinationDimensionConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfigurationSetEventDestinationEventDestinationCloudWatchDestinationDimensionConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfigurationSetEventDestinationEventDestinationCloudWatchDestinationDimensionConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_dimension_value: str,
                 dimension_name: str,
                 dimension_value_source: str):
        """
        :param str default_dimension_value: The default value of the dimension that is published to Amazon CloudWatch if you don't provide the value of the dimension when you send an email.
        :param str dimension_name: The name of an Amazon CloudWatch dimension associated with an email sending metric.
        :param str dimension_value_source: The location where the Amazon SES API v2 finds the value of a dimension to publish to Amazon CloudWatch. Valid values: `MESSAGE_TAG`, `EMAIL_HEADER`, `LINK_TAG`.
        """
        ConfigurationSetEventDestinationEventDestinationCloudWatchDestinationDimensionConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            default_dimension_value=default_dimension_value,
            dimension_name=dimension_name,
            dimension_value_source=dimension_value_source,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             default_dimension_value: Optional[str] = None,
             dimension_name: Optional[str] = None,
             dimension_value_source: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if default_dimension_value is None and 'defaultDimensionValue' in kwargs:
            default_dimension_value = kwargs['defaultDimensionValue']
        if default_dimension_value is None:
            raise TypeError("Missing 'default_dimension_value' argument")
        if dimension_name is None and 'dimensionName' in kwargs:
            dimension_name = kwargs['dimensionName']
        if dimension_name is None:
            raise TypeError("Missing 'dimension_name' argument")
        if dimension_value_source is None and 'dimensionValueSource' in kwargs:
            dimension_value_source = kwargs['dimensionValueSource']
        if dimension_value_source is None:
            raise TypeError("Missing 'dimension_value_source' argument")

        _setter("default_dimension_value", default_dimension_value)
        _setter("dimension_name", dimension_name)
        _setter("dimension_value_source", dimension_value_source)

    @property
    @pulumi.getter(name="defaultDimensionValue")
    def default_dimension_value(self) -> str:
        """
        The default value of the dimension that is published to Amazon CloudWatch if you don't provide the value of the dimension when you send an email.
        """
        return pulumi.get(self, "default_dimension_value")

    @property
    @pulumi.getter(name="dimensionName")
    def dimension_name(self) -> str:
        """
        The name of an Amazon CloudWatch dimension associated with an email sending metric.
        """
        return pulumi.get(self, "dimension_name")

    @property
    @pulumi.getter(name="dimensionValueSource")
    def dimension_value_source(self) -> str:
        """
        The location where the Amazon SES API v2 finds the value of a dimension to publish to Amazon CloudWatch. Valid values: `MESSAGE_TAG`, `EMAIL_HEADER`, `LINK_TAG`.
        """
        return pulumi.get(self, "dimension_value_source")


@pulumi.output_type
class ConfigurationSetEventDestinationEventDestinationKinesisFirehoseDestination(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deliveryStreamArn":
            suggest = "delivery_stream_arn"
        elif key == "iamRoleArn":
            suggest = "iam_role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfigurationSetEventDestinationEventDestinationKinesisFirehoseDestination. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfigurationSetEventDestinationEventDestinationKinesisFirehoseDestination.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfigurationSetEventDestinationEventDestinationKinesisFirehoseDestination.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delivery_stream_arn: str,
                 iam_role_arn: str):
        """
        :param str delivery_stream_arn: The Amazon Resource Name (ARN) of the Amazon Kinesis Data Firehose stream that the Amazon SES API v2 sends email events to.
        :param str iam_role_arn: The Amazon Resource Name (ARN) of the IAM role that the Amazon SES API v2 uses to send email events to the Amazon Kinesis Data Firehose stream.
        """
        ConfigurationSetEventDestinationEventDestinationKinesisFirehoseDestination._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            delivery_stream_arn=delivery_stream_arn,
            iam_role_arn=iam_role_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             delivery_stream_arn: Optional[str] = None,
             iam_role_arn: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if delivery_stream_arn is None and 'deliveryStreamArn' in kwargs:
            delivery_stream_arn = kwargs['deliveryStreamArn']
        if delivery_stream_arn is None:
            raise TypeError("Missing 'delivery_stream_arn' argument")
        if iam_role_arn is None and 'iamRoleArn' in kwargs:
            iam_role_arn = kwargs['iamRoleArn']
        if iam_role_arn is None:
            raise TypeError("Missing 'iam_role_arn' argument")

        _setter("delivery_stream_arn", delivery_stream_arn)
        _setter("iam_role_arn", iam_role_arn)

    @property
    @pulumi.getter(name="deliveryStreamArn")
    def delivery_stream_arn(self) -> str:
        """
        The Amazon Resource Name (ARN) of the Amazon Kinesis Data Firehose stream that the Amazon SES API v2 sends email events to.
        """
        return pulumi.get(self, "delivery_stream_arn")

    @property
    @pulumi.getter(name="iamRoleArn")
    def iam_role_arn(self) -> str:
        """
        The Amazon Resource Name (ARN) of the IAM role that the Amazon SES API v2 uses to send email events to the Amazon Kinesis Data Firehose stream.
        """
        return pulumi.get(self, "iam_role_arn")


@pulumi.output_type
class ConfigurationSetEventDestinationEventDestinationPinpointDestination(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationArn":
            suggest = "application_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfigurationSetEventDestinationEventDestinationPinpointDestination. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfigurationSetEventDestinationEventDestinationPinpointDestination.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfigurationSetEventDestinationEventDestinationPinpointDestination.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_arn: str):
        ConfigurationSetEventDestinationEventDestinationPinpointDestination._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            application_arn=application_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             application_arn: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if application_arn is None and 'applicationArn' in kwargs:
            application_arn = kwargs['applicationArn']
        if application_arn is None:
            raise TypeError("Missing 'application_arn' argument")

        _setter("application_arn", application_arn)

    @property
    @pulumi.getter(name="applicationArn")
    def application_arn(self) -> str:
        return pulumi.get(self, "application_arn")


@pulumi.output_type
class ConfigurationSetEventDestinationEventDestinationSnsDestination(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "topicArn":
            suggest = "topic_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfigurationSetEventDestinationEventDestinationSnsDestination. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfigurationSetEventDestinationEventDestinationSnsDestination.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfigurationSetEventDestinationEventDestinationSnsDestination.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 topic_arn: str):
        """
        :param str topic_arn: The Amazon Resource Name (ARN) of the Amazon SNS topic to publish email events to.
        """
        ConfigurationSetEventDestinationEventDestinationSnsDestination._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            topic_arn=topic_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             topic_arn: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if topic_arn is None and 'topicArn' in kwargs:
            topic_arn = kwargs['topicArn']
        if topic_arn is None:
            raise TypeError("Missing 'topic_arn' argument")

        _setter("topic_arn", topic_arn)

    @property
    @pulumi.getter(name="topicArn")
    def topic_arn(self) -> str:
        """
        The Amazon Resource Name (ARN) of the Amazon SNS topic to publish email events to.
        """
        return pulumi.get(self, "topic_arn")


@pulumi.output_type
class ConfigurationSetReputationOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastFreshStart":
            suggest = "last_fresh_start"
        elif key == "reputationMetricsEnabled":
            suggest = "reputation_metrics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfigurationSetReputationOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfigurationSetReputationOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfigurationSetReputationOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 last_fresh_start: Optional[str] = None,
                 reputation_metrics_enabled: Optional[bool] = None):
        """
        :param str last_fresh_start: The date and time (in Unix time) when the reputation metrics were last given a fresh start. When your account is given a fresh start, your reputation metrics are calculated starting from the date of the fresh start.
        :param bool reputation_metrics_enabled: If `true`, tracking of reputation metrics is enabled for the configuration set. If `false`, tracking of reputation metrics is disabled for the configuration set.
        """
        ConfigurationSetReputationOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            last_fresh_start=last_fresh_start,
            reputation_metrics_enabled=reputation_metrics_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             last_fresh_start: Optional[str] = None,
             reputation_metrics_enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if last_fresh_start is None and 'lastFreshStart' in kwargs:
            last_fresh_start = kwargs['lastFreshStart']
        if reputation_metrics_enabled is None and 'reputationMetricsEnabled' in kwargs:
            reputation_metrics_enabled = kwargs['reputationMetricsEnabled']

        if last_fresh_start is not None:
            _setter("last_fresh_start", last_fresh_start)
        if reputation_metrics_enabled is not None:
            _setter("reputation_metrics_enabled", reputation_metrics_enabled)

    @property
    @pulumi.getter(name="lastFreshStart")
    def last_fresh_start(self) -> Optional[str]:
        """
        The date and time (in Unix time) when the reputation metrics were last given a fresh start. When your account is given a fresh start, your reputation metrics are calculated starting from the date of the fresh start.
        """
        return pulumi.get(self, "last_fresh_start")

    @property
    @pulumi.getter(name="reputationMetricsEnabled")
    def reputation_metrics_enabled(self) -> Optional[bool]:
        """
        If `true`, tracking of reputation metrics is enabled for the configuration set. If `false`, tracking of reputation metrics is disabled for the configuration set.
        """
        return pulumi.get(self, "reputation_metrics_enabled")


@pulumi.output_type
class ConfigurationSetSendingOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sendingEnabled":
            suggest = "sending_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfigurationSetSendingOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfigurationSetSendingOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfigurationSetSendingOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sending_enabled: Optional[bool] = None):
        """
        :param bool sending_enabled: If `true`, email sending is enabled for the configuration set. If `false`, email sending is disabled for the configuration set.
        """
        ConfigurationSetSendingOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            sending_enabled=sending_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             sending_enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if sending_enabled is None and 'sendingEnabled' in kwargs:
            sending_enabled = kwargs['sendingEnabled']

        if sending_enabled is not None:
            _setter("sending_enabled", sending_enabled)

    @property
    @pulumi.getter(name="sendingEnabled")
    def sending_enabled(self) -> Optional[bool]:
        """
        If `true`, email sending is enabled for the configuration set. If `false`, email sending is disabled for the configuration set.
        """
        return pulumi.get(self, "sending_enabled")


@pulumi.output_type
class ConfigurationSetSuppressionOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "suppressedReasons":
            suggest = "suppressed_reasons"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfigurationSetSuppressionOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfigurationSetSuppressionOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfigurationSetSuppressionOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 suppressed_reasons: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] suppressed_reasons: A list that contains the reasons that email addresses are automatically added to the suppression list for your account. Valid values: `BOUNCE`, `COMPLAINT`.
        """
        ConfigurationSetSuppressionOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            suppressed_reasons=suppressed_reasons,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             suppressed_reasons: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if suppressed_reasons is None and 'suppressedReasons' in kwargs:
            suppressed_reasons = kwargs['suppressedReasons']

        if suppressed_reasons is not None:
            _setter("suppressed_reasons", suppressed_reasons)

    @property
    @pulumi.getter(name="suppressedReasons")
    def suppressed_reasons(self) -> Optional[Sequence[str]]:
        """
        A list that contains the reasons that email addresses are automatically added to the suppression list for your account. Valid values: `BOUNCE`, `COMPLAINT`.
        """
        return pulumi.get(self, "suppressed_reasons")


@pulumi.output_type
class ConfigurationSetTrackingOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customRedirectDomain":
            suggest = "custom_redirect_domain"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfigurationSetTrackingOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfigurationSetTrackingOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfigurationSetTrackingOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_redirect_domain: str):
        """
        :param str custom_redirect_domain: The domain to use for tracking open and click events.
        """
        ConfigurationSetTrackingOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_redirect_domain=custom_redirect_domain,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_redirect_domain: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if custom_redirect_domain is None and 'customRedirectDomain' in kwargs:
            custom_redirect_domain = kwargs['customRedirectDomain']
        if custom_redirect_domain is None:
            raise TypeError("Missing 'custom_redirect_domain' argument")

        _setter("custom_redirect_domain", custom_redirect_domain)

    @property
    @pulumi.getter(name="customRedirectDomain")
    def custom_redirect_domain(self) -> str:
        """
        The domain to use for tracking open and click events.
        """
        return pulumi.get(self, "custom_redirect_domain")


@pulumi.output_type
class ConfigurationSetVdmOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dashboardOptions":
            suggest = "dashboard_options"
        elif key == "guardianOptions":
            suggest = "guardian_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfigurationSetVdmOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfigurationSetVdmOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfigurationSetVdmOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dashboard_options: Optional['outputs.ConfigurationSetVdmOptionsDashboardOptions'] = None,
                 guardian_options: Optional['outputs.ConfigurationSetVdmOptionsGuardianOptions'] = None):
        """
        :param 'ConfigurationSetVdmOptionsDashboardOptionsArgs' dashboard_options: Specifies additional settings for your VDM configuration as applicable to the Dashboard.
        :param 'ConfigurationSetVdmOptionsGuardianOptionsArgs' guardian_options: Specifies additional settings for your VDM configuration as applicable to the Guardian.
        """
        ConfigurationSetVdmOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dashboard_options=dashboard_options,
            guardian_options=guardian_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dashboard_options: Optional['outputs.ConfigurationSetVdmOptionsDashboardOptions'] = None,
             guardian_options: Optional['outputs.ConfigurationSetVdmOptionsGuardianOptions'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if dashboard_options is None and 'dashboardOptions' in kwargs:
            dashboard_options = kwargs['dashboardOptions']
        if guardian_options is None and 'guardianOptions' in kwargs:
            guardian_options = kwargs['guardianOptions']

        if dashboard_options is not None:
            _setter("dashboard_options", dashboard_options)
        if guardian_options is not None:
            _setter("guardian_options", guardian_options)

    @property
    @pulumi.getter(name="dashboardOptions")
    def dashboard_options(self) -> Optional['outputs.ConfigurationSetVdmOptionsDashboardOptions']:
        """
        Specifies additional settings for your VDM configuration as applicable to the Dashboard.
        """
        return pulumi.get(self, "dashboard_options")

    @property
    @pulumi.getter(name="guardianOptions")
    def guardian_options(self) -> Optional['outputs.ConfigurationSetVdmOptionsGuardianOptions']:
        """
        Specifies additional settings for your VDM configuration as applicable to the Guardian.
        """
        return pulumi.get(self, "guardian_options")


@pulumi.output_type
class ConfigurationSetVdmOptionsDashboardOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "engagementMetrics":
            suggest = "engagement_metrics"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfigurationSetVdmOptionsDashboardOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfigurationSetVdmOptionsDashboardOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfigurationSetVdmOptionsDashboardOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 engagement_metrics: Optional[str] = None):
        """
        :param str engagement_metrics: Specifies the status of your VDM engagement metrics collection. Valid values: `ENABLED`, `DISABLED`.
        """
        ConfigurationSetVdmOptionsDashboardOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            engagement_metrics=engagement_metrics,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             engagement_metrics: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if engagement_metrics is None and 'engagementMetrics' in kwargs:
            engagement_metrics = kwargs['engagementMetrics']

        if engagement_metrics is not None:
            _setter("engagement_metrics", engagement_metrics)

    @property
    @pulumi.getter(name="engagementMetrics")
    def engagement_metrics(self) -> Optional[str]:
        """
        Specifies the status of your VDM engagement metrics collection. Valid values: `ENABLED`, `DISABLED`.
        """
        return pulumi.get(self, "engagement_metrics")


@pulumi.output_type
class ConfigurationSetVdmOptionsGuardianOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "optimizedSharedDelivery":
            suggest = "optimized_shared_delivery"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfigurationSetVdmOptionsGuardianOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfigurationSetVdmOptionsGuardianOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfigurationSetVdmOptionsGuardianOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 optimized_shared_delivery: Optional[str] = None):
        """
        :param str optimized_shared_delivery: Specifies the status of your VDM optimized shared delivery. Valid values: `ENABLED`, `DISABLED`.
        """
        ConfigurationSetVdmOptionsGuardianOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            optimized_shared_delivery=optimized_shared_delivery,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             optimized_shared_delivery: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if optimized_shared_delivery is None and 'optimizedSharedDelivery' in kwargs:
            optimized_shared_delivery = kwargs['optimizedSharedDelivery']

        if optimized_shared_delivery is not None:
            _setter("optimized_shared_delivery", optimized_shared_delivery)

    @property
    @pulumi.getter(name="optimizedSharedDelivery")
    def optimized_shared_delivery(self) -> Optional[str]:
        """
        Specifies the status of your VDM optimized shared delivery. Valid values: `ENABLED`, `DISABLED`.
        """
        return pulumi.get(self, "optimized_shared_delivery")


@pulumi.output_type
class ContactListTopic(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultSubscriptionStatus":
            suggest = "default_subscription_status"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "topicName":
            suggest = "topic_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContactListTopic. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContactListTopic.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContactListTopic.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_subscription_status: str,
                 display_name: str,
                 topic_name: str,
                 description: Optional[str] = None):
        """
        :param str default_subscription_status: The default subscription status to be applied to a contact if the contact has not noted their preference for subscribing to a topic.
        :param str display_name: The name of the topic the contact will see.
        :param str topic_name: The name of the topic.
               
               The following arguments are optional:
        :param str description: A description of what the topic is about, which the contact will see.
        """
        ContactListTopic._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            default_subscription_status=default_subscription_status,
            display_name=display_name,
            topic_name=topic_name,
            description=description,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             default_subscription_status: Optional[str] = None,
             display_name: Optional[str] = None,
             topic_name: Optional[str] = None,
             description: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if default_subscription_status is None and 'defaultSubscriptionStatus' in kwargs:
            default_subscription_status = kwargs['defaultSubscriptionStatus']
        if default_subscription_status is None:
            raise TypeError("Missing 'default_subscription_status' argument")
        if display_name is None and 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if display_name is None:
            raise TypeError("Missing 'display_name' argument")
        if topic_name is None and 'topicName' in kwargs:
            topic_name = kwargs['topicName']
        if topic_name is None:
            raise TypeError("Missing 'topic_name' argument")

        _setter("default_subscription_status", default_subscription_status)
        _setter("display_name", display_name)
        _setter("topic_name", topic_name)
        if description is not None:
            _setter("description", description)

    @property
    @pulumi.getter(name="defaultSubscriptionStatus")
    def default_subscription_status(self) -> str:
        """
        The default subscription status to be applied to a contact if the contact has not noted their preference for subscribing to a topic.
        """
        return pulumi.get(self, "default_subscription_status")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        The name of the topic the contact will see.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="topicName")
    def topic_name(self) -> str:
        """
        The name of the topic.

        The following arguments are optional:
        """
        return pulumi.get(self, "topic_name")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        A description of what the topic is about, which the contact will see.
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class EmailIdentityDkimSigningAttributes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "currentSigningKeyLength":
            suggest = "current_signing_key_length"
        elif key == "domainSigningPrivateKey":
            suggest = "domain_signing_private_key"
        elif key == "domainSigningSelector":
            suggest = "domain_signing_selector"
        elif key == "lastKeyGenerationTimestamp":
            suggest = "last_key_generation_timestamp"
        elif key == "nextSigningKeyLength":
            suggest = "next_signing_key_length"
        elif key == "signingAttributesOrigin":
            suggest = "signing_attributes_origin"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EmailIdentityDkimSigningAttributes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EmailIdentityDkimSigningAttributes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EmailIdentityDkimSigningAttributes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 current_signing_key_length: Optional[str] = None,
                 domain_signing_private_key: Optional[str] = None,
                 domain_signing_selector: Optional[str] = None,
                 last_key_generation_timestamp: Optional[str] = None,
                 next_signing_key_length: Optional[str] = None,
                 signing_attributes_origin: Optional[str] = None,
                 status: Optional[str] = None,
                 tokens: Optional[Sequence[str]] = None):
        """
        :param str current_signing_key_length: [Easy DKIM] The key length of the DKIM key pair in use.
        :param str domain_signing_private_key: [Bring Your Own DKIM] A private key that's used to generate a DKIM signature. The private key must use 1024 or 2048-bit RSA encryption, and must be encoded using base64 encoding.
               
               > **NOTE:** You have to delete the first and last lines ('-----BEGIN PRIVATE KEY-----' and '-----END PRIVATE KEY-----', respectively) of the generated private key. Additionally, you have to remove the line breaks in the generated private key. The resulting value is a string of characters with no spaces or line breaks.
        :param str domain_signing_selector: [Bring Your Own DKIM] A string that's used to identify a public key in the DNS configuration for a domain.
        :param str last_key_generation_timestamp: [Easy DKIM] The last time a key pair was generated for this identity.
        :param str next_signing_key_length: [Easy DKIM] The key length of the future DKIM key pair to be generated. This can be changed at most once per day. Valid values: `RSA_1024_BIT`, `RSA_2048_BIT`.
        :param str signing_attributes_origin: A string that indicates how DKIM was configured for the identity. `AWS_SES` indicates that DKIM was configured for the identity by using Easy DKIM. `EXTERNAL` indicates that DKIM was configured for the identity by using Bring Your Own DKIM (BYODKIM).
        :param str status: Describes whether or not Amazon SES has successfully located the DKIM records in the DNS records for the domain. See the [AWS SES API v2 Reference](https://docs.aws.amazon.com/ses/latest/APIReference-V2/API_DkimAttributes.html#SES-Type-DkimAttributes-Status) for supported statuses.
        :param Sequence[str] tokens: If you used Easy DKIM to configure DKIM authentication for the domain, then this object contains a set of unique strings that you use to create a set of CNAME records that you add to the DNS configuration for your domain. When Amazon SES detects these records in the DNS configuration for your domain, the DKIM authentication process is complete. If you configured DKIM authentication for the domain by providing your own public-private key pair, then this object contains the selector for the public key.
        """
        EmailIdentityDkimSigningAttributes._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            current_signing_key_length=current_signing_key_length,
            domain_signing_private_key=domain_signing_private_key,
            domain_signing_selector=domain_signing_selector,
            last_key_generation_timestamp=last_key_generation_timestamp,
            next_signing_key_length=next_signing_key_length,
            signing_attributes_origin=signing_attributes_origin,
            status=status,
            tokens=tokens,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             current_signing_key_length: Optional[str] = None,
             domain_signing_private_key: Optional[str] = None,
             domain_signing_selector: Optional[str] = None,
             last_key_generation_timestamp: Optional[str] = None,
             next_signing_key_length: Optional[str] = None,
             signing_attributes_origin: Optional[str] = None,
             status: Optional[str] = None,
             tokens: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if current_signing_key_length is None and 'currentSigningKeyLength' in kwargs:
            current_signing_key_length = kwargs['currentSigningKeyLength']
        if domain_signing_private_key is None and 'domainSigningPrivateKey' in kwargs:
            domain_signing_private_key = kwargs['domainSigningPrivateKey']
        if domain_signing_selector is None and 'domainSigningSelector' in kwargs:
            domain_signing_selector = kwargs['domainSigningSelector']
        if last_key_generation_timestamp is None and 'lastKeyGenerationTimestamp' in kwargs:
            last_key_generation_timestamp = kwargs['lastKeyGenerationTimestamp']
        if next_signing_key_length is None and 'nextSigningKeyLength' in kwargs:
            next_signing_key_length = kwargs['nextSigningKeyLength']
        if signing_attributes_origin is None and 'signingAttributesOrigin' in kwargs:
            signing_attributes_origin = kwargs['signingAttributesOrigin']

        if current_signing_key_length is not None:
            _setter("current_signing_key_length", current_signing_key_length)
        if domain_signing_private_key is not None:
            _setter("domain_signing_private_key", domain_signing_private_key)
        if domain_signing_selector is not None:
            _setter("domain_signing_selector", domain_signing_selector)
        if last_key_generation_timestamp is not None:
            _setter("last_key_generation_timestamp", last_key_generation_timestamp)
        if next_signing_key_length is not None:
            _setter("next_signing_key_length", next_signing_key_length)
        if signing_attributes_origin is not None:
            _setter("signing_attributes_origin", signing_attributes_origin)
        if status is not None:
            _setter("status", status)
        if tokens is not None:
            _setter("tokens", tokens)

    @property
    @pulumi.getter(name="currentSigningKeyLength")
    def current_signing_key_length(self) -> Optional[str]:
        """
        [Easy DKIM] The key length of the DKIM key pair in use.
        """
        return pulumi.get(self, "current_signing_key_length")

    @property
    @pulumi.getter(name="domainSigningPrivateKey")
    def domain_signing_private_key(self) -> Optional[str]:
        """
        [Bring Your Own DKIM] A private key that's used to generate a DKIM signature. The private key must use 1024 or 2048-bit RSA encryption, and must be encoded using base64 encoding.

        > **NOTE:** You have to delete the first and last lines ('-----BEGIN PRIVATE KEY-----' and '-----END PRIVATE KEY-----', respectively) of the generated private key. Additionally, you have to remove the line breaks in the generated private key. The resulting value is a string of characters with no spaces or line breaks.
        """
        return pulumi.get(self, "domain_signing_private_key")

    @property
    @pulumi.getter(name="domainSigningSelector")
    def domain_signing_selector(self) -> Optional[str]:
        """
        [Bring Your Own DKIM] A string that's used to identify a public key in the DNS configuration for a domain.
        """
        return pulumi.get(self, "domain_signing_selector")

    @property
    @pulumi.getter(name="lastKeyGenerationTimestamp")
    def last_key_generation_timestamp(self) -> Optional[str]:
        """
        [Easy DKIM] The last time a key pair was generated for this identity.
        """
        return pulumi.get(self, "last_key_generation_timestamp")

    @property
    @pulumi.getter(name="nextSigningKeyLength")
    def next_signing_key_length(self) -> Optional[str]:
        """
        [Easy DKIM] The key length of the future DKIM key pair to be generated. This can be changed at most once per day. Valid values: `RSA_1024_BIT`, `RSA_2048_BIT`.
        """
        return pulumi.get(self, "next_signing_key_length")

    @property
    @pulumi.getter(name="signingAttributesOrigin")
    def signing_attributes_origin(self) -> Optional[str]:
        """
        A string that indicates how DKIM was configured for the identity. `AWS_SES` indicates that DKIM was configured for the identity by using Easy DKIM. `EXTERNAL` indicates that DKIM was configured for the identity by using Bring Your Own DKIM (BYODKIM).
        """
        return pulumi.get(self, "signing_attributes_origin")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Describes whether or not Amazon SES has successfully located the DKIM records in the DNS records for the domain. See the [AWS SES API v2 Reference](https://docs.aws.amazon.com/ses/latest/APIReference-V2/API_DkimAttributes.html#SES-Type-DkimAttributes-Status) for supported statuses.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def tokens(self) -> Optional[Sequence[str]]:
        """
        If you used Easy DKIM to configure DKIM authentication for the domain, then this object contains a set of unique strings that you use to create a set of CNAME records that you add to the DNS configuration for your domain. When Amazon SES detects these records in the DNS configuration for your domain, the DKIM authentication process is complete. If you configured DKIM authentication for the domain by providing your own public-private key pair, then this object contains the selector for the public key.
        """
        return pulumi.get(self, "tokens")


@pulumi.output_type
class GetConfigurationSetDeliveryOptionResult(dict):
    def __init__(__self__, *,
                 sending_pool_name: str,
                 tls_policy: str):
        """
        :param str sending_pool_name: The name of the dedicated IP pool to associate with the configuration set.
        :param str tls_policy: Specifies whether messages that use the configuration set are required to use Transport Layer Security (TLS).
        """
        GetConfigurationSetDeliveryOptionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            sending_pool_name=sending_pool_name,
            tls_policy=tls_policy,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             sending_pool_name: Optional[str] = None,
             tls_policy: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if sending_pool_name is None and 'sendingPoolName' in kwargs:
            sending_pool_name = kwargs['sendingPoolName']
        if sending_pool_name is None:
            raise TypeError("Missing 'sending_pool_name' argument")
        if tls_policy is None and 'tlsPolicy' in kwargs:
            tls_policy = kwargs['tlsPolicy']
        if tls_policy is None:
            raise TypeError("Missing 'tls_policy' argument")

        _setter("sending_pool_name", sending_pool_name)
        _setter("tls_policy", tls_policy)

    @property
    @pulumi.getter(name="sendingPoolName")
    def sending_pool_name(self) -> str:
        """
        The name of the dedicated IP pool to associate with the configuration set.
        """
        return pulumi.get(self, "sending_pool_name")

    @property
    @pulumi.getter(name="tlsPolicy")
    def tls_policy(self) -> str:
        """
        Specifies whether messages that use the configuration set are required to use Transport Layer Security (TLS).
        """
        return pulumi.get(self, "tls_policy")


@pulumi.output_type
class GetConfigurationSetReputationOptionResult(dict):
    def __init__(__self__, *,
                 last_fresh_start: str,
                 reputation_metrics_enabled: bool):
        """
        :param str last_fresh_start: The date and time (in Unix time) when the reputation metrics were last given a fresh start.
        :param bool reputation_metrics_enabled: Specifies whether tracking of reputation metrics is enabled.
        """
        GetConfigurationSetReputationOptionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            last_fresh_start=last_fresh_start,
            reputation_metrics_enabled=reputation_metrics_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             last_fresh_start: Optional[str] = None,
             reputation_metrics_enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if last_fresh_start is None and 'lastFreshStart' in kwargs:
            last_fresh_start = kwargs['lastFreshStart']
        if last_fresh_start is None:
            raise TypeError("Missing 'last_fresh_start' argument")
        if reputation_metrics_enabled is None and 'reputationMetricsEnabled' in kwargs:
            reputation_metrics_enabled = kwargs['reputationMetricsEnabled']
        if reputation_metrics_enabled is None:
            raise TypeError("Missing 'reputation_metrics_enabled' argument")

        _setter("last_fresh_start", last_fresh_start)
        _setter("reputation_metrics_enabled", reputation_metrics_enabled)

    @property
    @pulumi.getter(name="lastFreshStart")
    def last_fresh_start(self) -> str:
        """
        The date and time (in Unix time) when the reputation metrics were last given a fresh start.
        """
        return pulumi.get(self, "last_fresh_start")

    @property
    @pulumi.getter(name="reputationMetricsEnabled")
    def reputation_metrics_enabled(self) -> bool:
        """
        Specifies whether tracking of reputation metrics is enabled.
        """
        return pulumi.get(self, "reputation_metrics_enabled")


@pulumi.output_type
class GetConfigurationSetSendingOptionResult(dict):
    def __init__(__self__, *,
                 sending_enabled: bool):
        """
        :param bool sending_enabled: Specifies whether email sending is enabled.
        """
        GetConfigurationSetSendingOptionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            sending_enabled=sending_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             sending_enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if sending_enabled is None and 'sendingEnabled' in kwargs:
            sending_enabled = kwargs['sendingEnabled']
        if sending_enabled is None:
            raise TypeError("Missing 'sending_enabled' argument")

        _setter("sending_enabled", sending_enabled)

    @property
    @pulumi.getter(name="sendingEnabled")
    def sending_enabled(self) -> bool:
        """
        Specifies whether email sending is enabled.
        """
        return pulumi.get(self, "sending_enabled")


@pulumi.output_type
class GetConfigurationSetSuppressionOptionResult(dict):
    def __init__(__self__, *,
                 suppressed_reasons: Sequence[str]):
        """
        :param Sequence[str] suppressed_reasons: A list that contains the reasons that email addresses are automatically added to the suppression list for your account.
        """
        GetConfigurationSetSuppressionOptionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            suppressed_reasons=suppressed_reasons,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             suppressed_reasons: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if suppressed_reasons is None and 'suppressedReasons' in kwargs:
            suppressed_reasons = kwargs['suppressedReasons']
        if suppressed_reasons is None:
            raise TypeError("Missing 'suppressed_reasons' argument")

        _setter("suppressed_reasons", suppressed_reasons)

    @property
    @pulumi.getter(name="suppressedReasons")
    def suppressed_reasons(self) -> Sequence[str]:
        """
        A list that contains the reasons that email addresses are automatically added to the suppression list for your account.
        """
        return pulumi.get(self, "suppressed_reasons")


@pulumi.output_type
class GetConfigurationSetTrackingOptionResult(dict):
    def __init__(__self__, *,
                 custom_redirect_domain: str):
        """
        :param str custom_redirect_domain: The domain to use for tracking open and click events.
        """
        GetConfigurationSetTrackingOptionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_redirect_domain=custom_redirect_domain,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_redirect_domain: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if custom_redirect_domain is None and 'customRedirectDomain' in kwargs:
            custom_redirect_domain = kwargs['customRedirectDomain']
        if custom_redirect_domain is None:
            raise TypeError("Missing 'custom_redirect_domain' argument")

        _setter("custom_redirect_domain", custom_redirect_domain)

    @property
    @pulumi.getter(name="customRedirectDomain")
    def custom_redirect_domain(self) -> str:
        """
        The domain to use for tracking open and click events.
        """
        return pulumi.get(self, "custom_redirect_domain")


@pulumi.output_type
class GetConfigurationSetVdmOptionResult(dict):
    def __init__(__self__, *,
                 dashboard_options: Sequence['outputs.GetConfigurationSetVdmOptionDashboardOptionResult'],
                 guardian_options: Sequence['outputs.GetConfigurationSetVdmOptionGuardianOptionResult']):
        """
        :param Sequence['GetConfigurationSetVdmOptionDashboardOptionArgs'] dashboard_options: Specifies additional settings for your VDM configuration as applicable to the Dashboard.
        :param Sequence['GetConfigurationSetVdmOptionGuardianOptionArgs'] guardian_options: Specifies additional settings for your VDM configuration as applicable to the Guardian.
        """
        GetConfigurationSetVdmOptionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dashboard_options=dashboard_options,
            guardian_options=guardian_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dashboard_options: Optional[Sequence['outputs.GetConfigurationSetVdmOptionDashboardOptionResult']] = None,
             guardian_options: Optional[Sequence['outputs.GetConfigurationSetVdmOptionGuardianOptionResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if dashboard_options is None and 'dashboardOptions' in kwargs:
            dashboard_options = kwargs['dashboardOptions']
        if dashboard_options is None:
            raise TypeError("Missing 'dashboard_options' argument")
        if guardian_options is None and 'guardianOptions' in kwargs:
            guardian_options = kwargs['guardianOptions']
        if guardian_options is None:
            raise TypeError("Missing 'guardian_options' argument")

        _setter("dashboard_options", dashboard_options)
        _setter("guardian_options", guardian_options)

    @property
    @pulumi.getter(name="dashboardOptions")
    def dashboard_options(self) -> Sequence['outputs.GetConfigurationSetVdmOptionDashboardOptionResult']:
        """
        Specifies additional settings for your VDM configuration as applicable to the Dashboard.
        """
        return pulumi.get(self, "dashboard_options")

    @property
    @pulumi.getter(name="guardianOptions")
    def guardian_options(self) -> Sequence['outputs.GetConfigurationSetVdmOptionGuardianOptionResult']:
        """
        Specifies additional settings for your VDM configuration as applicable to the Guardian.
        """
        return pulumi.get(self, "guardian_options")


@pulumi.output_type
class GetConfigurationSetVdmOptionDashboardOptionResult(dict):
    def __init__(__self__, *,
                 engagement_metrics: str):
        """
        :param str engagement_metrics: Specifies the status of your VDM engagement metrics collection.
        """
        GetConfigurationSetVdmOptionDashboardOptionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            engagement_metrics=engagement_metrics,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             engagement_metrics: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if engagement_metrics is None and 'engagementMetrics' in kwargs:
            engagement_metrics = kwargs['engagementMetrics']
        if engagement_metrics is None:
            raise TypeError("Missing 'engagement_metrics' argument")

        _setter("engagement_metrics", engagement_metrics)

    @property
    @pulumi.getter(name="engagementMetrics")
    def engagement_metrics(self) -> str:
        """
        Specifies the status of your VDM engagement metrics collection.
        """
        return pulumi.get(self, "engagement_metrics")


@pulumi.output_type
class GetConfigurationSetVdmOptionGuardianOptionResult(dict):
    def __init__(__self__, *,
                 optimized_shared_delivery: str):
        """
        :param str optimized_shared_delivery: Specifies the status of your VDM optimized shared delivery.
        """
        GetConfigurationSetVdmOptionGuardianOptionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            optimized_shared_delivery=optimized_shared_delivery,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             optimized_shared_delivery: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if optimized_shared_delivery is None and 'optimizedSharedDelivery' in kwargs:
            optimized_shared_delivery = kwargs['optimizedSharedDelivery']
        if optimized_shared_delivery is None:
            raise TypeError("Missing 'optimized_shared_delivery' argument")

        _setter("optimized_shared_delivery", optimized_shared_delivery)

    @property
    @pulumi.getter(name="optimizedSharedDelivery")
    def optimized_shared_delivery(self) -> str:
        """
        Specifies the status of your VDM optimized shared delivery.
        """
        return pulumi.get(self, "optimized_shared_delivery")


@pulumi.output_type
class GetDedicatedIpPoolDedicatedIpResult(dict):
    def __init__(__self__, *,
                 ip: str,
                 warmup_percentage: int,
                 warmup_status: str):
        """
        :param str ip: IPv4 address.
        :param int warmup_percentage: Indicates how complete the dedicated IP warm-up process is. When this value equals `1`, the address has completed the warm-up process and is ready for use.
        :param str warmup_status: The warm-up status of a dedicated IP address. Valid values: `IN_PROGRESS`, `DONE`.
        """
        GetDedicatedIpPoolDedicatedIpResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ip=ip,
            warmup_percentage=warmup_percentage,
            warmup_status=warmup_status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ip: Optional[str] = None,
             warmup_percentage: Optional[int] = None,
             warmup_status: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ip is None:
            raise TypeError("Missing 'ip' argument")
        if warmup_percentage is None and 'warmupPercentage' in kwargs:
            warmup_percentage = kwargs['warmupPercentage']
        if warmup_percentage is None:
            raise TypeError("Missing 'warmup_percentage' argument")
        if warmup_status is None and 'warmupStatus' in kwargs:
            warmup_status = kwargs['warmupStatus']
        if warmup_status is None:
            raise TypeError("Missing 'warmup_status' argument")

        _setter("ip", ip)
        _setter("warmup_percentage", warmup_percentage)
        _setter("warmup_status", warmup_status)

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        IPv4 address.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="warmupPercentage")
    def warmup_percentage(self) -> int:
        """
        Indicates how complete the dedicated IP warm-up process is. When this value equals `1`, the address has completed the warm-up process and is ready for use.
        """
        return pulumi.get(self, "warmup_percentage")

    @property
    @pulumi.getter(name="warmupStatus")
    def warmup_status(self) -> str:
        """
        The warm-up status of a dedicated IP address. Valid values: `IN_PROGRESS`, `DONE`.
        """
        return pulumi.get(self, "warmup_status")


@pulumi.output_type
class GetEmailIdentityDkimSigningAttributeResult(dict):
    def __init__(__self__, *,
                 current_signing_key_length: str,
                 domain_signing_private_key: str,
                 domain_signing_selector: str,
                 last_key_generation_timestamp: str,
                 next_signing_key_length: str,
                 signing_attributes_origin: str,
                 status: str,
                 tokens: Sequence[str]):
        """
        :param str current_signing_key_length: [Easy DKIM] The key length of the DKIM key pair in use.
        :param str last_key_generation_timestamp: [Easy DKIM] The last time a key pair was generated for this identity.
        :param str next_signing_key_length: [Easy DKIM] The key length of the future DKIM key pair to be generated. This can be changed at most once per day.
        :param str signing_attributes_origin: A string that indicates how DKIM was configured for the identity. `AWS_SES` indicates that DKIM was configured for the identity by using Easy DKIM. `EXTERNAL` indicates that DKIM was configured for the identity by using Bring Your Own DKIM (BYODKIM).
        :param str status: Describes whether or not Amazon SES has successfully located the DKIM records in the DNS records for the domain. See the [AWS SES API v2 Reference](https://docs.aws.amazon.com/ses/latest/APIReference-V2/API_DkimAttributes.html#SES-Type-DkimAttributes-Status) for supported statuses.
        :param Sequence[str] tokens: If you used Easy DKIM to configure DKIM authentication for the domain, then this object contains a set of unique strings that you use to create a set of CNAME records that you add to the DNS configuration for your domain. When Amazon SES detects these records in the DNS configuration for your domain, the DKIM authentication process is complete. If you configured DKIM authentication for the domain by providing your own public-private key pair, then this object contains the selector for the public key.
        """
        GetEmailIdentityDkimSigningAttributeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            current_signing_key_length=current_signing_key_length,
            domain_signing_private_key=domain_signing_private_key,
            domain_signing_selector=domain_signing_selector,
            last_key_generation_timestamp=last_key_generation_timestamp,
            next_signing_key_length=next_signing_key_length,
            signing_attributes_origin=signing_attributes_origin,
            status=status,
            tokens=tokens,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             current_signing_key_length: Optional[str] = None,
             domain_signing_private_key: Optional[str] = None,
             domain_signing_selector: Optional[str] = None,
             last_key_generation_timestamp: Optional[str] = None,
             next_signing_key_length: Optional[str] = None,
             signing_attributes_origin: Optional[str] = None,
             status: Optional[str] = None,
             tokens: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if current_signing_key_length is None and 'currentSigningKeyLength' in kwargs:
            current_signing_key_length = kwargs['currentSigningKeyLength']
        if current_signing_key_length is None:
            raise TypeError("Missing 'current_signing_key_length' argument")
        if domain_signing_private_key is None and 'domainSigningPrivateKey' in kwargs:
            domain_signing_private_key = kwargs['domainSigningPrivateKey']
        if domain_signing_private_key is None:
            raise TypeError("Missing 'domain_signing_private_key' argument")
        if domain_signing_selector is None and 'domainSigningSelector' in kwargs:
            domain_signing_selector = kwargs['domainSigningSelector']
        if domain_signing_selector is None:
            raise TypeError("Missing 'domain_signing_selector' argument")
        if last_key_generation_timestamp is None and 'lastKeyGenerationTimestamp' in kwargs:
            last_key_generation_timestamp = kwargs['lastKeyGenerationTimestamp']
        if last_key_generation_timestamp is None:
            raise TypeError("Missing 'last_key_generation_timestamp' argument")
        if next_signing_key_length is None and 'nextSigningKeyLength' in kwargs:
            next_signing_key_length = kwargs['nextSigningKeyLength']
        if next_signing_key_length is None:
            raise TypeError("Missing 'next_signing_key_length' argument")
        if signing_attributes_origin is None and 'signingAttributesOrigin' in kwargs:
            signing_attributes_origin = kwargs['signingAttributesOrigin']
        if signing_attributes_origin is None:
            raise TypeError("Missing 'signing_attributes_origin' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if tokens is None:
            raise TypeError("Missing 'tokens' argument")

        _setter("current_signing_key_length", current_signing_key_length)
        _setter("domain_signing_private_key", domain_signing_private_key)
        _setter("domain_signing_selector", domain_signing_selector)
        _setter("last_key_generation_timestamp", last_key_generation_timestamp)
        _setter("next_signing_key_length", next_signing_key_length)
        _setter("signing_attributes_origin", signing_attributes_origin)
        _setter("status", status)
        _setter("tokens", tokens)

    @property
    @pulumi.getter(name="currentSigningKeyLength")
    def current_signing_key_length(self) -> str:
        """
        [Easy DKIM] The key length of the DKIM key pair in use.
        """
        return pulumi.get(self, "current_signing_key_length")

    @property
    @pulumi.getter(name="domainSigningPrivateKey")
    def domain_signing_private_key(self) -> str:
        return pulumi.get(self, "domain_signing_private_key")

    @property
    @pulumi.getter(name="domainSigningSelector")
    def domain_signing_selector(self) -> str:
        return pulumi.get(self, "domain_signing_selector")

    @property
    @pulumi.getter(name="lastKeyGenerationTimestamp")
    def last_key_generation_timestamp(self) -> str:
        """
        [Easy DKIM] The last time a key pair was generated for this identity.
        """
        return pulumi.get(self, "last_key_generation_timestamp")

    @property
    @pulumi.getter(name="nextSigningKeyLength")
    def next_signing_key_length(self) -> str:
        """
        [Easy DKIM] The key length of the future DKIM key pair to be generated. This can be changed at most once per day.
        """
        return pulumi.get(self, "next_signing_key_length")

    @property
    @pulumi.getter(name="signingAttributesOrigin")
    def signing_attributes_origin(self) -> str:
        """
        A string that indicates how DKIM was configured for the identity. `AWS_SES` indicates that DKIM was configured for the identity by using Easy DKIM. `EXTERNAL` indicates that DKIM was configured for the identity by using Bring Your Own DKIM (BYODKIM).
        """
        return pulumi.get(self, "signing_attributes_origin")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Describes whether or not Amazon SES has successfully located the DKIM records in the DNS records for the domain. See the [AWS SES API v2 Reference](https://docs.aws.amazon.com/ses/latest/APIReference-V2/API_DkimAttributes.html#SES-Type-DkimAttributes-Status) for supported statuses.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def tokens(self) -> Sequence[str]:
        """
        If you used Easy DKIM to configure DKIM authentication for the domain, then this object contains a set of unique strings that you use to create a set of CNAME records that you add to the DNS configuration for your domain. When Amazon SES detects these records in the DNS configuration for your domain, the DKIM authentication process is complete. If you configured DKIM authentication for the domain by providing your own public-private key pair, then this object contains the selector for the public key.
        """
        return pulumi.get(self, "tokens")


