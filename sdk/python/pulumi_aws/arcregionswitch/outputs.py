# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'PlanAssociatedAlarm',
    'PlanTimeouts',
    'PlanTrigger',
    'PlanTriggerCondition',
    'PlanWorkflow',
    'PlanWorkflowStep',
    'PlanWorkflowStepArcRoutingControlConfig',
    'PlanWorkflowStepArcRoutingControlConfigRegionAndRoutingControl',
    'PlanWorkflowStepArcRoutingControlConfigRegionAndRoutingControlRoutingControl',
    'PlanWorkflowStepCustomActionLambdaConfig',
    'PlanWorkflowStepCustomActionLambdaConfigLambda',
    'PlanWorkflowStepCustomActionLambdaConfigUngraceful',
    'PlanWorkflowStepDocumentDbConfig',
    'PlanWorkflowStepDocumentDbConfigUngraceful',
    'PlanWorkflowStepEc2AsgCapacityIncreaseConfig',
    'PlanWorkflowStepEc2AsgCapacityIncreaseConfigAsg',
    'PlanWorkflowStepEc2AsgCapacityIncreaseConfigUngraceful',
    'PlanWorkflowStepEcsCapacityIncreaseConfig',
    'PlanWorkflowStepEcsCapacityIncreaseConfigService',
    'PlanWorkflowStepEcsCapacityIncreaseConfigUngraceful',
    'PlanWorkflowStepEksResourceScalingConfig',
    'PlanWorkflowStepEksResourceScalingConfigEksCluster',
    'PlanWorkflowStepEksResourceScalingConfigKubernetesResourceType',
    'PlanWorkflowStepEksResourceScalingConfigScalingResource',
    'PlanWorkflowStepEksResourceScalingConfigScalingResourceResource',
    'PlanWorkflowStepEksResourceScalingConfigUngraceful',
    'PlanWorkflowStepExecutionApprovalConfig',
    'PlanWorkflowStepGlobalAuroraConfig',
    'PlanWorkflowStepGlobalAuroraConfigUngraceful',
    'PlanWorkflowStepParallelConfig',
    'PlanWorkflowStepParallelConfigStep',
    'PlanWorkflowStepParallelConfigStepArcRoutingControlConfig',
    'PlanWorkflowStepParallelConfigStepArcRoutingControlConfigRegionAndRoutingControl',
    'PlanWorkflowStepParallelConfigStepArcRoutingControlConfigRegionAndRoutingControlRoutingControl',
    'PlanWorkflowStepParallelConfigStepCustomActionLambdaConfig',
    'PlanWorkflowStepParallelConfigStepCustomActionLambdaConfigLambda',
    'PlanWorkflowStepParallelConfigStepCustomActionLambdaConfigUngraceful',
    'PlanWorkflowStepParallelConfigStepDocumentDbConfig',
    'PlanWorkflowStepParallelConfigStepDocumentDbConfigUngraceful',
    'PlanWorkflowStepParallelConfigStepEc2AsgCapacityIncreaseConfig',
    'PlanWorkflowStepParallelConfigStepEc2AsgCapacityIncreaseConfigAsg',
    'PlanWorkflowStepParallelConfigStepEc2AsgCapacityIncreaseConfigUngraceful',
    'PlanWorkflowStepParallelConfigStepEcsCapacityIncreaseConfig',
    'PlanWorkflowStepParallelConfigStepEcsCapacityIncreaseConfigService',
    'PlanWorkflowStepParallelConfigStepEcsCapacityIncreaseConfigUngraceful',
    'PlanWorkflowStepParallelConfigStepEksResourceScalingConfig',
    'PlanWorkflowStepParallelConfigStepEksResourceScalingConfigEksCluster',
    'PlanWorkflowStepParallelConfigStepEksResourceScalingConfigKubernetesResourceType',
    'PlanWorkflowStepParallelConfigStepEksResourceScalingConfigScalingResource',
    'PlanWorkflowStepParallelConfigStepEksResourceScalingConfigScalingResourceResource',
    'PlanWorkflowStepParallelConfigStepEksResourceScalingConfigUngraceful',
    'PlanWorkflowStepParallelConfigStepExecutionApprovalConfig',
    'PlanWorkflowStepParallelConfigStepGlobalAuroraConfig',
    'PlanWorkflowStepParallelConfigStepGlobalAuroraConfigUngraceful',
    'PlanWorkflowStepParallelConfigStepRegionSwitchPlanConfig',
    'PlanWorkflowStepParallelConfigStepRoute53HealthCheckConfig',
    'PlanWorkflowStepParallelConfigStepRoute53HealthCheckConfigRecordSet',
    'PlanWorkflowStepRegionSwitchPlanConfig',
    'PlanWorkflowStepRoute53HealthCheckConfig',
    'PlanWorkflowStepRoute53HealthCheckConfigRecordSet',
    'GetRoute53HealthChecksHealthCheckResult',
]

@pulumi.output_type
class PlanAssociatedAlarm(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alarmType":
            suggest = "alarm_type"
        elif key == "mapBlockKey":
            suggest = "map_block_key"
        elif key == "resourceIdentifier":
            suggest = "resource_identifier"
        elif key == "crossAccountRole":
            suggest = "cross_account_role"
        elif key == "externalId":
            suggest = "external_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanAssociatedAlarm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanAssociatedAlarm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanAssociatedAlarm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alarm_type: _builtins.str,
                 map_block_key: _builtins.str,
                 resource_identifier: _builtins.str,
                 cross_account_role: Optional[_builtins.str] = None,
                 external_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str alarm_type: Type of alarm. Valid values: `applicationHealth`, `trigger`.
        :param _builtins.str map_block_key: Name of the alarm.
        :param _builtins.str resource_identifier: Resource identifier (ARN) of the CloudWatch alarm.
        :param _builtins.str cross_account_role: ARN of the cross-account role to assume.
        :param _builtins.str external_id: External ID for cross-account role assumption.
        """
        pulumi.set(__self__, "alarm_type", alarm_type)
        pulumi.set(__self__, "map_block_key", map_block_key)
        pulumi.set(__self__, "resource_identifier", resource_identifier)
        if cross_account_role is not None:
            pulumi.set(__self__, "cross_account_role", cross_account_role)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)

    @_builtins.property
    @pulumi.getter(name="alarmType")
    def alarm_type(self) -> _builtins.str:
        """
        Type of alarm. Valid values: `applicationHealth`, `trigger`.
        """
        return pulumi.get(self, "alarm_type")

    @_builtins.property
    @pulumi.getter(name="mapBlockKey")
    def map_block_key(self) -> _builtins.str:
        """
        Name of the alarm.
        """
        return pulumi.get(self, "map_block_key")

    @_builtins.property
    @pulumi.getter(name="resourceIdentifier")
    def resource_identifier(self) -> _builtins.str:
        """
        Resource identifier (ARN) of the CloudWatch alarm.
        """
        return pulumi.get(self, "resource_identifier")

    @_builtins.property
    @pulumi.getter(name="crossAccountRole")
    def cross_account_role(self) -> Optional[_builtins.str]:
        """
        ARN of the cross-account role to assume.
        """
        return pulumi.get(self, "cross_account_role")

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[_builtins.str]:
        """
        External ID for cross-account role assumption.
        """
        return pulumi.get(self, "external_id")


@pulumi.output_type
class PlanTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[_builtins.str] = None,
                 delete: Optional[_builtins.str] = None,
                 update: Optional[_builtins.str] = None):
        """
        :param _builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param _builtins.str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param _builtins.str update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")


@pulumi.output_type
class PlanTrigger(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minDelayMinutesBetweenExecutions":
            suggest = "min_delay_minutes_between_executions"
        elif key == "targetRegion":
            suggest = "target_region"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanTrigger. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanTrigger.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanTrigger.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: _builtins.str,
                 min_delay_minutes_between_executions: _builtins.int,
                 target_region: _builtins.str,
                 conditions: Optional[Sequence['outputs.PlanTriggerCondition']] = None,
                 description: Optional[_builtins.str] = None):
        """
        :param _builtins.str action: Action to trigger. Valid values: `activate`, `deactivate`.
        :param _builtins.int min_delay_minutes_between_executions: Minimum delay in minutes between executions.
        :param _builtins.str target_region: Target region for the trigger.
        :param Sequence['PlanTriggerConditionArgs'] conditions: List of conditions that must be met. See Conditions below.
        :param _builtins.str description: Description of the trigger.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "min_delay_minutes_between_executions", min_delay_minutes_between_executions)
        pulumi.set(__self__, "target_region", target_region)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        """
        Action to trigger. Valid values: `activate`, `deactivate`.
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter(name="minDelayMinutesBetweenExecutions")
    def min_delay_minutes_between_executions(self) -> _builtins.int:
        """
        Minimum delay in minutes between executions.
        """
        return pulumi.get(self, "min_delay_minutes_between_executions")

    @_builtins.property
    @pulumi.getter(name="targetRegion")
    def target_region(self) -> _builtins.str:
        """
        Target region for the trigger.
        """
        return pulumi.get(self, "target_region")

    @_builtins.property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.PlanTriggerCondition']]:
        """
        List of conditions that must be met. See Conditions below.
        """
        return pulumi.get(self, "conditions")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of the trigger.
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class PlanTriggerCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "associatedAlarmName":
            suggest = "associated_alarm_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanTriggerCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanTriggerCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanTriggerCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 associated_alarm_name: _builtins.str,
                 condition: _builtins.str):
        """
        :param _builtins.str associated_alarm_name: Name of the associated alarm.
        :param _builtins.str condition: Condition to check. Valid values: `red`, `green`.
        """
        pulumi.set(__self__, "associated_alarm_name", associated_alarm_name)
        pulumi.set(__self__, "condition", condition)

    @_builtins.property
    @pulumi.getter(name="associatedAlarmName")
    def associated_alarm_name(self) -> _builtins.str:
        """
        Name of the associated alarm.
        """
        return pulumi.get(self, "associated_alarm_name")

    @_builtins.property
    @pulumi.getter
    def condition(self) -> _builtins.str:
        """
        Condition to check. Valid values: `red`, `green`.
        """
        return pulumi.get(self, "condition")


@pulumi.output_type
class PlanWorkflow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "workflowTargetAction":
            suggest = "workflow_target_action"
        elif key == "workflowDescription":
            suggest = "workflow_description"
        elif key == "workflowTargetRegion":
            suggest = "workflow_target_region"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanWorkflow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanWorkflow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanWorkflow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 workflow_target_action: _builtins.str,
                 steps: Optional[Sequence['outputs.PlanWorkflowStep']] = None,
                 workflow_description: Optional[_builtins.str] = None,
                 workflow_target_region: Optional[_builtins.str] = None):
        """
        :param _builtins.str workflow_target_action: Action to perform. Valid values: `activate`, `deactivate`.
        :param Sequence['PlanWorkflowStepArgs'] steps: List of steps in the workflow. See Step below.
        :param _builtins.str workflow_description: Description of the workflow.
        :param _builtins.str workflow_target_region: Target region for the workflow.
        """
        pulumi.set(__self__, "workflow_target_action", workflow_target_action)
        if steps is not None:
            pulumi.set(__self__, "steps", steps)
        if workflow_description is not None:
            pulumi.set(__self__, "workflow_description", workflow_description)
        if workflow_target_region is not None:
            pulumi.set(__self__, "workflow_target_region", workflow_target_region)

    @_builtins.property
    @pulumi.getter(name="workflowTargetAction")
    def workflow_target_action(self) -> _builtins.str:
        """
        Action to perform. Valid values: `activate`, `deactivate`.
        """
        return pulumi.get(self, "workflow_target_action")

    @_builtins.property
    @pulumi.getter
    def steps(self) -> Optional[Sequence['outputs.PlanWorkflowStep']]:
        """
        List of steps in the workflow. See Step below.
        """
        return pulumi.get(self, "steps")

    @_builtins.property
    @pulumi.getter(name="workflowDescription")
    def workflow_description(self) -> Optional[_builtins.str]:
        """
        Description of the workflow.
        """
        return pulumi.get(self, "workflow_description")

    @_builtins.property
    @pulumi.getter(name="workflowTargetRegion")
    def workflow_target_region(self) -> Optional[_builtins.str]:
        """
        Target region for the workflow.
        """
        return pulumi.get(self, "workflow_target_region")


@pulumi.output_type
class PlanWorkflowStep(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "executionBlockType":
            suggest = "execution_block_type"
        elif key == "arcRoutingControlConfigs":
            suggest = "arc_routing_control_configs"
        elif key == "customActionLambdaConfigs":
            suggest = "custom_action_lambda_configs"
        elif key == "documentDbConfigs":
            suggest = "document_db_configs"
        elif key == "ec2AsgCapacityIncreaseConfigs":
            suggest = "ec2_asg_capacity_increase_configs"
        elif key == "ecsCapacityIncreaseConfigs":
            suggest = "ecs_capacity_increase_configs"
        elif key == "eksResourceScalingConfigs":
            suggest = "eks_resource_scaling_configs"
        elif key == "executionApprovalConfigs":
            suggest = "execution_approval_configs"
        elif key == "globalAuroraConfigs":
            suggest = "global_aurora_configs"
        elif key == "parallelConfigs":
            suggest = "parallel_configs"
        elif key == "regionSwitchPlanConfigs":
            suggest = "region_switch_plan_configs"
        elif key == "route53HealthCheckConfigs":
            suggest = "route53_health_check_configs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanWorkflowStep. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanWorkflowStep.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanWorkflowStep.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 execution_block_type: _builtins.str,
                 name: _builtins.str,
                 arc_routing_control_configs: Optional[Sequence['outputs.PlanWorkflowStepArcRoutingControlConfig']] = None,
                 custom_action_lambda_configs: Optional[Sequence['outputs.PlanWorkflowStepCustomActionLambdaConfig']] = None,
                 description: Optional[_builtins.str] = None,
                 document_db_configs: Optional[Sequence['outputs.PlanWorkflowStepDocumentDbConfig']] = None,
                 ec2_asg_capacity_increase_configs: Optional[Sequence['outputs.PlanWorkflowStepEc2AsgCapacityIncreaseConfig']] = None,
                 ecs_capacity_increase_configs: Optional[Sequence['outputs.PlanWorkflowStepEcsCapacityIncreaseConfig']] = None,
                 eks_resource_scaling_configs: Optional[Sequence['outputs.PlanWorkflowStepEksResourceScalingConfig']] = None,
                 execution_approval_configs: Optional[Sequence['outputs.PlanWorkflowStepExecutionApprovalConfig']] = None,
                 global_aurora_configs: Optional[Sequence['outputs.PlanWorkflowStepGlobalAuroraConfig']] = None,
                 parallel_configs: Optional[Sequence['outputs.PlanWorkflowStepParallelConfig']] = None,
                 region_switch_plan_configs: Optional[Sequence['outputs.PlanWorkflowStepRegionSwitchPlanConfig']] = None,
                 route53_health_check_configs: Optional[Sequence['outputs.PlanWorkflowStepRoute53HealthCheckConfig']] = None):
        """
        :param _builtins.str execution_block_type: Type of execution block. Valid values: `ARCRegionSwitchPlan`, `ARCRoutingControl`, `AuroraGlobalDatabase`, `CustomActionLambda`, `DocumentDb`, `EC2AutoScaling`, `ECSServiceScaling`, `EKSResourceScaling`, `ManualApproval`, `Parallel`, `Route53HealthCheck`.
        :param _builtins.str name: Name of the step.
        :param Sequence['PlanWorkflowStepArcRoutingControlConfigArgs'] arc_routing_control_configs: Configuration for ARC routing control. See ARC Routing Control Config below.
        :param Sequence['PlanWorkflowStepCustomActionLambdaConfigArgs'] custom_action_lambda_configs: Configuration for Lambda function execution. See Custom Action Lambda Config below.
        :param _builtins.str description: Description of the step.
        :param Sequence['PlanWorkflowStepDocumentDbConfigArgs'] document_db_configs: Configuration for DocumentDB global cluster operations. See DocumentDB Config below.
        :param Sequence['PlanWorkflowStepEc2AsgCapacityIncreaseConfigArgs'] ec2_asg_capacity_increase_configs: Configuration for EC2 Auto Scaling group capacity increase. See EC2 ASG Capacity Increase Config below.
        :param Sequence['PlanWorkflowStepEcsCapacityIncreaseConfigArgs'] ecs_capacity_increase_configs: Configuration for ECS service capacity increase. See ECS Capacity Increase Config below.
        :param Sequence['PlanWorkflowStepEksResourceScalingConfigArgs'] eks_resource_scaling_configs: Configuration for EKS resource scaling. See EKS Resource Scaling Config below.
        :param Sequence['PlanWorkflowStepExecutionApprovalConfigArgs'] execution_approval_configs: Configuration for manual approval steps. See Execution Approval Config below.
        :param Sequence['PlanWorkflowStepGlobalAuroraConfigArgs'] global_aurora_configs: Configuration for Aurora Global Database operations. See Global Aurora Config below.
        :param Sequence['PlanWorkflowStepParallelConfigArgs'] parallel_configs: Configuration for parallel execution of multiple steps. See Parallel Config below.
        :param Sequence['PlanWorkflowStepRoute53HealthCheckConfigArgs'] route53_health_check_configs: Configuration for Route53 health check operations. See Route53 Health Check Config below.
        """
        pulumi.set(__self__, "execution_block_type", execution_block_type)
        pulumi.set(__self__, "name", name)
        if arc_routing_control_configs is not None:
            pulumi.set(__self__, "arc_routing_control_configs", arc_routing_control_configs)
        if custom_action_lambda_configs is not None:
            pulumi.set(__self__, "custom_action_lambda_configs", custom_action_lambda_configs)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if document_db_configs is not None:
            pulumi.set(__self__, "document_db_configs", document_db_configs)
        if ec2_asg_capacity_increase_configs is not None:
            pulumi.set(__self__, "ec2_asg_capacity_increase_configs", ec2_asg_capacity_increase_configs)
        if ecs_capacity_increase_configs is not None:
            pulumi.set(__self__, "ecs_capacity_increase_configs", ecs_capacity_increase_configs)
        if eks_resource_scaling_configs is not None:
            pulumi.set(__self__, "eks_resource_scaling_configs", eks_resource_scaling_configs)
        if execution_approval_configs is not None:
            pulumi.set(__self__, "execution_approval_configs", execution_approval_configs)
        if global_aurora_configs is not None:
            pulumi.set(__self__, "global_aurora_configs", global_aurora_configs)
        if parallel_configs is not None:
            pulumi.set(__self__, "parallel_configs", parallel_configs)
        if region_switch_plan_configs is not None:
            pulumi.set(__self__, "region_switch_plan_configs", region_switch_plan_configs)
        if route53_health_check_configs is not None:
            pulumi.set(__self__, "route53_health_check_configs", route53_health_check_configs)

    @_builtins.property
    @pulumi.getter(name="executionBlockType")
    def execution_block_type(self) -> _builtins.str:
        """
        Type of execution block. Valid values: `ARCRegionSwitchPlan`, `ARCRoutingControl`, `AuroraGlobalDatabase`, `CustomActionLambda`, `DocumentDb`, `EC2AutoScaling`, `ECSServiceScaling`, `EKSResourceScaling`, `ManualApproval`, `Parallel`, `Route53HealthCheck`.
        """
        return pulumi.get(self, "execution_block_type")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the step.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="arcRoutingControlConfigs")
    def arc_routing_control_configs(self) -> Optional[Sequence['outputs.PlanWorkflowStepArcRoutingControlConfig']]:
        """
        Configuration for ARC routing control. See ARC Routing Control Config below.
        """
        return pulumi.get(self, "arc_routing_control_configs")

    @_builtins.property
    @pulumi.getter(name="customActionLambdaConfigs")
    def custom_action_lambda_configs(self) -> Optional[Sequence['outputs.PlanWorkflowStepCustomActionLambdaConfig']]:
        """
        Configuration for Lambda function execution. See Custom Action Lambda Config below.
        """
        return pulumi.get(self, "custom_action_lambda_configs")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of the step.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="documentDbConfigs")
    def document_db_configs(self) -> Optional[Sequence['outputs.PlanWorkflowStepDocumentDbConfig']]:
        """
        Configuration for DocumentDB global cluster operations. See DocumentDB Config below.
        """
        return pulumi.get(self, "document_db_configs")

    @_builtins.property
    @pulumi.getter(name="ec2AsgCapacityIncreaseConfigs")
    def ec2_asg_capacity_increase_configs(self) -> Optional[Sequence['outputs.PlanWorkflowStepEc2AsgCapacityIncreaseConfig']]:
        """
        Configuration for EC2 Auto Scaling group capacity increase. See EC2 ASG Capacity Increase Config below.
        """
        return pulumi.get(self, "ec2_asg_capacity_increase_configs")

    @_builtins.property
    @pulumi.getter(name="ecsCapacityIncreaseConfigs")
    def ecs_capacity_increase_configs(self) -> Optional[Sequence['outputs.PlanWorkflowStepEcsCapacityIncreaseConfig']]:
        """
        Configuration for ECS service capacity increase. See ECS Capacity Increase Config below.
        """
        return pulumi.get(self, "ecs_capacity_increase_configs")

    @_builtins.property
    @pulumi.getter(name="eksResourceScalingConfigs")
    def eks_resource_scaling_configs(self) -> Optional[Sequence['outputs.PlanWorkflowStepEksResourceScalingConfig']]:
        """
        Configuration for EKS resource scaling. See EKS Resource Scaling Config below.
        """
        return pulumi.get(self, "eks_resource_scaling_configs")

    @_builtins.property
    @pulumi.getter(name="executionApprovalConfigs")
    def execution_approval_configs(self) -> Optional[Sequence['outputs.PlanWorkflowStepExecutionApprovalConfig']]:
        """
        Configuration for manual approval steps. See Execution Approval Config below.
        """
        return pulumi.get(self, "execution_approval_configs")

    @_builtins.property
    @pulumi.getter(name="globalAuroraConfigs")
    def global_aurora_configs(self) -> Optional[Sequence['outputs.PlanWorkflowStepGlobalAuroraConfig']]:
        """
        Configuration for Aurora Global Database operations. See Global Aurora Config below.
        """
        return pulumi.get(self, "global_aurora_configs")

    @_builtins.property
    @pulumi.getter(name="parallelConfigs")
    def parallel_configs(self) -> Optional[Sequence['outputs.PlanWorkflowStepParallelConfig']]:
        """
        Configuration for parallel execution of multiple steps. See Parallel Config below.
        """
        return pulumi.get(self, "parallel_configs")

    @_builtins.property
    @pulumi.getter(name="regionSwitchPlanConfigs")
    def region_switch_plan_configs(self) -> Optional[Sequence['outputs.PlanWorkflowStepRegionSwitchPlanConfig']]:
        return pulumi.get(self, "region_switch_plan_configs")

    @_builtins.property
    @pulumi.getter(name="route53HealthCheckConfigs")
    def route53_health_check_configs(self) -> Optional[Sequence['outputs.PlanWorkflowStepRoute53HealthCheckConfig']]:
        """
        Configuration for Route53 health check operations. See Route53 Health Check Config below.
        """
        return pulumi.get(self, "route53_health_check_configs")


@pulumi.output_type
class PlanWorkflowStepArcRoutingControlConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "crossAccountRole":
            suggest = "cross_account_role"
        elif key == "externalId":
            suggest = "external_id"
        elif key == "regionAndRoutingControls":
            suggest = "region_and_routing_controls"
        elif key == "timeoutMinutes":
            suggest = "timeout_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanWorkflowStepArcRoutingControlConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanWorkflowStepArcRoutingControlConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanWorkflowStepArcRoutingControlConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cross_account_role: Optional[_builtins.str] = None,
                 external_id: Optional[_builtins.str] = None,
                 region_and_routing_controls: Optional[Sequence['outputs.PlanWorkflowStepArcRoutingControlConfigRegionAndRoutingControl']] = None,
                 timeout_minutes: Optional[_builtins.int] = None):
        """
        :param _builtins.str cross_account_role: ARN of the cross-account role to assume.
        :param _builtins.str external_id: External ID for cross-account role assumption.
        :param Sequence['PlanWorkflowStepArcRoutingControlConfigRegionAndRoutingControlArgs'] region_and_routing_controls: List of regions and their routing controls. See Region and Routing Controls below.
        :param _builtins.int timeout_minutes: Timeout in minutes.
        """
        if cross_account_role is not None:
            pulumi.set(__self__, "cross_account_role", cross_account_role)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if region_and_routing_controls is not None:
            pulumi.set(__self__, "region_and_routing_controls", region_and_routing_controls)
        if timeout_minutes is not None:
            pulumi.set(__self__, "timeout_minutes", timeout_minutes)

    @_builtins.property
    @pulumi.getter(name="crossAccountRole")
    def cross_account_role(self) -> Optional[_builtins.str]:
        """
        ARN of the cross-account role to assume.
        """
        return pulumi.get(self, "cross_account_role")

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[_builtins.str]:
        """
        External ID for cross-account role assumption.
        """
        return pulumi.get(self, "external_id")

    @_builtins.property
    @pulumi.getter(name="regionAndRoutingControls")
    def region_and_routing_controls(self) -> Optional[Sequence['outputs.PlanWorkflowStepArcRoutingControlConfigRegionAndRoutingControl']]:
        """
        List of regions and their routing controls. See Region and Routing Controls below.
        """
        return pulumi.get(self, "region_and_routing_controls")

    @_builtins.property
    @pulumi.getter(name="timeoutMinutes")
    def timeout_minutes(self) -> Optional[_builtins.int]:
        """
        Timeout in minutes.
        """
        return pulumi.get(self, "timeout_minutes")


@pulumi.output_type
class PlanWorkflowStepArcRoutingControlConfigRegionAndRoutingControl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "routingControls":
            suggest = "routing_controls"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanWorkflowStepArcRoutingControlConfigRegionAndRoutingControl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanWorkflowStepArcRoutingControlConfigRegionAndRoutingControl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanWorkflowStepArcRoutingControlConfigRegionAndRoutingControl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 region: _builtins.str,
                 routing_controls: Optional[Sequence['outputs.PlanWorkflowStepArcRoutingControlConfigRegionAndRoutingControlRoutingControl']] = None):
        """
        :param _builtins.str region: AWS region.
        :param Sequence['PlanWorkflowStepArcRoutingControlConfigRegionAndRoutingControlRoutingControlArgs'] routing_controls: List of routing controls. See Routing Control below.
        """
        pulumi.set(__self__, "region", region)
        if routing_controls is not None:
            pulumi.set(__self__, "routing_controls", routing_controls)

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        AWS region.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="routingControls")
    def routing_controls(self) -> Optional[Sequence['outputs.PlanWorkflowStepArcRoutingControlConfigRegionAndRoutingControlRoutingControl']]:
        """
        List of routing controls. See Routing Control below.
        """
        return pulumi.get(self, "routing_controls")


@pulumi.output_type
class PlanWorkflowStepArcRoutingControlConfigRegionAndRoutingControlRoutingControl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "routingControlArn":
            suggest = "routing_control_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanWorkflowStepArcRoutingControlConfigRegionAndRoutingControlRoutingControl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanWorkflowStepArcRoutingControlConfigRegionAndRoutingControlRoutingControl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanWorkflowStepArcRoutingControlConfigRegionAndRoutingControlRoutingControl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 routing_control_arn: _builtins.str,
                 state: _builtins.str):
        """
        :param _builtins.str routing_control_arn: ARN of the routing control.
        :param _builtins.str state: State of the routing control. Valid values: `On`, `Off`.
        """
        pulumi.set(__self__, "routing_control_arn", routing_control_arn)
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="routingControlArn")
    def routing_control_arn(self) -> _builtins.str:
        """
        ARN of the routing control.
        """
        return pulumi.get(self, "routing_control_arn")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        State of the routing control. Valid values: `On`, `Off`.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class PlanWorkflowStepCustomActionLambdaConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "regionToRun":
            suggest = "region_to_run"
        elif key == "retryIntervalMinutes":
            suggest = "retry_interval_minutes"
        elif key == "timeoutMinutes":
            suggest = "timeout_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanWorkflowStepCustomActionLambdaConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanWorkflowStepCustomActionLambdaConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanWorkflowStepCustomActionLambdaConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 region_to_run: _builtins.str,
                 retry_interval_minutes: _builtins.float,
                 lambdas: Optional[Sequence['outputs.PlanWorkflowStepCustomActionLambdaConfigLambda']] = None,
                 timeout_minutes: Optional[_builtins.int] = None,
                 ungracefuls: Optional[Sequence['outputs.PlanWorkflowStepCustomActionLambdaConfigUngraceful']] = None):
        """
        :param _builtins.str region_to_run: Region where the Lambda function should run. Valid values: `activatingRegion`, `deactivatingRegion`.
        :param _builtins.float retry_interval_minutes: Retry interval in minutes.
        :param Sequence['PlanWorkflowStepCustomActionLambdaConfigLambdaArgs'] lambdas: Lambda function configuration. See Lambda below.
        :param _builtins.int timeout_minutes: Timeout in minutes.
        :param Sequence['PlanWorkflowStepCustomActionLambdaConfigUngracefulArgs'] ungracefuls: Ungraceful behavior configuration. See Ungraceful below.
        """
        pulumi.set(__self__, "region_to_run", region_to_run)
        pulumi.set(__self__, "retry_interval_minutes", retry_interval_minutes)
        if lambdas is not None:
            pulumi.set(__self__, "lambdas", lambdas)
        if timeout_minutes is not None:
            pulumi.set(__self__, "timeout_minutes", timeout_minutes)
        if ungracefuls is not None:
            pulumi.set(__self__, "ungracefuls", ungracefuls)

    @_builtins.property
    @pulumi.getter(name="regionToRun")
    def region_to_run(self) -> _builtins.str:
        """
        Region where the Lambda function should run. Valid values: `activatingRegion`, `deactivatingRegion`.
        """
        return pulumi.get(self, "region_to_run")

    @_builtins.property
    @pulumi.getter(name="retryIntervalMinutes")
    def retry_interval_minutes(self) -> _builtins.float:
        """
        Retry interval in minutes.
        """
        return pulumi.get(self, "retry_interval_minutes")

    @_builtins.property
    @pulumi.getter
    def lambdas(self) -> Optional[Sequence['outputs.PlanWorkflowStepCustomActionLambdaConfigLambda']]:
        """
        Lambda function configuration. See Lambda below.
        """
        return pulumi.get(self, "lambdas")

    @_builtins.property
    @pulumi.getter(name="timeoutMinutes")
    def timeout_minutes(self) -> Optional[_builtins.int]:
        """
        Timeout in minutes.
        """
        return pulumi.get(self, "timeout_minutes")

    @_builtins.property
    @pulumi.getter
    def ungracefuls(self) -> Optional[Sequence['outputs.PlanWorkflowStepCustomActionLambdaConfigUngraceful']]:
        """
        Ungraceful behavior configuration. See Ungraceful below.
        """
        return pulumi.get(self, "ungracefuls")


@pulumi.output_type
class PlanWorkflowStepCustomActionLambdaConfigLambda(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "crossAccountRole":
            suggest = "cross_account_role"
        elif key == "externalId":
            suggest = "external_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanWorkflowStepCustomActionLambdaConfigLambda. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanWorkflowStepCustomActionLambdaConfigLambda.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanWorkflowStepCustomActionLambdaConfigLambda.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: _builtins.str,
                 cross_account_role: Optional[_builtins.str] = None,
                 external_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str arn: ARN of the Lambda function.
        :param _builtins.str cross_account_role: ARN of the cross-account role to assume.
        :param _builtins.str external_id: External ID for cross-account role assumption.
        """
        pulumi.set(__self__, "arn", arn)
        if cross_account_role is not None:
            pulumi.set(__self__, "cross_account_role", cross_account_role)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        """
        ARN of the Lambda function.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter(name="crossAccountRole")
    def cross_account_role(self) -> Optional[_builtins.str]:
        """
        ARN of the cross-account role to assume.
        """
        return pulumi.get(self, "cross_account_role")

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[_builtins.str]:
        """
        External ID for cross-account role assumption.
        """
        return pulumi.get(self, "external_id")


@pulumi.output_type
class PlanWorkflowStepCustomActionLambdaConfigUngraceful(dict):
    def __init__(__self__, *,
                 behavior: _builtins.str):
        """
        :param _builtins.str behavior: Behavior when ungraceful. Valid values: `skip`.
        """
        pulumi.set(__self__, "behavior", behavior)

    @_builtins.property
    @pulumi.getter
    def behavior(self) -> _builtins.str:
        """
        Behavior when ungraceful. Valid values: `skip`.
        """
        return pulumi.get(self, "behavior")


@pulumi.output_type
class PlanWorkflowStepDocumentDbConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseClusterArns":
            suggest = "database_cluster_arns"
        elif key == "globalClusterIdentifier":
            suggest = "global_cluster_identifier"
        elif key == "crossAccountRole":
            suggest = "cross_account_role"
        elif key == "externalId":
            suggest = "external_id"
        elif key == "timeoutMinutes":
            suggest = "timeout_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanWorkflowStepDocumentDbConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanWorkflowStepDocumentDbConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanWorkflowStepDocumentDbConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 behavior: _builtins.str,
                 database_cluster_arns: Sequence[_builtins.str],
                 global_cluster_identifier: _builtins.str,
                 cross_account_role: Optional[_builtins.str] = None,
                 external_id: Optional[_builtins.str] = None,
                 timeout_minutes: Optional[_builtins.int] = None,
                 ungracefuls: Optional[Sequence['outputs.PlanWorkflowStepDocumentDbConfigUngraceful']] = None):
        pulumi.set(__self__, "behavior", behavior)
        pulumi.set(__self__, "database_cluster_arns", database_cluster_arns)
        pulumi.set(__self__, "global_cluster_identifier", global_cluster_identifier)
        if cross_account_role is not None:
            pulumi.set(__self__, "cross_account_role", cross_account_role)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if timeout_minutes is not None:
            pulumi.set(__self__, "timeout_minutes", timeout_minutes)
        if ungracefuls is not None:
            pulumi.set(__self__, "ungracefuls", ungracefuls)

    @_builtins.property
    @pulumi.getter
    def behavior(self) -> _builtins.str:
        return pulumi.get(self, "behavior")

    @_builtins.property
    @pulumi.getter(name="databaseClusterArns")
    def database_cluster_arns(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "database_cluster_arns")

    @_builtins.property
    @pulumi.getter(name="globalClusterIdentifier")
    def global_cluster_identifier(self) -> _builtins.str:
        return pulumi.get(self, "global_cluster_identifier")

    @_builtins.property
    @pulumi.getter(name="crossAccountRole")
    def cross_account_role(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cross_account_role")

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "external_id")

    @_builtins.property
    @pulumi.getter(name="timeoutMinutes")
    def timeout_minutes(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "timeout_minutes")

    @_builtins.property
    @pulumi.getter
    def ungracefuls(self) -> Optional[Sequence['outputs.PlanWorkflowStepDocumentDbConfigUngraceful']]:
        return pulumi.get(self, "ungracefuls")


@pulumi.output_type
class PlanWorkflowStepDocumentDbConfigUngraceful(dict):
    def __init__(__self__, *,
                 ungraceful: _builtins.str):
        pulumi.set(__self__, "ungraceful", ungraceful)

    @_builtins.property
    @pulumi.getter
    def ungraceful(self) -> _builtins.str:
        return pulumi.get(self, "ungraceful")


@pulumi.output_type
class PlanWorkflowStepEc2AsgCapacityIncreaseConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capacityMonitoringApproach":
            suggest = "capacity_monitoring_approach"
        elif key == "targetPercent":
            suggest = "target_percent"
        elif key == "timeoutMinutes":
            suggest = "timeout_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanWorkflowStepEc2AsgCapacityIncreaseConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanWorkflowStepEc2AsgCapacityIncreaseConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanWorkflowStepEc2AsgCapacityIncreaseConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capacity_monitoring_approach: _builtins.str,
                 asgs: Optional[Sequence['outputs.PlanWorkflowStepEc2AsgCapacityIncreaseConfigAsg']] = None,
                 target_percent: Optional[_builtins.int] = None,
                 timeout_minutes: Optional[_builtins.int] = None,
                 ungraceful: Optional['outputs.PlanWorkflowStepEc2AsgCapacityIncreaseConfigUngraceful'] = None):
        """
        :param _builtins.str capacity_monitoring_approach: Capacity monitoring approach. Valid values: `sampledMaxInLast24Hours`, `autoscalingMaxInLast24Hours`.
        :param Sequence['PlanWorkflowStepEc2AsgCapacityIncreaseConfigAsgArgs'] asgs: Auto Scaling group configuration. See ASG below.
        :param _builtins.int target_percent: Target capacity percentage.
        :param _builtins.int timeout_minutes: Timeout in minutes.
        :param 'PlanWorkflowStepEc2AsgCapacityIncreaseConfigUngracefulArgs' ungraceful: Ungraceful behavior configuration. See Ungraceful below.
        """
        pulumi.set(__self__, "capacity_monitoring_approach", capacity_monitoring_approach)
        if asgs is not None:
            pulumi.set(__self__, "asgs", asgs)
        if target_percent is not None:
            pulumi.set(__self__, "target_percent", target_percent)
        if timeout_minutes is not None:
            pulumi.set(__self__, "timeout_minutes", timeout_minutes)
        if ungraceful is not None:
            pulumi.set(__self__, "ungraceful", ungraceful)

    @_builtins.property
    @pulumi.getter(name="capacityMonitoringApproach")
    def capacity_monitoring_approach(self) -> _builtins.str:
        """
        Capacity monitoring approach. Valid values: `sampledMaxInLast24Hours`, `autoscalingMaxInLast24Hours`.
        """
        return pulumi.get(self, "capacity_monitoring_approach")

    @_builtins.property
    @pulumi.getter
    def asgs(self) -> Optional[Sequence['outputs.PlanWorkflowStepEc2AsgCapacityIncreaseConfigAsg']]:
        """
        Auto Scaling group configuration. See ASG below.
        """
        return pulumi.get(self, "asgs")

    @_builtins.property
    @pulumi.getter(name="targetPercent")
    def target_percent(self) -> Optional[_builtins.int]:
        """
        Target capacity percentage.
        """
        return pulumi.get(self, "target_percent")

    @_builtins.property
    @pulumi.getter(name="timeoutMinutes")
    def timeout_minutes(self) -> Optional[_builtins.int]:
        """
        Timeout in minutes.
        """
        return pulumi.get(self, "timeout_minutes")

    @_builtins.property
    @pulumi.getter
    def ungraceful(self) -> Optional['outputs.PlanWorkflowStepEc2AsgCapacityIncreaseConfigUngraceful']:
        """
        Ungraceful behavior configuration. See Ungraceful below.
        """
        return pulumi.get(self, "ungraceful")


@pulumi.output_type
class PlanWorkflowStepEc2AsgCapacityIncreaseConfigAsg(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "crossAccountRole":
            suggest = "cross_account_role"
        elif key == "externalId":
            suggest = "external_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanWorkflowStepEc2AsgCapacityIncreaseConfigAsg. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanWorkflowStepEc2AsgCapacityIncreaseConfigAsg.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanWorkflowStepEc2AsgCapacityIncreaseConfigAsg.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: _builtins.str,
                 cross_account_role: Optional[_builtins.str] = None,
                 external_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str arn: ARN of the Auto Scaling group.
        :param _builtins.str cross_account_role: ARN of the cross-account role to assume.
        :param _builtins.str external_id: External ID for cross-account role assumption.
        """
        pulumi.set(__self__, "arn", arn)
        if cross_account_role is not None:
            pulumi.set(__self__, "cross_account_role", cross_account_role)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        """
        ARN of the Auto Scaling group.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter(name="crossAccountRole")
    def cross_account_role(self) -> Optional[_builtins.str]:
        """
        ARN of the cross-account role to assume.
        """
        return pulumi.get(self, "cross_account_role")

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[_builtins.str]:
        """
        External ID for cross-account role assumption.
        """
        return pulumi.get(self, "external_id")


@pulumi.output_type
class PlanWorkflowStepEc2AsgCapacityIncreaseConfigUngraceful(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minimumSuccessPercentage":
            suggest = "minimum_success_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanWorkflowStepEc2AsgCapacityIncreaseConfigUngraceful. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanWorkflowStepEc2AsgCapacityIncreaseConfigUngraceful.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanWorkflowStepEc2AsgCapacityIncreaseConfigUngraceful.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 minimum_success_percentage: _builtins.int):
        """
        :param _builtins.int minimum_success_percentage: Minimum success percentage required.
        """
        pulumi.set(__self__, "minimum_success_percentage", minimum_success_percentage)

    @_builtins.property
    @pulumi.getter(name="minimumSuccessPercentage")
    def minimum_success_percentage(self) -> _builtins.int:
        """
        Minimum success percentage required.
        """
        return pulumi.get(self, "minimum_success_percentage")


@pulumi.output_type
class PlanWorkflowStepEcsCapacityIncreaseConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capacityMonitoringApproach":
            suggest = "capacity_monitoring_approach"
        elif key == "targetPercent":
            suggest = "target_percent"
        elif key == "timeoutMinutes":
            suggest = "timeout_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanWorkflowStepEcsCapacityIncreaseConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanWorkflowStepEcsCapacityIncreaseConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanWorkflowStepEcsCapacityIncreaseConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capacity_monitoring_approach: _builtins.str,
                 services: Optional[Sequence['outputs.PlanWorkflowStepEcsCapacityIncreaseConfigService']] = None,
                 target_percent: Optional[_builtins.int] = None,
                 timeout_minutes: Optional[_builtins.int] = None,
                 ungraceful: Optional['outputs.PlanWorkflowStepEcsCapacityIncreaseConfigUngraceful'] = None):
        """
        :param _builtins.str capacity_monitoring_approach: Capacity monitoring approach. Valid values: `sampledMaxInLast24Hours`, `containerInsightsMaxInLast24Hours`.
        :param Sequence['PlanWorkflowStepEcsCapacityIncreaseConfigServiceArgs'] services: ECS service configuration. See ECS Service below.
        :param _builtins.int target_percent: Target capacity percentage.
        :param _builtins.int timeout_minutes: Timeout in minutes.
        :param 'PlanWorkflowStepEcsCapacityIncreaseConfigUngracefulArgs' ungraceful: Ungraceful behavior configuration. See Ungraceful Capacity below.
        """
        pulumi.set(__self__, "capacity_monitoring_approach", capacity_monitoring_approach)
        if services is not None:
            pulumi.set(__self__, "services", services)
        if target_percent is not None:
            pulumi.set(__self__, "target_percent", target_percent)
        if timeout_minutes is not None:
            pulumi.set(__self__, "timeout_minutes", timeout_minutes)
        if ungraceful is not None:
            pulumi.set(__self__, "ungraceful", ungraceful)

    @_builtins.property
    @pulumi.getter(name="capacityMonitoringApproach")
    def capacity_monitoring_approach(self) -> _builtins.str:
        """
        Capacity monitoring approach. Valid values: `sampledMaxInLast24Hours`, `containerInsightsMaxInLast24Hours`.
        """
        return pulumi.get(self, "capacity_monitoring_approach")

    @_builtins.property
    @pulumi.getter
    def services(self) -> Optional[Sequence['outputs.PlanWorkflowStepEcsCapacityIncreaseConfigService']]:
        """
        ECS service configuration. See ECS Service below.
        """
        return pulumi.get(self, "services")

    @_builtins.property
    @pulumi.getter(name="targetPercent")
    def target_percent(self) -> Optional[_builtins.int]:
        """
        Target capacity percentage.
        """
        return pulumi.get(self, "target_percent")

    @_builtins.property
    @pulumi.getter(name="timeoutMinutes")
    def timeout_minutes(self) -> Optional[_builtins.int]:
        """
        Timeout in minutes.
        """
        return pulumi.get(self, "timeout_minutes")

    @_builtins.property
    @pulumi.getter
    def ungraceful(self) -> Optional['outputs.PlanWorkflowStepEcsCapacityIncreaseConfigUngraceful']:
        """
        Ungraceful behavior configuration. See Ungraceful Capacity below.
        """
        return pulumi.get(self, "ungraceful")


@pulumi.output_type
class PlanWorkflowStepEcsCapacityIncreaseConfigService(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterArn":
            suggest = "cluster_arn"
        elif key == "serviceArn":
            suggest = "service_arn"
        elif key == "crossAccountRole":
            suggest = "cross_account_role"
        elif key == "externalId":
            suggest = "external_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanWorkflowStepEcsCapacityIncreaseConfigService. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanWorkflowStepEcsCapacityIncreaseConfigService.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanWorkflowStepEcsCapacityIncreaseConfigService.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_arn: _builtins.str,
                 service_arn: _builtins.str,
                 cross_account_role: Optional[_builtins.str] = None,
                 external_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str service_arn: ARN of the ECS service.
        """
        pulumi.set(__self__, "cluster_arn", cluster_arn)
        pulumi.set(__self__, "service_arn", service_arn)
        if cross_account_role is not None:
            pulumi.set(__self__, "cross_account_role", cross_account_role)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)

    @_builtins.property
    @pulumi.getter(name="clusterArn")
    def cluster_arn(self) -> _builtins.str:
        return pulumi.get(self, "cluster_arn")

    @_builtins.property
    @pulumi.getter(name="serviceArn")
    def service_arn(self) -> _builtins.str:
        """
        ARN of the ECS service.
        """
        return pulumi.get(self, "service_arn")

    @_builtins.property
    @pulumi.getter(name="crossAccountRole")
    def cross_account_role(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cross_account_role")

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "external_id")


@pulumi.output_type
class PlanWorkflowStepEcsCapacityIncreaseConfigUngraceful(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minimumSuccessPercentage":
            suggest = "minimum_success_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanWorkflowStepEcsCapacityIncreaseConfigUngraceful. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanWorkflowStepEcsCapacityIncreaseConfigUngraceful.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanWorkflowStepEcsCapacityIncreaseConfigUngraceful.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 minimum_success_percentage: _builtins.int):
        """
        :param _builtins.int minimum_success_percentage: Minimum success percentage required.
        """
        pulumi.set(__self__, "minimum_success_percentage", minimum_success_percentage)

    @_builtins.property
    @pulumi.getter(name="minimumSuccessPercentage")
    def minimum_success_percentage(self) -> _builtins.int:
        """
        Minimum success percentage required.
        """
        return pulumi.get(self, "minimum_success_percentage")


@pulumi.output_type
class PlanWorkflowStepEksResourceScalingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capacityMonitoringApproach":
            suggest = "capacity_monitoring_approach"
        elif key == "targetPercent":
            suggest = "target_percent"
        elif key == "eksClusters":
            suggest = "eks_clusters"
        elif key == "kubernetesResourceTypes":
            suggest = "kubernetes_resource_types"
        elif key == "scalingResources":
            suggest = "scaling_resources"
        elif key == "timeoutMinutes":
            suggest = "timeout_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanWorkflowStepEksResourceScalingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanWorkflowStepEksResourceScalingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanWorkflowStepEksResourceScalingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capacity_monitoring_approach: _builtins.str,
                 target_percent: _builtins.int,
                 eks_clusters: Optional[Sequence['outputs.PlanWorkflowStepEksResourceScalingConfigEksCluster']] = None,
                 kubernetes_resource_types: Optional[Sequence['outputs.PlanWorkflowStepEksResourceScalingConfigKubernetesResourceType']] = None,
                 scaling_resources: Optional[Sequence['outputs.PlanWorkflowStepEksResourceScalingConfigScalingResource']] = None,
                 timeout_minutes: Optional[_builtins.int] = None,
                 ungracefuls: Optional[Sequence['outputs.PlanWorkflowStepEksResourceScalingConfigUngraceful']] = None):
        """
        :param _builtins.str capacity_monitoring_approach: Capacity monitoring approach. Valid values: `sampledMaxInLast24Hours`, `autoscalingMaxInLast24Hours`.
        :param _builtins.int target_percent: Target capacity percentage.
        :param Sequence['PlanWorkflowStepEksResourceScalingConfigEksClusterArgs'] eks_clusters: List of EKS clusters. See EKS Clusters below.
        :param Sequence['PlanWorkflowStepEksResourceScalingConfigKubernetesResourceTypeArgs'] kubernetes_resource_types: Kubernetes resource type. See Kubernetes Resource Type below.
        :param Sequence['PlanWorkflowStepEksResourceScalingConfigScalingResourceArgs'] scaling_resources: List of scaling resources. See Scaling Resources below.
        :param _builtins.int timeout_minutes: Timeout in minutes.
        :param Sequence['PlanWorkflowStepEksResourceScalingConfigUngracefulArgs'] ungracefuls: Ungraceful behavior configuration. See Ungraceful Capacity below.
        """
        pulumi.set(__self__, "capacity_monitoring_approach", capacity_monitoring_approach)
        pulumi.set(__self__, "target_percent", target_percent)
        if eks_clusters is not None:
            pulumi.set(__self__, "eks_clusters", eks_clusters)
        if kubernetes_resource_types is not None:
            pulumi.set(__self__, "kubernetes_resource_types", kubernetes_resource_types)
        if scaling_resources is not None:
            pulumi.set(__self__, "scaling_resources", scaling_resources)
        if timeout_minutes is not None:
            pulumi.set(__self__, "timeout_minutes", timeout_minutes)
        if ungracefuls is not None:
            pulumi.set(__self__, "ungracefuls", ungracefuls)

    @_builtins.property
    @pulumi.getter(name="capacityMonitoringApproach")
    def capacity_monitoring_approach(self) -> _builtins.str:
        """
        Capacity monitoring approach. Valid values: `sampledMaxInLast24Hours`, `autoscalingMaxInLast24Hours`.
        """
        return pulumi.get(self, "capacity_monitoring_approach")

    @_builtins.property
    @pulumi.getter(name="targetPercent")
    def target_percent(self) -> _builtins.int:
        """
        Target capacity percentage.
        """
        return pulumi.get(self, "target_percent")

    @_builtins.property
    @pulumi.getter(name="eksClusters")
    def eks_clusters(self) -> Optional[Sequence['outputs.PlanWorkflowStepEksResourceScalingConfigEksCluster']]:
        """
        List of EKS clusters. See EKS Clusters below.
        """
        return pulumi.get(self, "eks_clusters")

    @_builtins.property
    @pulumi.getter(name="kubernetesResourceTypes")
    def kubernetes_resource_types(self) -> Optional[Sequence['outputs.PlanWorkflowStepEksResourceScalingConfigKubernetesResourceType']]:
        """
        Kubernetes resource type. See Kubernetes Resource Type below.
        """
        return pulumi.get(self, "kubernetes_resource_types")

    @_builtins.property
    @pulumi.getter(name="scalingResources")
    def scaling_resources(self) -> Optional[Sequence['outputs.PlanWorkflowStepEksResourceScalingConfigScalingResource']]:
        """
        List of scaling resources. See Scaling Resources below.
        """
        return pulumi.get(self, "scaling_resources")

    @_builtins.property
    @pulumi.getter(name="timeoutMinutes")
    def timeout_minutes(self) -> Optional[_builtins.int]:
        """
        Timeout in minutes.
        """
        return pulumi.get(self, "timeout_minutes")

    @_builtins.property
    @pulumi.getter
    def ungracefuls(self) -> Optional[Sequence['outputs.PlanWorkflowStepEksResourceScalingConfigUngraceful']]:
        """
        Ungraceful behavior configuration. See Ungraceful Capacity below.
        """
        return pulumi.get(self, "ungracefuls")


@pulumi.output_type
class PlanWorkflowStepEksResourceScalingConfigEksCluster(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterArn":
            suggest = "cluster_arn"
        elif key == "crossAccountRole":
            suggest = "cross_account_role"
        elif key == "externalId":
            suggest = "external_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanWorkflowStepEksResourceScalingConfigEksCluster. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanWorkflowStepEksResourceScalingConfigEksCluster.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanWorkflowStepEksResourceScalingConfigEksCluster.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_arn: _builtins.str,
                 cross_account_role: Optional[_builtins.str] = None,
                 external_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str cluster_arn: ARN of the EKS cluster.
        :param _builtins.str cross_account_role: ARN of the cross-account role to assume.
        :param _builtins.str external_id: External ID for cross-account role assumption.
        """
        pulumi.set(__self__, "cluster_arn", cluster_arn)
        if cross_account_role is not None:
            pulumi.set(__self__, "cross_account_role", cross_account_role)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)

    @_builtins.property
    @pulumi.getter(name="clusterArn")
    def cluster_arn(self) -> _builtins.str:
        """
        ARN of the EKS cluster.
        """
        return pulumi.get(self, "cluster_arn")

    @_builtins.property
    @pulumi.getter(name="crossAccountRole")
    def cross_account_role(self) -> Optional[_builtins.str]:
        """
        ARN of the cross-account role to assume.
        """
        return pulumi.get(self, "cross_account_role")

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[_builtins.str]:
        """
        External ID for cross-account role assumption.
        """
        return pulumi.get(self, "external_id")


@pulumi.output_type
class PlanWorkflowStepEksResourceScalingConfigKubernetesResourceType(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiVersion":
            suggest = "api_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanWorkflowStepEksResourceScalingConfigKubernetesResourceType. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanWorkflowStepEksResourceScalingConfigKubernetesResourceType.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanWorkflowStepEksResourceScalingConfigKubernetesResourceType.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_version: _builtins.str,
                 kind: _builtins.str):
        """
        :param _builtins.str api_version: Kubernetes API version.
        :param _builtins.str kind: Kubernetes resource kind.
        """
        pulumi.set(__self__, "api_version", api_version)
        pulumi.set(__self__, "kind", kind)

    @_builtins.property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> _builtins.str:
        """
        Kubernetes API version.
        """
        return pulumi.get(self, "api_version")

    @_builtins.property
    @pulumi.getter
    def kind(self) -> _builtins.str:
        """
        Kubernetes resource kind.
        """
        return pulumi.get(self, "kind")


@pulumi.output_type
class PlanWorkflowStepEksResourceScalingConfigScalingResource(dict):
    def __init__(__self__, *,
                 namespace: _builtins.str,
                 resources: Optional[Sequence['outputs.PlanWorkflowStepEksResourceScalingConfigScalingResourceResource']] = None):
        """
        :param _builtins.str namespace: Kubernetes namespace.
        :param Sequence['PlanWorkflowStepEksResourceScalingConfigScalingResourceResourceArgs'] resources: Set of resources to scale. See Resources below.
        """
        pulumi.set(__self__, "namespace", namespace)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> _builtins.str:
        """
        Kubernetes namespace.
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Optional[Sequence['outputs.PlanWorkflowStepEksResourceScalingConfigScalingResourceResource']]:
        """
        Set of resources to scale. See Resources below.
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class PlanWorkflowStepEksResourceScalingConfigScalingResourceResource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceName":
            suggest = "resource_name"
        elif key == "hpaName":
            suggest = "hpa_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanWorkflowStepEksResourceScalingConfigScalingResourceResource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanWorkflowStepEksResourceScalingConfigScalingResourceResource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanWorkflowStepEksResourceScalingConfigScalingResourceResource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 namespace: _builtins.str,
                 resource_name: _builtins.str,
                 hpa_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name of the Kubernetes object.
        :param _builtins.str namespace: Kubernetes namespace.
        :param _builtins.str resource_name: Name of the resource.
        :param _builtins.str hpa_name: Name of the Horizontal Pod Autoscaler.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "resource_name", resource_name)
        if hpa_name is not None:
            pulumi.set(__self__, "hpa_name", hpa_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the Kubernetes object.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> _builtins.str:
        """
        Kubernetes namespace.
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> _builtins.str:
        """
        Name of the resource.
        """
        return pulumi.get(self, "resource_name")

    @_builtins.property
    @pulumi.getter(name="hpaName")
    def hpa_name(self) -> Optional[_builtins.str]:
        """
        Name of the Horizontal Pod Autoscaler.
        """
        return pulumi.get(self, "hpa_name")


@pulumi.output_type
class PlanWorkflowStepEksResourceScalingConfigUngraceful(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minimumSuccessPercentage":
            suggest = "minimum_success_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanWorkflowStepEksResourceScalingConfigUngraceful. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanWorkflowStepEksResourceScalingConfigUngraceful.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanWorkflowStepEksResourceScalingConfigUngraceful.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 minimum_success_percentage: _builtins.int):
        """
        :param _builtins.int minimum_success_percentage: Minimum success percentage required.
        """
        pulumi.set(__self__, "minimum_success_percentage", minimum_success_percentage)

    @_builtins.property
    @pulumi.getter(name="minimumSuccessPercentage")
    def minimum_success_percentage(self) -> _builtins.int:
        """
        Minimum success percentage required.
        """
        return pulumi.get(self, "minimum_success_percentage")


@pulumi.output_type
class PlanWorkflowStepExecutionApprovalConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "approvalRole":
            suggest = "approval_role"
        elif key == "timeoutMinutes":
            suggest = "timeout_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanWorkflowStepExecutionApprovalConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanWorkflowStepExecutionApprovalConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanWorkflowStepExecutionApprovalConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 approval_role: _builtins.str,
                 timeout_minutes: Optional[_builtins.int] = None):
        """
        :param _builtins.str approval_role: ARN of the IAM role for approval.
        :param _builtins.int timeout_minutes: Timeout in minutes for the approval.
        """
        pulumi.set(__self__, "approval_role", approval_role)
        if timeout_minutes is not None:
            pulumi.set(__self__, "timeout_minutes", timeout_minutes)

    @_builtins.property
    @pulumi.getter(name="approvalRole")
    def approval_role(self) -> _builtins.str:
        """
        ARN of the IAM role for approval.
        """
        return pulumi.get(self, "approval_role")

    @_builtins.property
    @pulumi.getter(name="timeoutMinutes")
    def timeout_minutes(self) -> Optional[_builtins.int]:
        """
        Timeout in minutes for the approval.
        """
        return pulumi.get(self, "timeout_minutes")


@pulumi.output_type
class PlanWorkflowStepGlobalAuroraConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseClusterArns":
            suggest = "database_cluster_arns"
        elif key == "globalClusterIdentifier":
            suggest = "global_cluster_identifier"
        elif key == "crossAccountRole":
            suggest = "cross_account_role"
        elif key == "externalId":
            suggest = "external_id"
        elif key == "timeoutMinutes":
            suggest = "timeout_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanWorkflowStepGlobalAuroraConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanWorkflowStepGlobalAuroraConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanWorkflowStepGlobalAuroraConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 behavior: _builtins.str,
                 database_cluster_arns: Sequence[_builtins.str],
                 global_cluster_identifier: _builtins.str,
                 cross_account_role: Optional[_builtins.str] = None,
                 external_id: Optional[_builtins.str] = None,
                 timeout_minutes: Optional[_builtins.int] = None,
                 ungracefuls: Optional[Sequence['outputs.PlanWorkflowStepGlobalAuroraConfigUngraceful']] = None):
        """
        :param _builtins.str behavior: Behavior for Aurora operations. Valid values: `switchoverOnly`, `failover`.
        :param Sequence[_builtins.str] database_cluster_arns: List of database cluster ARNs.
        :param _builtins.str global_cluster_identifier: Global cluster identifier.
        :param _builtins.str cross_account_role: ARN of the cross-account role to assume.
        :param _builtins.str external_id: External ID for cross-account role assumption.
        :param _builtins.int timeout_minutes: Timeout in minutes.
        :param Sequence['PlanWorkflowStepGlobalAuroraConfigUngracefulArgs'] ungracefuls: Ungraceful behavior configuration. See Ungraceful Aurora below.
        """
        pulumi.set(__self__, "behavior", behavior)
        pulumi.set(__self__, "database_cluster_arns", database_cluster_arns)
        pulumi.set(__self__, "global_cluster_identifier", global_cluster_identifier)
        if cross_account_role is not None:
            pulumi.set(__self__, "cross_account_role", cross_account_role)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if timeout_minutes is not None:
            pulumi.set(__self__, "timeout_minutes", timeout_minutes)
        if ungracefuls is not None:
            pulumi.set(__self__, "ungracefuls", ungracefuls)

    @_builtins.property
    @pulumi.getter
    def behavior(self) -> _builtins.str:
        """
        Behavior for Aurora operations. Valid values: `switchoverOnly`, `failover`.
        """
        return pulumi.get(self, "behavior")

    @_builtins.property
    @pulumi.getter(name="databaseClusterArns")
    def database_cluster_arns(self) -> Sequence[_builtins.str]:
        """
        List of database cluster ARNs.
        """
        return pulumi.get(self, "database_cluster_arns")

    @_builtins.property
    @pulumi.getter(name="globalClusterIdentifier")
    def global_cluster_identifier(self) -> _builtins.str:
        """
        Global cluster identifier.
        """
        return pulumi.get(self, "global_cluster_identifier")

    @_builtins.property
    @pulumi.getter(name="crossAccountRole")
    def cross_account_role(self) -> Optional[_builtins.str]:
        """
        ARN of the cross-account role to assume.
        """
        return pulumi.get(self, "cross_account_role")

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[_builtins.str]:
        """
        External ID for cross-account role assumption.
        """
        return pulumi.get(self, "external_id")

    @_builtins.property
    @pulumi.getter(name="timeoutMinutes")
    def timeout_minutes(self) -> Optional[_builtins.int]:
        """
        Timeout in minutes.
        """
        return pulumi.get(self, "timeout_minutes")

    @_builtins.property
    @pulumi.getter
    def ungracefuls(self) -> Optional[Sequence['outputs.PlanWorkflowStepGlobalAuroraConfigUngraceful']]:
        """
        Ungraceful behavior configuration. See Ungraceful Aurora below.
        """
        return pulumi.get(self, "ungracefuls")


@pulumi.output_type
class PlanWorkflowStepGlobalAuroraConfigUngraceful(dict):
    def __init__(__self__, *,
                 ungraceful: _builtins.str):
        pulumi.set(__self__, "ungraceful", ungraceful)

    @_builtins.property
    @pulumi.getter
    def ungraceful(self) -> _builtins.str:
        return pulumi.get(self, "ungraceful")


@pulumi.output_type
class PlanWorkflowStepParallelConfig(dict):
    def __init__(__self__, *,
                 steps: Optional[Sequence['outputs.PlanWorkflowStepParallelConfigStep']] = None):
        """
        :param Sequence['PlanWorkflowStepParallelConfigStepArgs'] steps: List of steps to execute in parallel. Uses the same schema as Step but without `parallel_config` to prevent infinite nesting.
        """
        if steps is not None:
            pulumi.set(__self__, "steps", steps)

    @_builtins.property
    @pulumi.getter
    def steps(self) -> Optional[Sequence['outputs.PlanWorkflowStepParallelConfigStep']]:
        """
        List of steps to execute in parallel. Uses the same schema as Step but without `parallel_config` to prevent infinite nesting.
        """
        return pulumi.get(self, "steps")


@pulumi.output_type
class PlanWorkflowStepParallelConfigStep(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "executionBlockType":
            suggest = "execution_block_type"
        elif key == "arcRoutingControlConfigs":
            suggest = "arc_routing_control_configs"
        elif key == "customActionLambdaConfigs":
            suggest = "custom_action_lambda_configs"
        elif key == "documentDbConfigs":
            suggest = "document_db_configs"
        elif key == "ec2AsgCapacityIncreaseConfigs":
            suggest = "ec2_asg_capacity_increase_configs"
        elif key == "ecsCapacityIncreaseConfigs":
            suggest = "ecs_capacity_increase_configs"
        elif key == "eksResourceScalingConfigs":
            suggest = "eks_resource_scaling_configs"
        elif key == "executionApprovalConfigs":
            suggest = "execution_approval_configs"
        elif key == "globalAuroraConfigs":
            suggest = "global_aurora_configs"
        elif key == "regionSwitchPlanConfigs":
            suggest = "region_switch_plan_configs"
        elif key == "route53HealthCheckConfigs":
            suggest = "route53_health_check_configs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanWorkflowStepParallelConfigStep. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanWorkflowStepParallelConfigStep.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanWorkflowStepParallelConfigStep.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 execution_block_type: _builtins.str,
                 name: _builtins.str,
                 arc_routing_control_configs: Optional[Sequence['outputs.PlanWorkflowStepParallelConfigStepArcRoutingControlConfig']] = None,
                 custom_action_lambda_configs: Optional[Sequence['outputs.PlanWorkflowStepParallelConfigStepCustomActionLambdaConfig']] = None,
                 description: Optional[_builtins.str] = None,
                 document_db_configs: Optional[Sequence['outputs.PlanWorkflowStepParallelConfigStepDocumentDbConfig']] = None,
                 ec2_asg_capacity_increase_configs: Optional[Sequence['outputs.PlanWorkflowStepParallelConfigStepEc2AsgCapacityIncreaseConfig']] = None,
                 ecs_capacity_increase_configs: Optional[Sequence['outputs.PlanWorkflowStepParallelConfigStepEcsCapacityIncreaseConfig']] = None,
                 eks_resource_scaling_configs: Optional[Sequence['outputs.PlanWorkflowStepParallelConfigStepEksResourceScalingConfig']] = None,
                 execution_approval_configs: Optional[Sequence['outputs.PlanWorkflowStepParallelConfigStepExecutionApprovalConfig']] = None,
                 global_aurora_configs: Optional[Sequence['outputs.PlanWorkflowStepParallelConfigStepGlobalAuroraConfig']] = None,
                 region_switch_plan_configs: Optional[Sequence['outputs.PlanWorkflowStepParallelConfigStepRegionSwitchPlanConfig']] = None,
                 route53_health_check_configs: Optional[Sequence['outputs.PlanWorkflowStepParallelConfigStepRoute53HealthCheckConfig']] = None):
        """
        :param _builtins.str execution_block_type: Type of execution block. Valid values: `ARCRegionSwitchPlan`, `ARCRoutingControl`, `AuroraGlobalDatabase`, `CustomActionLambda`, `DocumentDb`, `EC2AutoScaling`, `ECSServiceScaling`, `EKSResourceScaling`, `ManualApproval`, `Parallel`, `Route53HealthCheck`.
        :param _builtins.str name: Name of the step.
        :param Sequence['PlanWorkflowStepParallelConfigStepArcRoutingControlConfigArgs'] arc_routing_control_configs: Configuration for ARC routing control. See ARC Routing Control Config below.
        :param Sequence['PlanWorkflowStepParallelConfigStepCustomActionLambdaConfigArgs'] custom_action_lambda_configs: Configuration for Lambda function execution. See Custom Action Lambda Config below.
        :param _builtins.str description: Description of the step.
        :param Sequence['PlanWorkflowStepParallelConfigStepDocumentDbConfigArgs'] document_db_configs: Configuration for DocumentDB global cluster operations. See DocumentDB Config below.
        :param Sequence['PlanWorkflowStepParallelConfigStepEc2AsgCapacityIncreaseConfigArgs'] ec2_asg_capacity_increase_configs: Configuration for EC2 Auto Scaling group capacity increase. See EC2 ASG Capacity Increase Config below.
        :param Sequence['PlanWorkflowStepParallelConfigStepEcsCapacityIncreaseConfigArgs'] ecs_capacity_increase_configs: Configuration for ECS service capacity increase. See ECS Capacity Increase Config below.
        :param Sequence['PlanWorkflowStepParallelConfigStepEksResourceScalingConfigArgs'] eks_resource_scaling_configs: Configuration for EKS resource scaling. See EKS Resource Scaling Config below.
        :param Sequence['PlanWorkflowStepParallelConfigStepExecutionApprovalConfigArgs'] execution_approval_configs: Configuration for manual approval steps. See Execution Approval Config below.
        :param Sequence['PlanWorkflowStepParallelConfigStepGlobalAuroraConfigArgs'] global_aurora_configs: Configuration for Aurora Global Database operations. See Global Aurora Config below.
        :param Sequence['PlanWorkflowStepParallelConfigStepRoute53HealthCheckConfigArgs'] route53_health_check_configs: Configuration for Route53 health check operations. See Route53 Health Check Config below.
        """
        pulumi.set(__self__, "execution_block_type", execution_block_type)
        pulumi.set(__self__, "name", name)
        if arc_routing_control_configs is not None:
            pulumi.set(__self__, "arc_routing_control_configs", arc_routing_control_configs)
        if custom_action_lambda_configs is not None:
            pulumi.set(__self__, "custom_action_lambda_configs", custom_action_lambda_configs)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if document_db_configs is not None:
            pulumi.set(__self__, "document_db_configs", document_db_configs)
        if ec2_asg_capacity_increase_configs is not None:
            pulumi.set(__self__, "ec2_asg_capacity_increase_configs", ec2_asg_capacity_increase_configs)
        if ecs_capacity_increase_configs is not None:
            pulumi.set(__self__, "ecs_capacity_increase_configs", ecs_capacity_increase_configs)
        if eks_resource_scaling_configs is not None:
            pulumi.set(__self__, "eks_resource_scaling_configs", eks_resource_scaling_configs)
        if execution_approval_configs is not None:
            pulumi.set(__self__, "execution_approval_configs", execution_approval_configs)
        if global_aurora_configs is not None:
            pulumi.set(__self__, "global_aurora_configs", global_aurora_configs)
        if region_switch_plan_configs is not None:
            pulumi.set(__self__, "region_switch_plan_configs", region_switch_plan_configs)
        if route53_health_check_configs is not None:
            pulumi.set(__self__, "route53_health_check_configs", route53_health_check_configs)

    @_builtins.property
    @pulumi.getter(name="executionBlockType")
    def execution_block_type(self) -> _builtins.str:
        """
        Type of execution block. Valid values: `ARCRegionSwitchPlan`, `ARCRoutingControl`, `AuroraGlobalDatabase`, `CustomActionLambda`, `DocumentDb`, `EC2AutoScaling`, `ECSServiceScaling`, `EKSResourceScaling`, `ManualApproval`, `Parallel`, `Route53HealthCheck`.
        """
        return pulumi.get(self, "execution_block_type")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the step.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="arcRoutingControlConfigs")
    def arc_routing_control_configs(self) -> Optional[Sequence['outputs.PlanWorkflowStepParallelConfigStepArcRoutingControlConfig']]:
        """
        Configuration for ARC routing control. See ARC Routing Control Config below.
        """
        return pulumi.get(self, "arc_routing_control_configs")

    @_builtins.property
    @pulumi.getter(name="customActionLambdaConfigs")
    def custom_action_lambda_configs(self) -> Optional[Sequence['outputs.PlanWorkflowStepParallelConfigStepCustomActionLambdaConfig']]:
        """
        Configuration for Lambda function execution. See Custom Action Lambda Config below.
        """
        return pulumi.get(self, "custom_action_lambda_configs")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of the step.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="documentDbConfigs")
    def document_db_configs(self) -> Optional[Sequence['outputs.PlanWorkflowStepParallelConfigStepDocumentDbConfig']]:
        """
        Configuration for DocumentDB global cluster operations. See DocumentDB Config below.
        """
        return pulumi.get(self, "document_db_configs")

    @_builtins.property
    @pulumi.getter(name="ec2AsgCapacityIncreaseConfigs")
    def ec2_asg_capacity_increase_configs(self) -> Optional[Sequence['outputs.PlanWorkflowStepParallelConfigStepEc2AsgCapacityIncreaseConfig']]:
        """
        Configuration for EC2 Auto Scaling group capacity increase. See EC2 ASG Capacity Increase Config below.
        """
        return pulumi.get(self, "ec2_asg_capacity_increase_configs")

    @_builtins.property
    @pulumi.getter(name="ecsCapacityIncreaseConfigs")
    def ecs_capacity_increase_configs(self) -> Optional[Sequence['outputs.PlanWorkflowStepParallelConfigStepEcsCapacityIncreaseConfig']]:
        """
        Configuration for ECS service capacity increase. See ECS Capacity Increase Config below.
        """
        return pulumi.get(self, "ecs_capacity_increase_configs")

    @_builtins.property
    @pulumi.getter(name="eksResourceScalingConfigs")
    def eks_resource_scaling_configs(self) -> Optional[Sequence['outputs.PlanWorkflowStepParallelConfigStepEksResourceScalingConfig']]:
        """
        Configuration for EKS resource scaling. See EKS Resource Scaling Config below.
        """
        return pulumi.get(self, "eks_resource_scaling_configs")

    @_builtins.property
    @pulumi.getter(name="executionApprovalConfigs")
    def execution_approval_configs(self) -> Optional[Sequence['outputs.PlanWorkflowStepParallelConfigStepExecutionApprovalConfig']]:
        """
        Configuration for manual approval steps. See Execution Approval Config below.
        """
        return pulumi.get(self, "execution_approval_configs")

    @_builtins.property
    @pulumi.getter(name="globalAuroraConfigs")
    def global_aurora_configs(self) -> Optional[Sequence['outputs.PlanWorkflowStepParallelConfigStepGlobalAuroraConfig']]:
        """
        Configuration for Aurora Global Database operations. See Global Aurora Config below.
        """
        return pulumi.get(self, "global_aurora_configs")

    @_builtins.property
    @pulumi.getter(name="regionSwitchPlanConfigs")
    def region_switch_plan_configs(self) -> Optional[Sequence['outputs.PlanWorkflowStepParallelConfigStepRegionSwitchPlanConfig']]:
        return pulumi.get(self, "region_switch_plan_configs")

    @_builtins.property
    @pulumi.getter(name="route53HealthCheckConfigs")
    def route53_health_check_configs(self) -> Optional[Sequence['outputs.PlanWorkflowStepParallelConfigStepRoute53HealthCheckConfig']]:
        """
        Configuration for Route53 health check operations. See Route53 Health Check Config below.
        """
        return pulumi.get(self, "route53_health_check_configs")


@pulumi.output_type
class PlanWorkflowStepParallelConfigStepArcRoutingControlConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "crossAccountRole":
            suggest = "cross_account_role"
        elif key == "externalId":
            suggest = "external_id"
        elif key == "regionAndRoutingControls":
            suggest = "region_and_routing_controls"
        elif key == "timeoutMinutes":
            suggest = "timeout_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanWorkflowStepParallelConfigStepArcRoutingControlConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanWorkflowStepParallelConfigStepArcRoutingControlConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanWorkflowStepParallelConfigStepArcRoutingControlConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cross_account_role: Optional[_builtins.str] = None,
                 external_id: Optional[_builtins.str] = None,
                 region_and_routing_controls: Optional[Sequence['outputs.PlanWorkflowStepParallelConfigStepArcRoutingControlConfigRegionAndRoutingControl']] = None,
                 timeout_minutes: Optional[_builtins.int] = None):
        """
        :param _builtins.str cross_account_role: ARN of the cross-account role to assume.
        :param _builtins.str external_id: External ID for cross-account role assumption.
        :param Sequence['PlanWorkflowStepParallelConfigStepArcRoutingControlConfigRegionAndRoutingControlArgs'] region_and_routing_controls: List of regions and their routing controls. See Region and Routing Controls below.
        :param _builtins.int timeout_minutes: Timeout in minutes.
        """
        if cross_account_role is not None:
            pulumi.set(__self__, "cross_account_role", cross_account_role)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if region_and_routing_controls is not None:
            pulumi.set(__self__, "region_and_routing_controls", region_and_routing_controls)
        if timeout_minutes is not None:
            pulumi.set(__self__, "timeout_minutes", timeout_minutes)

    @_builtins.property
    @pulumi.getter(name="crossAccountRole")
    def cross_account_role(self) -> Optional[_builtins.str]:
        """
        ARN of the cross-account role to assume.
        """
        return pulumi.get(self, "cross_account_role")

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[_builtins.str]:
        """
        External ID for cross-account role assumption.
        """
        return pulumi.get(self, "external_id")

    @_builtins.property
    @pulumi.getter(name="regionAndRoutingControls")
    def region_and_routing_controls(self) -> Optional[Sequence['outputs.PlanWorkflowStepParallelConfigStepArcRoutingControlConfigRegionAndRoutingControl']]:
        """
        List of regions and their routing controls. See Region and Routing Controls below.
        """
        return pulumi.get(self, "region_and_routing_controls")

    @_builtins.property
    @pulumi.getter(name="timeoutMinutes")
    def timeout_minutes(self) -> Optional[_builtins.int]:
        """
        Timeout in minutes.
        """
        return pulumi.get(self, "timeout_minutes")


@pulumi.output_type
class PlanWorkflowStepParallelConfigStepArcRoutingControlConfigRegionAndRoutingControl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "routingControls":
            suggest = "routing_controls"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanWorkflowStepParallelConfigStepArcRoutingControlConfigRegionAndRoutingControl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanWorkflowStepParallelConfigStepArcRoutingControlConfigRegionAndRoutingControl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanWorkflowStepParallelConfigStepArcRoutingControlConfigRegionAndRoutingControl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 region: _builtins.str,
                 routing_controls: Optional[Sequence['outputs.PlanWorkflowStepParallelConfigStepArcRoutingControlConfigRegionAndRoutingControlRoutingControl']] = None):
        """
        :param _builtins.str region: AWS region.
        :param Sequence['PlanWorkflowStepParallelConfigStepArcRoutingControlConfigRegionAndRoutingControlRoutingControlArgs'] routing_controls: List of routing controls. See Routing Control below.
        """
        pulumi.set(__self__, "region", region)
        if routing_controls is not None:
            pulumi.set(__self__, "routing_controls", routing_controls)

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        AWS region.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="routingControls")
    def routing_controls(self) -> Optional[Sequence['outputs.PlanWorkflowStepParallelConfigStepArcRoutingControlConfigRegionAndRoutingControlRoutingControl']]:
        """
        List of routing controls. See Routing Control below.
        """
        return pulumi.get(self, "routing_controls")


@pulumi.output_type
class PlanWorkflowStepParallelConfigStepArcRoutingControlConfigRegionAndRoutingControlRoutingControl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "routingControlArn":
            suggest = "routing_control_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanWorkflowStepParallelConfigStepArcRoutingControlConfigRegionAndRoutingControlRoutingControl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanWorkflowStepParallelConfigStepArcRoutingControlConfigRegionAndRoutingControlRoutingControl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanWorkflowStepParallelConfigStepArcRoutingControlConfigRegionAndRoutingControlRoutingControl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 routing_control_arn: _builtins.str,
                 state: _builtins.str):
        """
        :param _builtins.str routing_control_arn: ARN of the routing control.
        :param _builtins.str state: State of the routing control. Valid values: `On`, `Off`.
        """
        pulumi.set(__self__, "routing_control_arn", routing_control_arn)
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="routingControlArn")
    def routing_control_arn(self) -> _builtins.str:
        """
        ARN of the routing control.
        """
        return pulumi.get(self, "routing_control_arn")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        State of the routing control. Valid values: `On`, `Off`.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class PlanWorkflowStepParallelConfigStepCustomActionLambdaConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "regionToRun":
            suggest = "region_to_run"
        elif key == "retryIntervalMinutes":
            suggest = "retry_interval_minutes"
        elif key == "timeoutMinutes":
            suggest = "timeout_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanWorkflowStepParallelConfigStepCustomActionLambdaConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanWorkflowStepParallelConfigStepCustomActionLambdaConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanWorkflowStepParallelConfigStepCustomActionLambdaConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 region_to_run: _builtins.str,
                 retry_interval_minutes: _builtins.float,
                 lambdas: Optional[Sequence['outputs.PlanWorkflowStepParallelConfigStepCustomActionLambdaConfigLambda']] = None,
                 timeout_minutes: Optional[_builtins.int] = None,
                 ungracefuls: Optional[Sequence['outputs.PlanWorkflowStepParallelConfigStepCustomActionLambdaConfigUngraceful']] = None):
        """
        :param _builtins.str region_to_run: Region where the Lambda function should run. Valid values: `activatingRegion`, `deactivatingRegion`.
        :param _builtins.float retry_interval_minutes: Retry interval in minutes.
        :param Sequence['PlanWorkflowStepParallelConfigStepCustomActionLambdaConfigLambdaArgs'] lambdas: Lambda function configuration. See Lambda below.
        :param _builtins.int timeout_minutes: Timeout in minutes.
        :param Sequence['PlanWorkflowStepParallelConfigStepCustomActionLambdaConfigUngracefulArgs'] ungracefuls: Ungraceful behavior configuration. See Ungraceful below.
        """
        pulumi.set(__self__, "region_to_run", region_to_run)
        pulumi.set(__self__, "retry_interval_minutes", retry_interval_minutes)
        if lambdas is not None:
            pulumi.set(__self__, "lambdas", lambdas)
        if timeout_minutes is not None:
            pulumi.set(__self__, "timeout_minutes", timeout_minutes)
        if ungracefuls is not None:
            pulumi.set(__self__, "ungracefuls", ungracefuls)

    @_builtins.property
    @pulumi.getter(name="regionToRun")
    def region_to_run(self) -> _builtins.str:
        """
        Region where the Lambda function should run. Valid values: `activatingRegion`, `deactivatingRegion`.
        """
        return pulumi.get(self, "region_to_run")

    @_builtins.property
    @pulumi.getter(name="retryIntervalMinutes")
    def retry_interval_minutes(self) -> _builtins.float:
        """
        Retry interval in minutes.
        """
        return pulumi.get(self, "retry_interval_minutes")

    @_builtins.property
    @pulumi.getter
    def lambdas(self) -> Optional[Sequence['outputs.PlanWorkflowStepParallelConfigStepCustomActionLambdaConfigLambda']]:
        """
        Lambda function configuration. See Lambda below.
        """
        return pulumi.get(self, "lambdas")

    @_builtins.property
    @pulumi.getter(name="timeoutMinutes")
    def timeout_minutes(self) -> Optional[_builtins.int]:
        """
        Timeout in minutes.
        """
        return pulumi.get(self, "timeout_minutes")

    @_builtins.property
    @pulumi.getter
    def ungracefuls(self) -> Optional[Sequence['outputs.PlanWorkflowStepParallelConfigStepCustomActionLambdaConfigUngraceful']]:
        """
        Ungraceful behavior configuration. See Ungraceful below.
        """
        return pulumi.get(self, "ungracefuls")


@pulumi.output_type
class PlanWorkflowStepParallelConfigStepCustomActionLambdaConfigLambda(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "crossAccountRole":
            suggest = "cross_account_role"
        elif key == "externalId":
            suggest = "external_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanWorkflowStepParallelConfigStepCustomActionLambdaConfigLambda. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanWorkflowStepParallelConfigStepCustomActionLambdaConfigLambda.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanWorkflowStepParallelConfigStepCustomActionLambdaConfigLambda.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: _builtins.str,
                 cross_account_role: Optional[_builtins.str] = None,
                 external_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str arn: ARN of the Lambda function.
        :param _builtins.str cross_account_role: ARN of the cross-account role to assume.
        :param _builtins.str external_id: External ID for cross-account role assumption.
        """
        pulumi.set(__self__, "arn", arn)
        if cross_account_role is not None:
            pulumi.set(__self__, "cross_account_role", cross_account_role)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        """
        ARN of the Lambda function.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter(name="crossAccountRole")
    def cross_account_role(self) -> Optional[_builtins.str]:
        """
        ARN of the cross-account role to assume.
        """
        return pulumi.get(self, "cross_account_role")

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[_builtins.str]:
        """
        External ID for cross-account role assumption.
        """
        return pulumi.get(self, "external_id")


@pulumi.output_type
class PlanWorkflowStepParallelConfigStepCustomActionLambdaConfigUngraceful(dict):
    def __init__(__self__, *,
                 behavior: _builtins.str):
        """
        :param _builtins.str behavior: Behavior when ungraceful. Valid values: `skip`.
        """
        pulumi.set(__self__, "behavior", behavior)

    @_builtins.property
    @pulumi.getter
    def behavior(self) -> _builtins.str:
        """
        Behavior when ungraceful. Valid values: `skip`.
        """
        return pulumi.get(self, "behavior")


@pulumi.output_type
class PlanWorkflowStepParallelConfigStepDocumentDbConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseClusterArns":
            suggest = "database_cluster_arns"
        elif key == "globalClusterIdentifier":
            suggest = "global_cluster_identifier"
        elif key == "crossAccountRole":
            suggest = "cross_account_role"
        elif key == "externalId":
            suggest = "external_id"
        elif key == "timeoutMinutes":
            suggest = "timeout_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanWorkflowStepParallelConfigStepDocumentDbConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanWorkflowStepParallelConfigStepDocumentDbConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanWorkflowStepParallelConfigStepDocumentDbConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 behavior: _builtins.str,
                 database_cluster_arns: Sequence[_builtins.str],
                 global_cluster_identifier: _builtins.str,
                 cross_account_role: Optional[_builtins.str] = None,
                 external_id: Optional[_builtins.str] = None,
                 timeout_minutes: Optional[_builtins.int] = None,
                 ungracefuls: Optional[Sequence['outputs.PlanWorkflowStepParallelConfigStepDocumentDbConfigUngraceful']] = None):
        pulumi.set(__self__, "behavior", behavior)
        pulumi.set(__self__, "database_cluster_arns", database_cluster_arns)
        pulumi.set(__self__, "global_cluster_identifier", global_cluster_identifier)
        if cross_account_role is not None:
            pulumi.set(__self__, "cross_account_role", cross_account_role)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if timeout_minutes is not None:
            pulumi.set(__self__, "timeout_minutes", timeout_minutes)
        if ungracefuls is not None:
            pulumi.set(__self__, "ungracefuls", ungracefuls)

    @_builtins.property
    @pulumi.getter
    def behavior(self) -> _builtins.str:
        return pulumi.get(self, "behavior")

    @_builtins.property
    @pulumi.getter(name="databaseClusterArns")
    def database_cluster_arns(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "database_cluster_arns")

    @_builtins.property
    @pulumi.getter(name="globalClusterIdentifier")
    def global_cluster_identifier(self) -> _builtins.str:
        return pulumi.get(self, "global_cluster_identifier")

    @_builtins.property
    @pulumi.getter(name="crossAccountRole")
    def cross_account_role(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cross_account_role")

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "external_id")

    @_builtins.property
    @pulumi.getter(name="timeoutMinutes")
    def timeout_minutes(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "timeout_minutes")

    @_builtins.property
    @pulumi.getter
    def ungracefuls(self) -> Optional[Sequence['outputs.PlanWorkflowStepParallelConfigStepDocumentDbConfigUngraceful']]:
        return pulumi.get(self, "ungracefuls")


@pulumi.output_type
class PlanWorkflowStepParallelConfigStepDocumentDbConfigUngraceful(dict):
    def __init__(__self__, *,
                 ungraceful: _builtins.str):
        pulumi.set(__self__, "ungraceful", ungraceful)

    @_builtins.property
    @pulumi.getter
    def ungraceful(self) -> _builtins.str:
        return pulumi.get(self, "ungraceful")


@pulumi.output_type
class PlanWorkflowStepParallelConfigStepEc2AsgCapacityIncreaseConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capacityMonitoringApproach":
            suggest = "capacity_monitoring_approach"
        elif key == "targetPercent":
            suggest = "target_percent"
        elif key == "timeoutMinutes":
            suggest = "timeout_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanWorkflowStepParallelConfigStepEc2AsgCapacityIncreaseConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanWorkflowStepParallelConfigStepEc2AsgCapacityIncreaseConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanWorkflowStepParallelConfigStepEc2AsgCapacityIncreaseConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capacity_monitoring_approach: _builtins.str,
                 asgs: Optional[Sequence['outputs.PlanWorkflowStepParallelConfigStepEc2AsgCapacityIncreaseConfigAsg']] = None,
                 target_percent: Optional[_builtins.int] = None,
                 timeout_minutes: Optional[_builtins.int] = None,
                 ungraceful: Optional['outputs.PlanWorkflowStepParallelConfigStepEc2AsgCapacityIncreaseConfigUngraceful'] = None):
        """
        :param _builtins.str capacity_monitoring_approach: Capacity monitoring approach. Valid values: `sampledMaxInLast24Hours`, `autoscalingMaxInLast24Hours`.
        :param Sequence['PlanWorkflowStepParallelConfigStepEc2AsgCapacityIncreaseConfigAsgArgs'] asgs: Auto Scaling group configuration. See ASG below.
        :param _builtins.int target_percent: Target capacity percentage.
        :param _builtins.int timeout_minutes: Timeout in minutes.
        :param 'PlanWorkflowStepParallelConfigStepEc2AsgCapacityIncreaseConfigUngracefulArgs' ungraceful: Ungraceful behavior configuration. See Ungraceful below.
        """
        pulumi.set(__self__, "capacity_monitoring_approach", capacity_monitoring_approach)
        if asgs is not None:
            pulumi.set(__self__, "asgs", asgs)
        if target_percent is not None:
            pulumi.set(__self__, "target_percent", target_percent)
        if timeout_minutes is not None:
            pulumi.set(__self__, "timeout_minutes", timeout_minutes)
        if ungraceful is not None:
            pulumi.set(__self__, "ungraceful", ungraceful)

    @_builtins.property
    @pulumi.getter(name="capacityMonitoringApproach")
    def capacity_monitoring_approach(self) -> _builtins.str:
        """
        Capacity monitoring approach. Valid values: `sampledMaxInLast24Hours`, `autoscalingMaxInLast24Hours`.
        """
        return pulumi.get(self, "capacity_monitoring_approach")

    @_builtins.property
    @pulumi.getter
    def asgs(self) -> Optional[Sequence['outputs.PlanWorkflowStepParallelConfigStepEc2AsgCapacityIncreaseConfigAsg']]:
        """
        Auto Scaling group configuration. See ASG below.
        """
        return pulumi.get(self, "asgs")

    @_builtins.property
    @pulumi.getter(name="targetPercent")
    def target_percent(self) -> Optional[_builtins.int]:
        """
        Target capacity percentage.
        """
        return pulumi.get(self, "target_percent")

    @_builtins.property
    @pulumi.getter(name="timeoutMinutes")
    def timeout_minutes(self) -> Optional[_builtins.int]:
        """
        Timeout in minutes.
        """
        return pulumi.get(self, "timeout_minutes")

    @_builtins.property
    @pulumi.getter
    def ungraceful(self) -> Optional['outputs.PlanWorkflowStepParallelConfigStepEc2AsgCapacityIncreaseConfigUngraceful']:
        """
        Ungraceful behavior configuration. See Ungraceful below.
        """
        return pulumi.get(self, "ungraceful")


@pulumi.output_type
class PlanWorkflowStepParallelConfigStepEc2AsgCapacityIncreaseConfigAsg(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "crossAccountRole":
            suggest = "cross_account_role"
        elif key == "externalId":
            suggest = "external_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanWorkflowStepParallelConfigStepEc2AsgCapacityIncreaseConfigAsg. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanWorkflowStepParallelConfigStepEc2AsgCapacityIncreaseConfigAsg.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanWorkflowStepParallelConfigStepEc2AsgCapacityIncreaseConfigAsg.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: _builtins.str,
                 cross_account_role: Optional[_builtins.str] = None,
                 external_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str arn: ARN of the Auto Scaling group.
        :param _builtins.str cross_account_role: ARN of the cross-account role to assume.
        :param _builtins.str external_id: External ID for cross-account role assumption.
        """
        pulumi.set(__self__, "arn", arn)
        if cross_account_role is not None:
            pulumi.set(__self__, "cross_account_role", cross_account_role)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        """
        ARN of the Auto Scaling group.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter(name="crossAccountRole")
    def cross_account_role(self) -> Optional[_builtins.str]:
        """
        ARN of the cross-account role to assume.
        """
        return pulumi.get(self, "cross_account_role")

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[_builtins.str]:
        """
        External ID for cross-account role assumption.
        """
        return pulumi.get(self, "external_id")


@pulumi.output_type
class PlanWorkflowStepParallelConfigStepEc2AsgCapacityIncreaseConfigUngraceful(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minimumSuccessPercentage":
            suggest = "minimum_success_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanWorkflowStepParallelConfigStepEc2AsgCapacityIncreaseConfigUngraceful. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanWorkflowStepParallelConfigStepEc2AsgCapacityIncreaseConfigUngraceful.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanWorkflowStepParallelConfigStepEc2AsgCapacityIncreaseConfigUngraceful.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 minimum_success_percentage: _builtins.int):
        """
        :param _builtins.int minimum_success_percentage: Minimum success percentage required.
        """
        pulumi.set(__self__, "minimum_success_percentage", minimum_success_percentage)

    @_builtins.property
    @pulumi.getter(name="minimumSuccessPercentage")
    def minimum_success_percentage(self) -> _builtins.int:
        """
        Minimum success percentage required.
        """
        return pulumi.get(self, "minimum_success_percentage")


@pulumi.output_type
class PlanWorkflowStepParallelConfigStepEcsCapacityIncreaseConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capacityMonitoringApproach":
            suggest = "capacity_monitoring_approach"
        elif key == "targetPercent":
            suggest = "target_percent"
        elif key == "timeoutMinutes":
            suggest = "timeout_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanWorkflowStepParallelConfigStepEcsCapacityIncreaseConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanWorkflowStepParallelConfigStepEcsCapacityIncreaseConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanWorkflowStepParallelConfigStepEcsCapacityIncreaseConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capacity_monitoring_approach: _builtins.str,
                 services: Optional[Sequence['outputs.PlanWorkflowStepParallelConfigStepEcsCapacityIncreaseConfigService']] = None,
                 target_percent: Optional[_builtins.int] = None,
                 timeout_minutes: Optional[_builtins.int] = None,
                 ungraceful: Optional['outputs.PlanWorkflowStepParallelConfigStepEcsCapacityIncreaseConfigUngraceful'] = None):
        """
        :param _builtins.str capacity_monitoring_approach: Capacity monitoring approach. Valid values: `sampledMaxInLast24Hours`, `containerInsightsMaxInLast24Hours`.
        :param Sequence['PlanWorkflowStepParallelConfigStepEcsCapacityIncreaseConfigServiceArgs'] services: ECS service configuration. See ECS Service below.
        :param _builtins.int target_percent: Target capacity percentage.
        :param _builtins.int timeout_minutes: Timeout in minutes.
        :param 'PlanWorkflowStepParallelConfigStepEcsCapacityIncreaseConfigUngracefulArgs' ungraceful: Ungraceful behavior configuration. See Ungraceful Capacity below.
        """
        pulumi.set(__self__, "capacity_monitoring_approach", capacity_monitoring_approach)
        if services is not None:
            pulumi.set(__self__, "services", services)
        if target_percent is not None:
            pulumi.set(__self__, "target_percent", target_percent)
        if timeout_minutes is not None:
            pulumi.set(__self__, "timeout_minutes", timeout_minutes)
        if ungraceful is not None:
            pulumi.set(__self__, "ungraceful", ungraceful)

    @_builtins.property
    @pulumi.getter(name="capacityMonitoringApproach")
    def capacity_monitoring_approach(self) -> _builtins.str:
        """
        Capacity monitoring approach. Valid values: `sampledMaxInLast24Hours`, `containerInsightsMaxInLast24Hours`.
        """
        return pulumi.get(self, "capacity_monitoring_approach")

    @_builtins.property
    @pulumi.getter
    def services(self) -> Optional[Sequence['outputs.PlanWorkflowStepParallelConfigStepEcsCapacityIncreaseConfigService']]:
        """
        ECS service configuration. See ECS Service below.
        """
        return pulumi.get(self, "services")

    @_builtins.property
    @pulumi.getter(name="targetPercent")
    def target_percent(self) -> Optional[_builtins.int]:
        """
        Target capacity percentage.
        """
        return pulumi.get(self, "target_percent")

    @_builtins.property
    @pulumi.getter(name="timeoutMinutes")
    def timeout_minutes(self) -> Optional[_builtins.int]:
        """
        Timeout in minutes.
        """
        return pulumi.get(self, "timeout_minutes")

    @_builtins.property
    @pulumi.getter
    def ungraceful(self) -> Optional['outputs.PlanWorkflowStepParallelConfigStepEcsCapacityIncreaseConfigUngraceful']:
        """
        Ungraceful behavior configuration. See Ungraceful Capacity below.
        """
        return pulumi.get(self, "ungraceful")


@pulumi.output_type
class PlanWorkflowStepParallelConfigStepEcsCapacityIncreaseConfigService(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterArn":
            suggest = "cluster_arn"
        elif key == "serviceArn":
            suggest = "service_arn"
        elif key == "crossAccountRole":
            suggest = "cross_account_role"
        elif key == "externalId":
            suggest = "external_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanWorkflowStepParallelConfigStepEcsCapacityIncreaseConfigService. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanWorkflowStepParallelConfigStepEcsCapacityIncreaseConfigService.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanWorkflowStepParallelConfigStepEcsCapacityIncreaseConfigService.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_arn: _builtins.str,
                 service_arn: _builtins.str,
                 cross_account_role: Optional[_builtins.str] = None,
                 external_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str service_arn: ARN of the ECS service.
        """
        pulumi.set(__self__, "cluster_arn", cluster_arn)
        pulumi.set(__self__, "service_arn", service_arn)
        if cross_account_role is not None:
            pulumi.set(__self__, "cross_account_role", cross_account_role)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)

    @_builtins.property
    @pulumi.getter(name="clusterArn")
    def cluster_arn(self) -> _builtins.str:
        return pulumi.get(self, "cluster_arn")

    @_builtins.property
    @pulumi.getter(name="serviceArn")
    def service_arn(self) -> _builtins.str:
        """
        ARN of the ECS service.
        """
        return pulumi.get(self, "service_arn")

    @_builtins.property
    @pulumi.getter(name="crossAccountRole")
    def cross_account_role(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cross_account_role")

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "external_id")


@pulumi.output_type
class PlanWorkflowStepParallelConfigStepEcsCapacityIncreaseConfigUngraceful(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minimumSuccessPercentage":
            suggest = "minimum_success_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanWorkflowStepParallelConfigStepEcsCapacityIncreaseConfigUngraceful. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanWorkflowStepParallelConfigStepEcsCapacityIncreaseConfigUngraceful.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanWorkflowStepParallelConfigStepEcsCapacityIncreaseConfigUngraceful.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 minimum_success_percentage: _builtins.int):
        """
        :param _builtins.int minimum_success_percentage: Minimum success percentage required.
        """
        pulumi.set(__self__, "minimum_success_percentage", minimum_success_percentage)

    @_builtins.property
    @pulumi.getter(name="minimumSuccessPercentage")
    def minimum_success_percentage(self) -> _builtins.int:
        """
        Minimum success percentage required.
        """
        return pulumi.get(self, "minimum_success_percentage")


@pulumi.output_type
class PlanWorkflowStepParallelConfigStepEksResourceScalingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capacityMonitoringApproach":
            suggest = "capacity_monitoring_approach"
        elif key == "targetPercent":
            suggest = "target_percent"
        elif key == "eksClusters":
            suggest = "eks_clusters"
        elif key == "kubernetesResourceTypes":
            suggest = "kubernetes_resource_types"
        elif key == "scalingResources":
            suggest = "scaling_resources"
        elif key == "timeoutMinutes":
            suggest = "timeout_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanWorkflowStepParallelConfigStepEksResourceScalingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanWorkflowStepParallelConfigStepEksResourceScalingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanWorkflowStepParallelConfigStepEksResourceScalingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capacity_monitoring_approach: _builtins.str,
                 target_percent: _builtins.int,
                 eks_clusters: Optional[Sequence['outputs.PlanWorkflowStepParallelConfigStepEksResourceScalingConfigEksCluster']] = None,
                 kubernetes_resource_types: Optional[Sequence['outputs.PlanWorkflowStepParallelConfigStepEksResourceScalingConfigKubernetesResourceType']] = None,
                 scaling_resources: Optional[Sequence['outputs.PlanWorkflowStepParallelConfigStepEksResourceScalingConfigScalingResource']] = None,
                 timeout_minutes: Optional[_builtins.int] = None,
                 ungracefuls: Optional[Sequence['outputs.PlanWorkflowStepParallelConfigStepEksResourceScalingConfigUngraceful']] = None):
        """
        :param _builtins.str capacity_monitoring_approach: Capacity monitoring approach. Valid values: `sampledMaxInLast24Hours`, `autoscalingMaxInLast24Hours`.
        :param _builtins.int target_percent: Target capacity percentage.
        :param Sequence['PlanWorkflowStepParallelConfigStepEksResourceScalingConfigEksClusterArgs'] eks_clusters: List of EKS clusters. See EKS Clusters below.
        :param Sequence['PlanWorkflowStepParallelConfigStepEksResourceScalingConfigKubernetesResourceTypeArgs'] kubernetes_resource_types: Kubernetes resource type. See Kubernetes Resource Type below.
        :param Sequence['PlanWorkflowStepParallelConfigStepEksResourceScalingConfigScalingResourceArgs'] scaling_resources: List of scaling resources. See Scaling Resources below.
        :param _builtins.int timeout_minutes: Timeout in minutes.
        :param Sequence['PlanWorkflowStepParallelConfigStepEksResourceScalingConfigUngracefulArgs'] ungracefuls: Ungraceful behavior configuration. See Ungraceful Capacity below.
        """
        pulumi.set(__self__, "capacity_monitoring_approach", capacity_monitoring_approach)
        pulumi.set(__self__, "target_percent", target_percent)
        if eks_clusters is not None:
            pulumi.set(__self__, "eks_clusters", eks_clusters)
        if kubernetes_resource_types is not None:
            pulumi.set(__self__, "kubernetes_resource_types", kubernetes_resource_types)
        if scaling_resources is not None:
            pulumi.set(__self__, "scaling_resources", scaling_resources)
        if timeout_minutes is not None:
            pulumi.set(__self__, "timeout_minutes", timeout_minutes)
        if ungracefuls is not None:
            pulumi.set(__self__, "ungracefuls", ungracefuls)

    @_builtins.property
    @pulumi.getter(name="capacityMonitoringApproach")
    def capacity_monitoring_approach(self) -> _builtins.str:
        """
        Capacity monitoring approach. Valid values: `sampledMaxInLast24Hours`, `autoscalingMaxInLast24Hours`.
        """
        return pulumi.get(self, "capacity_monitoring_approach")

    @_builtins.property
    @pulumi.getter(name="targetPercent")
    def target_percent(self) -> _builtins.int:
        """
        Target capacity percentage.
        """
        return pulumi.get(self, "target_percent")

    @_builtins.property
    @pulumi.getter(name="eksClusters")
    def eks_clusters(self) -> Optional[Sequence['outputs.PlanWorkflowStepParallelConfigStepEksResourceScalingConfigEksCluster']]:
        """
        List of EKS clusters. See EKS Clusters below.
        """
        return pulumi.get(self, "eks_clusters")

    @_builtins.property
    @pulumi.getter(name="kubernetesResourceTypes")
    def kubernetes_resource_types(self) -> Optional[Sequence['outputs.PlanWorkflowStepParallelConfigStepEksResourceScalingConfigKubernetesResourceType']]:
        """
        Kubernetes resource type. See Kubernetes Resource Type below.
        """
        return pulumi.get(self, "kubernetes_resource_types")

    @_builtins.property
    @pulumi.getter(name="scalingResources")
    def scaling_resources(self) -> Optional[Sequence['outputs.PlanWorkflowStepParallelConfigStepEksResourceScalingConfigScalingResource']]:
        """
        List of scaling resources. See Scaling Resources below.
        """
        return pulumi.get(self, "scaling_resources")

    @_builtins.property
    @pulumi.getter(name="timeoutMinutes")
    def timeout_minutes(self) -> Optional[_builtins.int]:
        """
        Timeout in minutes.
        """
        return pulumi.get(self, "timeout_minutes")

    @_builtins.property
    @pulumi.getter
    def ungracefuls(self) -> Optional[Sequence['outputs.PlanWorkflowStepParallelConfigStepEksResourceScalingConfigUngraceful']]:
        """
        Ungraceful behavior configuration. See Ungraceful Capacity below.
        """
        return pulumi.get(self, "ungracefuls")


@pulumi.output_type
class PlanWorkflowStepParallelConfigStepEksResourceScalingConfigEksCluster(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterArn":
            suggest = "cluster_arn"
        elif key == "crossAccountRole":
            suggest = "cross_account_role"
        elif key == "externalId":
            suggest = "external_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanWorkflowStepParallelConfigStepEksResourceScalingConfigEksCluster. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanWorkflowStepParallelConfigStepEksResourceScalingConfigEksCluster.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanWorkflowStepParallelConfigStepEksResourceScalingConfigEksCluster.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_arn: _builtins.str,
                 cross_account_role: Optional[_builtins.str] = None,
                 external_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str cluster_arn: ARN of the EKS cluster.
        :param _builtins.str cross_account_role: ARN of the cross-account role to assume.
        :param _builtins.str external_id: External ID for cross-account role assumption.
        """
        pulumi.set(__self__, "cluster_arn", cluster_arn)
        if cross_account_role is not None:
            pulumi.set(__self__, "cross_account_role", cross_account_role)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)

    @_builtins.property
    @pulumi.getter(name="clusterArn")
    def cluster_arn(self) -> _builtins.str:
        """
        ARN of the EKS cluster.
        """
        return pulumi.get(self, "cluster_arn")

    @_builtins.property
    @pulumi.getter(name="crossAccountRole")
    def cross_account_role(self) -> Optional[_builtins.str]:
        """
        ARN of the cross-account role to assume.
        """
        return pulumi.get(self, "cross_account_role")

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[_builtins.str]:
        """
        External ID for cross-account role assumption.
        """
        return pulumi.get(self, "external_id")


@pulumi.output_type
class PlanWorkflowStepParallelConfigStepEksResourceScalingConfigKubernetesResourceType(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiVersion":
            suggest = "api_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanWorkflowStepParallelConfigStepEksResourceScalingConfigKubernetesResourceType. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanWorkflowStepParallelConfigStepEksResourceScalingConfigKubernetesResourceType.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanWorkflowStepParallelConfigStepEksResourceScalingConfigKubernetesResourceType.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_version: _builtins.str,
                 kind: _builtins.str):
        """
        :param _builtins.str api_version: Kubernetes API version.
        :param _builtins.str kind: Kubernetes resource kind.
        """
        pulumi.set(__self__, "api_version", api_version)
        pulumi.set(__self__, "kind", kind)

    @_builtins.property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> _builtins.str:
        """
        Kubernetes API version.
        """
        return pulumi.get(self, "api_version")

    @_builtins.property
    @pulumi.getter
    def kind(self) -> _builtins.str:
        """
        Kubernetes resource kind.
        """
        return pulumi.get(self, "kind")


@pulumi.output_type
class PlanWorkflowStepParallelConfigStepEksResourceScalingConfigScalingResource(dict):
    def __init__(__self__, *,
                 namespace: _builtins.str,
                 resources: Optional[Sequence['outputs.PlanWorkflowStepParallelConfigStepEksResourceScalingConfigScalingResourceResource']] = None):
        """
        :param _builtins.str namespace: Kubernetes namespace.
        :param Sequence['PlanWorkflowStepParallelConfigStepEksResourceScalingConfigScalingResourceResourceArgs'] resources: Set of resources to scale. See Resources below.
        """
        pulumi.set(__self__, "namespace", namespace)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> _builtins.str:
        """
        Kubernetes namespace.
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Optional[Sequence['outputs.PlanWorkflowStepParallelConfigStepEksResourceScalingConfigScalingResourceResource']]:
        """
        Set of resources to scale. See Resources below.
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class PlanWorkflowStepParallelConfigStepEksResourceScalingConfigScalingResourceResource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceName":
            suggest = "resource_name"
        elif key == "hpaName":
            suggest = "hpa_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanWorkflowStepParallelConfigStepEksResourceScalingConfigScalingResourceResource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanWorkflowStepParallelConfigStepEksResourceScalingConfigScalingResourceResource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanWorkflowStepParallelConfigStepEksResourceScalingConfigScalingResourceResource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 namespace: _builtins.str,
                 resource_name: _builtins.str,
                 hpa_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name of the Kubernetes object.
        :param _builtins.str namespace: Kubernetes namespace.
        :param _builtins.str resource_name: Name of the resource.
        :param _builtins.str hpa_name: Name of the Horizontal Pod Autoscaler.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "resource_name", resource_name)
        if hpa_name is not None:
            pulumi.set(__self__, "hpa_name", hpa_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the Kubernetes object.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> _builtins.str:
        """
        Kubernetes namespace.
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> _builtins.str:
        """
        Name of the resource.
        """
        return pulumi.get(self, "resource_name")

    @_builtins.property
    @pulumi.getter(name="hpaName")
    def hpa_name(self) -> Optional[_builtins.str]:
        """
        Name of the Horizontal Pod Autoscaler.
        """
        return pulumi.get(self, "hpa_name")


@pulumi.output_type
class PlanWorkflowStepParallelConfigStepEksResourceScalingConfigUngraceful(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minimumSuccessPercentage":
            suggest = "minimum_success_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanWorkflowStepParallelConfigStepEksResourceScalingConfigUngraceful. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanWorkflowStepParallelConfigStepEksResourceScalingConfigUngraceful.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanWorkflowStepParallelConfigStepEksResourceScalingConfigUngraceful.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 minimum_success_percentage: _builtins.int):
        """
        :param _builtins.int minimum_success_percentage: Minimum success percentage required.
        """
        pulumi.set(__self__, "minimum_success_percentage", minimum_success_percentage)

    @_builtins.property
    @pulumi.getter(name="minimumSuccessPercentage")
    def minimum_success_percentage(self) -> _builtins.int:
        """
        Minimum success percentage required.
        """
        return pulumi.get(self, "minimum_success_percentage")


@pulumi.output_type
class PlanWorkflowStepParallelConfigStepExecutionApprovalConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "approvalRole":
            suggest = "approval_role"
        elif key == "timeoutMinutes":
            suggest = "timeout_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanWorkflowStepParallelConfigStepExecutionApprovalConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanWorkflowStepParallelConfigStepExecutionApprovalConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanWorkflowStepParallelConfigStepExecutionApprovalConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 approval_role: _builtins.str,
                 timeout_minutes: Optional[_builtins.int] = None):
        """
        :param _builtins.str approval_role: ARN of the IAM role for approval.
        :param _builtins.int timeout_minutes: Timeout in minutes for the approval.
        """
        pulumi.set(__self__, "approval_role", approval_role)
        if timeout_minutes is not None:
            pulumi.set(__self__, "timeout_minutes", timeout_minutes)

    @_builtins.property
    @pulumi.getter(name="approvalRole")
    def approval_role(self) -> _builtins.str:
        """
        ARN of the IAM role for approval.
        """
        return pulumi.get(self, "approval_role")

    @_builtins.property
    @pulumi.getter(name="timeoutMinutes")
    def timeout_minutes(self) -> Optional[_builtins.int]:
        """
        Timeout in minutes for the approval.
        """
        return pulumi.get(self, "timeout_minutes")


@pulumi.output_type
class PlanWorkflowStepParallelConfigStepGlobalAuroraConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseClusterArns":
            suggest = "database_cluster_arns"
        elif key == "globalClusterIdentifier":
            suggest = "global_cluster_identifier"
        elif key == "crossAccountRole":
            suggest = "cross_account_role"
        elif key == "externalId":
            suggest = "external_id"
        elif key == "timeoutMinutes":
            suggest = "timeout_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanWorkflowStepParallelConfigStepGlobalAuroraConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanWorkflowStepParallelConfigStepGlobalAuroraConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanWorkflowStepParallelConfigStepGlobalAuroraConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 behavior: _builtins.str,
                 database_cluster_arns: Sequence[_builtins.str],
                 global_cluster_identifier: _builtins.str,
                 cross_account_role: Optional[_builtins.str] = None,
                 external_id: Optional[_builtins.str] = None,
                 timeout_minutes: Optional[_builtins.int] = None,
                 ungracefuls: Optional[Sequence['outputs.PlanWorkflowStepParallelConfigStepGlobalAuroraConfigUngraceful']] = None):
        """
        :param _builtins.str behavior: Behavior for Aurora operations. Valid values: `switchoverOnly`, `failover`.
        :param Sequence[_builtins.str] database_cluster_arns: List of database cluster ARNs.
        :param _builtins.str global_cluster_identifier: Global cluster identifier.
        :param _builtins.str cross_account_role: ARN of the cross-account role to assume.
        :param _builtins.str external_id: External ID for cross-account role assumption.
        :param _builtins.int timeout_minutes: Timeout in minutes.
        :param Sequence['PlanWorkflowStepParallelConfigStepGlobalAuroraConfigUngracefulArgs'] ungracefuls: Ungraceful behavior configuration. See Ungraceful Aurora below.
        """
        pulumi.set(__self__, "behavior", behavior)
        pulumi.set(__self__, "database_cluster_arns", database_cluster_arns)
        pulumi.set(__self__, "global_cluster_identifier", global_cluster_identifier)
        if cross_account_role is not None:
            pulumi.set(__self__, "cross_account_role", cross_account_role)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if timeout_minutes is not None:
            pulumi.set(__self__, "timeout_minutes", timeout_minutes)
        if ungracefuls is not None:
            pulumi.set(__self__, "ungracefuls", ungracefuls)

    @_builtins.property
    @pulumi.getter
    def behavior(self) -> _builtins.str:
        """
        Behavior for Aurora operations. Valid values: `switchoverOnly`, `failover`.
        """
        return pulumi.get(self, "behavior")

    @_builtins.property
    @pulumi.getter(name="databaseClusterArns")
    def database_cluster_arns(self) -> Sequence[_builtins.str]:
        """
        List of database cluster ARNs.
        """
        return pulumi.get(self, "database_cluster_arns")

    @_builtins.property
    @pulumi.getter(name="globalClusterIdentifier")
    def global_cluster_identifier(self) -> _builtins.str:
        """
        Global cluster identifier.
        """
        return pulumi.get(self, "global_cluster_identifier")

    @_builtins.property
    @pulumi.getter(name="crossAccountRole")
    def cross_account_role(self) -> Optional[_builtins.str]:
        """
        ARN of the cross-account role to assume.
        """
        return pulumi.get(self, "cross_account_role")

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[_builtins.str]:
        """
        External ID for cross-account role assumption.
        """
        return pulumi.get(self, "external_id")

    @_builtins.property
    @pulumi.getter(name="timeoutMinutes")
    def timeout_minutes(self) -> Optional[_builtins.int]:
        """
        Timeout in minutes.
        """
        return pulumi.get(self, "timeout_minutes")

    @_builtins.property
    @pulumi.getter
    def ungracefuls(self) -> Optional[Sequence['outputs.PlanWorkflowStepParallelConfigStepGlobalAuroraConfigUngraceful']]:
        """
        Ungraceful behavior configuration. See Ungraceful Aurora below.
        """
        return pulumi.get(self, "ungracefuls")


@pulumi.output_type
class PlanWorkflowStepParallelConfigStepGlobalAuroraConfigUngraceful(dict):
    def __init__(__self__, *,
                 ungraceful: _builtins.str):
        pulumi.set(__self__, "ungraceful", ungraceful)

    @_builtins.property
    @pulumi.getter
    def ungraceful(self) -> _builtins.str:
        return pulumi.get(self, "ungraceful")


@pulumi.output_type
class PlanWorkflowStepParallelConfigStepRegionSwitchPlanConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "crossAccountRole":
            suggest = "cross_account_role"
        elif key == "externalId":
            suggest = "external_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanWorkflowStepParallelConfigStepRegionSwitchPlanConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanWorkflowStepParallelConfigStepRegionSwitchPlanConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanWorkflowStepParallelConfigStepRegionSwitchPlanConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: _builtins.str,
                 cross_account_role: Optional[_builtins.str] = None,
                 external_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str arn: ARN of the nested region switch plan.
        :param _builtins.str cross_account_role: ARN of the cross-account role to assume.
        :param _builtins.str external_id: External ID for cross-account role assumption.
        """
        pulumi.set(__self__, "arn", arn)
        if cross_account_role is not None:
            pulumi.set(__self__, "cross_account_role", cross_account_role)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        """
        ARN of the nested region switch plan.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter(name="crossAccountRole")
    def cross_account_role(self) -> Optional[_builtins.str]:
        """
        ARN of the cross-account role to assume.
        """
        return pulumi.get(self, "cross_account_role")

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[_builtins.str]:
        """
        External ID for cross-account role assumption.
        """
        return pulumi.get(self, "external_id")


@pulumi.output_type
class PlanWorkflowStepParallelConfigStepRoute53HealthCheckConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostedZoneId":
            suggest = "hosted_zone_id"
        elif key == "recordName":
            suggest = "record_name"
        elif key == "crossAccountRole":
            suggest = "cross_account_role"
        elif key == "externalId":
            suggest = "external_id"
        elif key == "recordSets":
            suggest = "record_sets"
        elif key == "timeoutMinutes":
            suggest = "timeout_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanWorkflowStepParallelConfigStepRoute53HealthCheckConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanWorkflowStepParallelConfigStepRoute53HealthCheckConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanWorkflowStepParallelConfigStepRoute53HealthCheckConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hosted_zone_id: _builtins.str,
                 record_name: _builtins.str,
                 cross_account_role: Optional[_builtins.str] = None,
                 external_id: Optional[_builtins.str] = None,
                 record_sets: Optional[Sequence['outputs.PlanWorkflowStepParallelConfigStepRoute53HealthCheckConfigRecordSet']] = None,
                 timeout_minutes: Optional[_builtins.int] = None):
        """
        :param _builtins.str hosted_zone_id: Route53 hosted zone ID.
        :param _builtins.str record_name: DNS record name.
        :param _builtins.str cross_account_role: ARN of the cross-account role to assume.
        :param _builtins.str external_id: External ID for cross-account role assumption.
        :param Sequence['PlanWorkflowStepParallelConfigStepRoute53HealthCheckConfigRecordSetArgs'] record_sets: Configuration block for record sets. See Record Set below.
        :param _builtins.int timeout_minutes: Timeout in minutes.
        """
        pulumi.set(__self__, "hosted_zone_id", hosted_zone_id)
        pulumi.set(__self__, "record_name", record_name)
        if cross_account_role is not None:
            pulumi.set(__self__, "cross_account_role", cross_account_role)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if record_sets is not None:
            pulumi.set(__self__, "record_sets", record_sets)
        if timeout_minutes is not None:
            pulumi.set(__self__, "timeout_minutes", timeout_minutes)

    @_builtins.property
    @pulumi.getter(name="hostedZoneId")
    def hosted_zone_id(self) -> _builtins.str:
        """
        Route53 hosted zone ID.
        """
        return pulumi.get(self, "hosted_zone_id")

    @_builtins.property
    @pulumi.getter(name="recordName")
    def record_name(self) -> _builtins.str:
        """
        DNS record name.
        """
        return pulumi.get(self, "record_name")

    @_builtins.property
    @pulumi.getter(name="crossAccountRole")
    def cross_account_role(self) -> Optional[_builtins.str]:
        """
        ARN of the cross-account role to assume.
        """
        return pulumi.get(self, "cross_account_role")

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[_builtins.str]:
        """
        External ID for cross-account role assumption.
        """
        return pulumi.get(self, "external_id")

    @_builtins.property
    @pulumi.getter(name="recordSets")
    def record_sets(self) -> Optional[Sequence['outputs.PlanWorkflowStepParallelConfigStepRoute53HealthCheckConfigRecordSet']]:
        """
        Configuration block for record sets. See Record Set below.
        """
        return pulumi.get(self, "record_sets")

    @_builtins.property
    @pulumi.getter(name="timeoutMinutes")
    def timeout_minutes(self) -> Optional[_builtins.int]:
        """
        Timeout in minutes.
        """
        return pulumi.get(self, "timeout_minutes")


@pulumi.output_type
class PlanWorkflowStepParallelConfigStepRoute53HealthCheckConfigRecordSet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "recordSetIdentifier":
            suggest = "record_set_identifier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanWorkflowStepParallelConfigStepRoute53HealthCheckConfigRecordSet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanWorkflowStepParallelConfigStepRoute53HealthCheckConfigRecordSet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanWorkflowStepParallelConfigStepRoute53HealthCheckConfigRecordSet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 record_set_identifier: _builtins.str,
                 region: _builtins.str):
        """
        :param _builtins.str record_set_identifier: Record set identifier.
        :param _builtins.str region: AWS region.
        """
        pulumi.set(__self__, "record_set_identifier", record_set_identifier)
        pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter(name="recordSetIdentifier")
    def record_set_identifier(self) -> _builtins.str:
        """
        Record set identifier.
        """
        return pulumi.get(self, "record_set_identifier")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        AWS region.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class PlanWorkflowStepRegionSwitchPlanConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "crossAccountRole":
            suggest = "cross_account_role"
        elif key == "externalId":
            suggest = "external_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanWorkflowStepRegionSwitchPlanConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanWorkflowStepRegionSwitchPlanConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanWorkflowStepRegionSwitchPlanConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: _builtins.str,
                 cross_account_role: Optional[_builtins.str] = None,
                 external_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str arn: ARN of the nested region switch plan.
        :param _builtins.str cross_account_role: ARN of the cross-account role to assume.
        :param _builtins.str external_id: External ID for cross-account role assumption.
        """
        pulumi.set(__self__, "arn", arn)
        if cross_account_role is not None:
            pulumi.set(__self__, "cross_account_role", cross_account_role)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        """
        ARN of the nested region switch plan.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter(name="crossAccountRole")
    def cross_account_role(self) -> Optional[_builtins.str]:
        """
        ARN of the cross-account role to assume.
        """
        return pulumi.get(self, "cross_account_role")

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[_builtins.str]:
        """
        External ID for cross-account role assumption.
        """
        return pulumi.get(self, "external_id")


@pulumi.output_type
class PlanWorkflowStepRoute53HealthCheckConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostedZoneId":
            suggest = "hosted_zone_id"
        elif key == "recordName":
            suggest = "record_name"
        elif key == "crossAccountRole":
            suggest = "cross_account_role"
        elif key == "externalId":
            suggest = "external_id"
        elif key == "recordSets":
            suggest = "record_sets"
        elif key == "timeoutMinutes":
            suggest = "timeout_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanWorkflowStepRoute53HealthCheckConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanWorkflowStepRoute53HealthCheckConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanWorkflowStepRoute53HealthCheckConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hosted_zone_id: _builtins.str,
                 record_name: _builtins.str,
                 cross_account_role: Optional[_builtins.str] = None,
                 external_id: Optional[_builtins.str] = None,
                 record_sets: Optional[Sequence['outputs.PlanWorkflowStepRoute53HealthCheckConfigRecordSet']] = None,
                 timeout_minutes: Optional[_builtins.int] = None):
        """
        :param _builtins.str hosted_zone_id: Route53 hosted zone ID.
        :param _builtins.str record_name: DNS record name.
        :param _builtins.str cross_account_role: ARN of the cross-account role to assume.
        :param _builtins.str external_id: External ID for cross-account role assumption.
        :param Sequence['PlanWorkflowStepRoute53HealthCheckConfigRecordSetArgs'] record_sets: Configuration block for record sets. See Record Set below.
        :param _builtins.int timeout_minutes: Timeout in minutes.
        """
        pulumi.set(__self__, "hosted_zone_id", hosted_zone_id)
        pulumi.set(__self__, "record_name", record_name)
        if cross_account_role is not None:
            pulumi.set(__self__, "cross_account_role", cross_account_role)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if record_sets is not None:
            pulumi.set(__self__, "record_sets", record_sets)
        if timeout_minutes is not None:
            pulumi.set(__self__, "timeout_minutes", timeout_minutes)

    @_builtins.property
    @pulumi.getter(name="hostedZoneId")
    def hosted_zone_id(self) -> _builtins.str:
        """
        Route53 hosted zone ID.
        """
        return pulumi.get(self, "hosted_zone_id")

    @_builtins.property
    @pulumi.getter(name="recordName")
    def record_name(self) -> _builtins.str:
        """
        DNS record name.
        """
        return pulumi.get(self, "record_name")

    @_builtins.property
    @pulumi.getter(name="crossAccountRole")
    def cross_account_role(self) -> Optional[_builtins.str]:
        """
        ARN of the cross-account role to assume.
        """
        return pulumi.get(self, "cross_account_role")

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[_builtins.str]:
        """
        External ID for cross-account role assumption.
        """
        return pulumi.get(self, "external_id")

    @_builtins.property
    @pulumi.getter(name="recordSets")
    def record_sets(self) -> Optional[Sequence['outputs.PlanWorkflowStepRoute53HealthCheckConfigRecordSet']]:
        """
        Configuration block for record sets. See Record Set below.
        """
        return pulumi.get(self, "record_sets")

    @_builtins.property
    @pulumi.getter(name="timeoutMinutes")
    def timeout_minutes(self) -> Optional[_builtins.int]:
        """
        Timeout in minutes.
        """
        return pulumi.get(self, "timeout_minutes")


@pulumi.output_type
class PlanWorkflowStepRoute53HealthCheckConfigRecordSet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "recordSetIdentifier":
            suggest = "record_set_identifier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanWorkflowStepRoute53HealthCheckConfigRecordSet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanWorkflowStepRoute53HealthCheckConfigRecordSet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanWorkflowStepRoute53HealthCheckConfigRecordSet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 record_set_identifier: _builtins.str,
                 region: _builtins.str):
        """
        :param _builtins.str record_set_identifier: Record set identifier.
        :param _builtins.str region: AWS region.
        """
        pulumi.set(__self__, "record_set_identifier", record_set_identifier)
        pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter(name="recordSetIdentifier")
    def record_set_identifier(self) -> _builtins.str:
        """
        Record set identifier.
        """
        return pulumi.get(self, "record_set_identifier")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        AWS region.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class GetRoute53HealthChecksHealthCheckResult(dict):
    def __init__(__self__, *,
                 health_check_id: _builtins.str,
                 hosted_zone_id: _builtins.str,
                 record_name: _builtins.str,
                 region: _builtins.str,
                 status: _builtins.str):
        """
        :param _builtins.str health_check_id: ID of the Route53 health check.
        :param _builtins.str hosted_zone_id: Hosted zone ID for the health check.
        :param _builtins.str record_name: Record name for the health check.
        :param _builtins.str region: Region where this resource will be [managed](https://docs.aws.amazon.com/general/latest/gr/rande.html#regional-endpoints). Defaults to the Region set in the provider configuration.
        :param _builtins.str status: Status of the health check. Valid values: `healthy`, `unhealthy`, `unknown`.
        """
        pulumi.set(__self__, "health_check_id", health_check_id)
        pulumi.set(__self__, "hosted_zone_id", hosted_zone_id)
        pulumi.set(__self__, "record_name", record_name)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="healthCheckId")
    def health_check_id(self) -> _builtins.str:
        """
        ID of the Route53 health check.
        """
        return pulumi.get(self, "health_check_id")

    @_builtins.property
    @pulumi.getter(name="hostedZoneId")
    def hosted_zone_id(self) -> _builtins.str:
        """
        Hosted zone ID for the health check.
        """
        return pulumi.get(self, "hosted_zone_id")

    @_builtins.property
    @pulumi.getter(name="recordName")
    def record_name(self) -> _builtins.str:
        """
        Record name for the health check.
        """
        return pulumi.get(self, "record_name")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        Region where this resource will be [managed](https://docs.aws.amazon.com/general/latest/gr/rande.html#regional-endpoints). Defaults to the Region set in the provider configuration.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Status of the health check. Valid values: `healthy`, `unhealthy`, `unknown`.
        """
        return pulumi.get(self, "status")


