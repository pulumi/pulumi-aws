# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'PlanAssociatedAlarmArgs',
    'PlanAssociatedAlarmArgsDict',
    'PlanTimeoutsArgs',
    'PlanTimeoutsArgsDict',
    'PlanTriggerArgs',
    'PlanTriggerArgsDict',
    'PlanTriggerConditionArgs',
    'PlanTriggerConditionArgsDict',
    'PlanWorkflowArgs',
    'PlanWorkflowArgsDict',
    'PlanWorkflowStepArgs',
    'PlanWorkflowStepArgsDict',
    'PlanWorkflowStepArcRoutingControlConfigArgs',
    'PlanWorkflowStepArcRoutingControlConfigArgsDict',
    'PlanWorkflowStepArcRoutingControlConfigRegionAndRoutingControlArgs',
    'PlanWorkflowStepArcRoutingControlConfigRegionAndRoutingControlArgsDict',
    'PlanWorkflowStepArcRoutingControlConfigRegionAndRoutingControlRoutingControlArgs',
    'PlanWorkflowStepArcRoutingControlConfigRegionAndRoutingControlRoutingControlArgsDict',
    'PlanWorkflowStepCustomActionLambdaConfigArgs',
    'PlanWorkflowStepCustomActionLambdaConfigArgsDict',
    'PlanWorkflowStepCustomActionLambdaConfigLambdaArgs',
    'PlanWorkflowStepCustomActionLambdaConfigLambdaArgsDict',
    'PlanWorkflowStepCustomActionLambdaConfigUngracefulArgs',
    'PlanWorkflowStepCustomActionLambdaConfigUngracefulArgsDict',
    'PlanWorkflowStepDocumentDbConfigArgs',
    'PlanWorkflowStepDocumentDbConfigArgsDict',
    'PlanWorkflowStepDocumentDbConfigUngracefulArgs',
    'PlanWorkflowStepDocumentDbConfigUngracefulArgsDict',
    'PlanWorkflowStepEc2AsgCapacityIncreaseConfigArgs',
    'PlanWorkflowStepEc2AsgCapacityIncreaseConfigArgsDict',
    'PlanWorkflowStepEc2AsgCapacityIncreaseConfigAsgArgs',
    'PlanWorkflowStepEc2AsgCapacityIncreaseConfigAsgArgsDict',
    'PlanWorkflowStepEc2AsgCapacityIncreaseConfigUngracefulArgs',
    'PlanWorkflowStepEc2AsgCapacityIncreaseConfigUngracefulArgsDict',
    'PlanWorkflowStepEcsCapacityIncreaseConfigArgs',
    'PlanWorkflowStepEcsCapacityIncreaseConfigArgsDict',
    'PlanWorkflowStepEcsCapacityIncreaseConfigServiceArgs',
    'PlanWorkflowStepEcsCapacityIncreaseConfigServiceArgsDict',
    'PlanWorkflowStepEcsCapacityIncreaseConfigUngracefulArgs',
    'PlanWorkflowStepEcsCapacityIncreaseConfigUngracefulArgsDict',
    'PlanWorkflowStepEksResourceScalingConfigArgs',
    'PlanWorkflowStepEksResourceScalingConfigArgsDict',
    'PlanWorkflowStepEksResourceScalingConfigEksClusterArgs',
    'PlanWorkflowStepEksResourceScalingConfigEksClusterArgsDict',
    'PlanWorkflowStepEksResourceScalingConfigKubernetesResourceTypeArgs',
    'PlanWorkflowStepEksResourceScalingConfigKubernetesResourceTypeArgsDict',
    'PlanWorkflowStepEksResourceScalingConfigScalingResourceArgs',
    'PlanWorkflowStepEksResourceScalingConfigScalingResourceArgsDict',
    'PlanWorkflowStepEksResourceScalingConfigScalingResourceResourceArgs',
    'PlanWorkflowStepEksResourceScalingConfigScalingResourceResourceArgsDict',
    'PlanWorkflowStepEksResourceScalingConfigUngracefulArgs',
    'PlanWorkflowStepEksResourceScalingConfigUngracefulArgsDict',
    'PlanWorkflowStepExecutionApprovalConfigArgs',
    'PlanWorkflowStepExecutionApprovalConfigArgsDict',
    'PlanWorkflowStepGlobalAuroraConfigArgs',
    'PlanWorkflowStepGlobalAuroraConfigArgsDict',
    'PlanWorkflowStepGlobalAuroraConfigUngracefulArgs',
    'PlanWorkflowStepGlobalAuroraConfigUngracefulArgsDict',
    'PlanWorkflowStepParallelConfigArgs',
    'PlanWorkflowStepParallelConfigArgsDict',
    'PlanWorkflowStepParallelConfigStepArgs',
    'PlanWorkflowStepParallelConfigStepArgsDict',
    'PlanWorkflowStepParallelConfigStepArcRoutingControlConfigArgs',
    'PlanWorkflowStepParallelConfigStepArcRoutingControlConfigArgsDict',
    'PlanWorkflowStepParallelConfigStepArcRoutingControlConfigRegionAndRoutingControlArgs',
    'PlanWorkflowStepParallelConfigStepArcRoutingControlConfigRegionAndRoutingControlArgsDict',
    'PlanWorkflowStepParallelConfigStepArcRoutingControlConfigRegionAndRoutingControlRoutingControlArgs',
    'PlanWorkflowStepParallelConfigStepArcRoutingControlConfigRegionAndRoutingControlRoutingControlArgsDict',
    'PlanWorkflowStepParallelConfigStepCustomActionLambdaConfigArgs',
    'PlanWorkflowStepParallelConfigStepCustomActionLambdaConfigArgsDict',
    'PlanWorkflowStepParallelConfigStepCustomActionLambdaConfigLambdaArgs',
    'PlanWorkflowStepParallelConfigStepCustomActionLambdaConfigLambdaArgsDict',
    'PlanWorkflowStepParallelConfigStepCustomActionLambdaConfigUngracefulArgs',
    'PlanWorkflowStepParallelConfigStepCustomActionLambdaConfigUngracefulArgsDict',
    'PlanWorkflowStepParallelConfigStepDocumentDbConfigArgs',
    'PlanWorkflowStepParallelConfigStepDocumentDbConfigArgsDict',
    'PlanWorkflowStepParallelConfigStepDocumentDbConfigUngracefulArgs',
    'PlanWorkflowStepParallelConfigStepDocumentDbConfigUngracefulArgsDict',
    'PlanWorkflowStepParallelConfigStepEc2AsgCapacityIncreaseConfigArgs',
    'PlanWorkflowStepParallelConfigStepEc2AsgCapacityIncreaseConfigArgsDict',
    'PlanWorkflowStepParallelConfigStepEc2AsgCapacityIncreaseConfigAsgArgs',
    'PlanWorkflowStepParallelConfigStepEc2AsgCapacityIncreaseConfigAsgArgsDict',
    'PlanWorkflowStepParallelConfigStepEc2AsgCapacityIncreaseConfigUngracefulArgs',
    'PlanWorkflowStepParallelConfigStepEc2AsgCapacityIncreaseConfigUngracefulArgsDict',
    'PlanWorkflowStepParallelConfigStepEcsCapacityIncreaseConfigArgs',
    'PlanWorkflowStepParallelConfigStepEcsCapacityIncreaseConfigArgsDict',
    'PlanWorkflowStepParallelConfigStepEcsCapacityIncreaseConfigServiceArgs',
    'PlanWorkflowStepParallelConfigStepEcsCapacityIncreaseConfigServiceArgsDict',
    'PlanWorkflowStepParallelConfigStepEcsCapacityIncreaseConfigUngracefulArgs',
    'PlanWorkflowStepParallelConfigStepEcsCapacityIncreaseConfigUngracefulArgsDict',
    'PlanWorkflowStepParallelConfigStepEksResourceScalingConfigArgs',
    'PlanWorkflowStepParallelConfigStepEksResourceScalingConfigArgsDict',
    'PlanWorkflowStepParallelConfigStepEksResourceScalingConfigEksClusterArgs',
    'PlanWorkflowStepParallelConfigStepEksResourceScalingConfigEksClusterArgsDict',
    'PlanWorkflowStepParallelConfigStepEksResourceScalingConfigKubernetesResourceTypeArgs',
    'PlanWorkflowStepParallelConfigStepEksResourceScalingConfigKubernetesResourceTypeArgsDict',
    'PlanWorkflowStepParallelConfigStepEksResourceScalingConfigScalingResourceArgs',
    'PlanWorkflowStepParallelConfigStepEksResourceScalingConfigScalingResourceArgsDict',
    'PlanWorkflowStepParallelConfigStepEksResourceScalingConfigScalingResourceResourceArgs',
    'PlanWorkflowStepParallelConfigStepEksResourceScalingConfigScalingResourceResourceArgsDict',
    'PlanWorkflowStepParallelConfigStepEksResourceScalingConfigUngracefulArgs',
    'PlanWorkflowStepParallelConfigStepEksResourceScalingConfigUngracefulArgsDict',
    'PlanWorkflowStepParallelConfigStepExecutionApprovalConfigArgs',
    'PlanWorkflowStepParallelConfigStepExecutionApprovalConfigArgsDict',
    'PlanWorkflowStepParallelConfigStepGlobalAuroraConfigArgs',
    'PlanWorkflowStepParallelConfigStepGlobalAuroraConfigArgsDict',
    'PlanWorkflowStepParallelConfigStepGlobalAuroraConfigUngracefulArgs',
    'PlanWorkflowStepParallelConfigStepGlobalAuroraConfigUngracefulArgsDict',
    'PlanWorkflowStepParallelConfigStepRegionSwitchPlanConfigArgs',
    'PlanWorkflowStepParallelConfigStepRegionSwitchPlanConfigArgsDict',
    'PlanWorkflowStepParallelConfigStepRoute53HealthCheckConfigArgs',
    'PlanWorkflowStepParallelConfigStepRoute53HealthCheckConfigArgsDict',
    'PlanWorkflowStepParallelConfigStepRoute53HealthCheckConfigRecordSetArgs',
    'PlanWorkflowStepParallelConfigStepRoute53HealthCheckConfigRecordSetArgsDict',
    'PlanWorkflowStepRegionSwitchPlanConfigArgs',
    'PlanWorkflowStepRegionSwitchPlanConfigArgsDict',
    'PlanWorkflowStepRoute53HealthCheckConfigArgs',
    'PlanWorkflowStepRoute53HealthCheckConfigArgsDict',
    'PlanWorkflowStepRoute53HealthCheckConfigRecordSetArgs',
    'PlanWorkflowStepRoute53HealthCheckConfigRecordSetArgsDict',
]

MYPY = False

if not MYPY:
    class PlanAssociatedAlarmArgsDict(TypedDict):
        alarm_type: pulumi.Input[_builtins.str]
        """
        Type of alarm. Valid values: `applicationHealth`, `trigger`.
        """
        map_block_key: pulumi.Input[_builtins.str]
        """
        Name of the alarm.
        """
        resource_identifier: pulumi.Input[_builtins.str]
        """
        Resource identifier (ARN) of the CloudWatch alarm.
        """
        cross_account_role: NotRequired[pulumi.Input[_builtins.str]]
        """
        ARN of the cross-account role to assume.
        """
        external_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        External ID for cross-account role assumption.
        """
elif False:
    PlanAssociatedAlarmArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanAssociatedAlarmArgs:
    def __init__(__self__, *,
                 alarm_type: pulumi.Input[_builtins.str],
                 map_block_key: pulumi.Input[_builtins.str],
                 resource_identifier: pulumi.Input[_builtins.str],
                 cross_account_role: Optional[pulumi.Input[_builtins.str]] = None,
                 external_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] alarm_type: Type of alarm. Valid values: `applicationHealth`, `trigger`.
        :param pulumi.Input[_builtins.str] map_block_key: Name of the alarm.
        :param pulumi.Input[_builtins.str] resource_identifier: Resource identifier (ARN) of the CloudWatch alarm.
        :param pulumi.Input[_builtins.str] cross_account_role: ARN of the cross-account role to assume.
        :param pulumi.Input[_builtins.str] external_id: External ID for cross-account role assumption.
        """
        pulumi.set(__self__, "alarm_type", alarm_type)
        pulumi.set(__self__, "map_block_key", map_block_key)
        pulumi.set(__self__, "resource_identifier", resource_identifier)
        if cross_account_role is not None:
            pulumi.set(__self__, "cross_account_role", cross_account_role)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)

    @_builtins.property
    @pulumi.getter(name="alarmType")
    def alarm_type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of alarm. Valid values: `applicationHealth`, `trigger`.
        """
        return pulumi.get(self, "alarm_type")

    @alarm_type.setter
    def alarm_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "alarm_type", value)

    @_builtins.property
    @pulumi.getter(name="mapBlockKey")
    def map_block_key(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the alarm.
        """
        return pulumi.get(self, "map_block_key")

    @map_block_key.setter
    def map_block_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "map_block_key", value)

    @_builtins.property
    @pulumi.getter(name="resourceIdentifier")
    def resource_identifier(self) -> pulumi.Input[_builtins.str]:
        """
        Resource identifier (ARN) of the CloudWatch alarm.
        """
        return pulumi.get(self, "resource_identifier")

    @resource_identifier.setter
    def resource_identifier(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "resource_identifier", value)

    @_builtins.property
    @pulumi.getter(name="crossAccountRole")
    def cross_account_role(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ARN of the cross-account role to assume.
        """
        return pulumi.get(self, "cross_account_role")

    @cross_account_role.setter
    def cross_account_role(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cross_account_role", value)

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        External ID for cross-account role assumption.
        """
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "external_id", value)


if not MYPY:
    class PlanTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    PlanTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class PlanTriggerArgsDict(TypedDict):
        action: pulumi.Input[_builtins.str]
        """
        Action to trigger. Valid values: `activate`, `deactivate`.
        """
        min_delay_minutes_between_executions: pulumi.Input[_builtins.int]
        """
        Minimum delay in minutes between executions.
        """
        target_region: pulumi.Input[_builtins.str]
        """
        Target region for the trigger.
        """
        conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['PlanTriggerConditionArgsDict']]]]
        """
        List of conditions that must be met. See Conditions below.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of the plan.
        """
elif False:
    PlanTriggerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanTriggerArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[_builtins.str],
                 min_delay_minutes_between_executions: pulumi.Input[_builtins.int],
                 target_region: pulumi.Input[_builtins.str],
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['PlanTriggerConditionArgs']]]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] action: Action to trigger. Valid values: `activate`, `deactivate`.
        :param pulumi.Input[_builtins.int] min_delay_minutes_between_executions: Minimum delay in minutes between executions.
        :param pulumi.Input[_builtins.str] target_region: Target region for the trigger.
        :param pulumi.Input[Sequence[pulumi.Input['PlanTriggerConditionArgs']]] conditions: List of conditions that must be met. See Conditions below.
        :param pulumi.Input[_builtins.str] description: Description of the plan.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "min_delay_minutes_between_executions", min_delay_minutes_between_executions)
        pulumi.set(__self__, "target_region", target_region)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def action(self) -> pulumi.Input[_builtins.str]:
        """
        Action to trigger. Valid values: `activate`, `deactivate`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter(name="minDelayMinutesBetweenExecutions")
    def min_delay_minutes_between_executions(self) -> pulumi.Input[_builtins.int]:
        """
        Minimum delay in minutes between executions.
        """
        return pulumi.get(self, "min_delay_minutes_between_executions")

    @min_delay_minutes_between_executions.setter
    def min_delay_minutes_between_executions(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "min_delay_minutes_between_executions", value)

    @_builtins.property
    @pulumi.getter(name="targetRegion")
    def target_region(self) -> pulumi.Input[_builtins.str]:
        """
        Target region for the trigger.
        """
        return pulumi.get(self, "target_region")

    @target_region.setter
    def target_region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "target_region", value)

    @_builtins.property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlanTriggerConditionArgs']]]]:
        """
        List of conditions that must be met. See Conditions below.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlanTriggerConditionArgs']]]]):
        pulumi.set(self, "conditions", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of the plan.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class PlanTriggerConditionArgsDict(TypedDict):
        associated_alarm_name: pulumi.Input[_builtins.str]
        """
        Name of the associated alarm.
        """
        condition: pulumi.Input[_builtins.str]
        """
        Condition to check. Valid values: `red`, `green`.
        """
elif False:
    PlanTriggerConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanTriggerConditionArgs:
    def __init__(__self__, *,
                 associated_alarm_name: pulumi.Input[_builtins.str],
                 condition: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] associated_alarm_name: Name of the associated alarm.
        :param pulumi.Input[_builtins.str] condition: Condition to check. Valid values: `red`, `green`.
        """
        pulumi.set(__self__, "associated_alarm_name", associated_alarm_name)
        pulumi.set(__self__, "condition", condition)

    @_builtins.property
    @pulumi.getter(name="associatedAlarmName")
    def associated_alarm_name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the associated alarm.
        """
        return pulumi.get(self, "associated_alarm_name")

    @associated_alarm_name.setter
    def associated_alarm_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "associated_alarm_name", value)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> pulumi.Input[_builtins.str]:
        """
        Condition to check. Valid values: `red`, `green`.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "condition", value)


if not MYPY:
    class PlanWorkflowArgsDict(TypedDict):
        workflow_target_action: pulumi.Input[_builtins.str]
        """
        Action to perform. Valid values: `activate`, `deactivate`.
        """
        steps: NotRequired[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepArgsDict']]]]
        """
        List of steps in the workflow. See Step below.
        """
        workflow_description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of the workflow.
        """
        workflow_target_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Target region for the workflow.
        """
elif False:
    PlanWorkflowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanWorkflowArgs:
    def __init__(__self__, *,
                 workflow_target_action: pulumi.Input[_builtins.str],
                 steps: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepArgs']]]] = None,
                 workflow_description: Optional[pulumi.Input[_builtins.str]] = None,
                 workflow_target_region: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] workflow_target_action: Action to perform. Valid values: `activate`, `deactivate`.
        :param pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepArgs']]] steps: List of steps in the workflow. See Step below.
        :param pulumi.Input[_builtins.str] workflow_description: Description of the workflow.
        :param pulumi.Input[_builtins.str] workflow_target_region: Target region for the workflow.
        """
        pulumi.set(__self__, "workflow_target_action", workflow_target_action)
        if steps is not None:
            pulumi.set(__self__, "steps", steps)
        if workflow_description is not None:
            pulumi.set(__self__, "workflow_description", workflow_description)
        if workflow_target_region is not None:
            pulumi.set(__self__, "workflow_target_region", workflow_target_region)

    @_builtins.property
    @pulumi.getter(name="workflowTargetAction")
    def workflow_target_action(self) -> pulumi.Input[_builtins.str]:
        """
        Action to perform. Valid values: `activate`, `deactivate`.
        """
        return pulumi.get(self, "workflow_target_action")

    @workflow_target_action.setter
    def workflow_target_action(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "workflow_target_action", value)

    @_builtins.property
    @pulumi.getter
    def steps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepArgs']]]]:
        """
        List of steps in the workflow. See Step below.
        """
        return pulumi.get(self, "steps")

    @steps.setter
    def steps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepArgs']]]]):
        pulumi.set(self, "steps", value)

    @_builtins.property
    @pulumi.getter(name="workflowDescription")
    def workflow_description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of the workflow.
        """
        return pulumi.get(self, "workflow_description")

    @workflow_description.setter
    def workflow_description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "workflow_description", value)

    @_builtins.property
    @pulumi.getter(name="workflowTargetRegion")
    def workflow_target_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Target region for the workflow.
        """
        return pulumi.get(self, "workflow_target_region")

    @workflow_target_region.setter
    def workflow_target_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "workflow_target_region", value)


if not MYPY:
    class PlanWorkflowStepArgsDict(TypedDict):
        execution_block_type: pulumi.Input[_builtins.str]
        """
        Type of execution block. Valid values: `ARCRegionSwitchPlan`, `ARCRoutingControl`, `AuroraGlobalDatabase`, `CustomActionLambda`, `DocumentDb`, `EC2AutoScaling`, `ECSServiceScaling`, `EKSResourceScaling`, `ManualApproval`, `Parallel`, `Route53HealthCheck`.
        """
        name: pulumi.Input[_builtins.str]
        """
        Name of the step.
        """
        arc_routing_control_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepArcRoutingControlConfigArgsDict']]]]
        """
        Configuration for ARC routing control. See ARC Routing Control Config below.
        """
        custom_action_lambda_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepCustomActionLambdaConfigArgsDict']]]]
        """
        Configuration for Lambda function execution. See Custom Action Lambda Config below.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of the step.
        """
        document_db_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepDocumentDbConfigArgsDict']]]]
        """
        Configuration for DocumentDB global cluster operations. See DocumentDB Config below.
        """
        ec2_asg_capacity_increase_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepEc2AsgCapacityIncreaseConfigArgsDict']]]]
        """
        Configuration for EC2 Auto Scaling group capacity increase. See EC2 ASG Capacity Increase Config below.
        """
        ecs_capacity_increase_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepEcsCapacityIncreaseConfigArgsDict']]]]
        """
        Configuration for ECS service capacity increase. See ECS Capacity Increase Config below.
        """
        eks_resource_scaling_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepEksResourceScalingConfigArgsDict']]]]
        """
        Configuration for EKS resource scaling. See EKS Resource Scaling Config below.
        """
        execution_approval_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepExecutionApprovalConfigArgsDict']]]]
        """
        Configuration for manual approval steps. See Execution Approval Config below.
        """
        global_aurora_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepGlobalAuroraConfigArgsDict']]]]
        """
        Configuration for Aurora Global Database operations. See Global Aurora Config below.
        """
        parallel_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigArgsDict']]]]
        """
        Configuration for parallel execution of multiple steps. See Parallel Config below.
        """
        region_switch_plan_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepRegionSwitchPlanConfigArgsDict']]]]
        route53_health_check_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepRoute53HealthCheckConfigArgsDict']]]]
        """
        Configuration for Route53 health check operations. See Route53 Health Check Config below.
        """
elif False:
    PlanWorkflowStepArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanWorkflowStepArgs:
    def __init__(__self__, *,
                 execution_block_type: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 arc_routing_control_configs: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepArcRoutingControlConfigArgs']]]] = None,
                 custom_action_lambda_configs: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepCustomActionLambdaConfigArgs']]]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 document_db_configs: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepDocumentDbConfigArgs']]]] = None,
                 ec2_asg_capacity_increase_configs: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepEc2AsgCapacityIncreaseConfigArgs']]]] = None,
                 ecs_capacity_increase_configs: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepEcsCapacityIncreaseConfigArgs']]]] = None,
                 eks_resource_scaling_configs: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepEksResourceScalingConfigArgs']]]] = None,
                 execution_approval_configs: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepExecutionApprovalConfigArgs']]]] = None,
                 global_aurora_configs: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepGlobalAuroraConfigArgs']]]] = None,
                 parallel_configs: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigArgs']]]] = None,
                 region_switch_plan_configs: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepRegionSwitchPlanConfigArgs']]]] = None,
                 route53_health_check_configs: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepRoute53HealthCheckConfigArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] execution_block_type: Type of execution block. Valid values: `ARCRegionSwitchPlan`, `ARCRoutingControl`, `AuroraGlobalDatabase`, `CustomActionLambda`, `DocumentDb`, `EC2AutoScaling`, `ECSServiceScaling`, `EKSResourceScaling`, `ManualApproval`, `Parallel`, `Route53HealthCheck`.
        :param pulumi.Input[_builtins.str] name: Name of the step.
        :param pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepArcRoutingControlConfigArgs']]] arc_routing_control_configs: Configuration for ARC routing control. See ARC Routing Control Config below.
        :param pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepCustomActionLambdaConfigArgs']]] custom_action_lambda_configs: Configuration for Lambda function execution. See Custom Action Lambda Config below.
        :param pulumi.Input[_builtins.str] description: Description of the step.
        :param pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepDocumentDbConfigArgs']]] document_db_configs: Configuration for DocumentDB global cluster operations. See DocumentDB Config below.
        :param pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepEc2AsgCapacityIncreaseConfigArgs']]] ec2_asg_capacity_increase_configs: Configuration for EC2 Auto Scaling group capacity increase. See EC2 ASG Capacity Increase Config below.
        :param pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepEcsCapacityIncreaseConfigArgs']]] ecs_capacity_increase_configs: Configuration for ECS service capacity increase. See ECS Capacity Increase Config below.
        :param pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepEksResourceScalingConfigArgs']]] eks_resource_scaling_configs: Configuration for EKS resource scaling. See EKS Resource Scaling Config below.
        :param pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepExecutionApprovalConfigArgs']]] execution_approval_configs: Configuration for manual approval steps. See Execution Approval Config below.
        :param pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepGlobalAuroraConfigArgs']]] global_aurora_configs: Configuration for Aurora Global Database operations. See Global Aurora Config below.
        :param pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigArgs']]] parallel_configs: Configuration for parallel execution of multiple steps. See Parallel Config below.
        :param pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepRoute53HealthCheckConfigArgs']]] route53_health_check_configs: Configuration for Route53 health check operations. See Route53 Health Check Config below.
        """
        pulumi.set(__self__, "execution_block_type", execution_block_type)
        pulumi.set(__self__, "name", name)
        if arc_routing_control_configs is not None:
            pulumi.set(__self__, "arc_routing_control_configs", arc_routing_control_configs)
        if custom_action_lambda_configs is not None:
            pulumi.set(__self__, "custom_action_lambda_configs", custom_action_lambda_configs)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if document_db_configs is not None:
            pulumi.set(__self__, "document_db_configs", document_db_configs)
        if ec2_asg_capacity_increase_configs is not None:
            pulumi.set(__self__, "ec2_asg_capacity_increase_configs", ec2_asg_capacity_increase_configs)
        if ecs_capacity_increase_configs is not None:
            pulumi.set(__self__, "ecs_capacity_increase_configs", ecs_capacity_increase_configs)
        if eks_resource_scaling_configs is not None:
            pulumi.set(__self__, "eks_resource_scaling_configs", eks_resource_scaling_configs)
        if execution_approval_configs is not None:
            pulumi.set(__self__, "execution_approval_configs", execution_approval_configs)
        if global_aurora_configs is not None:
            pulumi.set(__self__, "global_aurora_configs", global_aurora_configs)
        if parallel_configs is not None:
            pulumi.set(__self__, "parallel_configs", parallel_configs)
        if region_switch_plan_configs is not None:
            pulumi.set(__self__, "region_switch_plan_configs", region_switch_plan_configs)
        if route53_health_check_configs is not None:
            pulumi.set(__self__, "route53_health_check_configs", route53_health_check_configs)

    @_builtins.property
    @pulumi.getter(name="executionBlockType")
    def execution_block_type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of execution block. Valid values: `ARCRegionSwitchPlan`, `ARCRoutingControl`, `AuroraGlobalDatabase`, `CustomActionLambda`, `DocumentDb`, `EC2AutoScaling`, `ECSServiceScaling`, `EKSResourceScaling`, `ManualApproval`, `Parallel`, `Route53HealthCheck`.
        """
        return pulumi.get(self, "execution_block_type")

    @execution_block_type.setter
    def execution_block_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "execution_block_type", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the step.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="arcRoutingControlConfigs")
    def arc_routing_control_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepArcRoutingControlConfigArgs']]]]:
        """
        Configuration for ARC routing control. See ARC Routing Control Config below.
        """
        return pulumi.get(self, "arc_routing_control_configs")

    @arc_routing_control_configs.setter
    def arc_routing_control_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepArcRoutingControlConfigArgs']]]]):
        pulumi.set(self, "arc_routing_control_configs", value)

    @_builtins.property
    @pulumi.getter(name="customActionLambdaConfigs")
    def custom_action_lambda_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepCustomActionLambdaConfigArgs']]]]:
        """
        Configuration for Lambda function execution. See Custom Action Lambda Config below.
        """
        return pulumi.get(self, "custom_action_lambda_configs")

    @custom_action_lambda_configs.setter
    def custom_action_lambda_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepCustomActionLambdaConfigArgs']]]]):
        pulumi.set(self, "custom_action_lambda_configs", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of the step.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="documentDbConfigs")
    def document_db_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepDocumentDbConfigArgs']]]]:
        """
        Configuration for DocumentDB global cluster operations. See DocumentDB Config below.
        """
        return pulumi.get(self, "document_db_configs")

    @document_db_configs.setter
    def document_db_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepDocumentDbConfigArgs']]]]):
        pulumi.set(self, "document_db_configs", value)

    @_builtins.property
    @pulumi.getter(name="ec2AsgCapacityIncreaseConfigs")
    def ec2_asg_capacity_increase_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepEc2AsgCapacityIncreaseConfigArgs']]]]:
        """
        Configuration for EC2 Auto Scaling group capacity increase. See EC2 ASG Capacity Increase Config below.
        """
        return pulumi.get(self, "ec2_asg_capacity_increase_configs")

    @ec2_asg_capacity_increase_configs.setter
    def ec2_asg_capacity_increase_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepEc2AsgCapacityIncreaseConfigArgs']]]]):
        pulumi.set(self, "ec2_asg_capacity_increase_configs", value)

    @_builtins.property
    @pulumi.getter(name="ecsCapacityIncreaseConfigs")
    def ecs_capacity_increase_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepEcsCapacityIncreaseConfigArgs']]]]:
        """
        Configuration for ECS service capacity increase. See ECS Capacity Increase Config below.
        """
        return pulumi.get(self, "ecs_capacity_increase_configs")

    @ecs_capacity_increase_configs.setter
    def ecs_capacity_increase_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepEcsCapacityIncreaseConfigArgs']]]]):
        pulumi.set(self, "ecs_capacity_increase_configs", value)

    @_builtins.property
    @pulumi.getter(name="eksResourceScalingConfigs")
    def eks_resource_scaling_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepEksResourceScalingConfigArgs']]]]:
        """
        Configuration for EKS resource scaling. See EKS Resource Scaling Config below.
        """
        return pulumi.get(self, "eks_resource_scaling_configs")

    @eks_resource_scaling_configs.setter
    def eks_resource_scaling_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepEksResourceScalingConfigArgs']]]]):
        pulumi.set(self, "eks_resource_scaling_configs", value)

    @_builtins.property
    @pulumi.getter(name="executionApprovalConfigs")
    def execution_approval_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepExecutionApprovalConfigArgs']]]]:
        """
        Configuration for manual approval steps. See Execution Approval Config below.
        """
        return pulumi.get(self, "execution_approval_configs")

    @execution_approval_configs.setter
    def execution_approval_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepExecutionApprovalConfigArgs']]]]):
        pulumi.set(self, "execution_approval_configs", value)

    @_builtins.property
    @pulumi.getter(name="globalAuroraConfigs")
    def global_aurora_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepGlobalAuroraConfigArgs']]]]:
        """
        Configuration for Aurora Global Database operations. See Global Aurora Config below.
        """
        return pulumi.get(self, "global_aurora_configs")

    @global_aurora_configs.setter
    def global_aurora_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepGlobalAuroraConfigArgs']]]]):
        pulumi.set(self, "global_aurora_configs", value)

    @_builtins.property
    @pulumi.getter(name="parallelConfigs")
    def parallel_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigArgs']]]]:
        """
        Configuration for parallel execution of multiple steps. See Parallel Config below.
        """
        return pulumi.get(self, "parallel_configs")

    @parallel_configs.setter
    def parallel_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigArgs']]]]):
        pulumi.set(self, "parallel_configs", value)

    @_builtins.property
    @pulumi.getter(name="regionSwitchPlanConfigs")
    def region_switch_plan_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepRegionSwitchPlanConfigArgs']]]]:
        return pulumi.get(self, "region_switch_plan_configs")

    @region_switch_plan_configs.setter
    def region_switch_plan_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepRegionSwitchPlanConfigArgs']]]]):
        pulumi.set(self, "region_switch_plan_configs", value)

    @_builtins.property
    @pulumi.getter(name="route53HealthCheckConfigs")
    def route53_health_check_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepRoute53HealthCheckConfigArgs']]]]:
        """
        Configuration for Route53 health check operations. See Route53 Health Check Config below.
        """
        return pulumi.get(self, "route53_health_check_configs")

    @route53_health_check_configs.setter
    def route53_health_check_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepRoute53HealthCheckConfigArgs']]]]):
        pulumi.set(self, "route53_health_check_configs", value)


if not MYPY:
    class PlanWorkflowStepArcRoutingControlConfigArgsDict(TypedDict):
        cross_account_role: NotRequired[pulumi.Input[_builtins.str]]
        """
        ARN of the cross-account role to assume.
        """
        external_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        External ID for cross-account role assumption.
        """
        region_and_routing_controls: NotRequired[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepArcRoutingControlConfigRegionAndRoutingControlArgsDict']]]]
        """
        List of regions and their routing controls. See Region and Routing Controls below.
        """
        timeout_minutes: NotRequired[pulumi.Input[_builtins.int]]
        """
        Timeout in minutes.
        """
elif False:
    PlanWorkflowStepArcRoutingControlConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanWorkflowStepArcRoutingControlConfigArgs:
    def __init__(__self__, *,
                 cross_account_role: Optional[pulumi.Input[_builtins.str]] = None,
                 external_id: Optional[pulumi.Input[_builtins.str]] = None,
                 region_and_routing_controls: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepArcRoutingControlConfigRegionAndRoutingControlArgs']]]] = None,
                 timeout_minutes: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] cross_account_role: ARN of the cross-account role to assume.
        :param pulumi.Input[_builtins.str] external_id: External ID for cross-account role assumption.
        :param pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepArcRoutingControlConfigRegionAndRoutingControlArgs']]] region_and_routing_controls: List of regions and their routing controls. See Region and Routing Controls below.
        :param pulumi.Input[_builtins.int] timeout_minutes: Timeout in minutes.
        """
        if cross_account_role is not None:
            pulumi.set(__self__, "cross_account_role", cross_account_role)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if region_and_routing_controls is not None:
            pulumi.set(__self__, "region_and_routing_controls", region_and_routing_controls)
        if timeout_minutes is not None:
            pulumi.set(__self__, "timeout_minutes", timeout_minutes)

    @_builtins.property
    @pulumi.getter(name="crossAccountRole")
    def cross_account_role(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ARN of the cross-account role to assume.
        """
        return pulumi.get(self, "cross_account_role")

    @cross_account_role.setter
    def cross_account_role(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cross_account_role", value)

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        External ID for cross-account role assumption.
        """
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "external_id", value)

    @_builtins.property
    @pulumi.getter(name="regionAndRoutingControls")
    def region_and_routing_controls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepArcRoutingControlConfigRegionAndRoutingControlArgs']]]]:
        """
        List of regions and their routing controls. See Region and Routing Controls below.
        """
        return pulumi.get(self, "region_and_routing_controls")

    @region_and_routing_controls.setter
    def region_and_routing_controls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepArcRoutingControlConfigRegionAndRoutingControlArgs']]]]):
        pulumi.set(self, "region_and_routing_controls", value)

    @_builtins.property
    @pulumi.getter(name="timeoutMinutes")
    def timeout_minutes(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Timeout in minutes.
        """
        return pulumi.get(self, "timeout_minutes")

    @timeout_minutes.setter
    def timeout_minutes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout_minutes", value)


if not MYPY:
    class PlanWorkflowStepArcRoutingControlConfigRegionAndRoutingControlArgsDict(TypedDict):
        region: pulumi.Input[_builtins.str]
        """
        AWS region.
        """
        routing_controls: NotRequired[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepArcRoutingControlConfigRegionAndRoutingControlRoutingControlArgsDict']]]]
        """
        List of routing controls. See Routing Control below.
        """
elif False:
    PlanWorkflowStepArcRoutingControlConfigRegionAndRoutingControlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanWorkflowStepArcRoutingControlConfigRegionAndRoutingControlArgs:
    def __init__(__self__, *,
                 region: pulumi.Input[_builtins.str],
                 routing_controls: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepArcRoutingControlConfigRegionAndRoutingControlRoutingControlArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] region: AWS region.
        :param pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepArcRoutingControlConfigRegionAndRoutingControlRoutingControlArgs']]] routing_controls: List of routing controls. See Routing Control below.
        """
        pulumi.set(__self__, "region", region)
        if routing_controls is not None:
            pulumi.set(__self__, "routing_controls", routing_controls)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        AWS region.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="routingControls")
    def routing_controls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepArcRoutingControlConfigRegionAndRoutingControlRoutingControlArgs']]]]:
        """
        List of routing controls. See Routing Control below.
        """
        return pulumi.get(self, "routing_controls")

    @routing_controls.setter
    def routing_controls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepArcRoutingControlConfigRegionAndRoutingControlRoutingControlArgs']]]]):
        pulumi.set(self, "routing_controls", value)


if not MYPY:
    class PlanWorkflowStepArcRoutingControlConfigRegionAndRoutingControlRoutingControlArgsDict(TypedDict):
        routing_control_arn: pulumi.Input[_builtins.str]
        """
        ARN of the routing control.
        """
        state: pulumi.Input[_builtins.str]
        """
        State of the routing control. Valid values: `On`, `Off`.
        """
elif False:
    PlanWorkflowStepArcRoutingControlConfigRegionAndRoutingControlRoutingControlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanWorkflowStepArcRoutingControlConfigRegionAndRoutingControlRoutingControlArgs:
    def __init__(__self__, *,
                 routing_control_arn: pulumi.Input[_builtins.str],
                 state: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] routing_control_arn: ARN of the routing control.
        :param pulumi.Input[_builtins.str] state: State of the routing control. Valid values: `On`, `Off`.
        """
        pulumi.set(__self__, "routing_control_arn", routing_control_arn)
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="routingControlArn")
    def routing_control_arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of the routing control.
        """
        return pulumi.get(self, "routing_control_arn")

    @routing_control_arn.setter
    def routing_control_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "routing_control_arn", value)

    @_builtins.property
    @pulumi.getter
    def state(self) -> pulumi.Input[_builtins.str]:
        """
        State of the routing control. Valid values: `On`, `Off`.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "state", value)


if not MYPY:
    class PlanWorkflowStepCustomActionLambdaConfigArgsDict(TypedDict):
        region_to_run: pulumi.Input[_builtins.str]
        """
        Region where the Lambda function should run. Valid values: `activatingRegion`, `deactivatingRegion`.
        """
        retry_interval_minutes: pulumi.Input[_builtins.float]
        """
        Retry interval in minutes.
        """
        lambdas: NotRequired[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepCustomActionLambdaConfigLambdaArgsDict']]]]
        """
        Lambda function configuration. See Lambda below.
        """
        timeout_minutes: NotRequired[pulumi.Input[_builtins.int]]
        """
        Timeout in minutes.
        """
        ungracefuls: NotRequired[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepCustomActionLambdaConfigUngracefulArgsDict']]]]
        """
        Ungraceful behavior configuration. See Ungraceful below.
        """
elif False:
    PlanWorkflowStepCustomActionLambdaConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanWorkflowStepCustomActionLambdaConfigArgs:
    def __init__(__self__, *,
                 region_to_run: pulumi.Input[_builtins.str],
                 retry_interval_minutes: pulumi.Input[_builtins.float],
                 lambdas: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepCustomActionLambdaConfigLambdaArgs']]]] = None,
                 timeout_minutes: Optional[pulumi.Input[_builtins.int]] = None,
                 ungracefuls: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepCustomActionLambdaConfigUngracefulArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] region_to_run: Region where the Lambda function should run. Valid values: `activatingRegion`, `deactivatingRegion`.
        :param pulumi.Input[_builtins.float] retry_interval_minutes: Retry interval in minutes.
        :param pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepCustomActionLambdaConfigLambdaArgs']]] lambdas: Lambda function configuration. See Lambda below.
        :param pulumi.Input[_builtins.int] timeout_minutes: Timeout in minutes.
        :param pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepCustomActionLambdaConfigUngracefulArgs']]] ungracefuls: Ungraceful behavior configuration. See Ungraceful below.
        """
        pulumi.set(__self__, "region_to_run", region_to_run)
        pulumi.set(__self__, "retry_interval_minutes", retry_interval_minutes)
        if lambdas is not None:
            pulumi.set(__self__, "lambdas", lambdas)
        if timeout_minutes is not None:
            pulumi.set(__self__, "timeout_minutes", timeout_minutes)
        if ungracefuls is not None:
            pulumi.set(__self__, "ungracefuls", ungracefuls)

    @_builtins.property
    @pulumi.getter(name="regionToRun")
    def region_to_run(self) -> pulumi.Input[_builtins.str]:
        """
        Region where the Lambda function should run. Valid values: `activatingRegion`, `deactivatingRegion`.
        """
        return pulumi.get(self, "region_to_run")

    @region_to_run.setter
    def region_to_run(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region_to_run", value)

    @_builtins.property
    @pulumi.getter(name="retryIntervalMinutes")
    def retry_interval_minutes(self) -> pulumi.Input[_builtins.float]:
        """
        Retry interval in minutes.
        """
        return pulumi.get(self, "retry_interval_minutes")

    @retry_interval_minutes.setter
    def retry_interval_minutes(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "retry_interval_minutes", value)

    @_builtins.property
    @pulumi.getter
    def lambdas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepCustomActionLambdaConfigLambdaArgs']]]]:
        """
        Lambda function configuration. See Lambda below.
        """
        return pulumi.get(self, "lambdas")

    @lambdas.setter
    def lambdas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepCustomActionLambdaConfigLambdaArgs']]]]):
        pulumi.set(self, "lambdas", value)

    @_builtins.property
    @pulumi.getter(name="timeoutMinutes")
    def timeout_minutes(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Timeout in minutes.
        """
        return pulumi.get(self, "timeout_minutes")

    @timeout_minutes.setter
    def timeout_minutes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout_minutes", value)

    @_builtins.property
    @pulumi.getter
    def ungracefuls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepCustomActionLambdaConfigUngracefulArgs']]]]:
        """
        Ungraceful behavior configuration. See Ungraceful below.
        """
        return pulumi.get(self, "ungracefuls")

    @ungracefuls.setter
    def ungracefuls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepCustomActionLambdaConfigUngracefulArgs']]]]):
        pulumi.set(self, "ungracefuls", value)


if not MYPY:
    class PlanWorkflowStepCustomActionLambdaConfigLambdaArgsDict(TypedDict):
        arn: pulumi.Input[_builtins.str]
        """
        ARN of the Lambda function.
        """
        cross_account_role: NotRequired[pulumi.Input[_builtins.str]]
        """
        ARN of the cross-account role to assume.
        """
        external_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        External ID for cross-account role assumption.
        """
elif False:
    PlanWorkflowStepCustomActionLambdaConfigLambdaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanWorkflowStepCustomActionLambdaConfigLambdaArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[_builtins.str],
                 cross_account_role: Optional[pulumi.Input[_builtins.str]] = None,
                 external_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] arn: ARN of the Lambda function.
        :param pulumi.Input[_builtins.str] cross_account_role: ARN of the cross-account role to assume.
        :param pulumi.Input[_builtins.str] external_id: External ID for cross-account role assumption.
        """
        pulumi.set(__self__, "arn", arn)
        if cross_account_role is not None:
            pulumi.set(__self__, "cross_account_role", cross_account_role)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of the Lambda function.
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "arn", value)

    @_builtins.property
    @pulumi.getter(name="crossAccountRole")
    def cross_account_role(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ARN of the cross-account role to assume.
        """
        return pulumi.get(self, "cross_account_role")

    @cross_account_role.setter
    def cross_account_role(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cross_account_role", value)

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        External ID for cross-account role assumption.
        """
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "external_id", value)


if not MYPY:
    class PlanWorkflowStepCustomActionLambdaConfigUngracefulArgsDict(TypedDict):
        behavior: pulumi.Input[_builtins.str]
        """
        Behavior when ungraceful. Valid values: `skip`.
        """
elif False:
    PlanWorkflowStepCustomActionLambdaConfigUngracefulArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanWorkflowStepCustomActionLambdaConfigUngracefulArgs:
    def __init__(__self__, *,
                 behavior: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] behavior: Behavior when ungraceful. Valid values: `skip`.
        """
        pulumi.set(__self__, "behavior", behavior)

    @_builtins.property
    @pulumi.getter
    def behavior(self) -> pulumi.Input[_builtins.str]:
        """
        Behavior when ungraceful. Valid values: `skip`.
        """
        return pulumi.get(self, "behavior")

    @behavior.setter
    def behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "behavior", value)


if not MYPY:
    class PlanWorkflowStepDocumentDbConfigArgsDict(TypedDict):
        behavior: pulumi.Input[_builtins.str]
        database_cluster_arns: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        global_cluster_identifier: pulumi.Input[_builtins.str]
        cross_account_role: NotRequired[pulumi.Input[_builtins.str]]
        external_id: NotRequired[pulumi.Input[_builtins.str]]
        timeout_minutes: NotRequired[pulumi.Input[_builtins.int]]
        ungracefuls: NotRequired[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepDocumentDbConfigUngracefulArgsDict']]]]
elif False:
    PlanWorkflowStepDocumentDbConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanWorkflowStepDocumentDbConfigArgs:
    def __init__(__self__, *,
                 behavior: pulumi.Input[_builtins.str],
                 database_cluster_arns: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 global_cluster_identifier: pulumi.Input[_builtins.str],
                 cross_account_role: Optional[pulumi.Input[_builtins.str]] = None,
                 external_id: Optional[pulumi.Input[_builtins.str]] = None,
                 timeout_minutes: Optional[pulumi.Input[_builtins.int]] = None,
                 ungracefuls: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepDocumentDbConfigUngracefulArgs']]]] = None):
        pulumi.set(__self__, "behavior", behavior)
        pulumi.set(__self__, "database_cluster_arns", database_cluster_arns)
        pulumi.set(__self__, "global_cluster_identifier", global_cluster_identifier)
        if cross_account_role is not None:
            pulumi.set(__self__, "cross_account_role", cross_account_role)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if timeout_minutes is not None:
            pulumi.set(__self__, "timeout_minutes", timeout_minutes)
        if ungracefuls is not None:
            pulumi.set(__self__, "ungracefuls", ungracefuls)

    @_builtins.property
    @pulumi.getter
    def behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "behavior")

    @behavior.setter
    def behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "behavior", value)

    @_builtins.property
    @pulumi.getter(name="databaseClusterArns")
    def database_cluster_arns(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "database_cluster_arns")

    @database_cluster_arns.setter
    def database_cluster_arns(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "database_cluster_arns", value)

    @_builtins.property
    @pulumi.getter(name="globalClusterIdentifier")
    def global_cluster_identifier(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "global_cluster_identifier")

    @global_cluster_identifier.setter
    def global_cluster_identifier(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "global_cluster_identifier", value)

    @_builtins.property
    @pulumi.getter(name="crossAccountRole")
    def cross_account_role(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "cross_account_role")

    @cross_account_role.setter
    def cross_account_role(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cross_account_role", value)

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "external_id", value)

    @_builtins.property
    @pulumi.getter(name="timeoutMinutes")
    def timeout_minutes(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "timeout_minutes")

    @timeout_minutes.setter
    def timeout_minutes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout_minutes", value)

    @_builtins.property
    @pulumi.getter
    def ungracefuls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepDocumentDbConfigUngracefulArgs']]]]:
        return pulumi.get(self, "ungracefuls")

    @ungracefuls.setter
    def ungracefuls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepDocumentDbConfigUngracefulArgs']]]]):
        pulumi.set(self, "ungracefuls", value)


if not MYPY:
    class PlanWorkflowStepDocumentDbConfigUngracefulArgsDict(TypedDict):
        ungraceful: pulumi.Input[_builtins.str]
elif False:
    PlanWorkflowStepDocumentDbConfigUngracefulArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanWorkflowStepDocumentDbConfigUngracefulArgs:
    def __init__(__self__, *,
                 ungraceful: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "ungraceful", ungraceful)

    @_builtins.property
    @pulumi.getter
    def ungraceful(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "ungraceful")

    @ungraceful.setter
    def ungraceful(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ungraceful", value)


if not MYPY:
    class PlanWorkflowStepEc2AsgCapacityIncreaseConfigArgsDict(TypedDict):
        capacity_monitoring_approach: pulumi.Input[_builtins.str]
        """
        Capacity monitoring approach. Valid values: `sampledMaxInLast24Hours`, `autoscalingMaxInLast24Hours`.
        """
        asgs: NotRequired[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepEc2AsgCapacityIncreaseConfigAsgArgsDict']]]]
        """
        Auto Scaling group configuration. See ASG below.
        """
        target_percent: NotRequired[pulumi.Input[_builtins.int]]
        """
        Target capacity percentage.
        """
        timeout_minutes: NotRequired[pulumi.Input[_builtins.int]]
        """
        Timeout in minutes.
        """
        ungraceful: NotRequired[pulumi.Input['PlanWorkflowStepEc2AsgCapacityIncreaseConfigUngracefulArgsDict']]
        """
        Ungraceful behavior configuration. See Ungraceful below.
        """
elif False:
    PlanWorkflowStepEc2AsgCapacityIncreaseConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanWorkflowStepEc2AsgCapacityIncreaseConfigArgs:
    def __init__(__self__, *,
                 capacity_monitoring_approach: pulumi.Input[_builtins.str],
                 asgs: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepEc2AsgCapacityIncreaseConfigAsgArgs']]]] = None,
                 target_percent: Optional[pulumi.Input[_builtins.int]] = None,
                 timeout_minutes: Optional[pulumi.Input[_builtins.int]] = None,
                 ungraceful: Optional[pulumi.Input['PlanWorkflowStepEc2AsgCapacityIncreaseConfigUngracefulArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] capacity_monitoring_approach: Capacity monitoring approach. Valid values: `sampledMaxInLast24Hours`, `autoscalingMaxInLast24Hours`.
        :param pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepEc2AsgCapacityIncreaseConfigAsgArgs']]] asgs: Auto Scaling group configuration. See ASG below.
        :param pulumi.Input[_builtins.int] target_percent: Target capacity percentage.
        :param pulumi.Input[_builtins.int] timeout_minutes: Timeout in minutes.
        :param pulumi.Input['PlanWorkflowStepEc2AsgCapacityIncreaseConfigUngracefulArgs'] ungraceful: Ungraceful behavior configuration. See Ungraceful below.
        """
        pulumi.set(__self__, "capacity_monitoring_approach", capacity_monitoring_approach)
        if asgs is not None:
            pulumi.set(__self__, "asgs", asgs)
        if target_percent is not None:
            pulumi.set(__self__, "target_percent", target_percent)
        if timeout_minutes is not None:
            pulumi.set(__self__, "timeout_minutes", timeout_minutes)
        if ungraceful is not None:
            pulumi.set(__self__, "ungraceful", ungraceful)

    @_builtins.property
    @pulumi.getter(name="capacityMonitoringApproach")
    def capacity_monitoring_approach(self) -> pulumi.Input[_builtins.str]:
        """
        Capacity monitoring approach. Valid values: `sampledMaxInLast24Hours`, `autoscalingMaxInLast24Hours`.
        """
        return pulumi.get(self, "capacity_monitoring_approach")

    @capacity_monitoring_approach.setter
    def capacity_monitoring_approach(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "capacity_monitoring_approach", value)

    @_builtins.property
    @pulumi.getter
    def asgs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepEc2AsgCapacityIncreaseConfigAsgArgs']]]]:
        """
        Auto Scaling group configuration. See ASG below.
        """
        return pulumi.get(self, "asgs")

    @asgs.setter
    def asgs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepEc2AsgCapacityIncreaseConfigAsgArgs']]]]):
        pulumi.set(self, "asgs", value)

    @_builtins.property
    @pulumi.getter(name="targetPercent")
    def target_percent(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Target capacity percentage.
        """
        return pulumi.get(self, "target_percent")

    @target_percent.setter
    def target_percent(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "target_percent", value)

    @_builtins.property
    @pulumi.getter(name="timeoutMinutes")
    def timeout_minutes(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Timeout in minutes.
        """
        return pulumi.get(self, "timeout_minutes")

    @timeout_minutes.setter
    def timeout_minutes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout_minutes", value)

    @_builtins.property
    @pulumi.getter
    def ungraceful(self) -> Optional[pulumi.Input['PlanWorkflowStepEc2AsgCapacityIncreaseConfigUngracefulArgs']]:
        """
        Ungraceful behavior configuration. See Ungraceful below.
        """
        return pulumi.get(self, "ungraceful")

    @ungraceful.setter
    def ungraceful(self, value: Optional[pulumi.Input['PlanWorkflowStepEc2AsgCapacityIncreaseConfigUngracefulArgs']]):
        pulumi.set(self, "ungraceful", value)


if not MYPY:
    class PlanWorkflowStepEc2AsgCapacityIncreaseConfigAsgArgsDict(TypedDict):
        arn: pulumi.Input[_builtins.str]
        """
        ARN of the Auto Scaling group.
        """
        cross_account_role: NotRequired[pulumi.Input[_builtins.str]]
        """
        ARN of the cross-account role to assume.
        """
        external_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        External ID for cross-account role assumption.
        """
elif False:
    PlanWorkflowStepEc2AsgCapacityIncreaseConfigAsgArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanWorkflowStepEc2AsgCapacityIncreaseConfigAsgArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[_builtins.str],
                 cross_account_role: Optional[pulumi.Input[_builtins.str]] = None,
                 external_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] arn: ARN of the Auto Scaling group.
        :param pulumi.Input[_builtins.str] cross_account_role: ARN of the cross-account role to assume.
        :param pulumi.Input[_builtins.str] external_id: External ID for cross-account role assumption.
        """
        pulumi.set(__self__, "arn", arn)
        if cross_account_role is not None:
            pulumi.set(__self__, "cross_account_role", cross_account_role)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of the Auto Scaling group.
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "arn", value)

    @_builtins.property
    @pulumi.getter(name="crossAccountRole")
    def cross_account_role(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ARN of the cross-account role to assume.
        """
        return pulumi.get(self, "cross_account_role")

    @cross_account_role.setter
    def cross_account_role(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cross_account_role", value)

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        External ID for cross-account role assumption.
        """
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "external_id", value)


if not MYPY:
    class PlanWorkflowStepEc2AsgCapacityIncreaseConfigUngracefulArgsDict(TypedDict):
        minimum_success_percentage: pulumi.Input[_builtins.int]
        """
        Minimum success percentage required.
        """
elif False:
    PlanWorkflowStepEc2AsgCapacityIncreaseConfigUngracefulArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanWorkflowStepEc2AsgCapacityIncreaseConfigUngracefulArgs:
    def __init__(__self__, *,
                 minimum_success_percentage: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.int] minimum_success_percentage: Minimum success percentage required.
        """
        pulumi.set(__self__, "minimum_success_percentage", minimum_success_percentage)

    @_builtins.property
    @pulumi.getter(name="minimumSuccessPercentage")
    def minimum_success_percentage(self) -> pulumi.Input[_builtins.int]:
        """
        Minimum success percentage required.
        """
        return pulumi.get(self, "minimum_success_percentage")

    @minimum_success_percentage.setter
    def minimum_success_percentage(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "minimum_success_percentage", value)


if not MYPY:
    class PlanWorkflowStepEcsCapacityIncreaseConfigArgsDict(TypedDict):
        capacity_monitoring_approach: pulumi.Input[_builtins.str]
        """
        Capacity monitoring approach. Valid values: `sampledMaxInLast24Hours`, `containerInsightsMaxInLast24Hours`.
        """
        services: NotRequired[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepEcsCapacityIncreaseConfigServiceArgsDict']]]]
        """
        ECS service configuration. See ECS Service below.
        """
        target_percent: NotRequired[pulumi.Input[_builtins.int]]
        """
        Target capacity percentage.
        """
        timeout_minutes: NotRequired[pulumi.Input[_builtins.int]]
        """
        Timeout in minutes.
        """
        ungraceful: NotRequired[pulumi.Input['PlanWorkflowStepEcsCapacityIncreaseConfigUngracefulArgsDict']]
        """
        Ungraceful behavior configuration. See Ungraceful Capacity below.
        """
elif False:
    PlanWorkflowStepEcsCapacityIncreaseConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanWorkflowStepEcsCapacityIncreaseConfigArgs:
    def __init__(__self__, *,
                 capacity_monitoring_approach: pulumi.Input[_builtins.str],
                 services: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepEcsCapacityIncreaseConfigServiceArgs']]]] = None,
                 target_percent: Optional[pulumi.Input[_builtins.int]] = None,
                 timeout_minutes: Optional[pulumi.Input[_builtins.int]] = None,
                 ungraceful: Optional[pulumi.Input['PlanWorkflowStepEcsCapacityIncreaseConfigUngracefulArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] capacity_monitoring_approach: Capacity monitoring approach. Valid values: `sampledMaxInLast24Hours`, `containerInsightsMaxInLast24Hours`.
        :param pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepEcsCapacityIncreaseConfigServiceArgs']]] services: ECS service configuration. See ECS Service below.
        :param pulumi.Input[_builtins.int] target_percent: Target capacity percentage.
        :param pulumi.Input[_builtins.int] timeout_minutes: Timeout in minutes.
        :param pulumi.Input['PlanWorkflowStepEcsCapacityIncreaseConfigUngracefulArgs'] ungraceful: Ungraceful behavior configuration. See Ungraceful Capacity below.
        """
        pulumi.set(__self__, "capacity_monitoring_approach", capacity_monitoring_approach)
        if services is not None:
            pulumi.set(__self__, "services", services)
        if target_percent is not None:
            pulumi.set(__self__, "target_percent", target_percent)
        if timeout_minutes is not None:
            pulumi.set(__self__, "timeout_minutes", timeout_minutes)
        if ungraceful is not None:
            pulumi.set(__self__, "ungraceful", ungraceful)

    @_builtins.property
    @pulumi.getter(name="capacityMonitoringApproach")
    def capacity_monitoring_approach(self) -> pulumi.Input[_builtins.str]:
        """
        Capacity monitoring approach. Valid values: `sampledMaxInLast24Hours`, `containerInsightsMaxInLast24Hours`.
        """
        return pulumi.get(self, "capacity_monitoring_approach")

    @capacity_monitoring_approach.setter
    def capacity_monitoring_approach(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "capacity_monitoring_approach", value)

    @_builtins.property
    @pulumi.getter
    def services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepEcsCapacityIncreaseConfigServiceArgs']]]]:
        """
        ECS service configuration. See ECS Service below.
        """
        return pulumi.get(self, "services")

    @services.setter
    def services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepEcsCapacityIncreaseConfigServiceArgs']]]]):
        pulumi.set(self, "services", value)

    @_builtins.property
    @pulumi.getter(name="targetPercent")
    def target_percent(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Target capacity percentage.
        """
        return pulumi.get(self, "target_percent")

    @target_percent.setter
    def target_percent(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "target_percent", value)

    @_builtins.property
    @pulumi.getter(name="timeoutMinutes")
    def timeout_minutes(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Timeout in minutes.
        """
        return pulumi.get(self, "timeout_minutes")

    @timeout_minutes.setter
    def timeout_minutes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout_minutes", value)

    @_builtins.property
    @pulumi.getter
    def ungraceful(self) -> Optional[pulumi.Input['PlanWorkflowStepEcsCapacityIncreaseConfigUngracefulArgs']]:
        """
        Ungraceful behavior configuration. See Ungraceful Capacity below.
        """
        return pulumi.get(self, "ungraceful")

    @ungraceful.setter
    def ungraceful(self, value: Optional[pulumi.Input['PlanWorkflowStepEcsCapacityIncreaseConfigUngracefulArgs']]):
        pulumi.set(self, "ungraceful", value)


if not MYPY:
    class PlanWorkflowStepEcsCapacityIncreaseConfigServiceArgsDict(TypedDict):
        cluster_arn: pulumi.Input[_builtins.str]
        service_arn: pulumi.Input[_builtins.str]
        """
        ARN of the ECS service.
        """
        cross_account_role: NotRequired[pulumi.Input[_builtins.str]]
        external_id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PlanWorkflowStepEcsCapacityIncreaseConfigServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanWorkflowStepEcsCapacityIncreaseConfigServiceArgs:
    def __init__(__self__, *,
                 cluster_arn: pulumi.Input[_builtins.str],
                 service_arn: pulumi.Input[_builtins.str],
                 cross_account_role: Optional[pulumi.Input[_builtins.str]] = None,
                 external_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] service_arn: ARN of the ECS service.
        """
        pulumi.set(__self__, "cluster_arn", cluster_arn)
        pulumi.set(__self__, "service_arn", service_arn)
        if cross_account_role is not None:
            pulumi.set(__self__, "cross_account_role", cross_account_role)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)

    @_builtins.property
    @pulumi.getter(name="clusterArn")
    def cluster_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "cluster_arn")

    @cluster_arn.setter
    def cluster_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cluster_arn", value)

    @_builtins.property
    @pulumi.getter(name="serviceArn")
    def service_arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of the ECS service.
        """
        return pulumi.get(self, "service_arn")

    @service_arn.setter
    def service_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "service_arn", value)

    @_builtins.property
    @pulumi.getter(name="crossAccountRole")
    def cross_account_role(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "cross_account_role")

    @cross_account_role.setter
    def cross_account_role(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cross_account_role", value)

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "external_id", value)


if not MYPY:
    class PlanWorkflowStepEcsCapacityIncreaseConfigUngracefulArgsDict(TypedDict):
        minimum_success_percentage: pulumi.Input[_builtins.int]
        """
        Minimum success percentage required.
        """
elif False:
    PlanWorkflowStepEcsCapacityIncreaseConfigUngracefulArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanWorkflowStepEcsCapacityIncreaseConfigUngracefulArgs:
    def __init__(__self__, *,
                 minimum_success_percentage: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.int] minimum_success_percentage: Minimum success percentage required.
        """
        pulumi.set(__self__, "minimum_success_percentage", minimum_success_percentage)

    @_builtins.property
    @pulumi.getter(name="minimumSuccessPercentage")
    def minimum_success_percentage(self) -> pulumi.Input[_builtins.int]:
        """
        Minimum success percentage required.
        """
        return pulumi.get(self, "minimum_success_percentage")

    @minimum_success_percentage.setter
    def minimum_success_percentage(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "minimum_success_percentage", value)


if not MYPY:
    class PlanWorkflowStepEksResourceScalingConfigArgsDict(TypedDict):
        capacity_monitoring_approach: pulumi.Input[_builtins.str]
        """
        Capacity monitoring approach. Valid values: `sampledMaxInLast24Hours`, `autoscalingMaxInLast24Hours`.
        """
        target_percent: pulumi.Input[_builtins.int]
        """
        Target capacity percentage.
        """
        eks_clusters: NotRequired[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepEksResourceScalingConfigEksClusterArgsDict']]]]
        """
        List of EKS clusters. See EKS Clusters below.
        """
        kubernetes_resource_types: NotRequired[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepEksResourceScalingConfigKubernetesResourceTypeArgsDict']]]]
        """
        Kubernetes resource type. See Kubernetes Resource Type below.
        """
        scaling_resources: NotRequired[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepEksResourceScalingConfigScalingResourceArgsDict']]]]
        """
        List of scaling resources. See Scaling Resources below.
        """
        timeout_minutes: NotRequired[pulumi.Input[_builtins.int]]
        """
        Timeout in minutes.
        """
        ungracefuls: NotRequired[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepEksResourceScalingConfigUngracefulArgsDict']]]]
        """
        Ungraceful behavior configuration. See Ungraceful Capacity below.
        """
elif False:
    PlanWorkflowStepEksResourceScalingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanWorkflowStepEksResourceScalingConfigArgs:
    def __init__(__self__, *,
                 capacity_monitoring_approach: pulumi.Input[_builtins.str],
                 target_percent: pulumi.Input[_builtins.int],
                 eks_clusters: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepEksResourceScalingConfigEksClusterArgs']]]] = None,
                 kubernetes_resource_types: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepEksResourceScalingConfigKubernetesResourceTypeArgs']]]] = None,
                 scaling_resources: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepEksResourceScalingConfigScalingResourceArgs']]]] = None,
                 timeout_minutes: Optional[pulumi.Input[_builtins.int]] = None,
                 ungracefuls: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepEksResourceScalingConfigUngracefulArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] capacity_monitoring_approach: Capacity monitoring approach. Valid values: `sampledMaxInLast24Hours`, `autoscalingMaxInLast24Hours`.
        :param pulumi.Input[_builtins.int] target_percent: Target capacity percentage.
        :param pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepEksResourceScalingConfigEksClusterArgs']]] eks_clusters: List of EKS clusters. See EKS Clusters below.
        :param pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepEksResourceScalingConfigKubernetesResourceTypeArgs']]] kubernetes_resource_types: Kubernetes resource type. See Kubernetes Resource Type below.
        :param pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepEksResourceScalingConfigScalingResourceArgs']]] scaling_resources: List of scaling resources. See Scaling Resources below.
        :param pulumi.Input[_builtins.int] timeout_minutes: Timeout in minutes.
        :param pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepEksResourceScalingConfigUngracefulArgs']]] ungracefuls: Ungraceful behavior configuration. See Ungraceful Capacity below.
        """
        pulumi.set(__self__, "capacity_monitoring_approach", capacity_monitoring_approach)
        pulumi.set(__self__, "target_percent", target_percent)
        if eks_clusters is not None:
            pulumi.set(__self__, "eks_clusters", eks_clusters)
        if kubernetes_resource_types is not None:
            pulumi.set(__self__, "kubernetes_resource_types", kubernetes_resource_types)
        if scaling_resources is not None:
            pulumi.set(__self__, "scaling_resources", scaling_resources)
        if timeout_minutes is not None:
            pulumi.set(__self__, "timeout_minutes", timeout_minutes)
        if ungracefuls is not None:
            pulumi.set(__self__, "ungracefuls", ungracefuls)

    @_builtins.property
    @pulumi.getter(name="capacityMonitoringApproach")
    def capacity_monitoring_approach(self) -> pulumi.Input[_builtins.str]:
        """
        Capacity monitoring approach. Valid values: `sampledMaxInLast24Hours`, `autoscalingMaxInLast24Hours`.
        """
        return pulumi.get(self, "capacity_monitoring_approach")

    @capacity_monitoring_approach.setter
    def capacity_monitoring_approach(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "capacity_monitoring_approach", value)

    @_builtins.property
    @pulumi.getter(name="targetPercent")
    def target_percent(self) -> pulumi.Input[_builtins.int]:
        """
        Target capacity percentage.
        """
        return pulumi.get(self, "target_percent")

    @target_percent.setter
    def target_percent(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "target_percent", value)

    @_builtins.property
    @pulumi.getter(name="eksClusters")
    def eks_clusters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepEksResourceScalingConfigEksClusterArgs']]]]:
        """
        List of EKS clusters. See EKS Clusters below.
        """
        return pulumi.get(self, "eks_clusters")

    @eks_clusters.setter
    def eks_clusters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepEksResourceScalingConfigEksClusterArgs']]]]):
        pulumi.set(self, "eks_clusters", value)

    @_builtins.property
    @pulumi.getter(name="kubernetesResourceTypes")
    def kubernetes_resource_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepEksResourceScalingConfigKubernetesResourceTypeArgs']]]]:
        """
        Kubernetes resource type. See Kubernetes Resource Type below.
        """
        return pulumi.get(self, "kubernetes_resource_types")

    @kubernetes_resource_types.setter
    def kubernetes_resource_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepEksResourceScalingConfigKubernetesResourceTypeArgs']]]]):
        pulumi.set(self, "kubernetes_resource_types", value)

    @_builtins.property
    @pulumi.getter(name="scalingResources")
    def scaling_resources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepEksResourceScalingConfigScalingResourceArgs']]]]:
        """
        List of scaling resources. See Scaling Resources below.
        """
        return pulumi.get(self, "scaling_resources")

    @scaling_resources.setter
    def scaling_resources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepEksResourceScalingConfigScalingResourceArgs']]]]):
        pulumi.set(self, "scaling_resources", value)

    @_builtins.property
    @pulumi.getter(name="timeoutMinutes")
    def timeout_minutes(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Timeout in minutes.
        """
        return pulumi.get(self, "timeout_minutes")

    @timeout_minutes.setter
    def timeout_minutes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout_minutes", value)

    @_builtins.property
    @pulumi.getter
    def ungracefuls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepEksResourceScalingConfigUngracefulArgs']]]]:
        """
        Ungraceful behavior configuration. See Ungraceful Capacity below.
        """
        return pulumi.get(self, "ungracefuls")

    @ungracefuls.setter
    def ungracefuls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepEksResourceScalingConfigUngracefulArgs']]]]):
        pulumi.set(self, "ungracefuls", value)


if not MYPY:
    class PlanWorkflowStepEksResourceScalingConfigEksClusterArgsDict(TypedDict):
        cluster_arn: pulumi.Input[_builtins.str]
        """
        ARN of the EKS cluster.
        """
        cross_account_role: NotRequired[pulumi.Input[_builtins.str]]
        """
        ARN of the cross-account role to assume.
        """
        external_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        External ID for cross-account role assumption.
        """
elif False:
    PlanWorkflowStepEksResourceScalingConfigEksClusterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanWorkflowStepEksResourceScalingConfigEksClusterArgs:
    def __init__(__self__, *,
                 cluster_arn: pulumi.Input[_builtins.str],
                 cross_account_role: Optional[pulumi.Input[_builtins.str]] = None,
                 external_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] cluster_arn: ARN of the EKS cluster.
        :param pulumi.Input[_builtins.str] cross_account_role: ARN of the cross-account role to assume.
        :param pulumi.Input[_builtins.str] external_id: External ID for cross-account role assumption.
        """
        pulumi.set(__self__, "cluster_arn", cluster_arn)
        if cross_account_role is not None:
            pulumi.set(__self__, "cross_account_role", cross_account_role)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)

    @_builtins.property
    @pulumi.getter(name="clusterArn")
    def cluster_arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of the EKS cluster.
        """
        return pulumi.get(self, "cluster_arn")

    @cluster_arn.setter
    def cluster_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cluster_arn", value)

    @_builtins.property
    @pulumi.getter(name="crossAccountRole")
    def cross_account_role(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ARN of the cross-account role to assume.
        """
        return pulumi.get(self, "cross_account_role")

    @cross_account_role.setter
    def cross_account_role(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cross_account_role", value)

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        External ID for cross-account role assumption.
        """
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "external_id", value)


if not MYPY:
    class PlanWorkflowStepEksResourceScalingConfigKubernetesResourceTypeArgsDict(TypedDict):
        api_version: pulumi.Input[_builtins.str]
        """
        Kubernetes API version.
        """
        kind: pulumi.Input[_builtins.str]
        """
        Kubernetes resource kind.
        """
elif False:
    PlanWorkflowStepEksResourceScalingConfigKubernetesResourceTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanWorkflowStepEksResourceScalingConfigKubernetesResourceTypeArgs:
    def __init__(__self__, *,
                 api_version: pulumi.Input[_builtins.str],
                 kind: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] api_version: Kubernetes API version.
        :param pulumi.Input[_builtins.str] kind: Kubernetes resource kind.
        """
        pulumi.set(__self__, "api_version", api_version)
        pulumi.set(__self__, "kind", kind)

    @_builtins.property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> pulumi.Input[_builtins.str]:
        """
        Kubernetes API version.
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "api_version", value)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> pulumi.Input[_builtins.str]:
        """
        Kubernetes resource kind.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "kind", value)


if not MYPY:
    class PlanWorkflowStepEksResourceScalingConfigScalingResourceArgsDict(TypedDict):
        namespace: pulumi.Input[_builtins.str]
        """
        Kubernetes namespace.
        """
        resources: NotRequired[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepEksResourceScalingConfigScalingResourceResourceArgsDict']]]]
        """
        Set of resources to scale. See Resources below.
        """
elif False:
    PlanWorkflowStepEksResourceScalingConfigScalingResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanWorkflowStepEksResourceScalingConfigScalingResourceArgs:
    def __init__(__self__, *,
                 namespace: pulumi.Input[_builtins.str],
                 resources: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepEksResourceScalingConfigScalingResourceResourceArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] namespace: Kubernetes namespace.
        :param pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepEksResourceScalingConfigScalingResourceResourceArgs']]] resources: Set of resources to scale. See Resources below.
        """
        pulumi.set(__self__, "namespace", namespace)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[_builtins.str]:
        """
        Kubernetes namespace.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepEksResourceScalingConfigScalingResourceResourceArgs']]]]:
        """
        Set of resources to scale. See Resources below.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepEksResourceScalingConfigScalingResourceResourceArgs']]]]):
        pulumi.set(self, "resources", value)


if not MYPY:
    class PlanWorkflowStepEksResourceScalingConfigScalingResourceResourceArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name of the Kubernetes object.
        """
        namespace: pulumi.Input[_builtins.str]
        """
        Kubernetes namespace.
        """
        resource_name: pulumi.Input[_builtins.str]
        """
        Name of the resource.
        """
        hpa_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the Horizontal Pod Autoscaler.
        """
elif False:
    PlanWorkflowStepEksResourceScalingConfigScalingResourceResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanWorkflowStepEksResourceScalingConfigScalingResourceResourceArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 namespace: pulumi.Input[_builtins.str],
                 resource_name: pulumi.Input[_builtins.str],
                 hpa_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name of the Kubernetes object.
        :param pulumi.Input[_builtins.str] namespace: Kubernetes namespace.
        :param pulumi.Input[_builtins.str] resource_name: Name of the resource.
        :param pulumi.Input[_builtins.str] hpa_name: Name of the Horizontal Pod Autoscaler.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "resource_name", resource_name)
        if hpa_name is not None:
            pulumi.set(__self__, "hpa_name", hpa_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the Kubernetes object.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[_builtins.str]:
        """
        Kubernetes namespace.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the resource.
        """
        return pulumi.get(self, "resource_name")

    @resource_name.setter
    def resource_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "resource_name", value)

    @_builtins.property
    @pulumi.getter(name="hpaName")
    def hpa_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the Horizontal Pod Autoscaler.
        """
        return pulumi.get(self, "hpa_name")

    @hpa_name.setter
    def hpa_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hpa_name", value)


if not MYPY:
    class PlanWorkflowStepEksResourceScalingConfigUngracefulArgsDict(TypedDict):
        minimum_success_percentage: pulumi.Input[_builtins.int]
        """
        Minimum success percentage required.
        """
elif False:
    PlanWorkflowStepEksResourceScalingConfigUngracefulArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanWorkflowStepEksResourceScalingConfigUngracefulArgs:
    def __init__(__self__, *,
                 minimum_success_percentage: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.int] minimum_success_percentage: Minimum success percentage required.
        """
        pulumi.set(__self__, "minimum_success_percentage", minimum_success_percentage)

    @_builtins.property
    @pulumi.getter(name="minimumSuccessPercentage")
    def minimum_success_percentage(self) -> pulumi.Input[_builtins.int]:
        """
        Minimum success percentage required.
        """
        return pulumi.get(self, "minimum_success_percentage")

    @minimum_success_percentage.setter
    def minimum_success_percentage(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "minimum_success_percentage", value)


if not MYPY:
    class PlanWorkflowStepExecutionApprovalConfigArgsDict(TypedDict):
        approval_role: pulumi.Input[_builtins.str]
        """
        ARN of the IAM role for approval.
        """
        timeout_minutes: NotRequired[pulumi.Input[_builtins.int]]
        """
        Timeout in minutes for the approval.
        """
elif False:
    PlanWorkflowStepExecutionApprovalConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanWorkflowStepExecutionApprovalConfigArgs:
    def __init__(__self__, *,
                 approval_role: pulumi.Input[_builtins.str],
                 timeout_minutes: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] approval_role: ARN of the IAM role for approval.
        :param pulumi.Input[_builtins.int] timeout_minutes: Timeout in minutes for the approval.
        """
        pulumi.set(__self__, "approval_role", approval_role)
        if timeout_minutes is not None:
            pulumi.set(__self__, "timeout_minutes", timeout_minutes)

    @_builtins.property
    @pulumi.getter(name="approvalRole")
    def approval_role(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of the IAM role for approval.
        """
        return pulumi.get(self, "approval_role")

    @approval_role.setter
    def approval_role(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "approval_role", value)

    @_builtins.property
    @pulumi.getter(name="timeoutMinutes")
    def timeout_minutes(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Timeout in minutes for the approval.
        """
        return pulumi.get(self, "timeout_minutes")

    @timeout_minutes.setter
    def timeout_minutes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout_minutes", value)


if not MYPY:
    class PlanWorkflowStepGlobalAuroraConfigArgsDict(TypedDict):
        behavior: pulumi.Input[_builtins.str]
        """
        Behavior for Aurora operations. Valid values: `switchoverOnly`, `failover`.
        """
        database_cluster_arns: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List of database cluster ARNs.
        """
        global_cluster_identifier: pulumi.Input[_builtins.str]
        """
        Global cluster identifier.
        """
        cross_account_role: NotRequired[pulumi.Input[_builtins.str]]
        """
        ARN of the cross-account role to assume.
        """
        external_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        External ID for cross-account role assumption.
        """
        timeout_minutes: NotRequired[pulumi.Input[_builtins.int]]
        """
        Timeout in minutes.
        """
        ungracefuls: NotRequired[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepGlobalAuroraConfigUngracefulArgsDict']]]]
        """
        Ungraceful behavior configuration. See Ungraceful Aurora below.
        """
elif False:
    PlanWorkflowStepGlobalAuroraConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanWorkflowStepGlobalAuroraConfigArgs:
    def __init__(__self__, *,
                 behavior: pulumi.Input[_builtins.str],
                 database_cluster_arns: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 global_cluster_identifier: pulumi.Input[_builtins.str],
                 cross_account_role: Optional[pulumi.Input[_builtins.str]] = None,
                 external_id: Optional[pulumi.Input[_builtins.str]] = None,
                 timeout_minutes: Optional[pulumi.Input[_builtins.int]] = None,
                 ungracefuls: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepGlobalAuroraConfigUngracefulArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] behavior: Behavior for Aurora operations. Valid values: `switchoverOnly`, `failover`.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] database_cluster_arns: List of database cluster ARNs.
        :param pulumi.Input[_builtins.str] global_cluster_identifier: Global cluster identifier.
        :param pulumi.Input[_builtins.str] cross_account_role: ARN of the cross-account role to assume.
        :param pulumi.Input[_builtins.str] external_id: External ID for cross-account role assumption.
        :param pulumi.Input[_builtins.int] timeout_minutes: Timeout in minutes.
        :param pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepGlobalAuroraConfigUngracefulArgs']]] ungracefuls: Ungraceful behavior configuration. See Ungraceful Aurora below.
        """
        pulumi.set(__self__, "behavior", behavior)
        pulumi.set(__self__, "database_cluster_arns", database_cluster_arns)
        pulumi.set(__self__, "global_cluster_identifier", global_cluster_identifier)
        if cross_account_role is not None:
            pulumi.set(__self__, "cross_account_role", cross_account_role)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if timeout_minutes is not None:
            pulumi.set(__self__, "timeout_minutes", timeout_minutes)
        if ungracefuls is not None:
            pulumi.set(__self__, "ungracefuls", ungracefuls)

    @_builtins.property
    @pulumi.getter
    def behavior(self) -> pulumi.Input[_builtins.str]:
        """
        Behavior for Aurora operations. Valid values: `switchoverOnly`, `failover`.
        """
        return pulumi.get(self, "behavior")

    @behavior.setter
    def behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "behavior", value)

    @_builtins.property
    @pulumi.getter(name="databaseClusterArns")
    def database_cluster_arns(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List of database cluster ARNs.
        """
        return pulumi.get(self, "database_cluster_arns")

    @database_cluster_arns.setter
    def database_cluster_arns(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "database_cluster_arns", value)

    @_builtins.property
    @pulumi.getter(name="globalClusterIdentifier")
    def global_cluster_identifier(self) -> pulumi.Input[_builtins.str]:
        """
        Global cluster identifier.
        """
        return pulumi.get(self, "global_cluster_identifier")

    @global_cluster_identifier.setter
    def global_cluster_identifier(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "global_cluster_identifier", value)

    @_builtins.property
    @pulumi.getter(name="crossAccountRole")
    def cross_account_role(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ARN of the cross-account role to assume.
        """
        return pulumi.get(self, "cross_account_role")

    @cross_account_role.setter
    def cross_account_role(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cross_account_role", value)

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        External ID for cross-account role assumption.
        """
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "external_id", value)

    @_builtins.property
    @pulumi.getter(name="timeoutMinutes")
    def timeout_minutes(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Timeout in minutes.
        """
        return pulumi.get(self, "timeout_minutes")

    @timeout_minutes.setter
    def timeout_minutes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout_minutes", value)

    @_builtins.property
    @pulumi.getter
    def ungracefuls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepGlobalAuroraConfigUngracefulArgs']]]]:
        """
        Ungraceful behavior configuration. See Ungraceful Aurora below.
        """
        return pulumi.get(self, "ungracefuls")

    @ungracefuls.setter
    def ungracefuls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepGlobalAuroraConfigUngracefulArgs']]]]):
        pulumi.set(self, "ungracefuls", value)


if not MYPY:
    class PlanWorkflowStepGlobalAuroraConfigUngracefulArgsDict(TypedDict):
        ungraceful: pulumi.Input[_builtins.str]
elif False:
    PlanWorkflowStepGlobalAuroraConfigUngracefulArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanWorkflowStepGlobalAuroraConfigUngracefulArgs:
    def __init__(__self__, *,
                 ungraceful: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "ungraceful", ungraceful)

    @_builtins.property
    @pulumi.getter
    def ungraceful(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "ungraceful")

    @ungraceful.setter
    def ungraceful(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ungraceful", value)


if not MYPY:
    class PlanWorkflowStepParallelConfigArgsDict(TypedDict):
        steps: NotRequired[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepArgsDict']]]]
        """
        List of steps to execute in parallel. Uses the same schema as Step but without `parallel_config` to prevent infinite nesting.
        """
elif False:
    PlanWorkflowStepParallelConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanWorkflowStepParallelConfigArgs:
    def __init__(__self__, *,
                 steps: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepArgs']]] steps: List of steps to execute in parallel. Uses the same schema as Step but without `parallel_config` to prevent infinite nesting.
        """
        if steps is not None:
            pulumi.set(__self__, "steps", steps)

    @_builtins.property
    @pulumi.getter
    def steps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepArgs']]]]:
        """
        List of steps to execute in parallel. Uses the same schema as Step but without `parallel_config` to prevent infinite nesting.
        """
        return pulumi.get(self, "steps")

    @steps.setter
    def steps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepArgs']]]]):
        pulumi.set(self, "steps", value)


if not MYPY:
    class PlanWorkflowStepParallelConfigStepArgsDict(TypedDict):
        execution_block_type: pulumi.Input[_builtins.str]
        """
        Type of execution block. Valid values: `ARCRegionSwitchPlan`, `ARCRoutingControl`, `AuroraGlobalDatabase`, `CustomActionLambda`, `DocumentDb`, `EC2AutoScaling`, `ECSServiceScaling`, `EKSResourceScaling`, `ManualApproval`, `Parallel`, `Route53HealthCheck`.
        """
        name: pulumi.Input[_builtins.str]
        """
        Name of the step.
        """
        arc_routing_control_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepArcRoutingControlConfigArgsDict']]]]
        """
        Configuration for ARC routing control. See ARC Routing Control Config below.
        """
        custom_action_lambda_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepCustomActionLambdaConfigArgsDict']]]]
        """
        Configuration for Lambda function execution. See Custom Action Lambda Config below.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of the step.
        """
        document_db_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepDocumentDbConfigArgsDict']]]]
        """
        Configuration for DocumentDB global cluster operations. See DocumentDB Config below.
        """
        ec2_asg_capacity_increase_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepEc2AsgCapacityIncreaseConfigArgsDict']]]]
        """
        Configuration for EC2 Auto Scaling group capacity increase. See EC2 ASG Capacity Increase Config below.
        """
        ecs_capacity_increase_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepEcsCapacityIncreaseConfigArgsDict']]]]
        """
        Configuration for ECS service capacity increase. See ECS Capacity Increase Config below.
        """
        eks_resource_scaling_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepEksResourceScalingConfigArgsDict']]]]
        """
        Configuration for EKS resource scaling. See EKS Resource Scaling Config below.
        """
        execution_approval_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepExecutionApprovalConfigArgsDict']]]]
        """
        Configuration for manual approval steps. See Execution Approval Config below.
        """
        global_aurora_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepGlobalAuroraConfigArgsDict']]]]
        """
        Configuration for Aurora Global Database operations. See Global Aurora Config below.
        """
        region_switch_plan_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepRegionSwitchPlanConfigArgsDict']]]]
        route53_health_check_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepRoute53HealthCheckConfigArgsDict']]]]
        """
        Configuration for Route53 health check operations. See Route53 Health Check Config below.
        """
elif False:
    PlanWorkflowStepParallelConfigStepArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanWorkflowStepParallelConfigStepArgs:
    def __init__(__self__, *,
                 execution_block_type: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 arc_routing_control_configs: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepArcRoutingControlConfigArgs']]]] = None,
                 custom_action_lambda_configs: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepCustomActionLambdaConfigArgs']]]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 document_db_configs: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepDocumentDbConfigArgs']]]] = None,
                 ec2_asg_capacity_increase_configs: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepEc2AsgCapacityIncreaseConfigArgs']]]] = None,
                 ecs_capacity_increase_configs: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepEcsCapacityIncreaseConfigArgs']]]] = None,
                 eks_resource_scaling_configs: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepEksResourceScalingConfigArgs']]]] = None,
                 execution_approval_configs: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepExecutionApprovalConfigArgs']]]] = None,
                 global_aurora_configs: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepGlobalAuroraConfigArgs']]]] = None,
                 region_switch_plan_configs: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepRegionSwitchPlanConfigArgs']]]] = None,
                 route53_health_check_configs: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepRoute53HealthCheckConfigArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] execution_block_type: Type of execution block. Valid values: `ARCRegionSwitchPlan`, `ARCRoutingControl`, `AuroraGlobalDatabase`, `CustomActionLambda`, `DocumentDb`, `EC2AutoScaling`, `ECSServiceScaling`, `EKSResourceScaling`, `ManualApproval`, `Parallel`, `Route53HealthCheck`.
        :param pulumi.Input[_builtins.str] name: Name of the step.
        :param pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepArcRoutingControlConfigArgs']]] arc_routing_control_configs: Configuration for ARC routing control. See ARC Routing Control Config below.
        :param pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepCustomActionLambdaConfigArgs']]] custom_action_lambda_configs: Configuration for Lambda function execution. See Custom Action Lambda Config below.
        :param pulumi.Input[_builtins.str] description: Description of the step.
        :param pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepDocumentDbConfigArgs']]] document_db_configs: Configuration for DocumentDB global cluster operations. See DocumentDB Config below.
        :param pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepEc2AsgCapacityIncreaseConfigArgs']]] ec2_asg_capacity_increase_configs: Configuration for EC2 Auto Scaling group capacity increase. See EC2 ASG Capacity Increase Config below.
        :param pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepEcsCapacityIncreaseConfigArgs']]] ecs_capacity_increase_configs: Configuration for ECS service capacity increase. See ECS Capacity Increase Config below.
        :param pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepEksResourceScalingConfigArgs']]] eks_resource_scaling_configs: Configuration for EKS resource scaling. See EKS Resource Scaling Config below.
        :param pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepExecutionApprovalConfigArgs']]] execution_approval_configs: Configuration for manual approval steps. See Execution Approval Config below.
        :param pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepGlobalAuroraConfigArgs']]] global_aurora_configs: Configuration for Aurora Global Database operations. See Global Aurora Config below.
        :param pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepRoute53HealthCheckConfigArgs']]] route53_health_check_configs: Configuration for Route53 health check operations. See Route53 Health Check Config below.
        """
        pulumi.set(__self__, "execution_block_type", execution_block_type)
        pulumi.set(__self__, "name", name)
        if arc_routing_control_configs is not None:
            pulumi.set(__self__, "arc_routing_control_configs", arc_routing_control_configs)
        if custom_action_lambda_configs is not None:
            pulumi.set(__self__, "custom_action_lambda_configs", custom_action_lambda_configs)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if document_db_configs is not None:
            pulumi.set(__self__, "document_db_configs", document_db_configs)
        if ec2_asg_capacity_increase_configs is not None:
            pulumi.set(__self__, "ec2_asg_capacity_increase_configs", ec2_asg_capacity_increase_configs)
        if ecs_capacity_increase_configs is not None:
            pulumi.set(__self__, "ecs_capacity_increase_configs", ecs_capacity_increase_configs)
        if eks_resource_scaling_configs is not None:
            pulumi.set(__self__, "eks_resource_scaling_configs", eks_resource_scaling_configs)
        if execution_approval_configs is not None:
            pulumi.set(__self__, "execution_approval_configs", execution_approval_configs)
        if global_aurora_configs is not None:
            pulumi.set(__self__, "global_aurora_configs", global_aurora_configs)
        if region_switch_plan_configs is not None:
            pulumi.set(__self__, "region_switch_plan_configs", region_switch_plan_configs)
        if route53_health_check_configs is not None:
            pulumi.set(__self__, "route53_health_check_configs", route53_health_check_configs)

    @_builtins.property
    @pulumi.getter(name="executionBlockType")
    def execution_block_type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of execution block. Valid values: `ARCRegionSwitchPlan`, `ARCRoutingControl`, `AuroraGlobalDatabase`, `CustomActionLambda`, `DocumentDb`, `EC2AutoScaling`, `ECSServiceScaling`, `EKSResourceScaling`, `ManualApproval`, `Parallel`, `Route53HealthCheck`.
        """
        return pulumi.get(self, "execution_block_type")

    @execution_block_type.setter
    def execution_block_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "execution_block_type", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the step.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="arcRoutingControlConfigs")
    def arc_routing_control_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepArcRoutingControlConfigArgs']]]]:
        """
        Configuration for ARC routing control. See ARC Routing Control Config below.
        """
        return pulumi.get(self, "arc_routing_control_configs")

    @arc_routing_control_configs.setter
    def arc_routing_control_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepArcRoutingControlConfigArgs']]]]):
        pulumi.set(self, "arc_routing_control_configs", value)

    @_builtins.property
    @pulumi.getter(name="customActionLambdaConfigs")
    def custom_action_lambda_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepCustomActionLambdaConfigArgs']]]]:
        """
        Configuration for Lambda function execution. See Custom Action Lambda Config below.
        """
        return pulumi.get(self, "custom_action_lambda_configs")

    @custom_action_lambda_configs.setter
    def custom_action_lambda_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepCustomActionLambdaConfigArgs']]]]):
        pulumi.set(self, "custom_action_lambda_configs", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of the step.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="documentDbConfigs")
    def document_db_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepDocumentDbConfigArgs']]]]:
        """
        Configuration for DocumentDB global cluster operations. See DocumentDB Config below.
        """
        return pulumi.get(self, "document_db_configs")

    @document_db_configs.setter
    def document_db_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepDocumentDbConfigArgs']]]]):
        pulumi.set(self, "document_db_configs", value)

    @_builtins.property
    @pulumi.getter(name="ec2AsgCapacityIncreaseConfigs")
    def ec2_asg_capacity_increase_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepEc2AsgCapacityIncreaseConfigArgs']]]]:
        """
        Configuration for EC2 Auto Scaling group capacity increase. See EC2 ASG Capacity Increase Config below.
        """
        return pulumi.get(self, "ec2_asg_capacity_increase_configs")

    @ec2_asg_capacity_increase_configs.setter
    def ec2_asg_capacity_increase_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepEc2AsgCapacityIncreaseConfigArgs']]]]):
        pulumi.set(self, "ec2_asg_capacity_increase_configs", value)

    @_builtins.property
    @pulumi.getter(name="ecsCapacityIncreaseConfigs")
    def ecs_capacity_increase_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepEcsCapacityIncreaseConfigArgs']]]]:
        """
        Configuration for ECS service capacity increase. See ECS Capacity Increase Config below.
        """
        return pulumi.get(self, "ecs_capacity_increase_configs")

    @ecs_capacity_increase_configs.setter
    def ecs_capacity_increase_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepEcsCapacityIncreaseConfigArgs']]]]):
        pulumi.set(self, "ecs_capacity_increase_configs", value)

    @_builtins.property
    @pulumi.getter(name="eksResourceScalingConfigs")
    def eks_resource_scaling_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepEksResourceScalingConfigArgs']]]]:
        """
        Configuration for EKS resource scaling. See EKS Resource Scaling Config below.
        """
        return pulumi.get(self, "eks_resource_scaling_configs")

    @eks_resource_scaling_configs.setter
    def eks_resource_scaling_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepEksResourceScalingConfigArgs']]]]):
        pulumi.set(self, "eks_resource_scaling_configs", value)

    @_builtins.property
    @pulumi.getter(name="executionApprovalConfigs")
    def execution_approval_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepExecutionApprovalConfigArgs']]]]:
        """
        Configuration for manual approval steps. See Execution Approval Config below.
        """
        return pulumi.get(self, "execution_approval_configs")

    @execution_approval_configs.setter
    def execution_approval_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepExecutionApprovalConfigArgs']]]]):
        pulumi.set(self, "execution_approval_configs", value)

    @_builtins.property
    @pulumi.getter(name="globalAuroraConfigs")
    def global_aurora_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepGlobalAuroraConfigArgs']]]]:
        """
        Configuration for Aurora Global Database operations. See Global Aurora Config below.
        """
        return pulumi.get(self, "global_aurora_configs")

    @global_aurora_configs.setter
    def global_aurora_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepGlobalAuroraConfigArgs']]]]):
        pulumi.set(self, "global_aurora_configs", value)

    @_builtins.property
    @pulumi.getter(name="regionSwitchPlanConfigs")
    def region_switch_plan_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepRegionSwitchPlanConfigArgs']]]]:
        return pulumi.get(self, "region_switch_plan_configs")

    @region_switch_plan_configs.setter
    def region_switch_plan_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepRegionSwitchPlanConfigArgs']]]]):
        pulumi.set(self, "region_switch_plan_configs", value)

    @_builtins.property
    @pulumi.getter(name="route53HealthCheckConfigs")
    def route53_health_check_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepRoute53HealthCheckConfigArgs']]]]:
        """
        Configuration for Route53 health check operations. See Route53 Health Check Config below.
        """
        return pulumi.get(self, "route53_health_check_configs")

    @route53_health_check_configs.setter
    def route53_health_check_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepRoute53HealthCheckConfigArgs']]]]):
        pulumi.set(self, "route53_health_check_configs", value)


if not MYPY:
    class PlanWorkflowStepParallelConfigStepArcRoutingControlConfigArgsDict(TypedDict):
        cross_account_role: NotRequired[pulumi.Input[_builtins.str]]
        """
        ARN of the cross-account role to assume.
        """
        external_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        External ID for cross-account role assumption.
        """
        region_and_routing_controls: NotRequired[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepArcRoutingControlConfigRegionAndRoutingControlArgsDict']]]]
        """
        List of regions and their routing controls. See Region and Routing Controls below.
        """
        timeout_minutes: NotRequired[pulumi.Input[_builtins.int]]
        """
        Timeout in minutes.
        """
elif False:
    PlanWorkflowStepParallelConfigStepArcRoutingControlConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanWorkflowStepParallelConfigStepArcRoutingControlConfigArgs:
    def __init__(__self__, *,
                 cross_account_role: Optional[pulumi.Input[_builtins.str]] = None,
                 external_id: Optional[pulumi.Input[_builtins.str]] = None,
                 region_and_routing_controls: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepArcRoutingControlConfigRegionAndRoutingControlArgs']]]] = None,
                 timeout_minutes: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] cross_account_role: ARN of the cross-account role to assume.
        :param pulumi.Input[_builtins.str] external_id: External ID for cross-account role assumption.
        :param pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepArcRoutingControlConfigRegionAndRoutingControlArgs']]] region_and_routing_controls: List of regions and their routing controls. See Region and Routing Controls below.
        :param pulumi.Input[_builtins.int] timeout_minutes: Timeout in minutes.
        """
        if cross_account_role is not None:
            pulumi.set(__self__, "cross_account_role", cross_account_role)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if region_and_routing_controls is not None:
            pulumi.set(__self__, "region_and_routing_controls", region_and_routing_controls)
        if timeout_minutes is not None:
            pulumi.set(__self__, "timeout_minutes", timeout_minutes)

    @_builtins.property
    @pulumi.getter(name="crossAccountRole")
    def cross_account_role(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ARN of the cross-account role to assume.
        """
        return pulumi.get(self, "cross_account_role")

    @cross_account_role.setter
    def cross_account_role(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cross_account_role", value)

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        External ID for cross-account role assumption.
        """
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "external_id", value)

    @_builtins.property
    @pulumi.getter(name="regionAndRoutingControls")
    def region_and_routing_controls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepArcRoutingControlConfigRegionAndRoutingControlArgs']]]]:
        """
        List of regions and their routing controls. See Region and Routing Controls below.
        """
        return pulumi.get(self, "region_and_routing_controls")

    @region_and_routing_controls.setter
    def region_and_routing_controls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepArcRoutingControlConfigRegionAndRoutingControlArgs']]]]):
        pulumi.set(self, "region_and_routing_controls", value)

    @_builtins.property
    @pulumi.getter(name="timeoutMinutes")
    def timeout_minutes(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Timeout in minutes.
        """
        return pulumi.get(self, "timeout_minutes")

    @timeout_minutes.setter
    def timeout_minutes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout_minutes", value)


if not MYPY:
    class PlanWorkflowStepParallelConfigStepArcRoutingControlConfigRegionAndRoutingControlArgsDict(TypedDict):
        region: pulumi.Input[_builtins.str]
        """
        AWS region.
        """
        routing_controls: NotRequired[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepArcRoutingControlConfigRegionAndRoutingControlRoutingControlArgsDict']]]]
        """
        List of routing controls. See Routing Control below.
        """
elif False:
    PlanWorkflowStepParallelConfigStepArcRoutingControlConfigRegionAndRoutingControlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanWorkflowStepParallelConfigStepArcRoutingControlConfigRegionAndRoutingControlArgs:
    def __init__(__self__, *,
                 region: pulumi.Input[_builtins.str],
                 routing_controls: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepArcRoutingControlConfigRegionAndRoutingControlRoutingControlArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] region: AWS region.
        :param pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepArcRoutingControlConfigRegionAndRoutingControlRoutingControlArgs']]] routing_controls: List of routing controls. See Routing Control below.
        """
        pulumi.set(__self__, "region", region)
        if routing_controls is not None:
            pulumi.set(__self__, "routing_controls", routing_controls)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        AWS region.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="routingControls")
    def routing_controls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepArcRoutingControlConfigRegionAndRoutingControlRoutingControlArgs']]]]:
        """
        List of routing controls. See Routing Control below.
        """
        return pulumi.get(self, "routing_controls")

    @routing_controls.setter
    def routing_controls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepArcRoutingControlConfigRegionAndRoutingControlRoutingControlArgs']]]]):
        pulumi.set(self, "routing_controls", value)


if not MYPY:
    class PlanWorkflowStepParallelConfigStepArcRoutingControlConfigRegionAndRoutingControlRoutingControlArgsDict(TypedDict):
        routing_control_arn: pulumi.Input[_builtins.str]
        """
        ARN of the routing control.
        """
        state: pulumi.Input[_builtins.str]
        """
        State of the routing control. Valid values: `On`, `Off`.
        """
elif False:
    PlanWorkflowStepParallelConfigStepArcRoutingControlConfigRegionAndRoutingControlRoutingControlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanWorkflowStepParallelConfigStepArcRoutingControlConfigRegionAndRoutingControlRoutingControlArgs:
    def __init__(__self__, *,
                 routing_control_arn: pulumi.Input[_builtins.str],
                 state: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] routing_control_arn: ARN of the routing control.
        :param pulumi.Input[_builtins.str] state: State of the routing control. Valid values: `On`, `Off`.
        """
        pulumi.set(__self__, "routing_control_arn", routing_control_arn)
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="routingControlArn")
    def routing_control_arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of the routing control.
        """
        return pulumi.get(self, "routing_control_arn")

    @routing_control_arn.setter
    def routing_control_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "routing_control_arn", value)

    @_builtins.property
    @pulumi.getter
    def state(self) -> pulumi.Input[_builtins.str]:
        """
        State of the routing control. Valid values: `On`, `Off`.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "state", value)


if not MYPY:
    class PlanWorkflowStepParallelConfigStepCustomActionLambdaConfigArgsDict(TypedDict):
        region_to_run: pulumi.Input[_builtins.str]
        """
        Region where the Lambda function should run. Valid values: `activatingRegion`, `deactivatingRegion`.
        """
        retry_interval_minutes: pulumi.Input[_builtins.float]
        """
        Retry interval in minutes.
        """
        lambdas: NotRequired[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepCustomActionLambdaConfigLambdaArgsDict']]]]
        """
        Lambda function configuration. See Lambda below.
        """
        timeout_minutes: NotRequired[pulumi.Input[_builtins.int]]
        """
        Timeout in minutes.
        """
        ungracefuls: NotRequired[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepCustomActionLambdaConfigUngracefulArgsDict']]]]
        """
        Ungraceful behavior configuration. See Ungraceful below.
        """
elif False:
    PlanWorkflowStepParallelConfigStepCustomActionLambdaConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanWorkflowStepParallelConfigStepCustomActionLambdaConfigArgs:
    def __init__(__self__, *,
                 region_to_run: pulumi.Input[_builtins.str],
                 retry_interval_minutes: pulumi.Input[_builtins.float],
                 lambdas: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepCustomActionLambdaConfigLambdaArgs']]]] = None,
                 timeout_minutes: Optional[pulumi.Input[_builtins.int]] = None,
                 ungracefuls: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepCustomActionLambdaConfigUngracefulArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] region_to_run: Region where the Lambda function should run. Valid values: `activatingRegion`, `deactivatingRegion`.
        :param pulumi.Input[_builtins.float] retry_interval_minutes: Retry interval in minutes.
        :param pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepCustomActionLambdaConfigLambdaArgs']]] lambdas: Lambda function configuration. See Lambda below.
        :param pulumi.Input[_builtins.int] timeout_minutes: Timeout in minutes.
        :param pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepCustomActionLambdaConfigUngracefulArgs']]] ungracefuls: Ungraceful behavior configuration. See Ungraceful below.
        """
        pulumi.set(__self__, "region_to_run", region_to_run)
        pulumi.set(__self__, "retry_interval_minutes", retry_interval_minutes)
        if lambdas is not None:
            pulumi.set(__self__, "lambdas", lambdas)
        if timeout_minutes is not None:
            pulumi.set(__self__, "timeout_minutes", timeout_minutes)
        if ungracefuls is not None:
            pulumi.set(__self__, "ungracefuls", ungracefuls)

    @_builtins.property
    @pulumi.getter(name="regionToRun")
    def region_to_run(self) -> pulumi.Input[_builtins.str]:
        """
        Region where the Lambda function should run. Valid values: `activatingRegion`, `deactivatingRegion`.
        """
        return pulumi.get(self, "region_to_run")

    @region_to_run.setter
    def region_to_run(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region_to_run", value)

    @_builtins.property
    @pulumi.getter(name="retryIntervalMinutes")
    def retry_interval_minutes(self) -> pulumi.Input[_builtins.float]:
        """
        Retry interval in minutes.
        """
        return pulumi.get(self, "retry_interval_minutes")

    @retry_interval_minutes.setter
    def retry_interval_minutes(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "retry_interval_minutes", value)

    @_builtins.property
    @pulumi.getter
    def lambdas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepCustomActionLambdaConfigLambdaArgs']]]]:
        """
        Lambda function configuration. See Lambda below.
        """
        return pulumi.get(self, "lambdas")

    @lambdas.setter
    def lambdas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepCustomActionLambdaConfigLambdaArgs']]]]):
        pulumi.set(self, "lambdas", value)

    @_builtins.property
    @pulumi.getter(name="timeoutMinutes")
    def timeout_minutes(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Timeout in minutes.
        """
        return pulumi.get(self, "timeout_minutes")

    @timeout_minutes.setter
    def timeout_minutes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout_minutes", value)

    @_builtins.property
    @pulumi.getter
    def ungracefuls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepCustomActionLambdaConfigUngracefulArgs']]]]:
        """
        Ungraceful behavior configuration. See Ungraceful below.
        """
        return pulumi.get(self, "ungracefuls")

    @ungracefuls.setter
    def ungracefuls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepCustomActionLambdaConfigUngracefulArgs']]]]):
        pulumi.set(self, "ungracefuls", value)


if not MYPY:
    class PlanWorkflowStepParallelConfigStepCustomActionLambdaConfigLambdaArgsDict(TypedDict):
        arn: pulumi.Input[_builtins.str]
        """
        ARN of the Lambda function.
        """
        cross_account_role: NotRequired[pulumi.Input[_builtins.str]]
        """
        ARN of the cross-account role to assume.
        """
        external_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        External ID for cross-account role assumption.
        """
elif False:
    PlanWorkflowStepParallelConfigStepCustomActionLambdaConfigLambdaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanWorkflowStepParallelConfigStepCustomActionLambdaConfigLambdaArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[_builtins.str],
                 cross_account_role: Optional[pulumi.Input[_builtins.str]] = None,
                 external_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] arn: ARN of the Lambda function.
        :param pulumi.Input[_builtins.str] cross_account_role: ARN of the cross-account role to assume.
        :param pulumi.Input[_builtins.str] external_id: External ID for cross-account role assumption.
        """
        pulumi.set(__self__, "arn", arn)
        if cross_account_role is not None:
            pulumi.set(__self__, "cross_account_role", cross_account_role)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of the Lambda function.
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "arn", value)

    @_builtins.property
    @pulumi.getter(name="crossAccountRole")
    def cross_account_role(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ARN of the cross-account role to assume.
        """
        return pulumi.get(self, "cross_account_role")

    @cross_account_role.setter
    def cross_account_role(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cross_account_role", value)

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        External ID for cross-account role assumption.
        """
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "external_id", value)


if not MYPY:
    class PlanWorkflowStepParallelConfigStepCustomActionLambdaConfigUngracefulArgsDict(TypedDict):
        behavior: pulumi.Input[_builtins.str]
        """
        Behavior when ungraceful. Valid values: `skip`.
        """
elif False:
    PlanWorkflowStepParallelConfigStepCustomActionLambdaConfigUngracefulArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanWorkflowStepParallelConfigStepCustomActionLambdaConfigUngracefulArgs:
    def __init__(__self__, *,
                 behavior: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] behavior: Behavior when ungraceful. Valid values: `skip`.
        """
        pulumi.set(__self__, "behavior", behavior)

    @_builtins.property
    @pulumi.getter
    def behavior(self) -> pulumi.Input[_builtins.str]:
        """
        Behavior when ungraceful. Valid values: `skip`.
        """
        return pulumi.get(self, "behavior")

    @behavior.setter
    def behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "behavior", value)


if not MYPY:
    class PlanWorkflowStepParallelConfigStepDocumentDbConfigArgsDict(TypedDict):
        behavior: pulumi.Input[_builtins.str]
        database_cluster_arns: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        global_cluster_identifier: pulumi.Input[_builtins.str]
        cross_account_role: NotRequired[pulumi.Input[_builtins.str]]
        external_id: NotRequired[pulumi.Input[_builtins.str]]
        timeout_minutes: NotRequired[pulumi.Input[_builtins.int]]
        ungracefuls: NotRequired[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepDocumentDbConfigUngracefulArgsDict']]]]
elif False:
    PlanWorkflowStepParallelConfigStepDocumentDbConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanWorkflowStepParallelConfigStepDocumentDbConfigArgs:
    def __init__(__self__, *,
                 behavior: pulumi.Input[_builtins.str],
                 database_cluster_arns: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 global_cluster_identifier: pulumi.Input[_builtins.str],
                 cross_account_role: Optional[pulumi.Input[_builtins.str]] = None,
                 external_id: Optional[pulumi.Input[_builtins.str]] = None,
                 timeout_minutes: Optional[pulumi.Input[_builtins.int]] = None,
                 ungracefuls: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepDocumentDbConfigUngracefulArgs']]]] = None):
        pulumi.set(__self__, "behavior", behavior)
        pulumi.set(__self__, "database_cluster_arns", database_cluster_arns)
        pulumi.set(__self__, "global_cluster_identifier", global_cluster_identifier)
        if cross_account_role is not None:
            pulumi.set(__self__, "cross_account_role", cross_account_role)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if timeout_minutes is not None:
            pulumi.set(__self__, "timeout_minutes", timeout_minutes)
        if ungracefuls is not None:
            pulumi.set(__self__, "ungracefuls", ungracefuls)

    @_builtins.property
    @pulumi.getter
    def behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "behavior")

    @behavior.setter
    def behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "behavior", value)

    @_builtins.property
    @pulumi.getter(name="databaseClusterArns")
    def database_cluster_arns(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "database_cluster_arns")

    @database_cluster_arns.setter
    def database_cluster_arns(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "database_cluster_arns", value)

    @_builtins.property
    @pulumi.getter(name="globalClusterIdentifier")
    def global_cluster_identifier(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "global_cluster_identifier")

    @global_cluster_identifier.setter
    def global_cluster_identifier(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "global_cluster_identifier", value)

    @_builtins.property
    @pulumi.getter(name="crossAccountRole")
    def cross_account_role(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "cross_account_role")

    @cross_account_role.setter
    def cross_account_role(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cross_account_role", value)

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "external_id", value)

    @_builtins.property
    @pulumi.getter(name="timeoutMinutes")
    def timeout_minutes(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "timeout_minutes")

    @timeout_minutes.setter
    def timeout_minutes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout_minutes", value)

    @_builtins.property
    @pulumi.getter
    def ungracefuls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepDocumentDbConfigUngracefulArgs']]]]:
        return pulumi.get(self, "ungracefuls")

    @ungracefuls.setter
    def ungracefuls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepDocumentDbConfigUngracefulArgs']]]]):
        pulumi.set(self, "ungracefuls", value)


if not MYPY:
    class PlanWorkflowStepParallelConfigStepDocumentDbConfigUngracefulArgsDict(TypedDict):
        ungraceful: pulumi.Input[_builtins.str]
elif False:
    PlanWorkflowStepParallelConfigStepDocumentDbConfigUngracefulArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanWorkflowStepParallelConfigStepDocumentDbConfigUngracefulArgs:
    def __init__(__self__, *,
                 ungraceful: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "ungraceful", ungraceful)

    @_builtins.property
    @pulumi.getter
    def ungraceful(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "ungraceful")

    @ungraceful.setter
    def ungraceful(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ungraceful", value)


if not MYPY:
    class PlanWorkflowStepParallelConfigStepEc2AsgCapacityIncreaseConfigArgsDict(TypedDict):
        capacity_monitoring_approach: pulumi.Input[_builtins.str]
        """
        Capacity monitoring approach. Valid values: `sampledMaxInLast24Hours`, `autoscalingMaxInLast24Hours`.
        """
        asgs: NotRequired[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepEc2AsgCapacityIncreaseConfigAsgArgsDict']]]]
        """
        Auto Scaling group configuration. See ASG below.
        """
        target_percent: NotRequired[pulumi.Input[_builtins.int]]
        """
        Target capacity percentage.
        """
        timeout_minutes: NotRequired[pulumi.Input[_builtins.int]]
        """
        Timeout in minutes.
        """
        ungraceful: NotRequired[pulumi.Input['PlanWorkflowStepParallelConfigStepEc2AsgCapacityIncreaseConfigUngracefulArgsDict']]
        """
        Ungraceful behavior configuration. See Ungraceful below.
        """
elif False:
    PlanWorkflowStepParallelConfigStepEc2AsgCapacityIncreaseConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanWorkflowStepParallelConfigStepEc2AsgCapacityIncreaseConfigArgs:
    def __init__(__self__, *,
                 capacity_monitoring_approach: pulumi.Input[_builtins.str],
                 asgs: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepEc2AsgCapacityIncreaseConfigAsgArgs']]]] = None,
                 target_percent: Optional[pulumi.Input[_builtins.int]] = None,
                 timeout_minutes: Optional[pulumi.Input[_builtins.int]] = None,
                 ungraceful: Optional[pulumi.Input['PlanWorkflowStepParallelConfigStepEc2AsgCapacityIncreaseConfigUngracefulArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] capacity_monitoring_approach: Capacity monitoring approach. Valid values: `sampledMaxInLast24Hours`, `autoscalingMaxInLast24Hours`.
        :param pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepEc2AsgCapacityIncreaseConfigAsgArgs']]] asgs: Auto Scaling group configuration. See ASG below.
        :param pulumi.Input[_builtins.int] target_percent: Target capacity percentage.
        :param pulumi.Input[_builtins.int] timeout_minutes: Timeout in minutes.
        :param pulumi.Input['PlanWorkflowStepParallelConfigStepEc2AsgCapacityIncreaseConfigUngracefulArgs'] ungraceful: Ungraceful behavior configuration. See Ungraceful below.
        """
        pulumi.set(__self__, "capacity_monitoring_approach", capacity_monitoring_approach)
        if asgs is not None:
            pulumi.set(__self__, "asgs", asgs)
        if target_percent is not None:
            pulumi.set(__self__, "target_percent", target_percent)
        if timeout_minutes is not None:
            pulumi.set(__self__, "timeout_minutes", timeout_minutes)
        if ungraceful is not None:
            pulumi.set(__self__, "ungraceful", ungraceful)

    @_builtins.property
    @pulumi.getter(name="capacityMonitoringApproach")
    def capacity_monitoring_approach(self) -> pulumi.Input[_builtins.str]:
        """
        Capacity monitoring approach. Valid values: `sampledMaxInLast24Hours`, `autoscalingMaxInLast24Hours`.
        """
        return pulumi.get(self, "capacity_monitoring_approach")

    @capacity_monitoring_approach.setter
    def capacity_monitoring_approach(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "capacity_monitoring_approach", value)

    @_builtins.property
    @pulumi.getter
    def asgs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepEc2AsgCapacityIncreaseConfigAsgArgs']]]]:
        """
        Auto Scaling group configuration. See ASG below.
        """
        return pulumi.get(self, "asgs")

    @asgs.setter
    def asgs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepEc2AsgCapacityIncreaseConfigAsgArgs']]]]):
        pulumi.set(self, "asgs", value)

    @_builtins.property
    @pulumi.getter(name="targetPercent")
    def target_percent(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Target capacity percentage.
        """
        return pulumi.get(self, "target_percent")

    @target_percent.setter
    def target_percent(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "target_percent", value)

    @_builtins.property
    @pulumi.getter(name="timeoutMinutes")
    def timeout_minutes(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Timeout in minutes.
        """
        return pulumi.get(self, "timeout_minutes")

    @timeout_minutes.setter
    def timeout_minutes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout_minutes", value)

    @_builtins.property
    @pulumi.getter
    def ungraceful(self) -> Optional[pulumi.Input['PlanWorkflowStepParallelConfigStepEc2AsgCapacityIncreaseConfigUngracefulArgs']]:
        """
        Ungraceful behavior configuration. See Ungraceful below.
        """
        return pulumi.get(self, "ungraceful")

    @ungraceful.setter
    def ungraceful(self, value: Optional[pulumi.Input['PlanWorkflowStepParallelConfigStepEc2AsgCapacityIncreaseConfigUngracefulArgs']]):
        pulumi.set(self, "ungraceful", value)


if not MYPY:
    class PlanWorkflowStepParallelConfigStepEc2AsgCapacityIncreaseConfigAsgArgsDict(TypedDict):
        arn: pulumi.Input[_builtins.str]
        """
        ARN of the Auto Scaling group.
        """
        cross_account_role: NotRequired[pulumi.Input[_builtins.str]]
        """
        ARN of the cross-account role to assume.
        """
        external_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        External ID for cross-account role assumption.
        """
elif False:
    PlanWorkflowStepParallelConfigStepEc2AsgCapacityIncreaseConfigAsgArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanWorkflowStepParallelConfigStepEc2AsgCapacityIncreaseConfigAsgArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[_builtins.str],
                 cross_account_role: Optional[pulumi.Input[_builtins.str]] = None,
                 external_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] arn: ARN of the Auto Scaling group.
        :param pulumi.Input[_builtins.str] cross_account_role: ARN of the cross-account role to assume.
        :param pulumi.Input[_builtins.str] external_id: External ID for cross-account role assumption.
        """
        pulumi.set(__self__, "arn", arn)
        if cross_account_role is not None:
            pulumi.set(__self__, "cross_account_role", cross_account_role)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of the Auto Scaling group.
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "arn", value)

    @_builtins.property
    @pulumi.getter(name="crossAccountRole")
    def cross_account_role(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ARN of the cross-account role to assume.
        """
        return pulumi.get(self, "cross_account_role")

    @cross_account_role.setter
    def cross_account_role(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cross_account_role", value)

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        External ID for cross-account role assumption.
        """
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "external_id", value)


if not MYPY:
    class PlanWorkflowStepParallelConfigStepEc2AsgCapacityIncreaseConfigUngracefulArgsDict(TypedDict):
        minimum_success_percentage: pulumi.Input[_builtins.int]
        """
        Minimum success percentage required.
        """
elif False:
    PlanWorkflowStepParallelConfigStepEc2AsgCapacityIncreaseConfigUngracefulArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanWorkflowStepParallelConfigStepEc2AsgCapacityIncreaseConfigUngracefulArgs:
    def __init__(__self__, *,
                 minimum_success_percentage: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.int] minimum_success_percentage: Minimum success percentage required.
        """
        pulumi.set(__self__, "minimum_success_percentage", minimum_success_percentage)

    @_builtins.property
    @pulumi.getter(name="minimumSuccessPercentage")
    def minimum_success_percentage(self) -> pulumi.Input[_builtins.int]:
        """
        Minimum success percentage required.
        """
        return pulumi.get(self, "minimum_success_percentage")

    @minimum_success_percentage.setter
    def minimum_success_percentage(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "minimum_success_percentage", value)


if not MYPY:
    class PlanWorkflowStepParallelConfigStepEcsCapacityIncreaseConfigArgsDict(TypedDict):
        capacity_monitoring_approach: pulumi.Input[_builtins.str]
        """
        Capacity monitoring approach. Valid values: `sampledMaxInLast24Hours`, `containerInsightsMaxInLast24Hours`.
        """
        services: NotRequired[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepEcsCapacityIncreaseConfigServiceArgsDict']]]]
        """
        ECS service configuration. See ECS Service below.
        """
        target_percent: NotRequired[pulumi.Input[_builtins.int]]
        """
        Target capacity percentage.
        """
        timeout_minutes: NotRequired[pulumi.Input[_builtins.int]]
        """
        Timeout in minutes.
        """
        ungraceful: NotRequired[pulumi.Input['PlanWorkflowStepParallelConfigStepEcsCapacityIncreaseConfigUngracefulArgsDict']]
        """
        Ungraceful behavior configuration. See Ungraceful Capacity below.
        """
elif False:
    PlanWorkflowStepParallelConfigStepEcsCapacityIncreaseConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanWorkflowStepParallelConfigStepEcsCapacityIncreaseConfigArgs:
    def __init__(__self__, *,
                 capacity_monitoring_approach: pulumi.Input[_builtins.str],
                 services: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepEcsCapacityIncreaseConfigServiceArgs']]]] = None,
                 target_percent: Optional[pulumi.Input[_builtins.int]] = None,
                 timeout_minutes: Optional[pulumi.Input[_builtins.int]] = None,
                 ungraceful: Optional[pulumi.Input['PlanWorkflowStepParallelConfigStepEcsCapacityIncreaseConfigUngracefulArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] capacity_monitoring_approach: Capacity monitoring approach. Valid values: `sampledMaxInLast24Hours`, `containerInsightsMaxInLast24Hours`.
        :param pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepEcsCapacityIncreaseConfigServiceArgs']]] services: ECS service configuration. See ECS Service below.
        :param pulumi.Input[_builtins.int] target_percent: Target capacity percentage.
        :param pulumi.Input[_builtins.int] timeout_minutes: Timeout in minutes.
        :param pulumi.Input['PlanWorkflowStepParallelConfigStepEcsCapacityIncreaseConfigUngracefulArgs'] ungraceful: Ungraceful behavior configuration. See Ungraceful Capacity below.
        """
        pulumi.set(__self__, "capacity_monitoring_approach", capacity_monitoring_approach)
        if services is not None:
            pulumi.set(__self__, "services", services)
        if target_percent is not None:
            pulumi.set(__self__, "target_percent", target_percent)
        if timeout_minutes is not None:
            pulumi.set(__self__, "timeout_minutes", timeout_minutes)
        if ungraceful is not None:
            pulumi.set(__self__, "ungraceful", ungraceful)

    @_builtins.property
    @pulumi.getter(name="capacityMonitoringApproach")
    def capacity_monitoring_approach(self) -> pulumi.Input[_builtins.str]:
        """
        Capacity monitoring approach. Valid values: `sampledMaxInLast24Hours`, `containerInsightsMaxInLast24Hours`.
        """
        return pulumi.get(self, "capacity_monitoring_approach")

    @capacity_monitoring_approach.setter
    def capacity_monitoring_approach(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "capacity_monitoring_approach", value)

    @_builtins.property
    @pulumi.getter
    def services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepEcsCapacityIncreaseConfigServiceArgs']]]]:
        """
        ECS service configuration. See ECS Service below.
        """
        return pulumi.get(self, "services")

    @services.setter
    def services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepEcsCapacityIncreaseConfigServiceArgs']]]]):
        pulumi.set(self, "services", value)

    @_builtins.property
    @pulumi.getter(name="targetPercent")
    def target_percent(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Target capacity percentage.
        """
        return pulumi.get(self, "target_percent")

    @target_percent.setter
    def target_percent(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "target_percent", value)

    @_builtins.property
    @pulumi.getter(name="timeoutMinutes")
    def timeout_minutes(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Timeout in minutes.
        """
        return pulumi.get(self, "timeout_minutes")

    @timeout_minutes.setter
    def timeout_minutes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout_minutes", value)

    @_builtins.property
    @pulumi.getter
    def ungraceful(self) -> Optional[pulumi.Input['PlanWorkflowStepParallelConfigStepEcsCapacityIncreaseConfigUngracefulArgs']]:
        """
        Ungraceful behavior configuration. See Ungraceful Capacity below.
        """
        return pulumi.get(self, "ungraceful")

    @ungraceful.setter
    def ungraceful(self, value: Optional[pulumi.Input['PlanWorkflowStepParallelConfigStepEcsCapacityIncreaseConfigUngracefulArgs']]):
        pulumi.set(self, "ungraceful", value)


if not MYPY:
    class PlanWorkflowStepParallelConfigStepEcsCapacityIncreaseConfigServiceArgsDict(TypedDict):
        cluster_arn: pulumi.Input[_builtins.str]
        service_arn: pulumi.Input[_builtins.str]
        """
        ARN of the ECS service.
        """
        cross_account_role: NotRequired[pulumi.Input[_builtins.str]]
        external_id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PlanWorkflowStepParallelConfigStepEcsCapacityIncreaseConfigServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanWorkflowStepParallelConfigStepEcsCapacityIncreaseConfigServiceArgs:
    def __init__(__self__, *,
                 cluster_arn: pulumi.Input[_builtins.str],
                 service_arn: pulumi.Input[_builtins.str],
                 cross_account_role: Optional[pulumi.Input[_builtins.str]] = None,
                 external_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] service_arn: ARN of the ECS service.
        """
        pulumi.set(__self__, "cluster_arn", cluster_arn)
        pulumi.set(__self__, "service_arn", service_arn)
        if cross_account_role is not None:
            pulumi.set(__self__, "cross_account_role", cross_account_role)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)

    @_builtins.property
    @pulumi.getter(name="clusterArn")
    def cluster_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "cluster_arn")

    @cluster_arn.setter
    def cluster_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cluster_arn", value)

    @_builtins.property
    @pulumi.getter(name="serviceArn")
    def service_arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of the ECS service.
        """
        return pulumi.get(self, "service_arn")

    @service_arn.setter
    def service_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "service_arn", value)

    @_builtins.property
    @pulumi.getter(name="crossAccountRole")
    def cross_account_role(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "cross_account_role")

    @cross_account_role.setter
    def cross_account_role(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cross_account_role", value)

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "external_id", value)


if not MYPY:
    class PlanWorkflowStepParallelConfigStepEcsCapacityIncreaseConfigUngracefulArgsDict(TypedDict):
        minimum_success_percentage: pulumi.Input[_builtins.int]
        """
        Minimum success percentage required.
        """
elif False:
    PlanWorkflowStepParallelConfigStepEcsCapacityIncreaseConfigUngracefulArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanWorkflowStepParallelConfigStepEcsCapacityIncreaseConfigUngracefulArgs:
    def __init__(__self__, *,
                 minimum_success_percentage: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.int] minimum_success_percentage: Minimum success percentage required.
        """
        pulumi.set(__self__, "minimum_success_percentage", minimum_success_percentage)

    @_builtins.property
    @pulumi.getter(name="minimumSuccessPercentage")
    def minimum_success_percentage(self) -> pulumi.Input[_builtins.int]:
        """
        Minimum success percentage required.
        """
        return pulumi.get(self, "minimum_success_percentage")

    @minimum_success_percentage.setter
    def minimum_success_percentage(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "minimum_success_percentage", value)


if not MYPY:
    class PlanWorkflowStepParallelConfigStepEksResourceScalingConfigArgsDict(TypedDict):
        capacity_monitoring_approach: pulumi.Input[_builtins.str]
        """
        Capacity monitoring approach. Valid values: `sampledMaxInLast24Hours`, `autoscalingMaxInLast24Hours`.
        """
        target_percent: pulumi.Input[_builtins.int]
        """
        Target capacity percentage.
        """
        eks_clusters: NotRequired[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepEksResourceScalingConfigEksClusterArgsDict']]]]
        """
        List of EKS clusters. See EKS Clusters below.
        """
        kubernetes_resource_types: NotRequired[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepEksResourceScalingConfigKubernetesResourceTypeArgsDict']]]]
        """
        Kubernetes resource type. See Kubernetes Resource Type below.
        """
        scaling_resources: NotRequired[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepEksResourceScalingConfigScalingResourceArgsDict']]]]
        """
        List of scaling resources. See Scaling Resources below.
        """
        timeout_minutes: NotRequired[pulumi.Input[_builtins.int]]
        """
        Timeout in minutes.
        """
        ungracefuls: NotRequired[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepEksResourceScalingConfigUngracefulArgsDict']]]]
        """
        Ungraceful behavior configuration. See Ungraceful Capacity below.
        """
elif False:
    PlanWorkflowStepParallelConfigStepEksResourceScalingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanWorkflowStepParallelConfigStepEksResourceScalingConfigArgs:
    def __init__(__self__, *,
                 capacity_monitoring_approach: pulumi.Input[_builtins.str],
                 target_percent: pulumi.Input[_builtins.int],
                 eks_clusters: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepEksResourceScalingConfigEksClusterArgs']]]] = None,
                 kubernetes_resource_types: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepEksResourceScalingConfigKubernetesResourceTypeArgs']]]] = None,
                 scaling_resources: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepEksResourceScalingConfigScalingResourceArgs']]]] = None,
                 timeout_minutes: Optional[pulumi.Input[_builtins.int]] = None,
                 ungracefuls: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepEksResourceScalingConfigUngracefulArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] capacity_monitoring_approach: Capacity monitoring approach. Valid values: `sampledMaxInLast24Hours`, `autoscalingMaxInLast24Hours`.
        :param pulumi.Input[_builtins.int] target_percent: Target capacity percentage.
        :param pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepEksResourceScalingConfigEksClusterArgs']]] eks_clusters: List of EKS clusters. See EKS Clusters below.
        :param pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepEksResourceScalingConfigKubernetesResourceTypeArgs']]] kubernetes_resource_types: Kubernetes resource type. See Kubernetes Resource Type below.
        :param pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepEksResourceScalingConfigScalingResourceArgs']]] scaling_resources: List of scaling resources. See Scaling Resources below.
        :param pulumi.Input[_builtins.int] timeout_minutes: Timeout in minutes.
        :param pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepEksResourceScalingConfigUngracefulArgs']]] ungracefuls: Ungraceful behavior configuration. See Ungraceful Capacity below.
        """
        pulumi.set(__self__, "capacity_monitoring_approach", capacity_monitoring_approach)
        pulumi.set(__self__, "target_percent", target_percent)
        if eks_clusters is not None:
            pulumi.set(__self__, "eks_clusters", eks_clusters)
        if kubernetes_resource_types is not None:
            pulumi.set(__self__, "kubernetes_resource_types", kubernetes_resource_types)
        if scaling_resources is not None:
            pulumi.set(__self__, "scaling_resources", scaling_resources)
        if timeout_minutes is not None:
            pulumi.set(__self__, "timeout_minutes", timeout_minutes)
        if ungracefuls is not None:
            pulumi.set(__self__, "ungracefuls", ungracefuls)

    @_builtins.property
    @pulumi.getter(name="capacityMonitoringApproach")
    def capacity_monitoring_approach(self) -> pulumi.Input[_builtins.str]:
        """
        Capacity monitoring approach. Valid values: `sampledMaxInLast24Hours`, `autoscalingMaxInLast24Hours`.
        """
        return pulumi.get(self, "capacity_monitoring_approach")

    @capacity_monitoring_approach.setter
    def capacity_monitoring_approach(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "capacity_monitoring_approach", value)

    @_builtins.property
    @pulumi.getter(name="targetPercent")
    def target_percent(self) -> pulumi.Input[_builtins.int]:
        """
        Target capacity percentage.
        """
        return pulumi.get(self, "target_percent")

    @target_percent.setter
    def target_percent(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "target_percent", value)

    @_builtins.property
    @pulumi.getter(name="eksClusters")
    def eks_clusters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepEksResourceScalingConfigEksClusterArgs']]]]:
        """
        List of EKS clusters. See EKS Clusters below.
        """
        return pulumi.get(self, "eks_clusters")

    @eks_clusters.setter
    def eks_clusters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepEksResourceScalingConfigEksClusterArgs']]]]):
        pulumi.set(self, "eks_clusters", value)

    @_builtins.property
    @pulumi.getter(name="kubernetesResourceTypes")
    def kubernetes_resource_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepEksResourceScalingConfigKubernetesResourceTypeArgs']]]]:
        """
        Kubernetes resource type. See Kubernetes Resource Type below.
        """
        return pulumi.get(self, "kubernetes_resource_types")

    @kubernetes_resource_types.setter
    def kubernetes_resource_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepEksResourceScalingConfigKubernetesResourceTypeArgs']]]]):
        pulumi.set(self, "kubernetes_resource_types", value)

    @_builtins.property
    @pulumi.getter(name="scalingResources")
    def scaling_resources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepEksResourceScalingConfigScalingResourceArgs']]]]:
        """
        List of scaling resources. See Scaling Resources below.
        """
        return pulumi.get(self, "scaling_resources")

    @scaling_resources.setter
    def scaling_resources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepEksResourceScalingConfigScalingResourceArgs']]]]):
        pulumi.set(self, "scaling_resources", value)

    @_builtins.property
    @pulumi.getter(name="timeoutMinutes")
    def timeout_minutes(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Timeout in minutes.
        """
        return pulumi.get(self, "timeout_minutes")

    @timeout_minutes.setter
    def timeout_minutes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout_minutes", value)

    @_builtins.property
    @pulumi.getter
    def ungracefuls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepEksResourceScalingConfigUngracefulArgs']]]]:
        """
        Ungraceful behavior configuration. See Ungraceful Capacity below.
        """
        return pulumi.get(self, "ungracefuls")

    @ungracefuls.setter
    def ungracefuls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepEksResourceScalingConfigUngracefulArgs']]]]):
        pulumi.set(self, "ungracefuls", value)


if not MYPY:
    class PlanWorkflowStepParallelConfigStepEksResourceScalingConfigEksClusterArgsDict(TypedDict):
        cluster_arn: pulumi.Input[_builtins.str]
        """
        ARN of the EKS cluster.
        """
        cross_account_role: NotRequired[pulumi.Input[_builtins.str]]
        """
        ARN of the cross-account role to assume.
        """
        external_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        External ID for cross-account role assumption.
        """
elif False:
    PlanWorkflowStepParallelConfigStepEksResourceScalingConfigEksClusterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanWorkflowStepParallelConfigStepEksResourceScalingConfigEksClusterArgs:
    def __init__(__self__, *,
                 cluster_arn: pulumi.Input[_builtins.str],
                 cross_account_role: Optional[pulumi.Input[_builtins.str]] = None,
                 external_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] cluster_arn: ARN of the EKS cluster.
        :param pulumi.Input[_builtins.str] cross_account_role: ARN of the cross-account role to assume.
        :param pulumi.Input[_builtins.str] external_id: External ID for cross-account role assumption.
        """
        pulumi.set(__self__, "cluster_arn", cluster_arn)
        if cross_account_role is not None:
            pulumi.set(__self__, "cross_account_role", cross_account_role)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)

    @_builtins.property
    @pulumi.getter(name="clusterArn")
    def cluster_arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of the EKS cluster.
        """
        return pulumi.get(self, "cluster_arn")

    @cluster_arn.setter
    def cluster_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cluster_arn", value)

    @_builtins.property
    @pulumi.getter(name="crossAccountRole")
    def cross_account_role(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ARN of the cross-account role to assume.
        """
        return pulumi.get(self, "cross_account_role")

    @cross_account_role.setter
    def cross_account_role(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cross_account_role", value)

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        External ID for cross-account role assumption.
        """
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "external_id", value)


if not MYPY:
    class PlanWorkflowStepParallelConfigStepEksResourceScalingConfigKubernetesResourceTypeArgsDict(TypedDict):
        api_version: pulumi.Input[_builtins.str]
        """
        Kubernetes API version.
        """
        kind: pulumi.Input[_builtins.str]
        """
        Kubernetes resource kind.
        """
elif False:
    PlanWorkflowStepParallelConfigStepEksResourceScalingConfigKubernetesResourceTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanWorkflowStepParallelConfigStepEksResourceScalingConfigKubernetesResourceTypeArgs:
    def __init__(__self__, *,
                 api_version: pulumi.Input[_builtins.str],
                 kind: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] api_version: Kubernetes API version.
        :param pulumi.Input[_builtins.str] kind: Kubernetes resource kind.
        """
        pulumi.set(__self__, "api_version", api_version)
        pulumi.set(__self__, "kind", kind)

    @_builtins.property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> pulumi.Input[_builtins.str]:
        """
        Kubernetes API version.
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "api_version", value)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> pulumi.Input[_builtins.str]:
        """
        Kubernetes resource kind.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "kind", value)


if not MYPY:
    class PlanWorkflowStepParallelConfigStepEksResourceScalingConfigScalingResourceArgsDict(TypedDict):
        namespace: pulumi.Input[_builtins.str]
        """
        Kubernetes namespace.
        """
        resources: NotRequired[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepEksResourceScalingConfigScalingResourceResourceArgsDict']]]]
        """
        Set of resources to scale. See Resources below.
        """
elif False:
    PlanWorkflowStepParallelConfigStepEksResourceScalingConfigScalingResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanWorkflowStepParallelConfigStepEksResourceScalingConfigScalingResourceArgs:
    def __init__(__self__, *,
                 namespace: pulumi.Input[_builtins.str],
                 resources: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepEksResourceScalingConfigScalingResourceResourceArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] namespace: Kubernetes namespace.
        :param pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepEksResourceScalingConfigScalingResourceResourceArgs']]] resources: Set of resources to scale. See Resources below.
        """
        pulumi.set(__self__, "namespace", namespace)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[_builtins.str]:
        """
        Kubernetes namespace.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepEksResourceScalingConfigScalingResourceResourceArgs']]]]:
        """
        Set of resources to scale. See Resources below.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepEksResourceScalingConfigScalingResourceResourceArgs']]]]):
        pulumi.set(self, "resources", value)


if not MYPY:
    class PlanWorkflowStepParallelConfigStepEksResourceScalingConfigScalingResourceResourceArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name of the Kubernetes object.
        """
        namespace: pulumi.Input[_builtins.str]
        """
        Kubernetes namespace.
        """
        resource_name: pulumi.Input[_builtins.str]
        """
        Name of the resource.
        """
        hpa_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the Horizontal Pod Autoscaler.
        """
elif False:
    PlanWorkflowStepParallelConfigStepEksResourceScalingConfigScalingResourceResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanWorkflowStepParallelConfigStepEksResourceScalingConfigScalingResourceResourceArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 namespace: pulumi.Input[_builtins.str],
                 resource_name: pulumi.Input[_builtins.str],
                 hpa_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name of the Kubernetes object.
        :param pulumi.Input[_builtins.str] namespace: Kubernetes namespace.
        :param pulumi.Input[_builtins.str] resource_name: Name of the resource.
        :param pulumi.Input[_builtins.str] hpa_name: Name of the Horizontal Pod Autoscaler.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "resource_name", resource_name)
        if hpa_name is not None:
            pulumi.set(__self__, "hpa_name", hpa_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the Kubernetes object.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[_builtins.str]:
        """
        Kubernetes namespace.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the resource.
        """
        return pulumi.get(self, "resource_name")

    @resource_name.setter
    def resource_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "resource_name", value)

    @_builtins.property
    @pulumi.getter(name="hpaName")
    def hpa_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the Horizontal Pod Autoscaler.
        """
        return pulumi.get(self, "hpa_name")

    @hpa_name.setter
    def hpa_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hpa_name", value)


if not MYPY:
    class PlanWorkflowStepParallelConfigStepEksResourceScalingConfigUngracefulArgsDict(TypedDict):
        minimum_success_percentage: pulumi.Input[_builtins.int]
        """
        Minimum success percentage required.
        """
elif False:
    PlanWorkflowStepParallelConfigStepEksResourceScalingConfigUngracefulArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanWorkflowStepParallelConfigStepEksResourceScalingConfigUngracefulArgs:
    def __init__(__self__, *,
                 minimum_success_percentage: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.int] minimum_success_percentage: Minimum success percentage required.
        """
        pulumi.set(__self__, "minimum_success_percentage", minimum_success_percentage)

    @_builtins.property
    @pulumi.getter(name="minimumSuccessPercentage")
    def minimum_success_percentage(self) -> pulumi.Input[_builtins.int]:
        """
        Minimum success percentage required.
        """
        return pulumi.get(self, "minimum_success_percentage")

    @minimum_success_percentage.setter
    def minimum_success_percentage(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "minimum_success_percentage", value)


if not MYPY:
    class PlanWorkflowStepParallelConfigStepExecutionApprovalConfigArgsDict(TypedDict):
        approval_role: pulumi.Input[_builtins.str]
        """
        ARN of the IAM role for approval.
        """
        timeout_minutes: NotRequired[pulumi.Input[_builtins.int]]
        """
        Timeout in minutes for the approval.
        """
elif False:
    PlanWorkflowStepParallelConfigStepExecutionApprovalConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanWorkflowStepParallelConfigStepExecutionApprovalConfigArgs:
    def __init__(__self__, *,
                 approval_role: pulumi.Input[_builtins.str],
                 timeout_minutes: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] approval_role: ARN of the IAM role for approval.
        :param pulumi.Input[_builtins.int] timeout_minutes: Timeout in minutes for the approval.
        """
        pulumi.set(__self__, "approval_role", approval_role)
        if timeout_minutes is not None:
            pulumi.set(__self__, "timeout_minutes", timeout_minutes)

    @_builtins.property
    @pulumi.getter(name="approvalRole")
    def approval_role(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of the IAM role for approval.
        """
        return pulumi.get(self, "approval_role")

    @approval_role.setter
    def approval_role(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "approval_role", value)

    @_builtins.property
    @pulumi.getter(name="timeoutMinutes")
    def timeout_minutes(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Timeout in minutes for the approval.
        """
        return pulumi.get(self, "timeout_minutes")

    @timeout_minutes.setter
    def timeout_minutes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout_minutes", value)


if not MYPY:
    class PlanWorkflowStepParallelConfigStepGlobalAuroraConfigArgsDict(TypedDict):
        behavior: pulumi.Input[_builtins.str]
        """
        Behavior for Aurora operations. Valid values: `switchoverOnly`, `failover`.
        """
        database_cluster_arns: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List of database cluster ARNs.
        """
        global_cluster_identifier: pulumi.Input[_builtins.str]
        """
        Global cluster identifier.
        """
        cross_account_role: NotRequired[pulumi.Input[_builtins.str]]
        """
        ARN of the cross-account role to assume.
        """
        external_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        External ID for cross-account role assumption.
        """
        timeout_minutes: NotRequired[pulumi.Input[_builtins.int]]
        """
        Timeout in minutes.
        """
        ungracefuls: NotRequired[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepGlobalAuroraConfigUngracefulArgsDict']]]]
        """
        Ungraceful behavior configuration. See Ungraceful Aurora below.
        """
elif False:
    PlanWorkflowStepParallelConfigStepGlobalAuroraConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanWorkflowStepParallelConfigStepGlobalAuroraConfigArgs:
    def __init__(__self__, *,
                 behavior: pulumi.Input[_builtins.str],
                 database_cluster_arns: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 global_cluster_identifier: pulumi.Input[_builtins.str],
                 cross_account_role: Optional[pulumi.Input[_builtins.str]] = None,
                 external_id: Optional[pulumi.Input[_builtins.str]] = None,
                 timeout_minutes: Optional[pulumi.Input[_builtins.int]] = None,
                 ungracefuls: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepGlobalAuroraConfigUngracefulArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] behavior: Behavior for Aurora operations. Valid values: `switchoverOnly`, `failover`.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] database_cluster_arns: List of database cluster ARNs.
        :param pulumi.Input[_builtins.str] global_cluster_identifier: Global cluster identifier.
        :param pulumi.Input[_builtins.str] cross_account_role: ARN of the cross-account role to assume.
        :param pulumi.Input[_builtins.str] external_id: External ID for cross-account role assumption.
        :param pulumi.Input[_builtins.int] timeout_minutes: Timeout in minutes.
        :param pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepGlobalAuroraConfigUngracefulArgs']]] ungracefuls: Ungraceful behavior configuration. See Ungraceful Aurora below.
        """
        pulumi.set(__self__, "behavior", behavior)
        pulumi.set(__self__, "database_cluster_arns", database_cluster_arns)
        pulumi.set(__self__, "global_cluster_identifier", global_cluster_identifier)
        if cross_account_role is not None:
            pulumi.set(__self__, "cross_account_role", cross_account_role)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if timeout_minutes is not None:
            pulumi.set(__self__, "timeout_minutes", timeout_minutes)
        if ungracefuls is not None:
            pulumi.set(__self__, "ungracefuls", ungracefuls)

    @_builtins.property
    @pulumi.getter
    def behavior(self) -> pulumi.Input[_builtins.str]:
        """
        Behavior for Aurora operations. Valid values: `switchoverOnly`, `failover`.
        """
        return pulumi.get(self, "behavior")

    @behavior.setter
    def behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "behavior", value)

    @_builtins.property
    @pulumi.getter(name="databaseClusterArns")
    def database_cluster_arns(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List of database cluster ARNs.
        """
        return pulumi.get(self, "database_cluster_arns")

    @database_cluster_arns.setter
    def database_cluster_arns(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "database_cluster_arns", value)

    @_builtins.property
    @pulumi.getter(name="globalClusterIdentifier")
    def global_cluster_identifier(self) -> pulumi.Input[_builtins.str]:
        """
        Global cluster identifier.
        """
        return pulumi.get(self, "global_cluster_identifier")

    @global_cluster_identifier.setter
    def global_cluster_identifier(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "global_cluster_identifier", value)

    @_builtins.property
    @pulumi.getter(name="crossAccountRole")
    def cross_account_role(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ARN of the cross-account role to assume.
        """
        return pulumi.get(self, "cross_account_role")

    @cross_account_role.setter
    def cross_account_role(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cross_account_role", value)

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        External ID for cross-account role assumption.
        """
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "external_id", value)

    @_builtins.property
    @pulumi.getter(name="timeoutMinutes")
    def timeout_minutes(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Timeout in minutes.
        """
        return pulumi.get(self, "timeout_minutes")

    @timeout_minutes.setter
    def timeout_minutes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout_minutes", value)

    @_builtins.property
    @pulumi.getter
    def ungracefuls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepGlobalAuroraConfigUngracefulArgs']]]]:
        """
        Ungraceful behavior configuration. See Ungraceful Aurora below.
        """
        return pulumi.get(self, "ungracefuls")

    @ungracefuls.setter
    def ungracefuls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepGlobalAuroraConfigUngracefulArgs']]]]):
        pulumi.set(self, "ungracefuls", value)


if not MYPY:
    class PlanWorkflowStepParallelConfigStepGlobalAuroraConfigUngracefulArgsDict(TypedDict):
        ungraceful: pulumi.Input[_builtins.str]
elif False:
    PlanWorkflowStepParallelConfigStepGlobalAuroraConfigUngracefulArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanWorkflowStepParallelConfigStepGlobalAuroraConfigUngracefulArgs:
    def __init__(__self__, *,
                 ungraceful: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "ungraceful", ungraceful)

    @_builtins.property
    @pulumi.getter
    def ungraceful(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "ungraceful")

    @ungraceful.setter
    def ungraceful(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ungraceful", value)


if not MYPY:
    class PlanWorkflowStepParallelConfigStepRegionSwitchPlanConfigArgsDict(TypedDict):
        arn: pulumi.Input[_builtins.str]
        """
        ARN of the nested region switch plan.
        """
        cross_account_role: NotRequired[pulumi.Input[_builtins.str]]
        """
        ARN of the cross-account role to assume.
        """
        external_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        External ID for cross-account role assumption.
        """
elif False:
    PlanWorkflowStepParallelConfigStepRegionSwitchPlanConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanWorkflowStepParallelConfigStepRegionSwitchPlanConfigArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[_builtins.str],
                 cross_account_role: Optional[pulumi.Input[_builtins.str]] = None,
                 external_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] arn: ARN of the nested region switch plan.
        :param pulumi.Input[_builtins.str] cross_account_role: ARN of the cross-account role to assume.
        :param pulumi.Input[_builtins.str] external_id: External ID for cross-account role assumption.
        """
        pulumi.set(__self__, "arn", arn)
        if cross_account_role is not None:
            pulumi.set(__self__, "cross_account_role", cross_account_role)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of the nested region switch plan.
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "arn", value)

    @_builtins.property
    @pulumi.getter(name="crossAccountRole")
    def cross_account_role(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ARN of the cross-account role to assume.
        """
        return pulumi.get(self, "cross_account_role")

    @cross_account_role.setter
    def cross_account_role(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cross_account_role", value)

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        External ID for cross-account role assumption.
        """
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "external_id", value)


if not MYPY:
    class PlanWorkflowStepParallelConfigStepRoute53HealthCheckConfigArgsDict(TypedDict):
        hosted_zone_id: pulumi.Input[_builtins.str]
        """
        Route53 hosted zone ID.
        """
        record_name: pulumi.Input[_builtins.str]
        """
        DNS record name.
        """
        cross_account_role: NotRequired[pulumi.Input[_builtins.str]]
        """
        ARN of the cross-account role to assume.
        """
        external_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        External ID for cross-account role assumption.
        """
        record_sets: NotRequired[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepRoute53HealthCheckConfigRecordSetArgsDict']]]]
        """
        Configuration block for record sets. See Record Set below.
        """
        timeout_minutes: NotRequired[pulumi.Input[_builtins.int]]
        """
        Timeout in minutes.
        """
elif False:
    PlanWorkflowStepParallelConfigStepRoute53HealthCheckConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanWorkflowStepParallelConfigStepRoute53HealthCheckConfigArgs:
    def __init__(__self__, *,
                 hosted_zone_id: pulumi.Input[_builtins.str],
                 record_name: pulumi.Input[_builtins.str],
                 cross_account_role: Optional[pulumi.Input[_builtins.str]] = None,
                 external_id: Optional[pulumi.Input[_builtins.str]] = None,
                 record_sets: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepRoute53HealthCheckConfigRecordSetArgs']]]] = None,
                 timeout_minutes: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] hosted_zone_id: Route53 hosted zone ID.
        :param pulumi.Input[_builtins.str] record_name: DNS record name.
        :param pulumi.Input[_builtins.str] cross_account_role: ARN of the cross-account role to assume.
        :param pulumi.Input[_builtins.str] external_id: External ID for cross-account role assumption.
        :param pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepRoute53HealthCheckConfigRecordSetArgs']]] record_sets: Configuration block for record sets. See Record Set below.
        :param pulumi.Input[_builtins.int] timeout_minutes: Timeout in minutes.
        """
        pulumi.set(__self__, "hosted_zone_id", hosted_zone_id)
        pulumi.set(__self__, "record_name", record_name)
        if cross_account_role is not None:
            pulumi.set(__self__, "cross_account_role", cross_account_role)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if record_sets is not None:
            pulumi.set(__self__, "record_sets", record_sets)
        if timeout_minutes is not None:
            pulumi.set(__self__, "timeout_minutes", timeout_minutes)

    @_builtins.property
    @pulumi.getter(name="hostedZoneId")
    def hosted_zone_id(self) -> pulumi.Input[_builtins.str]:
        """
        Route53 hosted zone ID.
        """
        return pulumi.get(self, "hosted_zone_id")

    @hosted_zone_id.setter
    def hosted_zone_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hosted_zone_id", value)

    @_builtins.property
    @pulumi.getter(name="recordName")
    def record_name(self) -> pulumi.Input[_builtins.str]:
        """
        DNS record name.
        """
        return pulumi.get(self, "record_name")

    @record_name.setter
    def record_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "record_name", value)

    @_builtins.property
    @pulumi.getter(name="crossAccountRole")
    def cross_account_role(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ARN of the cross-account role to assume.
        """
        return pulumi.get(self, "cross_account_role")

    @cross_account_role.setter
    def cross_account_role(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cross_account_role", value)

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        External ID for cross-account role assumption.
        """
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "external_id", value)

    @_builtins.property
    @pulumi.getter(name="recordSets")
    def record_sets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepRoute53HealthCheckConfigRecordSetArgs']]]]:
        """
        Configuration block for record sets. See Record Set below.
        """
        return pulumi.get(self, "record_sets")

    @record_sets.setter
    def record_sets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepParallelConfigStepRoute53HealthCheckConfigRecordSetArgs']]]]):
        pulumi.set(self, "record_sets", value)

    @_builtins.property
    @pulumi.getter(name="timeoutMinutes")
    def timeout_minutes(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Timeout in minutes.
        """
        return pulumi.get(self, "timeout_minutes")

    @timeout_minutes.setter
    def timeout_minutes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout_minutes", value)


if not MYPY:
    class PlanWorkflowStepParallelConfigStepRoute53HealthCheckConfigRecordSetArgsDict(TypedDict):
        record_set_identifier: pulumi.Input[_builtins.str]
        """
        Record set identifier.
        """
        region: pulumi.Input[_builtins.str]
        """
        AWS region.
        """
elif False:
    PlanWorkflowStepParallelConfigStepRoute53HealthCheckConfigRecordSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanWorkflowStepParallelConfigStepRoute53HealthCheckConfigRecordSetArgs:
    def __init__(__self__, *,
                 record_set_identifier: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] record_set_identifier: Record set identifier.
        :param pulumi.Input[_builtins.str] region: AWS region.
        """
        pulumi.set(__self__, "record_set_identifier", record_set_identifier)
        pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter(name="recordSetIdentifier")
    def record_set_identifier(self) -> pulumi.Input[_builtins.str]:
        """
        Record set identifier.
        """
        return pulumi.get(self, "record_set_identifier")

    @record_set_identifier.setter
    def record_set_identifier(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "record_set_identifier", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        AWS region.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)


if not MYPY:
    class PlanWorkflowStepRegionSwitchPlanConfigArgsDict(TypedDict):
        arn: pulumi.Input[_builtins.str]
        """
        ARN of the nested region switch plan.
        """
        cross_account_role: NotRequired[pulumi.Input[_builtins.str]]
        """
        ARN of the cross-account role to assume.
        """
        external_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        External ID for cross-account role assumption.
        """
elif False:
    PlanWorkflowStepRegionSwitchPlanConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanWorkflowStepRegionSwitchPlanConfigArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[_builtins.str],
                 cross_account_role: Optional[pulumi.Input[_builtins.str]] = None,
                 external_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] arn: ARN of the nested region switch plan.
        :param pulumi.Input[_builtins.str] cross_account_role: ARN of the cross-account role to assume.
        :param pulumi.Input[_builtins.str] external_id: External ID for cross-account role assumption.
        """
        pulumi.set(__self__, "arn", arn)
        if cross_account_role is not None:
            pulumi.set(__self__, "cross_account_role", cross_account_role)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of the nested region switch plan.
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "arn", value)

    @_builtins.property
    @pulumi.getter(name="crossAccountRole")
    def cross_account_role(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ARN of the cross-account role to assume.
        """
        return pulumi.get(self, "cross_account_role")

    @cross_account_role.setter
    def cross_account_role(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cross_account_role", value)

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        External ID for cross-account role assumption.
        """
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "external_id", value)


if not MYPY:
    class PlanWorkflowStepRoute53HealthCheckConfigArgsDict(TypedDict):
        hosted_zone_id: pulumi.Input[_builtins.str]
        """
        Route53 hosted zone ID.
        """
        record_name: pulumi.Input[_builtins.str]
        """
        DNS record name.
        """
        cross_account_role: NotRequired[pulumi.Input[_builtins.str]]
        """
        ARN of the cross-account role to assume.
        """
        external_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        External ID for cross-account role assumption.
        """
        record_sets: NotRequired[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepRoute53HealthCheckConfigRecordSetArgsDict']]]]
        """
        Configuration block for record sets. See Record Set below.
        """
        timeout_minutes: NotRequired[pulumi.Input[_builtins.int]]
        """
        Timeout in minutes.
        """
elif False:
    PlanWorkflowStepRoute53HealthCheckConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanWorkflowStepRoute53HealthCheckConfigArgs:
    def __init__(__self__, *,
                 hosted_zone_id: pulumi.Input[_builtins.str],
                 record_name: pulumi.Input[_builtins.str],
                 cross_account_role: Optional[pulumi.Input[_builtins.str]] = None,
                 external_id: Optional[pulumi.Input[_builtins.str]] = None,
                 record_sets: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepRoute53HealthCheckConfigRecordSetArgs']]]] = None,
                 timeout_minutes: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] hosted_zone_id: Route53 hosted zone ID.
        :param pulumi.Input[_builtins.str] record_name: DNS record name.
        :param pulumi.Input[_builtins.str] cross_account_role: ARN of the cross-account role to assume.
        :param pulumi.Input[_builtins.str] external_id: External ID for cross-account role assumption.
        :param pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepRoute53HealthCheckConfigRecordSetArgs']]] record_sets: Configuration block for record sets. See Record Set below.
        :param pulumi.Input[_builtins.int] timeout_minutes: Timeout in minutes.
        """
        pulumi.set(__self__, "hosted_zone_id", hosted_zone_id)
        pulumi.set(__self__, "record_name", record_name)
        if cross_account_role is not None:
            pulumi.set(__self__, "cross_account_role", cross_account_role)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if record_sets is not None:
            pulumi.set(__self__, "record_sets", record_sets)
        if timeout_minutes is not None:
            pulumi.set(__self__, "timeout_minutes", timeout_minutes)

    @_builtins.property
    @pulumi.getter(name="hostedZoneId")
    def hosted_zone_id(self) -> pulumi.Input[_builtins.str]:
        """
        Route53 hosted zone ID.
        """
        return pulumi.get(self, "hosted_zone_id")

    @hosted_zone_id.setter
    def hosted_zone_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hosted_zone_id", value)

    @_builtins.property
    @pulumi.getter(name="recordName")
    def record_name(self) -> pulumi.Input[_builtins.str]:
        """
        DNS record name.
        """
        return pulumi.get(self, "record_name")

    @record_name.setter
    def record_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "record_name", value)

    @_builtins.property
    @pulumi.getter(name="crossAccountRole")
    def cross_account_role(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ARN of the cross-account role to assume.
        """
        return pulumi.get(self, "cross_account_role")

    @cross_account_role.setter
    def cross_account_role(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cross_account_role", value)

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        External ID for cross-account role assumption.
        """
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "external_id", value)

    @_builtins.property
    @pulumi.getter(name="recordSets")
    def record_sets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepRoute53HealthCheckConfigRecordSetArgs']]]]:
        """
        Configuration block for record sets. See Record Set below.
        """
        return pulumi.get(self, "record_sets")

    @record_sets.setter
    def record_sets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlanWorkflowStepRoute53HealthCheckConfigRecordSetArgs']]]]):
        pulumi.set(self, "record_sets", value)

    @_builtins.property
    @pulumi.getter(name="timeoutMinutes")
    def timeout_minutes(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Timeout in minutes.
        """
        return pulumi.get(self, "timeout_minutes")

    @timeout_minutes.setter
    def timeout_minutes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout_minutes", value)


if not MYPY:
    class PlanWorkflowStepRoute53HealthCheckConfigRecordSetArgsDict(TypedDict):
        record_set_identifier: pulumi.Input[_builtins.str]
        """
        Record set identifier.
        """
        region: pulumi.Input[_builtins.str]
        """
        AWS region.
        """
elif False:
    PlanWorkflowStepRoute53HealthCheckConfigRecordSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanWorkflowStepRoute53HealthCheckConfigRecordSetArgs:
    def __init__(__self__, *,
                 record_set_identifier: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] record_set_identifier: Record set identifier.
        :param pulumi.Input[_builtins.str] region: AWS region.
        """
        pulumi.set(__self__, "record_set_identifier", record_set_identifier)
        pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter(name="recordSetIdentifier")
    def record_set_identifier(self) -> pulumi.Input[_builtins.str]:
        """
        Record set identifier.
        """
        return pulumi.get(self, "record_set_identifier")

    @record_set_identifier.setter
    def record_set_identifier(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "record_set_identifier", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        AWS region.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)


