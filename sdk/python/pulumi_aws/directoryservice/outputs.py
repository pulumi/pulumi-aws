# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = [
    'DirectoryConnectSettings',
    'DirectoryVpcSettings',
    'ServiceRegionVpcSettings',
    'SharedDirectoryTarget',
    'GetDirectoryConnectSettingResult',
    'GetDirectoryRadiusSettingResult',
    'GetDirectoryVpcSettingResult',
]

@pulumi.output_type
class DirectoryConnectSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customerDnsIps":
            suggest = "customer_dns_ips"
        elif key == "customerUsername":
            suggest = "customer_username"
        elif key == "subnetIds":
            suggest = "subnet_ids"
        elif key == "vpcId":
            suggest = "vpc_id"
        elif key == "availabilityZones":
            suggest = "availability_zones"
        elif key == "connectIps":
            suggest = "connect_ips"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DirectoryConnectSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DirectoryConnectSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DirectoryConnectSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 customer_dns_ips: Sequence[str],
                 customer_username: str,
                 subnet_ids: Sequence[str],
                 vpc_id: str,
                 availability_zones: Optional[Sequence[str]] = None,
                 connect_ips: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] customer_dns_ips: The DNS IP addresses of the domain to connect to.
        :param str customer_username: The username corresponding to the password provided.
        :param Sequence[str] subnet_ids: The identifiers of the subnets for the directory servers (2 subnets in 2 different AZs).
        :param str vpc_id: The identifier of the VPC that the directory is in.
        :param Sequence[str] connect_ips: The IP addresses of the AD Connector servers.
        """
        DirectoryConnectSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            customer_dns_ips=customer_dns_ips,
            customer_username=customer_username,
            subnet_ids=subnet_ids,
            vpc_id=vpc_id,
            availability_zones=availability_zones,
            connect_ips=connect_ips,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             customer_dns_ips: Optional[Sequence[str]] = None,
             customer_username: Optional[str] = None,
             subnet_ids: Optional[Sequence[str]] = None,
             vpc_id: Optional[str] = None,
             availability_zones: Optional[Sequence[str]] = None,
             connect_ips: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if customer_dns_ips is None and 'customerDnsIps' in kwargs:
            customer_dns_ips = kwargs['customerDnsIps']
        if customer_dns_ips is None:
            raise TypeError("Missing 'customer_dns_ips' argument")
        if customer_username is None and 'customerUsername' in kwargs:
            customer_username = kwargs['customerUsername']
        if customer_username is None:
            raise TypeError("Missing 'customer_username' argument")
        if subnet_ids is None and 'subnetIds' in kwargs:
            subnet_ids = kwargs['subnetIds']
        if subnet_ids is None:
            raise TypeError("Missing 'subnet_ids' argument")
        if vpc_id is None and 'vpcId' in kwargs:
            vpc_id = kwargs['vpcId']
        if vpc_id is None:
            raise TypeError("Missing 'vpc_id' argument")
        if availability_zones is None and 'availabilityZones' in kwargs:
            availability_zones = kwargs['availabilityZones']
        if connect_ips is None and 'connectIps' in kwargs:
            connect_ips = kwargs['connectIps']

        _setter("customer_dns_ips", customer_dns_ips)
        _setter("customer_username", customer_username)
        _setter("subnet_ids", subnet_ids)
        _setter("vpc_id", vpc_id)
        if availability_zones is not None:
            _setter("availability_zones", availability_zones)
        if connect_ips is not None:
            _setter("connect_ips", connect_ips)

    @property
    @pulumi.getter(name="customerDnsIps")
    def customer_dns_ips(self) -> Sequence[str]:
        """
        The DNS IP addresses of the domain to connect to.
        """
        return pulumi.get(self, "customer_dns_ips")

    @property
    @pulumi.getter(name="customerUsername")
    def customer_username(self) -> str:
        """
        The username corresponding to the password provided.
        """
        return pulumi.get(self, "customer_username")

    @property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Sequence[str]:
        """
        The identifiers of the subnets for the directory servers (2 subnets in 2 different AZs).
        """
        return pulumi.get(self, "subnet_ids")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> str:
        """
        The identifier of the VPC that the directory is in.
        """
        return pulumi.get(self, "vpc_id")

    @property
    @pulumi.getter(name="availabilityZones")
    def availability_zones(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "availability_zones")

    @property
    @pulumi.getter(name="connectIps")
    def connect_ips(self) -> Optional[Sequence[str]]:
        """
        The IP addresses of the AD Connector servers.
        """
        return pulumi.get(self, "connect_ips")


@pulumi.output_type
class DirectoryVpcSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetIds":
            suggest = "subnet_ids"
        elif key == "vpcId":
            suggest = "vpc_id"
        elif key == "availabilityZones":
            suggest = "availability_zones"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DirectoryVpcSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DirectoryVpcSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DirectoryVpcSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subnet_ids: Sequence[str],
                 vpc_id: str,
                 availability_zones: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] subnet_ids: The identifiers of the subnets for the directory servers (2 subnets in 2 different AZs).
        :param str vpc_id: The identifier of the VPC that the directory is in.
        """
        DirectoryVpcSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            subnet_ids=subnet_ids,
            vpc_id=vpc_id,
            availability_zones=availability_zones,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             subnet_ids: Optional[Sequence[str]] = None,
             vpc_id: Optional[str] = None,
             availability_zones: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if subnet_ids is None and 'subnetIds' in kwargs:
            subnet_ids = kwargs['subnetIds']
        if subnet_ids is None:
            raise TypeError("Missing 'subnet_ids' argument")
        if vpc_id is None and 'vpcId' in kwargs:
            vpc_id = kwargs['vpcId']
        if vpc_id is None:
            raise TypeError("Missing 'vpc_id' argument")
        if availability_zones is None and 'availabilityZones' in kwargs:
            availability_zones = kwargs['availabilityZones']

        _setter("subnet_ids", subnet_ids)
        _setter("vpc_id", vpc_id)
        if availability_zones is not None:
            _setter("availability_zones", availability_zones)

    @property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Sequence[str]:
        """
        The identifiers of the subnets for the directory servers (2 subnets in 2 different AZs).
        """
        return pulumi.get(self, "subnet_ids")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> str:
        """
        The identifier of the VPC that the directory is in.
        """
        return pulumi.get(self, "vpc_id")

    @property
    @pulumi.getter(name="availabilityZones")
    def availability_zones(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "availability_zones")


@pulumi.output_type
class ServiceRegionVpcSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetIds":
            suggest = "subnet_ids"
        elif key == "vpcId":
            suggest = "vpc_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceRegionVpcSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceRegionVpcSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceRegionVpcSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subnet_ids: Sequence[str],
                 vpc_id: str):
        """
        :param Sequence[str] subnet_ids: The identifiers of the subnets for the directory servers.
        :param str vpc_id: The identifier of the VPC in which to create the directory.
        """
        ServiceRegionVpcSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            subnet_ids=subnet_ids,
            vpc_id=vpc_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             subnet_ids: Optional[Sequence[str]] = None,
             vpc_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if subnet_ids is None and 'subnetIds' in kwargs:
            subnet_ids = kwargs['subnetIds']
        if subnet_ids is None:
            raise TypeError("Missing 'subnet_ids' argument")
        if vpc_id is None and 'vpcId' in kwargs:
            vpc_id = kwargs['vpcId']
        if vpc_id is None:
            raise TypeError("Missing 'vpc_id' argument")

        _setter("subnet_ids", subnet_ids)
        _setter("vpc_id", vpc_id)

    @property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Sequence[str]:
        """
        The identifiers of the subnets for the directory servers.
        """
        return pulumi.get(self, "subnet_ids")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> str:
        """
        The identifier of the VPC in which to create the directory.
        """
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class SharedDirectoryTarget(dict):
    def __init__(__self__, *,
                 id: str,
                 type: Optional[str] = None):
        """
        :param str id: Identifier of the directory consumer account.
        :param str type: Type of identifier to be used in the `id` field. Valid value is `ACCOUNT`. Default is `ACCOUNT`.
        """
        SharedDirectoryTarget._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Identifier of the directory consumer account.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of identifier to be used in the `id` field. Valid value is `ACCOUNT`. Default is `ACCOUNT`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetDirectoryConnectSettingResult(dict):
    def __init__(__self__, *,
                 availability_zones: Sequence[str],
                 connect_ips: Sequence[str],
                 customer_dns_ips: Sequence[str],
                 customer_username: str,
                 subnet_ids: Sequence[str],
                 vpc_id: str):
        """
        :param Sequence[str] connect_ips: IP addresses of the AD Connector servers.
        :param Sequence[str] customer_dns_ips: DNS IP addresses of the domain to connect to.
        :param str customer_username: Username corresponding to the password provided.
        :param Sequence[str] subnet_ids: Identifiers of the subnets for the connector servers (2 subnets in 2 different AZs).
        :param str vpc_id: ID of the VPC that the connector is in.
        """
        GetDirectoryConnectSettingResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability_zones=availability_zones,
            connect_ips=connect_ips,
            customer_dns_ips=customer_dns_ips,
            customer_username=customer_username,
            subnet_ids=subnet_ids,
            vpc_id=vpc_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability_zones: Optional[Sequence[str]] = None,
             connect_ips: Optional[Sequence[str]] = None,
             customer_dns_ips: Optional[Sequence[str]] = None,
             customer_username: Optional[str] = None,
             subnet_ids: Optional[Sequence[str]] = None,
             vpc_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if availability_zones is None and 'availabilityZones' in kwargs:
            availability_zones = kwargs['availabilityZones']
        if availability_zones is None:
            raise TypeError("Missing 'availability_zones' argument")
        if connect_ips is None and 'connectIps' in kwargs:
            connect_ips = kwargs['connectIps']
        if connect_ips is None:
            raise TypeError("Missing 'connect_ips' argument")
        if customer_dns_ips is None and 'customerDnsIps' in kwargs:
            customer_dns_ips = kwargs['customerDnsIps']
        if customer_dns_ips is None:
            raise TypeError("Missing 'customer_dns_ips' argument")
        if customer_username is None and 'customerUsername' in kwargs:
            customer_username = kwargs['customerUsername']
        if customer_username is None:
            raise TypeError("Missing 'customer_username' argument")
        if subnet_ids is None and 'subnetIds' in kwargs:
            subnet_ids = kwargs['subnetIds']
        if subnet_ids is None:
            raise TypeError("Missing 'subnet_ids' argument")
        if vpc_id is None and 'vpcId' in kwargs:
            vpc_id = kwargs['vpcId']
        if vpc_id is None:
            raise TypeError("Missing 'vpc_id' argument")

        _setter("availability_zones", availability_zones)
        _setter("connect_ips", connect_ips)
        _setter("customer_dns_ips", customer_dns_ips)
        _setter("customer_username", customer_username)
        _setter("subnet_ids", subnet_ids)
        _setter("vpc_id", vpc_id)

    @property
    @pulumi.getter(name="availabilityZones")
    def availability_zones(self) -> Sequence[str]:
        return pulumi.get(self, "availability_zones")

    @property
    @pulumi.getter(name="connectIps")
    def connect_ips(self) -> Sequence[str]:
        """
        IP addresses of the AD Connector servers.
        """
        return pulumi.get(self, "connect_ips")

    @property
    @pulumi.getter(name="customerDnsIps")
    def customer_dns_ips(self) -> Sequence[str]:
        """
        DNS IP addresses of the domain to connect to.
        """
        return pulumi.get(self, "customer_dns_ips")

    @property
    @pulumi.getter(name="customerUsername")
    def customer_username(self) -> str:
        """
        Username corresponding to the password provided.
        """
        return pulumi.get(self, "customer_username")

    @property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Sequence[str]:
        """
        Identifiers of the subnets for the connector servers (2 subnets in 2 different AZs).
        """
        return pulumi.get(self, "subnet_ids")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> str:
        """
        ID of the VPC that the connector is in.
        """
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class GetDirectoryRadiusSettingResult(dict):
    def __init__(__self__, *,
                 authentication_protocol: str,
                 display_label: str,
                 radius_port: int,
                 radius_retries: int,
                 radius_servers: Sequence[str],
                 radius_timeout: int,
                 use_same_username: bool):
        """
        :param str authentication_protocol: The protocol specified for your RADIUS endpoints.
        :param str display_label: Display label.
        :param int radius_port: Port that your RADIUS server is using for communications.
        :param int radius_retries: Maximum number of times that communication with the RADIUS server is attempted.
        :param Sequence[str] radius_servers: Set of strings that contains the fully qualified domain name (FQDN) or IP addresses of the RADIUS server endpoints, or the FQDN or IP addresses of your RADIUS server load balancer.
        :param int radius_timeout: Amount of time, in seconds, to wait for the RADIUS server to respond.
        :param bool use_same_username: Not currently used.
        """
        GetDirectoryRadiusSettingResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            authentication_protocol=authentication_protocol,
            display_label=display_label,
            radius_port=radius_port,
            radius_retries=radius_retries,
            radius_servers=radius_servers,
            radius_timeout=radius_timeout,
            use_same_username=use_same_username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             authentication_protocol: Optional[str] = None,
             display_label: Optional[str] = None,
             radius_port: Optional[int] = None,
             radius_retries: Optional[int] = None,
             radius_servers: Optional[Sequence[str]] = None,
             radius_timeout: Optional[int] = None,
             use_same_username: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if authentication_protocol is None and 'authenticationProtocol' in kwargs:
            authentication_protocol = kwargs['authenticationProtocol']
        if authentication_protocol is None:
            raise TypeError("Missing 'authentication_protocol' argument")
        if display_label is None and 'displayLabel' in kwargs:
            display_label = kwargs['displayLabel']
        if display_label is None:
            raise TypeError("Missing 'display_label' argument")
        if radius_port is None and 'radiusPort' in kwargs:
            radius_port = kwargs['radiusPort']
        if radius_port is None:
            raise TypeError("Missing 'radius_port' argument")
        if radius_retries is None and 'radiusRetries' in kwargs:
            radius_retries = kwargs['radiusRetries']
        if radius_retries is None:
            raise TypeError("Missing 'radius_retries' argument")
        if radius_servers is None and 'radiusServers' in kwargs:
            radius_servers = kwargs['radiusServers']
        if radius_servers is None:
            raise TypeError("Missing 'radius_servers' argument")
        if radius_timeout is None and 'radiusTimeout' in kwargs:
            radius_timeout = kwargs['radiusTimeout']
        if radius_timeout is None:
            raise TypeError("Missing 'radius_timeout' argument")
        if use_same_username is None and 'useSameUsername' in kwargs:
            use_same_username = kwargs['useSameUsername']
        if use_same_username is None:
            raise TypeError("Missing 'use_same_username' argument")

        _setter("authentication_protocol", authentication_protocol)
        _setter("display_label", display_label)
        _setter("radius_port", radius_port)
        _setter("radius_retries", radius_retries)
        _setter("radius_servers", radius_servers)
        _setter("radius_timeout", radius_timeout)
        _setter("use_same_username", use_same_username)

    @property
    @pulumi.getter(name="authenticationProtocol")
    def authentication_protocol(self) -> str:
        """
        The protocol specified for your RADIUS endpoints.
        """
        return pulumi.get(self, "authentication_protocol")

    @property
    @pulumi.getter(name="displayLabel")
    def display_label(self) -> str:
        """
        Display label.
        """
        return pulumi.get(self, "display_label")

    @property
    @pulumi.getter(name="radiusPort")
    def radius_port(self) -> int:
        """
        Port that your RADIUS server is using for communications.
        """
        return pulumi.get(self, "radius_port")

    @property
    @pulumi.getter(name="radiusRetries")
    def radius_retries(self) -> int:
        """
        Maximum number of times that communication with the RADIUS server is attempted.
        """
        return pulumi.get(self, "radius_retries")

    @property
    @pulumi.getter(name="radiusServers")
    def radius_servers(self) -> Sequence[str]:
        """
        Set of strings that contains the fully qualified domain name (FQDN) or IP addresses of the RADIUS server endpoints, or the FQDN or IP addresses of your RADIUS server load balancer.
        """
        return pulumi.get(self, "radius_servers")

    @property
    @pulumi.getter(name="radiusTimeout")
    def radius_timeout(self) -> int:
        """
        Amount of time, in seconds, to wait for the RADIUS server to respond.
        """
        return pulumi.get(self, "radius_timeout")

    @property
    @pulumi.getter(name="useSameUsername")
    def use_same_username(self) -> bool:
        """
        Not currently used.
        """
        return pulumi.get(self, "use_same_username")


@pulumi.output_type
class GetDirectoryVpcSettingResult(dict):
    def __init__(__self__, *,
                 availability_zones: Sequence[str],
                 subnet_ids: Sequence[str],
                 vpc_id: str):
        """
        :param Sequence[str] subnet_ids: Identifiers of the subnets for the connector servers (2 subnets in 2 different AZs).
        :param str vpc_id: ID of the VPC that the connector is in.
        """
        GetDirectoryVpcSettingResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability_zones=availability_zones,
            subnet_ids=subnet_ids,
            vpc_id=vpc_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability_zones: Optional[Sequence[str]] = None,
             subnet_ids: Optional[Sequence[str]] = None,
             vpc_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if availability_zones is None and 'availabilityZones' in kwargs:
            availability_zones = kwargs['availabilityZones']
        if availability_zones is None:
            raise TypeError("Missing 'availability_zones' argument")
        if subnet_ids is None and 'subnetIds' in kwargs:
            subnet_ids = kwargs['subnetIds']
        if subnet_ids is None:
            raise TypeError("Missing 'subnet_ids' argument")
        if vpc_id is None and 'vpcId' in kwargs:
            vpc_id = kwargs['vpcId']
        if vpc_id is None:
            raise TypeError("Missing 'vpc_id' argument")

        _setter("availability_zones", availability_zones)
        _setter("subnet_ids", subnet_ids)
        _setter("vpc_id", vpc_id)

    @property
    @pulumi.getter(name="availabilityZones")
    def availability_zones(self) -> Sequence[str]:
        return pulumi.get(self, "availability_zones")

    @property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Sequence[str]:
        """
        Identifiers of the subnets for the connector servers (2 subnets in 2 different AZs).
        """
        return pulumi.get(self, "subnet_ids")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> str:
        """
        ID of the VPC that the connector is in.
        """
        return pulumi.get(self, "vpc_id")


