# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'ClusterMasterUserSecretArgs',
    'ClusterMasterUserSecretArgsDict',
    'ClusterParameterGroupParameterArgs',
    'ClusterParameterGroupParameterArgsDict',
    'ClusterRestoreToPointInTimeArgs',
    'ClusterRestoreToPointInTimeArgsDict',
    'ClusterS3ImportArgs',
    'ClusterS3ImportArgsDict',
    'ClusterScalingConfigurationArgs',
    'ClusterScalingConfigurationArgsDict',
    'ClusterServerlessv2ScalingConfigurationArgs',
    'ClusterServerlessv2ScalingConfigurationArgsDict',
    'ClusterSnapshotCopyTimeoutsArgs',
    'ClusterSnapshotCopyTimeoutsArgsDict',
    'ExportTaskTimeoutsArgs',
    'ExportTaskTimeoutsArgsDict',
    'GlobalClusterGlobalClusterMemberArgs',
    'GlobalClusterGlobalClusterMemberArgsDict',
    'InstanceBlueGreenUpdateArgs',
    'InstanceBlueGreenUpdateArgsDict',
    'InstanceDesiredStateTimeoutsArgs',
    'InstanceDesiredStateTimeoutsArgsDict',
    'InstanceListenerEndpointArgs',
    'InstanceListenerEndpointArgsDict',
    'InstanceMasterUserSecretArgs',
    'InstanceMasterUserSecretArgsDict',
    'InstanceRestoreToPointInTimeArgs',
    'InstanceRestoreToPointInTimeArgsDict',
    'InstanceS3ImportArgs',
    'InstanceS3ImportArgsDict',
    'IntegrationTimeoutsArgs',
    'IntegrationTimeoutsArgsDict',
    'OptionGroupOptionArgs',
    'OptionGroupOptionArgsDict',
    'OptionGroupOptionOptionSettingArgs',
    'OptionGroupOptionOptionSettingArgsDict',
    'ParameterGroupParameterArgs',
    'ParameterGroupParameterArgsDict',
    'ProxyAuthArgs',
    'ProxyAuthArgsDict',
    'ProxyDefaultTargetGroupConnectionPoolConfigArgs',
    'ProxyDefaultTargetGroupConnectionPoolConfigArgsDict',
    'ReservedInstanceRecurringChargeArgs',
    'ReservedInstanceRecurringChargeArgsDict',
    'ShardGroupTimeoutsArgs',
    'ShardGroupTimeoutsArgsDict',
    'GetClustersFilterArgs',
    'GetClustersFilterArgsDict',
    'GetEngineVersionFilterArgs',
    'GetEngineVersionFilterArgsDict',
    'GetInstancesFilterArgs',
    'GetInstancesFilterArgsDict',
]

MYPY = False

if not MYPY:
    class ClusterMasterUserSecretArgsDict(TypedDict):
        kms_key_id: NotRequired[pulumi.Input[_builtins.str]]
        secret_arn: NotRequired[pulumi.Input[_builtins.str]]
        secret_status: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ClusterMasterUserSecretArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterMasterUserSecretArgs:
    def __init__(__self__, *,
                 kms_key_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_status: Optional[pulumi.Input[_builtins.str]] = None):
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if secret_arn is not None:
            pulumi.set(__self__, "secret_arn", secret_arn)
        if secret_status is not None:
            pulumi.set(__self__, "secret_status", secret_status)

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kms_key_id", value)

    @_builtins.property
    @pulumi.getter(name="secretArn")
    def secret_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "secret_arn")

    @secret_arn.setter
    def secret_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_arn", value)

    @_builtins.property
    @pulumi.getter(name="secretStatus")
    def secret_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "secret_status")

    @secret_status.setter
    def secret_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_status", value)


if not MYPY:
    class ClusterParameterGroupParameterArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
        apply_method: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ClusterParameterGroupParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterParameterGroupParameterArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str],
                 apply_method: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)
        if apply_method is not None:
            pulumi.set(__self__, "apply_method", apply_method)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)

    @_builtins.property
    @pulumi.getter(name="applyMethod")
    def apply_method(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "apply_method")

    @apply_method.setter
    def apply_method(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "apply_method", value)


if not MYPY:
    class ClusterRestoreToPointInTimeArgsDict(TypedDict):
        restore_to_time: NotRequired[pulumi.Input[_builtins.str]]
        restore_type: NotRequired[pulumi.Input[_builtins.str]]
        source_cluster_identifier: NotRequired[pulumi.Input[_builtins.str]]
        source_cluster_resource_id: NotRequired[pulumi.Input[_builtins.str]]
        use_latest_restorable_time: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    ClusterRestoreToPointInTimeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRestoreToPointInTimeArgs:
    def __init__(__self__, *,
                 restore_to_time: Optional[pulumi.Input[_builtins.str]] = None,
                 restore_type: Optional[pulumi.Input[_builtins.str]] = None,
                 source_cluster_identifier: Optional[pulumi.Input[_builtins.str]] = None,
                 source_cluster_resource_id: Optional[pulumi.Input[_builtins.str]] = None,
                 use_latest_restorable_time: Optional[pulumi.Input[_builtins.bool]] = None):
        if restore_to_time is not None:
            pulumi.set(__self__, "restore_to_time", restore_to_time)
        if restore_type is not None:
            pulumi.set(__self__, "restore_type", restore_type)
        if source_cluster_identifier is not None:
            pulumi.set(__self__, "source_cluster_identifier", source_cluster_identifier)
        if source_cluster_resource_id is not None:
            pulumi.set(__self__, "source_cluster_resource_id", source_cluster_resource_id)
        if use_latest_restorable_time is not None:
            pulumi.set(__self__, "use_latest_restorable_time", use_latest_restorable_time)

    @_builtins.property
    @pulumi.getter(name="restoreToTime")
    def restore_to_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "restore_to_time")

    @restore_to_time.setter
    def restore_to_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "restore_to_time", value)

    @_builtins.property
    @pulumi.getter(name="restoreType")
    def restore_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "restore_type")

    @restore_type.setter
    def restore_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "restore_type", value)

    @_builtins.property
    @pulumi.getter(name="sourceClusterIdentifier")
    def source_cluster_identifier(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "source_cluster_identifier")

    @source_cluster_identifier.setter
    def source_cluster_identifier(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_cluster_identifier", value)

    @_builtins.property
    @pulumi.getter(name="sourceClusterResourceId")
    def source_cluster_resource_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "source_cluster_resource_id")

    @source_cluster_resource_id.setter
    def source_cluster_resource_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_cluster_resource_id", value)

    @_builtins.property
    @pulumi.getter(name="useLatestRestorableTime")
    def use_latest_restorable_time(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "use_latest_restorable_time")

    @use_latest_restorable_time.setter
    def use_latest_restorable_time(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_latest_restorable_time", value)


if not MYPY:
    class ClusterS3ImportArgsDict(TypedDict):
        bucket_name: pulumi.Input[_builtins.str]
        ingestion_role: pulumi.Input[_builtins.str]
        source_engine: pulumi.Input[_builtins.str]
        source_engine_version: pulumi.Input[_builtins.str]
        bucket_prefix: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ClusterS3ImportArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterS3ImportArgs:
    def __init__(__self__, *,
                 bucket_name: pulumi.Input[_builtins.str],
                 ingestion_role: pulumi.Input[_builtins.str],
                 source_engine: pulumi.Input[_builtins.str],
                 source_engine_version: pulumi.Input[_builtins.str],
                 bucket_prefix: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "ingestion_role", ingestion_role)
        pulumi.set(__self__, "source_engine", source_engine)
        pulumi.set(__self__, "source_engine_version", source_engine_version)
        if bucket_prefix is not None:
            pulumi.set(__self__, "bucket_prefix", bucket_prefix)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket_name", value)

    @_builtins.property
    @pulumi.getter(name="ingestionRole")
    def ingestion_role(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "ingestion_role")

    @ingestion_role.setter
    def ingestion_role(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ingestion_role", value)

    @_builtins.property
    @pulumi.getter(name="sourceEngine")
    def source_engine(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "source_engine")

    @source_engine.setter
    def source_engine(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source_engine", value)

    @_builtins.property
    @pulumi.getter(name="sourceEngineVersion")
    def source_engine_version(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "source_engine_version")

    @source_engine_version.setter
    def source_engine_version(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source_engine_version", value)

    @_builtins.property
    @pulumi.getter(name="bucketPrefix")
    def bucket_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "bucket_prefix")

    @bucket_prefix.setter
    def bucket_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket_prefix", value)


if not MYPY:
    class ClusterScalingConfigurationArgsDict(TypedDict):
        auto_pause: NotRequired[pulumi.Input[_builtins.bool]]
        max_capacity: NotRequired[pulumi.Input[_builtins.int]]
        min_capacity: NotRequired[pulumi.Input[_builtins.int]]
        seconds_before_timeout: NotRequired[pulumi.Input[_builtins.int]]
        seconds_until_auto_pause: NotRequired[pulumi.Input[_builtins.int]]
        timeout_action: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ClusterScalingConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterScalingConfigurationArgs:
    def __init__(__self__, *,
                 auto_pause: Optional[pulumi.Input[_builtins.bool]] = None,
                 max_capacity: Optional[pulumi.Input[_builtins.int]] = None,
                 min_capacity: Optional[pulumi.Input[_builtins.int]] = None,
                 seconds_before_timeout: Optional[pulumi.Input[_builtins.int]] = None,
                 seconds_until_auto_pause: Optional[pulumi.Input[_builtins.int]] = None,
                 timeout_action: Optional[pulumi.Input[_builtins.str]] = None):
        if auto_pause is not None:
            pulumi.set(__self__, "auto_pause", auto_pause)
        if max_capacity is not None:
            pulumi.set(__self__, "max_capacity", max_capacity)
        if min_capacity is not None:
            pulumi.set(__self__, "min_capacity", min_capacity)
        if seconds_before_timeout is not None:
            pulumi.set(__self__, "seconds_before_timeout", seconds_before_timeout)
        if seconds_until_auto_pause is not None:
            pulumi.set(__self__, "seconds_until_auto_pause", seconds_until_auto_pause)
        if timeout_action is not None:
            pulumi.set(__self__, "timeout_action", timeout_action)

    @_builtins.property
    @pulumi.getter(name="autoPause")
    def auto_pause(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "auto_pause")

    @auto_pause.setter
    def auto_pause(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "auto_pause", value)

    @_builtins.property
    @pulumi.getter(name="maxCapacity")
    def max_capacity(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "max_capacity")

    @max_capacity.setter
    def max_capacity(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_capacity", value)

    @_builtins.property
    @pulumi.getter(name="minCapacity")
    def min_capacity(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "min_capacity")

    @min_capacity.setter
    def min_capacity(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min_capacity", value)

    @_builtins.property
    @pulumi.getter(name="secondsBeforeTimeout")
    def seconds_before_timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "seconds_before_timeout")

    @seconds_before_timeout.setter
    def seconds_before_timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "seconds_before_timeout", value)

    @_builtins.property
    @pulumi.getter(name="secondsUntilAutoPause")
    def seconds_until_auto_pause(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "seconds_until_auto_pause")

    @seconds_until_auto_pause.setter
    def seconds_until_auto_pause(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "seconds_until_auto_pause", value)

    @_builtins.property
    @pulumi.getter(name="timeoutAction")
    def timeout_action(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "timeout_action")

    @timeout_action.setter
    def timeout_action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "timeout_action", value)


if not MYPY:
    class ClusterServerlessv2ScalingConfigurationArgsDict(TypedDict):
        max_capacity: pulumi.Input[_builtins.float]
        min_capacity: pulumi.Input[_builtins.float]
        seconds_until_auto_pause: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    ClusterServerlessv2ScalingConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterServerlessv2ScalingConfigurationArgs:
    def __init__(__self__, *,
                 max_capacity: pulumi.Input[_builtins.float],
                 min_capacity: pulumi.Input[_builtins.float],
                 seconds_until_auto_pause: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "max_capacity", max_capacity)
        pulumi.set(__self__, "min_capacity", min_capacity)
        if seconds_until_auto_pause is not None:
            pulumi.set(__self__, "seconds_until_auto_pause", seconds_until_auto_pause)

    @_builtins.property
    @pulumi.getter(name="maxCapacity")
    def max_capacity(self) -> pulumi.Input[_builtins.float]:
        return pulumi.get(self, "max_capacity")

    @max_capacity.setter
    def max_capacity(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "max_capacity", value)

    @_builtins.property
    @pulumi.getter(name="minCapacity")
    def min_capacity(self) -> pulumi.Input[_builtins.float]:
        return pulumi.get(self, "min_capacity")

    @min_capacity.setter
    def min_capacity(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "min_capacity", value)

    @_builtins.property
    @pulumi.getter(name="secondsUntilAutoPause")
    def seconds_until_auto_pause(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "seconds_until_auto_pause")

    @seconds_until_auto_pause.setter
    def seconds_until_auto_pause(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "seconds_until_auto_pause", value)


if not MYPY:
    class ClusterSnapshotCopyTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    ClusterSnapshotCopyTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterSnapshotCopyTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)


if not MYPY:
    class ExportTaskTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
elif False:
    ExportTaskTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExportTaskTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)


if not MYPY:
    class GlobalClusterGlobalClusterMemberArgsDict(TypedDict):
        db_cluster_arn: NotRequired[pulumi.Input[_builtins.str]]
        is_writer: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    GlobalClusterGlobalClusterMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GlobalClusterGlobalClusterMemberArgs:
    def __init__(__self__, *,
                 db_cluster_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 is_writer: Optional[pulumi.Input[_builtins.bool]] = None):
        if db_cluster_arn is not None:
            pulumi.set(__self__, "db_cluster_arn", db_cluster_arn)
        if is_writer is not None:
            pulumi.set(__self__, "is_writer", is_writer)

    @_builtins.property
    @pulumi.getter(name="dbClusterArn")
    def db_cluster_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "db_cluster_arn")

    @db_cluster_arn.setter
    def db_cluster_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "db_cluster_arn", value)

    @_builtins.property
    @pulumi.getter(name="isWriter")
    def is_writer(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "is_writer")

    @is_writer.setter
    def is_writer(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_writer", value)


if not MYPY:
    class InstanceBlueGreenUpdateArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    InstanceBlueGreenUpdateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceBlueGreenUpdateArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class InstanceDesiredStateTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    InstanceDesiredStateTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceDesiredStateTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class InstanceListenerEndpointArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[_builtins.str]]
        hosted_zone_id: NotRequired[pulumi.Input[_builtins.str]]
        port: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    InstanceListenerEndpointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceListenerEndpointArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[_builtins.str]] = None,
                 hosted_zone_id: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None):
        if address is not None:
            pulumi.set(__self__, "address", address)
        if hosted_zone_id is not None:
            pulumi.set(__self__, "hosted_zone_id", hosted_zone_id)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter(name="hostedZoneId")
    def hosted_zone_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "hosted_zone_id")

    @hosted_zone_id.setter
    def hosted_zone_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hosted_zone_id", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class InstanceMasterUserSecretArgsDict(TypedDict):
        kms_key_id: NotRequired[pulumi.Input[_builtins.str]]
        secret_arn: NotRequired[pulumi.Input[_builtins.str]]
        secret_status: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    InstanceMasterUserSecretArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceMasterUserSecretArgs:
    def __init__(__self__, *,
                 kms_key_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_status: Optional[pulumi.Input[_builtins.str]] = None):
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if secret_arn is not None:
            pulumi.set(__self__, "secret_arn", secret_arn)
        if secret_status is not None:
            pulumi.set(__self__, "secret_status", secret_status)

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kms_key_id", value)

    @_builtins.property
    @pulumi.getter(name="secretArn")
    def secret_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "secret_arn")

    @secret_arn.setter
    def secret_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_arn", value)

    @_builtins.property
    @pulumi.getter(name="secretStatus")
    def secret_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "secret_status")

    @secret_status.setter
    def secret_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_status", value)


if not MYPY:
    class InstanceRestoreToPointInTimeArgsDict(TypedDict):
        restore_time: NotRequired[pulumi.Input[_builtins.str]]
        source_db_instance_automated_backups_arn: NotRequired[pulumi.Input[_builtins.str]]
        source_db_instance_identifier: NotRequired[pulumi.Input[_builtins.str]]
        source_dbi_resource_id: NotRequired[pulumi.Input[_builtins.str]]
        use_latest_restorable_time: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    InstanceRestoreToPointInTimeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceRestoreToPointInTimeArgs:
    def __init__(__self__, *,
                 restore_time: Optional[pulumi.Input[_builtins.str]] = None,
                 source_db_instance_automated_backups_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 source_db_instance_identifier: Optional[pulumi.Input[_builtins.str]] = None,
                 source_dbi_resource_id: Optional[pulumi.Input[_builtins.str]] = None,
                 use_latest_restorable_time: Optional[pulumi.Input[_builtins.bool]] = None):
        if restore_time is not None:
            pulumi.set(__self__, "restore_time", restore_time)
        if source_db_instance_automated_backups_arn is not None:
            pulumi.set(__self__, "source_db_instance_automated_backups_arn", source_db_instance_automated_backups_arn)
        if source_db_instance_identifier is not None:
            pulumi.set(__self__, "source_db_instance_identifier", source_db_instance_identifier)
        if source_dbi_resource_id is not None:
            pulumi.set(__self__, "source_dbi_resource_id", source_dbi_resource_id)
        if use_latest_restorable_time is not None:
            pulumi.set(__self__, "use_latest_restorable_time", use_latest_restorable_time)

    @_builtins.property
    @pulumi.getter(name="restoreTime")
    def restore_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "restore_time")

    @restore_time.setter
    def restore_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "restore_time", value)

    @_builtins.property
    @pulumi.getter(name="sourceDbInstanceAutomatedBackupsArn")
    def source_db_instance_automated_backups_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "source_db_instance_automated_backups_arn")

    @source_db_instance_automated_backups_arn.setter
    def source_db_instance_automated_backups_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_db_instance_automated_backups_arn", value)

    @_builtins.property
    @pulumi.getter(name="sourceDbInstanceIdentifier")
    def source_db_instance_identifier(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "source_db_instance_identifier")

    @source_db_instance_identifier.setter
    def source_db_instance_identifier(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_db_instance_identifier", value)

    @_builtins.property
    @pulumi.getter(name="sourceDbiResourceId")
    def source_dbi_resource_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "source_dbi_resource_id")

    @source_dbi_resource_id.setter
    def source_dbi_resource_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_dbi_resource_id", value)

    @_builtins.property
    @pulumi.getter(name="useLatestRestorableTime")
    def use_latest_restorable_time(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "use_latest_restorable_time")

    @use_latest_restorable_time.setter
    def use_latest_restorable_time(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_latest_restorable_time", value)


if not MYPY:
    class InstanceS3ImportArgsDict(TypedDict):
        bucket_name: pulumi.Input[_builtins.str]
        ingestion_role: pulumi.Input[_builtins.str]
        source_engine: pulumi.Input[_builtins.str]
        source_engine_version: pulumi.Input[_builtins.str]
        bucket_prefix: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    InstanceS3ImportArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceS3ImportArgs:
    def __init__(__self__, *,
                 bucket_name: pulumi.Input[_builtins.str],
                 ingestion_role: pulumi.Input[_builtins.str],
                 source_engine: pulumi.Input[_builtins.str],
                 source_engine_version: pulumi.Input[_builtins.str],
                 bucket_prefix: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "ingestion_role", ingestion_role)
        pulumi.set(__self__, "source_engine", source_engine)
        pulumi.set(__self__, "source_engine_version", source_engine_version)
        if bucket_prefix is not None:
            pulumi.set(__self__, "bucket_prefix", bucket_prefix)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket_name", value)

    @_builtins.property
    @pulumi.getter(name="ingestionRole")
    def ingestion_role(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "ingestion_role")

    @ingestion_role.setter
    def ingestion_role(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ingestion_role", value)

    @_builtins.property
    @pulumi.getter(name="sourceEngine")
    def source_engine(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "source_engine")

    @source_engine.setter
    def source_engine(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source_engine", value)

    @_builtins.property
    @pulumi.getter(name="sourceEngineVersion")
    def source_engine_version(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "source_engine_version")

    @source_engine_version.setter
    def source_engine_version(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source_engine_version", value)

    @_builtins.property
    @pulumi.getter(name="bucketPrefix")
    def bucket_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "bucket_prefix")

    @bucket_prefix.setter
    def bucket_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket_prefix", value)


if not MYPY:
    class IntegrationTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
elif False:
    IntegrationTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)


if not MYPY:
    class OptionGroupOptionArgsDict(TypedDict):
        option_name: pulumi.Input[_builtins.str]
        db_security_group_memberships: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        option_settings: NotRequired[pulumi.Input[Sequence[pulumi.Input['OptionGroupOptionOptionSettingArgsDict']]]]
        port: NotRequired[pulumi.Input[_builtins.int]]
        version: NotRequired[pulumi.Input[_builtins.str]]
        vpc_security_group_memberships: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    OptionGroupOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OptionGroupOptionArgs:
    def __init__(__self__, *,
                 option_name: pulumi.Input[_builtins.str],
                 db_security_group_memberships: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 option_settings: Optional[pulumi.Input[Sequence[pulumi.Input['OptionGroupOptionOptionSettingArgs']]]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 version: Optional[pulumi.Input[_builtins.str]] = None,
                 vpc_security_group_memberships: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "option_name", option_name)
        if db_security_group_memberships is not None:
            pulumi.set(__self__, "db_security_group_memberships", db_security_group_memberships)
        if option_settings is not None:
            pulumi.set(__self__, "option_settings", option_settings)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if version is not None:
            pulumi.set(__self__, "version", version)
        if vpc_security_group_memberships is not None:
            pulumi.set(__self__, "vpc_security_group_memberships", vpc_security_group_memberships)

    @_builtins.property
    @pulumi.getter(name="optionName")
    def option_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "option_name")

    @option_name.setter
    def option_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "option_name", value)

    @_builtins.property
    @pulumi.getter(name="dbSecurityGroupMemberships")
    def db_security_group_memberships(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "db_security_group_memberships")

    @db_security_group_memberships.setter
    def db_security_group_memberships(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "db_security_group_memberships", value)

    @_builtins.property
    @pulumi.getter(name="optionSettings")
    def option_settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['OptionGroupOptionOptionSettingArgs']]]]:
        return pulumi.get(self, "option_settings")

    @option_settings.setter
    def option_settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['OptionGroupOptionOptionSettingArgs']]]]):
        pulumi.set(self, "option_settings", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "version", value)

    @_builtins.property
    @pulumi.getter(name="vpcSecurityGroupMemberships")
    def vpc_security_group_memberships(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "vpc_security_group_memberships")

    @vpc_security_group_memberships.setter
    def vpc_security_group_memberships(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "vpc_security_group_memberships", value)


if not MYPY:
    class OptionGroupOptionOptionSettingArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
elif False:
    OptionGroupOptionOptionSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OptionGroupOptionOptionSettingArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ParameterGroupParameterArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
        apply_method: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ParameterGroupParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ParameterGroupParameterArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str],
                 apply_method: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)
        if apply_method is None:
            apply_method = 'immediate'
        if apply_method is not None:
            pulumi.set(__self__, "apply_method", apply_method)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)

    @_builtins.property
    @pulumi.getter(name="applyMethod")
    def apply_method(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "apply_method")

    @apply_method.setter
    def apply_method(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "apply_method", value)


if not MYPY:
    class ProxyAuthArgsDict(TypedDict):
        auth_scheme: NotRequired[pulumi.Input[_builtins.str]]
        client_password_auth_type: NotRequired[pulumi.Input[_builtins.str]]
        description: NotRequired[pulumi.Input[_builtins.str]]
        iam_auth: NotRequired[pulumi.Input[_builtins.str]]
        secret_arn: NotRequired[pulumi.Input[_builtins.str]]
        username: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ProxyAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProxyAuthArgs:
    def __init__(__self__, *,
                 auth_scheme: Optional[pulumi.Input[_builtins.str]] = None,
                 client_password_auth_type: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 iam_auth: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        if auth_scheme is not None:
            pulumi.set(__self__, "auth_scheme", auth_scheme)
        if client_password_auth_type is not None:
            pulumi.set(__self__, "client_password_auth_type", client_password_auth_type)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if iam_auth is not None:
            pulumi.set(__self__, "iam_auth", iam_auth)
        if secret_arn is not None:
            pulumi.set(__self__, "secret_arn", secret_arn)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="authScheme")
    def auth_scheme(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "auth_scheme")

    @auth_scheme.setter
    def auth_scheme(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "auth_scheme", value)

    @_builtins.property
    @pulumi.getter(name="clientPasswordAuthType")
    def client_password_auth_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "client_password_auth_type")

    @client_password_auth_type.setter
    def client_password_auth_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_password_auth_type", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="iamAuth")
    def iam_auth(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "iam_auth")

    @iam_auth.setter
    def iam_auth(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "iam_auth", value)

    @_builtins.property
    @pulumi.getter(name="secretArn")
    def secret_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "secret_arn")

    @secret_arn.setter
    def secret_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_arn", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ProxyDefaultTargetGroupConnectionPoolConfigArgsDict(TypedDict):
        connection_borrow_timeout: NotRequired[pulumi.Input[_builtins.int]]
        init_query: NotRequired[pulumi.Input[_builtins.str]]
        max_connections_percent: NotRequired[pulumi.Input[_builtins.int]]
        max_idle_connections_percent: NotRequired[pulumi.Input[_builtins.int]]
        session_pinning_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    ProxyDefaultTargetGroupConnectionPoolConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProxyDefaultTargetGroupConnectionPoolConfigArgs:
    def __init__(__self__, *,
                 connection_borrow_timeout: Optional[pulumi.Input[_builtins.int]] = None,
                 init_query: Optional[pulumi.Input[_builtins.str]] = None,
                 max_connections_percent: Optional[pulumi.Input[_builtins.int]] = None,
                 max_idle_connections_percent: Optional[pulumi.Input[_builtins.int]] = None,
                 session_pinning_filters: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if connection_borrow_timeout is not None:
            pulumi.set(__self__, "connection_borrow_timeout", connection_borrow_timeout)
        if init_query is not None:
            pulumi.set(__self__, "init_query", init_query)
        if max_connections_percent is not None:
            pulumi.set(__self__, "max_connections_percent", max_connections_percent)
        if max_idle_connections_percent is not None:
            pulumi.set(__self__, "max_idle_connections_percent", max_idle_connections_percent)
        if session_pinning_filters is not None:
            pulumi.set(__self__, "session_pinning_filters", session_pinning_filters)

    @_builtins.property
    @pulumi.getter(name="connectionBorrowTimeout")
    def connection_borrow_timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "connection_borrow_timeout")

    @connection_borrow_timeout.setter
    def connection_borrow_timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "connection_borrow_timeout", value)

    @_builtins.property
    @pulumi.getter(name="initQuery")
    def init_query(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "init_query")

    @init_query.setter
    def init_query(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "init_query", value)

    @_builtins.property
    @pulumi.getter(name="maxConnectionsPercent")
    def max_connections_percent(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "max_connections_percent")

    @max_connections_percent.setter
    def max_connections_percent(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_connections_percent", value)

    @_builtins.property
    @pulumi.getter(name="maxIdleConnectionsPercent")
    def max_idle_connections_percent(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "max_idle_connections_percent")

    @max_idle_connections_percent.setter
    def max_idle_connections_percent(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_idle_connections_percent", value)

    @_builtins.property
    @pulumi.getter(name="sessionPinningFilters")
    def session_pinning_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "session_pinning_filters")

    @session_pinning_filters.setter
    def session_pinning_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "session_pinning_filters", value)


if not MYPY:
    class ReservedInstanceRecurringChargeArgsDict(TypedDict):
        recurring_charge_amount: NotRequired[pulumi.Input[_builtins.int]]
        recurring_charge_frequency: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ReservedInstanceRecurringChargeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReservedInstanceRecurringChargeArgs:
    def __init__(__self__, *,
                 recurring_charge_amount: Optional[pulumi.Input[_builtins.int]] = None,
                 recurring_charge_frequency: Optional[pulumi.Input[_builtins.str]] = None):
        if recurring_charge_amount is not None:
            pulumi.set(__self__, "recurring_charge_amount", recurring_charge_amount)
        if recurring_charge_frequency is not None:
            pulumi.set(__self__, "recurring_charge_frequency", recurring_charge_frequency)

    @_builtins.property
    @pulumi.getter(name="recurringChargeAmount")
    def recurring_charge_amount(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "recurring_charge_amount")

    @recurring_charge_amount.setter
    def recurring_charge_amount(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "recurring_charge_amount", value)

    @_builtins.property
    @pulumi.getter(name="recurringChargeFrequency")
    def recurring_charge_frequency(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "recurring_charge_frequency")

    @recurring_charge_frequency.setter
    def recurring_charge_frequency(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "recurring_charge_frequency", value)


if not MYPY:
    class ShardGroupTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    ShardGroupTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ShardGroupTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class GetClustersFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetClustersFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetClustersFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetEngineVersionFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetEngineVersionFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetEngineVersionFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetInstancesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetInstancesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetInstancesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


