# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'ConnectAttachmentOptionsArgs',
    'ConnectAttachmentOptionsArgsDict',
    'ConnectPeerBgpOptionsArgs',
    'ConnectPeerBgpOptionsArgsDict',
    'ConnectPeerConfigurationArgs',
    'ConnectPeerConfigurationArgsDict',
    'ConnectPeerConfigurationBgpConfigurationArgs',
    'ConnectPeerConfigurationBgpConfigurationArgsDict',
    'CoreNetworkEdgeArgs',
    'CoreNetworkEdgeArgsDict',
    'CoreNetworkSegmentArgs',
    'CoreNetworkSegmentArgsDict',
    'DeviceAwsLocationArgs',
    'DeviceAwsLocationArgsDict',
    'DeviceLocationArgs',
    'DeviceLocationArgsDict',
    'DxGatewayAttachmentTimeoutsArgs',
    'DxGatewayAttachmentTimeoutsArgsDict',
    'LinkBandwidthArgs',
    'LinkBandwidthArgsDict',
    'SiteLocationArgs',
    'SiteLocationArgsDict',
    'VpcAttachmentOptionsArgs',
    'VpcAttachmentOptionsArgsDict',
    'GetCoreNetworkPolicyDocumentAttachmentPolicyArgs',
    'GetCoreNetworkPolicyDocumentAttachmentPolicyArgsDict',
    'GetCoreNetworkPolicyDocumentAttachmentPolicyActionArgs',
    'GetCoreNetworkPolicyDocumentAttachmentPolicyActionArgsDict',
    'GetCoreNetworkPolicyDocumentAttachmentPolicyConditionArgs',
    'GetCoreNetworkPolicyDocumentAttachmentPolicyConditionArgsDict',
    'GetCoreNetworkPolicyDocumentAttachmentRoutingPolicyRuleArgs',
    'GetCoreNetworkPolicyDocumentAttachmentRoutingPolicyRuleArgsDict',
    'GetCoreNetworkPolicyDocumentAttachmentRoutingPolicyRuleActionArgs',
    'GetCoreNetworkPolicyDocumentAttachmentRoutingPolicyRuleActionArgsDict',
    'GetCoreNetworkPolicyDocumentAttachmentRoutingPolicyRuleConditionArgs',
    'GetCoreNetworkPolicyDocumentAttachmentRoutingPolicyRuleConditionArgsDict',
    'GetCoreNetworkPolicyDocumentCoreNetworkConfigurationArgs',
    'GetCoreNetworkPolicyDocumentCoreNetworkConfigurationArgsDict',
    'GetCoreNetworkPolicyDocumentCoreNetworkConfigurationEdgeLocationArgs',
    'GetCoreNetworkPolicyDocumentCoreNetworkConfigurationEdgeLocationArgsDict',
    'GetCoreNetworkPolicyDocumentNetworkFunctionGroupArgs',
    'GetCoreNetworkPolicyDocumentNetworkFunctionGroupArgsDict',
    'GetCoreNetworkPolicyDocumentRoutingPolicyArgs',
    'GetCoreNetworkPolicyDocumentRoutingPolicyArgsDict',
    'GetCoreNetworkPolicyDocumentRoutingPolicyRoutingPolicyRuleArgs',
    'GetCoreNetworkPolicyDocumentRoutingPolicyRoutingPolicyRuleArgsDict',
    'GetCoreNetworkPolicyDocumentRoutingPolicyRoutingPolicyRuleRuleDefinitionArgs',
    'GetCoreNetworkPolicyDocumentRoutingPolicyRoutingPolicyRuleRuleDefinitionArgsDict',
    'GetCoreNetworkPolicyDocumentRoutingPolicyRoutingPolicyRuleRuleDefinitionActionArgs',
    'GetCoreNetworkPolicyDocumentRoutingPolicyRoutingPolicyRuleRuleDefinitionActionArgsDict',
    'GetCoreNetworkPolicyDocumentRoutingPolicyRoutingPolicyRuleRuleDefinitionMatchConditionArgs',
    'GetCoreNetworkPolicyDocumentRoutingPolicyRoutingPolicyRuleRuleDefinitionMatchConditionArgsDict',
    'GetCoreNetworkPolicyDocumentSegmentArgs',
    'GetCoreNetworkPolicyDocumentSegmentArgsDict',
    'GetCoreNetworkPolicyDocumentSegmentActionArgs',
    'GetCoreNetworkPolicyDocumentSegmentActionArgsDict',
    'GetCoreNetworkPolicyDocumentSegmentActionEdgeLocationAssociationArgs',
    'GetCoreNetworkPolicyDocumentSegmentActionEdgeLocationAssociationArgsDict',
    'GetCoreNetworkPolicyDocumentSegmentActionViaArgs',
    'GetCoreNetworkPolicyDocumentSegmentActionViaArgsDict',
    'GetCoreNetworkPolicyDocumentSegmentActionViaWithEdgeOverrideArgs',
    'GetCoreNetworkPolicyDocumentSegmentActionViaWithEdgeOverrideArgsDict',
    'GetCoreNetworkPolicyDocumentSegmentActionWhenSentToArgs',
    'GetCoreNetworkPolicyDocumentSegmentActionWhenSentToArgsDict',
]

MYPY = False

if not MYPY:
    class ConnectAttachmentOptionsArgsDict(TypedDict):
        protocol: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ConnectAttachmentOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectAttachmentOptionsArgs:
    def __init__(__self__, *,
                 protocol: Optional[pulumi.Input[_builtins.str]] = None):
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)


if not MYPY:
    class ConnectPeerBgpOptionsArgsDict(TypedDict):
        peer_asn: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ConnectPeerBgpOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectPeerBgpOptionsArgs:
    def __init__(__self__, *,
                 peer_asn: Optional[pulumi.Input[_builtins.str]] = None):
        if peer_asn is not None:
            pulumi.set(__self__, "peer_asn", peer_asn)

    @_builtins.property
    @pulumi.getter(name="peerAsn")
    def peer_asn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "peer_asn")

    @peer_asn.setter
    def peer_asn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "peer_asn", value)


if not MYPY:
    class ConnectPeerConfigurationArgsDict(TypedDict):
        bgp_configurations: NotRequired[pulumi.Input[Sequence[pulumi.Input['ConnectPeerConfigurationBgpConfigurationArgsDict']]]]
        core_network_address: NotRequired[pulumi.Input[_builtins.str]]
        inside_cidr_blocks: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        peer_address: NotRequired[pulumi.Input[_builtins.str]]
        protocol: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ConnectPeerConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectPeerConfigurationArgs:
    def __init__(__self__, *,
                 bgp_configurations: Optional[pulumi.Input[Sequence[pulumi.Input['ConnectPeerConfigurationBgpConfigurationArgs']]]] = None,
                 core_network_address: Optional[pulumi.Input[_builtins.str]] = None,
                 inside_cidr_blocks: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 peer_address: Optional[pulumi.Input[_builtins.str]] = None,
                 protocol: Optional[pulumi.Input[_builtins.str]] = None):
        if bgp_configurations is not None:
            pulumi.set(__self__, "bgp_configurations", bgp_configurations)
        if core_network_address is not None:
            pulumi.set(__self__, "core_network_address", core_network_address)
        if inside_cidr_blocks is not None:
            pulumi.set(__self__, "inside_cidr_blocks", inside_cidr_blocks)
        if peer_address is not None:
            pulumi.set(__self__, "peer_address", peer_address)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter(name="bgpConfigurations")
    def bgp_configurations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ConnectPeerConfigurationBgpConfigurationArgs']]]]:
        return pulumi.get(self, "bgp_configurations")

    @bgp_configurations.setter
    def bgp_configurations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ConnectPeerConfigurationBgpConfigurationArgs']]]]):
        pulumi.set(self, "bgp_configurations", value)

    @_builtins.property
    @pulumi.getter(name="coreNetworkAddress")
    def core_network_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "core_network_address")

    @core_network_address.setter
    def core_network_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "core_network_address", value)

    @_builtins.property
    @pulumi.getter(name="insideCidrBlocks")
    def inside_cidr_blocks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "inside_cidr_blocks")

    @inside_cidr_blocks.setter
    def inside_cidr_blocks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "inside_cidr_blocks", value)

    @_builtins.property
    @pulumi.getter(name="peerAddress")
    def peer_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "peer_address")

    @peer_address.setter
    def peer_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "peer_address", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)


if not MYPY:
    class ConnectPeerConfigurationBgpConfigurationArgsDict(TypedDict):
        core_network_address: NotRequired[pulumi.Input[_builtins.str]]
        core_network_asn: NotRequired[pulumi.Input[_builtins.int]]
        peer_address: NotRequired[pulumi.Input[_builtins.str]]
        peer_asn: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ConnectPeerConfigurationBgpConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectPeerConfigurationBgpConfigurationArgs:
    def __init__(__self__, *,
                 core_network_address: Optional[pulumi.Input[_builtins.str]] = None,
                 core_network_asn: Optional[pulumi.Input[_builtins.int]] = None,
                 peer_address: Optional[pulumi.Input[_builtins.str]] = None,
                 peer_asn: Optional[pulumi.Input[_builtins.str]] = None):
        if core_network_address is not None:
            pulumi.set(__self__, "core_network_address", core_network_address)
        if core_network_asn is not None:
            pulumi.set(__self__, "core_network_asn", core_network_asn)
        if peer_address is not None:
            pulumi.set(__self__, "peer_address", peer_address)
        if peer_asn is not None:
            pulumi.set(__self__, "peer_asn", peer_asn)

    @_builtins.property
    @pulumi.getter(name="coreNetworkAddress")
    def core_network_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "core_network_address")

    @core_network_address.setter
    def core_network_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "core_network_address", value)

    @_builtins.property
    @pulumi.getter(name="coreNetworkAsn")
    def core_network_asn(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "core_network_asn")

    @core_network_asn.setter
    def core_network_asn(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "core_network_asn", value)

    @_builtins.property
    @pulumi.getter(name="peerAddress")
    def peer_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "peer_address")

    @peer_address.setter
    def peer_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "peer_address", value)

    @_builtins.property
    @pulumi.getter(name="peerAsn")
    def peer_asn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "peer_asn")

    @peer_asn.setter
    def peer_asn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "peer_asn", value)


if not MYPY:
    class CoreNetworkEdgeArgsDict(TypedDict):
        asn: NotRequired[pulumi.Input[_builtins.int]]
        edge_location: NotRequired[pulumi.Input[_builtins.str]]
        inside_cidr_blocks: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    CoreNetworkEdgeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CoreNetworkEdgeArgs:
    def __init__(__self__, *,
                 asn: Optional[pulumi.Input[_builtins.int]] = None,
                 edge_location: Optional[pulumi.Input[_builtins.str]] = None,
                 inside_cidr_blocks: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if asn is not None:
            pulumi.set(__self__, "asn", asn)
        if edge_location is not None:
            pulumi.set(__self__, "edge_location", edge_location)
        if inside_cidr_blocks is not None:
            pulumi.set(__self__, "inside_cidr_blocks", inside_cidr_blocks)

    @_builtins.property
    @pulumi.getter
    def asn(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "asn")

    @asn.setter
    def asn(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "asn", value)

    @_builtins.property
    @pulumi.getter(name="edgeLocation")
    def edge_location(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "edge_location")

    @edge_location.setter
    def edge_location(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "edge_location", value)

    @_builtins.property
    @pulumi.getter(name="insideCidrBlocks")
    def inside_cidr_blocks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "inside_cidr_blocks")

    @inside_cidr_blocks.setter
    def inside_cidr_blocks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "inside_cidr_blocks", value)


if not MYPY:
    class CoreNetworkSegmentArgsDict(TypedDict):
        edge_locations: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        name: NotRequired[pulumi.Input[_builtins.str]]
        shared_segments: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    CoreNetworkSegmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CoreNetworkSegmentArgs:
    def __init__(__self__, *,
                 edge_locations: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 shared_segments: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if edge_locations is not None:
            pulumi.set(__self__, "edge_locations", edge_locations)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if shared_segments is not None:
            pulumi.set(__self__, "shared_segments", shared_segments)

    @_builtins.property
    @pulumi.getter(name="edgeLocations")
    def edge_locations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "edge_locations")

    @edge_locations.setter
    def edge_locations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "edge_locations", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="sharedSegments")
    def shared_segments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "shared_segments")

    @shared_segments.setter
    def shared_segments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "shared_segments", value)


if not MYPY:
    class DeviceAwsLocationArgsDict(TypedDict):
        subnet_arn: NotRequired[pulumi.Input[_builtins.str]]
        zone: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DeviceAwsLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceAwsLocationArgs:
    def __init__(__self__, *,
                 subnet_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 zone: Optional[pulumi.Input[_builtins.str]] = None):
        if subnet_arn is not None:
            pulumi.set(__self__, "subnet_arn", subnet_arn)
        if zone is not None:
            pulumi.set(__self__, "zone", zone)

    @_builtins.property
    @pulumi.getter(name="subnetArn")
    def subnet_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "subnet_arn")

    @subnet_arn.setter
    def subnet_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subnet_arn", value)

    @_builtins.property
    @pulumi.getter
    def zone(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "zone")

    @zone.setter
    def zone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "zone", value)


if not MYPY:
    class DeviceLocationArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[_builtins.str]]
        latitude: NotRequired[pulumi.Input[_builtins.str]]
        longitude: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DeviceLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceLocationArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[_builtins.str]] = None,
                 latitude: Optional[pulumi.Input[_builtins.str]] = None,
                 longitude: Optional[pulumi.Input[_builtins.str]] = None):
        if address is not None:
            pulumi.set(__self__, "address", address)
        if latitude is not None:
            pulumi.set(__self__, "latitude", latitude)
        if longitude is not None:
            pulumi.set(__self__, "longitude", longitude)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter
    def latitude(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "latitude")

    @latitude.setter
    def latitude(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "latitude", value)

    @_builtins.property
    @pulumi.getter
    def longitude(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "longitude")

    @longitude.setter
    def longitude(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "longitude", value)


if not MYPY:
    class DxGatewayAttachmentTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    DxGatewayAttachmentTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DxGatewayAttachmentTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class LinkBandwidthArgsDict(TypedDict):
        download_speed: NotRequired[pulumi.Input[_builtins.int]]
        upload_speed: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    LinkBandwidthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinkBandwidthArgs:
    def __init__(__self__, *,
                 download_speed: Optional[pulumi.Input[_builtins.int]] = None,
                 upload_speed: Optional[pulumi.Input[_builtins.int]] = None):
        if download_speed is not None:
            pulumi.set(__self__, "download_speed", download_speed)
        if upload_speed is not None:
            pulumi.set(__self__, "upload_speed", upload_speed)

    @_builtins.property
    @pulumi.getter(name="downloadSpeed")
    def download_speed(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "download_speed")

    @download_speed.setter
    def download_speed(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "download_speed", value)

    @_builtins.property
    @pulumi.getter(name="uploadSpeed")
    def upload_speed(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "upload_speed")

    @upload_speed.setter
    def upload_speed(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "upload_speed", value)


if not MYPY:
    class SiteLocationArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[_builtins.str]]
        latitude: NotRequired[pulumi.Input[_builtins.str]]
        longitude: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    SiteLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SiteLocationArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[_builtins.str]] = None,
                 latitude: Optional[pulumi.Input[_builtins.str]] = None,
                 longitude: Optional[pulumi.Input[_builtins.str]] = None):
        if address is not None:
            pulumi.set(__self__, "address", address)
        if latitude is not None:
            pulumi.set(__self__, "latitude", latitude)
        if longitude is not None:
            pulumi.set(__self__, "longitude", longitude)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter
    def latitude(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "latitude")

    @latitude.setter
    def latitude(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "latitude", value)

    @_builtins.property
    @pulumi.getter
    def longitude(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "longitude")

    @longitude.setter
    def longitude(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "longitude", value)


if not MYPY:
    class VpcAttachmentOptionsArgsDict(TypedDict):
        appliance_mode_support: NotRequired[pulumi.Input[_builtins.bool]]
        dns_support: NotRequired[pulumi.Input[_builtins.bool]]
        ipv6_support: NotRequired[pulumi.Input[_builtins.bool]]
        security_group_referencing_support: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    VpcAttachmentOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcAttachmentOptionsArgs:
    def __init__(__self__, *,
                 appliance_mode_support: Optional[pulumi.Input[_builtins.bool]] = None,
                 dns_support: Optional[pulumi.Input[_builtins.bool]] = None,
                 ipv6_support: Optional[pulumi.Input[_builtins.bool]] = None,
                 security_group_referencing_support: Optional[pulumi.Input[_builtins.bool]] = None):
        if appliance_mode_support is not None:
            pulumi.set(__self__, "appliance_mode_support", appliance_mode_support)
        if dns_support is not None:
            pulumi.set(__self__, "dns_support", dns_support)
        if ipv6_support is not None:
            pulumi.set(__self__, "ipv6_support", ipv6_support)
        if security_group_referencing_support is not None:
            pulumi.set(__self__, "security_group_referencing_support", security_group_referencing_support)

    @_builtins.property
    @pulumi.getter(name="applianceModeSupport")
    def appliance_mode_support(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "appliance_mode_support")

    @appliance_mode_support.setter
    def appliance_mode_support(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "appliance_mode_support", value)

    @_builtins.property
    @pulumi.getter(name="dnsSupport")
    def dns_support(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "dns_support")

    @dns_support.setter
    def dns_support(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "dns_support", value)

    @_builtins.property
    @pulumi.getter(name="ipv6Support")
    def ipv6_support(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "ipv6_support")

    @ipv6_support.setter
    def ipv6_support(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ipv6_support", value)

    @_builtins.property
    @pulumi.getter(name="securityGroupReferencingSupport")
    def security_group_referencing_support(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "security_group_referencing_support")

    @security_group_referencing_support.setter
    def security_group_referencing_support(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "security_group_referencing_support", value)


if not MYPY:
    class GetCoreNetworkPolicyDocumentAttachmentPolicyArgsDict(TypedDict):
        action: 'GetCoreNetworkPolicyDocumentAttachmentPolicyActionArgsDict'
        conditions: Sequence['GetCoreNetworkPolicyDocumentAttachmentPolicyConditionArgsDict']
        rule_number: _builtins.int
        condition_logic: NotRequired[_builtins.str]
        description: NotRequired[_builtins.str]
elif False:
    GetCoreNetworkPolicyDocumentAttachmentPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCoreNetworkPolicyDocumentAttachmentPolicyArgs:
    def __init__(__self__, *,
                 action: 'GetCoreNetworkPolicyDocumentAttachmentPolicyActionArgs',
                 conditions: Sequence['GetCoreNetworkPolicyDocumentAttachmentPolicyConditionArgs'],
                 rule_number: _builtins.int,
                 condition_logic: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None):
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "conditions", conditions)
        pulumi.set(__self__, "rule_number", rule_number)
        if condition_logic is not None:
            pulumi.set(__self__, "condition_logic", condition_logic)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def action(self) -> 'GetCoreNetworkPolicyDocumentAttachmentPolicyActionArgs':
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: 'GetCoreNetworkPolicyDocumentAttachmentPolicyActionArgs'):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def conditions(self) -> Sequence['GetCoreNetworkPolicyDocumentAttachmentPolicyConditionArgs']:
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Sequence['GetCoreNetworkPolicyDocumentAttachmentPolicyConditionArgs']):
        pulumi.set(self, "conditions", value)

    @_builtins.property
    @pulumi.getter(name="ruleNumber")
    def rule_number(self) -> _builtins.int:
        return pulumi.get(self, "rule_number")

    @rule_number.setter
    def rule_number(self, value: _builtins.int):
        pulumi.set(self, "rule_number", value)

    @_builtins.property
    @pulumi.getter(name="conditionLogic")
    def condition_logic(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "condition_logic")

    @condition_logic.setter
    def condition_logic(self, value: Optional[_builtins.str]):
        pulumi.set(self, "condition_logic", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[_builtins.str]):
        pulumi.set(self, "description", value)


if not MYPY:
    class GetCoreNetworkPolicyDocumentAttachmentPolicyActionArgsDict(TypedDict):
        add_to_network_function_group: NotRequired[_builtins.str]
        association_method: NotRequired[_builtins.str]
        require_acceptance: NotRequired[_builtins.bool]
        segment: NotRequired[_builtins.str]
        tag_value_of_key: NotRequired[_builtins.str]
elif False:
    GetCoreNetworkPolicyDocumentAttachmentPolicyActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCoreNetworkPolicyDocumentAttachmentPolicyActionArgs:
    def __init__(__self__, *,
                 add_to_network_function_group: Optional[_builtins.str] = None,
                 association_method: Optional[_builtins.str] = None,
                 require_acceptance: Optional[_builtins.bool] = None,
                 segment: Optional[_builtins.str] = None,
                 tag_value_of_key: Optional[_builtins.str] = None):
        if add_to_network_function_group is not None:
            pulumi.set(__self__, "add_to_network_function_group", add_to_network_function_group)
        if association_method is not None:
            pulumi.set(__self__, "association_method", association_method)
        if require_acceptance is not None:
            pulumi.set(__self__, "require_acceptance", require_acceptance)
        if segment is not None:
            pulumi.set(__self__, "segment", segment)
        if tag_value_of_key is not None:
            pulumi.set(__self__, "tag_value_of_key", tag_value_of_key)

    @_builtins.property
    @pulumi.getter(name="addToNetworkFunctionGroup")
    def add_to_network_function_group(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "add_to_network_function_group")

    @add_to_network_function_group.setter
    def add_to_network_function_group(self, value: Optional[_builtins.str]):
        pulumi.set(self, "add_to_network_function_group", value)

    @_builtins.property
    @pulumi.getter(name="associationMethod")
    def association_method(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "association_method")

    @association_method.setter
    def association_method(self, value: Optional[_builtins.str]):
        pulumi.set(self, "association_method", value)

    @_builtins.property
    @pulumi.getter(name="requireAcceptance")
    def require_acceptance(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "require_acceptance")

    @require_acceptance.setter
    def require_acceptance(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "require_acceptance", value)

    @_builtins.property
    @pulumi.getter
    def segment(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "segment")

    @segment.setter
    def segment(self, value: Optional[_builtins.str]):
        pulumi.set(self, "segment", value)

    @_builtins.property
    @pulumi.getter(name="tagValueOfKey")
    def tag_value_of_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "tag_value_of_key")

    @tag_value_of_key.setter
    def tag_value_of_key(self, value: Optional[_builtins.str]):
        pulumi.set(self, "tag_value_of_key", value)


if not MYPY:
    class GetCoreNetworkPolicyDocumentAttachmentPolicyConditionArgsDict(TypedDict):
        type: _builtins.str
        key: NotRequired[_builtins.str]
        operator: NotRequired[_builtins.str]
        value: NotRequired[_builtins.str]
elif False:
    GetCoreNetworkPolicyDocumentAttachmentPolicyConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCoreNetworkPolicyDocumentAttachmentPolicyConditionArgs:
    def __init__(__self__, *,
                 type: _builtins.str,
                 key: Optional[_builtins.str] = None,
                 operator: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        pulumi.set(__self__, "type", type)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: _builtins.str):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[_builtins.str]):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetCoreNetworkPolicyDocumentAttachmentRoutingPolicyRuleArgsDict(TypedDict):
        action: 'GetCoreNetworkPolicyDocumentAttachmentRoutingPolicyRuleActionArgsDict'
        conditions: Sequence['GetCoreNetworkPolicyDocumentAttachmentRoutingPolicyRuleConditionArgsDict']
        rule_number: _builtins.int
        description: NotRequired[_builtins.str]
        edge_locations: NotRequired[Sequence[_builtins.str]]
elif False:
    GetCoreNetworkPolicyDocumentAttachmentRoutingPolicyRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCoreNetworkPolicyDocumentAttachmentRoutingPolicyRuleArgs:
    def __init__(__self__, *,
                 action: 'GetCoreNetworkPolicyDocumentAttachmentRoutingPolicyRuleActionArgs',
                 conditions: Sequence['GetCoreNetworkPolicyDocumentAttachmentRoutingPolicyRuleConditionArgs'],
                 rule_number: _builtins.int,
                 description: Optional[_builtins.str] = None,
                 edge_locations: Optional[Sequence[_builtins.str]] = None):
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "conditions", conditions)
        pulumi.set(__self__, "rule_number", rule_number)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if edge_locations is not None:
            pulumi.set(__self__, "edge_locations", edge_locations)

    @_builtins.property
    @pulumi.getter
    def action(self) -> 'GetCoreNetworkPolicyDocumentAttachmentRoutingPolicyRuleActionArgs':
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: 'GetCoreNetworkPolicyDocumentAttachmentRoutingPolicyRuleActionArgs'):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def conditions(self) -> Sequence['GetCoreNetworkPolicyDocumentAttachmentRoutingPolicyRuleConditionArgs']:
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Sequence['GetCoreNetworkPolicyDocumentAttachmentRoutingPolicyRuleConditionArgs']):
        pulumi.set(self, "conditions", value)

    @_builtins.property
    @pulumi.getter(name="ruleNumber")
    def rule_number(self) -> _builtins.int:
        return pulumi.get(self, "rule_number")

    @rule_number.setter
    def rule_number(self, value: _builtins.int):
        pulumi.set(self, "rule_number", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[_builtins.str]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="edgeLocations")
    def edge_locations(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "edge_locations")

    @edge_locations.setter
    def edge_locations(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "edge_locations", value)


if not MYPY:
    class GetCoreNetworkPolicyDocumentAttachmentRoutingPolicyRuleActionArgsDict(TypedDict):
        associate_routing_policies: Sequence[_builtins.str]
elif False:
    GetCoreNetworkPolicyDocumentAttachmentRoutingPolicyRuleActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCoreNetworkPolicyDocumentAttachmentRoutingPolicyRuleActionArgs:
    def __init__(__self__, *,
                 associate_routing_policies: Sequence[_builtins.str]):
        pulumi.set(__self__, "associate_routing_policies", associate_routing_policies)

    @_builtins.property
    @pulumi.getter(name="associateRoutingPolicies")
    def associate_routing_policies(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "associate_routing_policies")

    @associate_routing_policies.setter
    def associate_routing_policies(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "associate_routing_policies", value)


if not MYPY:
    class GetCoreNetworkPolicyDocumentAttachmentRoutingPolicyRuleConditionArgsDict(TypedDict):
        type: _builtins.str
        value: _builtins.str
elif False:
    GetCoreNetworkPolicyDocumentAttachmentRoutingPolicyRuleConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCoreNetworkPolicyDocumentAttachmentRoutingPolicyRuleConditionArgs:
    def __init__(__self__, *,
                 type: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: _builtins.str):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: _builtins.str):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetCoreNetworkPolicyDocumentCoreNetworkConfigurationArgsDict(TypedDict):
        asn_ranges: Sequence[_builtins.str]
        edge_locations: Sequence['GetCoreNetworkPolicyDocumentCoreNetworkConfigurationEdgeLocationArgsDict']
        dns_support: NotRequired[_builtins.bool]
        inside_cidr_blocks: NotRequired[Sequence[_builtins.str]]
        security_group_referencing_support: NotRequired[_builtins.bool]
        vpn_ecmp_support: NotRequired[_builtins.bool]
elif False:
    GetCoreNetworkPolicyDocumentCoreNetworkConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCoreNetworkPolicyDocumentCoreNetworkConfigurationArgs:
    def __init__(__self__, *,
                 asn_ranges: Sequence[_builtins.str],
                 edge_locations: Sequence['GetCoreNetworkPolicyDocumentCoreNetworkConfigurationEdgeLocationArgs'],
                 dns_support: Optional[_builtins.bool] = None,
                 inside_cidr_blocks: Optional[Sequence[_builtins.str]] = None,
                 security_group_referencing_support: Optional[_builtins.bool] = None,
                 vpn_ecmp_support: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "asn_ranges", asn_ranges)
        pulumi.set(__self__, "edge_locations", edge_locations)
        if dns_support is not None:
            pulumi.set(__self__, "dns_support", dns_support)
        if inside_cidr_blocks is not None:
            pulumi.set(__self__, "inside_cidr_blocks", inside_cidr_blocks)
        if security_group_referencing_support is not None:
            pulumi.set(__self__, "security_group_referencing_support", security_group_referencing_support)
        if vpn_ecmp_support is not None:
            pulumi.set(__self__, "vpn_ecmp_support", vpn_ecmp_support)

    @_builtins.property
    @pulumi.getter(name="asnRanges")
    def asn_ranges(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "asn_ranges")

    @asn_ranges.setter
    def asn_ranges(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "asn_ranges", value)

    @_builtins.property
    @pulumi.getter(name="edgeLocations")
    def edge_locations(self) -> Sequence['GetCoreNetworkPolicyDocumentCoreNetworkConfigurationEdgeLocationArgs']:
        return pulumi.get(self, "edge_locations")

    @edge_locations.setter
    def edge_locations(self, value: Sequence['GetCoreNetworkPolicyDocumentCoreNetworkConfigurationEdgeLocationArgs']):
        pulumi.set(self, "edge_locations", value)

    @_builtins.property
    @pulumi.getter(name="dnsSupport")
    def dns_support(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "dns_support")

    @dns_support.setter
    def dns_support(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "dns_support", value)

    @_builtins.property
    @pulumi.getter(name="insideCidrBlocks")
    def inside_cidr_blocks(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "inside_cidr_blocks")

    @inside_cidr_blocks.setter
    def inside_cidr_blocks(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "inside_cidr_blocks", value)

    @_builtins.property
    @pulumi.getter(name="securityGroupReferencingSupport")
    def security_group_referencing_support(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "security_group_referencing_support")

    @security_group_referencing_support.setter
    def security_group_referencing_support(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "security_group_referencing_support", value)

    @_builtins.property
    @pulumi.getter(name="vpnEcmpSupport")
    def vpn_ecmp_support(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "vpn_ecmp_support")

    @vpn_ecmp_support.setter
    def vpn_ecmp_support(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "vpn_ecmp_support", value)


if not MYPY:
    class GetCoreNetworkPolicyDocumentCoreNetworkConfigurationEdgeLocationArgsDict(TypedDict):
        location: _builtins.str
        asn: NotRequired[_builtins.str]
        inside_cidr_blocks: NotRequired[Sequence[_builtins.str]]
elif False:
    GetCoreNetworkPolicyDocumentCoreNetworkConfigurationEdgeLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCoreNetworkPolicyDocumentCoreNetworkConfigurationEdgeLocationArgs:
    def __init__(__self__, *,
                 location: _builtins.str,
                 asn: Optional[_builtins.str] = None,
                 inside_cidr_blocks: Optional[Sequence[_builtins.str]] = None):
        pulumi.set(__self__, "location", location)
        if asn is not None:
            pulumi.set(__self__, "asn", asn)
        if inside_cidr_blocks is not None:
            pulumi.set(__self__, "inside_cidr_blocks", inside_cidr_blocks)

    @_builtins.property
    @pulumi.getter
    def location(self) -> _builtins.str:
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: _builtins.str):
        pulumi.set(self, "location", value)

    @_builtins.property
    @pulumi.getter
    def asn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "asn")

    @asn.setter
    def asn(self, value: Optional[_builtins.str]):
        pulumi.set(self, "asn", value)

    @_builtins.property
    @pulumi.getter(name="insideCidrBlocks")
    def inside_cidr_blocks(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "inside_cidr_blocks")

    @inside_cidr_blocks.setter
    def inside_cidr_blocks(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "inside_cidr_blocks", value)


if not MYPY:
    class GetCoreNetworkPolicyDocumentNetworkFunctionGroupArgsDict(TypedDict):
        name: _builtins.str
        require_attachment_acceptance: _builtins.bool
        description: NotRequired[_builtins.str]
elif False:
    GetCoreNetworkPolicyDocumentNetworkFunctionGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCoreNetworkPolicyDocumentNetworkFunctionGroupArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 require_attachment_acceptance: _builtins.bool,
                 description: Optional[_builtins.str] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "require_attachment_acceptance", require_attachment_acceptance)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="requireAttachmentAcceptance")
    def require_attachment_acceptance(self) -> _builtins.bool:
        return pulumi.get(self, "require_attachment_acceptance")

    @require_attachment_acceptance.setter
    def require_attachment_acceptance(self, value: _builtins.bool):
        pulumi.set(self, "require_attachment_acceptance", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[_builtins.str]):
        pulumi.set(self, "description", value)


if not MYPY:
    class GetCoreNetworkPolicyDocumentRoutingPolicyArgsDict(TypedDict):
        routing_policy_direction: _builtins.str
        routing_policy_name: _builtins.str
        routing_policy_number: _builtins.int
        routing_policy_rules: Sequence['GetCoreNetworkPolicyDocumentRoutingPolicyRoutingPolicyRuleArgsDict']
        routing_policy_description: NotRequired[_builtins.str]
elif False:
    GetCoreNetworkPolicyDocumentRoutingPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCoreNetworkPolicyDocumentRoutingPolicyArgs:
    def __init__(__self__, *,
                 routing_policy_direction: _builtins.str,
                 routing_policy_name: _builtins.str,
                 routing_policy_number: _builtins.int,
                 routing_policy_rules: Sequence['GetCoreNetworkPolicyDocumentRoutingPolicyRoutingPolicyRuleArgs'],
                 routing_policy_description: Optional[_builtins.str] = None):
        pulumi.set(__self__, "routing_policy_direction", routing_policy_direction)
        pulumi.set(__self__, "routing_policy_name", routing_policy_name)
        pulumi.set(__self__, "routing_policy_number", routing_policy_number)
        pulumi.set(__self__, "routing_policy_rules", routing_policy_rules)
        if routing_policy_description is not None:
            pulumi.set(__self__, "routing_policy_description", routing_policy_description)

    @_builtins.property
    @pulumi.getter(name="routingPolicyDirection")
    def routing_policy_direction(self) -> _builtins.str:
        return pulumi.get(self, "routing_policy_direction")

    @routing_policy_direction.setter
    def routing_policy_direction(self, value: _builtins.str):
        pulumi.set(self, "routing_policy_direction", value)

    @_builtins.property
    @pulumi.getter(name="routingPolicyName")
    def routing_policy_name(self) -> _builtins.str:
        return pulumi.get(self, "routing_policy_name")

    @routing_policy_name.setter
    def routing_policy_name(self, value: _builtins.str):
        pulumi.set(self, "routing_policy_name", value)

    @_builtins.property
    @pulumi.getter(name="routingPolicyNumber")
    def routing_policy_number(self) -> _builtins.int:
        return pulumi.get(self, "routing_policy_number")

    @routing_policy_number.setter
    def routing_policy_number(self, value: _builtins.int):
        pulumi.set(self, "routing_policy_number", value)

    @_builtins.property
    @pulumi.getter(name="routingPolicyRules")
    def routing_policy_rules(self) -> Sequence['GetCoreNetworkPolicyDocumentRoutingPolicyRoutingPolicyRuleArgs']:
        return pulumi.get(self, "routing_policy_rules")

    @routing_policy_rules.setter
    def routing_policy_rules(self, value: Sequence['GetCoreNetworkPolicyDocumentRoutingPolicyRoutingPolicyRuleArgs']):
        pulumi.set(self, "routing_policy_rules", value)

    @_builtins.property
    @pulumi.getter(name="routingPolicyDescription")
    def routing_policy_description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "routing_policy_description")

    @routing_policy_description.setter
    def routing_policy_description(self, value: Optional[_builtins.str]):
        pulumi.set(self, "routing_policy_description", value)


if not MYPY:
    class GetCoreNetworkPolicyDocumentRoutingPolicyRoutingPolicyRuleArgsDict(TypedDict):
        rule_definition: 'GetCoreNetworkPolicyDocumentRoutingPolicyRoutingPolicyRuleRuleDefinitionArgsDict'
        rule_number: _builtins.int
elif False:
    GetCoreNetworkPolicyDocumentRoutingPolicyRoutingPolicyRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCoreNetworkPolicyDocumentRoutingPolicyRoutingPolicyRuleArgs:
    def __init__(__self__, *,
                 rule_definition: 'GetCoreNetworkPolicyDocumentRoutingPolicyRoutingPolicyRuleRuleDefinitionArgs',
                 rule_number: _builtins.int):
        pulumi.set(__self__, "rule_definition", rule_definition)
        pulumi.set(__self__, "rule_number", rule_number)

    @_builtins.property
    @pulumi.getter(name="ruleDefinition")
    def rule_definition(self) -> 'GetCoreNetworkPolicyDocumentRoutingPolicyRoutingPolicyRuleRuleDefinitionArgs':
        return pulumi.get(self, "rule_definition")

    @rule_definition.setter
    def rule_definition(self, value: 'GetCoreNetworkPolicyDocumentRoutingPolicyRoutingPolicyRuleRuleDefinitionArgs'):
        pulumi.set(self, "rule_definition", value)

    @_builtins.property
    @pulumi.getter(name="ruleNumber")
    def rule_number(self) -> _builtins.int:
        return pulumi.get(self, "rule_number")

    @rule_number.setter
    def rule_number(self, value: _builtins.int):
        pulumi.set(self, "rule_number", value)


if not MYPY:
    class GetCoreNetworkPolicyDocumentRoutingPolicyRoutingPolicyRuleRuleDefinitionArgsDict(TypedDict):
        action: 'GetCoreNetworkPolicyDocumentRoutingPolicyRoutingPolicyRuleRuleDefinitionActionArgsDict'
        condition_logic: NotRequired[_builtins.str]
        match_conditions: NotRequired[Sequence['GetCoreNetworkPolicyDocumentRoutingPolicyRoutingPolicyRuleRuleDefinitionMatchConditionArgsDict']]
elif False:
    GetCoreNetworkPolicyDocumentRoutingPolicyRoutingPolicyRuleRuleDefinitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCoreNetworkPolicyDocumentRoutingPolicyRoutingPolicyRuleRuleDefinitionArgs:
    def __init__(__self__, *,
                 action: 'GetCoreNetworkPolicyDocumentRoutingPolicyRoutingPolicyRuleRuleDefinitionActionArgs',
                 condition_logic: Optional[_builtins.str] = None,
                 match_conditions: Optional[Sequence['GetCoreNetworkPolicyDocumentRoutingPolicyRoutingPolicyRuleRuleDefinitionMatchConditionArgs']] = None):
        pulumi.set(__self__, "action", action)
        if condition_logic is not None:
            pulumi.set(__self__, "condition_logic", condition_logic)
        if match_conditions is not None:
            pulumi.set(__self__, "match_conditions", match_conditions)

    @_builtins.property
    @pulumi.getter
    def action(self) -> 'GetCoreNetworkPolicyDocumentRoutingPolicyRoutingPolicyRuleRuleDefinitionActionArgs':
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: 'GetCoreNetworkPolicyDocumentRoutingPolicyRoutingPolicyRuleRuleDefinitionActionArgs'):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter(name="conditionLogic")
    def condition_logic(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "condition_logic")

    @condition_logic.setter
    def condition_logic(self, value: Optional[_builtins.str]):
        pulumi.set(self, "condition_logic", value)

    @_builtins.property
    @pulumi.getter(name="matchConditions")
    def match_conditions(self) -> Optional[Sequence['GetCoreNetworkPolicyDocumentRoutingPolicyRoutingPolicyRuleRuleDefinitionMatchConditionArgs']]:
        return pulumi.get(self, "match_conditions")

    @match_conditions.setter
    def match_conditions(self, value: Optional[Sequence['GetCoreNetworkPolicyDocumentRoutingPolicyRoutingPolicyRuleRuleDefinitionMatchConditionArgs']]):
        pulumi.set(self, "match_conditions", value)


if not MYPY:
    class GetCoreNetworkPolicyDocumentRoutingPolicyRoutingPolicyRuleRuleDefinitionActionArgsDict(TypedDict):
        type: _builtins.str
        value: NotRequired[_builtins.str]
elif False:
    GetCoreNetworkPolicyDocumentRoutingPolicyRoutingPolicyRuleRuleDefinitionActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCoreNetworkPolicyDocumentRoutingPolicyRoutingPolicyRuleRuleDefinitionActionArgs:
    def __init__(__self__, *,
                 type: _builtins.str,
                 value: Optional[_builtins.str] = None):
        pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: _builtins.str):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetCoreNetworkPolicyDocumentRoutingPolicyRoutingPolicyRuleRuleDefinitionMatchConditionArgsDict(TypedDict):
        type: _builtins.str
        value: _builtins.str
elif False:
    GetCoreNetworkPolicyDocumentRoutingPolicyRoutingPolicyRuleRuleDefinitionMatchConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCoreNetworkPolicyDocumentRoutingPolicyRoutingPolicyRuleRuleDefinitionMatchConditionArgs:
    def __init__(__self__, *,
                 type: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: _builtins.str):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: _builtins.str):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetCoreNetworkPolicyDocumentSegmentArgsDict(TypedDict):
        name: _builtins.str
        allow_filters: NotRequired[Sequence[_builtins.str]]
        deny_filters: NotRequired[Sequence[_builtins.str]]
        description: NotRequired[_builtins.str]
        edge_locations: NotRequired[Sequence[_builtins.str]]
        isolate_attachments: NotRequired[_builtins.bool]
        require_attachment_acceptance: NotRequired[_builtins.bool]
elif False:
    GetCoreNetworkPolicyDocumentSegmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCoreNetworkPolicyDocumentSegmentArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 allow_filters: Optional[Sequence[_builtins.str]] = None,
                 deny_filters: Optional[Sequence[_builtins.str]] = None,
                 description: Optional[_builtins.str] = None,
                 edge_locations: Optional[Sequence[_builtins.str]] = None,
                 isolate_attachments: Optional[_builtins.bool] = None,
                 require_attachment_acceptance: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        if allow_filters is not None:
            pulumi.set(__self__, "allow_filters", allow_filters)
        if deny_filters is not None:
            pulumi.set(__self__, "deny_filters", deny_filters)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if edge_locations is not None:
            pulumi.set(__self__, "edge_locations", edge_locations)
        if isolate_attachments is not None:
            pulumi.set(__self__, "isolate_attachments", isolate_attachments)
        if require_attachment_acceptance is not None:
            pulumi.set(__self__, "require_attachment_acceptance", require_attachment_acceptance)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="allowFilters")
    def allow_filters(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "allow_filters")

    @allow_filters.setter
    def allow_filters(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "allow_filters", value)

    @_builtins.property
    @pulumi.getter(name="denyFilters")
    def deny_filters(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "deny_filters")

    @deny_filters.setter
    def deny_filters(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "deny_filters", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[_builtins.str]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="edgeLocations")
    def edge_locations(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "edge_locations")

    @edge_locations.setter
    def edge_locations(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "edge_locations", value)

    @_builtins.property
    @pulumi.getter(name="isolateAttachments")
    def isolate_attachments(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "isolate_attachments")

    @isolate_attachments.setter
    def isolate_attachments(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "isolate_attachments", value)

    @_builtins.property
    @pulumi.getter(name="requireAttachmentAcceptance")
    def require_attachment_acceptance(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "require_attachment_acceptance")

    @require_attachment_acceptance.setter
    def require_attachment_acceptance(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "require_attachment_acceptance", value)


if not MYPY:
    class GetCoreNetworkPolicyDocumentSegmentActionArgsDict(TypedDict):
        action: _builtins.str
        segment: _builtins.str
        description: NotRequired[_builtins.str]
        destination_cidr_blocks: NotRequired[Sequence[_builtins.str]]
        destinations: NotRequired[Sequence[_builtins.str]]
        edge_location_association: NotRequired['GetCoreNetworkPolicyDocumentSegmentActionEdgeLocationAssociationArgsDict']
        mode: NotRequired[_builtins.str]
        share_with_excepts: NotRequired[Sequence[_builtins.str]]
        share_withs: NotRequired[Sequence[_builtins.str]]
        via: NotRequired['GetCoreNetworkPolicyDocumentSegmentActionViaArgsDict']
        when_sent_to: NotRequired['GetCoreNetworkPolicyDocumentSegmentActionWhenSentToArgsDict']
elif False:
    GetCoreNetworkPolicyDocumentSegmentActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCoreNetworkPolicyDocumentSegmentActionArgs:
    def __init__(__self__, *,
                 action: _builtins.str,
                 segment: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 destination_cidr_blocks: Optional[Sequence[_builtins.str]] = None,
                 destinations: Optional[Sequence[_builtins.str]] = None,
                 edge_location_association: Optional['GetCoreNetworkPolicyDocumentSegmentActionEdgeLocationAssociationArgs'] = None,
                 mode: Optional[_builtins.str] = None,
                 share_with_excepts: Optional[Sequence[_builtins.str]] = None,
                 share_withs: Optional[Sequence[_builtins.str]] = None,
                 via: Optional['GetCoreNetworkPolicyDocumentSegmentActionViaArgs'] = None,
                 when_sent_to: Optional['GetCoreNetworkPolicyDocumentSegmentActionWhenSentToArgs'] = None):
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "segment", segment)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if destination_cidr_blocks is not None:
            pulumi.set(__self__, "destination_cidr_blocks", destination_cidr_blocks)
        if destinations is not None:
            pulumi.set(__self__, "destinations", destinations)
        if edge_location_association is not None:
            pulumi.set(__self__, "edge_location_association", edge_location_association)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if share_with_excepts is not None:
            pulumi.set(__self__, "share_with_excepts", share_with_excepts)
        if share_withs is not None:
            pulumi.set(__self__, "share_withs", share_withs)
        if via is not None:
            pulumi.set(__self__, "via", via)
        if when_sent_to is not None:
            pulumi.set(__self__, "when_sent_to", when_sent_to)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: _builtins.str):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def segment(self) -> _builtins.str:
        return pulumi.get(self, "segment")

    @segment.setter
    def segment(self, value: _builtins.str):
        pulumi.set(self, "segment", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[_builtins.str]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="destinationCidrBlocks")
    def destination_cidr_blocks(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "destination_cidr_blocks")

    @destination_cidr_blocks.setter
    def destination_cidr_blocks(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "destination_cidr_blocks", value)

    @_builtins.property
    @pulumi.getter
    def destinations(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "destinations")

    @destinations.setter
    def destinations(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "destinations", value)

    @_builtins.property
    @pulumi.getter(name="edgeLocationAssociation")
    def edge_location_association(self) -> Optional['GetCoreNetworkPolicyDocumentSegmentActionEdgeLocationAssociationArgs']:
        return pulumi.get(self, "edge_location_association")

    @edge_location_association.setter
    def edge_location_association(self, value: Optional['GetCoreNetworkPolicyDocumentSegmentActionEdgeLocationAssociationArgs']):
        pulumi.set(self, "edge_location_association", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[_builtins.str]):
        pulumi.set(self, "mode", value)

    @_builtins.property
    @pulumi.getter(name="shareWithExcepts")
    def share_with_excepts(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "share_with_excepts")

    @share_with_excepts.setter
    def share_with_excepts(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "share_with_excepts", value)

    @_builtins.property
    @pulumi.getter(name="shareWiths")
    def share_withs(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "share_withs")

    @share_withs.setter
    def share_withs(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "share_withs", value)

    @_builtins.property
    @pulumi.getter
    def via(self) -> Optional['GetCoreNetworkPolicyDocumentSegmentActionViaArgs']:
        return pulumi.get(self, "via")

    @via.setter
    def via(self, value: Optional['GetCoreNetworkPolicyDocumentSegmentActionViaArgs']):
        pulumi.set(self, "via", value)

    @_builtins.property
    @pulumi.getter(name="whenSentTo")
    def when_sent_to(self) -> Optional['GetCoreNetworkPolicyDocumentSegmentActionWhenSentToArgs']:
        return pulumi.get(self, "when_sent_to")

    @when_sent_to.setter
    def when_sent_to(self, value: Optional['GetCoreNetworkPolicyDocumentSegmentActionWhenSentToArgs']):
        pulumi.set(self, "when_sent_to", value)


if not MYPY:
    class GetCoreNetworkPolicyDocumentSegmentActionEdgeLocationAssociationArgsDict(TypedDict):
        edge_location: _builtins.str
        peer_edge_location: _builtins.str
        routing_policy_names: Sequence[_builtins.str]
elif False:
    GetCoreNetworkPolicyDocumentSegmentActionEdgeLocationAssociationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCoreNetworkPolicyDocumentSegmentActionEdgeLocationAssociationArgs:
    def __init__(__self__, *,
                 edge_location: _builtins.str,
                 peer_edge_location: _builtins.str,
                 routing_policy_names: Sequence[_builtins.str]):
        pulumi.set(__self__, "edge_location", edge_location)
        pulumi.set(__self__, "peer_edge_location", peer_edge_location)
        pulumi.set(__self__, "routing_policy_names", routing_policy_names)

    @_builtins.property
    @pulumi.getter(name="edgeLocation")
    def edge_location(self) -> _builtins.str:
        return pulumi.get(self, "edge_location")

    @edge_location.setter
    def edge_location(self, value: _builtins.str):
        pulumi.set(self, "edge_location", value)

    @_builtins.property
    @pulumi.getter(name="peerEdgeLocation")
    def peer_edge_location(self) -> _builtins.str:
        return pulumi.get(self, "peer_edge_location")

    @peer_edge_location.setter
    def peer_edge_location(self, value: _builtins.str):
        pulumi.set(self, "peer_edge_location", value)

    @_builtins.property
    @pulumi.getter(name="routingPolicyNames")
    def routing_policy_names(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "routing_policy_names")

    @routing_policy_names.setter
    def routing_policy_names(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "routing_policy_names", value)


if not MYPY:
    class GetCoreNetworkPolicyDocumentSegmentActionViaArgsDict(TypedDict):
        network_function_groups: NotRequired[Sequence[_builtins.str]]
        with_edge_overrides: NotRequired[Sequence['GetCoreNetworkPolicyDocumentSegmentActionViaWithEdgeOverrideArgsDict']]
elif False:
    GetCoreNetworkPolicyDocumentSegmentActionViaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCoreNetworkPolicyDocumentSegmentActionViaArgs:
    def __init__(__self__, *,
                 network_function_groups: Optional[Sequence[_builtins.str]] = None,
                 with_edge_overrides: Optional[Sequence['GetCoreNetworkPolicyDocumentSegmentActionViaWithEdgeOverrideArgs']] = None):
        if network_function_groups is not None:
            pulumi.set(__self__, "network_function_groups", network_function_groups)
        if with_edge_overrides is not None:
            pulumi.set(__self__, "with_edge_overrides", with_edge_overrides)

    @_builtins.property
    @pulumi.getter(name="networkFunctionGroups")
    def network_function_groups(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "network_function_groups")

    @network_function_groups.setter
    def network_function_groups(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "network_function_groups", value)

    @_builtins.property
    @pulumi.getter(name="withEdgeOverrides")
    def with_edge_overrides(self) -> Optional[Sequence['GetCoreNetworkPolicyDocumentSegmentActionViaWithEdgeOverrideArgs']]:
        return pulumi.get(self, "with_edge_overrides")

    @with_edge_overrides.setter
    def with_edge_overrides(self, value: Optional[Sequence['GetCoreNetworkPolicyDocumentSegmentActionViaWithEdgeOverrideArgs']]):
        pulumi.set(self, "with_edge_overrides", value)


if not MYPY:
    class GetCoreNetworkPolicyDocumentSegmentActionViaWithEdgeOverrideArgsDict(TypedDict):
        edge_sets: NotRequired[Sequence[Sequence[_builtins.str]]]
        use_edge: NotRequired[_builtins.str]
        use_edge_location: NotRequired[_builtins.str]
elif False:
    GetCoreNetworkPolicyDocumentSegmentActionViaWithEdgeOverrideArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCoreNetworkPolicyDocumentSegmentActionViaWithEdgeOverrideArgs:
    def __init__(__self__, *,
                 edge_sets: Optional[Sequence[Sequence[_builtins.str]]] = None,
                 use_edge: Optional[_builtins.str] = None,
                 use_edge_location: Optional[_builtins.str] = None):
        if edge_sets is not None:
            pulumi.set(__self__, "edge_sets", edge_sets)
        if use_edge is not None:
            warnings.warn("""use_edge is deprecated. Use use_edge_location instead.""", DeprecationWarning)
            pulumi.log.warn("""use_edge is deprecated: use_edge is deprecated. Use use_edge_location instead.""")
        if use_edge is not None:
            pulumi.set(__self__, "use_edge", use_edge)
        if use_edge_location is not None:
            pulumi.set(__self__, "use_edge_location", use_edge_location)

    @_builtins.property
    @pulumi.getter(name="edgeSets")
    def edge_sets(self) -> Optional[Sequence[Sequence[_builtins.str]]]:
        return pulumi.get(self, "edge_sets")

    @edge_sets.setter
    def edge_sets(self, value: Optional[Sequence[Sequence[_builtins.str]]]):
        pulumi.set(self, "edge_sets", value)

    @_builtins.property
    @pulumi.getter(name="useEdge")
    @_utilities.deprecated("""use_edge is deprecated. Use use_edge_location instead.""")
    def use_edge(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "use_edge")

    @use_edge.setter
    def use_edge(self, value: Optional[_builtins.str]):
        pulumi.set(self, "use_edge", value)

    @_builtins.property
    @pulumi.getter(name="useEdgeLocation")
    def use_edge_location(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "use_edge_location")

    @use_edge_location.setter
    def use_edge_location(self, value: Optional[_builtins.str]):
        pulumi.set(self, "use_edge_location", value)


if not MYPY:
    class GetCoreNetworkPolicyDocumentSegmentActionWhenSentToArgsDict(TypedDict):
        segments: NotRequired[Sequence[_builtins.str]]
elif False:
    GetCoreNetworkPolicyDocumentSegmentActionWhenSentToArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCoreNetworkPolicyDocumentSegmentActionWhenSentToArgs:
    def __init__(__self__, *,
                 segments: Optional[Sequence[_builtins.str]] = None):
        if segments is not None:
            pulumi.set(__self__, "segments", segments)

    @_builtins.property
    @pulumi.getter
    def segments(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "segments")

    @segments.setter
    def segments(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "segments", value)


