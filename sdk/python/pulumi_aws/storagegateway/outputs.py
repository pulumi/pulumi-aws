# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = [
    'FileSystemAssociationCacheAttributes',
    'GatewayGatewayNetworkInterface',
    'GatewayMaintenanceStartTime',
    'GatewaySmbActiveDirectorySettings',
    'NfsFileShareCacheAttributes',
    'NfsFileShareNfsFileShareDefaults',
    'SmbFileShareCacheAttributes',
]

@pulumi.output_type
class FileSystemAssociationCacheAttributes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cacheStaleTimeoutInSeconds":
            suggest = "cache_stale_timeout_in_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FileSystemAssociationCacheAttributes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FileSystemAssociationCacheAttributes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FileSystemAssociationCacheAttributes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cache_stale_timeout_in_seconds: Optional[int] = None):
        """
        :param int cache_stale_timeout_in_seconds: Refreshes a file share's cache by using Time To Live (TTL).
               TTL is the length of time since the last refresh after which access to the directory would cause the file gateway
               to first refresh that directory's contents from the Amazon S3 bucket. Valid Values: `0` or `300` to `2592000` seconds (5 minutes to 30 days). Defaults to `0`
        """
        FileSystemAssociationCacheAttributes._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cache_stale_timeout_in_seconds=cache_stale_timeout_in_seconds,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cache_stale_timeout_in_seconds: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cache_stale_timeout_in_seconds is None and 'cacheStaleTimeoutInSeconds' in kwargs:
            cache_stale_timeout_in_seconds = kwargs['cacheStaleTimeoutInSeconds']

        if cache_stale_timeout_in_seconds is not None:
            _setter("cache_stale_timeout_in_seconds", cache_stale_timeout_in_seconds)

    @property
    @pulumi.getter(name="cacheStaleTimeoutInSeconds")
    def cache_stale_timeout_in_seconds(self) -> Optional[int]:
        """
        Refreshes a file share's cache by using Time To Live (TTL).
        TTL is the length of time since the last refresh after which access to the directory would cause the file gateway
        to first refresh that directory's contents from the Amazon S3 bucket. Valid Values: `0` or `300` to `2592000` seconds (5 minutes to 30 days). Defaults to `0`
        """
        return pulumi.get(self, "cache_stale_timeout_in_seconds")


@pulumi.output_type
class GatewayGatewayNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipv4Address":
            suggest = "ipv4_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayGatewayNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayGatewayNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayGatewayNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ipv4_address: Optional[str] = None):
        """
        :param str ipv4_address: The Internet Protocol version 4 (IPv4) address of the interface.
        """
        GatewayGatewayNetworkInterface._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ipv4_address=ipv4_address,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ipv4_address: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ipv4_address is None and 'ipv4Address' in kwargs:
            ipv4_address = kwargs['ipv4Address']

        if ipv4_address is not None:
            _setter("ipv4_address", ipv4_address)

    @property
    @pulumi.getter(name="ipv4Address")
    def ipv4_address(self) -> Optional[str]:
        """
        The Internet Protocol version 4 (IPv4) address of the interface.
        """
        return pulumi.get(self, "ipv4_address")


@pulumi.output_type
class GatewayMaintenanceStartTime(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hourOfDay":
            suggest = "hour_of_day"
        elif key == "dayOfMonth":
            suggest = "day_of_month"
        elif key == "dayOfWeek":
            suggest = "day_of_week"
        elif key == "minuteOfHour":
            suggest = "minute_of_hour"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayMaintenanceStartTime. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayMaintenanceStartTime.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayMaintenanceStartTime.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hour_of_day: int,
                 day_of_month: Optional[str] = None,
                 day_of_week: Optional[str] = None,
                 minute_of_hour: Optional[int] = None):
        """
        :param int hour_of_day: The hour component of the maintenance start time represented as _hh_, where _hh_ is the hour (00 to 23). The hour of the day is in the time zone of the gateway.
        :param str day_of_month: The day of the month component of the maintenance start time represented as an ordinal number from 1 to 28, where 1 represents the first day of the month and 28 represents the last day of the month.
        :param str day_of_week: The day of the week component of the maintenance start time week represented as an ordinal number from 0 to 6, where 0 represents Sunday and 6 Saturday.
        :param int minute_of_hour: The minute component of the maintenance start time represented as _mm_, where _mm_ is the minute (00 to 59). The minute of the hour is in the time zone of the gateway.
        """
        GatewayMaintenanceStartTime._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            hour_of_day=hour_of_day,
            day_of_month=day_of_month,
            day_of_week=day_of_week,
            minute_of_hour=minute_of_hour,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             hour_of_day: Optional[int] = None,
             day_of_month: Optional[str] = None,
             day_of_week: Optional[str] = None,
             minute_of_hour: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if hour_of_day is None and 'hourOfDay' in kwargs:
            hour_of_day = kwargs['hourOfDay']
        if hour_of_day is None:
            raise TypeError("Missing 'hour_of_day' argument")
        if day_of_month is None and 'dayOfMonth' in kwargs:
            day_of_month = kwargs['dayOfMonth']
        if day_of_week is None and 'dayOfWeek' in kwargs:
            day_of_week = kwargs['dayOfWeek']
        if minute_of_hour is None and 'minuteOfHour' in kwargs:
            minute_of_hour = kwargs['minuteOfHour']

        _setter("hour_of_day", hour_of_day)
        if day_of_month is not None:
            _setter("day_of_month", day_of_month)
        if day_of_week is not None:
            _setter("day_of_week", day_of_week)
        if minute_of_hour is not None:
            _setter("minute_of_hour", minute_of_hour)

    @property
    @pulumi.getter(name="hourOfDay")
    def hour_of_day(self) -> int:
        """
        The hour component of the maintenance start time represented as _hh_, where _hh_ is the hour (00 to 23). The hour of the day is in the time zone of the gateway.
        """
        return pulumi.get(self, "hour_of_day")

    @property
    @pulumi.getter(name="dayOfMonth")
    def day_of_month(self) -> Optional[str]:
        """
        The day of the month component of the maintenance start time represented as an ordinal number from 1 to 28, where 1 represents the first day of the month and 28 represents the last day of the month.
        """
        return pulumi.get(self, "day_of_month")

    @property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> Optional[str]:
        """
        The day of the week component of the maintenance start time week represented as an ordinal number from 0 to 6, where 0 represents Sunday and 6 Saturday.
        """
        return pulumi.get(self, "day_of_week")

    @property
    @pulumi.getter(name="minuteOfHour")
    def minute_of_hour(self) -> Optional[int]:
        """
        The minute component of the maintenance start time represented as _mm_, where _mm_ is the minute (00 to 59). The minute of the hour is in the time zone of the gateway.
        """
        return pulumi.get(self, "minute_of_hour")


@pulumi.output_type
class GatewaySmbActiveDirectorySettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "domainName":
            suggest = "domain_name"
        elif key == "activeDirectoryStatus":
            suggest = "active_directory_status"
        elif key == "domainControllers":
            suggest = "domain_controllers"
        elif key == "organizationalUnit":
            suggest = "organizational_unit"
        elif key == "timeoutInSeconds":
            suggest = "timeout_in_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewaySmbActiveDirectorySettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewaySmbActiveDirectorySettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewaySmbActiveDirectorySettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 domain_name: str,
                 password: str,
                 username: str,
                 active_directory_status: Optional[str] = None,
                 domain_controllers: Optional[Sequence[str]] = None,
                 organizational_unit: Optional[str] = None,
                 timeout_in_seconds: Optional[int] = None):
        """
        :param str domain_name: The name of the domain that you want the gateway to join.
        :param str password: The password of the user who has permission to add the gateway to the Active Directory domain.
        :param str username: The user name of user who has permission to add the gateway to the Active Directory domain.
        :param Sequence[str] domain_controllers: List of IPv4 addresses, NetBIOS names, or host names of your domain server.
               If you need to specify the port number include it after the colon (“:”). For example, `mydc.mydomain.com:389`.
        :param str organizational_unit: The organizational unit (OU) is a container in an Active Directory that can hold users, groups,
               computers, and other OUs and this parameter specifies the OU that the gateway will join within the AD domain.
        :param int timeout_in_seconds: Specifies the time in seconds, in which the JoinDomain operation must complete. The default is `20` seconds.
        """
        GatewaySmbActiveDirectorySettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            domain_name=domain_name,
            password=password,
            username=username,
            active_directory_status=active_directory_status,
            domain_controllers=domain_controllers,
            organizational_unit=organizational_unit,
            timeout_in_seconds=timeout_in_seconds,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             domain_name: Optional[str] = None,
             password: Optional[str] = None,
             username: Optional[str] = None,
             active_directory_status: Optional[str] = None,
             domain_controllers: Optional[Sequence[str]] = None,
             organizational_unit: Optional[str] = None,
             timeout_in_seconds: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if domain_name is None and 'domainName' in kwargs:
            domain_name = kwargs['domainName']
        if domain_name is None:
            raise TypeError("Missing 'domain_name' argument")
        if password is None:
            raise TypeError("Missing 'password' argument")
        if username is None:
            raise TypeError("Missing 'username' argument")
        if active_directory_status is None and 'activeDirectoryStatus' in kwargs:
            active_directory_status = kwargs['activeDirectoryStatus']
        if domain_controllers is None and 'domainControllers' in kwargs:
            domain_controllers = kwargs['domainControllers']
        if organizational_unit is None and 'organizationalUnit' in kwargs:
            organizational_unit = kwargs['organizationalUnit']
        if timeout_in_seconds is None and 'timeoutInSeconds' in kwargs:
            timeout_in_seconds = kwargs['timeoutInSeconds']

        _setter("domain_name", domain_name)
        _setter("password", password)
        _setter("username", username)
        if active_directory_status is not None:
            _setter("active_directory_status", active_directory_status)
        if domain_controllers is not None:
            _setter("domain_controllers", domain_controllers)
        if organizational_unit is not None:
            _setter("organizational_unit", organizational_unit)
        if timeout_in_seconds is not None:
            _setter("timeout_in_seconds", timeout_in_seconds)

    @property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> str:
        """
        The name of the domain that you want the gateway to join.
        """
        return pulumi.get(self, "domain_name")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The password of the user who has permission to add the gateway to the Active Directory domain.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The user name of user who has permission to add the gateway to the Active Directory domain.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="activeDirectoryStatus")
    def active_directory_status(self) -> Optional[str]:
        return pulumi.get(self, "active_directory_status")

    @property
    @pulumi.getter(name="domainControllers")
    def domain_controllers(self) -> Optional[Sequence[str]]:
        """
        List of IPv4 addresses, NetBIOS names, or host names of your domain server.
        If you need to specify the port number include it after the colon (“:”). For example, `mydc.mydomain.com:389`.
        """
        return pulumi.get(self, "domain_controllers")

    @property
    @pulumi.getter(name="organizationalUnit")
    def organizational_unit(self) -> Optional[str]:
        """
        The organizational unit (OU) is a container in an Active Directory that can hold users, groups,
        computers, and other OUs and this parameter specifies the OU that the gateway will join within the AD domain.
        """
        return pulumi.get(self, "organizational_unit")

    @property
    @pulumi.getter(name="timeoutInSeconds")
    def timeout_in_seconds(self) -> Optional[int]:
        """
        Specifies the time in seconds, in which the JoinDomain operation must complete. The default is `20` seconds.
        """
        return pulumi.get(self, "timeout_in_seconds")


@pulumi.output_type
class NfsFileShareCacheAttributes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cacheStaleTimeoutInSeconds":
            suggest = "cache_stale_timeout_in_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NfsFileShareCacheAttributes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NfsFileShareCacheAttributes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NfsFileShareCacheAttributes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cache_stale_timeout_in_seconds: Optional[int] = None):
        """
        :param int cache_stale_timeout_in_seconds: Refreshes a file share's cache by using Time To Live (TTL).
               TTL is the length of time since the last refresh after which access to the directory would cause the file gateway
               to first refresh that directory's contents from the Amazon S3 bucket. Valid Values: 300 to 2,592,000 seconds (5 minutes to 30 days)
        """
        NfsFileShareCacheAttributes._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cache_stale_timeout_in_seconds=cache_stale_timeout_in_seconds,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cache_stale_timeout_in_seconds: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cache_stale_timeout_in_seconds is None and 'cacheStaleTimeoutInSeconds' in kwargs:
            cache_stale_timeout_in_seconds = kwargs['cacheStaleTimeoutInSeconds']

        if cache_stale_timeout_in_seconds is not None:
            _setter("cache_stale_timeout_in_seconds", cache_stale_timeout_in_seconds)

    @property
    @pulumi.getter(name="cacheStaleTimeoutInSeconds")
    def cache_stale_timeout_in_seconds(self) -> Optional[int]:
        """
        Refreshes a file share's cache by using Time To Live (TTL).
        TTL is the length of time since the last refresh after which access to the directory would cause the file gateway
        to first refresh that directory's contents from the Amazon S3 bucket. Valid Values: 300 to 2,592,000 seconds (5 minutes to 30 days)
        """
        return pulumi.get(self, "cache_stale_timeout_in_seconds")


@pulumi.output_type
class NfsFileShareNfsFileShareDefaults(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "directoryMode":
            suggest = "directory_mode"
        elif key == "fileMode":
            suggest = "file_mode"
        elif key == "groupId":
            suggest = "group_id"
        elif key == "ownerId":
            suggest = "owner_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NfsFileShareNfsFileShareDefaults. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NfsFileShareNfsFileShareDefaults.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NfsFileShareNfsFileShareDefaults.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 directory_mode: Optional[str] = None,
                 file_mode: Optional[str] = None,
                 group_id: Optional[str] = None,
                 owner_id: Optional[str] = None):
        """
        :param str directory_mode: The Unix directory mode in the string form "nnnn". Defaults to `"0777"`.
        :param str file_mode: The Unix file mode in the string form "nnnn". Defaults to `"0666"`.
        :param str group_id: The default group ID for the file share (unless the files have another group ID specified). Defaults to `65534` (`nfsnobody`). Valid values: `0` through `4294967294`.
        :param str owner_id: The default owner ID for the file share (unless the files have another owner ID specified). Defaults to `65534` (`nfsnobody`). Valid values: `0` through `4294967294`.
        """
        NfsFileShareNfsFileShareDefaults._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            directory_mode=directory_mode,
            file_mode=file_mode,
            group_id=group_id,
            owner_id=owner_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             directory_mode: Optional[str] = None,
             file_mode: Optional[str] = None,
             group_id: Optional[str] = None,
             owner_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if directory_mode is None and 'directoryMode' in kwargs:
            directory_mode = kwargs['directoryMode']
        if file_mode is None and 'fileMode' in kwargs:
            file_mode = kwargs['fileMode']
        if group_id is None and 'groupId' in kwargs:
            group_id = kwargs['groupId']
        if owner_id is None and 'ownerId' in kwargs:
            owner_id = kwargs['ownerId']

        if directory_mode is not None:
            _setter("directory_mode", directory_mode)
        if file_mode is not None:
            _setter("file_mode", file_mode)
        if group_id is not None:
            _setter("group_id", group_id)
        if owner_id is not None:
            _setter("owner_id", owner_id)

    @property
    @pulumi.getter(name="directoryMode")
    def directory_mode(self) -> Optional[str]:
        """
        The Unix directory mode in the string form "nnnn". Defaults to `"0777"`.
        """
        return pulumi.get(self, "directory_mode")

    @property
    @pulumi.getter(name="fileMode")
    def file_mode(self) -> Optional[str]:
        """
        The Unix file mode in the string form "nnnn". Defaults to `"0666"`.
        """
        return pulumi.get(self, "file_mode")

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[str]:
        """
        The default group ID for the file share (unless the files have another group ID specified). Defaults to `65534` (`nfsnobody`). Valid values: `0` through `4294967294`.
        """
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter(name="ownerId")
    def owner_id(self) -> Optional[str]:
        """
        The default owner ID for the file share (unless the files have another owner ID specified). Defaults to `65534` (`nfsnobody`). Valid values: `0` through `4294967294`.
        """
        return pulumi.get(self, "owner_id")


@pulumi.output_type
class SmbFileShareCacheAttributes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cacheStaleTimeoutInSeconds":
            suggest = "cache_stale_timeout_in_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SmbFileShareCacheAttributes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SmbFileShareCacheAttributes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SmbFileShareCacheAttributes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cache_stale_timeout_in_seconds: Optional[int] = None):
        """
        :param int cache_stale_timeout_in_seconds: Refreshes a file share's cache by using Time To Live (TTL).
               TTL is the length of time since the last refresh after which access to the directory would cause the file gateway
               to first refresh that directory's contents from the Amazon S3 bucket. Valid Values: 300 to 2,592,000 seconds (5 minutes to 30 days)
        """
        SmbFileShareCacheAttributes._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cache_stale_timeout_in_seconds=cache_stale_timeout_in_seconds,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cache_stale_timeout_in_seconds: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cache_stale_timeout_in_seconds is None and 'cacheStaleTimeoutInSeconds' in kwargs:
            cache_stale_timeout_in_seconds = kwargs['cacheStaleTimeoutInSeconds']

        if cache_stale_timeout_in_seconds is not None:
            _setter("cache_stale_timeout_in_seconds", cache_stale_timeout_in_seconds)

    @property
    @pulumi.getter(name="cacheStaleTimeoutInSeconds")
    def cache_stale_timeout_in_seconds(self) -> Optional[int]:
        """
        Refreshes a file share's cache by using Time To Live (TTL).
        TTL is the length of time since the last refresh after which access to the directory would cause the file gateway
        to first refresh that directory's contents from the Amazon S3 bucket. Valid Values: 300 to 2,592,000 seconds (5 minutes to 30 days)
        """
        return pulumi.get(self, "cache_stale_timeout_in_seconds")


