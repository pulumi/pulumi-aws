# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'ConnectorCapacityArgs',
    'ConnectorCapacityArgsDict',
    'ConnectorCapacityAutoscalingArgs',
    'ConnectorCapacityAutoscalingArgsDict',
    'ConnectorCapacityAutoscalingScaleInPolicyArgs',
    'ConnectorCapacityAutoscalingScaleInPolicyArgsDict',
    'ConnectorCapacityAutoscalingScaleOutPolicyArgs',
    'ConnectorCapacityAutoscalingScaleOutPolicyArgsDict',
    'ConnectorCapacityProvisionedCapacityArgs',
    'ConnectorCapacityProvisionedCapacityArgsDict',
    'ConnectorKafkaClusterArgs',
    'ConnectorKafkaClusterArgsDict',
    'ConnectorKafkaClusterApacheKafkaClusterArgs',
    'ConnectorKafkaClusterApacheKafkaClusterArgsDict',
    'ConnectorKafkaClusterApacheKafkaClusterVpcArgs',
    'ConnectorKafkaClusterApacheKafkaClusterVpcArgsDict',
    'ConnectorKafkaClusterClientAuthenticationArgs',
    'ConnectorKafkaClusterClientAuthenticationArgsDict',
    'ConnectorKafkaClusterEncryptionInTransitArgs',
    'ConnectorKafkaClusterEncryptionInTransitArgsDict',
    'ConnectorLogDeliveryArgs',
    'ConnectorLogDeliveryArgsDict',
    'ConnectorLogDeliveryWorkerLogDeliveryArgs',
    'ConnectorLogDeliveryWorkerLogDeliveryArgsDict',
    'ConnectorLogDeliveryWorkerLogDeliveryCloudwatchLogsArgs',
    'ConnectorLogDeliveryWorkerLogDeliveryCloudwatchLogsArgsDict',
    'ConnectorLogDeliveryWorkerLogDeliveryFirehoseArgs',
    'ConnectorLogDeliveryWorkerLogDeliveryFirehoseArgsDict',
    'ConnectorLogDeliveryWorkerLogDeliveryS3Args',
    'ConnectorLogDeliveryWorkerLogDeliveryS3ArgsDict',
    'ConnectorPluginArgs',
    'ConnectorPluginArgsDict',
    'ConnectorPluginCustomPluginArgs',
    'ConnectorPluginCustomPluginArgsDict',
    'ConnectorWorkerConfigurationArgs',
    'ConnectorWorkerConfigurationArgsDict',
    'CustomPluginLocationArgs',
    'CustomPluginLocationArgsDict',
    'CustomPluginLocationS3Args',
    'CustomPluginLocationS3ArgsDict',
]

MYPY = False

if not MYPY:
    class ConnectorCapacityArgsDict(TypedDict):
        autoscaling: NotRequired[pulumi.Input['ConnectorCapacityAutoscalingArgsDict']]
        provisioned_capacity: NotRequired[pulumi.Input['ConnectorCapacityProvisionedCapacityArgsDict']]
elif False:
    ConnectorCapacityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectorCapacityArgs:
    def __init__(__self__, *,
                 autoscaling: Optional[pulumi.Input['ConnectorCapacityAutoscalingArgs']] = None,
                 provisioned_capacity: Optional[pulumi.Input['ConnectorCapacityProvisionedCapacityArgs']] = None):
        if autoscaling is not None:
            pulumi.set(__self__, "autoscaling", autoscaling)
        if provisioned_capacity is not None:
            pulumi.set(__self__, "provisioned_capacity", provisioned_capacity)

    @_builtins.property
    @pulumi.getter
    def autoscaling(self) -> Optional[pulumi.Input['ConnectorCapacityAutoscalingArgs']]:
        return pulumi.get(self, "autoscaling")

    @autoscaling.setter
    def autoscaling(self, value: Optional[pulumi.Input['ConnectorCapacityAutoscalingArgs']]):
        pulumi.set(self, "autoscaling", value)

    @_builtins.property
    @pulumi.getter(name="provisionedCapacity")
    def provisioned_capacity(self) -> Optional[pulumi.Input['ConnectorCapacityProvisionedCapacityArgs']]:
        return pulumi.get(self, "provisioned_capacity")

    @provisioned_capacity.setter
    def provisioned_capacity(self, value: Optional[pulumi.Input['ConnectorCapacityProvisionedCapacityArgs']]):
        pulumi.set(self, "provisioned_capacity", value)


if not MYPY:
    class ConnectorCapacityAutoscalingArgsDict(TypedDict):
        max_worker_count: pulumi.Input[_builtins.int]
        min_worker_count: pulumi.Input[_builtins.int]
        mcu_count: NotRequired[pulumi.Input[_builtins.int]]
        scale_in_policy: NotRequired[pulumi.Input['ConnectorCapacityAutoscalingScaleInPolicyArgsDict']]
        scale_out_policy: NotRequired[pulumi.Input['ConnectorCapacityAutoscalingScaleOutPolicyArgsDict']]
elif False:
    ConnectorCapacityAutoscalingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectorCapacityAutoscalingArgs:
    def __init__(__self__, *,
                 max_worker_count: pulumi.Input[_builtins.int],
                 min_worker_count: pulumi.Input[_builtins.int],
                 mcu_count: Optional[pulumi.Input[_builtins.int]] = None,
                 scale_in_policy: Optional[pulumi.Input['ConnectorCapacityAutoscalingScaleInPolicyArgs']] = None,
                 scale_out_policy: Optional[pulumi.Input['ConnectorCapacityAutoscalingScaleOutPolicyArgs']] = None):
        pulumi.set(__self__, "max_worker_count", max_worker_count)
        pulumi.set(__self__, "min_worker_count", min_worker_count)
        if mcu_count is not None:
            pulumi.set(__self__, "mcu_count", mcu_count)
        if scale_in_policy is not None:
            pulumi.set(__self__, "scale_in_policy", scale_in_policy)
        if scale_out_policy is not None:
            pulumi.set(__self__, "scale_out_policy", scale_out_policy)

    @_builtins.property
    @pulumi.getter(name="maxWorkerCount")
    def max_worker_count(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "max_worker_count")

    @max_worker_count.setter
    def max_worker_count(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "max_worker_count", value)

    @_builtins.property
    @pulumi.getter(name="minWorkerCount")
    def min_worker_count(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "min_worker_count")

    @min_worker_count.setter
    def min_worker_count(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "min_worker_count", value)

    @_builtins.property
    @pulumi.getter(name="mcuCount")
    def mcu_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "mcu_count")

    @mcu_count.setter
    def mcu_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "mcu_count", value)

    @_builtins.property
    @pulumi.getter(name="scaleInPolicy")
    def scale_in_policy(self) -> Optional[pulumi.Input['ConnectorCapacityAutoscalingScaleInPolicyArgs']]:
        return pulumi.get(self, "scale_in_policy")

    @scale_in_policy.setter
    def scale_in_policy(self, value: Optional[pulumi.Input['ConnectorCapacityAutoscalingScaleInPolicyArgs']]):
        pulumi.set(self, "scale_in_policy", value)

    @_builtins.property
    @pulumi.getter(name="scaleOutPolicy")
    def scale_out_policy(self) -> Optional[pulumi.Input['ConnectorCapacityAutoscalingScaleOutPolicyArgs']]:
        return pulumi.get(self, "scale_out_policy")

    @scale_out_policy.setter
    def scale_out_policy(self, value: Optional[pulumi.Input['ConnectorCapacityAutoscalingScaleOutPolicyArgs']]):
        pulumi.set(self, "scale_out_policy", value)


if not MYPY:
    class ConnectorCapacityAutoscalingScaleInPolicyArgsDict(TypedDict):
        cpu_utilization_percentage: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    ConnectorCapacityAutoscalingScaleInPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectorCapacityAutoscalingScaleInPolicyArgs:
    def __init__(__self__, *,
                 cpu_utilization_percentage: Optional[pulumi.Input[_builtins.int]] = None):
        if cpu_utilization_percentage is not None:
            pulumi.set(__self__, "cpu_utilization_percentage", cpu_utilization_percentage)

    @_builtins.property
    @pulumi.getter(name="cpuUtilizationPercentage")
    def cpu_utilization_percentage(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "cpu_utilization_percentage")

    @cpu_utilization_percentage.setter
    def cpu_utilization_percentage(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "cpu_utilization_percentage", value)


if not MYPY:
    class ConnectorCapacityAutoscalingScaleOutPolicyArgsDict(TypedDict):
        cpu_utilization_percentage: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    ConnectorCapacityAutoscalingScaleOutPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectorCapacityAutoscalingScaleOutPolicyArgs:
    def __init__(__self__, *,
                 cpu_utilization_percentage: Optional[pulumi.Input[_builtins.int]] = None):
        if cpu_utilization_percentage is not None:
            pulumi.set(__self__, "cpu_utilization_percentage", cpu_utilization_percentage)

    @_builtins.property
    @pulumi.getter(name="cpuUtilizationPercentage")
    def cpu_utilization_percentage(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "cpu_utilization_percentage")

    @cpu_utilization_percentage.setter
    def cpu_utilization_percentage(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "cpu_utilization_percentage", value)


if not MYPY:
    class ConnectorCapacityProvisionedCapacityArgsDict(TypedDict):
        worker_count: pulumi.Input[_builtins.int]
        mcu_count: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    ConnectorCapacityProvisionedCapacityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectorCapacityProvisionedCapacityArgs:
    def __init__(__self__, *,
                 worker_count: pulumi.Input[_builtins.int],
                 mcu_count: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "worker_count", worker_count)
        if mcu_count is not None:
            pulumi.set(__self__, "mcu_count", mcu_count)

    @_builtins.property
    @pulumi.getter(name="workerCount")
    def worker_count(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "worker_count")

    @worker_count.setter
    def worker_count(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "worker_count", value)

    @_builtins.property
    @pulumi.getter(name="mcuCount")
    def mcu_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "mcu_count")

    @mcu_count.setter
    def mcu_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "mcu_count", value)


if not MYPY:
    class ConnectorKafkaClusterArgsDict(TypedDict):
        apache_kafka_cluster: pulumi.Input['ConnectorKafkaClusterApacheKafkaClusterArgsDict']
elif False:
    ConnectorKafkaClusterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectorKafkaClusterArgs:
    def __init__(__self__, *,
                 apache_kafka_cluster: pulumi.Input['ConnectorKafkaClusterApacheKafkaClusterArgs']):
        pulumi.set(__self__, "apache_kafka_cluster", apache_kafka_cluster)

    @_builtins.property
    @pulumi.getter(name="apacheKafkaCluster")
    def apache_kafka_cluster(self) -> pulumi.Input['ConnectorKafkaClusterApacheKafkaClusterArgs']:
        return pulumi.get(self, "apache_kafka_cluster")

    @apache_kafka_cluster.setter
    def apache_kafka_cluster(self, value: pulumi.Input['ConnectorKafkaClusterApacheKafkaClusterArgs']):
        pulumi.set(self, "apache_kafka_cluster", value)


if not MYPY:
    class ConnectorKafkaClusterApacheKafkaClusterArgsDict(TypedDict):
        bootstrap_servers: pulumi.Input[_builtins.str]
        vpc: pulumi.Input['ConnectorKafkaClusterApacheKafkaClusterVpcArgsDict']
elif False:
    ConnectorKafkaClusterApacheKafkaClusterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectorKafkaClusterApacheKafkaClusterArgs:
    def __init__(__self__, *,
                 bootstrap_servers: pulumi.Input[_builtins.str],
                 vpc: pulumi.Input['ConnectorKafkaClusterApacheKafkaClusterVpcArgs']):
        pulumi.set(__self__, "bootstrap_servers", bootstrap_servers)
        pulumi.set(__self__, "vpc", vpc)

    @_builtins.property
    @pulumi.getter(name="bootstrapServers")
    def bootstrap_servers(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "bootstrap_servers")

    @bootstrap_servers.setter
    def bootstrap_servers(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bootstrap_servers", value)

    @_builtins.property
    @pulumi.getter
    def vpc(self) -> pulumi.Input['ConnectorKafkaClusterApacheKafkaClusterVpcArgs']:
        return pulumi.get(self, "vpc")

    @vpc.setter
    def vpc(self, value: pulumi.Input['ConnectorKafkaClusterApacheKafkaClusterVpcArgs']):
        pulumi.set(self, "vpc", value)


if not MYPY:
    class ConnectorKafkaClusterApacheKafkaClusterVpcArgsDict(TypedDict):
        security_groups: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        subnets: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
elif False:
    ConnectorKafkaClusterApacheKafkaClusterVpcArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectorKafkaClusterApacheKafkaClusterVpcArgs:
    def __init__(__self__, *,
                 security_groups: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 subnets: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(__self__, "security_groups", security_groups)
        pulumi.set(__self__, "subnets", subnets)

    @_builtins.property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "security_groups")

    @security_groups.setter
    def security_groups(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "security_groups", value)

    @_builtins.property
    @pulumi.getter
    def subnets(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "subnets")

    @subnets.setter
    def subnets(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "subnets", value)


if not MYPY:
    class ConnectorKafkaClusterClientAuthenticationArgsDict(TypedDict):
        authentication_type: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ConnectorKafkaClusterClientAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectorKafkaClusterClientAuthenticationArgs:
    def __init__(__self__, *,
                 authentication_type: Optional[pulumi.Input[_builtins.str]] = None):
        if authentication_type is not None:
            pulumi.set(__self__, "authentication_type", authentication_type)

    @_builtins.property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "authentication_type")

    @authentication_type.setter
    def authentication_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "authentication_type", value)


if not MYPY:
    class ConnectorKafkaClusterEncryptionInTransitArgsDict(TypedDict):
        encryption_type: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ConnectorKafkaClusterEncryptionInTransitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectorKafkaClusterEncryptionInTransitArgs:
    def __init__(__self__, *,
                 encryption_type: Optional[pulumi.Input[_builtins.str]] = None):
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)

    @_builtins.property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "encryption_type")

    @encryption_type.setter
    def encryption_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "encryption_type", value)


if not MYPY:
    class ConnectorLogDeliveryArgsDict(TypedDict):
        worker_log_delivery: pulumi.Input['ConnectorLogDeliveryWorkerLogDeliveryArgsDict']
elif False:
    ConnectorLogDeliveryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectorLogDeliveryArgs:
    def __init__(__self__, *,
                 worker_log_delivery: pulumi.Input['ConnectorLogDeliveryWorkerLogDeliveryArgs']):
        pulumi.set(__self__, "worker_log_delivery", worker_log_delivery)

    @_builtins.property
    @pulumi.getter(name="workerLogDelivery")
    def worker_log_delivery(self) -> pulumi.Input['ConnectorLogDeliveryWorkerLogDeliveryArgs']:
        return pulumi.get(self, "worker_log_delivery")

    @worker_log_delivery.setter
    def worker_log_delivery(self, value: pulumi.Input['ConnectorLogDeliveryWorkerLogDeliveryArgs']):
        pulumi.set(self, "worker_log_delivery", value)


if not MYPY:
    class ConnectorLogDeliveryWorkerLogDeliveryArgsDict(TypedDict):
        cloudwatch_logs: NotRequired[pulumi.Input['ConnectorLogDeliveryWorkerLogDeliveryCloudwatchLogsArgsDict']]
        firehose: NotRequired[pulumi.Input['ConnectorLogDeliveryWorkerLogDeliveryFirehoseArgsDict']]
        s3: NotRequired[pulumi.Input['ConnectorLogDeliveryWorkerLogDeliveryS3ArgsDict']]
elif False:
    ConnectorLogDeliveryWorkerLogDeliveryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectorLogDeliveryWorkerLogDeliveryArgs:
    def __init__(__self__, *,
                 cloudwatch_logs: Optional[pulumi.Input['ConnectorLogDeliveryWorkerLogDeliveryCloudwatchLogsArgs']] = None,
                 firehose: Optional[pulumi.Input['ConnectorLogDeliveryWorkerLogDeliveryFirehoseArgs']] = None,
                 s3: Optional[pulumi.Input['ConnectorLogDeliveryWorkerLogDeliveryS3Args']] = None):
        if cloudwatch_logs is not None:
            pulumi.set(__self__, "cloudwatch_logs", cloudwatch_logs)
        if firehose is not None:
            pulumi.set(__self__, "firehose", firehose)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)

    @_builtins.property
    @pulumi.getter(name="cloudwatchLogs")
    def cloudwatch_logs(self) -> Optional[pulumi.Input['ConnectorLogDeliveryWorkerLogDeliveryCloudwatchLogsArgs']]:
        return pulumi.get(self, "cloudwatch_logs")

    @cloudwatch_logs.setter
    def cloudwatch_logs(self, value: Optional[pulumi.Input['ConnectorLogDeliveryWorkerLogDeliveryCloudwatchLogsArgs']]):
        pulumi.set(self, "cloudwatch_logs", value)

    @_builtins.property
    @pulumi.getter
    def firehose(self) -> Optional[pulumi.Input['ConnectorLogDeliveryWorkerLogDeliveryFirehoseArgs']]:
        return pulumi.get(self, "firehose")

    @firehose.setter
    def firehose(self, value: Optional[pulumi.Input['ConnectorLogDeliveryWorkerLogDeliveryFirehoseArgs']]):
        pulumi.set(self, "firehose", value)

    @_builtins.property
    @pulumi.getter
    def s3(self) -> Optional[pulumi.Input['ConnectorLogDeliveryWorkerLogDeliveryS3Args']]:
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional[pulumi.Input['ConnectorLogDeliveryWorkerLogDeliveryS3Args']]):
        pulumi.set(self, "s3", value)


if not MYPY:
    class ConnectorLogDeliveryWorkerLogDeliveryCloudwatchLogsArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        log_group: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ConnectorLogDeliveryWorkerLogDeliveryCloudwatchLogsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectorLogDeliveryWorkerLogDeliveryCloudwatchLogsArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 log_group: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "enabled", enabled)
        if log_group is not None:
            pulumi.set(__self__, "log_group", log_group)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="logGroup")
    def log_group(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "log_group")

    @log_group.setter
    def log_group(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_group", value)


if not MYPY:
    class ConnectorLogDeliveryWorkerLogDeliveryFirehoseArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        delivery_stream: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ConnectorLogDeliveryWorkerLogDeliveryFirehoseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectorLogDeliveryWorkerLogDeliveryFirehoseArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 delivery_stream: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "enabled", enabled)
        if delivery_stream is not None:
            pulumi.set(__self__, "delivery_stream", delivery_stream)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="deliveryStream")
    def delivery_stream(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "delivery_stream")

    @delivery_stream.setter
    def delivery_stream(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delivery_stream", value)


if not MYPY:
    class ConnectorLogDeliveryWorkerLogDeliveryS3ArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        bucket: NotRequired[pulumi.Input[_builtins.str]]
        prefix: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ConnectorLogDeliveryWorkerLogDeliveryS3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectorLogDeliveryWorkerLogDeliveryS3Args:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 bucket: Optional[pulumi.Input[_builtins.str]] = None,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "enabled", enabled)
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)


if not MYPY:
    class ConnectorPluginArgsDict(TypedDict):
        custom_plugin: pulumi.Input['ConnectorPluginCustomPluginArgsDict']
elif False:
    ConnectorPluginArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectorPluginArgs:
    def __init__(__self__, *,
                 custom_plugin: pulumi.Input['ConnectorPluginCustomPluginArgs']):
        pulumi.set(__self__, "custom_plugin", custom_plugin)

    @_builtins.property
    @pulumi.getter(name="customPlugin")
    def custom_plugin(self) -> pulumi.Input['ConnectorPluginCustomPluginArgs']:
        return pulumi.get(self, "custom_plugin")

    @custom_plugin.setter
    def custom_plugin(self, value: pulumi.Input['ConnectorPluginCustomPluginArgs']):
        pulumi.set(self, "custom_plugin", value)


if not MYPY:
    class ConnectorPluginCustomPluginArgsDict(TypedDict):
        arn: pulumi.Input[_builtins.str]
        revision: pulumi.Input[_builtins.int]
elif False:
    ConnectorPluginCustomPluginArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectorPluginCustomPluginArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[_builtins.str],
                 revision: pulumi.Input[_builtins.int]):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "revision", revision)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "arn", value)

    @_builtins.property
    @pulumi.getter
    def revision(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "revision")

    @revision.setter
    def revision(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "revision", value)


if not MYPY:
    class ConnectorWorkerConfigurationArgsDict(TypedDict):
        arn: pulumi.Input[_builtins.str]
        revision: pulumi.Input[_builtins.int]
elif False:
    ConnectorWorkerConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectorWorkerConfigurationArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[_builtins.str],
                 revision: pulumi.Input[_builtins.int]):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "revision", revision)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "arn", value)

    @_builtins.property
    @pulumi.getter
    def revision(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "revision")

    @revision.setter
    def revision(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "revision", value)


if not MYPY:
    class CustomPluginLocationArgsDict(TypedDict):
        s3: pulumi.Input['CustomPluginLocationS3ArgsDict']
elif False:
    CustomPluginLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomPluginLocationArgs:
    def __init__(__self__, *,
                 s3: pulumi.Input['CustomPluginLocationS3Args']):
        pulumi.set(__self__, "s3", s3)

    @_builtins.property
    @pulumi.getter
    def s3(self) -> pulumi.Input['CustomPluginLocationS3Args']:
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: pulumi.Input['CustomPluginLocationS3Args']):
        pulumi.set(self, "s3", value)


if not MYPY:
    class CustomPluginLocationS3ArgsDict(TypedDict):
        bucket_arn: pulumi.Input[_builtins.str]
        file_key: pulumi.Input[_builtins.str]
        object_version: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    CustomPluginLocationS3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomPluginLocationS3Args:
    def __init__(__self__, *,
                 bucket_arn: pulumi.Input[_builtins.str],
                 file_key: pulumi.Input[_builtins.str],
                 object_version: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "bucket_arn", bucket_arn)
        pulumi.set(__self__, "file_key", file_key)
        if object_version is not None:
            pulumi.set(__self__, "object_version", object_version)

    @_builtins.property
    @pulumi.getter(name="bucketArn")
    def bucket_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "bucket_arn")

    @bucket_arn.setter
    def bucket_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket_arn", value)

    @_builtins.property
    @pulumi.getter(name="fileKey")
    def file_key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "file_key")

    @file_key.setter
    def file_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "file_key", value)

    @_builtins.property
    @pulumi.getter(name="objectVersion")
    def object_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "object_version")

    @object_version.setter
    def object_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "object_version", value)


