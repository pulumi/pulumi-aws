# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'CatalogDatabaseCreateTableDefaultPermissionArgs',
    'CatalogDatabaseCreateTableDefaultPermissionArgsDict',
    'CatalogDatabaseCreateTableDefaultPermissionPrincipalArgs',
    'CatalogDatabaseCreateTableDefaultPermissionPrincipalArgsDict',
    'CatalogDatabaseFederatedDatabaseArgs',
    'CatalogDatabaseFederatedDatabaseArgsDict',
    'CatalogDatabaseTargetDatabaseArgs',
    'CatalogDatabaseTargetDatabaseArgsDict',
    'CatalogTableOpenTableFormatInputArgs',
    'CatalogTableOpenTableFormatInputArgsDict',
    'CatalogTableOpenTableFormatInputIcebergInputArgs',
    'CatalogTableOpenTableFormatInputIcebergInputArgsDict',
    'CatalogTableOptimizerConfigurationArgs',
    'CatalogTableOptimizerConfigurationArgsDict',
    'CatalogTableOptimizerConfigurationOrphanFileDeletionConfigurationArgs',
    'CatalogTableOptimizerConfigurationOrphanFileDeletionConfigurationArgsDict',
    'CatalogTableOptimizerConfigurationOrphanFileDeletionConfigurationIcebergConfigurationArgs',
    'CatalogTableOptimizerConfigurationOrphanFileDeletionConfigurationIcebergConfigurationArgsDict',
    'CatalogTableOptimizerConfigurationRetentionConfigurationArgs',
    'CatalogTableOptimizerConfigurationRetentionConfigurationArgsDict',
    'CatalogTableOptimizerConfigurationRetentionConfigurationIcebergConfigurationArgs',
    'CatalogTableOptimizerConfigurationRetentionConfigurationIcebergConfigurationArgsDict',
    'CatalogTablePartitionIndexArgs',
    'CatalogTablePartitionIndexArgsDict',
    'CatalogTablePartitionKeyArgs',
    'CatalogTablePartitionKeyArgsDict',
    'CatalogTableStorageDescriptorArgs',
    'CatalogTableStorageDescriptorArgsDict',
    'CatalogTableStorageDescriptorColumnArgs',
    'CatalogTableStorageDescriptorColumnArgsDict',
    'CatalogTableStorageDescriptorSchemaReferenceArgs',
    'CatalogTableStorageDescriptorSchemaReferenceArgsDict',
    'CatalogTableStorageDescriptorSchemaReferenceSchemaIdArgs',
    'CatalogTableStorageDescriptorSchemaReferenceSchemaIdArgsDict',
    'CatalogTableStorageDescriptorSerDeInfoArgs',
    'CatalogTableStorageDescriptorSerDeInfoArgsDict',
    'CatalogTableStorageDescriptorSkewedInfoArgs',
    'CatalogTableStorageDescriptorSkewedInfoArgsDict',
    'CatalogTableStorageDescriptorSortColumnArgs',
    'CatalogTableStorageDescriptorSortColumnArgsDict',
    'CatalogTableTargetTableArgs',
    'CatalogTableTargetTableArgsDict',
    'ClassifierCsvClassifierArgs',
    'ClassifierCsvClassifierArgsDict',
    'ClassifierGrokClassifierArgs',
    'ClassifierGrokClassifierArgsDict',
    'ClassifierJsonClassifierArgs',
    'ClassifierJsonClassifierArgsDict',
    'ClassifierXmlClassifierArgs',
    'ClassifierXmlClassifierArgsDict',
    'ConnectionPhysicalConnectionRequirementsArgs',
    'ConnectionPhysicalConnectionRequirementsArgsDict',
    'CrawlerCatalogTargetArgs',
    'CrawlerCatalogTargetArgsDict',
    'CrawlerDeltaTargetArgs',
    'CrawlerDeltaTargetArgsDict',
    'CrawlerDynamodbTargetArgs',
    'CrawlerDynamodbTargetArgsDict',
    'CrawlerHudiTargetArgs',
    'CrawlerHudiTargetArgsDict',
    'CrawlerIcebergTargetArgs',
    'CrawlerIcebergTargetArgsDict',
    'CrawlerJdbcTargetArgs',
    'CrawlerJdbcTargetArgsDict',
    'CrawlerLakeFormationConfigurationArgs',
    'CrawlerLakeFormationConfigurationArgsDict',
    'CrawlerLineageConfigurationArgs',
    'CrawlerLineageConfigurationArgsDict',
    'CrawlerMongodbTargetArgs',
    'CrawlerMongodbTargetArgsDict',
    'CrawlerRecrawlPolicyArgs',
    'CrawlerRecrawlPolicyArgsDict',
    'CrawlerS3TargetArgs',
    'CrawlerS3TargetArgsDict',
    'CrawlerSchemaChangePolicyArgs',
    'CrawlerSchemaChangePolicyArgsDict',
    'DataCatalogEncryptionSettingsDataCatalogEncryptionSettingsArgs',
    'DataCatalogEncryptionSettingsDataCatalogEncryptionSettingsArgsDict',
    'DataCatalogEncryptionSettingsDataCatalogEncryptionSettingsConnectionPasswordEncryptionArgs',
    'DataCatalogEncryptionSettingsDataCatalogEncryptionSettingsConnectionPasswordEncryptionArgsDict',
    'DataCatalogEncryptionSettingsDataCatalogEncryptionSettingsEncryptionAtRestArgs',
    'DataCatalogEncryptionSettingsDataCatalogEncryptionSettingsEncryptionAtRestArgsDict',
    'DataQualityRulesetTargetTableArgs',
    'DataQualityRulesetTargetTableArgsDict',
    'JobCommandArgs',
    'JobCommandArgsDict',
    'JobExecutionPropertyArgs',
    'JobExecutionPropertyArgsDict',
    'JobNotificationPropertyArgs',
    'JobNotificationPropertyArgsDict',
    'JobSourceControlDetailsArgs',
    'JobSourceControlDetailsArgsDict',
    'MLTransformInputRecordTableArgs',
    'MLTransformInputRecordTableArgsDict',
    'MLTransformParametersArgs',
    'MLTransformParametersArgsDict',
    'MLTransformParametersFindMatchesParametersArgs',
    'MLTransformParametersFindMatchesParametersArgsDict',
    'MLTransformSchemaArgs',
    'MLTransformSchemaArgsDict',
    'PartitionIndexPartitionIndexArgs',
    'PartitionIndexPartitionIndexArgsDict',
    'PartitionStorageDescriptorArgs',
    'PartitionStorageDescriptorArgsDict',
    'PartitionStorageDescriptorColumnArgs',
    'PartitionStorageDescriptorColumnArgsDict',
    'PartitionStorageDescriptorSerDeInfoArgs',
    'PartitionStorageDescriptorSerDeInfoArgsDict',
    'PartitionStorageDescriptorSkewedInfoArgs',
    'PartitionStorageDescriptorSkewedInfoArgsDict',
    'PartitionStorageDescriptorSortColumnArgs',
    'PartitionStorageDescriptorSortColumnArgsDict',
    'SecurityConfigurationEncryptionConfigurationArgs',
    'SecurityConfigurationEncryptionConfigurationArgsDict',
    'SecurityConfigurationEncryptionConfigurationCloudwatchEncryptionArgs',
    'SecurityConfigurationEncryptionConfigurationCloudwatchEncryptionArgsDict',
    'SecurityConfigurationEncryptionConfigurationJobBookmarksEncryptionArgs',
    'SecurityConfigurationEncryptionConfigurationJobBookmarksEncryptionArgsDict',
    'SecurityConfigurationEncryptionConfigurationS3EncryptionArgs',
    'SecurityConfigurationEncryptionConfigurationS3EncryptionArgsDict',
    'TriggerActionArgs',
    'TriggerActionArgsDict',
    'TriggerActionNotificationPropertyArgs',
    'TriggerActionNotificationPropertyArgsDict',
    'TriggerEventBatchingConditionArgs',
    'TriggerEventBatchingConditionArgsDict',
    'TriggerPredicateArgs',
    'TriggerPredicateArgsDict',
    'TriggerPredicateConditionArgs',
    'TriggerPredicateConditionArgsDict',
    'UserDefinedFunctionResourceUriArgs',
    'UserDefinedFunctionResourceUriArgsDict',
    'GetScriptDagEdgeArgs',
    'GetScriptDagEdgeArgsDict',
    'GetScriptDagNodeArgs',
    'GetScriptDagNodeArgsDict',
    'GetScriptDagNodeArgArgs',
    'GetScriptDagNodeArgArgsDict',
]

MYPY = False

if not MYPY:
    class CatalogDatabaseCreateTableDefaultPermissionArgsDict(TypedDict):
        permissions: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        principal: NotRequired[pulumi.Input['CatalogDatabaseCreateTableDefaultPermissionPrincipalArgsDict']]
elif False:
    CatalogDatabaseCreateTableDefaultPermissionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CatalogDatabaseCreateTableDefaultPermissionArgs:
    def __init__(__self__, *,
                 permissions: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 principal: Optional[pulumi.Input['CatalogDatabaseCreateTableDefaultPermissionPrincipalArgs']] = None):
        if permissions is not None:
            pulumi.set(__self__, "permissions", permissions)
        if principal is not None:
            pulumi.set(__self__, "principal", principal)

    @_builtins.property
    @pulumi.getter
    def permissions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "permissions", value)

    @_builtins.property
    @pulumi.getter
    def principal(self) -> Optional[pulumi.Input['CatalogDatabaseCreateTableDefaultPermissionPrincipalArgs']]:
        return pulumi.get(self, "principal")

    @principal.setter
    def principal(self, value: Optional[pulumi.Input['CatalogDatabaseCreateTableDefaultPermissionPrincipalArgs']]):
        pulumi.set(self, "principal", value)


if not MYPY:
    class CatalogDatabaseCreateTableDefaultPermissionPrincipalArgsDict(TypedDict):
        data_lake_principal_identifier: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    CatalogDatabaseCreateTableDefaultPermissionPrincipalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CatalogDatabaseCreateTableDefaultPermissionPrincipalArgs:
    def __init__(__self__, *,
                 data_lake_principal_identifier: Optional[pulumi.Input[_builtins.str]] = None):
        if data_lake_principal_identifier is not None:
            pulumi.set(__self__, "data_lake_principal_identifier", data_lake_principal_identifier)

    @_builtins.property
    @pulumi.getter(name="dataLakePrincipalIdentifier")
    def data_lake_principal_identifier(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "data_lake_principal_identifier")

    @data_lake_principal_identifier.setter
    def data_lake_principal_identifier(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "data_lake_principal_identifier", value)


if not MYPY:
    class CatalogDatabaseFederatedDatabaseArgsDict(TypedDict):
        connection_name: NotRequired[pulumi.Input[_builtins.str]]
        identifier: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    CatalogDatabaseFederatedDatabaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CatalogDatabaseFederatedDatabaseArgs:
    def __init__(__self__, *,
                 connection_name: Optional[pulumi.Input[_builtins.str]] = None,
                 identifier: Optional[pulumi.Input[_builtins.str]] = None):
        if connection_name is not None:
            pulumi.set(__self__, "connection_name", connection_name)
        if identifier is not None:
            pulumi.set(__self__, "identifier", identifier)

    @_builtins.property
    @pulumi.getter(name="connectionName")
    def connection_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "connection_name")

    @connection_name.setter
    def connection_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "connection_name", value)

    @_builtins.property
    @pulumi.getter
    def identifier(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "identifier")

    @identifier.setter
    def identifier(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "identifier", value)


if not MYPY:
    class CatalogDatabaseTargetDatabaseArgsDict(TypedDict):
        catalog_id: pulumi.Input[_builtins.str]
        database_name: pulumi.Input[_builtins.str]
        region: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    CatalogDatabaseTargetDatabaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CatalogDatabaseTargetDatabaseArgs:
    def __init__(__self__, *,
                 catalog_id: pulumi.Input[_builtins.str],
                 database_name: pulumi.Input[_builtins.str],
                 region: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "catalog_id", catalog_id)
        pulumi.set(__self__, "database_name", database_name)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "catalog_id")

    @catalog_id.setter
    def catalog_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "catalog_id", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)


if not MYPY:
    class CatalogTableOpenTableFormatInputArgsDict(TypedDict):
        iceberg_input: pulumi.Input['CatalogTableOpenTableFormatInputIcebergInputArgsDict']
elif False:
    CatalogTableOpenTableFormatInputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CatalogTableOpenTableFormatInputArgs:
    def __init__(__self__, *,
                 iceberg_input: pulumi.Input['CatalogTableOpenTableFormatInputIcebergInputArgs']):
        pulumi.set(__self__, "iceberg_input", iceberg_input)

    @_builtins.property
    @pulumi.getter(name="icebergInput")
    def iceberg_input(self) -> pulumi.Input['CatalogTableOpenTableFormatInputIcebergInputArgs']:
        return pulumi.get(self, "iceberg_input")

    @iceberg_input.setter
    def iceberg_input(self, value: pulumi.Input['CatalogTableOpenTableFormatInputIcebergInputArgs']):
        pulumi.set(self, "iceberg_input", value)


if not MYPY:
    class CatalogTableOpenTableFormatInputIcebergInputArgsDict(TypedDict):
        metadata_operation: pulumi.Input[_builtins.str]
        version: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    CatalogTableOpenTableFormatInputIcebergInputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CatalogTableOpenTableFormatInputIcebergInputArgs:
    def __init__(__self__, *,
                 metadata_operation: pulumi.Input[_builtins.str],
                 version: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "metadata_operation", metadata_operation)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="metadataOperation")
    def metadata_operation(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "metadata_operation")

    @metadata_operation.setter
    def metadata_operation(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "metadata_operation", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class CatalogTableOptimizerConfigurationArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        role_arn: pulumi.Input[_builtins.str]
        orphan_file_deletion_configuration: NotRequired[pulumi.Input['CatalogTableOptimizerConfigurationOrphanFileDeletionConfigurationArgsDict']]
        retention_configuration: NotRequired[pulumi.Input['CatalogTableOptimizerConfigurationRetentionConfigurationArgsDict']]
elif False:
    CatalogTableOptimizerConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CatalogTableOptimizerConfigurationArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 role_arn: pulumi.Input[_builtins.str],
                 orphan_file_deletion_configuration: Optional[pulumi.Input['CatalogTableOptimizerConfigurationOrphanFileDeletionConfigurationArgs']] = None,
                 retention_configuration: Optional[pulumi.Input['CatalogTableOptimizerConfigurationRetentionConfigurationArgs']] = None):
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "role_arn", role_arn)
        if orphan_file_deletion_configuration is not None:
            pulumi.set(__self__, "orphan_file_deletion_configuration", orphan_file_deletion_configuration)
        if retention_configuration is not None:
            pulumi.set(__self__, "retention_configuration", retention_configuration)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="orphanFileDeletionConfiguration")
    def orphan_file_deletion_configuration(self) -> Optional[pulumi.Input['CatalogTableOptimizerConfigurationOrphanFileDeletionConfigurationArgs']]:
        return pulumi.get(self, "orphan_file_deletion_configuration")

    @orphan_file_deletion_configuration.setter
    def orphan_file_deletion_configuration(self, value: Optional[pulumi.Input['CatalogTableOptimizerConfigurationOrphanFileDeletionConfigurationArgs']]):
        pulumi.set(self, "orphan_file_deletion_configuration", value)

    @_builtins.property
    @pulumi.getter(name="retentionConfiguration")
    def retention_configuration(self) -> Optional[pulumi.Input['CatalogTableOptimizerConfigurationRetentionConfigurationArgs']]:
        return pulumi.get(self, "retention_configuration")

    @retention_configuration.setter
    def retention_configuration(self, value: Optional[pulumi.Input['CatalogTableOptimizerConfigurationRetentionConfigurationArgs']]):
        pulumi.set(self, "retention_configuration", value)


if not MYPY:
    class CatalogTableOptimizerConfigurationOrphanFileDeletionConfigurationArgsDict(TypedDict):
        iceberg_configuration: NotRequired[pulumi.Input['CatalogTableOptimizerConfigurationOrphanFileDeletionConfigurationIcebergConfigurationArgsDict']]
elif False:
    CatalogTableOptimizerConfigurationOrphanFileDeletionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CatalogTableOptimizerConfigurationOrphanFileDeletionConfigurationArgs:
    def __init__(__self__, *,
                 iceberg_configuration: Optional[pulumi.Input['CatalogTableOptimizerConfigurationOrphanFileDeletionConfigurationIcebergConfigurationArgs']] = None):
        if iceberg_configuration is not None:
            pulumi.set(__self__, "iceberg_configuration", iceberg_configuration)

    @_builtins.property
    @pulumi.getter(name="icebergConfiguration")
    def iceberg_configuration(self) -> Optional[pulumi.Input['CatalogTableOptimizerConfigurationOrphanFileDeletionConfigurationIcebergConfigurationArgs']]:
        return pulumi.get(self, "iceberg_configuration")

    @iceberg_configuration.setter
    def iceberg_configuration(self, value: Optional[pulumi.Input['CatalogTableOptimizerConfigurationOrphanFileDeletionConfigurationIcebergConfigurationArgs']]):
        pulumi.set(self, "iceberg_configuration", value)


if not MYPY:
    class CatalogTableOptimizerConfigurationOrphanFileDeletionConfigurationIcebergConfigurationArgsDict(TypedDict):
        location: NotRequired[pulumi.Input[_builtins.str]]
        orphan_file_retention_period_in_days: NotRequired[pulumi.Input[_builtins.int]]
        run_rate_in_hours: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    CatalogTableOptimizerConfigurationOrphanFileDeletionConfigurationIcebergConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CatalogTableOptimizerConfigurationOrphanFileDeletionConfigurationIcebergConfigurationArgs:
    def __init__(__self__, *,
                 location: Optional[pulumi.Input[_builtins.str]] = None,
                 orphan_file_retention_period_in_days: Optional[pulumi.Input[_builtins.int]] = None,
                 run_rate_in_hours: Optional[pulumi.Input[_builtins.int]] = None):
        if location is not None:
            pulumi.set(__self__, "location", location)
        if orphan_file_retention_period_in_days is not None:
            pulumi.set(__self__, "orphan_file_retention_period_in_days", orphan_file_retention_period_in_days)
        if run_rate_in_hours is not None:
            pulumi.set(__self__, "run_rate_in_hours", run_rate_in_hours)

    @_builtins.property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "location", value)

    @_builtins.property
    @pulumi.getter(name="orphanFileRetentionPeriodInDays")
    def orphan_file_retention_period_in_days(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "orphan_file_retention_period_in_days")

    @orphan_file_retention_period_in_days.setter
    def orphan_file_retention_period_in_days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "orphan_file_retention_period_in_days", value)

    @_builtins.property
    @pulumi.getter(name="runRateInHours")
    def run_rate_in_hours(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "run_rate_in_hours")

    @run_rate_in_hours.setter
    def run_rate_in_hours(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "run_rate_in_hours", value)


if not MYPY:
    class CatalogTableOptimizerConfigurationRetentionConfigurationArgsDict(TypedDict):
        iceberg_configuration: NotRequired[pulumi.Input['CatalogTableOptimizerConfigurationRetentionConfigurationIcebergConfigurationArgsDict']]
elif False:
    CatalogTableOptimizerConfigurationRetentionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CatalogTableOptimizerConfigurationRetentionConfigurationArgs:
    def __init__(__self__, *,
                 iceberg_configuration: Optional[pulumi.Input['CatalogTableOptimizerConfigurationRetentionConfigurationIcebergConfigurationArgs']] = None):
        if iceberg_configuration is not None:
            pulumi.set(__self__, "iceberg_configuration", iceberg_configuration)

    @_builtins.property
    @pulumi.getter(name="icebergConfiguration")
    def iceberg_configuration(self) -> Optional[pulumi.Input['CatalogTableOptimizerConfigurationRetentionConfigurationIcebergConfigurationArgs']]:
        return pulumi.get(self, "iceberg_configuration")

    @iceberg_configuration.setter
    def iceberg_configuration(self, value: Optional[pulumi.Input['CatalogTableOptimizerConfigurationRetentionConfigurationIcebergConfigurationArgs']]):
        pulumi.set(self, "iceberg_configuration", value)


if not MYPY:
    class CatalogTableOptimizerConfigurationRetentionConfigurationIcebergConfigurationArgsDict(TypedDict):
        clean_expired_files: NotRequired[pulumi.Input[_builtins.bool]]
        number_of_snapshots_to_retain: NotRequired[pulumi.Input[_builtins.int]]
        run_rate_in_hours: NotRequired[pulumi.Input[_builtins.int]]
        snapshot_retention_period_in_days: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    CatalogTableOptimizerConfigurationRetentionConfigurationIcebergConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CatalogTableOptimizerConfigurationRetentionConfigurationIcebergConfigurationArgs:
    def __init__(__self__, *,
                 clean_expired_files: Optional[pulumi.Input[_builtins.bool]] = None,
                 number_of_snapshots_to_retain: Optional[pulumi.Input[_builtins.int]] = None,
                 run_rate_in_hours: Optional[pulumi.Input[_builtins.int]] = None,
                 snapshot_retention_period_in_days: Optional[pulumi.Input[_builtins.int]] = None):
        if clean_expired_files is not None:
            pulumi.set(__self__, "clean_expired_files", clean_expired_files)
        if number_of_snapshots_to_retain is not None:
            pulumi.set(__self__, "number_of_snapshots_to_retain", number_of_snapshots_to_retain)
        if run_rate_in_hours is not None:
            pulumi.set(__self__, "run_rate_in_hours", run_rate_in_hours)
        if snapshot_retention_period_in_days is not None:
            pulumi.set(__self__, "snapshot_retention_period_in_days", snapshot_retention_period_in_days)

    @_builtins.property
    @pulumi.getter(name="cleanExpiredFiles")
    def clean_expired_files(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "clean_expired_files")

    @clean_expired_files.setter
    def clean_expired_files(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "clean_expired_files", value)

    @_builtins.property
    @pulumi.getter(name="numberOfSnapshotsToRetain")
    def number_of_snapshots_to_retain(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "number_of_snapshots_to_retain")

    @number_of_snapshots_to_retain.setter
    def number_of_snapshots_to_retain(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "number_of_snapshots_to_retain", value)

    @_builtins.property
    @pulumi.getter(name="runRateInHours")
    def run_rate_in_hours(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "run_rate_in_hours")

    @run_rate_in_hours.setter
    def run_rate_in_hours(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "run_rate_in_hours", value)

    @_builtins.property
    @pulumi.getter(name="snapshotRetentionPeriodInDays")
    def snapshot_retention_period_in_days(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "snapshot_retention_period_in_days")

    @snapshot_retention_period_in_days.setter
    def snapshot_retention_period_in_days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "snapshot_retention_period_in_days", value)


if not MYPY:
    class CatalogTablePartitionIndexArgsDict(TypedDict):
        index_name: pulumi.Input[_builtins.str]
        keys: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        index_status: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    CatalogTablePartitionIndexArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CatalogTablePartitionIndexArgs:
    def __init__(__self__, *,
                 index_name: pulumi.Input[_builtins.str],
                 keys: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 index_status: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "index_name", index_name)
        pulumi.set(__self__, "keys", keys)
        if index_status is not None:
            pulumi.set(__self__, "index_status", index_status)

    @_builtins.property
    @pulumi.getter(name="indexName")
    def index_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "index_name")

    @index_name.setter
    def index_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "index_name", value)

    @_builtins.property
    @pulumi.getter
    def keys(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "keys")

    @keys.setter
    def keys(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "keys", value)

    @_builtins.property
    @pulumi.getter(name="indexStatus")
    def index_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "index_status")

    @index_status.setter
    def index_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "index_status", value)


if not MYPY:
    class CatalogTablePartitionKeyArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        comment: NotRequired[pulumi.Input[_builtins.str]]
        parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        type: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    CatalogTablePartitionKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CatalogTablePartitionKeyArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 comment: Optional[pulumi.Input[_builtins.str]] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "name", name)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "comment", value)

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "parameters", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class CatalogTableStorageDescriptorArgsDict(TypedDict):
        additional_locations: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        bucket_columns: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        columns: NotRequired[pulumi.Input[Sequence[pulumi.Input['CatalogTableStorageDescriptorColumnArgsDict']]]]
        compressed: NotRequired[pulumi.Input[_builtins.bool]]
        input_format: NotRequired[pulumi.Input[_builtins.str]]
        location: NotRequired[pulumi.Input[_builtins.str]]
        number_of_buckets: NotRequired[pulumi.Input[_builtins.int]]
        output_format: NotRequired[pulumi.Input[_builtins.str]]
        parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        schema_reference: NotRequired[pulumi.Input['CatalogTableStorageDescriptorSchemaReferenceArgsDict']]
        ser_de_info: NotRequired[pulumi.Input['CatalogTableStorageDescriptorSerDeInfoArgsDict']]
        skewed_info: NotRequired[pulumi.Input['CatalogTableStorageDescriptorSkewedInfoArgsDict']]
        sort_columns: NotRequired[pulumi.Input[Sequence[pulumi.Input['CatalogTableStorageDescriptorSortColumnArgsDict']]]]
        stored_as_sub_directories: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    CatalogTableStorageDescriptorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CatalogTableStorageDescriptorArgs:
    def __init__(__self__, *,
                 additional_locations: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 bucket_columns: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 columns: Optional[pulumi.Input[Sequence[pulumi.Input['CatalogTableStorageDescriptorColumnArgs']]]] = None,
                 compressed: Optional[pulumi.Input[_builtins.bool]] = None,
                 input_format: Optional[pulumi.Input[_builtins.str]] = None,
                 location: Optional[pulumi.Input[_builtins.str]] = None,
                 number_of_buckets: Optional[pulumi.Input[_builtins.int]] = None,
                 output_format: Optional[pulumi.Input[_builtins.str]] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 schema_reference: Optional[pulumi.Input['CatalogTableStorageDescriptorSchemaReferenceArgs']] = None,
                 ser_de_info: Optional[pulumi.Input['CatalogTableStorageDescriptorSerDeInfoArgs']] = None,
                 skewed_info: Optional[pulumi.Input['CatalogTableStorageDescriptorSkewedInfoArgs']] = None,
                 sort_columns: Optional[pulumi.Input[Sequence[pulumi.Input['CatalogTableStorageDescriptorSortColumnArgs']]]] = None,
                 stored_as_sub_directories: Optional[pulumi.Input[_builtins.bool]] = None):
        if additional_locations is not None:
            pulumi.set(__self__, "additional_locations", additional_locations)
        if bucket_columns is not None:
            pulumi.set(__self__, "bucket_columns", bucket_columns)
        if columns is not None:
            pulumi.set(__self__, "columns", columns)
        if compressed is not None:
            pulumi.set(__self__, "compressed", compressed)
        if input_format is not None:
            pulumi.set(__self__, "input_format", input_format)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if number_of_buckets is not None:
            pulumi.set(__self__, "number_of_buckets", number_of_buckets)
        if output_format is not None:
            pulumi.set(__self__, "output_format", output_format)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema_reference is not None:
            pulumi.set(__self__, "schema_reference", schema_reference)
        if ser_de_info is not None:
            pulumi.set(__self__, "ser_de_info", ser_de_info)
        if skewed_info is not None:
            pulumi.set(__self__, "skewed_info", skewed_info)
        if sort_columns is not None:
            pulumi.set(__self__, "sort_columns", sort_columns)
        if stored_as_sub_directories is not None:
            pulumi.set(__self__, "stored_as_sub_directories", stored_as_sub_directories)

    @_builtins.property
    @pulumi.getter(name="additionalLocations")
    def additional_locations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "additional_locations")

    @additional_locations.setter
    def additional_locations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "additional_locations", value)

    @_builtins.property
    @pulumi.getter(name="bucketColumns")
    def bucket_columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "bucket_columns")

    @bucket_columns.setter
    def bucket_columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "bucket_columns", value)

    @_builtins.property
    @pulumi.getter
    def columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CatalogTableStorageDescriptorColumnArgs']]]]:
        return pulumi.get(self, "columns")

    @columns.setter
    def columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CatalogTableStorageDescriptorColumnArgs']]]]):
        pulumi.set(self, "columns", value)

    @_builtins.property
    @pulumi.getter
    def compressed(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "compressed")

    @compressed.setter
    def compressed(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "compressed", value)

    @_builtins.property
    @pulumi.getter(name="inputFormat")
    def input_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "input_format")

    @input_format.setter
    def input_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "input_format", value)

    @_builtins.property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "location", value)

    @_builtins.property
    @pulumi.getter(name="numberOfBuckets")
    def number_of_buckets(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "number_of_buckets")

    @number_of_buckets.setter
    def number_of_buckets(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "number_of_buckets", value)

    @_builtins.property
    @pulumi.getter(name="outputFormat")
    def output_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "output_format")

    @output_format.setter
    def output_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "output_format", value)

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "parameters", value)

    @_builtins.property
    @pulumi.getter(name="schemaReference")
    def schema_reference(self) -> Optional[pulumi.Input['CatalogTableStorageDescriptorSchemaReferenceArgs']]:
        return pulumi.get(self, "schema_reference")

    @schema_reference.setter
    def schema_reference(self, value: Optional[pulumi.Input['CatalogTableStorageDescriptorSchemaReferenceArgs']]):
        pulumi.set(self, "schema_reference", value)

    @_builtins.property
    @pulumi.getter(name="serDeInfo")
    def ser_de_info(self) -> Optional[pulumi.Input['CatalogTableStorageDescriptorSerDeInfoArgs']]:
        return pulumi.get(self, "ser_de_info")

    @ser_de_info.setter
    def ser_de_info(self, value: Optional[pulumi.Input['CatalogTableStorageDescriptorSerDeInfoArgs']]):
        pulumi.set(self, "ser_de_info", value)

    @_builtins.property
    @pulumi.getter(name="skewedInfo")
    def skewed_info(self) -> Optional[pulumi.Input['CatalogTableStorageDescriptorSkewedInfoArgs']]:
        return pulumi.get(self, "skewed_info")

    @skewed_info.setter
    def skewed_info(self, value: Optional[pulumi.Input['CatalogTableStorageDescriptorSkewedInfoArgs']]):
        pulumi.set(self, "skewed_info", value)

    @_builtins.property
    @pulumi.getter(name="sortColumns")
    def sort_columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CatalogTableStorageDescriptorSortColumnArgs']]]]:
        return pulumi.get(self, "sort_columns")

    @sort_columns.setter
    def sort_columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CatalogTableStorageDescriptorSortColumnArgs']]]]):
        pulumi.set(self, "sort_columns", value)

    @_builtins.property
    @pulumi.getter(name="storedAsSubDirectories")
    def stored_as_sub_directories(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "stored_as_sub_directories")

    @stored_as_sub_directories.setter
    def stored_as_sub_directories(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "stored_as_sub_directories", value)


if not MYPY:
    class CatalogTableStorageDescriptorColumnArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        comment: NotRequired[pulumi.Input[_builtins.str]]
        parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        type: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    CatalogTableStorageDescriptorColumnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CatalogTableStorageDescriptorColumnArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 comment: Optional[pulumi.Input[_builtins.str]] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "name", name)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "comment", value)

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "parameters", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class CatalogTableStorageDescriptorSchemaReferenceArgsDict(TypedDict):
        schema_version_number: pulumi.Input[_builtins.int]
        schema_id: NotRequired[pulumi.Input['CatalogTableStorageDescriptorSchemaReferenceSchemaIdArgsDict']]
        schema_version_id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    CatalogTableStorageDescriptorSchemaReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CatalogTableStorageDescriptorSchemaReferenceArgs:
    def __init__(__self__, *,
                 schema_version_number: pulumi.Input[_builtins.int],
                 schema_id: Optional[pulumi.Input['CatalogTableStorageDescriptorSchemaReferenceSchemaIdArgs']] = None,
                 schema_version_id: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "schema_version_number", schema_version_number)
        if schema_id is not None:
            pulumi.set(__self__, "schema_id", schema_id)
        if schema_version_id is not None:
            pulumi.set(__self__, "schema_version_id", schema_version_id)

    @_builtins.property
    @pulumi.getter(name="schemaVersionNumber")
    def schema_version_number(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "schema_version_number")

    @schema_version_number.setter
    def schema_version_number(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "schema_version_number", value)

    @_builtins.property
    @pulumi.getter(name="schemaId")
    def schema_id(self) -> Optional[pulumi.Input['CatalogTableStorageDescriptorSchemaReferenceSchemaIdArgs']]:
        return pulumi.get(self, "schema_id")

    @schema_id.setter
    def schema_id(self, value: Optional[pulumi.Input['CatalogTableStorageDescriptorSchemaReferenceSchemaIdArgs']]):
        pulumi.set(self, "schema_id", value)

    @_builtins.property
    @pulumi.getter(name="schemaVersionId")
    def schema_version_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "schema_version_id")

    @schema_version_id.setter
    def schema_version_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_version_id", value)


if not MYPY:
    class CatalogTableStorageDescriptorSchemaReferenceSchemaIdArgsDict(TypedDict):
        registry_name: NotRequired[pulumi.Input[_builtins.str]]
        schema_arn: NotRequired[pulumi.Input[_builtins.str]]
        schema_name: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    CatalogTableStorageDescriptorSchemaReferenceSchemaIdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CatalogTableStorageDescriptorSchemaReferenceSchemaIdArgs:
    def __init__(__self__, *,
                 registry_name: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_name: Optional[pulumi.Input[_builtins.str]] = None):
        if registry_name is not None:
            pulumi.set(__self__, "registry_name", registry_name)
        if schema_arn is not None:
            pulumi.set(__self__, "schema_arn", schema_arn)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter(name="registryName")
    def registry_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "registry_name")

    @registry_name.setter
    def registry_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "registry_name", value)

    @_builtins.property
    @pulumi.getter(name="schemaArn")
    def schema_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "schema_arn")

    @schema_arn.setter
    def schema_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_arn", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_name", value)


if not MYPY:
    class CatalogTableStorageDescriptorSerDeInfoArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        serialization_library: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    CatalogTableStorageDescriptorSerDeInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CatalogTableStorageDescriptorSerDeInfoArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 serialization_library: Optional[pulumi.Input[_builtins.str]] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if serialization_library is not None:
            pulumi.set(__self__, "serialization_library", serialization_library)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "parameters", value)

    @_builtins.property
    @pulumi.getter(name="serializationLibrary")
    def serialization_library(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "serialization_library")

    @serialization_library.setter
    def serialization_library(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "serialization_library", value)


if not MYPY:
    class CatalogTableStorageDescriptorSkewedInfoArgsDict(TypedDict):
        skewed_column_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        skewed_column_value_location_maps: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        skewed_column_values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    CatalogTableStorageDescriptorSkewedInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CatalogTableStorageDescriptorSkewedInfoArgs:
    def __init__(__self__, *,
                 skewed_column_names: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 skewed_column_value_location_maps: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 skewed_column_values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if skewed_column_names is not None:
            pulumi.set(__self__, "skewed_column_names", skewed_column_names)
        if skewed_column_value_location_maps is not None:
            pulumi.set(__self__, "skewed_column_value_location_maps", skewed_column_value_location_maps)
        if skewed_column_values is not None:
            pulumi.set(__self__, "skewed_column_values", skewed_column_values)

    @_builtins.property
    @pulumi.getter(name="skewedColumnNames")
    def skewed_column_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "skewed_column_names")

    @skewed_column_names.setter
    def skewed_column_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "skewed_column_names", value)

    @_builtins.property
    @pulumi.getter(name="skewedColumnValueLocationMaps")
    def skewed_column_value_location_maps(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "skewed_column_value_location_maps")

    @skewed_column_value_location_maps.setter
    def skewed_column_value_location_maps(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "skewed_column_value_location_maps", value)

    @_builtins.property
    @pulumi.getter(name="skewedColumnValues")
    def skewed_column_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "skewed_column_values")

    @skewed_column_values.setter
    def skewed_column_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "skewed_column_values", value)


if not MYPY:
    class CatalogTableStorageDescriptorSortColumnArgsDict(TypedDict):
        column: pulumi.Input[_builtins.str]
        sort_order: pulumi.Input[_builtins.int]
elif False:
    CatalogTableStorageDescriptorSortColumnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CatalogTableStorageDescriptorSortColumnArgs:
    def __init__(__self__, *,
                 column: pulumi.Input[_builtins.str],
                 sort_order: pulumi.Input[_builtins.int]):
        pulumi.set(__self__, "column", column)
        pulumi.set(__self__, "sort_order", sort_order)

    @_builtins.property
    @pulumi.getter
    def column(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "column")

    @column.setter
    def column(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "column", value)

    @_builtins.property
    @pulumi.getter(name="sortOrder")
    def sort_order(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "sort_order")

    @sort_order.setter
    def sort_order(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "sort_order", value)


if not MYPY:
    class CatalogTableTargetTableArgsDict(TypedDict):
        catalog_id: pulumi.Input[_builtins.str]
        database_name: pulumi.Input[_builtins.str]
        name: pulumi.Input[_builtins.str]
        region: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    CatalogTableTargetTableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CatalogTableTargetTableArgs:
    def __init__(__self__, *,
                 catalog_id: pulumi.Input[_builtins.str],
                 database_name: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 region: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "catalog_id", catalog_id)
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "name", name)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "catalog_id")

    @catalog_id.setter
    def catalog_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "catalog_id", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)


if not MYPY:
    class ClassifierCsvClassifierArgsDict(TypedDict):
        allow_single_column: NotRequired[pulumi.Input[_builtins.bool]]
        contains_header: NotRequired[pulumi.Input[_builtins.str]]
        custom_datatype_configured: NotRequired[pulumi.Input[_builtins.bool]]
        custom_datatypes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        delimiter: NotRequired[pulumi.Input[_builtins.str]]
        disable_value_trimming: NotRequired[pulumi.Input[_builtins.bool]]
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        quote_symbol: NotRequired[pulumi.Input[_builtins.str]]
        serde: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ClassifierCsvClassifierArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClassifierCsvClassifierArgs:
    def __init__(__self__, *,
                 allow_single_column: Optional[pulumi.Input[_builtins.bool]] = None,
                 contains_header: Optional[pulumi.Input[_builtins.str]] = None,
                 custom_datatype_configured: Optional[pulumi.Input[_builtins.bool]] = None,
                 custom_datatypes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 delimiter: Optional[pulumi.Input[_builtins.str]] = None,
                 disable_value_trimming: Optional[pulumi.Input[_builtins.bool]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 quote_symbol: Optional[pulumi.Input[_builtins.str]] = None,
                 serde: Optional[pulumi.Input[_builtins.str]] = None):
        if allow_single_column is not None:
            pulumi.set(__self__, "allow_single_column", allow_single_column)
        if contains_header is not None:
            pulumi.set(__self__, "contains_header", contains_header)
        if custom_datatype_configured is not None:
            pulumi.set(__self__, "custom_datatype_configured", custom_datatype_configured)
        if custom_datatypes is not None:
            pulumi.set(__self__, "custom_datatypes", custom_datatypes)
        if delimiter is not None:
            pulumi.set(__self__, "delimiter", delimiter)
        if disable_value_trimming is not None:
            pulumi.set(__self__, "disable_value_trimming", disable_value_trimming)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if quote_symbol is not None:
            pulumi.set(__self__, "quote_symbol", quote_symbol)
        if serde is not None:
            pulumi.set(__self__, "serde", serde)

    @_builtins.property
    @pulumi.getter(name="allowSingleColumn")
    def allow_single_column(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "allow_single_column")

    @allow_single_column.setter
    def allow_single_column(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_single_column", value)

    @_builtins.property
    @pulumi.getter(name="containsHeader")
    def contains_header(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "contains_header")

    @contains_header.setter
    def contains_header(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "contains_header", value)

    @_builtins.property
    @pulumi.getter(name="customDatatypeConfigured")
    def custom_datatype_configured(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "custom_datatype_configured")

    @custom_datatype_configured.setter
    def custom_datatype_configured(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "custom_datatype_configured", value)

    @_builtins.property
    @pulumi.getter(name="customDatatypes")
    def custom_datatypes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "custom_datatypes")

    @custom_datatypes.setter
    def custom_datatypes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "custom_datatypes", value)

    @_builtins.property
    @pulumi.getter
    def delimiter(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "delimiter")

    @delimiter.setter
    def delimiter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delimiter", value)

    @_builtins.property
    @pulumi.getter(name="disableValueTrimming")
    def disable_value_trimming(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "disable_value_trimming")

    @disable_value_trimming.setter
    def disable_value_trimming(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_value_trimming", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter(name="quoteSymbol")
    def quote_symbol(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "quote_symbol")

    @quote_symbol.setter
    def quote_symbol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "quote_symbol", value)

    @_builtins.property
    @pulumi.getter
    def serde(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "serde")

    @serde.setter
    def serde(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "serde", value)


if not MYPY:
    class ClassifierGrokClassifierArgsDict(TypedDict):
        classification: pulumi.Input[_builtins.str]
        grok_pattern: pulumi.Input[_builtins.str]
        custom_patterns: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ClassifierGrokClassifierArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClassifierGrokClassifierArgs:
    def __init__(__self__, *,
                 classification: pulumi.Input[_builtins.str],
                 grok_pattern: pulumi.Input[_builtins.str],
                 custom_patterns: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "classification", classification)
        pulumi.set(__self__, "grok_pattern", grok_pattern)
        if custom_patterns is not None:
            pulumi.set(__self__, "custom_patterns", custom_patterns)

    @_builtins.property
    @pulumi.getter
    def classification(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "classification")

    @classification.setter
    def classification(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "classification", value)

    @_builtins.property
    @pulumi.getter(name="grokPattern")
    def grok_pattern(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "grok_pattern")

    @grok_pattern.setter
    def grok_pattern(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "grok_pattern", value)

    @_builtins.property
    @pulumi.getter(name="customPatterns")
    def custom_patterns(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "custom_patterns")

    @custom_patterns.setter
    def custom_patterns(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "custom_patterns", value)


if not MYPY:
    class ClassifierJsonClassifierArgsDict(TypedDict):
        json_path: pulumi.Input[_builtins.str]
elif False:
    ClassifierJsonClassifierArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClassifierJsonClassifierArgs:
    def __init__(__self__, *,
                 json_path: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "json_path", json_path)

    @_builtins.property
    @pulumi.getter(name="jsonPath")
    def json_path(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "json_path")

    @json_path.setter
    def json_path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "json_path", value)


if not MYPY:
    class ClassifierXmlClassifierArgsDict(TypedDict):
        classification: pulumi.Input[_builtins.str]
        row_tag: pulumi.Input[_builtins.str]
elif False:
    ClassifierXmlClassifierArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClassifierXmlClassifierArgs:
    def __init__(__self__, *,
                 classification: pulumi.Input[_builtins.str],
                 row_tag: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "classification", classification)
        pulumi.set(__self__, "row_tag", row_tag)

    @_builtins.property
    @pulumi.getter
    def classification(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "classification")

    @classification.setter
    def classification(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "classification", value)

    @_builtins.property
    @pulumi.getter(name="rowTag")
    def row_tag(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "row_tag")

    @row_tag.setter
    def row_tag(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "row_tag", value)


if not MYPY:
    class ConnectionPhysicalConnectionRequirementsArgsDict(TypedDict):
        availability_zone: NotRequired[pulumi.Input[_builtins.str]]
        security_group_id_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        subnet_id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ConnectionPhysicalConnectionRequirementsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionPhysicalConnectionRequirementsArgs:
    def __init__(__self__, *,
                 availability_zone: Optional[pulumi.Input[_builtins.str]] = None,
                 security_group_id_lists: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 subnet_id: Optional[pulumi.Input[_builtins.str]] = None):
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if security_group_id_lists is not None:
            pulumi.set(__self__, "security_group_id_lists", security_group_id_lists)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "availability_zone")

    @availability_zone.setter
    def availability_zone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "availability_zone", value)

    @_builtins.property
    @pulumi.getter(name="securityGroupIdLists")
    def security_group_id_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "security_group_id_lists")

    @security_group_id_lists.setter
    def security_group_id_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "security_group_id_lists", value)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class CrawlerCatalogTargetArgsDict(TypedDict):
        database_name: pulumi.Input[_builtins.str]
        tables: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        connection_name: NotRequired[pulumi.Input[_builtins.str]]
        dlq_event_queue_arn: NotRequired[pulumi.Input[_builtins.str]]
        event_queue_arn: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    CrawlerCatalogTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CrawlerCatalogTargetArgs:
    def __init__(__self__, *,
                 database_name: pulumi.Input[_builtins.str],
                 tables: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 connection_name: Optional[pulumi.Input[_builtins.str]] = None,
                 dlq_event_queue_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 event_queue_arn: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "tables", tables)
        if connection_name is not None:
            pulumi.set(__self__, "connection_name", connection_name)
        if dlq_event_queue_arn is not None:
            pulumi.set(__self__, "dlq_event_queue_arn", dlq_event_queue_arn)
        if event_queue_arn is not None:
            pulumi.set(__self__, "event_queue_arn", event_queue_arn)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter
    def tables(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "tables")

    @tables.setter
    def tables(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "tables", value)

    @_builtins.property
    @pulumi.getter(name="connectionName")
    def connection_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "connection_name")

    @connection_name.setter
    def connection_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "connection_name", value)

    @_builtins.property
    @pulumi.getter(name="dlqEventQueueArn")
    def dlq_event_queue_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "dlq_event_queue_arn")

    @dlq_event_queue_arn.setter
    def dlq_event_queue_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dlq_event_queue_arn", value)

    @_builtins.property
    @pulumi.getter(name="eventQueueArn")
    def event_queue_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "event_queue_arn")

    @event_queue_arn.setter
    def event_queue_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "event_queue_arn", value)


if not MYPY:
    class CrawlerDeltaTargetArgsDict(TypedDict):
        delta_tables: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        write_manifest: pulumi.Input[_builtins.bool]
        connection_name: NotRequired[pulumi.Input[_builtins.str]]
        create_native_delta_table: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    CrawlerDeltaTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CrawlerDeltaTargetArgs:
    def __init__(__self__, *,
                 delta_tables: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 write_manifest: pulumi.Input[_builtins.bool],
                 connection_name: Optional[pulumi.Input[_builtins.str]] = None,
                 create_native_delta_table: Optional[pulumi.Input[_builtins.bool]] = None):
        pulumi.set(__self__, "delta_tables", delta_tables)
        pulumi.set(__self__, "write_manifest", write_manifest)
        if connection_name is not None:
            pulumi.set(__self__, "connection_name", connection_name)
        if create_native_delta_table is not None:
            pulumi.set(__self__, "create_native_delta_table", create_native_delta_table)

    @_builtins.property
    @pulumi.getter(name="deltaTables")
    def delta_tables(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "delta_tables")

    @delta_tables.setter
    def delta_tables(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "delta_tables", value)

    @_builtins.property
    @pulumi.getter(name="writeManifest")
    def write_manifest(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "write_manifest")

    @write_manifest.setter
    def write_manifest(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "write_manifest", value)

    @_builtins.property
    @pulumi.getter(name="connectionName")
    def connection_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "connection_name")

    @connection_name.setter
    def connection_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "connection_name", value)

    @_builtins.property
    @pulumi.getter(name="createNativeDeltaTable")
    def create_native_delta_table(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "create_native_delta_table")

    @create_native_delta_table.setter
    def create_native_delta_table(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "create_native_delta_table", value)


if not MYPY:
    class CrawlerDynamodbTargetArgsDict(TypedDict):
        path: pulumi.Input[_builtins.str]
        scan_all: NotRequired[pulumi.Input[_builtins.bool]]
        scan_rate: NotRequired[pulumi.Input[_builtins.float]]
elif False:
    CrawlerDynamodbTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CrawlerDynamodbTargetArgs:
    def __init__(__self__, *,
                 path: pulumi.Input[_builtins.str],
                 scan_all: Optional[pulumi.Input[_builtins.bool]] = None,
                 scan_rate: Optional[pulumi.Input[_builtins.float]] = None):
        pulumi.set(__self__, "path", path)
        if scan_all is not None:
            pulumi.set(__self__, "scan_all", scan_all)
        if scan_rate is not None:
            pulumi.set(__self__, "scan_rate", scan_rate)

    @_builtins.property
    @pulumi.getter
    def path(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter(name="scanAll")
    def scan_all(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "scan_all")

    @scan_all.setter
    def scan_all(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "scan_all", value)

    @_builtins.property
    @pulumi.getter(name="scanRate")
    def scan_rate(self) -> Optional[pulumi.Input[_builtins.float]]:
        return pulumi.get(self, "scan_rate")

    @scan_rate.setter
    def scan_rate(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "scan_rate", value)


if not MYPY:
    class CrawlerHudiTargetArgsDict(TypedDict):
        maximum_traversal_depth: pulumi.Input[_builtins.int]
        paths: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        connection_name: NotRequired[pulumi.Input[_builtins.str]]
        exclusions: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    CrawlerHudiTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CrawlerHudiTargetArgs:
    def __init__(__self__, *,
                 maximum_traversal_depth: pulumi.Input[_builtins.int],
                 paths: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 connection_name: Optional[pulumi.Input[_builtins.str]] = None,
                 exclusions: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "maximum_traversal_depth", maximum_traversal_depth)
        pulumi.set(__self__, "paths", paths)
        if connection_name is not None:
            pulumi.set(__self__, "connection_name", connection_name)
        if exclusions is not None:
            pulumi.set(__self__, "exclusions", exclusions)

    @_builtins.property
    @pulumi.getter(name="maximumTraversalDepth")
    def maximum_traversal_depth(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "maximum_traversal_depth")

    @maximum_traversal_depth.setter
    def maximum_traversal_depth(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "maximum_traversal_depth", value)

    @_builtins.property
    @pulumi.getter
    def paths(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "paths")

    @paths.setter
    def paths(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "paths", value)

    @_builtins.property
    @pulumi.getter(name="connectionName")
    def connection_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "connection_name")

    @connection_name.setter
    def connection_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "connection_name", value)

    @_builtins.property
    @pulumi.getter
    def exclusions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "exclusions")

    @exclusions.setter
    def exclusions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exclusions", value)


if not MYPY:
    class CrawlerIcebergTargetArgsDict(TypedDict):
        maximum_traversal_depth: pulumi.Input[_builtins.int]
        paths: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        connection_name: NotRequired[pulumi.Input[_builtins.str]]
        exclusions: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    CrawlerIcebergTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CrawlerIcebergTargetArgs:
    def __init__(__self__, *,
                 maximum_traversal_depth: pulumi.Input[_builtins.int],
                 paths: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 connection_name: Optional[pulumi.Input[_builtins.str]] = None,
                 exclusions: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "maximum_traversal_depth", maximum_traversal_depth)
        pulumi.set(__self__, "paths", paths)
        if connection_name is not None:
            pulumi.set(__self__, "connection_name", connection_name)
        if exclusions is not None:
            pulumi.set(__self__, "exclusions", exclusions)

    @_builtins.property
    @pulumi.getter(name="maximumTraversalDepth")
    def maximum_traversal_depth(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "maximum_traversal_depth")

    @maximum_traversal_depth.setter
    def maximum_traversal_depth(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "maximum_traversal_depth", value)

    @_builtins.property
    @pulumi.getter
    def paths(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "paths")

    @paths.setter
    def paths(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "paths", value)

    @_builtins.property
    @pulumi.getter(name="connectionName")
    def connection_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "connection_name")

    @connection_name.setter
    def connection_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "connection_name", value)

    @_builtins.property
    @pulumi.getter
    def exclusions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "exclusions")

    @exclusions.setter
    def exclusions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exclusions", value)


if not MYPY:
    class CrawlerJdbcTargetArgsDict(TypedDict):
        connection_name: pulumi.Input[_builtins.str]
        path: pulumi.Input[_builtins.str]
        enable_additional_metadatas: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        exclusions: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    CrawlerJdbcTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CrawlerJdbcTargetArgs:
    def __init__(__self__, *,
                 connection_name: pulumi.Input[_builtins.str],
                 path: pulumi.Input[_builtins.str],
                 enable_additional_metadatas: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 exclusions: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "connection_name", connection_name)
        pulumi.set(__self__, "path", path)
        if enable_additional_metadatas is not None:
            pulumi.set(__self__, "enable_additional_metadatas", enable_additional_metadatas)
        if exclusions is not None:
            pulumi.set(__self__, "exclusions", exclusions)

    @_builtins.property
    @pulumi.getter(name="connectionName")
    def connection_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "connection_name")

    @connection_name.setter
    def connection_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "connection_name", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter(name="enableAdditionalMetadatas")
    def enable_additional_metadatas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "enable_additional_metadatas")

    @enable_additional_metadatas.setter
    def enable_additional_metadatas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "enable_additional_metadatas", value)

    @_builtins.property
    @pulumi.getter
    def exclusions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "exclusions")

    @exclusions.setter
    def exclusions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exclusions", value)


if not MYPY:
    class CrawlerLakeFormationConfigurationArgsDict(TypedDict):
        account_id: NotRequired[pulumi.Input[_builtins.str]]
        use_lake_formation_credentials: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    CrawlerLakeFormationConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CrawlerLakeFormationConfigurationArgs:
    def __init__(__self__, *,
                 account_id: Optional[pulumi.Input[_builtins.str]] = None,
                 use_lake_formation_credentials: Optional[pulumi.Input[_builtins.bool]] = None):
        if account_id is not None:
            pulumi.set(__self__, "account_id", account_id)
        if use_lake_formation_credentials is not None:
            pulumi.set(__self__, "use_lake_formation_credentials", use_lake_formation_credentials)

    @_builtins.property
    @pulumi.getter(name="accountId")
    def account_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "account_id")

    @account_id.setter
    def account_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "account_id", value)

    @_builtins.property
    @pulumi.getter(name="useLakeFormationCredentials")
    def use_lake_formation_credentials(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "use_lake_formation_credentials")

    @use_lake_formation_credentials.setter
    def use_lake_formation_credentials(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_lake_formation_credentials", value)


if not MYPY:
    class CrawlerLineageConfigurationArgsDict(TypedDict):
        crawler_lineage_settings: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    CrawlerLineageConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CrawlerLineageConfigurationArgs:
    def __init__(__self__, *,
                 crawler_lineage_settings: Optional[pulumi.Input[_builtins.str]] = None):
        if crawler_lineage_settings is not None:
            pulumi.set(__self__, "crawler_lineage_settings", crawler_lineage_settings)

    @_builtins.property
    @pulumi.getter(name="crawlerLineageSettings")
    def crawler_lineage_settings(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "crawler_lineage_settings")

    @crawler_lineage_settings.setter
    def crawler_lineage_settings(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "crawler_lineage_settings", value)


if not MYPY:
    class CrawlerMongodbTargetArgsDict(TypedDict):
        connection_name: pulumi.Input[_builtins.str]
        path: pulumi.Input[_builtins.str]
        scan_all: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    CrawlerMongodbTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CrawlerMongodbTargetArgs:
    def __init__(__self__, *,
                 connection_name: pulumi.Input[_builtins.str],
                 path: pulumi.Input[_builtins.str],
                 scan_all: Optional[pulumi.Input[_builtins.bool]] = None):
        pulumi.set(__self__, "connection_name", connection_name)
        pulumi.set(__self__, "path", path)
        if scan_all is not None:
            pulumi.set(__self__, "scan_all", scan_all)

    @_builtins.property
    @pulumi.getter(name="connectionName")
    def connection_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "connection_name")

    @connection_name.setter
    def connection_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "connection_name", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter(name="scanAll")
    def scan_all(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "scan_all")

    @scan_all.setter
    def scan_all(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "scan_all", value)


if not MYPY:
    class CrawlerRecrawlPolicyArgsDict(TypedDict):
        recrawl_behavior: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    CrawlerRecrawlPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CrawlerRecrawlPolicyArgs:
    def __init__(__self__, *,
                 recrawl_behavior: Optional[pulumi.Input[_builtins.str]] = None):
        if recrawl_behavior is not None:
            pulumi.set(__self__, "recrawl_behavior", recrawl_behavior)

    @_builtins.property
    @pulumi.getter(name="recrawlBehavior")
    def recrawl_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "recrawl_behavior")

    @recrawl_behavior.setter
    def recrawl_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "recrawl_behavior", value)


if not MYPY:
    class CrawlerS3TargetArgsDict(TypedDict):
        path: pulumi.Input[_builtins.str]
        connection_name: NotRequired[pulumi.Input[_builtins.str]]
        dlq_event_queue_arn: NotRequired[pulumi.Input[_builtins.str]]
        event_queue_arn: NotRequired[pulumi.Input[_builtins.str]]
        exclusions: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        sample_size: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    CrawlerS3TargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CrawlerS3TargetArgs:
    def __init__(__self__, *,
                 path: pulumi.Input[_builtins.str],
                 connection_name: Optional[pulumi.Input[_builtins.str]] = None,
                 dlq_event_queue_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 event_queue_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 exclusions: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 sample_size: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "path", path)
        if connection_name is not None:
            pulumi.set(__self__, "connection_name", connection_name)
        if dlq_event_queue_arn is not None:
            pulumi.set(__self__, "dlq_event_queue_arn", dlq_event_queue_arn)
        if event_queue_arn is not None:
            pulumi.set(__self__, "event_queue_arn", event_queue_arn)
        if exclusions is not None:
            pulumi.set(__self__, "exclusions", exclusions)
        if sample_size is not None:
            pulumi.set(__self__, "sample_size", sample_size)

    @_builtins.property
    @pulumi.getter
    def path(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter(name="connectionName")
    def connection_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "connection_name")

    @connection_name.setter
    def connection_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "connection_name", value)

    @_builtins.property
    @pulumi.getter(name="dlqEventQueueArn")
    def dlq_event_queue_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "dlq_event_queue_arn")

    @dlq_event_queue_arn.setter
    def dlq_event_queue_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dlq_event_queue_arn", value)

    @_builtins.property
    @pulumi.getter(name="eventQueueArn")
    def event_queue_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "event_queue_arn")

    @event_queue_arn.setter
    def event_queue_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "event_queue_arn", value)

    @_builtins.property
    @pulumi.getter
    def exclusions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "exclusions")

    @exclusions.setter
    def exclusions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exclusions", value)

    @_builtins.property
    @pulumi.getter(name="sampleSize")
    def sample_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "sample_size")

    @sample_size.setter
    def sample_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "sample_size", value)


if not MYPY:
    class CrawlerSchemaChangePolicyArgsDict(TypedDict):
        delete_behavior: NotRequired[pulumi.Input[_builtins.str]]
        update_behavior: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    CrawlerSchemaChangePolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CrawlerSchemaChangePolicyArgs:
    def __init__(__self__, *,
                 delete_behavior: Optional[pulumi.Input[_builtins.str]] = None,
                 update_behavior: Optional[pulumi.Input[_builtins.str]] = None):
        if delete_behavior is not None:
            pulumi.set(__self__, "delete_behavior", delete_behavior)
        if update_behavior is not None:
            pulumi.set(__self__, "update_behavior", update_behavior)

    @_builtins.property
    @pulumi.getter(name="deleteBehavior")
    def delete_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "delete_behavior")

    @delete_behavior.setter
    def delete_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete_behavior", value)

    @_builtins.property
    @pulumi.getter(name="updateBehavior")
    def update_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "update_behavior")

    @update_behavior.setter
    def update_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update_behavior", value)


if not MYPY:
    class DataCatalogEncryptionSettingsDataCatalogEncryptionSettingsArgsDict(TypedDict):
        connection_password_encryption: pulumi.Input['DataCatalogEncryptionSettingsDataCatalogEncryptionSettingsConnectionPasswordEncryptionArgsDict']
        encryption_at_rest: pulumi.Input['DataCatalogEncryptionSettingsDataCatalogEncryptionSettingsEncryptionAtRestArgsDict']
elif False:
    DataCatalogEncryptionSettingsDataCatalogEncryptionSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataCatalogEncryptionSettingsDataCatalogEncryptionSettingsArgs:
    def __init__(__self__, *,
                 connection_password_encryption: pulumi.Input['DataCatalogEncryptionSettingsDataCatalogEncryptionSettingsConnectionPasswordEncryptionArgs'],
                 encryption_at_rest: pulumi.Input['DataCatalogEncryptionSettingsDataCatalogEncryptionSettingsEncryptionAtRestArgs']):
        pulumi.set(__self__, "connection_password_encryption", connection_password_encryption)
        pulumi.set(__self__, "encryption_at_rest", encryption_at_rest)

    @_builtins.property
    @pulumi.getter(name="connectionPasswordEncryption")
    def connection_password_encryption(self) -> pulumi.Input['DataCatalogEncryptionSettingsDataCatalogEncryptionSettingsConnectionPasswordEncryptionArgs']:
        return pulumi.get(self, "connection_password_encryption")

    @connection_password_encryption.setter
    def connection_password_encryption(self, value: pulumi.Input['DataCatalogEncryptionSettingsDataCatalogEncryptionSettingsConnectionPasswordEncryptionArgs']):
        pulumi.set(self, "connection_password_encryption", value)

    @_builtins.property
    @pulumi.getter(name="encryptionAtRest")
    def encryption_at_rest(self) -> pulumi.Input['DataCatalogEncryptionSettingsDataCatalogEncryptionSettingsEncryptionAtRestArgs']:
        return pulumi.get(self, "encryption_at_rest")

    @encryption_at_rest.setter
    def encryption_at_rest(self, value: pulumi.Input['DataCatalogEncryptionSettingsDataCatalogEncryptionSettingsEncryptionAtRestArgs']):
        pulumi.set(self, "encryption_at_rest", value)


if not MYPY:
    class DataCatalogEncryptionSettingsDataCatalogEncryptionSettingsConnectionPasswordEncryptionArgsDict(TypedDict):
        return_connection_password_encrypted: pulumi.Input[_builtins.bool]
        aws_kms_key_id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DataCatalogEncryptionSettingsDataCatalogEncryptionSettingsConnectionPasswordEncryptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataCatalogEncryptionSettingsDataCatalogEncryptionSettingsConnectionPasswordEncryptionArgs:
    def __init__(__self__, *,
                 return_connection_password_encrypted: pulumi.Input[_builtins.bool],
                 aws_kms_key_id: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "return_connection_password_encrypted", return_connection_password_encrypted)
        if aws_kms_key_id is not None:
            pulumi.set(__self__, "aws_kms_key_id", aws_kms_key_id)

    @_builtins.property
    @pulumi.getter(name="returnConnectionPasswordEncrypted")
    def return_connection_password_encrypted(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "return_connection_password_encrypted")

    @return_connection_password_encrypted.setter
    def return_connection_password_encrypted(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "return_connection_password_encrypted", value)

    @_builtins.property
    @pulumi.getter(name="awsKmsKeyId")
    def aws_kms_key_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "aws_kms_key_id")

    @aws_kms_key_id.setter
    def aws_kms_key_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "aws_kms_key_id", value)


if not MYPY:
    class DataCatalogEncryptionSettingsDataCatalogEncryptionSettingsEncryptionAtRestArgsDict(TypedDict):
        catalog_encryption_mode: pulumi.Input[_builtins.str]
        catalog_encryption_service_role: NotRequired[pulumi.Input[_builtins.str]]
        sse_aws_kms_key_id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DataCatalogEncryptionSettingsDataCatalogEncryptionSettingsEncryptionAtRestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataCatalogEncryptionSettingsDataCatalogEncryptionSettingsEncryptionAtRestArgs:
    def __init__(__self__, *,
                 catalog_encryption_mode: pulumi.Input[_builtins.str],
                 catalog_encryption_service_role: Optional[pulumi.Input[_builtins.str]] = None,
                 sse_aws_kms_key_id: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "catalog_encryption_mode", catalog_encryption_mode)
        if catalog_encryption_service_role is not None:
            pulumi.set(__self__, "catalog_encryption_service_role", catalog_encryption_service_role)
        if sse_aws_kms_key_id is not None:
            pulumi.set(__self__, "sse_aws_kms_key_id", sse_aws_kms_key_id)

    @_builtins.property
    @pulumi.getter(name="catalogEncryptionMode")
    def catalog_encryption_mode(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "catalog_encryption_mode")

    @catalog_encryption_mode.setter
    def catalog_encryption_mode(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "catalog_encryption_mode", value)

    @_builtins.property
    @pulumi.getter(name="catalogEncryptionServiceRole")
    def catalog_encryption_service_role(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "catalog_encryption_service_role")

    @catalog_encryption_service_role.setter
    def catalog_encryption_service_role(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "catalog_encryption_service_role", value)

    @_builtins.property
    @pulumi.getter(name="sseAwsKmsKeyId")
    def sse_aws_kms_key_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "sse_aws_kms_key_id")

    @sse_aws_kms_key_id.setter
    def sse_aws_kms_key_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sse_aws_kms_key_id", value)


if not MYPY:
    class DataQualityRulesetTargetTableArgsDict(TypedDict):
        database_name: pulumi.Input[_builtins.str]
        table_name: pulumi.Input[_builtins.str]
        catalog_id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DataQualityRulesetTargetTableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataQualityRulesetTargetTableArgs:
    def __init__(__self__, *,
                 database_name: pulumi.Input[_builtins.str],
                 table_name: pulumi.Input[_builtins.str],
                 catalog_id: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "table_name", table_name)
        if catalog_id is not None:
            pulumi.set(__self__, "catalog_id", catalog_id)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="tableName")
    def table_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "table_name", value)

    @_builtins.property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "catalog_id")

    @catalog_id.setter
    def catalog_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "catalog_id", value)


if not MYPY:
    class JobCommandArgsDict(TypedDict):
        script_location: pulumi.Input[_builtins.str]
        name: NotRequired[pulumi.Input[_builtins.str]]
        python_version: NotRequired[pulumi.Input[_builtins.str]]
        runtime: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    JobCommandArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobCommandArgs:
    def __init__(__self__, *,
                 script_location: pulumi.Input[_builtins.str],
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 python_version: Optional[pulumi.Input[_builtins.str]] = None,
                 runtime: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "script_location", script_location)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if python_version is not None:
            pulumi.set(__self__, "python_version", python_version)
        if runtime is not None:
            pulumi.set(__self__, "runtime", runtime)

    @_builtins.property
    @pulumi.getter(name="scriptLocation")
    def script_location(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "script_location")

    @script_location.setter
    def script_location(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "script_location", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="pythonVersion")
    def python_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "python_version")

    @python_version.setter
    def python_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "python_version", value)

    @_builtins.property
    @pulumi.getter
    def runtime(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "runtime")

    @runtime.setter
    def runtime(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "runtime", value)


if not MYPY:
    class JobExecutionPropertyArgsDict(TypedDict):
        max_concurrent_runs: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    JobExecutionPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobExecutionPropertyArgs:
    def __init__(__self__, *,
                 max_concurrent_runs: Optional[pulumi.Input[_builtins.int]] = None):
        if max_concurrent_runs is not None:
            pulumi.set(__self__, "max_concurrent_runs", max_concurrent_runs)

    @_builtins.property
    @pulumi.getter(name="maxConcurrentRuns")
    def max_concurrent_runs(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "max_concurrent_runs")

    @max_concurrent_runs.setter
    def max_concurrent_runs(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_concurrent_runs", value)


if not MYPY:
    class JobNotificationPropertyArgsDict(TypedDict):
        notify_delay_after: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    JobNotificationPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobNotificationPropertyArgs:
    def __init__(__self__, *,
                 notify_delay_after: Optional[pulumi.Input[_builtins.int]] = None):
        if notify_delay_after is not None:
            pulumi.set(__self__, "notify_delay_after", notify_delay_after)

    @_builtins.property
    @pulumi.getter(name="notifyDelayAfter")
    def notify_delay_after(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "notify_delay_after")

    @notify_delay_after.setter
    def notify_delay_after(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "notify_delay_after", value)


if not MYPY:
    class JobSourceControlDetailsArgsDict(TypedDict):
        auth_strategy: NotRequired[pulumi.Input[_builtins.str]]
        auth_token: NotRequired[pulumi.Input[_builtins.str]]
        branch: NotRequired[pulumi.Input[_builtins.str]]
        folder: NotRequired[pulumi.Input[_builtins.str]]
        last_commit_id: NotRequired[pulumi.Input[_builtins.str]]
        owner: NotRequired[pulumi.Input[_builtins.str]]
        provider: NotRequired[pulumi.Input[_builtins.str]]
        repository: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    JobSourceControlDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobSourceControlDetailsArgs:
    def __init__(__self__, *,
                 auth_strategy: Optional[pulumi.Input[_builtins.str]] = None,
                 auth_token: Optional[pulumi.Input[_builtins.str]] = None,
                 branch: Optional[pulumi.Input[_builtins.str]] = None,
                 folder: Optional[pulumi.Input[_builtins.str]] = None,
                 last_commit_id: Optional[pulumi.Input[_builtins.str]] = None,
                 owner: Optional[pulumi.Input[_builtins.str]] = None,
                 provider: Optional[pulumi.Input[_builtins.str]] = None,
                 repository: Optional[pulumi.Input[_builtins.str]] = None):
        if auth_strategy is not None:
            pulumi.set(__self__, "auth_strategy", auth_strategy)
        if auth_token is not None:
            pulumi.set(__self__, "auth_token", auth_token)
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if last_commit_id is not None:
            pulumi.set(__self__, "last_commit_id", last_commit_id)
        if owner is not None:
            pulumi.set(__self__, "owner", owner)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if repository is not None:
            pulumi.set(__self__, "repository", repository)

    @_builtins.property
    @pulumi.getter(name="authStrategy")
    def auth_strategy(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "auth_strategy")

    @auth_strategy.setter
    def auth_strategy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "auth_strategy", value)

    @_builtins.property
    @pulumi.getter(name="authToken")
    def auth_token(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "auth_token")

    @auth_token.setter
    def auth_token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "auth_token", value)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "branch")

    @branch.setter
    def branch(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "branch", value)

    @_builtins.property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "folder", value)

    @_builtins.property
    @pulumi.getter(name="lastCommitId")
    def last_commit_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "last_commit_id")

    @last_commit_id.setter
    def last_commit_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "last_commit_id", value)

    @_builtins.property
    @pulumi.getter
    def owner(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "owner")

    @owner.setter
    def owner(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "owner", value)

    @_builtins.property
    @pulumi.getter
    def provider(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "provider")

    @provider.setter
    def provider(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "provider", value)

    @_builtins.property
    @pulumi.getter
    def repository(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "repository")

    @repository.setter
    def repository(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "repository", value)


if not MYPY:
    class MLTransformInputRecordTableArgsDict(TypedDict):
        database_name: pulumi.Input[_builtins.str]
        table_name: pulumi.Input[_builtins.str]
        catalog_id: NotRequired[pulumi.Input[_builtins.str]]
        connection_name: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    MLTransformInputRecordTableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MLTransformInputRecordTableArgs:
    def __init__(__self__, *,
                 database_name: pulumi.Input[_builtins.str],
                 table_name: pulumi.Input[_builtins.str],
                 catalog_id: Optional[pulumi.Input[_builtins.str]] = None,
                 connection_name: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "table_name", table_name)
        if catalog_id is not None:
            pulumi.set(__self__, "catalog_id", catalog_id)
        if connection_name is not None:
            pulumi.set(__self__, "connection_name", connection_name)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="tableName")
    def table_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "table_name", value)

    @_builtins.property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "catalog_id")

    @catalog_id.setter
    def catalog_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "catalog_id", value)

    @_builtins.property
    @pulumi.getter(name="connectionName")
    def connection_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "connection_name")

    @connection_name.setter
    def connection_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "connection_name", value)


if not MYPY:
    class MLTransformParametersArgsDict(TypedDict):
        find_matches_parameters: pulumi.Input['MLTransformParametersFindMatchesParametersArgsDict']
        transform_type: pulumi.Input[_builtins.str]
elif False:
    MLTransformParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MLTransformParametersArgs:
    def __init__(__self__, *,
                 find_matches_parameters: pulumi.Input['MLTransformParametersFindMatchesParametersArgs'],
                 transform_type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "find_matches_parameters", find_matches_parameters)
        pulumi.set(__self__, "transform_type", transform_type)

    @_builtins.property
    @pulumi.getter(name="findMatchesParameters")
    def find_matches_parameters(self) -> pulumi.Input['MLTransformParametersFindMatchesParametersArgs']:
        return pulumi.get(self, "find_matches_parameters")

    @find_matches_parameters.setter
    def find_matches_parameters(self, value: pulumi.Input['MLTransformParametersFindMatchesParametersArgs']):
        pulumi.set(self, "find_matches_parameters", value)

    @_builtins.property
    @pulumi.getter(name="transformType")
    def transform_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "transform_type")

    @transform_type.setter
    def transform_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "transform_type", value)


if not MYPY:
    class MLTransformParametersFindMatchesParametersArgsDict(TypedDict):
        accuracy_cost_trade_off: NotRequired[pulumi.Input[_builtins.float]]
        enforce_provided_labels: NotRequired[pulumi.Input[_builtins.bool]]
        precision_recall_trade_off: NotRequired[pulumi.Input[_builtins.float]]
        primary_key_column_name: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    MLTransformParametersFindMatchesParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MLTransformParametersFindMatchesParametersArgs:
    def __init__(__self__, *,
                 accuracy_cost_trade_off: Optional[pulumi.Input[_builtins.float]] = None,
                 enforce_provided_labels: Optional[pulumi.Input[_builtins.bool]] = None,
                 precision_recall_trade_off: Optional[pulumi.Input[_builtins.float]] = None,
                 primary_key_column_name: Optional[pulumi.Input[_builtins.str]] = None):
        if accuracy_cost_trade_off is not None:
            pulumi.set(__self__, "accuracy_cost_trade_off", accuracy_cost_trade_off)
        if enforce_provided_labels is not None:
            pulumi.set(__self__, "enforce_provided_labels", enforce_provided_labels)
        if precision_recall_trade_off is not None:
            pulumi.set(__self__, "precision_recall_trade_off", precision_recall_trade_off)
        if primary_key_column_name is not None:
            pulumi.set(__self__, "primary_key_column_name", primary_key_column_name)

    @_builtins.property
    @pulumi.getter(name="accuracyCostTradeOff")
    def accuracy_cost_trade_off(self) -> Optional[pulumi.Input[_builtins.float]]:
        return pulumi.get(self, "accuracy_cost_trade_off")

    @accuracy_cost_trade_off.setter
    def accuracy_cost_trade_off(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "accuracy_cost_trade_off", value)

    @_builtins.property
    @pulumi.getter(name="enforceProvidedLabels")
    def enforce_provided_labels(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "enforce_provided_labels")

    @enforce_provided_labels.setter
    def enforce_provided_labels(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enforce_provided_labels", value)

    @_builtins.property
    @pulumi.getter(name="precisionRecallTradeOff")
    def precision_recall_trade_off(self) -> Optional[pulumi.Input[_builtins.float]]:
        return pulumi.get(self, "precision_recall_trade_off")

    @precision_recall_trade_off.setter
    def precision_recall_trade_off(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "precision_recall_trade_off", value)

    @_builtins.property
    @pulumi.getter(name="primaryKeyColumnName")
    def primary_key_column_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "primary_key_column_name")

    @primary_key_column_name.setter
    def primary_key_column_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "primary_key_column_name", value)


if not MYPY:
    class MLTransformSchemaArgsDict(TypedDict):
        data_type: NotRequired[pulumi.Input[_builtins.str]]
        name: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    MLTransformSchemaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MLTransformSchemaArgs:
    def __init__(__self__, *,
                 data_type: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        if data_type is not None:
            pulumi.set(__self__, "data_type", data_type)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "data_type")

    @data_type.setter
    def data_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "data_type", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class PartitionIndexPartitionIndexArgsDict(TypedDict):
        index_name: NotRequired[pulumi.Input[_builtins.str]]
        index_status: NotRequired[pulumi.Input[_builtins.str]]
        keys: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    PartitionIndexPartitionIndexArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PartitionIndexPartitionIndexArgs:
    def __init__(__self__, *,
                 index_name: Optional[pulumi.Input[_builtins.str]] = None,
                 index_status: Optional[pulumi.Input[_builtins.str]] = None,
                 keys: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if index_name is not None:
            pulumi.set(__self__, "index_name", index_name)
        if index_status is not None:
            pulumi.set(__self__, "index_status", index_status)
        if keys is not None:
            pulumi.set(__self__, "keys", keys)

    @_builtins.property
    @pulumi.getter(name="indexName")
    def index_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "index_name")

    @index_name.setter
    def index_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "index_name", value)

    @_builtins.property
    @pulumi.getter(name="indexStatus")
    def index_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "index_status")

    @index_status.setter
    def index_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "index_status", value)

    @_builtins.property
    @pulumi.getter
    def keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "keys")

    @keys.setter
    def keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "keys", value)


if not MYPY:
    class PartitionStorageDescriptorArgsDict(TypedDict):
        additional_locations: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        bucket_columns: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        columns: NotRequired[pulumi.Input[Sequence[pulumi.Input['PartitionStorageDescriptorColumnArgsDict']]]]
        compressed: NotRequired[pulumi.Input[_builtins.bool]]
        input_format: NotRequired[pulumi.Input[_builtins.str]]
        location: NotRequired[pulumi.Input[_builtins.str]]
        number_of_buckets: NotRequired[pulumi.Input[_builtins.int]]
        output_format: NotRequired[pulumi.Input[_builtins.str]]
        parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        ser_de_info: NotRequired[pulumi.Input['PartitionStorageDescriptorSerDeInfoArgsDict']]
        skewed_info: NotRequired[pulumi.Input['PartitionStorageDescriptorSkewedInfoArgsDict']]
        sort_columns: NotRequired[pulumi.Input[Sequence[pulumi.Input['PartitionStorageDescriptorSortColumnArgsDict']]]]
        stored_as_sub_directories: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    PartitionStorageDescriptorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PartitionStorageDescriptorArgs:
    def __init__(__self__, *,
                 additional_locations: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 bucket_columns: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 columns: Optional[pulumi.Input[Sequence[pulumi.Input['PartitionStorageDescriptorColumnArgs']]]] = None,
                 compressed: Optional[pulumi.Input[_builtins.bool]] = None,
                 input_format: Optional[pulumi.Input[_builtins.str]] = None,
                 location: Optional[pulumi.Input[_builtins.str]] = None,
                 number_of_buckets: Optional[pulumi.Input[_builtins.int]] = None,
                 output_format: Optional[pulumi.Input[_builtins.str]] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 ser_de_info: Optional[pulumi.Input['PartitionStorageDescriptorSerDeInfoArgs']] = None,
                 skewed_info: Optional[pulumi.Input['PartitionStorageDescriptorSkewedInfoArgs']] = None,
                 sort_columns: Optional[pulumi.Input[Sequence[pulumi.Input['PartitionStorageDescriptorSortColumnArgs']]]] = None,
                 stored_as_sub_directories: Optional[pulumi.Input[_builtins.bool]] = None):
        if additional_locations is not None:
            pulumi.set(__self__, "additional_locations", additional_locations)
        if bucket_columns is not None:
            pulumi.set(__self__, "bucket_columns", bucket_columns)
        if columns is not None:
            pulumi.set(__self__, "columns", columns)
        if compressed is not None:
            pulumi.set(__self__, "compressed", compressed)
        if input_format is not None:
            pulumi.set(__self__, "input_format", input_format)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if number_of_buckets is not None:
            pulumi.set(__self__, "number_of_buckets", number_of_buckets)
        if output_format is not None:
            pulumi.set(__self__, "output_format", output_format)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if ser_de_info is not None:
            pulumi.set(__self__, "ser_de_info", ser_de_info)
        if skewed_info is not None:
            pulumi.set(__self__, "skewed_info", skewed_info)
        if sort_columns is not None:
            pulumi.set(__self__, "sort_columns", sort_columns)
        if stored_as_sub_directories is not None:
            pulumi.set(__self__, "stored_as_sub_directories", stored_as_sub_directories)

    @_builtins.property
    @pulumi.getter(name="additionalLocations")
    def additional_locations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "additional_locations")

    @additional_locations.setter
    def additional_locations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "additional_locations", value)

    @_builtins.property
    @pulumi.getter(name="bucketColumns")
    def bucket_columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "bucket_columns")

    @bucket_columns.setter
    def bucket_columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "bucket_columns", value)

    @_builtins.property
    @pulumi.getter
    def columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PartitionStorageDescriptorColumnArgs']]]]:
        return pulumi.get(self, "columns")

    @columns.setter
    def columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PartitionStorageDescriptorColumnArgs']]]]):
        pulumi.set(self, "columns", value)

    @_builtins.property
    @pulumi.getter
    def compressed(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "compressed")

    @compressed.setter
    def compressed(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "compressed", value)

    @_builtins.property
    @pulumi.getter(name="inputFormat")
    def input_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "input_format")

    @input_format.setter
    def input_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "input_format", value)

    @_builtins.property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "location", value)

    @_builtins.property
    @pulumi.getter(name="numberOfBuckets")
    def number_of_buckets(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "number_of_buckets")

    @number_of_buckets.setter
    def number_of_buckets(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "number_of_buckets", value)

    @_builtins.property
    @pulumi.getter(name="outputFormat")
    def output_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "output_format")

    @output_format.setter
    def output_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "output_format", value)

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "parameters", value)

    @_builtins.property
    @pulumi.getter(name="serDeInfo")
    def ser_de_info(self) -> Optional[pulumi.Input['PartitionStorageDescriptorSerDeInfoArgs']]:
        return pulumi.get(self, "ser_de_info")

    @ser_de_info.setter
    def ser_de_info(self, value: Optional[pulumi.Input['PartitionStorageDescriptorSerDeInfoArgs']]):
        pulumi.set(self, "ser_de_info", value)

    @_builtins.property
    @pulumi.getter(name="skewedInfo")
    def skewed_info(self) -> Optional[pulumi.Input['PartitionStorageDescriptorSkewedInfoArgs']]:
        return pulumi.get(self, "skewed_info")

    @skewed_info.setter
    def skewed_info(self, value: Optional[pulumi.Input['PartitionStorageDescriptorSkewedInfoArgs']]):
        pulumi.set(self, "skewed_info", value)

    @_builtins.property
    @pulumi.getter(name="sortColumns")
    def sort_columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PartitionStorageDescriptorSortColumnArgs']]]]:
        return pulumi.get(self, "sort_columns")

    @sort_columns.setter
    def sort_columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PartitionStorageDescriptorSortColumnArgs']]]]):
        pulumi.set(self, "sort_columns", value)

    @_builtins.property
    @pulumi.getter(name="storedAsSubDirectories")
    def stored_as_sub_directories(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "stored_as_sub_directories")

    @stored_as_sub_directories.setter
    def stored_as_sub_directories(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "stored_as_sub_directories", value)


if not MYPY:
    class PartitionStorageDescriptorColumnArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        comment: NotRequired[pulumi.Input[_builtins.str]]
        type: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PartitionStorageDescriptorColumnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PartitionStorageDescriptorColumnArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 comment: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "name", name)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "comment", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class PartitionStorageDescriptorSerDeInfoArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        serialization_library: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PartitionStorageDescriptorSerDeInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PartitionStorageDescriptorSerDeInfoArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 serialization_library: Optional[pulumi.Input[_builtins.str]] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if serialization_library is not None:
            pulumi.set(__self__, "serialization_library", serialization_library)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "parameters", value)

    @_builtins.property
    @pulumi.getter(name="serializationLibrary")
    def serialization_library(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "serialization_library")

    @serialization_library.setter
    def serialization_library(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "serialization_library", value)


if not MYPY:
    class PartitionStorageDescriptorSkewedInfoArgsDict(TypedDict):
        skewed_column_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        skewed_column_value_location_maps: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        skewed_column_values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    PartitionStorageDescriptorSkewedInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PartitionStorageDescriptorSkewedInfoArgs:
    def __init__(__self__, *,
                 skewed_column_names: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 skewed_column_value_location_maps: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 skewed_column_values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if skewed_column_names is not None:
            pulumi.set(__self__, "skewed_column_names", skewed_column_names)
        if skewed_column_value_location_maps is not None:
            pulumi.set(__self__, "skewed_column_value_location_maps", skewed_column_value_location_maps)
        if skewed_column_values is not None:
            pulumi.set(__self__, "skewed_column_values", skewed_column_values)

    @_builtins.property
    @pulumi.getter(name="skewedColumnNames")
    def skewed_column_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "skewed_column_names")

    @skewed_column_names.setter
    def skewed_column_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "skewed_column_names", value)

    @_builtins.property
    @pulumi.getter(name="skewedColumnValueLocationMaps")
    def skewed_column_value_location_maps(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "skewed_column_value_location_maps")

    @skewed_column_value_location_maps.setter
    def skewed_column_value_location_maps(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "skewed_column_value_location_maps", value)

    @_builtins.property
    @pulumi.getter(name="skewedColumnValues")
    def skewed_column_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "skewed_column_values")

    @skewed_column_values.setter
    def skewed_column_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "skewed_column_values", value)


if not MYPY:
    class PartitionStorageDescriptorSortColumnArgsDict(TypedDict):
        column: pulumi.Input[_builtins.str]
        sort_order: pulumi.Input[_builtins.int]
elif False:
    PartitionStorageDescriptorSortColumnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PartitionStorageDescriptorSortColumnArgs:
    def __init__(__self__, *,
                 column: pulumi.Input[_builtins.str],
                 sort_order: pulumi.Input[_builtins.int]):
        pulumi.set(__self__, "column", column)
        pulumi.set(__self__, "sort_order", sort_order)

    @_builtins.property
    @pulumi.getter
    def column(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "column")

    @column.setter
    def column(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "column", value)

    @_builtins.property
    @pulumi.getter(name="sortOrder")
    def sort_order(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "sort_order")

    @sort_order.setter
    def sort_order(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "sort_order", value)


if not MYPY:
    class SecurityConfigurationEncryptionConfigurationArgsDict(TypedDict):
        cloudwatch_encryption: pulumi.Input['SecurityConfigurationEncryptionConfigurationCloudwatchEncryptionArgsDict']
        job_bookmarks_encryption: pulumi.Input['SecurityConfigurationEncryptionConfigurationJobBookmarksEncryptionArgsDict']
        s3_encryption: pulumi.Input['SecurityConfigurationEncryptionConfigurationS3EncryptionArgsDict']
elif False:
    SecurityConfigurationEncryptionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityConfigurationEncryptionConfigurationArgs:
    def __init__(__self__, *,
                 cloudwatch_encryption: pulumi.Input['SecurityConfigurationEncryptionConfigurationCloudwatchEncryptionArgs'],
                 job_bookmarks_encryption: pulumi.Input['SecurityConfigurationEncryptionConfigurationJobBookmarksEncryptionArgs'],
                 s3_encryption: pulumi.Input['SecurityConfigurationEncryptionConfigurationS3EncryptionArgs']):
        pulumi.set(__self__, "cloudwatch_encryption", cloudwatch_encryption)
        pulumi.set(__self__, "job_bookmarks_encryption", job_bookmarks_encryption)
        pulumi.set(__self__, "s3_encryption", s3_encryption)

    @_builtins.property
    @pulumi.getter(name="cloudwatchEncryption")
    def cloudwatch_encryption(self) -> pulumi.Input['SecurityConfigurationEncryptionConfigurationCloudwatchEncryptionArgs']:
        return pulumi.get(self, "cloudwatch_encryption")

    @cloudwatch_encryption.setter
    def cloudwatch_encryption(self, value: pulumi.Input['SecurityConfigurationEncryptionConfigurationCloudwatchEncryptionArgs']):
        pulumi.set(self, "cloudwatch_encryption", value)

    @_builtins.property
    @pulumi.getter(name="jobBookmarksEncryption")
    def job_bookmarks_encryption(self) -> pulumi.Input['SecurityConfigurationEncryptionConfigurationJobBookmarksEncryptionArgs']:
        return pulumi.get(self, "job_bookmarks_encryption")

    @job_bookmarks_encryption.setter
    def job_bookmarks_encryption(self, value: pulumi.Input['SecurityConfigurationEncryptionConfigurationJobBookmarksEncryptionArgs']):
        pulumi.set(self, "job_bookmarks_encryption", value)

    @_builtins.property
    @pulumi.getter(name="s3Encryption")
    def s3_encryption(self) -> pulumi.Input['SecurityConfigurationEncryptionConfigurationS3EncryptionArgs']:
        return pulumi.get(self, "s3_encryption")

    @s3_encryption.setter
    def s3_encryption(self, value: pulumi.Input['SecurityConfigurationEncryptionConfigurationS3EncryptionArgs']):
        pulumi.set(self, "s3_encryption", value)


if not MYPY:
    class SecurityConfigurationEncryptionConfigurationCloudwatchEncryptionArgsDict(TypedDict):
        cloudwatch_encryption_mode: NotRequired[pulumi.Input[_builtins.str]]
        kms_key_arn: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    SecurityConfigurationEncryptionConfigurationCloudwatchEncryptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityConfigurationEncryptionConfigurationCloudwatchEncryptionArgs:
    def __init__(__self__, *,
                 cloudwatch_encryption_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 kms_key_arn: Optional[pulumi.Input[_builtins.str]] = None):
        if cloudwatch_encryption_mode is not None:
            pulumi.set(__self__, "cloudwatch_encryption_mode", cloudwatch_encryption_mode)
        if kms_key_arn is not None:
            pulumi.set(__self__, "kms_key_arn", kms_key_arn)

    @_builtins.property
    @pulumi.getter(name="cloudwatchEncryptionMode")
    def cloudwatch_encryption_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "cloudwatch_encryption_mode")

    @cloudwatch_encryption_mode.setter
    def cloudwatch_encryption_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cloudwatch_encryption_mode", value)

    @_builtins.property
    @pulumi.getter(name="kmsKeyArn")
    def kms_key_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "kms_key_arn")

    @kms_key_arn.setter
    def kms_key_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kms_key_arn", value)


if not MYPY:
    class SecurityConfigurationEncryptionConfigurationJobBookmarksEncryptionArgsDict(TypedDict):
        job_bookmarks_encryption_mode: NotRequired[pulumi.Input[_builtins.str]]
        kms_key_arn: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    SecurityConfigurationEncryptionConfigurationJobBookmarksEncryptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityConfigurationEncryptionConfigurationJobBookmarksEncryptionArgs:
    def __init__(__self__, *,
                 job_bookmarks_encryption_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 kms_key_arn: Optional[pulumi.Input[_builtins.str]] = None):
        if job_bookmarks_encryption_mode is not None:
            pulumi.set(__self__, "job_bookmarks_encryption_mode", job_bookmarks_encryption_mode)
        if kms_key_arn is not None:
            pulumi.set(__self__, "kms_key_arn", kms_key_arn)

    @_builtins.property
    @pulumi.getter(name="jobBookmarksEncryptionMode")
    def job_bookmarks_encryption_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "job_bookmarks_encryption_mode")

    @job_bookmarks_encryption_mode.setter
    def job_bookmarks_encryption_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "job_bookmarks_encryption_mode", value)

    @_builtins.property
    @pulumi.getter(name="kmsKeyArn")
    def kms_key_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "kms_key_arn")

    @kms_key_arn.setter
    def kms_key_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kms_key_arn", value)


if not MYPY:
    class SecurityConfigurationEncryptionConfigurationS3EncryptionArgsDict(TypedDict):
        kms_key_arn: NotRequired[pulumi.Input[_builtins.str]]
        s3_encryption_mode: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    SecurityConfigurationEncryptionConfigurationS3EncryptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityConfigurationEncryptionConfigurationS3EncryptionArgs:
    def __init__(__self__, *,
                 kms_key_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 s3_encryption_mode: Optional[pulumi.Input[_builtins.str]] = None):
        if kms_key_arn is not None:
            pulumi.set(__self__, "kms_key_arn", kms_key_arn)
        if s3_encryption_mode is not None:
            pulumi.set(__self__, "s3_encryption_mode", s3_encryption_mode)

    @_builtins.property
    @pulumi.getter(name="kmsKeyArn")
    def kms_key_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "kms_key_arn")

    @kms_key_arn.setter
    def kms_key_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kms_key_arn", value)

    @_builtins.property
    @pulumi.getter(name="s3EncryptionMode")
    def s3_encryption_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "s3_encryption_mode")

    @s3_encryption_mode.setter
    def s3_encryption_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "s3_encryption_mode", value)


if not MYPY:
    class TriggerActionArgsDict(TypedDict):
        arguments: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        crawler_name: NotRequired[pulumi.Input[_builtins.str]]
        job_name: NotRequired[pulumi.Input[_builtins.str]]
        notification_property: NotRequired[pulumi.Input['TriggerActionNotificationPropertyArgsDict']]
        security_configuration: NotRequired[pulumi.Input[_builtins.str]]
        timeout: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    TriggerActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TriggerActionArgs:
    def __init__(__self__, *,
                 arguments: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 crawler_name: Optional[pulumi.Input[_builtins.str]] = None,
                 job_name: Optional[pulumi.Input[_builtins.str]] = None,
                 notification_property: Optional[pulumi.Input['TriggerActionNotificationPropertyArgs']] = None,
                 security_configuration: Optional[pulumi.Input[_builtins.str]] = None,
                 timeout: Optional[pulumi.Input[_builtins.int]] = None):
        if arguments is not None:
            pulumi.set(__self__, "arguments", arguments)
        if crawler_name is not None:
            pulumi.set(__self__, "crawler_name", crawler_name)
        if job_name is not None:
            pulumi.set(__self__, "job_name", job_name)
        if notification_property is not None:
            pulumi.set(__self__, "notification_property", notification_property)
        if security_configuration is not None:
            pulumi.set(__self__, "security_configuration", security_configuration)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def arguments(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "arguments")

    @arguments.setter
    def arguments(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "arguments", value)

    @_builtins.property
    @pulumi.getter(name="crawlerName")
    def crawler_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "crawler_name")

    @crawler_name.setter
    def crawler_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "crawler_name", value)

    @_builtins.property
    @pulumi.getter(name="jobName")
    def job_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "job_name")

    @job_name.setter
    def job_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "job_name", value)

    @_builtins.property
    @pulumi.getter(name="notificationProperty")
    def notification_property(self) -> Optional[pulumi.Input['TriggerActionNotificationPropertyArgs']]:
        return pulumi.get(self, "notification_property")

    @notification_property.setter
    def notification_property(self, value: Optional[pulumi.Input['TriggerActionNotificationPropertyArgs']]):
        pulumi.set(self, "notification_property", value)

    @_builtins.property
    @pulumi.getter(name="securityConfiguration")
    def security_configuration(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "security_configuration")

    @security_configuration.setter
    def security_configuration(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "security_configuration", value)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class TriggerActionNotificationPropertyArgsDict(TypedDict):
        notify_delay_after: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    TriggerActionNotificationPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TriggerActionNotificationPropertyArgs:
    def __init__(__self__, *,
                 notify_delay_after: Optional[pulumi.Input[_builtins.int]] = None):
        if notify_delay_after is not None:
            pulumi.set(__self__, "notify_delay_after", notify_delay_after)

    @_builtins.property
    @pulumi.getter(name="notifyDelayAfter")
    def notify_delay_after(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "notify_delay_after")

    @notify_delay_after.setter
    def notify_delay_after(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "notify_delay_after", value)


if not MYPY:
    class TriggerEventBatchingConditionArgsDict(TypedDict):
        batch_size: pulumi.Input[_builtins.int]
        batch_window: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    TriggerEventBatchingConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TriggerEventBatchingConditionArgs:
    def __init__(__self__, *,
                 batch_size: pulumi.Input[_builtins.int],
                 batch_window: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "batch_size", batch_size)
        if batch_window is not None:
            pulumi.set(__self__, "batch_window", batch_window)

    @_builtins.property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "batch_size")

    @batch_size.setter
    def batch_size(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "batch_size", value)

    @_builtins.property
    @pulumi.getter(name="batchWindow")
    def batch_window(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "batch_window")

    @batch_window.setter
    def batch_window(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "batch_window", value)


if not MYPY:
    class TriggerPredicateArgsDict(TypedDict):
        conditions: pulumi.Input[Sequence[pulumi.Input['TriggerPredicateConditionArgsDict']]]
        logical: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    TriggerPredicateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TriggerPredicateArgs:
    def __init__(__self__, *,
                 conditions: pulumi.Input[Sequence[pulumi.Input['TriggerPredicateConditionArgs']]],
                 logical: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "conditions", conditions)
        if logical is not None:
            pulumi.set(__self__, "logical", logical)

    @_builtins.property
    @pulumi.getter
    def conditions(self) -> pulumi.Input[Sequence[pulumi.Input['TriggerPredicateConditionArgs']]]:
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: pulumi.Input[Sequence[pulumi.Input['TriggerPredicateConditionArgs']]]):
        pulumi.set(self, "conditions", value)

    @_builtins.property
    @pulumi.getter
    def logical(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "logical")

    @logical.setter
    def logical(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "logical", value)


if not MYPY:
    class TriggerPredicateConditionArgsDict(TypedDict):
        crawl_state: NotRequired[pulumi.Input[_builtins.str]]
        crawler_name: NotRequired[pulumi.Input[_builtins.str]]
        job_name: NotRequired[pulumi.Input[_builtins.str]]
        logical_operator: NotRequired[pulumi.Input[_builtins.str]]
        state: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    TriggerPredicateConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TriggerPredicateConditionArgs:
    def __init__(__self__, *,
                 crawl_state: Optional[pulumi.Input[_builtins.str]] = None,
                 crawler_name: Optional[pulumi.Input[_builtins.str]] = None,
                 job_name: Optional[pulumi.Input[_builtins.str]] = None,
                 logical_operator: Optional[pulumi.Input[_builtins.str]] = None,
                 state: Optional[pulumi.Input[_builtins.str]] = None):
        if crawl_state is not None:
            pulumi.set(__self__, "crawl_state", crawl_state)
        if crawler_name is not None:
            pulumi.set(__self__, "crawler_name", crawler_name)
        if job_name is not None:
            pulumi.set(__self__, "job_name", job_name)
        if logical_operator is not None:
            pulumi.set(__self__, "logical_operator", logical_operator)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="crawlState")
    def crawl_state(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "crawl_state")

    @crawl_state.setter
    def crawl_state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "crawl_state", value)

    @_builtins.property
    @pulumi.getter(name="crawlerName")
    def crawler_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "crawler_name")

    @crawler_name.setter
    def crawler_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "crawler_name", value)

    @_builtins.property
    @pulumi.getter(name="jobName")
    def job_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "job_name")

    @job_name.setter
    def job_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "job_name", value)

    @_builtins.property
    @pulumi.getter(name="logicalOperator")
    def logical_operator(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "logical_operator")

    @logical_operator.setter
    def logical_operator(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "logical_operator", value)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class UserDefinedFunctionResourceUriArgsDict(TypedDict):
        resource_type: pulumi.Input[_builtins.str]
        uri: pulumi.Input[_builtins.str]
elif False:
    UserDefinedFunctionResourceUriArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserDefinedFunctionResourceUriArgs:
    def __init__(__self__, *,
                 resource_type: pulumi.Input[_builtins.str],
                 uri: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "resource_type", resource_type)
        pulumi.set(__self__, "uri", uri)

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "resource_type", value)

    @_builtins.property
    @pulumi.getter
    def uri(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "uri", value)


if not MYPY:
    class GetScriptDagEdgeArgsDict(TypedDict):
        source: _builtins.str
        target: _builtins.str
        target_parameter: NotRequired[_builtins.str]
elif False:
    GetScriptDagEdgeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetScriptDagEdgeArgs:
    def __init__(__self__, *,
                 source: _builtins.str,
                 target: _builtins.str,
                 target_parameter: Optional[_builtins.str] = None):
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "target", target)
        if target_parameter is not None:
            pulumi.set(__self__, "target_parameter", target_parameter)

    @_builtins.property
    @pulumi.getter
    def source(self) -> _builtins.str:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: _builtins.str):
        pulumi.set(self, "source", value)

    @_builtins.property
    @pulumi.getter
    def target(self) -> _builtins.str:
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: _builtins.str):
        pulumi.set(self, "target", value)

    @_builtins.property
    @pulumi.getter(name="targetParameter")
    def target_parameter(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "target_parameter")

    @target_parameter.setter
    def target_parameter(self, value: Optional[_builtins.str]):
        pulumi.set(self, "target_parameter", value)


if not MYPY:
    class GetScriptDagNodeArgsDict(TypedDict):
        args: Sequence['GetScriptDagNodeArgArgsDict']
        id: _builtins.str
        node_type: _builtins.str
        line_number: NotRequired[_builtins.int]
elif False:
    GetScriptDagNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetScriptDagNodeArgs:
    def __init__(__self__, *,
                 args: Sequence['GetScriptDagNodeArgArgs'],
                 id: _builtins.str,
                 node_type: _builtins.str,
                 line_number: Optional[_builtins.int] = None):
        pulumi.set(__self__, "args", args)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "node_type", node_type)
        if line_number is not None:
            pulumi.set(__self__, "line_number", line_number)

    @_builtins.property
    @pulumi.getter
    def args(self) -> Sequence['GetScriptDagNodeArgArgs']:
        return pulumi.get(self, "args")

    @args.setter
    def args(self, value: Sequence['GetScriptDagNodeArgArgs']):
        pulumi.set(self, "args", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: _builtins.str):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="nodeType")
    def node_type(self) -> _builtins.str:
        return pulumi.get(self, "node_type")

    @node_type.setter
    def node_type(self, value: _builtins.str):
        pulumi.set(self, "node_type", value)

    @_builtins.property
    @pulumi.getter(name="lineNumber")
    def line_number(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "line_number")

    @line_number.setter
    def line_number(self, value: Optional[_builtins.int]):
        pulumi.set(self, "line_number", value)


if not MYPY:
    class GetScriptDagNodeArgArgsDict(TypedDict):
        name: _builtins.str
        value: _builtins.str
        param: NotRequired[_builtins.bool]
elif False:
    GetScriptDagNodeArgArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetScriptDagNodeArgArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str,
                 param: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)
        if param is not None:
            pulumi.set(__self__, "param", param)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: _builtins.str):
        pulumi.set(self, "value", value)

    @_builtins.property
    @pulumi.getter
    def param(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "param")

    @param.setter
    def param(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "param", value)


