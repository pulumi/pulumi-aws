# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'CatalogDatabaseCreateTableDefaultPermission',
    'CatalogDatabaseCreateTableDefaultPermissionPrincipal',
    'CatalogDatabaseTargetDatabase',
    'CatalogTableOpenTableFormatInput',
    'CatalogTableOpenTableFormatInputIcebergInput',
    'CatalogTablePartitionIndex',
    'CatalogTablePartitionKey',
    'CatalogTableStorageDescriptor',
    'CatalogTableStorageDescriptorColumn',
    'CatalogTableStorageDescriptorSchemaReference',
    'CatalogTableStorageDescriptorSchemaReferenceSchemaId',
    'CatalogTableStorageDescriptorSerDeInfo',
    'CatalogTableStorageDescriptorSkewedInfo',
    'CatalogTableStorageDescriptorSortColumn',
    'CatalogTableTargetTable',
    'ClassifierCsvClassifier',
    'ClassifierGrokClassifier',
    'ClassifierJsonClassifier',
    'ClassifierXmlClassifier',
    'ConnectionPhysicalConnectionRequirements',
    'CrawlerCatalogTarget',
    'CrawlerDeltaTarget',
    'CrawlerDynamodbTarget',
    'CrawlerHudiTarget',
    'CrawlerIcebergTarget',
    'CrawlerJdbcTarget',
    'CrawlerLakeFormationConfiguration',
    'CrawlerLineageConfiguration',
    'CrawlerMongodbTarget',
    'CrawlerRecrawlPolicy',
    'CrawlerS3Target',
    'CrawlerSchemaChangePolicy',
    'DataCatalogEncryptionSettingsDataCatalogEncryptionSettings',
    'DataCatalogEncryptionSettingsDataCatalogEncryptionSettingsConnectionPasswordEncryption',
    'DataCatalogEncryptionSettingsDataCatalogEncryptionSettingsEncryptionAtRest',
    'DataQualityRulesetTargetTable',
    'JobCommand',
    'JobExecutionProperty',
    'JobNotificationProperty',
    'MLTransformInputRecordTable',
    'MLTransformParameters',
    'MLTransformParametersFindMatchesParameters',
    'MLTransformSchema',
    'PartitionIndexPartitionIndex',
    'PartitionStorageDescriptor',
    'PartitionStorageDescriptorColumn',
    'PartitionStorageDescriptorSerDeInfo',
    'PartitionStorageDescriptorSkewedInfo',
    'PartitionStorageDescriptorSortColumn',
    'SecurityConfigurationEncryptionConfiguration',
    'SecurityConfigurationEncryptionConfigurationCloudwatchEncryption',
    'SecurityConfigurationEncryptionConfigurationJobBookmarksEncryption',
    'SecurityConfigurationEncryptionConfigurationS3Encryption',
    'TriggerAction',
    'TriggerActionNotificationProperty',
    'TriggerEventBatchingCondition',
    'TriggerPredicate',
    'TriggerPredicateCondition',
    'UserDefinedFunctionResourceUri',
    'GetCatalogTablePartitionIndexResult',
    'GetCatalogTablePartitionKeyResult',
    'GetCatalogTableStorageDescriptorResult',
    'GetCatalogTableStorageDescriptorColumnResult',
    'GetCatalogTableStorageDescriptorSchemaReferenceResult',
    'GetCatalogTableStorageDescriptorSchemaReferenceSchemaIdResult',
    'GetCatalogTableStorageDescriptorSerDeInfoResult',
    'GetCatalogTableStorageDescriptorSkewedInfoResult',
    'GetCatalogTableStorageDescriptorSortColumnResult',
    'GetCatalogTableTargetTableResult',
    'GetConnectionPhysicalConnectionRequirementResult',
    'GetDataCatalogEncryptionSettingsDataCatalogEncryptionSettingResult',
    'GetDataCatalogEncryptionSettingsDataCatalogEncryptionSettingConnectionPasswordEncryptionResult',
    'GetDataCatalogEncryptionSettingsDataCatalogEncryptionSettingEncryptionAtRestResult',
    'GetScriptDagEdgeResult',
    'GetScriptDagNodeResult',
    'GetScriptDagNodeArgResult',
]

@pulumi.output_type
class CatalogDatabaseCreateTableDefaultPermission(dict):
    def __init__(__self__, *,
                 permissions: Optional[Sequence[str]] = None,
                 principal: Optional['outputs.CatalogDatabaseCreateTableDefaultPermissionPrincipal'] = None):
        """
        :param Sequence[str] permissions: The permissions that are granted to the principal.
        :param 'CatalogDatabaseCreateTableDefaultPermissionPrincipalArgs' principal: The principal who is granted permissions.. See `principal` below.
        """
        CatalogDatabaseCreateTableDefaultPermission._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            permissions=permissions,
            principal=principal,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             permissions: Optional[Sequence[str]] = None,
             principal: Optional['outputs.CatalogDatabaseCreateTableDefaultPermissionPrincipal'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if permissions is not None:
            _setter("permissions", permissions)
        if principal is not None:
            _setter("principal", principal)

    @property
    @pulumi.getter
    def permissions(self) -> Optional[Sequence[str]]:
        """
        The permissions that are granted to the principal.
        """
        return pulumi.get(self, "permissions")

    @property
    @pulumi.getter
    def principal(self) -> Optional['outputs.CatalogDatabaseCreateTableDefaultPermissionPrincipal']:
        """
        The principal who is granted permissions.. See `principal` below.
        """
        return pulumi.get(self, "principal")


@pulumi.output_type
class CatalogDatabaseCreateTableDefaultPermissionPrincipal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataLakePrincipalIdentifier":
            suggest = "data_lake_principal_identifier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CatalogDatabaseCreateTableDefaultPermissionPrincipal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CatalogDatabaseCreateTableDefaultPermissionPrincipal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CatalogDatabaseCreateTableDefaultPermissionPrincipal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_lake_principal_identifier: Optional[str] = None):
        """
        :param str data_lake_principal_identifier: An identifier for the Lake Formation principal.
        """
        CatalogDatabaseCreateTableDefaultPermissionPrincipal._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_lake_principal_identifier=data_lake_principal_identifier,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_lake_principal_identifier: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if data_lake_principal_identifier is None and 'dataLakePrincipalIdentifier' in kwargs:
            data_lake_principal_identifier = kwargs['dataLakePrincipalIdentifier']

        if data_lake_principal_identifier is not None:
            _setter("data_lake_principal_identifier", data_lake_principal_identifier)

    @property
    @pulumi.getter(name="dataLakePrincipalIdentifier")
    def data_lake_principal_identifier(self) -> Optional[str]:
        """
        An identifier for the Lake Formation principal.
        """
        return pulumi.get(self, "data_lake_principal_identifier")


@pulumi.output_type
class CatalogDatabaseTargetDatabase(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "catalogId":
            suggest = "catalog_id"
        elif key == "databaseName":
            suggest = "database_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CatalogDatabaseTargetDatabase. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CatalogDatabaseTargetDatabase.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CatalogDatabaseTargetDatabase.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 catalog_id: str,
                 database_name: str,
                 region: Optional[str] = None):
        """
        :param str catalog_id: ID of the Data Catalog in which the database resides.
        :param str database_name: Name of the catalog database.
        :param str region: Region of the target database.
        """
        CatalogDatabaseTargetDatabase._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            catalog_id=catalog_id,
            database_name=database_name,
            region=region,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             catalog_id: Optional[str] = None,
             database_name: Optional[str] = None,
             region: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if catalog_id is None and 'catalogId' in kwargs:
            catalog_id = kwargs['catalogId']
        if catalog_id is None:
            raise TypeError("Missing 'catalog_id' argument")
        if database_name is None and 'databaseName' in kwargs:
            database_name = kwargs['databaseName']
        if database_name is None:
            raise TypeError("Missing 'database_name' argument")

        _setter("catalog_id", catalog_id)
        _setter("database_name", database_name)
        if region is not None:
            _setter("region", region)

    @property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> str:
        """
        ID of the Data Catalog in which the database resides.
        """
        return pulumi.get(self, "catalog_id")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        Name of the catalog database.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        Region of the target database.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class CatalogTableOpenTableFormatInput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "icebergInput":
            suggest = "iceberg_input"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CatalogTableOpenTableFormatInput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CatalogTableOpenTableFormatInput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CatalogTableOpenTableFormatInput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 iceberg_input: 'outputs.CatalogTableOpenTableFormatInputIcebergInput'):
        """
        :param 'CatalogTableOpenTableFormatInputIcebergInputArgs' iceberg_input: Configuration block for iceberg table config. See `iceberg_input` below.
        """
        CatalogTableOpenTableFormatInput._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            iceberg_input=iceberg_input,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             iceberg_input: Optional['outputs.CatalogTableOpenTableFormatInputIcebergInput'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if iceberg_input is None and 'icebergInput' in kwargs:
            iceberg_input = kwargs['icebergInput']
        if iceberg_input is None:
            raise TypeError("Missing 'iceberg_input' argument")

        _setter("iceberg_input", iceberg_input)

    @property
    @pulumi.getter(name="icebergInput")
    def iceberg_input(self) -> 'outputs.CatalogTableOpenTableFormatInputIcebergInput':
        """
        Configuration block for iceberg table config. See `iceberg_input` below.
        """
        return pulumi.get(self, "iceberg_input")


@pulumi.output_type
class CatalogTableOpenTableFormatInputIcebergInput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metadataOperation":
            suggest = "metadata_operation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CatalogTableOpenTableFormatInputIcebergInput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CatalogTableOpenTableFormatInputIcebergInput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CatalogTableOpenTableFormatInputIcebergInput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metadata_operation: str,
                 version: Optional[str] = None):
        """
        :param str metadata_operation: A required metadata operation. Can only be set to CREATE.
        :param str version: The table version for the Iceberg table. Defaults to 2.
        """
        CatalogTableOpenTableFormatInputIcebergInput._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            metadata_operation=metadata_operation,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             metadata_operation: Optional[str] = None,
             version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if metadata_operation is None and 'metadataOperation' in kwargs:
            metadata_operation = kwargs['metadataOperation']
        if metadata_operation is None:
            raise TypeError("Missing 'metadata_operation' argument")

        _setter("metadata_operation", metadata_operation)
        if version is not None:
            _setter("version", version)

    @property
    @pulumi.getter(name="metadataOperation")
    def metadata_operation(self) -> str:
        """
        A required metadata operation. Can only be set to CREATE.
        """
        return pulumi.get(self, "metadata_operation")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        The table version for the Iceberg table. Defaults to 2.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class CatalogTablePartitionIndex(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "indexName":
            suggest = "index_name"
        elif key == "indexStatus":
            suggest = "index_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CatalogTablePartitionIndex. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CatalogTablePartitionIndex.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CatalogTablePartitionIndex.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index_name: str,
                 keys: Sequence[str],
                 index_status: Optional[str] = None):
        """
        :param str index_name: Name of the partition index.
        :param Sequence[str] keys: Keys for the partition index.
        """
        CatalogTablePartitionIndex._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index_name=index_name,
            keys=keys,
            index_status=index_status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index_name: Optional[str] = None,
             keys: Optional[Sequence[str]] = None,
             index_status: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if index_name is None and 'indexName' in kwargs:
            index_name = kwargs['indexName']
        if index_name is None:
            raise TypeError("Missing 'index_name' argument")
        if keys is None:
            raise TypeError("Missing 'keys' argument")
        if index_status is None and 'indexStatus' in kwargs:
            index_status = kwargs['indexStatus']

        _setter("index_name", index_name)
        _setter("keys", keys)
        if index_status is not None:
            _setter("index_status", index_status)

    @property
    @pulumi.getter(name="indexName")
    def index_name(self) -> str:
        """
        Name of the partition index.
        """
        return pulumi.get(self, "index_name")

    @property
    @pulumi.getter
    def keys(self) -> Sequence[str]:
        """
        Keys for the partition index.
        """
        return pulumi.get(self, "keys")

    @property
    @pulumi.getter(name="indexStatus")
    def index_status(self) -> Optional[str]:
        return pulumi.get(self, "index_status")


@pulumi.output_type
class CatalogTablePartitionKey(dict):
    def __init__(__self__, *,
                 name: str,
                 comment: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str name: Name of the Partition Key.
        :param str comment: Free-form text comment.
        :param str type: Datatype of data in the Partition Key.
        """
        CatalogTablePartitionKey._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            comment=comment,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             comment: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)
        if comment is not None:
            _setter("comment", comment)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the Partition Key.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def comment(self) -> Optional[str]:
        """
        Free-form text comment.
        """
        return pulumi.get(self, "comment")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Datatype of data in the Partition Key.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class CatalogTableStorageDescriptor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketColumns":
            suggest = "bucket_columns"
        elif key == "inputFormat":
            suggest = "input_format"
        elif key == "numberOfBuckets":
            suggest = "number_of_buckets"
        elif key == "outputFormat":
            suggest = "output_format"
        elif key == "schemaReference":
            suggest = "schema_reference"
        elif key == "serDeInfo":
            suggest = "ser_de_info"
        elif key == "skewedInfo":
            suggest = "skewed_info"
        elif key == "sortColumns":
            suggest = "sort_columns"
        elif key == "storedAsSubDirectories":
            suggest = "stored_as_sub_directories"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CatalogTableStorageDescriptor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CatalogTableStorageDescriptor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CatalogTableStorageDescriptor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_columns: Optional[Sequence[str]] = None,
                 columns: Optional[Sequence['outputs.CatalogTableStorageDescriptorColumn']] = None,
                 compressed: Optional[bool] = None,
                 input_format: Optional[str] = None,
                 location: Optional[str] = None,
                 number_of_buckets: Optional[int] = None,
                 output_format: Optional[str] = None,
                 parameters: Optional[Mapping[str, str]] = None,
                 schema_reference: Optional['outputs.CatalogTableStorageDescriptorSchemaReference'] = None,
                 ser_de_info: Optional['outputs.CatalogTableStorageDescriptorSerDeInfo'] = None,
                 skewed_info: Optional['outputs.CatalogTableStorageDescriptorSkewedInfo'] = None,
                 sort_columns: Optional[Sequence['outputs.CatalogTableStorageDescriptorSortColumn']] = None,
                 stored_as_sub_directories: Optional[bool] = None):
        """
        :param Sequence[str] bucket_columns: List of reducer grouping columns, clustering columns, and bucketing columns in the table.
        :param Sequence['CatalogTableStorageDescriptorColumnArgs'] columns: Configuration block for columns in the table. See `columns` below.
        :param bool compressed: Whether the data in the table is compressed.
        :param str input_format: Input format: SequenceFileInputFormat (binary), or TextInputFormat, or a custom format.
        :param str location: Physical location of the table. By default this takes the form of the warehouse location, followed by the database location in the warehouse, followed by the table name.
        :param int number_of_buckets: Must be specified if the table contains any dimension columns.
        :param str output_format: Output format: SequenceFileOutputFormat (binary), or IgnoreKeyTextOutputFormat, or a custom format.
        :param Mapping[str, str] parameters: User-supplied properties in key-value form.
        :param 'CatalogTableStorageDescriptorSchemaReferenceArgs' schema_reference: Object that references a schema stored in the AWS Glue Schema Registry. When creating a table, you can pass an empty list of columns for the schema, and instead use a schema reference. See Schema Reference below.
        :param 'CatalogTableStorageDescriptorSerDeInfoArgs' ser_de_info: Configuration block for serialization and deserialization ("SerDe") information. See `ser_de_info` below.
        :param 'CatalogTableStorageDescriptorSkewedInfoArgs' skewed_info: Configuration block with information about values that appear very frequently in a column (skewed values). See `skewed_info` below.
        :param Sequence['CatalogTableStorageDescriptorSortColumnArgs'] sort_columns: Configuration block for the sort order of each bucket in the table. See `sort_columns` below.
        :param bool stored_as_sub_directories: Whether the table data is stored in subdirectories.
        """
        CatalogTableStorageDescriptor._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bucket_columns=bucket_columns,
            columns=columns,
            compressed=compressed,
            input_format=input_format,
            location=location,
            number_of_buckets=number_of_buckets,
            output_format=output_format,
            parameters=parameters,
            schema_reference=schema_reference,
            ser_de_info=ser_de_info,
            skewed_info=skewed_info,
            sort_columns=sort_columns,
            stored_as_sub_directories=stored_as_sub_directories,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bucket_columns: Optional[Sequence[str]] = None,
             columns: Optional[Sequence['outputs.CatalogTableStorageDescriptorColumn']] = None,
             compressed: Optional[bool] = None,
             input_format: Optional[str] = None,
             location: Optional[str] = None,
             number_of_buckets: Optional[int] = None,
             output_format: Optional[str] = None,
             parameters: Optional[Mapping[str, str]] = None,
             schema_reference: Optional['outputs.CatalogTableStorageDescriptorSchemaReference'] = None,
             ser_de_info: Optional['outputs.CatalogTableStorageDescriptorSerDeInfo'] = None,
             skewed_info: Optional['outputs.CatalogTableStorageDescriptorSkewedInfo'] = None,
             sort_columns: Optional[Sequence['outputs.CatalogTableStorageDescriptorSortColumn']] = None,
             stored_as_sub_directories: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if bucket_columns is None and 'bucketColumns' in kwargs:
            bucket_columns = kwargs['bucketColumns']
        if input_format is None and 'inputFormat' in kwargs:
            input_format = kwargs['inputFormat']
        if number_of_buckets is None and 'numberOfBuckets' in kwargs:
            number_of_buckets = kwargs['numberOfBuckets']
        if output_format is None and 'outputFormat' in kwargs:
            output_format = kwargs['outputFormat']
        if schema_reference is None and 'schemaReference' in kwargs:
            schema_reference = kwargs['schemaReference']
        if ser_de_info is None and 'serDeInfo' in kwargs:
            ser_de_info = kwargs['serDeInfo']
        if skewed_info is None and 'skewedInfo' in kwargs:
            skewed_info = kwargs['skewedInfo']
        if sort_columns is None and 'sortColumns' in kwargs:
            sort_columns = kwargs['sortColumns']
        if stored_as_sub_directories is None and 'storedAsSubDirectories' in kwargs:
            stored_as_sub_directories = kwargs['storedAsSubDirectories']

        if bucket_columns is not None:
            _setter("bucket_columns", bucket_columns)
        if columns is not None:
            _setter("columns", columns)
        if compressed is not None:
            _setter("compressed", compressed)
        if input_format is not None:
            _setter("input_format", input_format)
        if location is not None:
            _setter("location", location)
        if number_of_buckets is not None:
            _setter("number_of_buckets", number_of_buckets)
        if output_format is not None:
            _setter("output_format", output_format)
        if parameters is not None:
            _setter("parameters", parameters)
        if schema_reference is not None:
            _setter("schema_reference", schema_reference)
        if ser_de_info is not None:
            _setter("ser_de_info", ser_de_info)
        if skewed_info is not None:
            _setter("skewed_info", skewed_info)
        if sort_columns is not None:
            _setter("sort_columns", sort_columns)
        if stored_as_sub_directories is not None:
            _setter("stored_as_sub_directories", stored_as_sub_directories)

    @property
    @pulumi.getter(name="bucketColumns")
    def bucket_columns(self) -> Optional[Sequence[str]]:
        """
        List of reducer grouping columns, clustering columns, and bucketing columns in the table.
        """
        return pulumi.get(self, "bucket_columns")

    @property
    @pulumi.getter
    def columns(self) -> Optional[Sequence['outputs.CatalogTableStorageDescriptorColumn']]:
        """
        Configuration block for columns in the table. See `columns` below.
        """
        return pulumi.get(self, "columns")

    @property
    @pulumi.getter
    def compressed(self) -> Optional[bool]:
        """
        Whether the data in the table is compressed.
        """
        return pulumi.get(self, "compressed")

    @property
    @pulumi.getter(name="inputFormat")
    def input_format(self) -> Optional[str]:
        """
        Input format: SequenceFileInputFormat (binary), or TextInputFormat, or a custom format.
        """
        return pulumi.get(self, "input_format")

    @property
    @pulumi.getter
    def location(self) -> Optional[str]:
        """
        Physical location of the table. By default this takes the form of the warehouse location, followed by the database location in the warehouse, followed by the table name.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter(name="numberOfBuckets")
    def number_of_buckets(self) -> Optional[int]:
        """
        Must be specified if the table contains any dimension columns.
        """
        return pulumi.get(self, "number_of_buckets")

    @property
    @pulumi.getter(name="outputFormat")
    def output_format(self) -> Optional[str]:
        """
        Output format: SequenceFileOutputFormat (binary), or IgnoreKeyTextOutputFormat, or a custom format.
        """
        return pulumi.get(self, "output_format")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, str]]:
        """
        User-supplied properties in key-value form.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter(name="schemaReference")
    def schema_reference(self) -> Optional['outputs.CatalogTableStorageDescriptorSchemaReference']:
        """
        Object that references a schema stored in the AWS Glue Schema Registry. When creating a table, you can pass an empty list of columns for the schema, and instead use a schema reference. See Schema Reference below.
        """
        return pulumi.get(self, "schema_reference")

    @property
    @pulumi.getter(name="serDeInfo")
    def ser_de_info(self) -> Optional['outputs.CatalogTableStorageDescriptorSerDeInfo']:
        """
        Configuration block for serialization and deserialization ("SerDe") information. See `ser_de_info` below.
        """
        return pulumi.get(self, "ser_de_info")

    @property
    @pulumi.getter(name="skewedInfo")
    def skewed_info(self) -> Optional['outputs.CatalogTableStorageDescriptorSkewedInfo']:
        """
        Configuration block with information about values that appear very frequently in a column (skewed values). See `skewed_info` below.
        """
        return pulumi.get(self, "skewed_info")

    @property
    @pulumi.getter(name="sortColumns")
    def sort_columns(self) -> Optional[Sequence['outputs.CatalogTableStorageDescriptorSortColumn']]:
        """
        Configuration block for the sort order of each bucket in the table. See `sort_columns` below.
        """
        return pulumi.get(self, "sort_columns")

    @property
    @pulumi.getter(name="storedAsSubDirectories")
    def stored_as_sub_directories(self) -> Optional[bool]:
        """
        Whether the table data is stored in subdirectories.
        """
        return pulumi.get(self, "stored_as_sub_directories")


@pulumi.output_type
class CatalogTableStorageDescriptorColumn(dict):
    def __init__(__self__, *,
                 name: str,
                 comment: Optional[str] = None,
                 parameters: Optional[Mapping[str, str]] = None,
                 type: Optional[str] = None):
        """
        :param str name: Name of the Column.
        :param str comment: Free-form text comment.
        :param Mapping[str, str] parameters: Key-value pairs defining properties associated with the column.
        :param str type: Datatype of data in the Column.
        """
        CatalogTableStorageDescriptorColumn._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            comment=comment,
            parameters=parameters,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             comment: Optional[str] = None,
             parameters: Optional[Mapping[str, str]] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)
        if comment is not None:
            _setter("comment", comment)
        if parameters is not None:
            _setter("parameters", parameters)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the Column.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def comment(self) -> Optional[str]:
        """
        Free-form text comment.
        """
        return pulumi.get(self, "comment")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, str]]:
        """
        Key-value pairs defining properties associated with the column.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Datatype of data in the Column.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class CatalogTableStorageDescriptorSchemaReference(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "schemaVersionNumber":
            suggest = "schema_version_number"
        elif key == "schemaId":
            suggest = "schema_id"
        elif key == "schemaVersionId":
            suggest = "schema_version_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CatalogTableStorageDescriptorSchemaReference. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CatalogTableStorageDescriptorSchemaReference.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CatalogTableStorageDescriptorSchemaReference.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 schema_version_number: int,
                 schema_id: Optional['outputs.CatalogTableStorageDescriptorSchemaReferenceSchemaId'] = None,
                 schema_version_id: Optional[str] = None):
        """
        :param int schema_version_number: Version number of the schema.
        :param 'CatalogTableStorageDescriptorSchemaReferenceSchemaIdArgs' schema_id: Configuration block that contains schema identity fields. Either this or the `schema_version_id` has to be provided. See `schema_id` below.
        :param str schema_version_id: Unique ID assigned to a version of the schema. Either this or the `schema_id` has to be provided.
        """
        CatalogTableStorageDescriptorSchemaReference._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            schema_version_number=schema_version_number,
            schema_id=schema_id,
            schema_version_id=schema_version_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             schema_version_number: Optional[int] = None,
             schema_id: Optional['outputs.CatalogTableStorageDescriptorSchemaReferenceSchemaId'] = None,
             schema_version_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if schema_version_number is None and 'schemaVersionNumber' in kwargs:
            schema_version_number = kwargs['schemaVersionNumber']
        if schema_version_number is None:
            raise TypeError("Missing 'schema_version_number' argument")
        if schema_id is None and 'schemaId' in kwargs:
            schema_id = kwargs['schemaId']
        if schema_version_id is None and 'schemaVersionId' in kwargs:
            schema_version_id = kwargs['schemaVersionId']

        _setter("schema_version_number", schema_version_number)
        if schema_id is not None:
            _setter("schema_id", schema_id)
        if schema_version_id is not None:
            _setter("schema_version_id", schema_version_id)

    @property
    @pulumi.getter(name="schemaVersionNumber")
    def schema_version_number(self) -> int:
        """
        Version number of the schema.
        """
        return pulumi.get(self, "schema_version_number")

    @property
    @pulumi.getter(name="schemaId")
    def schema_id(self) -> Optional['outputs.CatalogTableStorageDescriptorSchemaReferenceSchemaId']:
        """
        Configuration block that contains schema identity fields. Either this or the `schema_version_id` has to be provided. See `schema_id` below.
        """
        return pulumi.get(self, "schema_id")

    @property
    @pulumi.getter(name="schemaVersionId")
    def schema_version_id(self) -> Optional[str]:
        """
        Unique ID assigned to a version of the schema. Either this or the `schema_id` has to be provided.
        """
        return pulumi.get(self, "schema_version_id")


@pulumi.output_type
class CatalogTableStorageDescriptorSchemaReferenceSchemaId(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "registryName":
            suggest = "registry_name"
        elif key == "schemaArn":
            suggest = "schema_arn"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CatalogTableStorageDescriptorSchemaReferenceSchemaId. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CatalogTableStorageDescriptorSchemaReferenceSchemaId.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CatalogTableStorageDescriptorSchemaReferenceSchemaId.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 registry_name: Optional[str] = None,
                 schema_arn: Optional[str] = None,
                 schema_name: Optional[str] = None):
        """
        :param str registry_name: Name of the schema registry that contains the schema. Must be provided when `schema_name` is specified and conflicts with `schema_arn`.
        :param str schema_arn: ARN of the schema. One of `schema_arn` or `schema_name` has to be provided.
        :param str schema_name: Name of the schema. One of `schema_arn` or `schema_name` has to be provided.
        """
        CatalogTableStorageDescriptorSchemaReferenceSchemaId._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            registry_name=registry_name,
            schema_arn=schema_arn,
            schema_name=schema_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             registry_name: Optional[str] = None,
             schema_arn: Optional[str] = None,
             schema_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if registry_name is None and 'registryName' in kwargs:
            registry_name = kwargs['registryName']
        if schema_arn is None and 'schemaArn' in kwargs:
            schema_arn = kwargs['schemaArn']
        if schema_name is None and 'schemaName' in kwargs:
            schema_name = kwargs['schemaName']

        if registry_name is not None:
            _setter("registry_name", registry_name)
        if schema_arn is not None:
            _setter("schema_arn", schema_arn)
        if schema_name is not None:
            _setter("schema_name", schema_name)

    @property
    @pulumi.getter(name="registryName")
    def registry_name(self) -> Optional[str]:
        """
        Name of the schema registry that contains the schema. Must be provided when `schema_name` is specified and conflicts with `schema_arn`.
        """
        return pulumi.get(self, "registry_name")

    @property
    @pulumi.getter(name="schemaArn")
    def schema_arn(self) -> Optional[str]:
        """
        ARN of the schema. One of `schema_arn` or `schema_name` has to be provided.
        """
        return pulumi.get(self, "schema_arn")

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[str]:
        """
        Name of the schema. One of `schema_arn` or `schema_name` has to be provided.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class CatalogTableStorageDescriptorSerDeInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serializationLibrary":
            suggest = "serialization_library"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CatalogTableStorageDescriptorSerDeInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CatalogTableStorageDescriptorSerDeInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CatalogTableStorageDescriptorSerDeInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[str] = None,
                 parameters: Optional[Mapping[str, str]] = None,
                 serialization_library: Optional[str] = None):
        """
        :param str name: Name of the SerDe.
        :param Mapping[str, str] parameters: Map of initialization parameters for the SerDe, in key-value form.
        :param str serialization_library: Usually the class that implements the SerDe. An example is `org.apache.hadoop.hive.serde2.columnar.ColumnarSerDe`.
        """
        CatalogTableStorageDescriptorSerDeInfo._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            parameters=parameters,
            serialization_library=serialization_library,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             parameters: Optional[Mapping[str, str]] = None,
             serialization_library: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if serialization_library is None and 'serializationLibrary' in kwargs:
            serialization_library = kwargs['serializationLibrary']

        if name is not None:
            _setter("name", name)
        if parameters is not None:
            _setter("parameters", parameters)
        if serialization_library is not None:
            _setter("serialization_library", serialization_library)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the SerDe.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, str]]:
        """
        Map of initialization parameters for the SerDe, in key-value form.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter(name="serializationLibrary")
    def serialization_library(self) -> Optional[str]:
        """
        Usually the class that implements the SerDe. An example is `org.apache.hadoop.hive.serde2.columnar.ColumnarSerDe`.
        """
        return pulumi.get(self, "serialization_library")


@pulumi.output_type
class CatalogTableStorageDescriptorSkewedInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "skewedColumnNames":
            suggest = "skewed_column_names"
        elif key == "skewedColumnValueLocationMaps":
            suggest = "skewed_column_value_location_maps"
        elif key == "skewedColumnValues":
            suggest = "skewed_column_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CatalogTableStorageDescriptorSkewedInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CatalogTableStorageDescriptorSkewedInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CatalogTableStorageDescriptorSkewedInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 skewed_column_names: Optional[Sequence[str]] = None,
                 skewed_column_value_location_maps: Optional[Mapping[str, str]] = None,
                 skewed_column_values: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] skewed_column_names: List of names of columns that contain skewed values.
        :param Mapping[str, str] skewed_column_value_location_maps: List of values that appear so frequently as to be considered skewed.
        :param Sequence[str] skewed_column_values: Map of skewed values to the columns that contain them.
        """
        CatalogTableStorageDescriptorSkewedInfo._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            skewed_column_names=skewed_column_names,
            skewed_column_value_location_maps=skewed_column_value_location_maps,
            skewed_column_values=skewed_column_values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             skewed_column_names: Optional[Sequence[str]] = None,
             skewed_column_value_location_maps: Optional[Mapping[str, str]] = None,
             skewed_column_values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if skewed_column_names is None and 'skewedColumnNames' in kwargs:
            skewed_column_names = kwargs['skewedColumnNames']
        if skewed_column_value_location_maps is None and 'skewedColumnValueLocationMaps' in kwargs:
            skewed_column_value_location_maps = kwargs['skewedColumnValueLocationMaps']
        if skewed_column_values is None and 'skewedColumnValues' in kwargs:
            skewed_column_values = kwargs['skewedColumnValues']

        if skewed_column_names is not None:
            _setter("skewed_column_names", skewed_column_names)
        if skewed_column_value_location_maps is not None:
            _setter("skewed_column_value_location_maps", skewed_column_value_location_maps)
        if skewed_column_values is not None:
            _setter("skewed_column_values", skewed_column_values)

    @property
    @pulumi.getter(name="skewedColumnNames")
    def skewed_column_names(self) -> Optional[Sequence[str]]:
        """
        List of names of columns that contain skewed values.
        """
        return pulumi.get(self, "skewed_column_names")

    @property
    @pulumi.getter(name="skewedColumnValueLocationMaps")
    def skewed_column_value_location_maps(self) -> Optional[Mapping[str, str]]:
        """
        List of values that appear so frequently as to be considered skewed.
        """
        return pulumi.get(self, "skewed_column_value_location_maps")

    @property
    @pulumi.getter(name="skewedColumnValues")
    def skewed_column_values(self) -> Optional[Sequence[str]]:
        """
        Map of skewed values to the columns that contain them.
        """
        return pulumi.get(self, "skewed_column_values")


@pulumi.output_type
class CatalogTableStorageDescriptorSortColumn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortOrder":
            suggest = "sort_order"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CatalogTableStorageDescriptorSortColumn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CatalogTableStorageDescriptorSortColumn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CatalogTableStorageDescriptorSortColumn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: str,
                 sort_order: int):
        """
        :param str column: Name of the column.
        :param int sort_order: Whether the column is sorted in ascending (`1`) or descending order (`0`).
        """
        CatalogTableStorageDescriptorSortColumn._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column=column,
            sort_order=sort_order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column: Optional[str] = None,
             sort_order: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if column is None:
            raise TypeError("Missing 'column' argument")
        if sort_order is None and 'sortOrder' in kwargs:
            sort_order = kwargs['sortOrder']
        if sort_order is None:
            raise TypeError("Missing 'sort_order' argument")

        _setter("column", column)
        _setter("sort_order", sort_order)

    @property
    @pulumi.getter
    def column(self) -> str:
        """
        Name of the column.
        """
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="sortOrder")
    def sort_order(self) -> int:
        """
        Whether the column is sorted in ascending (`1`) or descending order (`0`).
        """
        return pulumi.get(self, "sort_order")


@pulumi.output_type
class CatalogTableTargetTable(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "catalogId":
            suggest = "catalog_id"
        elif key == "databaseName":
            suggest = "database_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CatalogTableTargetTable. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CatalogTableTargetTable.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CatalogTableTargetTable.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 catalog_id: str,
                 database_name: str,
                 name: str):
        """
        :param str catalog_id: ID of the Data Catalog in which the table resides.
        :param str database_name: Name of the catalog database that contains the target table.
        :param str name: Name of the target table.
        """
        CatalogTableTargetTable._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            catalog_id=catalog_id,
            database_name=database_name,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             catalog_id: Optional[str] = None,
             database_name: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if catalog_id is None and 'catalogId' in kwargs:
            catalog_id = kwargs['catalogId']
        if catalog_id is None:
            raise TypeError("Missing 'catalog_id' argument")
        if database_name is None and 'databaseName' in kwargs:
            database_name = kwargs['databaseName']
        if database_name is None:
            raise TypeError("Missing 'database_name' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("catalog_id", catalog_id)
        _setter("database_name", database_name)
        _setter("name", name)

    @property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> str:
        """
        ID of the Data Catalog in which the table resides.
        """
        return pulumi.get(self, "catalog_id")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        Name of the catalog database that contains the target table.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the target table.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ClassifierCsvClassifier(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowSingleColumn":
            suggest = "allow_single_column"
        elif key == "containsHeader":
            suggest = "contains_header"
        elif key == "customDatatypeConfigured":
            suggest = "custom_datatype_configured"
        elif key == "customDatatypes":
            suggest = "custom_datatypes"
        elif key == "disableValueTrimming":
            suggest = "disable_value_trimming"
        elif key == "quoteSymbol":
            suggest = "quote_symbol"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClassifierCsvClassifier. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClassifierCsvClassifier.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClassifierCsvClassifier.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_single_column: Optional[bool] = None,
                 contains_header: Optional[str] = None,
                 custom_datatype_configured: Optional[bool] = None,
                 custom_datatypes: Optional[Sequence[str]] = None,
                 delimiter: Optional[str] = None,
                 disable_value_trimming: Optional[bool] = None,
                 headers: Optional[Sequence[str]] = None,
                 quote_symbol: Optional[str] = None):
        """
        :param bool allow_single_column: Enables the processing of files that contain only one column.
        :param str contains_header: Indicates whether the CSV file contains a header. This can be one of "ABSENT", "PRESENT", or "UNKNOWN".
        :param bool custom_datatype_configured: A custom symbol to denote what combines content into a single column value. It must be different from the column delimiter.
        :param Sequence[str] custom_datatypes: A list of supported custom datatypes. Valid values are `BINARY`, `BOOLEAN`, `DATE`, `DECIMAL`, `DOUBLE`, `FLOAT`, `INT`, `LONG`, `SHORT`, `STRING`, `TIMESTAMP`.
        :param str delimiter: The delimiter used in the Csv to separate columns.
        :param bool disable_value_trimming: Specifies whether to trim column values.
        :param Sequence[str] headers: A list of strings representing column names.
        :param str quote_symbol: A custom symbol to denote what combines content into a single column value. It must be different from the column delimiter.
        """
        ClassifierCsvClassifier._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allow_single_column=allow_single_column,
            contains_header=contains_header,
            custom_datatype_configured=custom_datatype_configured,
            custom_datatypes=custom_datatypes,
            delimiter=delimiter,
            disable_value_trimming=disable_value_trimming,
            headers=headers,
            quote_symbol=quote_symbol,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allow_single_column: Optional[bool] = None,
             contains_header: Optional[str] = None,
             custom_datatype_configured: Optional[bool] = None,
             custom_datatypes: Optional[Sequence[str]] = None,
             delimiter: Optional[str] = None,
             disable_value_trimming: Optional[bool] = None,
             headers: Optional[Sequence[str]] = None,
             quote_symbol: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if allow_single_column is None and 'allowSingleColumn' in kwargs:
            allow_single_column = kwargs['allowSingleColumn']
        if contains_header is None and 'containsHeader' in kwargs:
            contains_header = kwargs['containsHeader']
        if custom_datatype_configured is None and 'customDatatypeConfigured' in kwargs:
            custom_datatype_configured = kwargs['customDatatypeConfigured']
        if custom_datatypes is None and 'customDatatypes' in kwargs:
            custom_datatypes = kwargs['customDatatypes']
        if disable_value_trimming is None and 'disableValueTrimming' in kwargs:
            disable_value_trimming = kwargs['disableValueTrimming']
        if quote_symbol is None and 'quoteSymbol' in kwargs:
            quote_symbol = kwargs['quoteSymbol']

        if allow_single_column is not None:
            _setter("allow_single_column", allow_single_column)
        if contains_header is not None:
            _setter("contains_header", contains_header)
        if custom_datatype_configured is not None:
            _setter("custom_datatype_configured", custom_datatype_configured)
        if custom_datatypes is not None:
            _setter("custom_datatypes", custom_datatypes)
        if delimiter is not None:
            _setter("delimiter", delimiter)
        if disable_value_trimming is not None:
            _setter("disable_value_trimming", disable_value_trimming)
        if headers is not None:
            _setter("headers", headers)
        if quote_symbol is not None:
            _setter("quote_symbol", quote_symbol)

    @property
    @pulumi.getter(name="allowSingleColumn")
    def allow_single_column(self) -> Optional[bool]:
        """
        Enables the processing of files that contain only one column.
        """
        return pulumi.get(self, "allow_single_column")

    @property
    @pulumi.getter(name="containsHeader")
    def contains_header(self) -> Optional[str]:
        """
        Indicates whether the CSV file contains a header. This can be one of "ABSENT", "PRESENT", or "UNKNOWN".
        """
        return pulumi.get(self, "contains_header")

    @property
    @pulumi.getter(name="customDatatypeConfigured")
    def custom_datatype_configured(self) -> Optional[bool]:
        """
        A custom symbol to denote what combines content into a single column value. It must be different from the column delimiter.
        """
        return pulumi.get(self, "custom_datatype_configured")

    @property
    @pulumi.getter(name="customDatatypes")
    def custom_datatypes(self) -> Optional[Sequence[str]]:
        """
        A list of supported custom datatypes. Valid values are `BINARY`, `BOOLEAN`, `DATE`, `DECIMAL`, `DOUBLE`, `FLOAT`, `INT`, `LONG`, `SHORT`, `STRING`, `TIMESTAMP`.
        """
        return pulumi.get(self, "custom_datatypes")

    @property
    @pulumi.getter
    def delimiter(self) -> Optional[str]:
        """
        The delimiter used in the Csv to separate columns.
        """
        return pulumi.get(self, "delimiter")

    @property
    @pulumi.getter(name="disableValueTrimming")
    def disable_value_trimming(self) -> Optional[bool]:
        """
        Specifies whether to trim column values.
        """
        return pulumi.get(self, "disable_value_trimming")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence[str]]:
        """
        A list of strings representing column names.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="quoteSymbol")
    def quote_symbol(self) -> Optional[str]:
        """
        A custom symbol to denote what combines content into a single column value. It must be different from the column delimiter.
        """
        return pulumi.get(self, "quote_symbol")


@pulumi.output_type
class ClassifierGrokClassifier(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "grokPattern":
            suggest = "grok_pattern"
        elif key == "customPatterns":
            suggest = "custom_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClassifierGrokClassifier. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClassifierGrokClassifier.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClassifierGrokClassifier.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 classification: str,
                 grok_pattern: str,
                 custom_patterns: Optional[str] = None):
        """
        :param str classification: An identifier of the data format that the classifier matches, such as Twitter, JSON, Omniture logs, Amazon CloudWatch Logs, and so on.
        :param str grok_pattern: The grok pattern used by this classifier.
        :param str custom_patterns: Custom grok patterns used by this classifier.
        """
        ClassifierGrokClassifier._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            classification=classification,
            grok_pattern=grok_pattern,
            custom_patterns=custom_patterns,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             classification: Optional[str] = None,
             grok_pattern: Optional[str] = None,
             custom_patterns: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if classification is None:
            raise TypeError("Missing 'classification' argument")
        if grok_pattern is None and 'grokPattern' in kwargs:
            grok_pattern = kwargs['grokPattern']
        if grok_pattern is None:
            raise TypeError("Missing 'grok_pattern' argument")
        if custom_patterns is None and 'customPatterns' in kwargs:
            custom_patterns = kwargs['customPatterns']

        _setter("classification", classification)
        _setter("grok_pattern", grok_pattern)
        if custom_patterns is not None:
            _setter("custom_patterns", custom_patterns)

    @property
    @pulumi.getter
    def classification(self) -> str:
        """
        An identifier of the data format that the classifier matches, such as Twitter, JSON, Omniture logs, Amazon CloudWatch Logs, and so on.
        """
        return pulumi.get(self, "classification")

    @property
    @pulumi.getter(name="grokPattern")
    def grok_pattern(self) -> str:
        """
        The grok pattern used by this classifier.
        """
        return pulumi.get(self, "grok_pattern")

    @property
    @pulumi.getter(name="customPatterns")
    def custom_patterns(self) -> Optional[str]:
        """
        Custom grok patterns used by this classifier.
        """
        return pulumi.get(self, "custom_patterns")


@pulumi.output_type
class ClassifierJsonClassifier(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jsonPath":
            suggest = "json_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClassifierJsonClassifier. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClassifierJsonClassifier.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClassifierJsonClassifier.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 json_path: str):
        """
        :param str json_path: A `JsonPath` string defining the JSON data for the classifier to classify. AWS Glue supports a subset of `JsonPath`, as described in [Writing JsonPath Custom Classifiers](https://docs.aws.amazon.com/glue/latest/dg/custom-classifier.html#custom-classifier-json).
        """
        ClassifierJsonClassifier._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            json_path=json_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             json_path: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if json_path is None and 'jsonPath' in kwargs:
            json_path = kwargs['jsonPath']
        if json_path is None:
            raise TypeError("Missing 'json_path' argument")

        _setter("json_path", json_path)

    @property
    @pulumi.getter(name="jsonPath")
    def json_path(self) -> str:
        """
        A `JsonPath` string defining the JSON data for the classifier to classify. AWS Glue supports a subset of `JsonPath`, as described in [Writing JsonPath Custom Classifiers](https://docs.aws.amazon.com/glue/latest/dg/custom-classifier.html#custom-classifier-json).
        """
        return pulumi.get(self, "json_path")


@pulumi.output_type
class ClassifierXmlClassifier(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rowTag":
            suggest = "row_tag"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClassifierXmlClassifier. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClassifierXmlClassifier.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClassifierXmlClassifier.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 classification: str,
                 row_tag: str):
        """
        :param str classification: An identifier of the data format that the classifier matches.
        :param str row_tag: The XML tag designating the element that contains each record in an XML document being parsed. Note that this cannot identify a self-closing element (closed by `/>`). An empty row element that contains only attributes can be parsed as long as it ends with a closing tag (for example, `<row item_a="A" item_b="B"></row>` is okay, but `<row item_a="A" item_b="B" />` is not).
        """
        ClassifierXmlClassifier._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            classification=classification,
            row_tag=row_tag,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             classification: Optional[str] = None,
             row_tag: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if classification is None:
            raise TypeError("Missing 'classification' argument")
        if row_tag is None and 'rowTag' in kwargs:
            row_tag = kwargs['rowTag']
        if row_tag is None:
            raise TypeError("Missing 'row_tag' argument")

        _setter("classification", classification)
        _setter("row_tag", row_tag)

    @property
    @pulumi.getter
    def classification(self) -> str:
        """
        An identifier of the data format that the classifier matches.
        """
        return pulumi.get(self, "classification")

    @property
    @pulumi.getter(name="rowTag")
    def row_tag(self) -> str:
        """
        The XML tag designating the element that contains each record in an XML document being parsed. Note that this cannot identify a self-closing element (closed by `/>`). An empty row element that contains only attributes can be parsed as long as it ends with a closing tag (for example, `<row item_a="A" item_b="B"></row>` is okay, but `<row item_a="A" item_b="B" />` is not).
        """
        return pulumi.get(self, "row_tag")


@pulumi.output_type
class ConnectionPhysicalConnectionRequirements(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "securityGroupIdLists":
            suggest = "security_group_id_lists"
        elif key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionPhysicalConnectionRequirements. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionPhysicalConnectionRequirements.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionPhysicalConnectionRequirements.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_zone: Optional[str] = None,
                 security_group_id_lists: Optional[Sequence[str]] = None,
                 subnet_id: Optional[str] = None):
        """
        :param str availability_zone: The availability zone of the connection. This field is redundant and implied by `subnet_id`, but is currently an api requirement.
        :param Sequence[str] security_group_id_lists: The security group ID list used by the connection.
        :param str subnet_id: The subnet ID used by the connection.
        """
        ConnectionPhysicalConnectionRequirements._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability_zone=availability_zone,
            security_group_id_lists=security_group_id_lists,
            subnet_id=subnet_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability_zone: Optional[str] = None,
             security_group_id_lists: Optional[Sequence[str]] = None,
             subnet_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if availability_zone is None and 'availabilityZone' in kwargs:
            availability_zone = kwargs['availabilityZone']
        if security_group_id_lists is None and 'securityGroupIdLists' in kwargs:
            security_group_id_lists = kwargs['securityGroupIdLists']
        if subnet_id is None and 'subnetId' in kwargs:
            subnet_id = kwargs['subnetId']

        if availability_zone is not None:
            _setter("availability_zone", availability_zone)
        if security_group_id_lists is not None:
            _setter("security_group_id_lists", security_group_id_lists)
        if subnet_id is not None:
            _setter("subnet_id", subnet_id)

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[str]:
        """
        The availability zone of the connection. This field is redundant and implied by `subnet_id`, but is currently an api requirement.
        """
        return pulumi.get(self, "availability_zone")

    @property
    @pulumi.getter(name="securityGroupIdLists")
    def security_group_id_lists(self) -> Optional[Sequence[str]]:
        """
        The security group ID list used by the connection.
        """
        return pulumi.get(self, "security_group_id_lists")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        The subnet ID used by the connection.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class CrawlerCatalogTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "connectionName":
            suggest = "connection_name"
        elif key == "dlqEventQueueArn":
            suggest = "dlq_event_queue_arn"
        elif key == "eventQueueArn":
            suggest = "event_queue_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CrawlerCatalogTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CrawlerCatalogTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CrawlerCatalogTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_name: str,
                 tables: Sequence[str],
                 connection_name: Optional[str] = None,
                 dlq_event_queue_arn: Optional[str] = None,
                 event_queue_arn: Optional[str] = None):
        """
        :param str database_name: The name of the Glue database to be synchronized.
        :param Sequence[str] tables: A list of catalog tables to be synchronized.
        :param str connection_name: The name of the connection for an Amazon S3-backed Data Catalog table to be a target of the crawl when using a Catalog connection type paired with a `NETWORK` Connection type.
        :param str dlq_event_queue_arn: A valid Amazon SQS ARN.
               
               > **Note:** `deletion_behavior` of catalog target doesn't support `DEPRECATE_IN_DATABASE`.
               
               > **Note:** `configuration` for catalog target crawlers will have `{ ... "Grouping": { "TableGroupingPolicy": "CombineCompatibleSchemas"} }` by default.
        :param str event_queue_arn: A valid Amazon SQS ARN.
        """
        CrawlerCatalogTarget._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database_name=database_name,
            tables=tables,
            connection_name=connection_name,
            dlq_event_queue_arn=dlq_event_queue_arn,
            event_queue_arn=event_queue_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database_name: Optional[str] = None,
             tables: Optional[Sequence[str]] = None,
             connection_name: Optional[str] = None,
             dlq_event_queue_arn: Optional[str] = None,
             event_queue_arn: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if database_name is None and 'databaseName' in kwargs:
            database_name = kwargs['databaseName']
        if database_name is None:
            raise TypeError("Missing 'database_name' argument")
        if tables is None:
            raise TypeError("Missing 'tables' argument")
        if connection_name is None and 'connectionName' in kwargs:
            connection_name = kwargs['connectionName']
        if dlq_event_queue_arn is None and 'dlqEventQueueArn' in kwargs:
            dlq_event_queue_arn = kwargs['dlqEventQueueArn']
        if event_queue_arn is None and 'eventQueueArn' in kwargs:
            event_queue_arn = kwargs['eventQueueArn']

        _setter("database_name", database_name)
        _setter("tables", tables)
        if connection_name is not None:
            _setter("connection_name", connection_name)
        if dlq_event_queue_arn is not None:
            _setter("dlq_event_queue_arn", dlq_event_queue_arn)
        if event_queue_arn is not None:
            _setter("event_queue_arn", event_queue_arn)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        The name of the Glue database to be synchronized.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter
    def tables(self) -> Sequence[str]:
        """
        A list of catalog tables to be synchronized.
        """
        return pulumi.get(self, "tables")

    @property
    @pulumi.getter(name="connectionName")
    def connection_name(self) -> Optional[str]:
        """
        The name of the connection for an Amazon S3-backed Data Catalog table to be a target of the crawl when using a Catalog connection type paired with a `NETWORK` Connection type.
        """
        return pulumi.get(self, "connection_name")

    @property
    @pulumi.getter(name="dlqEventQueueArn")
    def dlq_event_queue_arn(self) -> Optional[str]:
        """
        A valid Amazon SQS ARN.

        > **Note:** `deletion_behavior` of catalog target doesn't support `DEPRECATE_IN_DATABASE`.

        > **Note:** `configuration` for catalog target crawlers will have `{ ... "Grouping": { "TableGroupingPolicy": "CombineCompatibleSchemas"} }` by default.
        """
        return pulumi.get(self, "dlq_event_queue_arn")

    @property
    @pulumi.getter(name="eventQueueArn")
    def event_queue_arn(self) -> Optional[str]:
        """
        A valid Amazon SQS ARN.
        """
        return pulumi.get(self, "event_queue_arn")


@pulumi.output_type
class CrawlerDeltaTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deltaTables":
            suggest = "delta_tables"
        elif key == "writeManifest":
            suggest = "write_manifest"
        elif key == "connectionName":
            suggest = "connection_name"
        elif key == "createNativeDeltaTable":
            suggest = "create_native_delta_table"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CrawlerDeltaTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CrawlerDeltaTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CrawlerDeltaTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delta_tables: Sequence[str],
                 write_manifest: bool,
                 connection_name: Optional[str] = None,
                 create_native_delta_table: Optional[bool] = None):
        """
        :param Sequence[str] delta_tables: A list of the Amazon S3 paths to the Delta tables.
        :param bool write_manifest: Specifies whether to write the manifest files to the Delta table path.
        :param str connection_name: The name of the connection to use to connect to the Delta table target.
        :param bool create_native_delta_table: Specifies whether the crawler will create native tables, to allow integration with query engines that support querying of the Delta transaction log directly.
        """
        CrawlerDeltaTarget._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            delta_tables=delta_tables,
            write_manifest=write_manifest,
            connection_name=connection_name,
            create_native_delta_table=create_native_delta_table,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             delta_tables: Optional[Sequence[str]] = None,
             write_manifest: Optional[bool] = None,
             connection_name: Optional[str] = None,
             create_native_delta_table: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if delta_tables is None and 'deltaTables' in kwargs:
            delta_tables = kwargs['deltaTables']
        if delta_tables is None:
            raise TypeError("Missing 'delta_tables' argument")
        if write_manifest is None and 'writeManifest' in kwargs:
            write_manifest = kwargs['writeManifest']
        if write_manifest is None:
            raise TypeError("Missing 'write_manifest' argument")
        if connection_name is None and 'connectionName' in kwargs:
            connection_name = kwargs['connectionName']
        if create_native_delta_table is None and 'createNativeDeltaTable' in kwargs:
            create_native_delta_table = kwargs['createNativeDeltaTable']

        _setter("delta_tables", delta_tables)
        _setter("write_manifest", write_manifest)
        if connection_name is not None:
            _setter("connection_name", connection_name)
        if create_native_delta_table is not None:
            _setter("create_native_delta_table", create_native_delta_table)

    @property
    @pulumi.getter(name="deltaTables")
    def delta_tables(self) -> Sequence[str]:
        """
        A list of the Amazon S3 paths to the Delta tables.
        """
        return pulumi.get(self, "delta_tables")

    @property
    @pulumi.getter(name="writeManifest")
    def write_manifest(self) -> bool:
        """
        Specifies whether to write the manifest files to the Delta table path.
        """
        return pulumi.get(self, "write_manifest")

    @property
    @pulumi.getter(name="connectionName")
    def connection_name(self) -> Optional[str]:
        """
        The name of the connection to use to connect to the Delta table target.
        """
        return pulumi.get(self, "connection_name")

    @property
    @pulumi.getter(name="createNativeDeltaTable")
    def create_native_delta_table(self) -> Optional[bool]:
        """
        Specifies whether the crawler will create native tables, to allow integration with query engines that support querying of the Delta transaction log directly.
        """
        return pulumi.get(self, "create_native_delta_table")


@pulumi.output_type
class CrawlerDynamodbTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scanAll":
            suggest = "scan_all"
        elif key == "scanRate":
            suggest = "scan_rate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CrawlerDynamodbTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CrawlerDynamodbTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CrawlerDynamodbTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: str,
                 scan_all: Optional[bool] = None,
                 scan_rate: Optional[float] = None):
        """
        :param str path: The name of the DynamoDB table to crawl.
        :param bool scan_all: Indicates whether to scan all the records, or to sample rows from the table. Scanning all the records can take a long time when the table is not a high throughput table.  defaults to `true`.
        :param float scan_rate: The percentage of the configured read capacity units to use by the AWS Glue crawler. The valid values are null or a value between 0.1 to 1.5.
        """
        CrawlerDynamodbTarget._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            path=path,
            scan_all=scan_all,
            scan_rate=scan_rate,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             path: Optional[str] = None,
             scan_all: Optional[bool] = None,
             scan_rate: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if path is None:
            raise TypeError("Missing 'path' argument")
        if scan_all is None and 'scanAll' in kwargs:
            scan_all = kwargs['scanAll']
        if scan_rate is None and 'scanRate' in kwargs:
            scan_rate = kwargs['scanRate']

        _setter("path", path)
        if scan_all is not None:
            _setter("scan_all", scan_all)
        if scan_rate is not None:
            _setter("scan_rate", scan_rate)

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The name of the DynamoDB table to crawl.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="scanAll")
    def scan_all(self) -> Optional[bool]:
        """
        Indicates whether to scan all the records, or to sample rows from the table. Scanning all the records can take a long time when the table is not a high throughput table.  defaults to `true`.
        """
        return pulumi.get(self, "scan_all")

    @property
    @pulumi.getter(name="scanRate")
    def scan_rate(self) -> Optional[float]:
        """
        The percentage of the configured read capacity units to use by the AWS Glue crawler. The valid values are null or a value between 0.1 to 1.5.
        """
        return pulumi.get(self, "scan_rate")


@pulumi.output_type
class CrawlerHudiTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maximumTraversalDepth":
            suggest = "maximum_traversal_depth"
        elif key == "connectionName":
            suggest = "connection_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CrawlerHudiTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CrawlerHudiTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CrawlerHudiTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 maximum_traversal_depth: int,
                 paths: Sequence[str],
                 connection_name: Optional[str] = None,
                 exclusions: Optional[Sequence[str]] = None):
        """
        :param int maximum_traversal_depth: The maximum depth of Amazon S3 paths that the crawler can traverse to discover the Hudi metadata folder in your Amazon S3 path. Used to limit the crawler run time. Valid values are between `1` and `20`.
        :param Sequence[str] paths: One or more Amazon S3 paths that contains Hudi metadata folders as s3://bucket/prefix.
        :param str connection_name: The name of the connection to use to connect to the Hudi target.
        :param Sequence[str] exclusions: A list of glob patterns used to exclude from the crawl.
        """
        CrawlerHudiTarget._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            maximum_traversal_depth=maximum_traversal_depth,
            paths=paths,
            connection_name=connection_name,
            exclusions=exclusions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             maximum_traversal_depth: Optional[int] = None,
             paths: Optional[Sequence[str]] = None,
             connection_name: Optional[str] = None,
             exclusions: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if maximum_traversal_depth is None and 'maximumTraversalDepth' in kwargs:
            maximum_traversal_depth = kwargs['maximumTraversalDepth']
        if maximum_traversal_depth is None:
            raise TypeError("Missing 'maximum_traversal_depth' argument")
        if paths is None:
            raise TypeError("Missing 'paths' argument")
        if connection_name is None and 'connectionName' in kwargs:
            connection_name = kwargs['connectionName']

        _setter("maximum_traversal_depth", maximum_traversal_depth)
        _setter("paths", paths)
        if connection_name is not None:
            _setter("connection_name", connection_name)
        if exclusions is not None:
            _setter("exclusions", exclusions)

    @property
    @pulumi.getter(name="maximumTraversalDepth")
    def maximum_traversal_depth(self) -> int:
        """
        The maximum depth of Amazon S3 paths that the crawler can traverse to discover the Hudi metadata folder in your Amazon S3 path. Used to limit the crawler run time. Valid values are between `1` and `20`.
        """
        return pulumi.get(self, "maximum_traversal_depth")

    @property
    @pulumi.getter
    def paths(self) -> Sequence[str]:
        """
        One or more Amazon S3 paths that contains Hudi metadata folders as s3://bucket/prefix.
        """
        return pulumi.get(self, "paths")

    @property
    @pulumi.getter(name="connectionName")
    def connection_name(self) -> Optional[str]:
        """
        The name of the connection to use to connect to the Hudi target.
        """
        return pulumi.get(self, "connection_name")

    @property
    @pulumi.getter
    def exclusions(self) -> Optional[Sequence[str]]:
        """
        A list of glob patterns used to exclude from the crawl.
        """
        return pulumi.get(self, "exclusions")


@pulumi.output_type
class CrawlerIcebergTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maximumTraversalDepth":
            suggest = "maximum_traversal_depth"
        elif key == "connectionName":
            suggest = "connection_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CrawlerIcebergTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CrawlerIcebergTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CrawlerIcebergTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 maximum_traversal_depth: int,
                 paths: Sequence[str],
                 connection_name: Optional[str] = None,
                 exclusions: Optional[Sequence[str]] = None):
        """
        :param int maximum_traversal_depth: The maximum depth of Amazon S3 paths that the crawler can traverse to discover the Iceberg metadata folder in your Amazon S3 path. Used to limit the crawler run time. Valid values are between `1` and `20`.
        :param Sequence[str] paths: One or more Amazon S3 paths that contains Iceberg metadata folders as s3://bucket/prefix.
        :param str connection_name: The name of the connection to use to connect to the Iceberg target.
        :param Sequence[str] exclusions: A list of glob patterns used to exclude from the crawl.
        """
        CrawlerIcebergTarget._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            maximum_traversal_depth=maximum_traversal_depth,
            paths=paths,
            connection_name=connection_name,
            exclusions=exclusions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             maximum_traversal_depth: Optional[int] = None,
             paths: Optional[Sequence[str]] = None,
             connection_name: Optional[str] = None,
             exclusions: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if maximum_traversal_depth is None and 'maximumTraversalDepth' in kwargs:
            maximum_traversal_depth = kwargs['maximumTraversalDepth']
        if maximum_traversal_depth is None:
            raise TypeError("Missing 'maximum_traversal_depth' argument")
        if paths is None:
            raise TypeError("Missing 'paths' argument")
        if connection_name is None and 'connectionName' in kwargs:
            connection_name = kwargs['connectionName']

        _setter("maximum_traversal_depth", maximum_traversal_depth)
        _setter("paths", paths)
        if connection_name is not None:
            _setter("connection_name", connection_name)
        if exclusions is not None:
            _setter("exclusions", exclusions)

    @property
    @pulumi.getter(name="maximumTraversalDepth")
    def maximum_traversal_depth(self) -> int:
        """
        The maximum depth of Amazon S3 paths that the crawler can traverse to discover the Iceberg metadata folder in your Amazon S3 path. Used to limit the crawler run time. Valid values are between `1` and `20`.
        """
        return pulumi.get(self, "maximum_traversal_depth")

    @property
    @pulumi.getter
    def paths(self) -> Sequence[str]:
        """
        One or more Amazon S3 paths that contains Iceberg metadata folders as s3://bucket/prefix.
        """
        return pulumi.get(self, "paths")

    @property
    @pulumi.getter(name="connectionName")
    def connection_name(self) -> Optional[str]:
        """
        The name of the connection to use to connect to the Iceberg target.
        """
        return pulumi.get(self, "connection_name")

    @property
    @pulumi.getter
    def exclusions(self) -> Optional[Sequence[str]]:
        """
        A list of glob patterns used to exclude from the crawl.
        """
        return pulumi.get(self, "exclusions")


@pulumi.output_type
class CrawlerJdbcTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionName":
            suggest = "connection_name"
        elif key == "enableAdditionalMetadatas":
            suggest = "enable_additional_metadatas"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CrawlerJdbcTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CrawlerJdbcTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CrawlerJdbcTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_name: str,
                 path: str,
                 enable_additional_metadatas: Optional[Sequence[str]] = None,
                 exclusions: Optional[Sequence[str]] = None):
        """
        :param str connection_name: The name of the connection to use to connect to the JDBC target.
        :param str path: The path of the JDBC target.
        :param Sequence[str] enable_additional_metadatas: Specify a value of `RAWTYPES` or `COMMENTS` to enable additional metadata intable responses. `RAWTYPES` provides the native-level datatype. `COMMENTS` provides comments associated with a column or table in the database.
        :param Sequence[str] exclusions: A list of glob patterns used to exclude from the crawl.
        """
        CrawlerJdbcTarget._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            connection_name=connection_name,
            path=path,
            enable_additional_metadatas=enable_additional_metadatas,
            exclusions=exclusions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             connection_name: Optional[str] = None,
             path: Optional[str] = None,
             enable_additional_metadatas: Optional[Sequence[str]] = None,
             exclusions: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if connection_name is None and 'connectionName' in kwargs:
            connection_name = kwargs['connectionName']
        if connection_name is None:
            raise TypeError("Missing 'connection_name' argument")
        if path is None:
            raise TypeError("Missing 'path' argument")
        if enable_additional_metadatas is None and 'enableAdditionalMetadatas' in kwargs:
            enable_additional_metadatas = kwargs['enableAdditionalMetadatas']

        _setter("connection_name", connection_name)
        _setter("path", path)
        if enable_additional_metadatas is not None:
            _setter("enable_additional_metadatas", enable_additional_metadatas)
        if exclusions is not None:
            _setter("exclusions", exclusions)

    @property
    @pulumi.getter(name="connectionName")
    def connection_name(self) -> str:
        """
        The name of the connection to use to connect to the JDBC target.
        """
        return pulumi.get(self, "connection_name")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The path of the JDBC target.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="enableAdditionalMetadatas")
    def enable_additional_metadatas(self) -> Optional[Sequence[str]]:
        """
        Specify a value of `RAWTYPES` or `COMMENTS` to enable additional metadata intable responses. `RAWTYPES` provides the native-level datatype. `COMMENTS` provides comments associated with a column or table in the database.
        """
        return pulumi.get(self, "enable_additional_metadatas")

    @property
    @pulumi.getter
    def exclusions(self) -> Optional[Sequence[str]]:
        """
        A list of glob patterns used to exclude from the crawl.
        """
        return pulumi.get(self, "exclusions")


@pulumi.output_type
class CrawlerLakeFormationConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountId":
            suggest = "account_id"
        elif key == "useLakeFormationCredentials":
            suggest = "use_lake_formation_credentials"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CrawlerLakeFormationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CrawlerLakeFormationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CrawlerLakeFormationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account_id: Optional[str] = None,
                 use_lake_formation_credentials: Optional[bool] = None):
        """
        :param str account_id: Required for cross account crawls. For same account crawls as the target data, this can omitted.
        :param bool use_lake_formation_credentials: Specifies whether to use Lake Formation credentials for the crawler instead of the IAM role credentials.
        """
        CrawlerLakeFormationConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            account_id=account_id,
            use_lake_formation_credentials=use_lake_formation_credentials,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             account_id: Optional[str] = None,
             use_lake_formation_credentials: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if account_id is None and 'accountId' in kwargs:
            account_id = kwargs['accountId']
        if use_lake_formation_credentials is None and 'useLakeFormationCredentials' in kwargs:
            use_lake_formation_credentials = kwargs['useLakeFormationCredentials']

        if account_id is not None:
            _setter("account_id", account_id)
        if use_lake_formation_credentials is not None:
            _setter("use_lake_formation_credentials", use_lake_formation_credentials)

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> Optional[str]:
        """
        Required for cross account crawls. For same account crawls as the target data, this can omitted.
        """
        return pulumi.get(self, "account_id")

    @property
    @pulumi.getter(name="useLakeFormationCredentials")
    def use_lake_formation_credentials(self) -> Optional[bool]:
        """
        Specifies whether to use Lake Formation credentials for the crawler instead of the IAM role credentials.
        """
        return pulumi.get(self, "use_lake_formation_credentials")


@pulumi.output_type
class CrawlerLineageConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "crawlerLineageSettings":
            suggest = "crawler_lineage_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CrawlerLineageConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CrawlerLineageConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CrawlerLineageConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 crawler_lineage_settings: Optional[str] = None):
        """
        :param str crawler_lineage_settings: Specifies whether data lineage is enabled for the crawler. Valid values are: `ENABLE` and `DISABLE`. Default value is `DISABLE`.
        """
        CrawlerLineageConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            crawler_lineage_settings=crawler_lineage_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             crawler_lineage_settings: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if crawler_lineage_settings is None and 'crawlerLineageSettings' in kwargs:
            crawler_lineage_settings = kwargs['crawlerLineageSettings']

        if crawler_lineage_settings is not None:
            _setter("crawler_lineage_settings", crawler_lineage_settings)

    @property
    @pulumi.getter(name="crawlerLineageSettings")
    def crawler_lineage_settings(self) -> Optional[str]:
        """
        Specifies whether data lineage is enabled for the crawler. Valid values are: `ENABLE` and `DISABLE`. Default value is `DISABLE`.
        """
        return pulumi.get(self, "crawler_lineage_settings")


@pulumi.output_type
class CrawlerMongodbTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionName":
            suggest = "connection_name"
        elif key == "scanAll":
            suggest = "scan_all"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CrawlerMongodbTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CrawlerMongodbTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CrawlerMongodbTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_name: str,
                 path: str,
                 scan_all: Optional[bool] = None):
        """
        :param str connection_name: The name of the connection to use to connect to the Amazon DocumentDB or MongoDB target.
        :param str path: The path of the Amazon DocumentDB or MongoDB target (database/collection).
        :param bool scan_all: Indicates whether to scan all the records, or to sample rows from the table. Scanning all the records can take a long time when the table is not a high throughput table. Default value is `true`.
        """
        CrawlerMongodbTarget._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            connection_name=connection_name,
            path=path,
            scan_all=scan_all,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             connection_name: Optional[str] = None,
             path: Optional[str] = None,
             scan_all: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if connection_name is None and 'connectionName' in kwargs:
            connection_name = kwargs['connectionName']
        if connection_name is None:
            raise TypeError("Missing 'connection_name' argument")
        if path is None:
            raise TypeError("Missing 'path' argument")
        if scan_all is None and 'scanAll' in kwargs:
            scan_all = kwargs['scanAll']

        _setter("connection_name", connection_name)
        _setter("path", path)
        if scan_all is not None:
            _setter("scan_all", scan_all)

    @property
    @pulumi.getter(name="connectionName")
    def connection_name(self) -> str:
        """
        The name of the connection to use to connect to the Amazon DocumentDB or MongoDB target.
        """
        return pulumi.get(self, "connection_name")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The path of the Amazon DocumentDB or MongoDB target (database/collection).
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="scanAll")
    def scan_all(self) -> Optional[bool]:
        """
        Indicates whether to scan all the records, or to sample rows from the table. Scanning all the records can take a long time when the table is not a high throughput table. Default value is `true`.
        """
        return pulumi.get(self, "scan_all")


@pulumi.output_type
class CrawlerRecrawlPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "recrawlBehavior":
            suggest = "recrawl_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CrawlerRecrawlPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CrawlerRecrawlPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CrawlerRecrawlPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 recrawl_behavior: Optional[str] = None):
        """
        :param str recrawl_behavior: Specifies whether to crawl the entire dataset again, crawl only folders that were added since the last crawler run, or crawl what S3 notifies the crawler of via SQS. Valid Values are: `CRAWL_EVENT_MODE`, `CRAWL_EVERYTHING` and `CRAWL_NEW_FOLDERS_ONLY`. Default value is `CRAWL_EVERYTHING`.
        """
        CrawlerRecrawlPolicy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            recrawl_behavior=recrawl_behavior,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             recrawl_behavior: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if recrawl_behavior is None and 'recrawlBehavior' in kwargs:
            recrawl_behavior = kwargs['recrawlBehavior']

        if recrawl_behavior is not None:
            _setter("recrawl_behavior", recrawl_behavior)

    @property
    @pulumi.getter(name="recrawlBehavior")
    def recrawl_behavior(self) -> Optional[str]:
        """
        Specifies whether to crawl the entire dataset again, crawl only folders that were added since the last crawler run, or crawl what S3 notifies the crawler of via SQS. Valid Values are: `CRAWL_EVENT_MODE`, `CRAWL_EVERYTHING` and `CRAWL_NEW_FOLDERS_ONLY`. Default value is `CRAWL_EVERYTHING`.
        """
        return pulumi.get(self, "recrawl_behavior")


@pulumi.output_type
class CrawlerS3Target(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionName":
            suggest = "connection_name"
        elif key == "dlqEventQueueArn":
            suggest = "dlq_event_queue_arn"
        elif key == "eventQueueArn":
            suggest = "event_queue_arn"
        elif key == "sampleSize":
            suggest = "sample_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CrawlerS3Target. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CrawlerS3Target.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CrawlerS3Target.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: str,
                 connection_name: Optional[str] = None,
                 dlq_event_queue_arn: Optional[str] = None,
                 event_queue_arn: Optional[str] = None,
                 exclusions: Optional[Sequence[str]] = None,
                 sample_size: Optional[int] = None):
        """
        :param str path: The name of the DynamoDB table to crawl.
        :param str connection_name: The name of the connection for an Amazon S3-backed Data Catalog table to be a target of the crawl when using a Catalog connection type paired with a `NETWORK` Connection type.
        :param str dlq_event_queue_arn: A valid Amazon SQS ARN.
               
               > **Note:** `deletion_behavior` of catalog target doesn't support `DEPRECATE_IN_DATABASE`.
               
               > **Note:** `configuration` for catalog target crawlers will have `{ ... "Grouping": { "TableGroupingPolicy": "CombineCompatibleSchemas"} }` by default.
        :param str event_queue_arn: A valid Amazon SQS ARN.
        :param Sequence[str] exclusions: A list of glob patterns used to exclude from the crawl.
        :param int sample_size: Sets the number of files in each leaf folder to be crawled when crawling sample files in a dataset. If not set, all the files are crawled. A valid value is an integer between 1 and 249.
        """
        CrawlerS3Target._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            path=path,
            connection_name=connection_name,
            dlq_event_queue_arn=dlq_event_queue_arn,
            event_queue_arn=event_queue_arn,
            exclusions=exclusions,
            sample_size=sample_size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             path: Optional[str] = None,
             connection_name: Optional[str] = None,
             dlq_event_queue_arn: Optional[str] = None,
             event_queue_arn: Optional[str] = None,
             exclusions: Optional[Sequence[str]] = None,
             sample_size: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if path is None:
            raise TypeError("Missing 'path' argument")
        if connection_name is None and 'connectionName' in kwargs:
            connection_name = kwargs['connectionName']
        if dlq_event_queue_arn is None and 'dlqEventQueueArn' in kwargs:
            dlq_event_queue_arn = kwargs['dlqEventQueueArn']
        if event_queue_arn is None and 'eventQueueArn' in kwargs:
            event_queue_arn = kwargs['eventQueueArn']
        if sample_size is None and 'sampleSize' in kwargs:
            sample_size = kwargs['sampleSize']

        _setter("path", path)
        if connection_name is not None:
            _setter("connection_name", connection_name)
        if dlq_event_queue_arn is not None:
            _setter("dlq_event_queue_arn", dlq_event_queue_arn)
        if event_queue_arn is not None:
            _setter("event_queue_arn", event_queue_arn)
        if exclusions is not None:
            _setter("exclusions", exclusions)
        if sample_size is not None:
            _setter("sample_size", sample_size)

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The name of the DynamoDB table to crawl.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="connectionName")
    def connection_name(self) -> Optional[str]:
        """
        The name of the connection for an Amazon S3-backed Data Catalog table to be a target of the crawl when using a Catalog connection type paired with a `NETWORK` Connection type.
        """
        return pulumi.get(self, "connection_name")

    @property
    @pulumi.getter(name="dlqEventQueueArn")
    def dlq_event_queue_arn(self) -> Optional[str]:
        """
        A valid Amazon SQS ARN.

        > **Note:** `deletion_behavior` of catalog target doesn't support `DEPRECATE_IN_DATABASE`.

        > **Note:** `configuration` for catalog target crawlers will have `{ ... "Grouping": { "TableGroupingPolicy": "CombineCompatibleSchemas"} }` by default.
        """
        return pulumi.get(self, "dlq_event_queue_arn")

    @property
    @pulumi.getter(name="eventQueueArn")
    def event_queue_arn(self) -> Optional[str]:
        """
        A valid Amazon SQS ARN.
        """
        return pulumi.get(self, "event_queue_arn")

    @property
    @pulumi.getter
    def exclusions(self) -> Optional[Sequence[str]]:
        """
        A list of glob patterns used to exclude from the crawl.
        """
        return pulumi.get(self, "exclusions")

    @property
    @pulumi.getter(name="sampleSize")
    def sample_size(self) -> Optional[int]:
        """
        Sets the number of files in each leaf folder to be crawled when crawling sample files in a dataset. If not set, all the files are crawled. A valid value is an integer between 1 and 249.
        """
        return pulumi.get(self, "sample_size")


@pulumi.output_type
class CrawlerSchemaChangePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteBehavior":
            suggest = "delete_behavior"
        elif key == "updateBehavior":
            suggest = "update_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CrawlerSchemaChangePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CrawlerSchemaChangePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CrawlerSchemaChangePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delete_behavior: Optional[str] = None,
                 update_behavior: Optional[str] = None):
        """
        :param str delete_behavior: The deletion behavior when the crawler finds a deleted object. Valid values: `LOG`, `DELETE_FROM_DATABASE`, or `DEPRECATE_IN_DATABASE`. Defaults to `DEPRECATE_IN_DATABASE`.
        :param str update_behavior: The update behavior when the crawler finds a changed schema. Valid values: `LOG` or `UPDATE_IN_DATABASE`. Defaults to `UPDATE_IN_DATABASE`.
        """
        CrawlerSchemaChangePolicy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            delete_behavior=delete_behavior,
            update_behavior=update_behavior,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             delete_behavior: Optional[str] = None,
             update_behavior: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if delete_behavior is None and 'deleteBehavior' in kwargs:
            delete_behavior = kwargs['deleteBehavior']
        if update_behavior is None and 'updateBehavior' in kwargs:
            update_behavior = kwargs['updateBehavior']

        if delete_behavior is not None:
            _setter("delete_behavior", delete_behavior)
        if update_behavior is not None:
            _setter("update_behavior", update_behavior)

    @property
    @pulumi.getter(name="deleteBehavior")
    def delete_behavior(self) -> Optional[str]:
        """
        The deletion behavior when the crawler finds a deleted object. Valid values: `LOG`, `DELETE_FROM_DATABASE`, or `DEPRECATE_IN_DATABASE`. Defaults to `DEPRECATE_IN_DATABASE`.
        """
        return pulumi.get(self, "delete_behavior")

    @property
    @pulumi.getter(name="updateBehavior")
    def update_behavior(self) -> Optional[str]:
        """
        The update behavior when the crawler finds a changed schema. Valid values: `LOG` or `UPDATE_IN_DATABASE`. Defaults to `UPDATE_IN_DATABASE`.
        """
        return pulumi.get(self, "update_behavior")


@pulumi.output_type
class DataCatalogEncryptionSettingsDataCatalogEncryptionSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionPasswordEncryption":
            suggest = "connection_password_encryption"
        elif key == "encryptionAtRest":
            suggest = "encryption_at_rest"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataCatalogEncryptionSettingsDataCatalogEncryptionSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataCatalogEncryptionSettingsDataCatalogEncryptionSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataCatalogEncryptionSettingsDataCatalogEncryptionSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_password_encryption: 'outputs.DataCatalogEncryptionSettingsDataCatalogEncryptionSettingsConnectionPasswordEncryption',
                 encryption_at_rest: 'outputs.DataCatalogEncryptionSettingsDataCatalogEncryptionSettingsEncryptionAtRest'):
        """
        :param 'DataCatalogEncryptionSettingsDataCatalogEncryptionSettingsConnectionPasswordEncryptionArgs' connection_password_encryption: When connection password protection is enabled, the Data Catalog uses a customer-provided key to encrypt the password as part of CreateConnection or UpdateConnection and store it in the ENCRYPTED_PASSWORD field in the connection properties. You can enable catalog encryption or only password encryption. see Connection Password Encryption.
        :param 'DataCatalogEncryptionSettingsDataCatalogEncryptionSettingsEncryptionAtRestArgs' encryption_at_rest: Specifies the encryption-at-rest configuration for the Data Catalog. see Encryption At Rest.
        """
        DataCatalogEncryptionSettingsDataCatalogEncryptionSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            connection_password_encryption=connection_password_encryption,
            encryption_at_rest=encryption_at_rest,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             connection_password_encryption: Optional['outputs.DataCatalogEncryptionSettingsDataCatalogEncryptionSettingsConnectionPasswordEncryption'] = None,
             encryption_at_rest: Optional['outputs.DataCatalogEncryptionSettingsDataCatalogEncryptionSettingsEncryptionAtRest'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if connection_password_encryption is None and 'connectionPasswordEncryption' in kwargs:
            connection_password_encryption = kwargs['connectionPasswordEncryption']
        if connection_password_encryption is None:
            raise TypeError("Missing 'connection_password_encryption' argument")
        if encryption_at_rest is None and 'encryptionAtRest' in kwargs:
            encryption_at_rest = kwargs['encryptionAtRest']
        if encryption_at_rest is None:
            raise TypeError("Missing 'encryption_at_rest' argument")

        _setter("connection_password_encryption", connection_password_encryption)
        _setter("encryption_at_rest", encryption_at_rest)

    @property
    @pulumi.getter(name="connectionPasswordEncryption")
    def connection_password_encryption(self) -> 'outputs.DataCatalogEncryptionSettingsDataCatalogEncryptionSettingsConnectionPasswordEncryption':
        """
        When connection password protection is enabled, the Data Catalog uses a customer-provided key to encrypt the password as part of CreateConnection or UpdateConnection and store it in the ENCRYPTED_PASSWORD field in the connection properties. You can enable catalog encryption or only password encryption. see Connection Password Encryption.
        """
        return pulumi.get(self, "connection_password_encryption")

    @property
    @pulumi.getter(name="encryptionAtRest")
    def encryption_at_rest(self) -> 'outputs.DataCatalogEncryptionSettingsDataCatalogEncryptionSettingsEncryptionAtRest':
        """
        Specifies the encryption-at-rest configuration for the Data Catalog. see Encryption At Rest.
        """
        return pulumi.get(self, "encryption_at_rest")


@pulumi.output_type
class DataCatalogEncryptionSettingsDataCatalogEncryptionSettingsConnectionPasswordEncryption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "returnConnectionPasswordEncrypted":
            suggest = "return_connection_password_encrypted"
        elif key == "awsKmsKeyId":
            suggest = "aws_kms_key_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataCatalogEncryptionSettingsDataCatalogEncryptionSettingsConnectionPasswordEncryption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataCatalogEncryptionSettingsDataCatalogEncryptionSettingsConnectionPasswordEncryption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataCatalogEncryptionSettingsDataCatalogEncryptionSettingsConnectionPasswordEncryption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 return_connection_password_encrypted: bool,
                 aws_kms_key_id: Optional[str] = None):
        """
        :param bool return_connection_password_encrypted: When set to `true`, passwords remain encrypted in the responses of GetConnection and GetConnections. This encryption takes effect independently of the catalog encryption.
        :param str aws_kms_key_id: A KMS key ARN that is used to encrypt the connection password. If connection password protection is enabled, the caller of CreateConnection and UpdateConnection needs at least `kms:Encrypt` permission on the specified AWS KMS key, to encrypt passwords before storing them in the Data Catalog.
        """
        DataCatalogEncryptionSettingsDataCatalogEncryptionSettingsConnectionPasswordEncryption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            return_connection_password_encrypted=return_connection_password_encrypted,
            aws_kms_key_id=aws_kms_key_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             return_connection_password_encrypted: Optional[bool] = None,
             aws_kms_key_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if return_connection_password_encrypted is None and 'returnConnectionPasswordEncrypted' in kwargs:
            return_connection_password_encrypted = kwargs['returnConnectionPasswordEncrypted']
        if return_connection_password_encrypted is None:
            raise TypeError("Missing 'return_connection_password_encrypted' argument")
        if aws_kms_key_id is None and 'awsKmsKeyId' in kwargs:
            aws_kms_key_id = kwargs['awsKmsKeyId']

        _setter("return_connection_password_encrypted", return_connection_password_encrypted)
        if aws_kms_key_id is not None:
            _setter("aws_kms_key_id", aws_kms_key_id)

    @property
    @pulumi.getter(name="returnConnectionPasswordEncrypted")
    def return_connection_password_encrypted(self) -> bool:
        """
        When set to `true`, passwords remain encrypted in the responses of GetConnection and GetConnections. This encryption takes effect independently of the catalog encryption.
        """
        return pulumi.get(self, "return_connection_password_encrypted")

    @property
    @pulumi.getter(name="awsKmsKeyId")
    def aws_kms_key_id(self) -> Optional[str]:
        """
        A KMS key ARN that is used to encrypt the connection password. If connection password protection is enabled, the caller of CreateConnection and UpdateConnection needs at least `kms:Encrypt` permission on the specified AWS KMS key, to encrypt passwords before storing them in the Data Catalog.
        """
        return pulumi.get(self, "aws_kms_key_id")


@pulumi.output_type
class DataCatalogEncryptionSettingsDataCatalogEncryptionSettingsEncryptionAtRest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "catalogEncryptionMode":
            suggest = "catalog_encryption_mode"
        elif key == "sseAwsKmsKeyId":
            suggest = "sse_aws_kms_key_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataCatalogEncryptionSettingsDataCatalogEncryptionSettingsEncryptionAtRest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataCatalogEncryptionSettingsDataCatalogEncryptionSettingsEncryptionAtRest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataCatalogEncryptionSettingsDataCatalogEncryptionSettingsEncryptionAtRest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 catalog_encryption_mode: str,
                 sse_aws_kms_key_id: Optional[str] = None):
        """
        :param str catalog_encryption_mode: The encryption-at-rest mode for encrypting Data Catalog data. Valid values are `DISABLED` and `SSE-KMS`.
        :param str sse_aws_kms_key_id: The ARN of the AWS KMS key to use for encryption at rest.
        """
        DataCatalogEncryptionSettingsDataCatalogEncryptionSettingsEncryptionAtRest._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            catalog_encryption_mode=catalog_encryption_mode,
            sse_aws_kms_key_id=sse_aws_kms_key_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             catalog_encryption_mode: Optional[str] = None,
             sse_aws_kms_key_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if catalog_encryption_mode is None and 'catalogEncryptionMode' in kwargs:
            catalog_encryption_mode = kwargs['catalogEncryptionMode']
        if catalog_encryption_mode is None:
            raise TypeError("Missing 'catalog_encryption_mode' argument")
        if sse_aws_kms_key_id is None and 'sseAwsKmsKeyId' in kwargs:
            sse_aws_kms_key_id = kwargs['sseAwsKmsKeyId']

        _setter("catalog_encryption_mode", catalog_encryption_mode)
        if sse_aws_kms_key_id is not None:
            _setter("sse_aws_kms_key_id", sse_aws_kms_key_id)

    @property
    @pulumi.getter(name="catalogEncryptionMode")
    def catalog_encryption_mode(self) -> str:
        """
        The encryption-at-rest mode for encrypting Data Catalog data. Valid values are `DISABLED` and `SSE-KMS`.
        """
        return pulumi.get(self, "catalog_encryption_mode")

    @property
    @pulumi.getter(name="sseAwsKmsKeyId")
    def sse_aws_kms_key_id(self) -> Optional[str]:
        """
        The ARN of the AWS KMS key to use for encryption at rest.
        """
        return pulumi.get(self, "sse_aws_kms_key_id")


@pulumi.output_type
class DataQualityRulesetTargetTable(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "tableName":
            suggest = "table_name"
        elif key == "catalogId":
            suggest = "catalog_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataQualityRulesetTargetTable. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataQualityRulesetTargetTable.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataQualityRulesetTargetTable.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_name: str,
                 table_name: str,
                 catalog_id: Optional[str] = None):
        """
        :param str database_name: Name of the database where the AWS Glue table exists.
        :param str table_name: Name of the AWS Glue table.
        :param str catalog_id: The catalog id where the AWS Glue table exists.
        """
        DataQualityRulesetTargetTable._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database_name=database_name,
            table_name=table_name,
            catalog_id=catalog_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database_name: Optional[str] = None,
             table_name: Optional[str] = None,
             catalog_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if database_name is None and 'databaseName' in kwargs:
            database_name = kwargs['databaseName']
        if database_name is None:
            raise TypeError("Missing 'database_name' argument")
        if table_name is None and 'tableName' in kwargs:
            table_name = kwargs['tableName']
        if table_name is None:
            raise TypeError("Missing 'table_name' argument")
        if catalog_id is None and 'catalogId' in kwargs:
            catalog_id = kwargs['catalogId']

        _setter("database_name", database_name)
        _setter("table_name", table_name)
        if catalog_id is not None:
            _setter("catalog_id", catalog_id)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        Name of the database where the AWS Glue table exists.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> str:
        """
        Name of the AWS Glue table.
        """
        return pulumi.get(self, "table_name")

    @property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> Optional[str]:
        """
        The catalog id where the AWS Glue table exists.
        """
        return pulumi.get(self, "catalog_id")


@pulumi.output_type
class JobCommand(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scriptLocation":
            suggest = "script_location"
        elif key == "pythonVersion":
            suggest = "python_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobCommand. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobCommand.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobCommand.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 script_location: str,
                 name: Optional[str] = None,
                 python_version: Optional[str] = None,
                 runtime: Optional[str] = None):
        """
        :param str script_location: Specifies the S3 path to a script that executes a job.
        :param str name: The name of the job command. Defaults to `glueetl`. Use `pythonshell` for Python Shell Job Type, `glueray` for Ray Job Type, or `gluestreaming` for Streaming Job Type. `max_capacity` needs to be set if `pythonshell` is chosen.
        :param str python_version: The Python version being used to execute a Python shell job. Allowed values are 2, 3 or 3.9. Version 3 refers to Python 3.6.
        :param str runtime: In Ray jobs, runtime is used to specify the versions of Ray, Python and additional libraries available in your environment. This field is not used in other job types. For supported runtime environment values, see [Working with Ray jobs](https://docs.aws.amazon.com/glue/latest/dg/ray-jobs-section.html#author-job-ray-runtimes) in the Glue Developer Guide.
        """
        JobCommand._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            script_location=script_location,
            name=name,
            python_version=python_version,
            runtime=runtime,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             script_location: Optional[str] = None,
             name: Optional[str] = None,
             python_version: Optional[str] = None,
             runtime: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if script_location is None and 'scriptLocation' in kwargs:
            script_location = kwargs['scriptLocation']
        if script_location is None:
            raise TypeError("Missing 'script_location' argument")
        if python_version is None and 'pythonVersion' in kwargs:
            python_version = kwargs['pythonVersion']

        _setter("script_location", script_location)
        if name is not None:
            _setter("name", name)
        if python_version is not None:
            _setter("python_version", python_version)
        if runtime is not None:
            _setter("runtime", runtime)

    @property
    @pulumi.getter(name="scriptLocation")
    def script_location(self) -> str:
        """
        Specifies the S3 path to a script that executes a job.
        """
        return pulumi.get(self, "script_location")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the job command. Defaults to `glueetl`. Use `pythonshell` for Python Shell Job Type, `glueray` for Ray Job Type, or `gluestreaming` for Streaming Job Type. `max_capacity` needs to be set if `pythonshell` is chosen.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="pythonVersion")
    def python_version(self) -> Optional[str]:
        """
        The Python version being used to execute a Python shell job. Allowed values are 2, 3 or 3.9. Version 3 refers to Python 3.6.
        """
        return pulumi.get(self, "python_version")

    @property
    @pulumi.getter
    def runtime(self) -> Optional[str]:
        """
        In Ray jobs, runtime is used to specify the versions of Ray, Python and additional libraries available in your environment. This field is not used in other job types. For supported runtime environment values, see [Working with Ray jobs](https://docs.aws.amazon.com/glue/latest/dg/ray-jobs-section.html#author-job-ray-runtimes) in the Glue Developer Guide.
        """
        return pulumi.get(self, "runtime")


@pulumi.output_type
class JobExecutionProperty(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxConcurrentRuns":
            suggest = "max_concurrent_runs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobExecutionProperty. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobExecutionProperty.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobExecutionProperty.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_concurrent_runs: Optional[int] = None):
        """
        :param int max_concurrent_runs: The maximum number of concurrent runs allowed for a job. The default is 1.
        """
        JobExecutionProperty._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_concurrent_runs=max_concurrent_runs,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_concurrent_runs: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if max_concurrent_runs is None and 'maxConcurrentRuns' in kwargs:
            max_concurrent_runs = kwargs['maxConcurrentRuns']

        if max_concurrent_runs is not None:
            _setter("max_concurrent_runs", max_concurrent_runs)

    @property
    @pulumi.getter(name="maxConcurrentRuns")
    def max_concurrent_runs(self) -> Optional[int]:
        """
        The maximum number of concurrent runs allowed for a job. The default is 1.
        """
        return pulumi.get(self, "max_concurrent_runs")


@pulumi.output_type
class JobNotificationProperty(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "notifyDelayAfter":
            suggest = "notify_delay_after"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobNotificationProperty. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobNotificationProperty.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobNotificationProperty.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 notify_delay_after: Optional[int] = None):
        """
        :param int notify_delay_after: After a job run starts, the number of minutes to wait before sending a job run delay notification.
        """
        JobNotificationProperty._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            notify_delay_after=notify_delay_after,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             notify_delay_after: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if notify_delay_after is None and 'notifyDelayAfter' in kwargs:
            notify_delay_after = kwargs['notifyDelayAfter']

        if notify_delay_after is not None:
            _setter("notify_delay_after", notify_delay_after)

    @property
    @pulumi.getter(name="notifyDelayAfter")
    def notify_delay_after(self) -> Optional[int]:
        """
        After a job run starts, the number of minutes to wait before sending a job run delay notification.
        """
        return pulumi.get(self, "notify_delay_after")


@pulumi.output_type
class MLTransformInputRecordTable(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "tableName":
            suggest = "table_name"
        elif key == "catalogId":
            suggest = "catalog_id"
        elif key == "connectionName":
            suggest = "connection_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MLTransformInputRecordTable. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MLTransformInputRecordTable.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MLTransformInputRecordTable.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_name: str,
                 table_name: str,
                 catalog_id: Optional[str] = None,
                 connection_name: Optional[str] = None):
        """
        :param str database_name: A database name in the AWS Glue Data Catalog.
        :param str table_name: A table name in the AWS Glue Data Catalog.
        :param str catalog_id: A unique identifier for the AWS Glue Data Catalog.
        :param str connection_name: The name of the connection to the AWS Glue Data Catalog.
        """
        MLTransformInputRecordTable._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database_name=database_name,
            table_name=table_name,
            catalog_id=catalog_id,
            connection_name=connection_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database_name: Optional[str] = None,
             table_name: Optional[str] = None,
             catalog_id: Optional[str] = None,
             connection_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if database_name is None and 'databaseName' in kwargs:
            database_name = kwargs['databaseName']
        if database_name is None:
            raise TypeError("Missing 'database_name' argument")
        if table_name is None and 'tableName' in kwargs:
            table_name = kwargs['tableName']
        if table_name is None:
            raise TypeError("Missing 'table_name' argument")
        if catalog_id is None and 'catalogId' in kwargs:
            catalog_id = kwargs['catalogId']
        if connection_name is None and 'connectionName' in kwargs:
            connection_name = kwargs['connectionName']

        _setter("database_name", database_name)
        _setter("table_name", table_name)
        if catalog_id is not None:
            _setter("catalog_id", catalog_id)
        if connection_name is not None:
            _setter("connection_name", connection_name)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        A database name in the AWS Glue Data Catalog.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> str:
        """
        A table name in the AWS Glue Data Catalog.
        """
        return pulumi.get(self, "table_name")

    @property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> Optional[str]:
        """
        A unique identifier for the AWS Glue Data Catalog.
        """
        return pulumi.get(self, "catalog_id")

    @property
    @pulumi.getter(name="connectionName")
    def connection_name(self) -> Optional[str]:
        """
        The name of the connection to the AWS Glue Data Catalog.
        """
        return pulumi.get(self, "connection_name")


@pulumi.output_type
class MLTransformParameters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "findMatchesParameters":
            suggest = "find_matches_parameters"
        elif key == "transformType":
            suggest = "transform_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MLTransformParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MLTransformParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MLTransformParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 find_matches_parameters: 'outputs.MLTransformParametersFindMatchesParameters',
                 transform_type: str):
        """
        :param 'MLTransformParametersFindMatchesParametersArgs' find_matches_parameters: The parameters for the find matches algorithm. see Find Matches Parameters.
        :param str transform_type: The type of machine learning transform. For information about the types of machine learning transforms, see [Creating Machine Learning Transforms](http://docs.aws.amazon.com/glue/latest/dg/add-job-machine-learning-transform.html).
        """
        MLTransformParameters._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            find_matches_parameters=find_matches_parameters,
            transform_type=transform_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             find_matches_parameters: Optional['outputs.MLTransformParametersFindMatchesParameters'] = None,
             transform_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if find_matches_parameters is None and 'findMatchesParameters' in kwargs:
            find_matches_parameters = kwargs['findMatchesParameters']
        if find_matches_parameters is None:
            raise TypeError("Missing 'find_matches_parameters' argument")
        if transform_type is None and 'transformType' in kwargs:
            transform_type = kwargs['transformType']
        if transform_type is None:
            raise TypeError("Missing 'transform_type' argument")

        _setter("find_matches_parameters", find_matches_parameters)
        _setter("transform_type", transform_type)

    @property
    @pulumi.getter(name="findMatchesParameters")
    def find_matches_parameters(self) -> 'outputs.MLTransformParametersFindMatchesParameters':
        """
        The parameters for the find matches algorithm. see Find Matches Parameters.
        """
        return pulumi.get(self, "find_matches_parameters")

    @property
    @pulumi.getter(name="transformType")
    def transform_type(self) -> str:
        """
        The type of machine learning transform. For information about the types of machine learning transforms, see [Creating Machine Learning Transforms](http://docs.aws.amazon.com/glue/latest/dg/add-job-machine-learning-transform.html).
        """
        return pulumi.get(self, "transform_type")


@pulumi.output_type
class MLTransformParametersFindMatchesParameters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accuracyCostTradeOff":
            suggest = "accuracy_cost_trade_off"
        elif key == "enforceProvidedLabels":
            suggest = "enforce_provided_labels"
        elif key == "precisionRecallTradeOff":
            suggest = "precision_recall_trade_off"
        elif key == "primaryKeyColumnName":
            suggest = "primary_key_column_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MLTransformParametersFindMatchesParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MLTransformParametersFindMatchesParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MLTransformParametersFindMatchesParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 accuracy_cost_trade_off: Optional[float] = None,
                 enforce_provided_labels: Optional[bool] = None,
                 precision_recall_trade_off: Optional[float] = None,
                 primary_key_column_name: Optional[str] = None):
        """
        :param float accuracy_cost_trade_off: The value that is selected when tuning your transform for a balance between accuracy and cost.
        :param bool enforce_provided_labels: The value to switch on or off to force the output to match the provided labels from users.
        :param float precision_recall_trade_off: The value selected when tuning your transform for a balance between precision and recall.
        :param str primary_key_column_name: The name of a column that uniquely identifies rows in the source table.
        """
        MLTransformParametersFindMatchesParameters._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            accuracy_cost_trade_off=accuracy_cost_trade_off,
            enforce_provided_labels=enforce_provided_labels,
            precision_recall_trade_off=precision_recall_trade_off,
            primary_key_column_name=primary_key_column_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             accuracy_cost_trade_off: Optional[float] = None,
             enforce_provided_labels: Optional[bool] = None,
             precision_recall_trade_off: Optional[float] = None,
             primary_key_column_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if accuracy_cost_trade_off is None and 'accuracyCostTradeOff' in kwargs:
            accuracy_cost_trade_off = kwargs['accuracyCostTradeOff']
        if enforce_provided_labels is None and 'enforceProvidedLabels' in kwargs:
            enforce_provided_labels = kwargs['enforceProvidedLabels']
        if precision_recall_trade_off is None and 'precisionRecallTradeOff' in kwargs:
            precision_recall_trade_off = kwargs['precisionRecallTradeOff']
        if primary_key_column_name is None and 'primaryKeyColumnName' in kwargs:
            primary_key_column_name = kwargs['primaryKeyColumnName']

        if accuracy_cost_trade_off is not None:
            _setter("accuracy_cost_trade_off", accuracy_cost_trade_off)
        if enforce_provided_labels is not None:
            _setter("enforce_provided_labels", enforce_provided_labels)
        if precision_recall_trade_off is not None:
            _setter("precision_recall_trade_off", precision_recall_trade_off)
        if primary_key_column_name is not None:
            _setter("primary_key_column_name", primary_key_column_name)

    @property
    @pulumi.getter(name="accuracyCostTradeOff")
    def accuracy_cost_trade_off(self) -> Optional[float]:
        """
        The value that is selected when tuning your transform for a balance between accuracy and cost.
        """
        return pulumi.get(self, "accuracy_cost_trade_off")

    @property
    @pulumi.getter(name="enforceProvidedLabels")
    def enforce_provided_labels(self) -> Optional[bool]:
        """
        The value to switch on or off to force the output to match the provided labels from users.
        """
        return pulumi.get(self, "enforce_provided_labels")

    @property
    @pulumi.getter(name="precisionRecallTradeOff")
    def precision_recall_trade_off(self) -> Optional[float]:
        """
        The value selected when tuning your transform for a balance between precision and recall.
        """
        return pulumi.get(self, "precision_recall_trade_off")

    @property
    @pulumi.getter(name="primaryKeyColumnName")
    def primary_key_column_name(self) -> Optional[str]:
        """
        The name of a column that uniquely identifies rows in the source table.
        """
        return pulumi.get(self, "primary_key_column_name")


@pulumi.output_type
class MLTransformSchema(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataType":
            suggest = "data_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MLTransformSchema. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MLTransformSchema.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MLTransformSchema.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_type: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str data_type: The type of data in the column.
        :param str name: The name you assign to this ML Transform. It must be unique in your account.
        """
        MLTransformSchema._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_type=data_type,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_type: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if data_type is None and 'dataType' in kwargs:
            data_type = kwargs['dataType']

        if data_type is not None:
            _setter("data_type", data_type)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[str]:
        """
        The type of data in the column.
        """
        return pulumi.get(self, "data_type")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name you assign to this ML Transform. It must be unique in your account.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class PartitionIndexPartitionIndex(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "indexName":
            suggest = "index_name"
        elif key == "indexStatus":
            suggest = "index_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PartitionIndexPartitionIndex. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PartitionIndexPartitionIndex.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PartitionIndexPartitionIndex.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index_name: Optional[str] = None,
                 index_status: Optional[str] = None,
                 keys: Optional[Sequence[str]] = None):
        """
        :param str index_name: Name of the partition index.
        :param Sequence[str] keys: Keys for the partition index.
        """
        PartitionIndexPartitionIndex._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index_name=index_name,
            index_status=index_status,
            keys=keys,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index_name: Optional[str] = None,
             index_status: Optional[str] = None,
             keys: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if index_name is None and 'indexName' in kwargs:
            index_name = kwargs['indexName']
        if index_status is None and 'indexStatus' in kwargs:
            index_status = kwargs['indexStatus']

        if index_name is not None:
            _setter("index_name", index_name)
        if index_status is not None:
            _setter("index_status", index_status)
        if keys is not None:
            _setter("keys", keys)

    @property
    @pulumi.getter(name="indexName")
    def index_name(self) -> Optional[str]:
        """
        Name of the partition index.
        """
        return pulumi.get(self, "index_name")

    @property
    @pulumi.getter(name="indexStatus")
    def index_status(self) -> Optional[str]:
        return pulumi.get(self, "index_status")

    @property
    @pulumi.getter
    def keys(self) -> Optional[Sequence[str]]:
        """
        Keys for the partition index.
        """
        return pulumi.get(self, "keys")


@pulumi.output_type
class PartitionStorageDescriptor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketColumns":
            suggest = "bucket_columns"
        elif key == "inputFormat":
            suggest = "input_format"
        elif key == "numberOfBuckets":
            suggest = "number_of_buckets"
        elif key == "outputFormat":
            suggest = "output_format"
        elif key == "serDeInfo":
            suggest = "ser_de_info"
        elif key == "skewedInfo":
            suggest = "skewed_info"
        elif key == "sortColumns":
            suggest = "sort_columns"
        elif key == "storedAsSubDirectories":
            suggest = "stored_as_sub_directories"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PartitionStorageDescriptor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PartitionStorageDescriptor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PartitionStorageDescriptor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_columns: Optional[Sequence[str]] = None,
                 columns: Optional[Sequence['outputs.PartitionStorageDescriptorColumn']] = None,
                 compressed: Optional[bool] = None,
                 input_format: Optional[str] = None,
                 location: Optional[str] = None,
                 number_of_buckets: Optional[int] = None,
                 output_format: Optional[str] = None,
                 parameters: Optional[Mapping[str, str]] = None,
                 ser_de_info: Optional['outputs.PartitionStorageDescriptorSerDeInfo'] = None,
                 skewed_info: Optional['outputs.PartitionStorageDescriptorSkewedInfo'] = None,
                 sort_columns: Optional[Sequence['outputs.PartitionStorageDescriptorSortColumn']] = None,
                 stored_as_sub_directories: Optional[bool] = None):
        """
        :param Sequence[str] bucket_columns: A list of reducer grouping columns, clustering columns, and bucketing columns in the table.
        :param Sequence['PartitionStorageDescriptorColumnArgs'] columns: A list of the Columns in the table.
        :param bool compressed: True if the data in the table is compressed, or False if not.
        :param str input_format: The input format: SequenceFileInputFormat (binary), or TextInputFormat, or a custom format.
        :param str location: The physical location of the table. By default this takes the form of the warehouse location, followed by the database location in the warehouse, followed by the table name.
        :param int number_of_buckets: Must be specified if the table contains any dimension columns.
        :param str output_format: The output format: SequenceFileOutputFormat (binary), or IgnoreKeyTextOutputFormat, or a custom format.
        :param Mapping[str, str] parameters: User-supplied properties in key-value form.
        :param 'PartitionStorageDescriptorSerDeInfoArgs' ser_de_info: Serialization/deserialization (SerDe) information.
        :param 'PartitionStorageDescriptorSkewedInfoArgs' skewed_info: Information about values that appear very frequently in a column (skewed values).
        :param Sequence['PartitionStorageDescriptorSortColumnArgs'] sort_columns: A list of Order objects specifying the sort order of each bucket in the table.
        :param bool stored_as_sub_directories: True if the table data is stored in subdirectories, or False if not.
        """
        PartitionStorageDescriptor._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bucket_columns=bucket_columns,
            columns=columns,
            compressed=compressed,
            input_format=input_format,
            location=location,
            number_of_buckets=number_of_buckets,
            output_format=output_format,
            parameters=parameters,
            ser_de_info=ser_de_info,
            skewed_info=skewed_info,
            sort_columns=sort_columns,
            stored_as_sub_directories=stored_as_sub_directories,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bucket_columns: Optional[Sequence[str]] = None,
             columns: Optional[Sequence['outputs.PartitionStorageDescriptorColumn']] = None,
             compressed: Optional[bool] = None,
             input_format: Optional[str] = None,
             location: Optional[str] = None,
             number_of_buckets: Optional[int] = None,
             output_format: Optional[str] = None,
             parameters: Optional[Mapping[str, str]] = None,
             ser_de_info: Optional['outputs.PartitionStorageDescriptorSerDeInfo'] = None,
             skewed_info: Optional['outputs.PartitionStorageDescriptorSkewedInfo'] = None,
             sort_columns: Optional[Sequence['outputs.PartitionStorageDescriptorSortColumn']] = None,
             stored_as_sub_directories: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if bucket_columns is None and 'bucketColumns' in kwargs:
            bucket_columns = kwargs['bucketColumns']
        if input_format is None and 'inputFormat' in kwargs:
            input_format = kwargs['inputFormat']
        if number_of_buckets is None and 'numberOfBuckets' in kwargs:
            number_of_buckets = kwargs['numberOfBuckets']
        if output_format is None and 'outputFormat' in kwargs:
            output_format = kwargs['outputFormat']
        if ser_de_info is None and 'serDeInfo' in kwargs:
            ser_de_info = kwargs['serDeInfo']
        if skewed_info is None and 'skewedInfo' in kwargs:
            skewed_info = kwargs['skewedInfo']
        if sort_columns is None and 'sortColumns' in kwargs:
            sort_columns = kwargs['sortColumns']
        if stored_as_sub_directories is None and 'storedAsSubDirectories' in kwargs:
            stored_as_sub_directories = kwargs['storedAsSubDirectories']

        if bucket_columns is not None:
            _setter("bucket_columns", bucket_columns)
        if columns is not None:
            _setter("columns", columns)
        if compressed is not None:
            _setter("compressed", compressed)
        if input_format is not None:
            _setter("input_format", input_format)
        if location is not None:
            _setter("location", location)
        if number_of_buckets is not None:
            _setter("number_of_buckets", number_of_buckets)
        if output_format is not None:
            _setter("output_format", output_format)
        if parameters is not None:
            _setter("parameters", parameters)
        if ser_de_info is not None:
            _setter("ser_de_info", ser_de_info)
        if skewed_info is not None:
            _setter("skewed_info", skewed_info)
        if sort_columns is not None:
            _setter("sort_columns", sort_columns)
        if stored_as_sub_directories is not None:
            _setter("stored_as_sub_directories", stored_as_sub_directories)

    @property
    @pulumi.getter(name="bucketColumns")
    def bucket_columns(self) -> Optional[Sequence[str]]:
        """
        A list of reducer grouping columns, clustering columns, and bucketing columns in the table.
        """
        return pulumi.get(self, "bucket_columns")

    @property
    @pulumi.getter
    def columns(self) -> Optional[Sequence['outputs.PartitionStorageDescriptorColumn']]:
        """
        A list of the Columns in the table.
        """
        return pulumi.get(self, "columns")

    @property
    @pulumi.getter
    def compressed(self) -> Optional[bool]:
        """
        True if the data in the table is compressed, or False if not.
        """
        return pulumi.get(self, "compressed")

    @property
    @pulumi.getter(name="inputFormat")
    def input_format(self) -> Optional[str]:
        """
        The input format: SequenceFileInputFormat (binary), or TextInputFormat, or a custom format.
        """
        return pulumi.get(self, "input_format")

    @property
    @pulumi.getter
    def location(self) -> Optional[str]:
        """
        The physical location of the table. By default this takes the form of the warehouse location, followed by the database location in the warehouse, followed by the table name.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter(name="numberOfBuckets")
    def number_of_buckets(self) -> Optional[int]:
        """
        Must be specified if the table contains any dimension columns.
        """
        return pulumi.get(self, "number_of_buckets")

    @property
    @pulumi.getter(name="outputFormat")
    def output_format(self) -> Optional[str]:
        """
        The output format: SequenceFileOutputFormat (binary), or IgnoreKeyTextOutputFormat, or a custom format.
        """
        return pulumi.get(self, "output_format")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, str]]:
        """
        User-supplied properties in key-value form.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter(name="serDeInfo")
    def ser_de_info(self) -> Optional['outputs.PartitionStorageDescriptorSerDeInfo']:
        """
        Serialization/deserialization (SerDe) information.
        """
        return pulumi.get(self, "ser_de_info")

    @property
    @pulumi.getter(name="skewedInfo")
    def skewed_info(self) -> Optional['outputs.PartitionStorageDescriptorSkewedInfo']:
        """
        Information about values that appear very frequently in a column (skewed values).
        """
        return pulumi.get(self, "skewed_info")

    @property
    @pulumi.getter(name="sortColumns")
    def sort_columns(self) -> Optional[Sequence['outputs.PartitionStorageDescriptorSortColumn']]:
        """
        A list of Order objects specifying the sort order of each bucket in the table.
        """
        return pulumi.get(self, "sort_columns")

    @property
    @pulumi.getter(name="storedAsSubDirectories")
    def stored_as_sub_directories(self) -> Optional[bool]:
        """
        True if the table data is stored in subdirectories, or False if not.
        """
        return pulumi.get(self, "stored_as_sub_directories")


@pulumi.output_type
class PartitionStorageDescriptorColumn(dict):
    def __init__(__self__, *,
                 name: str,
                 comment: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str name: The name of the Column.
        :param str comment: Free-form text comment.
        :param str type: The datatype of data in the Column.
        """
        PartitionStorageDescriptorColumn._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            comment=comment,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             comment: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)
        if comment is not None:
            _setter("comment", comment)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Column.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def comment(self) -> Optional[str]:
        """
        Free-form text comment.
        """
        return pulumi.get(self, "comment")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The datatype of data in the Column.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class PartitionStorageDescriptorSerDeInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serializationLibrary":
            suggest = "serialization_library"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PartitionStorageDescriptorSerDeInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PartitionStorageDescriptorSerDeInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PartitionStorageDescriptorSerDeInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[str] = None,
                 parameters: Optional[Mapping[str, str]] = None,
                 serialization_library: Optional[str] = None):
        """
        :param str name: Name of the SerDe.
        :param Mapping[str, str] parameters: A map of initialization parameters for the SerDe, in key-value form.
        :param str serialization_library: Usually the class that implements the SerDe. An example is: org.apache.hadoop.hive.serde2.columnar.ColumnarSerDe.
        """
        PartitionStorageDescriptorSerDeInfo._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            parameters=parameters,
            serialization_library=serialization_library,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             parameters: Optional[Mapping[str, str]] = None,
             serialization_library: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if serialization_library is None and 'serializationLibrary' in kwargs:
            serialization_library = kwargs['serializationLibrary']

        if name is not None:
            _setter("name", name)
        if parameters is not None:
            _setter("parameters", parameters)
        if serialization_library is not None:
            _setter("serialization_library", serialization_library)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the SerDe.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, str]]:
        """
        A map of initialization parameters for the SerDe, in key-value form.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter(name="serializationLibrary")
    def serialization_library(self) -> Optional[str]:
        """
        Usually the class that implements the SerDe. An example is: org.apache.hadoop.hive.serde2.columnar.ColumnarSerDe.
        """
        return pulumi.get(self, "serialization_library")


@pulumi.output_type
class PartitionStorageDescriptorSkewedInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "skewedColumnNames":
            suggest = "skewed_column_names"
        elif key == "skewedColumnValueLocationMaps":
            suggest = "skewed_column_value_location_maps"
        elif key == "skewedColumnValues":
            suggest = "skewed_column_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PartitionStorageDescriptorSkewedInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PartitionStorageDescriptorSkewedInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PartitionStorageDescriptorSkewedInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 skewed_column_names: Optional[Sequence[str]] = None,
                 skewed_column_value_location_maps: Optional[Mapping[str, str]] = None,
                 skewed_column_values: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] skewed_column_names: A list of names of columns that contain skewed values.
        :param Mapping[str, str] skewed_column_value_location_maps: A list of values that appear so frequently as to be considered skewed.
        :param Sequence[str] skewed_column_values: A map of skewed values to the columns that contain them.
        """
        PartitionStorageDescriptorSkewedInfo._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            skewed_column_names=skewed_column_names,
            skewed_column_value_location_maps=skewed_column_value_location_maps,
            skewed_column_values=skewed_column_values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             skewed_column_names: Optional[Sequence[str]] = None,
             skewed_column_value_location_maps: Optional[Mapping[str, str]] = None,
             skewed_column_values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if skewed_column_names is None and 'skewedColumnNames' in kwargs:
            skewed_column_names = kwargs['skewedColumnNames']
        if skewed_column_value_location_maps is None and 'skewedColumnValueLocationMaps' in kwargs:
            skewed_column_value_location_maps = kwargs['skewedColumnValueLocationMaps']
        if skewed_column_values is None and 'skewedColumnValues' in kwargs:
            skewed_column_values = kwargs['skewedColumnValues']

        if skewed_column_names is not None:
            _setter("skewed_column_names", skewed_column_names)
        if skewed_column_value_location_maps is not None:
            _setter("skewed_column_value_location_maps", skewed_column_value_location_maps)
        if skewed_column_values is not None:
            _setter("skewed_column_values", skewed_column_values)

    @property
    @pulumi.getter(name="skewedColumnNames")
    def skewed_column_names(self) -> Optional[Sequence[str]]:
        """
        A list of names of columns that contain skewed values.
        """
        return pulumi.get(self, "skewed_column_names")

    @property
    @pulumi.getter(name="skewedColumnValueLocationMaps")
    def skewed_column_value_location_maps(self) -> Optional[Mapping[str, str]]:
        """
        A list of values that appear so frequently as to be considered skewed.
        """
        return pulumi.get(self, "skewed_column_value_location_maps")

    @property
    @pulumi.getter(name="skewedColumnValues")
    def skewed_column_values(self) -> Optional[Sequence[str]]:
        """
        A map of skewed values to the columns that contain them.
        """
        return pulumi.get(self, "skewed_column_values")


@pulumi.output_type
class PartitionStorageDescriptorSortColumn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortOrder":
            suggest = "sort_order"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PartitionStorageDescriptorSortColumn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PartitionStorageDescriptorSortColumn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PartitionStorageDescriptorSortColumn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: str,
                 sort_order: int):
        """
        :param str column: The name of the column.
        :param int sort_order: Indicates that the column is sorted in ascending order (== 1), or in descending order (==0).
        """
        PartitionStorageDescriptorSortColumn._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column=column,
            sort_order=sort_order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column: Optional[str] = None,
             sort_order: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if column is None:
            raise TypeError("Missing 'column' argument")
        if sort_order is None and 'sortOrder' in kwargs:
            sort_order = kwargs['sortOrder']
        if sort_order is None:
            raise TypeError("Missing 'sort_order' argument")

        _setter("column", column)
        _setter("sort_order", sort_order)

    @property
    @pulumi.getter
    def column(self) -> str:
        """
        The name of the column.
        """
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="sortOrder")
    def sort_order(self) -> int:
        """
        Indicates that the column is sorted in ascending order (== 1), or in descending order (==0).
        """
        return pulumi.get(self, "sort_order")


@pulumi.output_type
class SecurityConfigurationEncryptionConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudwatchEncryption":
            suggest = "cloudwatch_encryption"
        elif key == "jobBookmarksEncryption":
            suggest = "job_bookmarks_encryption"
        elif key == "s3Encryption":
            suggest = "s3_encryption"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityConfigurationEncryptionConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityConfigurationEncryptionConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityConfigurationEncryptionConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloudwatch_encryption: 'outputs.SecurityConfigurationEncryptionConfigurationCloudwatchEncryption',
                 job_bookmarks_encryption: 'outputs.SecurityConfigurationEncryptionConfigurationJobBookmarksEncryption',
                 s3_encryption: 'outputs.SecurityConfigurationEncryptionConfigurationS3Encryption'):
        """
        :param 'SecurityConfigurationEncryptionConfigurationS3EncryptionArgs' s3_encryption: A `s3_encryption ` block as described below, which contains encryption configuration for S3 data.
        """
        SecurityConfigurationEncryptionConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloudwatch_encryption=cloudwatch_encryption,
            job_bookmarks_encryption=job_bookmarks_encryption,
            s3_encryption=s3_encryption,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloudwatch_encryption: Optional['outputs.SecurityConfigurationEncryptionConfigurationCloudwatchEncryption'] = None,
             job_bookmarks_encryption: Optional['outputs.SecurityConfigurationEncryptionConfigurationJobBookmarksEncryption'] = None,
             s3_encryption: Optional['outputs.SecurityConfigurationEncryptionConfigurationS3Encryption'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cloudwatch_encryption is None and 'cloudwatchEncryption' in kwargs:
            cloudwatch_encryption = kwargs['cloudwatchEncryption']
        if cloudwatch_encryption is None:
            raise TypeError("Missing 'cloudwatch_encryption' argument")
        if job_bookmarks_encryption is None and 'jobBookmarksEncryption' in kwargs:
            job_bookmarks_encryption = kwargs['jobBookmarksEncryption']
        if job_bookmarks_encryption is None:
            raise TypeError("Missing 'job_bookmarks_encryption' argument")
        if s3_encryption is None and 's3Encryption' in kwargs:
            s3_encryption = kwargs['s3Encryption']
        if s3_encryption is None:
            raise TypeError("Missing 's3_encryption' argument")

        _setter("cloudwatch_encryption", cloudwatch_encryption)
        _setter("job_bookmarks_encryption", job_bookmarks_encryption)
        _setter("s3_encryption", s3_encryption)

    @property
    @pulumi.getter(name="cloudwatchEncryption")
    def cloudwatch_encryption(self) -> 'outputs.SecurityConfigurationEncryptionConfigurationCloudwatchEncryption':
        return pulumi.get(self, "cloudwatch_encryption")

    @property
    @pulumi.getter(name="jobBookmarksEncryption")
    def job_bookmarks_encryption(self) -> 'outputs.SecurityConfigurationEncryptionConfigurationJobBookmarksEncryption':
        return pulumi.get(self, "job_bookmarks_encryption")

    @property
    @pulumi.getter(name="s3Encryption")
    def s3_encryption(self) -> 'outputs.SecurityConfigurationEncryptionConfigurationS3Encryption':
        """
        A `s3_encryption ` block as described below, which contains encryption configuration for S3 data.
        """
        return pulumi.get(self, "s3_encryption")


@pulumi.output_type
class SecurityConfigurationEncryptionConfigurationCloudwatchEncryption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudwatchEncryptionMode":
            suggest = "cloudwatch_encryption_mode"
        elif key == "kmsKeyArn":
            suggest = "kms_key_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityConfigurationEncryptionConfigurationCloudwatchEncryption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityConfigurationEncryptionConfigurationCloudwatchEncryption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityConfigurationEncryptionConfigurationCloudwatchEncryption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloudwatch_encryption_mode: Optional[str] = None,
                 kms_key_arn: Optional[str] = None):
        """
        :param str cloudwatch_encryption_mode: Encryption mode to use for CloudWatch data. Valid values: `DISABLED`, `SSE-KMS`. Default value: `DISABLED`.
        :param str kms_key_arn: Amazon Resource Name (ARN) of the KMS key to be used to encrypt the data.
        """
        SecurityConfigurationEncryptionConfigurationCloudwatchEncryption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloudwatch_encryption_mode=cloudwatch_encryption_mode,
            kms_key_arn=kms_key_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloudwatch_encryption_mode: Optional[str] = None,
             kms_key_arn: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cloudwatch_encryption_mode is None and 'cloudwatchEncryptionMode' in kwargs:
            cloudwatch_encryption_mode = kwargs['cloudwatchEncryptionMode']
        if kms_key_arn is None and 'kmsKeyArn' in kwargs:
            kms_key_arn = kwargs['kmsKeyArn']

        if cloudwatch_encryption_mode is not None:
            _setter("cloudwatch_encryption_mode", cloudwatch_encryption_mode)
        if kms_key_arn is not None:
            _setter("kms_key_arn", kms_key_arn)

    @property
    @pulumi.getter(name="cloudwatchEncryptionMode")
    def cloudwatch_encryption_mode(self) -> Optional[str]:
        """
        Encryption mode to use for CloudWatch data. Valid values: `DISABLED`, `SSE-KMS`. Default value: `DISABLED`.
        """
        return pulumi.get(self, "cloudwatch_encryption_mode")

    @property
    @pulumi.getter(name="kmsKeyArn")
    def kms_key_arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN) of the KMS key to be used to encrypt the data.
        """
        return pulumi.get(self, "kms_key_arn")


@pulumi.output_type
class SecurityConfigurationEncryptionConfigurationJobBookmarksEncryption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jobBookmarksEncryptionMode":
            suggest = "job_bookmarks_encryption_mode"
        elif key == "kmsKeyArn":
            suggest = "kms_key_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityConfigurationEncryptionConfigurationJobBookmarksEncryption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityConfigurationEncryptionConfigurationJobBookmarksEncryption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityConfigurationEncryptionConfigurationJobBookmarksEncryption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 job_bookmarks_encryption_mode: Optional[str] = None,
                 kms_key_arn: Optional[str] = None):
        """
        :param str job_bookmarks_encryption_mode: Encryption mode to use for job bookmarks data. Valid values: `CSE-KMS`, `DISABLED`. Default value: `DISABLED`.
        :param str kms_key_arn: Amazon Resource Name (ARN) of the KMS key to be used to encrypt the data.
        """
        SecurityConfigurationEncryptionConfigurationJobBookmarksEncryption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            job_bookmarks_encryption_mode=job_bookmarks_encryption_mode,
            kms_key_arn=kms_key_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             job_bookmarks_encryption_mode: Optional[str] = None,
             kms_key_arn: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if job_bookmarks_encryption_mode is None and 'jobBookmarksEncryptionMode' in kwargs:
            job_bookmarks_encryption_mode = kwargs['jobBookmarksEncryptionMode']
        if kms_key_arn is None and 'kmsKeyArn' in kwargs:
            kms_key_arn = kwargs['kmsKeyArn']

        if job_bookmarks_encryption_mode is not None:
            _setter("job_bookmarks_encryption_mode", job_bookmarks_encryption_mode)
        if kms_key_arn is not None:
            _setter("kms_key_arn", kms_key_arn)

    @property
    @pulumi.getter(name="jobBookmarksEncryptionMode")
    def job_bookmarks_encryption_mode(self) -> Optional[str]:
        """
        Encryption mode to use for job bookmarks data. Valid values: `CSE-KMS`, `DISABLED`. Default value: `DISABLED`.
        """
        return pulumi.get(self, "job_bookmarks_encryption_mode")

    @property
    @pulumi.getter(name="kmsKeyArn")
    def kms_key_arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN) of the KMS key to be used to encrypt the data.
        """
        return pulumi.get(self, "kms_key_arn")


@pulumi.output_type
class SecurityConfigurationEncryptionConfigurationS3Encryption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kmsKeyArn":
            suggest = "kms_key_arn"
        elif key == "s3EncryptionMode":
            suggest = "s3_encryption_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityConfigurationEncryptionConfigurationS3Encryption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityConfigurationEncryptionConfigurationS3Encryption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityConfigurationEncryptionConfigurationS3Encryption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kms_key_arn: Optional[str] = None,
                 s3_encryption_mode: Optional[str] = None):
        """
        :param str kms_key_arn: Amazon Resource Name (ARN) of the KMS key to be used to encrypt the data.
        :param str s3_encryption_mode: Encryption mode to use for S3 data. Valid values: `DISABLED`, `SSE-KMS`, `SSE-S3`. Default value: `DISABLED`.
        """
        SecurityConfigurationEncryptionConfigurationS3Encryption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            kms_key_arn=kms_key_arn,
            s3_encryption_mode=s3_encryption_mode,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             kms_key_arn: Optional[str] = None,
             s3_encryption_mode: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if kms_key_arn is None and 'kmsKeyArn' in kwargs:
            kms_key_arn = kwargs['kmsKeyArn']
        if s3_encryption_mode is None and 's3EncryptionMode' in kwargs:
            s3_encryption_mode = kwargs['s3EncryptionMode']

        if kms_key_arn is not None:
            _setter("kms_key_arn", kms_key_arn)
        if s3_encryption_mode is not None:
            _setter("s3_encryption_mode", s3_encryption_mode)

    @property
    @pulumi.getter(name="kmsKeyArn")
    def kms_key_arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN) of the KMS key to be used to encrypt the data.
        """
        return pulumi.get(self, "kms_key_arn")

    @property
    @pulumi.getter(name="s3EncryptionMode")
    def s3_encryption_mode(self) -> Optional[str]:
        """
        Encryption mode to use for S3 data. Valid values: `DISABLED`, `SSE-KMS`, `SSE-S3`. Default value: `DISABLED`.
        """
        return pulumi.get(self, "s3_encryption_mode")


@pulumi.output_type
class TriggerAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "crawlerName":
            suggest = "crawler_name"
        elif key == "jobName":
            suggest = "job_name"
        elif key == "notificationProperty":
            suggest = "notification_property"
        elif key == "securityConfiguration":
            suggest = "security_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TriggerAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TriggerAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TriggerAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arguments: Optional[Mapping[str, str]] = None,
                 crawler_name: Optional[str] = None,
                 job_name: Optional[str] = None,
                 notification_property: Optional['outputs.TriggerActionNotificationProperty'] = None,
                 security_configuration: Optional[str] = None,
                 timeout: Optional[int] = None):
        """
        :param Mapping[str, str] arguments: Arguments to be passed to the job. You can specify arguments here that your own job-execution script consumes, as well as arguments that AWS Glue itself consumes.
        :param str crawler_name: The name of the crawler to be executed. Conflicts with `job_name`.
        :param str job_name: The name of a job to be executed. Conflicts with `crawler_name`.
        :param 'TriggerActionNotificationPropertyArgs' notification_property: Specifies configuration properties of a job run notification. See Notification Property details below.
        :param str security_configuration: The name of the Security Configuration structure to be used with this action.
        :param int timeout: The job run timeout in minutes. It overrides the timeout value of the job.
        """
        TriggerAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arguments=arguments,
            crawler_name=crawler_name,
            job_name=job_name,
            notification_property=notification_property,
            security_configuration=security_configuration,
            timeout=timeout,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arguments: Optional[Mapping[str, str]] = None,
             crawler_name: Optional[str] = None,
             job_name: Optional[str] = None,
             notification_property: Optional['outputs.TriggerActionNotificationProperty'] = None,
             security_configuration: Optional[str] = None,
             timeout: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if crawler_name is None and 'crawlerName' in kwargs:
            crawler_name = kwargs['crawlerName']
        if job_name is None and 'jobName' in kwargs:
            job_name = kwargs['jobName']
        if notification_property is None and 'notificationProperty' in kwargs:
            notification_property = kwargs['notificationProperty']
        if security_configuration is None and 'securityConfiguration' in kwargs:
            security_configuration = kwargs['securityConfiguration']

        if arguments is not None:
            _setter("arguments", arguments)
        if crawler_name is not None:
            _setter("crawler_name", crawler_name)
        if job_name is not None:
            _setter("job_name", job_name)
        if notification_property is not None:
            _setter("notification_property", notification_property)
        if security_configuration is not None:
            _setter("security_configuration", security_configuration)
        if timeout is not None:
            _setter("timeout", timeout)

    @property
    @pulumi.getter
    def arguments(self) -> Optional[Mapping[str, str]]:
        """
        Arguments to be passed to the job. You can specify arguments here that your own job-execution script consumes, as well as arguments that AWS Glue itself consumes.
        """
        return pulumi.get(self, "arguments")

    @property
    @pulumi.getter(name="crawlerName")
    def crawler_name(self) -> Optional[str]:
        """
        The name of the crawler to be executed. Conflicts with `job_name`.
        """
        return pulumi.get(self, "crawler_name")

    @property
    @pulumi.getter(name="jobName")
    def job_name(self) -> Optional[str]:
        """
        The name of a job to be executed. Conflicts with `crawler_name`.
        """
        return pulumi.get(self, "job_name")

    @property
    @pulumi.getter(name="notificationProperty")
    def notification_property(self) -> Optional['outputs.TriggerActionNotificationProperty']:
        """
        Specifies configuration properties of a job run notification. See Notification Property details below.
        """
        return pulumi.get(self, "notification_property")

    @property
    @pulumi.getter(name="securityConfiguration")
    def security_configuration(self) -> Optional[str]:
        """
        The name of the Security Configuration structure to be used with this action.
        """
        return pulumi.get(self, "security_configuration")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        """
        The job run timeout in minutes. It overrides the timeout value of the job.
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class TriggerActionNotificationProperty(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "notifyDelayAfter":
            suggest = "notify_delay_after"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TriggerActionNotificationProperty. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TriggerActionNotificationProperty.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TriggerActionNotificationProperty.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 notify_delay_after: Optional[int] = None):
        """
        :param int notify_delay_after: After a job run starts, the number of minutes to wait before sending a job run delay notification.
        """
        TriggerActionNotificationProperty._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            notify_delay_after=notify_delay_after,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             notify_delay_after: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if notify_delay_after is None and 'notifyDelayAfter' in kwargs:
            notify_delay_after = kwargs['notifyDelayAfter']

        if notify_delay_after is not None:
            _setter("notify_delay_after", notify_delay_after)

    @property
    @pulumi.getter(name="notifyDelayAfter")
    def notify_delay_after(self) -> Optional[int]:
        """
        After a job run starts, the number of minutes to wait before sending a job run delay notification.
        """
        return pulumi.get(self, "notify_delay_after")


@pulumi.output_type
class TriggerEventBatchingCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "batchSize":
            suggest = "batch_size"
        elif key == "batchWindow":
            suggest = "batch_window"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TriggerEventBatchingCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TriggerEventBatchingCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TriggerEventBatchingCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 batch_size: int,
                 batch_window: Optional[int] = None):
        """
        :param int batch_size: Number of events that must be received from Amazon EventBridge before EventBridge  event trigger fires.
        :param int batch_window: Window of time in seconds after which EventBridge event trigger fires. Window starts when first event is received. Default value is `900`.
        """
        TriggerEventBatchingCondition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            batch_size=batch_size,
            batch_window=batch_window,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             batch_size: Optional[int] = None,
             batch_window: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if batch_size is None and 'batchSize' in kwargs:
            batch_size = kwargs['batchSize']
        if batch_size is None:
            raise TypeError("Missing 'batch_size' argument")
        if batch_window is None and 'batchWindow' in kwargs:
            batch_window = kwargs['batchWindow']

        _setter("batch_size", batch_size)
        if batch_window is not None:
            _setter("batch_window", batch_window)

    @property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> int:
        """
        Number of events that must be received from Amazon EventBridge before EventBridge  event trigger fires.
        """
        return pulumi.get(self, "batch_size")

    @property
    @pulumi.getter(name="batchWindow")
    def batch_window(self) -> Optional[int]:
        """
        Window of time in seconds after which EventBridge event trigger fires. Window starts when first event is received. Default value is `900`.
        """
        return pulumi.get(self, "batch_window")


@pulumi.output_type
class TriggerPredicate(dict):
    def __init__(__self__, *,
                 conditions: Sequence['outputs.TriggerPredicateCondition'],
                 logical: Optional[str] = None):
        """
        :param Sequence['TriggerPredicateConditionArgs'] conditions: A list of the conditions that determine when the trigger will fire. See Conditions.
        :param str logical: How to handle multiple conditions. Defaults to `AND`. Valid values are `AND` or `ANY`.
        """
        TriggerPredicate._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            conditions=conditions,
            logical=logical,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             conditions: Optional[Sequence['outputs.TriggerPredicateCondition']] = None,
             logical: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if conditions is None:
            raise TypeError("Missing 'conditions' argument")

        _setter("conditions", conditions)
        if logical is not None:
            _setter("logical", logical)

    @property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.TriggerPredicateCondition']:
        """
        A list of the conditions that determine when the trigger will fire. See Conditions.
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def logical(self) -> Optional[str]:
        """
        How to handle multiple conditions. Defaults to `AND`. Valid values are `AND` or `ANY`.
        """
        return pulumi.get(self, "logical")


@pulumi.output_type
class TriggerPredicateCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "crawlState":
            suggest = "crawl_state"
        elif key == "crawlerName":
            suggest = "crawler_name"
        elif key == "jobName":
            suggest = "job_name"
        elif key == "logicalOperator":
            suggest = "logical_operator"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TriggerPredicateCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TriggerPredicateCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TriggerPredicateCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 crawl_state: Optional[str] = None,
                 crawler_name: Optional[str] = None,
                 job_name: Optional[str] = None,
                 logical_operator: Optional[str] = None,
                 state: Optional[str] = None):
        """
        :param str crawl_state: The condition crawl state. Currently, the values supported are `RUNNING`, `SUCCEEDED`, `CANCELLED`, and `FAILED`. If this is specified, `crawler_name` must also be specified. Conflicts with `state`.
        :param str crawler_name: The name of the crawler to watch. If this is specified, `crawl_state` must also be specified. Conflicts with `job_name`.
        :param str job_name: The name of the job to watch. If this is specified, `state` must also be specified. Conflicts with `crawler_name`.
        :param str logical_operator: A logical operator. Defaults to `EQUALS`.
        :param str state: The condition job state. Currently, the values supported are `SUCCEEDED`, `STOPPED`, `TIMEOUT` and `FAILED`. If this is specified, `job_name` must also be specified. Conflicts with `crawler_state`.
        """
        TriggerPredicateCondition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            crawl_state=crawl_state,
            crawler_name=crawler_name,
            job_name=job_name,
            logical_operator=logical_operator,
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             crawl_state: Optional[str] = None,
             crawler_name: Optional[str] = None,
             job_name: Optional[str] = None,
             logical_operator: Optional[str] = None,
             state: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if crawl_state is None and 'crawlState' in kwargs:
            crawl_state = kwargs['crawlState']
        if crawler_name is None and 'crawlerName' in kwargs:
            crawler_name = kwargs['crawlerName']
        if job_name is None and 'jobName' in kwargs:
            job_name = kwargs['jobName']
        if logical_operator is None and 'logicalOperator' in kwargs:
            logical_operator = kwargs['logicalOperator']

        if crawl_state is not None:
            _setter("crawl_state", crawl_state)
        if crawler_name is not None:
            _setter("crawler_name", crawler_name)
        if job_name is not None:
            _setter("job_name", job_name)
        if logical_operator is not None:
            _setter("logical_operator", logical_operator)
        if state is not None:
            _setter("state", state)

    @property
    @pulumi.getter(name="crawlState")
    def crawl_state(self) -> Optional[str]:
        """
        The condition crawl state. Currently, the values supported are `RUNNING`, `SUCCEEDED`, `CANCELLED`, and `FAILED`. If this is specified, `crawler_name` must also be specified. Conflicts with `state`.
        """
        return pulumi.get(self, "crawl_state")

    @property
    @pulumi.getter(name="crawlerName")
    def crawler_name(self) -> Optional[str]:
        """
        The name of the crawler to watch. If this is specified, `crawl_state` must also be specified. Conflicts with `job_name`.
        """
        return pulumi.get(self, "crawler_name")

    @property
    @pulumi.getter(name="jobName")
    def job_name(self) -> Optional[str]:
        """
        The name of the job to watch. If this is specified, `state` must also be specified. Conflicts with `crawler_name`.
        """
        return pulumi.get(self, "job_name")

    @property
    @pulumi.getter(name="logicalOperator")
    def logical_operator(self) -> Optional[str]:
        """
        A logical operator. Defaults to `EQUALS`.
        """
        return pulumi.get(self, "logical_operator")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        The condition job state. Currently, the values supported are `SUCCEEDED`, `STOPPED`, `TIMEOUT` and `FAILED`. If this is specified, `job_name` must also be specified. Conflicts with `crawler_state`.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class UserDefinedFunctionResourceUri(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceType":
            suggest = "resource_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserDefinedFunctionResourceUri. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserDefinedFunctionResourceUri.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserDefinedFunctionResourceUri.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_type: str,
                 uri: str):
        """
        :param str resource_type: The type of the resource. can be one of `JAR`, `FILE`, and `ARCHIVE`.
        :param str uri: The URI for accessing the resource.
        """
        UserDefinedFunctionResourceUri._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            resource_type=resource_type,
            uri=uri,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             resource_type: Optional[str] = None,
             uri: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if resource_type is None and 'resourceType' in kwargs:
            resource_type = kwargs['resourceType']
        if resource_type is None:
            raise TypeError("Missing 'resource_type' argument")
        if uri is None:
            raise TypeError("Missing 'uri' argument")

        _setter("resource_type", resource_type)
        _setter("uri", uri)

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> str:
        """
        The type of the resource. can be one of `JAR`, `FILE`, and `ARCHIVE`.
        """
        return pulumi.get(self, "resource_type")

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        The URI for accessing the resource.
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class GetCatalogTablePartitionIndexResult(dict):
    def __init__(__self__, *,
                 index_name: str,
                 index_status: str,
                 keys: Sequence[str]):
        """
        :param str index_name: Name of the partition index.
        :param Sequence[str] keys: Keys for the partition index.
        """
        GetCatalogTablePartitionIndexResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index_name=index_name,
            index_status=index_status,
            keys=keys,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index_name: Optional[str] = None,
             index_status: Optional[str] = None,
             keys: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if index_name is None and 'indexName' in kwargs:
            index_name = kwargs['indexName']
        if index_name is None:
            raise TypeError("Missing 'index_name' argument")
        if index_status is None and 'indexStatus' in kwargs:
            index_status = kwargs['indexStatus']
        if index_status is None:
            raise TypeError("Missing 'index_status' argument")
        if keys is None:
            raise TypeError("Missing 'keys' argument")

        _setter("index_name", index_name)
        _setter("index_status", index_status)
        _setter("keys", keys)

    @property
    @pulumi.getter(name="indexName")
    def index_name(self) -> str:
        """
        Name of the partition index.
        """
        return pulumi.get(self, "index_name")

    @property
    @pulumi.getter(name="indexStatus")
    def index_status(self) -> str:
        return pulumi.get(self, "index_status")

    @property
    @pulumi.getter
    def keys(self) -> Sequence[str]:
        """
        Keys for the partition index.
        """
        return pulumi.get(self, "keys")


@pulumi.output_type
class GetCatalogTablePartitionKeyResult(dict):
    def __init__(__self__, *,
                 comment: str,
                 name: str,
                 type: str):
        """
        :param str comment: Free-form text comment.
        :param str name: Name of the table.
        :param str type: Datatype of data in the Column.
        """
        GetCatalogTablePartitionKeyResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            comment=comment,
            name=name,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             comment: Optional[str] = None,
             name: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if comment is None:
            raise TypeError("Missing 'comment' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("comment", comment)
        _setter("name", name)
        _setter("type", type)

    @property
    @pulumi.getter
    def comment(self) -> str:
        """
        Free-form text comment.
        """
        return pulumi.get(self, "comment")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the table.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Datatype of data in the Column.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetCatalogTableStorageDescriptorResult(dict):
    def __init__(__self__, *,
                 bucket_columns: Sequence[str],
                 columns: Sequence['outputs.GetCatalogTableStorageDescriptorColumnResult'],
                 compressed: bool,
                 input_format: str,
                 location: str,
                 number_of_buckets: int,
                 output_format: str,
                 parameters: Mapping[str, str],
                 schema_references: Sequence['outputs.GetCatalogTableStorageDescriptorSchemaReferenceResult'],
                 ser_de_infos: Sequence['outputs.GetCatalogTableStorageDescriptorSerDeInfoResult'],
                 skewed_infos: Sequence['outputs.GetCatalogTableStorageDescriptorSkewedInfoResult'],
                 sort_columns: Sequence['outputs.GetCatalogTableStorageDescriptorSortColumnResult'],
                 stored_as_sub_directories: bool):
        """
        :param Sequence[str] bucket_columns: List of reducer grouping columns, clustering columns, and bucketing columns in the table.
        :param Sequence['GetCatalogTableStorageDescriptorColumnArgs'] columns: Configuration block for columns in the table. See `columns` below.
        :param bool compressed: Whether the data in the table is compressed.
        :param str input_format: Input format: SequenceFileInputFormat (binary), or TextInputFormat, or a custom format.
        :param str location: Physical location of the table. By default, this takes the form of the warehouse location, followed by the database location in the warehouse, followed by the table name.
        :param int number_of_buckets: Is if the table contains any dimension columns.
        :param str output_format: Output format: SequenceFileOutputFormat (binary), or IgnoreKeyTextOutputFormat, or a custom format.
        :param Mapping[str, str] parameters: Map of initialization parameters for the SerDe, in key-value form.
        :param Sequence['GetCatalogTableStorageDescriptorSchemaReferenceArgs'] schema_references: Object that references a schema stored in the AWS Glue Schema Registry. See `schema_reference` below.
        :param Sequence['GetCatalogTableStorageDescriptorSerDeInfoArgs'] ser_de_infos: Configuration block for serialization and deserialization ("SerDe") information. See `ser_de_info` below.
        :param Sequence['GetCatalogTableStorageDescriptorSkewedInfoArgs'] skewed_infos: Configuration block with information about values that appear very frequently in a column (skewed values). See `skewed_info` below.
        :param Sequence['GetCatalogTableStorageDescriptorSortColumnArgs'] sort_columns: Configuration block for the sort order of each bucket in the table. See `sort_columns` below.
        :param bool stored_as_sub_directories: Whether the table data is stored in subdirectories.
        """
        GetCatalogTableStorageDescriptorResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bucket_columns=bucket_columns,
            columns=columns,
            compressed=compressed,
            input_format=input_format,
            location=location,
            number_of_buckets=number_of_buckets,
            output_format=output_format,
            parameters=parameters,
            schema_references=schema_references,
            ser_de_infos=ser_de_infos,
            skewed_infos=skewed_infos,
            sort_columns=sort_columns,
            stored_as_sub_directories=stored_as_sub_directories,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bucket_columns: Optional[Sequence[str]] = None,
             columns: Optional[Sequence['outputs.GetCatalogTableStorageDescriptorColumnResult']] = None,
             compressed: Optional[bool] = None,
             input_format: Optional[str] = None,
             location: Optional[str] = None,
             number_of_buckets: Optional[int] = None,
             output_format: Optional[str] = None,
             parameters: Optional[Mapping[str, str]] = None,
             schema_references: Optional[Sequence['outputs.GetCatalogTableStorageDescriptorSchemaReferenceResult']] = None,
             ser_de_infos: Optional[Sequence['outputs.GetCatalogTableStorageDescriptorSerDeInfoResult']] = None,
             skewed_infos: Optional[Sequence['outputs.GetCatalogTableStorageDescriptorSkewedInfoResult']] = None,
             sort_columns: Optional[Sequence['outputs.GetCatalogTableStorageDescriptorSortColumnResult']] = None,
             stored_as_sub_directories: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if bucket_columns is None and 'bucketColumns' in kwargs:
            bucket_columns = kwargs['bucketColumns']
        if bucket_columns is None:
            raise TypeError("Missing 'bucket_columns' argument")
        if columns is None:
            raise TypeError("Missing 'columns' argument")
        if compressed is None:
            raise TypeError("Missing 'compressed' argument")
        if input_format is None and 'inputFormat' in kwargs:
            input_format = kwargs['inputFormat']
        if input_format is None:
            raise TypeError("Missing 'input_format' argument")
        if location is None:
            raise TypeError("Missing 'location' argument")
        if number_of_buckets is None and 'numberOfBuckets' in kwargs:
            number_of_buckets = kwargs['numberOfBuckets']
        if number_of_buckets is None:
            raise TypeError("Missing 'number_of_buckets' argument")
        if output_format is None and 'outputFormat' in kwargs:
            output_format = kwargs['outputFormat']
        if output_format is None:
            raise TypeError("Missing 'output_format' argument")
        if parameters is None:
            raise TypeError("Missing 'parameters' argument")
        if schema_references is None and 'schemaReferences' in kwargs:
            schema_references = kwargs['schemaReferences']
        if schema_references is None:
            raise TypeError("Missing 'schema_references' argument")
        if ser_de_infos is None and 'serDeInfos' in kwargs:
            ser_de_infos = kwargs['serDeInfos']
        if ser_de_infos is None:
            raise TypeError("Missing 'ser_de_infos' argument")
        if skewed_infos is None and 'skewedInfos' in kwargs:
            skewed_infos = kwargs['skewedInfos']
        if skewed_infos is None:
            raise TypeError("Missing 'skewed_infos' argument")
        if sort_columns is None and 'sortColumns' in kwargs:
            sort_columns = kwargs['sortColumns']
        if sort_columns is None:
            raise TypeError("Missing 'sort_columns' argument")
        if stored_as_sub_directories is None and 'storedAsSubDirectories' in kwargs:
            stored_as_sub_directories = kwargs['storedAsSubDirectories']
        if stored_as_sub_directories is None:
            raise TypeError("Missing 'stored_as_sub_directories' argument")

        _setter("bucket_columns", bucket_columns)
        _setter("columns", columns)
        _setter("compressed", compressed)
        _setter("input_format", input_format)
        _setter("location", location)
        _setter("number_of_buckets", number_of_buckets)
        _setter("output_format", output_format)
        _setter("parameters", parameters)
        _setter("schema_references", schema_references)
        _setter("ser_de_infos", ser_de_infos)
        _setter("skewed_infos", skewed_infos)
        _setter("sort_columns", sort_columns)
        _setter("stored_as_sub_directories", stored_as_sub_directories)

    @property
    @pulumi.getter(name="bucketColumns")
    def bucket_columns(self) -> Sequence[str]:
        """
        List of reducer grouping columns, clustering columns, and bucketing columns in the table.
        """
        return pulumi.get(self, "bucket_columns")

    @property
    @pulumi.getter
    def columns(self) -> Sequence['outputs.GetCatalogTableStorageDescriptorColumnResult']:
        """
        Configuration block for columns in the table. See `columns` below.
        """
        return pulumi.get(self, "columns")

    @property
    @pulumi.getter
    def compressed(self) -> bool:
        """
        Whether the data in the table is compressed.
        """
        return pulumi.get(self, "compressed")

    @property
    @pulumi.getter(name="inputFormat")
    def input_format(self) -> str:
        """
        Input format: SequenceFileInputFormat (binary), or TextInputFormat, or a custom format.
        """
        return pulumi.get(self, "input_format")

    @property
    @pulumi.getter
    def location(self) -> str:
        """
        Physical location of the table. By default, this takes the form of the warehouse location, followed by the database location in the warehouse, followed by the table name.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter(name="numberOfBuckets")
    def number_of_buckets(self) -> int:
        """
        Is if the table contains any dimension columns.
        """
        return pulumi.get(self, "number_of_buckets")

    @property
    @pulumi.getter(name="outputFormat")
    def output_format(self) -> str:
        """
        Output format: SequenceFileOutputFormat (binary), or IgnoreKeyTextOutputFormat, or a custom format.
        """
        return pulumi.get(self, "output_format")

    @property
    @pulumi.getter
    def parameters(self) -> Mapping[str, str]:
        """
        Map of initialization parameters for the SerDe, in key-value form.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter(name="schemaReferences")
    def schema_references(self) -> Sequence['outputs.GetCatalogTableStorageDescriptorSchemaReferenceResult']:
        """
        Object that references a schema stored in the AWS Glue Schema Registry. See `schema_reference` below.
        """
        return pulumi.get(self, "schema_references")

    @property
    @pulumi.getter(name="serDeInfos")
    def ser_de_infos(self) -> Sequence['outputs.GetCatalogTableStorageDescriptorSerDeInfoResult']:
        """
        Configuration block for serialization and deserialization ("SerDe") information. See `ser_de_info` below.
        """
        return pulumi.get(self, "ser_de_infos")

    @property
    @pulumi.getter(name="skewedInfos")
    def skewed_infos(self) -> Sequence['outputs.GetCatalogTableStorageDescriptorSkewedInfoResult']:
        """
        Configuration block with information about values that appear very frequently in a column (skewed values). See `skewed_info` below.
        """
        return pulumi.get(self, "skewed_infos")

    @property
    @pulumi.getter(name="sortColumns")
    def sort_columns(self) -> Sequence['outputs.GetCatalogTableStorageDescriptorSortColumnResult']:
        """
        Configuration block for the sort order of each bucket in the table. See `sort_columns` below.
        """
        return pulumi.get(self, "sort_columns")

    @property
    @pulumi.getter(name="storedAsSubDirectories")
    def stored_as_sub_directories(self) -> bool:
        """
        Whether the table data is stored in subdirectories.
        """
        return pulumi.get(self, "stored_as_sub_directories")


@pulumi.output_type
class GetCatalogTableStorageDescriptorColumnResult(dict):
    def __init__(__self__, *,
                 comment: str,
                 name: str,
                 parameters: Mapping[str, str],
                 type: str):
        """
        :param str comment: Free-form text comment.
        :param str name: Name of the table.
        :param Mapping[str, str] parameters: Map of initialization parameters for the SerDe, in key-value form.
        :param str type: Datatype of data in the Column.
        """
        GetCatalogTableStorageDescriptorColumnResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            comment=comment,
            name=name,
            parameters=parameters,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             comment: Optional[str] = None,
             name: Optional[str] = None,
             parameters: Optional[Mapping[str, str]] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if comment is None:
            raise TypeError("Missing 'comment' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if parameters is None:
            raise TypeError("Missing 'parameters' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("comment", comment)
        _setter("name", name)
        _setter("parameters", parameters)
        _setter("type", type)

    @property
    @pulumi.getter
    def comment(self) -> str:
        """
        Free-form text comment.
        """
        return pulumi.get(self, "comment")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the table.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> Mapping[str, str]:
        """
        Map of initialization parameters for the SerDe, in key-value form.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Datatype of data in the Column.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetCatalogTableStorageDescriptorSchemaReferenceResult(dict):
    def __init__(__self__, *,
                 schema_ids: Sequence['outputs.GetCatalogTableStorageDescriptorSchemaReferenceSchemaIdResult'],
                 schema_version_id: str,
                 schema_version_number: int):
        """
        :param Sequence['GetCatalogTableStorageDescriptorSchemaReferenceSchemaIdArgs'] schema_ids: Configuration block that contains schema identity fields. See `schema_id` below.
        :param str schema_version_id: Unique ID assigned to a version of the schema.
        :param int schema_version_number: Version number of the schema.
        """
        GetCatalogTableStorageDescriptorSchemaReferenceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            schema_ids=schema_ids,
            schema_version_id=schema_version_id,
            schema_version_number=schema_version_number,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             schema_ids: Optional[Sequence['outputs.GetCatalogTableStorageDescriptorSchemaReferenceSchemaIdResult']] = None,
             schema_version_id: Optional[str] = None,
             schema_version_number: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if schema_ids is None and 'schemaIds' in kwargs:
            schema_ids = kwargs['schemaIds']
        if schema_ids is None:
            raise TypeError("Missing 'schema_ids' argument")
        if schema_version_id is None and 'schemaVersionId' in kwargs:
            schema_version_id = kwargs['schemaVersionId']
        if schema_version_id is None:
            raise TypeError("Missing 'schema_version_id' argument")
        if schema_version_number is None and 'schemaVersionNumber' in kwargs:
            schema_version_number = kwargs['schemaVersionNumber']
        if schema_version_number is None:
            raise TypeError("Missing 'schema_version_number' argument")

        _setter("schema_ids", schema_ids)
        _setter("schema_version_id", schema_version_id)
        _setter("schema_version_number", schema_version_number)

    @property
    @pulumi.getter(name="schemaIds")
    def schema_ids(self) -> Sequence['outputs.GetCatalogTableStorageDescriptorSchemaReferenceSchemaIdResult']:
        """
        Configuration block that contains schema identity fields. See `schema_id` below.
        """
        return pulumi.get(self, "schema_ids")

    @property
    @pulumi.getter(name="schemaVersionId")
    def schema_version_id(self) -> str:
        """
        Unique ID assigned to a version of the schema.
        """
        return pulumi.get(self, "schema_version_id")

    @property
    @pulumi.getter(name="schemaVersionNumber")
    def schema_version_number(self) -> int:
        """
        Version number of the schema.
        """
        return pulumi.get(self, "schema_version_number")


@pulumi.output_type
class GetCatalogTableStorageDescriptorSchemaReferenceSchemaIdResult(dict):
    def __init__(__self__, *,
                 registry_name: str,
                 schema_arn: str,
                 schema_name: str):
        """
        :param str registry_name: Name of the schema registry that contains the schema.
        :param str schema_arn: ARN of the schema.
        :param str schema_name: Name of the schema.
        """
        GetCatalogTableStorageDescriptorSchemaReferenceSchemaIdResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            registry_name=registry_name,
            schema_arn=schema_arn,
            schema_name=schema_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             registry_name: Optional[str] = None,
             schema_arn: Optional[str] = None,
             schema_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if registry_name is None and 'registryName' in kwargs:
            registry_name = kwargs['registryName']
        if registry_name is None:
            raise TypeError("Missing 'registry_name' argument")
        if schema_arn is None and 'schemaArn' in kwargs:
            schema_arn = kwargs['schemaArn']
        if schema_arn is None:
            raise TypeError("Missing 'schema_arn' argument")
        if schema_name is None and 'schemaName' in kwargs:
            schema_name = kwargs['schemaName']
        if schema_name is None:
            raise TypeError("Missing 'schema_name' argument")

        _setter("registry_name", registry_name)
        _setter("schema_arn", schema_arn)
        _setter("schema_name", schema_name)

    @property
    @pulumi.getter(name="registryName")
    def registry_name(self) -> str:
        """
        Name of the schema registry that contains the schema.
        """
        return pulumi.get(self, "registry_name")

    @property
    @pulumi.getter(name="schemaArn")
    def schema_arn(self) -> str:
        """
        ARN of the schema.
        """
        return pulumi.get(self, "schema_arn")

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> str:
        """
        Name of the schema.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class GetCatalogTableStorageDescriptorSerDeInfoResult(dict):
    def __init__(__self__, *,
                 name: str,
                 parameters: Mapping[str, str],
                 serialization_library: str):
        """
        :param str name: Name of the table.
        :param Mapping[str, str] parameters: Map of initialization parameters for the SerDe, in key-value form.
        :param str serialization_library: Usually the class that implements the SerDe. An example is `org.apache.hadoop.hive.serde2.columnar.ColumnarSerDe`.
        """
        GetCatalogTableStorageDescriptorSerDeInfoResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            parameters=parameters,
            serialization_library=serialization_library,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             parameters: Optional[Mapping[str, str]] = None,
             serialization_library: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if parameters is None:
            raise TypeError("Missing 'parameters' argument")
        if serialization_library is None and 'serializationLibrary' in kwargs:
            serialization_library = kwargs['serializationLibrary']
        if serialization_library is None:
            raise TypeError("Missing 'serialization_library' argument")

        _setter("name", name)
        _setter("parameters", parameters)
        _setter("serialization_library", serialization_library)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the table.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> Mapping[str, str]:
        """
        Map of initialization parameters for the SerDe, in key-value form.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter(name="serializationLibrary")
    def serialization_library(self) -> str:
        """
        Usually the class that implements the SerDe. An example is `org.apache.hadoop.hive.serde2.columnar.ColumnarSerDe`.
        """
        return pulumi.get(self, "serialization_library")


@pulumi.output_type
class GetCatalogTableStorageDescriptorSkewedInfoResult(dict):
    def __init__(__self__, *,
                 skewed_column_names: Sequence[str],
                 skewed_column_value_location_maps: Mapping[str, str],
                 skewed_column_values: Sequence[str]):
        """
        :param Sequence[str] skewed_column_names: List of names of columns that contain skewed values.
        :param Mapping[str, str] skewed_column_value_location_maps: List of values that appear so frequently as to be considered skewed.
        :param Sequence[str] skewed_column_values: Map of skewed values to the columns that contain them.
        """
        GetCatalogTableStorageDescriptorSkewedInfoResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            skewed_column_names=skewed_column_names,
            skewed_column_value_location_maps=skewed_column_value_location_maps,
            skewed_column_values=skewed_column_values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             skewed_column_names: Optional[Sequence[str]] = None,
             skewed_column_value_location_maps: Optional[Mapping[str, str]] = None,
             skewed_column_values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if skewed_column_names is None and 'skewedColumnNames' in kwargs:
            skewed_column_names = kwargs['skewedColumnNames']
        if skewed_column_names is None:
            raise TypeError("Missing 'skewed_column_names' argument")
        if skewed_column_value_location_maps is None and 'skewedColumnValueLocationMaps' in kwargs:
            skewed_column_value_location_maps = kwargs['skewedColumnValueLocationMaps']
        if skewed_column_value_location_maps is None:
            raise TypeError("Missing 'skewed_column_value_location_maps' argument")
        if skewed_column_values is None and 'skewedColumnValues' in kwargs:
            skewed_column_values = kwargs['skewedColumnValues']
        if skewed_column_values is None:
            raise TypeError("Missing 'skewed_column_values' argument")

        _setter("skewed_column_names", skewed_column_names)
        _setter("skewed_column_value_location_maps", skewed_column_value_location_maps)
        _setter("skewed_column_values", skewed_column_values)

    @property
    @pulumi.getter(name="skewedColumnNames")
    def skewed_column_names(self) -> Sequence[str]:
        """
        List of names of columns that contain skewed values.
        """
        return pulumi.get(self, "skewed_column_names")

    @property
    @pulumi.getter(name="skewedColumnValueLocationMaps")
    def skewed_column_value_location_maps(self) -> Mapping[str, str]:
        """
        List of values that appear so frequently as to be considered skewed.
        """
        return pulumi.get(self, "skewed_column_value_location_maps")

    @property
    @pulumi.getter(name="skewedColumnValues")
    def skewed_column_values(self) -> Sequence[str]:
        """
        Map of skewed values to the columns that contain them.
        """
        return pulumi.get(self, "skewed_column_values")


@pulumi.output_type
class GetCatalogTableStorageDescriptorSortColumnResult(dict):
    def __init__(__self__, *,
                 column: str,
                 sort_order: int):
        """
        :param str column: Name of the column.
        :param int sort_order: Whether the column is sorted in ascending (`1`) or descending order (`0`).
        """
        GetCatalogTableStorageDescriptorSortColumnResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column=column,
            sort_order=sort_order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column: Optional[str] = None,
             sort_order: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if column is None:
            raise TypeError("Missing 'column' argument")
        if sort_order is None and 'sortOrder' in kwargs:
            sort_order = kwargs['sortOrder']
        if sort_order is None:
            raise TypeError("Missing 'sort_order' argument")

        _setter("column", column)
        _setter("sort_order", sort_order)

    @property
    @pulumi.getter
    def column(self) -> str:
        """
        Name of the column.
        """
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="sortOrder")
    def sort_order(self) -> int:
        """
        Whether the column is sorted in ascending (`1`) or descending order (`0`).
        """
        return pulumi.get(self, "sort_order")


@pulumi.output_type
class GetCatalogTableTargetTableResult(dict):
    def __init__(__self__, *,
                 catalog_id: str,
                 database_name: str,
                 name: str):
        """
        :param str catalog_id: ID of the Glue Catalog and database where the table metadata resides. If omitted, this defaults to the current AWS Account ID.
        :param str database_name: Name of the metadata database where the table metadata resides.
        :param str name: Name of the table.
        """
        GetCatalogTableTargetTableResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            catalog_id=catalog_id,
            database_name=database_name,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             catalog_id: Optional[str] = None,
             database_name: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if catalog_id is None and 'catalogId' in kwargs:
            catalog_id = kwargs['catalogId']
        if catalog_id is None:
            raise TypeError("Missing 'catalog_id' argument")
        if database_name is None and 'databaseName' in kwargs:
            database_name = kwargs['databaseName']
        if database_name is None:
            raise TypeError("Missing 'database_name' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("catalog_id", catalog_id)
        _setter("database_name", database_name)
        _setter("name", name)

    @property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> str:
        """
        ID of the Glue Catalog and database where the table metadata resides. If omitted, this defaults to the current AWS Account ID.
        """
        return pulumi.get(self, "catalog_id")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        Name of the metadata database where the table metadata resides.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the table.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetConnectionPhysicalConnectionRequirementResult(dict):
    def __init__(__self__, *,
                 availability_zone: str,
                 security_group_id_lists: Sequence[str],
                 subnet_id: str):
        GetConnectionPhysicalConnectionRequirementResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability_zone=availability_zone,
            security_group_id_lists=security_group_id_lists,
            subnet_id=subnet_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability_zone: Optional[str] = None,
             security_group_id_lists: Optional[Sequence[str]] = None,
             subnet_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if availability_zone is None and 'availabilityZone' in kwargs:
            availability_zone = kwargs['availabilityZone']
        if availability_zone is None:
            raise TypeError("Missing 'availability_zone' argument")
        if security_group_id_lists is None and 'securityGroupIdLists' in kwargs:
            security_group_id_lists = kwargs['securityGroupIdLists']
        if security_group_id_lists is None:
            raise TypeError("Missing 'security_group_id_lists' argument")
        if subnet_id is None and 'subnetId' in kwargs:
            subnet_id = kwargs['subnetId']
        if subnet_id is None:
            raise TypeError("Missing 'subnet_id' argument")

        _setter("availability_zone", availability_zone)
        _setter("security_group_id_lists", security_group_id_lists)
        _setter("subnet_id", subnet_id)

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> str:
        return pulumi.get(self, "availability_zone")

    @property
    @pulumi.getter(name="securityGroupIdLists")
    def security_group_id_lists(self) -> Sequence[str]:
        return pulumi.get(self, "security_group_id_lists")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class GetDataCatalogEncryptionSettingsDataCatalogEncryptionSettingResult(dict):
    def __init__(__self__, *,
                 connection_password_encryptions: Sequence['outputs.GetDataCatalogEncryptionSettingsDataCatalogEncryptionSettingConnectionPasswordEncryptionResult'],
                 encryption_at_rests: Sequence['outputs.GetDataCatalogEncryptionSettingsDataCatalogEncryptionSettingEncryptionAtRestResult']):
        """
        :param Sequence['GetDataCatalogEncryptionSettingsDataCatalogEncryptionSettingConnectionPasswordEncryptionArgs'] connection_password_encryptions: When connection password protection is enabled, the Data Catalog uses a customer-provided key to encrypt the password as part of CreateConnection or UpdateConnection and store it in the ENCRYPTED_PASSWORD field in the connection properties. You can enable catalog encryption or only password encryption. see Connection Password Encryption.
        :param Sequence['GetDataCatalogEncryptionSettingsDataCatalogEncryptionSettingEncryptionAtRestArgs'] encryption_at_rests: Encryption-at-rest configuration for the Data Catalog. see Encryption At Rest.
        """
        GetDataCatalogEncryptionSettingsDataCatalogEncryptionSettingResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            connection_password_encryptions=connection_password_encryptions,
            encryption_at_rests=encryption_at_rests,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             connection_password_encryptions: Optional[Sequence['outputs.GetDataCatalogEncryptionSettingsDataCatalogEncryptionSettingConnectionPasswordEncryptionResult']] = None,
             encryption_at_rests: Optional[Sequence['outputs.GetDataCatalogEncryptionSettingsDataCatalogEncryptionSettingEncryptionAtRestResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if connection_password_encryptions is None and 'connectionPasswordEncryptions' in kwargs:
            connection_password_encryptions = kwargs['connectionPasswordEncryptions']
        if connection_password_encryptions is None:
            raise TypeError("Missing 'connection_password_encryptions' argument")
        if encryption_at_rests is None and 'encryptionAtRests' in kwargs:
            encryption_at_rests = kwargs['encryptionAtRests']
        if encryption_at_rests is None:
            raise TypeError("Missing 'encryption_at_rests' argument")

        _setter("connection_password_encryptions", connection_password_encryptions)
        _setter("encryption_at_rests", encryption_at_rests)

    @property
    @pulumi.getter(name="connectionPasswordEncryptions")
    def connection_password_encryptions(self) -> Sequence['outputs.GetDataCatalogEncryptionSettingsDataCatalogEncryptionSettingConnectionPasswordEncryptionResult']:
        """
        When connection password protection is enabled, the Data Catalog uses a customer-provided key to encrypt the password as part of CreateConnection or UpdateConnection and store it in the ENCRYPTED_PASSWORD field in the connection properties. You can enable catalog encryption or only password encryption. see Connection Password Encryption.
        """
        return pulumi.get(self, "connection_password_encryptions")

    @property
    @pulumi.getter(name="encryptionAtRests")
    def encryption_at_rests(self) -> Sequence['outputs.GetDataCatalogEncryptionSettingsDataCatalogEncryptionSettingEncryptionAtRestResult']:
        """
        Encryption-at-rest configuration for the Data Catalog. see Encryption At Rest.
        """
        return pulumi.get(self, "encryption_at_rests")


@pulumi.output_type
class GetDataCatalogEncryptionSettingsDataCatalogEncryptionSettingConnectionPasswordEncryptionResult(dict):
    def __init__(__self__, *,
                 aws_kms_key_id: str,
                 return_connection_password_encrypted: bool):
        """
        :param str aws_kms_key_id: KMS key ARN that is used to encrypt the connection password.
        :param bool return_connection_password_encrypted: When set to `true`, passwords remain encrypted in the responses of GetConnection and GetConnections. This encryption takes effect independently of the catalog encryption.
        """
        GetDataCatalogEncryptionSettingsDataCatalogEncryptionSettingConnectionPasswordEncryptionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aws_kms_key_id=aws_kms_key_id,
            return_connection_password_encrypted=return_connection_password_encrypted,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aws_kms_key_id: Optional[str] = None,
             return_connection_password_encrypted: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if aws_kms_key_id is None and 'awsKmsKeyId' in kwargs:
            aws_kms_key_id = kwargs['awsKmsKeyId']
        if aws_kms_key_id is None:
            raise TypeError("Missing 'aws_kms_key_id' argument")
        if return_connection_password_encrypted is None and 'returnConnectionPasswordEncrypted' in kwargs:
            return_connection_password_encrypted = kwargs['returnConnectionPasswordEncrypted']
        if return_connection_password_encrypted is None:
            raise TypeError("Missing 'return_connection_password_encrypted' argument")

        _setter("aws_kms_key_id", aws_kms_key_id)
        _setter("return_connection_password_encrypted", return_connection_password_encrypted)

    @property
    @pulumi.getter(name="awsKmsKeyId")
    def aws_kms_key_id(self) -> str:
        """
        KMS key ARN that is used to encrypt the connection password.
        """
        return pulumi.get(self, "aws_kms_key_id")

    @property
    @pulumi.getter(name="returnConnectionPasswordEncrypted")
    def return_connection_password_encrypted(self) -> bool:
        """
        When set to `true`, passwords remain encrypted in the responses of GetConnection and GetConnections. This encryption takes effect independently of the catalog encryption.
        """
        return pulumi.get(self, "return_connection_password_encrypted")


@pulumi.output_type
class GetDataCatalogEncryptionSettingsDataCatalogEncryptionSettingEncryptionAtRestResult(dict):
    def __init__(__self__, *,
                 catalog_encryption_mode: str,
                 sse_aws_kms_key_id: str):
        """
        :param str catalog_encryption_mode: The encryption-at-rest mode for encrypting Data Catalog data.
        :param str sse_aws_kms_key_id: ARN of the AWS KMS key to use for encryption at rest.
        """
        GetDataCatalogEncryptionSettingsDataCatalogEncryptionSettingEncryptionAtRestResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            catalog_encryption_mode=catalog_encryption_mode,
            sse_aws_kms_key_id=sse_aws_kms_key_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             catalog_encryption_mode: Optional[str] = None,
             sse_aws_kms_key_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if catalog_encryption_mode is None and 'catalogEncryptionMode' in kwargs:
            catalog_encryption_mode = kwargs['catalogEncryptionMode']
        if catalog_encryption_mode is None:
            raise TypeError("Missing 'catalog_encryption_mode' argument")
        if sse_aws_kms_key_id is None and 'sseAwsKmsKeyId' in kwargs:
            sse_aws_kms_key_id = kwargs['sseAwsKmsKeyId']
        if sse_aws_kms_key_id is None:
            raise TypeError("Missing 'sse_aws_kms_key_id' argument")

        _setter("catalog_encryption_mode", catalog_encryption_mode)
        _setter("sse_aws_kms_key_id", sse_aws_kms_key_id)

    @property
    @pulumi.getter(name="catalogEncryptionMode")
    def catalog_encryption_mode(self) -> str:
        """
        The encryption-at-rest mode for encrypting Data Catalog data.
        """
        return pulumi.get(self, "catalog_encryption_mode")

    @property
    @pulumi.getter(name="sseAwsKmsKeyId")
    def sse_aws_kms_key_id(self) -> str:
        """
        ARN of the AWS KMS key to use for encryption at rest.
        """
        return pulumi.get(self, "sse_aws_kms_key_id")


@pulumi.output_type
class GetScriptDagEdgeResult(dict):
    def __init__(__self__, *,
                 source: str,
                 target: str,
                 target_parameter: Optional[str] = None):
        """
        :param str source: ID of the node at which the edge starts.
        :param str target: ID of the node at which the edge ends.
        :param str target_parameter: Target of the edge.
        """
        GetScriptDagEdgeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            source=source,
            target=target,
            target_parameter=target_parameter,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             source: Optional[str] = None,
             target: Optional[str] = None,
             target_parameter: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if source is None:
            raise TypeError("Missing 'source' argument")
        if target is None:
            raise TypeError("Missing 'target' argument")
        if target_parameter is None and 'targetParameter' in kwargs:
            target_parameter = kwargs['targetParameter']

        _setter("source", source)
        _setter("target", target)
        if target_parameter is not None:
            _setter("target_parameter", target_parameter)

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        ID of the node at which the edge starts.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        ID of the node at which the edge ends.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="targetParameter")
    def target_parameter(self) -> Optional[str]:
        """
        Target of the edge.
        """
        return pulumi.get(self, "target_parameter")


@pulumi.output_type
class GetScriptDagNodeResult(dict):
    def __init__(__self__, *,
                 args: Sequence['outputs.GetScriptDagNodeArgResult'],
                 id: str,
                 node_type: str,
                 line_number: Optional[int] = None):
        """
        :param Sequence['GetScriptDagNodeArgArgs'] args: Nested configuration an argument or property of a node. Defined below.
        :param str id: Node identifier that is unique within the node's graph.
        :param str node_type: Type of node this is.
        :param int line_number: Line number of the node.
        """
        GetScriptDagNodeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            args=args,
            id=id,
            node_type=node_type,
            line_number=line_number,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             args: Optional[Sequence['outputs.GetScriptDagNodeArgResult']] = None,
             id: Optional[str] = None,
             node_type: Optional[str] = None,
             line_number: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if args is None:
            raise TypeError("Missing 'args' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if node_type is None and 'nodeType' in kwargs:
            node_type = kwargs['nodeType']
        if node_type is None:
            raise TypeError("Missing 'node_type' argument")
        if line_number is None and 'lineNumber' in kwargs:
            line_number = kwargs['lineNumber']

        _setter("args", args)
        _setter("id", id)
        _setter("node_type", node_type)
        if line_number is not None:
            _setter("line_number", line_number)

    @property
    @pulumi.getter
    def args(self) -> Sequence['outputs.GetScriptDagNodeArgResult']:
        """
        Nested configuration an argument or property of a node. Defined below.
        """
        return pulumi.get(self, "args")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Node identifier that is unique within the node's graph.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="nodeType")
    def node_type(self) -> str:
        """
        Type of node this is.
        """
        return pulumi.get(self, "node_type")

    @property
    @pulumi.getter(name="lineNumber")
    def line_number(self) -> Optional[int]:
        """
        Line number of the node.
        """
        return pulumi.get(self, "line_number")


@pulumi.output_type
class GetScriptDagNodeArgResult(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str,
                 param: Optional[bool] = None):
        """
        :param str name: Name of the argument or property.
        :param str value: Value of the argument or property.
        :param bool param: Boolean if the value is used as a parameter. Defaults to `false`.
        """
        GetScriptDagNodeArgResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            value=value,
            param=param,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             value: Optional[str] = None,
             param: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("name", name)
        _setter("value", value)
        if param is not None:
            _setter("param", param)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the argument or property.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value of the argument or property.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def param(self) -> Optional[bool]:
        """
        Boolean if the value is used as a parameter. Defaults to `false`.
        """
        return pulumi.get(self, "param")


