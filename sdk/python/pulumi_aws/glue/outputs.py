# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'CatalogDatabaseCreateTableDefaultPermission',
    'CatalogDatabaseCreateTableDefaultPermissionPrincipal',
    'CatalogDatabaseFederatedDatabase',
    'CatalogDatabaseTargetDatabase',
    'CatalogTableOpenTableFormatInput',
    'CatalogTableOpenTableFormatInputIcebergInput',
    'CatalogTableOptimizerConfiguration',
    'CatalogTableOptimizerConfigurationOrphanFileDeletionConfiguration',
    'CatalogTableOptimizerConfigurationOrphanFileDeletionConfigurationIcebergConfiguration',
    'CatalogTableOptimizerConfigurationRetentionConfiguration',
    'CatalogTableOptimizerConfigurationRetentionConfigurationIcebergConfiguration',
    'CatalogTablePartitionIndex',
    'CatalogTablePartitionKey',
    'CatalogTableStorageDescriptor',
    'CatalogTableStorageDescriptorColumn',
    'CatalogTableStorageDescriptorSchemaReference',
    'CatalogTableStorageDescriptorSchemaReferenceSchemaId',
    'CatalogTableStorageDescriptorSerDeInfo',
    'CatalogTableStorageDescriptorSkewedInfo',
    'CatalogTableStorageDescriptorSortColumn',
    'CatalogTableTargetTable',
    'ClassifierCsvClassifier',
    'ClassifierGrokClassifier',
    'ClassifierJsonClassifier',
    'ClassifierXmlClassifier',
    'ConnectionPhysicalConnectionRequirements',
    'CrawlerCatalogTarget',
    'CrawlerDeltaTarget',
    'CrawlerDynamodbTarget',
    'CrawlerHudiTarget',
    'CrawlerIcebergTarget',
    'CrawlerJdbcTarget',
    'CrawlerLakeFormationConfiguration',
    'CrawlerLineageConfiguration',
    'CrawlerMongodbTarget',
    'CrawlerRecrawlPolicy',
    'CrawlerS3Target',
    'CrawlerSchemaChangePolicy',
    'DataCatalogEncryptionSettingsDataCatalogEncryptionSettings',
    'DataCatalogEncryptionSettingsDataCatalogEncryptionSettingsConnectionPasswordEncryption',
    'DataCatalogEncryptionSettingsDataCatalogEncryptionSettingsEncryptionAtRest',
    'DataQualityRulesetTargetTable',
    'JobCommand',
    'JobExecutionProperty',
    'JobNotificationProperty',
    'JobSourceControlDetails',
    'MLTransformInputRecordTable',
    'MLTransformParameters',
    'MLTransformParametersFindMatchesParameters',
    'MLTransformSchema',
    'PartitionIndexPartitionIndex',
    'PartitionStorageDescriptor',
    'PartitionStorageDescriptorColumn',
    'PartitionStorageDescriptorSerDeInfo',
    'PartitionStorageDescriptorSkewedInfo',
    'PartitionStorageDescriptorSortColumn',
    'SecurityConfigurationEncryptionConfiguration',
    'SecurityConfigurationEncryptionConfigurationCloudwatchEncryption',
    'SecurityConfigurationEncryptionConfigurationJobBookmarksEncryption',
    'SecurityConfigurationEncryptionConfigurationS3Encryption',
    'TriggerAction',
    'TriggerActionNotificationProperty',
    'TriggerEventBatchingCondition',
    'TriggerPredicate',
    'TriggerPredicateCondition',
    'UserDefinedFunctionResourceUri',
    'GetCatalogTablePartitionIndexResult',
    'GetCatalogTablePartitionKeyResult',
    'GetCatalogTableStorageDescriptorResult',
    'GetCatalogTableStorageDescriptorColumnResult',
    'GetCatalogTableStorageDescriptorSchemaReferenceResult',
    'GetCatalogTableStorageDescriptorSchemaReferenceSchemaIdResult',
    'GetCatalogTableStorageDescriptorSerDeInfoResult',
    'GetCatalogTableStorageDescriptorSkewedInfoResult',
    'GetCatalogTableStorageDescriptorSortColumnResult',
    'GetCatalogTableTargetTableResult',
    'GetConnectionPhysicalConnectionRequirementResult',
    'GetDataCatalogEncryptionSettingsDataCatalogEncryptionSettingResult',
    'GetDataCatalogEncryptionSettingsDataCatalogEncryptionSettingConnectionPasswordEncryptionResult',
    'GetDataCatalogEncryptionSettingsDataCatalogEncryptionSettingEncryptionAtRestResult',
    'GetScriptDagEdgeResult',
    'GetScriptDagNodeResult',
    'GetScriptDagNodeArgResult',
]

@pulumi.output_type
class CatalogDatabaseCreateTableDefaultPermission(dict):
    def __init__(__self__, *,
                 permissions: Optional[Sequence[_builtins.str]] = None,
                 principal: Optional['outputs.CatalogDatabaseCreateTableDefaultPermissionPrincipal'] = None):
        if permissions is not None:
            pulumi.set(__self__, "permissions", permissions)
        if principal is not None:
            pulumi.set(__self__, "principal", principal)

    @_builtins.property
    @pulumi.getter
    def permissions(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "permissions")

    @_builtins.property
    @pulumi.getter
    def principal(self) -> Optional['outputs.CatalogDatabaseCreateTableDefaultPermissionPrincipal']:
        return pulumi.get(self, "principal")


@pulumi.output_type
class CatalogDatabaseCreateTableDefaultPermissionPrincipal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataLakePrincipalIdentifier":
            suggest = "data_lake_principal_identifier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CatalogDatabaseCreateTableDefaultPermissionPrincipal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CatalogDatabaseCreateTableDefaultPermissionPrincipal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CatalogDatabaseCreateTableDefaultPermissionPrincipal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_lake_principal_identifier: Optional[_builtins.str] = None):
        if data_lake_principal_identifier is not None:
            pulumi.set(__self__, "data_lake_principal_identifier", data_lake_principal_identifier)

    @_builtins.property
    @pulumi.getter(name="dataLakePrincipalIdentifier")
    def data_lake_principal_identifier(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "data_lake_principal_identifier")


@pulumi.output_type
class CatalogDatabaseFederatedDatabase(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionName":
            suggest = "connection_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CatalogDatabaseFederatedDatabase. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CatalogDatabaseFederatedDatabase.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CatalogDatabaseFederatedDatabase.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_name: Optional[_builtins.str] = None,
                 identifier: Optional[_builtins.str] = None):
        if connection_name is not None:
            pulumi.set(__self__, "connection_name", connection_name)
        if identifier is not None:
            pulumi.set(__self__, "identifier", identifier)

    @_builtins.property
    @pulumi.getter(name="connectionName")
    def connection_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "connection_name")

    @_builtins.property
    @pulumi.getter
    def identifier(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "identifier")


@pulumi.output_type
class CatalogDatabaseTargetDatabase(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "catalogId":
            suggest = "catalog_id"
        elif key == "databaseName":
            suggest = "database_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CatalogDatabaseTargetDatabase. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CatalogDatabaseTargetDatabase.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CatalogDatabaseTargetDatabase.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 catalog_id: _builtins.str,
                 database_name: _builtins.str,
                 region: Optional[_builtins.str] = None):
        pulumi.set(__self__, "catalog_id", catalog_id)
        pulumi.set(__self__, "database_name", database_name)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> _builtins.str:
        return pulumi.get(self, "catalog_id")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> _builtins.str:
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "region")


@pulumi.output_type
class CatalogTableOpenTableFormatInput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "icebergInput":
            suggest = "iceberg_input"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CatalogTableOpenTableFormatInput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CatalogTableOpenTableFormatInput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CatalogTableOpenTableFormatInput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 iceberg_input: 'outputs.CatalogTableOpenTableFormatInputIcebergInput'):
        pulumi.set(__self__, "iceberg_input", iceberg_input)

    @_builtins.property
    @pulumi.getter(name="icebergInput")
    def iceberg_input(self) -> 'outputs.CatalogTableOpenTableFormatInputIcebergInput':
        return pulumi.get(self, "iceberg_input")


@pulumi.output_type
class CatalogTableOpenTableFormatInputIcebergInput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metadataOperation":
            suggest = "metadata_operation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CatalogTableOpenTableFormatInputIcebergInput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CatalogTableOpenTableFormatInputIcebergInput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CatalogTableOpenTableFormatInputIcebergInput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metadata_operation: _builtins.str,
                 version: Optional[_builtins.str] = None):
        pulumi.set(__self__, "metadata_operation", metadata_operation)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="metadataOperation")
    def metadata_operation(self) -> _builtins.str:
        return pulumi.get(self, "metadata_operation")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "version")


@pulumi.output_type
class CatalogTableOptimizerConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleArn":
            suggest = "role_arn"
        elif key == "orphanFileDeletionConfiguration":
            suggest = "orphan_file_deletion_configuration"
        elif key == "retentionConfiguration":
            suggest = "retention_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CatalogTableOptimizerConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CatalogTableOptimizerConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CatalogTableOptimizerConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 role_arn: _builtins.str,
                 orphan_file_deletion_configuration: Optional['outputs.CatalogTableOptimizerConfigurationOrphanFileDeletionConfiguration'] = None,
                 retention_configuration: Optional['outputs.CatalogTableOptimizerConfigurationRetentionConfiguration'] = None):
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "role_arn", role_arn)
        if orphan_file_deletion_configuration is not None:
            pulumi.set(__self__, "orphan_file_deletion_configuration", orphan_file_deletion_configuration)
        if retention_configuration is not None:
            pulumi.set(__self__, "retention_configuration", retention_configuration)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> _builtins.str:
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="orphanFileDeletionConfiguration")
    def orphan_file_deletion_configuration(self) -> Optional['outputs.CatalogTableOptimizerConfigurationOrphanFileDeletionConfiguration']:
        return pulumi.get(self, "orphan_file_deletion_configuration")

    @_builtins.property
    @pulumi.getter(name="retentionConfiguration")
    def retention_configuration(self) -> Optional['outputs.CatalogTableOptimizerConfigurationRetentionConfiguration']:
        return pulumi.get(self, "retention_configuration")


@pulumi.output_type
class CatalogTableOptimizerConfigurationOrphanFileDeletionConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "icebergConfiguration":
            suggest = "iceberg_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CatalogTableOptimizerConfigurationOrphanFileDeletionConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CatalogTableOptimizerConfigurationOrphanFileDeletionConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CatalogTableOptimizerConfigurationOrphanFileDeletionConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 iceberg_configuration: Optional['outputs.CatalogTableOptimizerConfigurationOrphanFileDeletionConfigurationIcebergConfiguration'] = None):
        if iceberg_configuration is not None:
            pulumi.set(__self__, "iceberg_configuration", iceberg_configuration)

    @_builtins.property
    @pulumi.getter(name="icebergConfiguration")
    def iceberg_configuration(self) -> Optional['outputs.CatalogTableOptimizerConfigurationOrphanFileDeletionConfigurationIcebergConfiguration']:
        return pulumi.get(self, "iceberg_configuration")


@pulumi.output_type
class CatalogTableOptimizerConfigurationOrphanFileDeletionConfigurationIcebergConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "orphanFileRetentionPeriodInDays":
            suggest = "orphan_file_retention_period_in_days"
        elif key == "runRateInHours":
            suggest = "run_rate_in_hours"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CatalogTableOptimizerConfigurationOrphanFileDeletionConfigurationIcebergConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CatalogTableOptimizerConfigurationOrphanFileDeletionConfigurationIcebergConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CatalogTableOptimizerConfigurationOrphanFileDeletionConfigurationIcebergConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 location: Optional[_builtins.str] = None,
                 orphan_file_retention_period_in_days: Optional[_builtins.int] = None,
                 run_rate_in_hours: Optional[_builtins.int] = None):
        if location is not None:
            pulumi.set(__self__, "location", location)
        if orphan_file_retention_period_in_days is not None:
            pulumi.set(__self__, "orphan_file_retention_period_in_days", orphan_file_retention_period_in_days)
        if run_rate_in_hours is not None:
            pulumi.set(__self__, "run_rate_in_hours", run_rate_in_hours)

    @_builtins.property
    @pulumi.getter
    def location(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "location")

    @_builtins.property
    @pulumi.getter(name="orphanFileRetentionPeriodInDays")
    def orphan_file_retention_period_in_days(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "orphan_file_retention_period_in_days")

    @_builtins.property
    @pulumi.getter(name="runRateInHours")
    def run_rate_in_hours(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "run_rate_in_hours")


@pulumi.output_type
class CatalogTableOptimizerConfigurationRetentionConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "icebergConfiguration":
            suggest = "iceberg_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CatalogTableOptimizerConfigurationRetentionConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CatalogTableOptimizerConfigurationRetentionConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CatalogTableOptimizerConfigurationRetentionConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 iceberg_configuration: Optional['outputs.CatalogTableOptimizerConfigurationRetentionConfigurationIcebergConfiguration'] = None):
        if iceberg_configuration is not None:
            pulumi.set(__self__, "iceberg_configuration", iceberg_configuration)

    @_builtins.property
    @pulumi.getter(name="icebergConfiguration")
    def iceberg_configuration(self) -> Optional['outputs.CatalogTableOptimizerConfigurationRetentionConfigurationIcebergConfiguration']:
        return pulumi.get(self, "iceberg_configuration")


@pulumi.output_type
class CatalogTableOptimizerConfigurationRetentionConfigurationIcebergConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cleanExpiredFiles":
            suggest = "clean_expired_files"
        elif key == "numberOfSnapshotsToRetain":
            suggest = "number_of_snapshots_to_retain"
        elif key == "runRateInHours":
            suggest = "run_rate_in_hours"
        elif key == "snapshotRetentionPeriodInDays":
            suggest = "snapshot_retention_period_in_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CatalogTableOptimizerConfigurationRetentionConfigurationIcebergConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CatalogTableOptimizerConfigurationRetentionConfigurationIcebergConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CatalogTableOptimizerConfigurationRetentionConfigurationIcebergConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 clean_expired_files: Optional[_builtins.bool] = None,
                 number_of_snapshots_to_retain: Optional[_builtins.int] = None,
                 run_rate_in_hours: Optional[_builtins.int] = None,
                 snapshot_retention_period_in_days: Optional[_builtins.int] = None):
        if clean_expired_files is not None:
            pulumi.set(__self__, "clean_expired_files", clean_expired_files)
        if number_of_snapshots_to_retain is not None:
            pulumi.set(__self__, "number_of_snapshots_to_retain", number_of_snapshots_to_retain)
        if run_rate_in_hours is not None:
            pulumi.set(__self__, "run_rate_in_hours", run_rate_in_hours)
        if snapshot_retention_period_in_days is not None:
            pulumi.set(__self__, "snapshot_retention_period_in_days", snapshot_retention_period_in_days)

    @_builtins.property
    @pulumi.getter(name="cleanExpiredFiles")
    def clean_expired_files(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "clean_expired_files")

    @_builtins.property
    @pulumi.getter(name="numberOfSnapshotsToRetain")
    def number_of_snapshots_to_retain(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "number_of_snapshots_to_retain")

    @_builtins.property
    @pulumi.getter(name="runRateInHours")
    def run_rate_in_hours(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "run_rate_in_hours")

    @_builtins.property
    @pulumi.getter(name="snapshotRetentionPeriodInDays")
    def snapshot_retention_period_in_days(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "snapshot_retention_period_in_days")


@pulumi.output_type
class CatalogTablePartitionIndex(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "indexName":
            suggest = "index_name"
        elif key == "indexStatus":
            suggest = "index_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CatalogTablePartitionIndex. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CatalogTablePartitionIndex.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CatalogTablePartitionIndex.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index_name: _builtins.str,
                 keys: Sequence[_builtins.str],
                 index_status: Optional[_builtins.str] = None):
        pulumi.set(__self__, "index_name", index_name)
        pulumi.set(__self__, "keys", keys)
        if index_status is not None:
            pulumi.set(__self__, "index_status", index_status)

    @_builtins.property
    @pulumi.getter(name="indexName")
    def index_name(self) -> _builtins.str:
        return pulumi.get(self, "index_name")

    @_builtins.property
    @pulumi.getter
    def keys(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "keys")

    @_builtins.property
    @pulumi.getter(name="indexStatus")
    def index_status(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "index_status")


@pulumi.output_type
class CatalogTablePartitionKey(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 comment: Optional[_builtins.str] = None,
                 parameters: Optional[Mapping[str, _builtins.str]] = None,
                 type: Optional[_builtins.str] = None):
        pulumi.set(__self__, "name", name)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "comment")

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "parameters")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class CatalogTableStorageDescriptor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalLocations":
            suggest = "additional_locations"
        elif key == "bucketColumns":
            suggest = "bucket_columns"
        elif key == "inputFormat":
            suggest = "input_format"
        elif key == "numberOfBuckets":
            suggest = "number_of_buckets"
        elif key == "outputFormat":
            suggest = "output_format"
        elif key == "schemaReference":
            suggest = "schema_reference"
        elif key == "serDeInfo":
            suggest = "ser_de_info"
        elif key == "skewedInfo":
            suggest = "skewed_info"
        elif key == "sortColumns":
            suggest = "sort_columns"
        elif key == "storedAsSubDirectories":
            suggest = "stored_as_sub_directories"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CatalogTableStorageDescriptor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CatalogTableStorageDescriptor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CatalogTableStorageDescriptor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_locations: Optional[Sequence[_builtins.str]] = None,
                 bucket_columns: Optional[Sequence[_builtins.str]] = None,
                 columns: Optional[Sequence['outputs.CatalogTableStorageDescriptorColumn']] = None,
                 compressed: Optional[_builtins.bool] = None,
                 input_format: Optional[_builtins.str] = None,
                 location: Optional[_builtins.str] = None,
                 number_of_buckets: Optional[_builtins.int] = None,
                 output_format: Optional[_builtins.str] = None,
                 parameters: Optional[Mapping[str, _builtins.str]] = None,
                 schema_reference: Optional['outputs.CatalogTableStorageDescriptorSchemaReference'] = None,
                 ser_de_info: Optional['outputs.CatalogTableStorageDescriptorSerDeInfo'] = None,
                 skewed_info: Optional['outputs.CatalogTableStorageDescriptorSkewedInfo'] = None,
                 sort_columns: Optional[Sequence['outputs.CatalogTableStorageDescriptorSortColumn']] = None,
                 stored_as_sub_directories: Optional[_builtins.bool] = None):
        if additional_locations is not None:
            pulumi.set(__self__, "additional_locations", additional_locations)
        if bucket_columns is not None:
            pulumi.set(__self__, "bucket_columns", bucket_columns)
        if columns is not None:
            pulumi.set(__self__, "columns", columns)
        if compressed is not None:
            pulumi.set(__self__, "compressed", compressed)
        if input_format is not None:
            pulumi.set(__self__, "input_format", input_format)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if number_of_buckets is not None:
            pulumi.set(__self__, "number_of_buckets", number_of_buckets)
        if output_format is not None:
            pulumi.set(__self__, "output_format", output_format)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema_reference is not None:
            pulumi.set(__self__, "schema_reference", schema_reference)
        if ser_de_info is not None:
            pulumi.set(__self__, "ser_de_info", ser_de_info)
        if skewed_info is not None:
            pulumi.set(__self__, "skewed_info", skewed_info)
        if sort_columns is not None:
            pulumi.set(__self__, "sort_columns", sort_columns)
        if stored_as_sub_directories is not None:
            pulumi.set(__self__, "stored_as_sub_directories", stored_as_sub_directories)

    @_builtins.property
    @pulumi.getter(name="additionalLocations")
    def additional_locations(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "additional_locations")

    @_builtins.property
    @pulumi.getter(name="bucketColumns")
    def bucket_columns(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "bucket_columns")

    @_builtins.property
    @pulumi.getter
    def columns(self) -> Optional[Sequence['outputs.CatalogTableStorageDescriptorColumn']]:
        return pulumi.get(self, "columns")

    @_builtins.property
    @pulumi.getter
    def compressed(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "compressed")

    @_builtins.property
    @pulumi.getter(name="inputFormat")
    def input_format(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "input_format")

    @_builtins.property
    @pulumi.getter
    def location(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "location")

    @_builtins.property
    @pulumi.getter(name="numberOfBuckets")
    def number_of_buckets(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "number_of_buckets")

    @_builtins.property
    @pulumi.getter(name="outputFormat")
    def output_format(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "output_format")

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "parameters")

    @_builtins.property
    @pulumi.getter(name="schemaReference")
    def schema_reference(self) -> Optional['outputs.CatalogTableStorageDescriptorSchemaReference']:
        return pulumi.get(self, "schema_reference")

    @_builtins.property
    @pulumi.getter(name="serDeInfo")
    def ser_de_info(self) -> Optional['outputs.CatalogTableStorageDescriptorSerDeInfo']:
        return pulumi.get(self, "ser_de_info")

    @_builtins.property
    @pulumi.getter(name="skewedInfo")
    def skewed_info(self) -> Optional['outputs.CatalogTableStorageDescriptorSkewedInfo']:
        return pulumi.get(self, "skewed_info")

    @_builtins.property
    @pulumi.getter(name="sortColumns")
    def sort_columns(self) -> Optional[Sequence['outputs.CatalogTableStorageDescriptorSortColumn']]:
        return pulumi.get(self, "sort_columns")

    @_builtins.property
    @pulumi.getter(name="storedAsSubDirectories")
    def stored_as_sub_directories(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "stored_as_sub_directories")


@pulumi.output_type
class CatalogTableStorageDescriptorColumn(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 comment: Optional[_builtins.str] = None,
                 parameters: Optional[Mapping[str, _builtins.str]] = None,
                 type: Optional[_builtins.str] = None):
        pulumi.set(__self__, "name", name)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "comment")

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "parameters")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class CatalogTableStorageDescriptorSchemaReference(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "schemaVersionNumber":
            suggest = "schema_version_number"
        elif key == "schemaId":
            suggest = "schema_id"
        elif key == "schemaVersionId":
            suggest = "schema_version_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CatalogTableStorageDescriptorSchemaReference. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CatalogTableStorageDescriptorSchemaReference.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CatalogTableStorageDescriptorSchemaReference.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 schema_version_number: _builtins.int,
                 schema_id: Optional['outputs.CatalogTableStorageDescriptorSchemaReferenceSchemaId'] = None,
                 schema_version_id: Optional[_builtins.str] = None):
        pulumi.set(__self__, "schema_version_number", schema_version_number)
        if schema_id is not None:
            pulumi.set(__self__, "schema_id", schema_id)
        if schema_version_id is not None:
            pulumi.set(__self__, "schema_version_id", schema_version_id)

    @_builtins.property
    @pulumi.getter(name="schemaVersionNumber")
    def schema_version_number(self) -> _builtins.int:
        return pulumi.get(self, "schema_version_number")

    @_builtins.property
    @pulumi.getter(name="schemaId")
    def schema_id(self) -> Optional['outputs.CatalogTableStorageDescriptorSchemaReferenceSchemaId']:
        return pulumi.get(self, "schema_id")

    @_builtins.property
    @pulumi.getter(name="schemaVersionId")
    def schema_version_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "schema_version_id")


@pulumi.output_type
class CatalogTableStorageDescriptorSchemaReferenceSchemaId(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "registryName":
            suggest = "registry_name"
        elif key == "schemaArn":
            suggest = "schema_arn"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CatalogTableStorageDescriptorSchemaReferenceSchemaId. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CatalogTableStorageDescriptorSchemaReferenceSchemaId.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CatalogTableStorageDescriptorSchemaReferenceSchemaId.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 registry_name: Optional[_builtins.str] = None,
                 schema_arn: Optional[_builtins.str] = None,
                 schema_name: Optional[_builtins.str] = None):
        if registry_name is not None:
            pulumi.set(__self__, "registry_name", registry_name)
        if schema_arn is not None:
            pulumi.set(__self__, "schema_arn", schema_arn)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter(name="registryName")
    def registry_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "registry_name")

    @_builtins.property
    @pulumi.getter(name="schemaArn")
    def schema_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "schema_arn")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class CatalogTableStorageDescriptorSerDeInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serializationLibrary":
            suggest = "serialization_library"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CatalogTableStorageDescriptorSerDeInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CatalogTableStorageDescriptorSerDeInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CatalogTableStorageDescriptorSerDeInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 parameters: Optional[Mapping[str, _builtins.str]] = None,
                 serialization_library: Optional[_builtins.str] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if serialization_library is not None:
            pulumi.set(__self__, "serialization_library", serialization_library)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "parameters")

    @_builtins.property
    @pulumi.getter(name="serializationLibrary")
    def serialization_library(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "serialization_library")


@pulumi.output_type
class CatalogTableStorageDescriptorSkewedInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "skewedColumnNames":
            suggest = "skewed_column_names"
        elif key == "skewedColumnValueLocationMaps":
            suggest = "skewed_column_value_location_maps"
        elif key == "skewedColumnValues":
            suggest = "skewed_column_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CatalogTableStorageDescriptorSkewedInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CatalogTableStorageDescriptorSkewedInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CatalogTableStorageDescriptorSkewedInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 skewed_column_names: Optional[Sequence[_builtins.str]] = None,
                 skewed_column_value_location_maps: Optional[Mapping[str, _builtins.str]] = None,
                 skewed_column_values: Optional[Sequence[_builtins.str]] = None):
        if skewed_column_names is not None:
            pulumi.set(__self__, "skewed_column_names", skewed_column_names)
        if skewed_column_value_location_maps is not None:
            pulumi.set(__self__, "skewed_column_value_location_maps", skewed_column_value_location_maps)
        if skewed_column_values is not None:
            pulumi.set(__self__, "skewed_column_values", skewed_column_values)

    @_builtins.property
    @pulumi.getter(name="skewedColumnNames")
    def skewed_column_names(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "skewed_column_names")

    @_builtins.property
    @pulumi.getter(name="skewedColumnValueLocationMaps")
    def skewed_column_value_location_maps(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "skewed_column_value_location_maps")

    @_builtins.property
    @pulumi.getter(name="skewedColumnValues")
    def skewed_column_values(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "skewed_column_values")


@pulumi.output_type
class CatalogTableStorageDescriptorSortColumn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortOrder":
            suggest = "sort_order"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CatalogTableStorageDescriptorSortColumn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CatalogTableStorageDescriptorSortColumn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CatalogTableStorageDescriptorSortColumn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: _builtins.str,
                 sort_order: _builtins.int):
        pulumi.set(__self__, "column", column)
        pulumi.set(__self__, "sort_order", sort_order)

    @_builtins.property
    @pulumi.getter
    def column(self) -> _builtins.str:
        return pulumi.get(self, "column")

    @_builtins.property
    @pulumi.getter(name="sortOrder")
    def sort_order(self) -> _builtins.int:
        return pulumi.get(self, "sort_order")


@pulumi.output_type
class CatalogTableTargetTable(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "catalogId":
            suggest = "catalog_id"
        elif key == "databaseName":
            suggest = "database_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CatalogTableTargetTable. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CatalogTableTargetTable.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CatalogTableTargetTable.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 catalog_id: _builtins.str,
                 database_name: _builtins.str,
                 name: _builtins.str,
                 region: Optional[_builtins.str] = None):
        pulumi.set(__self__, "catalog_id", catalog_id)
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "name", name)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> _builtins.str:
        return pulumi.get(self, "catalog_id")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> _builtins.str:
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "region")


@pulumi.output_type
class ClassifierCsvClassifier(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowSingleColumn":
            suggest = "allow_single_column"
        elif key == "containsHeader":
            suggest = "contains_header"
        elif key == "customDatatypeConfigured":
            suggest = "custom_datatype_configured"
        elif key == "customDatatypes":
            suggest = "custom_datatypes"
        elif key == "disableValueTrimming":
            suggest = "disable_value_trimming"
        elif key == "quoteSymbol":
            suggest = "quote_symbol"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClassifierCsvClassifier. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClassifierCsvClassifier.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClassifierCsvClassifier.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_single_column: Optional[_builtins.bool] = None,
                 contains_header: Optional[_builtins.str] = None,
                 custom_datatype_configured: Optional[_builtins.bool] = None,
                 custom_datatypes: Optional[Sequence[_builtins.str]] = None,
                 delimiter: Optional[_builtins.str] = None,
                 disable_value_trimming: Optional[_builtins.bool] = None,
                 headers: Optional[Sequence[_builtins.str]] = None,
                 quote_symbol: Optional[_builtins.str] = None,
                 serde: Optional[_builtins.str] = None):
        if allow_single_column is not None:
            pulumi.set(__self__, "allow_single_column", allow_single_column)
        if contains_header is not None:
            pulumi.set(__self__, "contains_header", contains_header)
        if custom_datatype_configured is not None:
            pulumi.set(__self__, "custom_datatype_configured", custom_datatype_configured)
        if custom_datatypes is not None:
            pulumi.set(__self__, "custom_datatypes", custom_datatypes)
        if delimiter is not None:
            pulumi.set(__self__, "delimiter", delimiter)
        if disable_value_trimming is not None:
            pulumi.set(__self__, "disable_value_trimming", disable_value_trimming)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if quote_symbol is not None:
            pulumi.set(__self__, "quote_symbol", quote_symbol)
        if serde is not None:
            pulumi.set(__self__, "serde", serde)

    @_builtins.property
    @pulumi.getter(name="allowSingleColumn")
    def allow_single_column(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "allow_single_column")

    @_builtins.property
    @pulumi.getter(name="containsHeader")
    def contains_header(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "contains_header")

    @_builtins.property
    @pulumi.getter(name="customDatatypeConfigured")
    def custom_datatype_configured(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "custom_datatype_configured")

    @_builtins.property
    @pulumi.getter(name="customDatatypes")
    def custom_datatypes(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "custom_datatypes")

    @_builtins.property
    @pulumi.getter
    def delimiter(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "delimiter")

    @_builtins.property
    @pulumi.getter(name="disableValueTrimming")
    def disable_value_trimming(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "disable_value_trimming")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter(name="quoteSymbol")
    def quote_symbol(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "quote_symbol")

    @_builtins.property
    @pulumi.getter
    def serde(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "serde")


@pulumi.output_type
class ClassifierGrokClassifier(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "grokPattern":
            suggest = "grok_pattern"
        elif key == "customPatterns":
            suggest = "custom_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClassifierGrokClassifier. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClassifierGrokClassifier.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClassifierGrokClassifier.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 classification: _builtins.str,
                 grok_pattern: _builtins.str,
                 custom_patterns: Optional[_builtins.str] = None):
        pulumi.set(__self__, "classification", classification)
        pulumi.set(__self__, "grok_pattern", grok_pattern)
        if custom_patterns is not None:
            pulumi.set(__self__, "custom_patterns", custom_patterns)

    @_builtins.property
    @pulumi.getter
    def classification(self) -> _builtins.str:
        return pulumi.get(self, "classification")

    @_builtins.property
    @pulumi.getter(name="grokPattern")
    def grok_pattern(self) -> _builtins.str:
        return pulumi.get(self, "grok_pattern")

    @_builtins.property
    @pulumi.getter(name="customPatterns")
    def custom_patterns(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "custom_patterns")


@pulumi.output_type
class ClassifierJsonClassifier(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jsonPath":
            suggest = "json_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClassifierJsonClassifier. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClassifierJsonClassifier.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClassifierJsonClassifier.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 json_path: _builtins.str):
        pulumi.set(__self__, "json_path", json_path)

    @_builtins.property
    @pulumi.getter(name="jsonPath")
    def json_path(self) -> _builtins.str:
        return pulumi.get(self, "json_path")


@pulumi.output_type
class ClassifierXmlClassifier(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rowTag":
            suggest = "row_tag"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClassifierXmlClassifier. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClassifierXmlClassifier.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClassifierXmlClassifier.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 classification: _builtins.str,
                 row_tag: _builtins.str):
        pulumi.set(__self__, "classification", classification)
        pulumi.set(__self__, "row_tag", row_tag)

    @_builtins.property
    @pulumi.getter
    def classification(self) -> _builtins.str:
        return pulumi.get(self, "classification")

    @_builtins.property
    @pulumi.getter(name="rowTag")
    def row_tag(self) -> _builtins.str:
        return pulumi.get(self, "row_tag")


@pulumi.output_type
class ConnectionPhysicalConnectionRequirements(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "securityGroupIdLists":
            suggest = "security_group_id_lists"
        elif key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionPhysicalConnectionRequirements. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionPhysicalConnectionRequirements.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionPhysicalConnectionRequirements.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_zone: Optional[_builtins.str] = None,
                 security_group_id_lists: Optional[Sequence[_builtins.str]] = None,
                 subnet_id: Optional[_builtins.str] = None):
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if security_group_id_lists is not None:
            pulumi.set(__self__, "security_group_id_lists", security_group_id_lists)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "availability_zone")

    @_builtins.property
    @pulumi.getter(name="securityGroupIdLists")
    def security_group_id_lists(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "security_group_id_lists")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class CrawlerCatalogTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "connectionName":
            suggest = "connection_name"
        elif key == "dlqEventQueueArn":
            suggest = "dlq_event_queue_arn"
        elif key == "eventQueueArn":
            suggest = "event_queue_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CrawlerCatalogTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CrawlerCatalogTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CrawlerCatalogTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_name: _builtins.str,
                 tables: Sequence[_builtins.str],
                 connection_name: Optional[_builtins.str] = None,
                 dlq_event_queue_arn: Optional[_builtins.str] = None,
                 event_queue_arn: Optional[_builtins.str] = None):
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "tables", tables)
        if connection_name is not None:
            pulumi.set(__self__, "connection_name", connection_name)
        if dlq_event_queue_arn is not None:
            pulumi.set(__self__, "dlq_event_queue_arn", dlq_event_queue_arn)
        if event_queue_arn is not None:
            pulumi.set(__self__, "event_queue_arn", event_queue_arn)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> _builtins.str:
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter
    def tables(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "tables")

    @_builtins.property
    @pulumi.getter(name="connectionName")
    def connection_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "connection_name")

    @_builtins.property
    @pulumi.getter(name="dlqEventQueueArn")
    def dlq_event_queue_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "dlq_event_queue_arn")

    @_builtins.property
    @pulumi.getter(name="eventQueueArn")
    def event_queue_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "event_queue_arn")


@pulumi.output_type
class CrawlerDeltaTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deltaTables":
            suggest = "delta_tables"
        elif key == "writeManifest":
            suggest = "write_manifest"
        elif key == "connectionName":
            suggest = "connection_name"
        elif key == "createNativeDeltaTable":
            suggest = "create_native_delta_table"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CrawlerDeltaTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CrawlerDeltaTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CrawlerDeltaTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delta_tables: Sequence[_builtins.str],
                 write_manifest: _builtins.bool,
                 connection_name: Optional[_builtins.str] = None,
                 create_native_delta_table: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "delta_tables", delta_tables)
        pulumi.set(__self__, "write_manifest", write_manifest)
        if connection_name is not None:
            pulumi.set(__self__, "connection_name", connection_name)
        if create_native_delta_table is not None:
            pulumi.set(__self__, "create_native_delta_table", create_native_delta_table)

    @_builtins.property
    @pulumi.getter(name="deltaTables")
    def delta_tables(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "delta_tables")

    @_builtins.property
    @pulumi.getter(name="writeManifest")
    def write_manifest(self) -> _builtins.bool:
        return pulumi.get(self, "write_manifest")

    @_builtins.property
    @pulumi.getter(name="connectionName")
    def connection_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "connection_name")

    @_builtins.property
    @pulumi.getter(name="createNativeDeltaTable")
    def create_native_delta_table(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "create_native_delta_table")


@pulumi.output_type
class CrawlerDynamodbTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scanAll":
            suggest = "scan_all"
        elif key == "scanRate":
            suggest = "scan_rate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CrawlerDynamodbTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CrawlerDynamodbTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CrawlerDynamodbTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 scan_all: Optional[_builtins.bool] = None,
                 scan_rate: Optional[_builtins.float] = None):
        pulumi.set(__self__, "path", path)
        if scan_all is not None:
            pulumi.set(__self__, "scan_all", scan_all)
        if scan_rate is not None:
            pulumi.set(__self__, "scan_rate", scan_rate)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="scanAll")
    def scan_all(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "scan_all")

    @_builtins.property
    @pulumi.getter(name="scanRate")
    def scan_rate(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "scan_rate")


@pulumi.output_type
class CrawlerHudiTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maximumTraversalDepth":
            suggest = "maximum_traversal_depth"
        elif key == "connectionName":
            suggest = "connection_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CrawlerHudiTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CrawlerHudiTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CrawlerHudiTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 maximum_traversal_depth: _builtins.int,
                 paths: Sequence[_builtins.str],
                 connection_name: Optional[_builtins.str] = None,
                 exclusions: Optional[Sequence[_builtins.str]] = None):
        pulumi.set(__self__, "maximum_traversal_depth", maximum_traversal_depth)
        pulumi.set(__self__, "paths", paths)
        if connection_name is not None:
            pulumi.set(__self__, "connection_name", connection_name)
        if exclusions is not None:
            pulumi.set(__self__, "exclusions", exclusions)

    @_builtins.property
    @pulumi.getter(name="maximumTraversalDepth")
    def maximum_traversal_depth(self) -> _builtins.int:
        return pulumi.get(self, "maximum_traversal_depth")

    @_builtins.property
    @pulumi.getter
    def paths(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "paths")

    @_builtins.property
    @pulumi.getter(name="connectionName")
    def connection_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "connection_name")

    @_builtins.property
    @pulumi.getter
    def exclusions(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "exclusions")


@pulumi.output_type
class CrawlerIcebergTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maximumTraversalDepth":
            suggest = "maximum_traversal_depth"
        elif key == "connectionName":
            suggest = "connection_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CrawlerIcebergTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CrawlerIcebergTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CrawlerIcebergTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 maximum_traversal_depth: _builtins.int,
                 paths: Sequence[_builtins.str],
                 connection_name: Optional[_builtins.str] = None,
                 exclusions: Optional[Sequence[_builtins.str]] = None):
        pulumi.set(__self__, "maximum_traversal_depth", maximum_traversal_depth)
        pulumi.set(__self__, "paths", paths)
        if connection_name is not None:
            pulumi.set(__self__, "connection_name", connection_name)
        if exclusions is not None:
            pulumi.set(__self__, "exclusions", exclusions)

    @_builtins.property
    @pulumi.getter(name="maximumTraversalDepth")
    def maximum_traversal_depth(self) -> _builtins.int:
        return pulumi.get(self, "maximum_traversal_depth")

    @_builtins.property
    @pulumi.getter
    def paths(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "paths")

    @_builtins.property
    @pulumi.getter(name="connectionName")
    def connection_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "connection_name")

    @_builtins.property
    @pulumi.getter
    def exclusions(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "exclusions")


@pulumi.output_type
class CrawlerJdbcTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionName":
            suggest = "connection_name"
        elif key == "enableAdditionalMetadatas":
            suggest = "enable_additional_metadatas"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CrawlerJdbcTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CrawlerJdbcTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CrawlerJdbcTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_name: _builtins.str,
                 path: _builtins.str,
                 enable_additional_metadatas: Optional[Sequence[_builtins.str]] = None,
                 exclusions: Optional[Sequence[_builtins.str]] = None):
        pulumi.set(__self__, "connection_name", connection_name)
        pulumi.set(__self__, "path", path)
        if enable_additional_metadatas is not None:
            pulumi.set(__self__, "enable_additional_metadatas", enable_additional_metadatas)
        if exclusions is not None:
            pulumi.set(__self__, "exclusions", exclusions)

    @_builtins.property
    @pulumi.getter(name="connectionName")
    def connection_name(self) -> _builtins.str:
        return pulumi.get(self, "connection_name")

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="enableAdditionalMetadatas")
    def enable_additional_metadatas(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "enable_additional_metadatas")

    @_builtins.property
    @pulumi.getter
    def exclusions(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "exclusions")


@pulumi.output_type
class CrawlerLakeFormationConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountId":
            suggest = "account_id"
        elif key == "useLakeFormationCredentials":
            suggest = "use_lake_formation_credentials"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CrawlerLakeFormationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CrawlerLakeFormationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CrawlerLakeFormationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account_id: Optional[_builtins.str] = None,
                 use_lake_formation_credentials: Optional[_builtins.bool] = None):
        if account_id is not None:
            pulumi.set(__self__, "account_id", account_id)
        if use_lake_formation_credentials is not None:
            pulumi.set(__self__, "use_lake_formation_credentials", use_lake_formation_credentials)

    @_builtins.property
    @pulumi.getter(name="accountId")
    def account_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "account_id")

    @_builtins.property
    @pulumi.getter(name="useLakeFormationCredentials")
    def use_lake_formation_credentials(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "use_lake_formation_credentials")


@pulumi.output_type
class CrawlerLineageConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "crawlerLineageSettings":
            suggest = "crawler_lineage_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CrawlerLineageConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CrawlerLineageConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CrawlerLineageConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 crawler_lineage_settings: Optional[_builtins.str] = None):
        if crawler_lineage_settings is not None:
            pulumi.set(__self__, "crawler_lineage_settings", crawler_lineage_settings)

    @_builtins.property
    @pulumi.getter(name="crawlerLineageSettings")
    def crawler_lineage_settings(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "crawler_lineage_settings")


@pulumi.output_type
class CrawlerMongodbTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionName":
            suggest = "connection_name"
        elif key == "scanAll":
            suggest = "scan_all"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CrawlerMongodbTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CrawlerMongodbTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CrawlerMongodbTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_name: _builtins.str,
                 path: _builtins.str,
                 scan_all: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "connection_name", connection_name)
        pulumi.set(__self__, "path", path)
        if scan_all is not None:
            pulumi.set(__self__, "scan_all", scan_all)

    @_builtins.property
    @pulumi.getter(name="connectionName")
    def connection_name(self) -> _builtins.str:
        return pulumi.get(self, "connection_name")

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="scanAll")
    def scan_all(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "scan_all")


@pulumi.output_type
class CrawlerRecrawlPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "recrawlBehavior":
            suggest = "recrawl_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CrawlerRecrawlPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CrawlerRecrawlPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CrawlerRecrawlPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 recrawl_behavior: Optional[_builtins.str] = None):
        if recrawl_behavior is not None:
            pulumi.set(__self__, "recrawl_behavior", recrawl_behavior)

    @_builtins.property
    @pulumi.getter(name="recrawlBehavior")
    def recrawl_behavior(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "recrawl_behavior")


@pulumi.output_type
class CrawlerS3Target(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionName":
            suggest = "connection_name"
        elif key == "dlqEventQueueArn":
            suggest = "dlq_event_queue_arn"
        elif key == "eventQueueArn":
            suggest = "event_queue_arn"
        elif key == "sampleSize":
            suggest = "sample_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CrawlerS3Target. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CrawlerS3Target.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CrawlerS3Target.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 connection_name: Optional[_builtins.str] = None,
                 dlq_event_queue_arn: Optional[_builtins.str] = None,
                 event_queue_arn: Optional[_builtins.str] = None,
                 exclusions: Optional[Sequence[_builtins.str]] = None,
                 sample_size: Optional[_builtins.int] = None):
        pulumi.set(__self__, "path", path)
        if connection_name is not None:
            pulumi.set(__self__, "connection_name", connection_name)
        if dlq_event_queue_arn is not None:
            pulumi.set(__self__, "dlq_event_queue_arn", dlq_event_queue_arn)
        if event_queue_arn is not None:
            pulumi.set(__self__, "event_queue_arn", event_queue_arn)
        if exclusions is not None:
            pulumi.set(__self__, "exclusions", exclusions)
        if sample_size is not None:
            pulumi.set(__self__, "sample_size", sample_size)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="connectionName")
    def connection_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "connection_name")

    @_builtins.property
    @pulumi.getter(name="dlqEventQueueArn")
    def dlq_event_queue_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "dlq_event_queue_arn")

    @_builtins.property
    @pulumi.getter(name="eventQueueArn")
    def event_queue_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "event_queue_arn")

    @_builtins.property
    @pulumi.getter
    def exclusions(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "exclusions")

    @_builtins.property
    @pulumi.getter(name="sampleSize")
    def sample_size(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "sample_size")


@pulumi.output_type
class CrawlerSchemaChangePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteBehavior":
            suggest = "delete_behavior"
        elif key == "updateBehavior":
            suggest = "update_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CrawlerSchemaChangePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CrawlerSchemaChangePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CrawlerSchemaChangePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delete_behavior: Optional[_builtins.str] = None,
                 update_behavior: Optional[_builtins.str] = None):
        if delete_behavior is not None:
            pulumi.set(__self__, "delete_behavior", delete_behavior)
        if update_behavior is not None:
            pulumi.set(__self__, "update_behavior", update_behavior)

    @_builtins.property
    @pulumi.getter(name="deleteBehavior")
    def delete_behavior(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "delete_behavior")

    @_builtins.property
    @pulumi.getter(name="updateBehavior")
    def update_behavior(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "update_behavior")


@pulumi.output_type
class DataCatalogEncryptionSettingsDataCatalogEncryptionSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionPasswordEncryption":
            suggest = "connection_password_encryption"
        elif key == "encryptionAtRest":
            suggest = "encryption_at_rest"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataCatalogEncryptionSettingsDataCatalogEncryptionSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataCatalogEncryptionSettingsDataCatalogEncryptionSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataCatalogEncryptionSettingsDataCatalogEncryptionSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_password_encryption: 'outputs.DataCatalogEncryptionSettingsDataCatalogEncryptionSettingsConnectionPasswordEncryption',
                 encryption_at_rest: 'outputs.DataCatalogEncryptionSettingsDataCatalogEncryptionSettingsEncryptionAtRest'):
        pulumi.set(__self__, "connection_password_encryption", connection_password_encryption)
        pulumi.set(__self__, "encryption_at_rest", encryption_at_rest)

    @_builtins.property
    @pulumi.getter(name="connectionPasswordEncryption")
    def connection_password_encryption(self) -> 'outputs.DataCatalogEncryptionSettingsDataCatalogEncryptionSettingsConnectionPasswordEncryption':
        return pulumi.get(self, "connection_password_encryption")

    @_builtins.property
    @pulumi.getter(name="encryptionAtRest")
    def encryption_at_rest(self) -> 'outputs.DataCatalogEncryptionSettingsDataCatalogEncryptionSettingsEncryptionAtRest':
        return pulumi.get(self, "encryption_at_rest")


@pulumi.output_type
class DataCatalogEncryptionSettingsDataCatalogEncryptionSettingsConnectionPasswordEncryption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "returnConnectionPasswordEncrypted":
            suggest = "return_connection_password_encrypted"
        elif key == "awsKmsKeyId":
            suggest = "aws_kms_key_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataCatalogEncryptionSettingsDataCatalogEncryptionSettingsConnectionPasswordEncryption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataCatalogEncryptionSettingsDataCatalogEncryptionSettingsConnectionPasswordEncryption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataCatalogEncryptionSettingsDataCatalogEncryptionSettingsConnectionPasswordEncryption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 return_connection_password_encrypted: _builtins.bool,
                 aws_kms_key_id: Optional[_builtins.str] = None):
        pulumi.set(__self__, "return_connection_password_encrypted", return_connection_password_encrypted)
        if aws_kms_key_id is not None:
            pulumi.set(__self__, "aws_kms_key_id", aws_kms_key_id)

    @_builtins.property
    @pulumi.getter(name="returnConnectionPasswordEncrypted")
    def return_connection_password_encrypted(self) -> _builtins.bool:
        return pulumi.get(self, "return_connection_password_encrypted")

    @_builtins.property
    @pulumi.getter(name="awsKmsKeyId")
    def aws_kms_key_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "aws_kms_key_id")


@pulumi.output_type
class DataCatalogEncryptionSettingsDataCatalogEncryptionSettingsEncryptionAtRest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "catalogEncryptionMode":
            suggest = "catalog_encryption_mode"
        elif key == "catalogEncryptionServiceRole":
            suggest = "catalog_encryption_service_role"
        elif key == "sseAwsKmsKeyId":
            suggest = "sse_aws_kms_key_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataCatalogEncryptionSettingsDataCatalogEncryptionSettingsEncryptionAtRest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataCatalogEncryptionSettingsDataCatalogEncryptionSettingsEncryptionAtRest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataCatalogEncryptionSettingsDataCatalogEncryptionSettingsEncryptionAtRest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 catalog_encryption_mode: _builtins.str,
                 catalog_encryption_service_role: Optional[_builtins.str] = None,
                 sse_aws_kms_key_id: Optional[_builtins.str] = None):
        pulumi.set(__self__, "catalog_encryption_mode", catalog_encryption_mode)
        if catalog_encryption_service_role is not None:
            pulumi.set(__self__, "catalog_encryption_service_role", catalog_encryption_service_role)
        if sse_aws_kms_key_id is not None:
            pulumi.set(__self__, "sse_aws_kms_key_id", sse_aws_kms_key_id)

    @_builtins.property
    @pulumi.getter(name="catalogEncryptionMode")
    def catalog_encryption_mode(self) -> _builtins.str:
        return pulumi.get(self, "catalog_encryption_mode")

    @_builtins.property
    @pulumi.getter(name="catalogEncryptionServiceRole")
    def catalog_encryption_service_role(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "catalog_encryption_service_role")

    @_builtins.property
    @pulumi.getter(name="sseAwsKmsKeyId")
    def sse_aws_kms_key_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sse_aws_kms_key_id")


@pulumi.output_type
class DataQualityRulesetTargetTable(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "tableName":
            suggest = "table_name"
        elif key == "catalogId":
            suggest = "catalog_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataQualityRulesetTargetTable. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataQualityRulesetTargetTable.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataQualityRulesetTargetTable.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_name: _builtins.str,
                 table_name: _builtins.str,
                 catalog_id: Optional[_builtins.str] = None):
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "table_name", table_name)
        if catalog_id is not None:
            pulumi.set(__self__, "catalog_id", catalog_id)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> _builtins.str:
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="tableName")
    def table_name(self) -> _builtins.str:
        return pulumi.get(self, "table_name")

    @_builtins.property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "catalog_id")


@pulumi.output_type
class JobCommand(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scriptLocation":
            suggest = "script_location"
        elif key == "pythonVersion":
            suggest = "python_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobCommand. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobCommand.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobCommand.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 script_location: _builtins.str,
                 name: Optional[_builtins.str] = None,
                 python_version: Optional[_builtins.str] = None,
                 runtime: Optional[_builtins.str] = None):
        pulumi.set(__self__, "script_location", script_location)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if python_version is not None:
            pulumi.set(__self__, "python_version", python_version)
        if runtime is not None:
            pulumi.set(__self__, "runtime", runtime)

    @_builtins.property
    @pulumi.getter(name="scriptLocation")
    def script_location(self) -> _builtins.str:
        return pulumi.get(self, "script_location")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="pythonVersion")
    def python_version(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "python_version")

    @_builtins.property
    @pulumi.getter
    def runtime(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "runtime")


@pulumi.output_type
class JobExecutionProperty(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxConcurrentRuns":
            suggest = "max_concurrent_runs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobExecutionProperty. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobExecutionProperty.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobExecutionProperty.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_concurrent_runs: Optional[_builtins.int] = None):
        if max_concurrent_runs is not None:
            pulumi.set(__self__, "max_concurrent_runs", max_concurrent_runs)

    @_builtins.property
    @pulumi.getter(name="maxConcurrentRuns")
    def max_concurrent_runs(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max_concurrent_runs")


@pulumi.output_type
class JobNotificationProperty(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "notifyDelayAfter":
            suggest = "notify_delay_after"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobNotificationProperty. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobNotificationProperty.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobNotificationProperty.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 notify_delay_after: Optional[_builtins.int] = None):
        if notify_delay_after is not None:
            pulumi.set(__self__, "notify_delay_after", notify_delay_after)

    @_builtins.property
    @pulumi.getter(name="notifyDelayAfter")
    def notify_delay_after(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "notify_delay_after")


@pulumi.output_type
class JobSourceControlDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authStrategy":
            suggest = "auth_strategy"
        elif key == "authToken":
            suggest = "auth_token"
        elif key == "lastCommitId":
            suggest = "last_commit_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobSourceControlDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobSourceControlDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobSourceControlDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_strategy: Optional[_builtins.str] = None,
                 auth_token: Optional[_builtins.str] = None,
                 branch: Optional[_builtins.str] = None,
                 folder: Optional[_builtins.str] = None,
                 last_commit_id: Optional[_builtins.str] = None,
                 owner: Optional[_builtins.str] = None,
                 provider: Optional[_builtins.str] = None,
                 repository: Optional[_builtins.str] = None):
        if auth_strategy is not None:
            pulumi.set(__self__, "auth_strategy", auth_strategy)
        if auth_token is not None:
            pulumi.set(__self__, "auth_token", auth_token)
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if last_commit_id is not None:
            pulumi.set(__self__, "last_commit_id", last_commit_id)
        if owner is not None:
            pulumi.set(__self__, "owner", owner)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if repository is not None:
            pulumi.set(__self__, "repository", repository)

    @_builtins.property
    @pulumi.getter(name="authStrategy")
    def auth_strategy(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "auth_strategy")

    @_builtins.property
    @pulumi.getter(name="authToken")
    def auth_token(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "auth_token")

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "branch")

    @_builtins.property
    @pulumi.getter
    def folder(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "folder")

    @_builtins.property
    @pulumi.getter(name="lastCommitId")
    def last_commit_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "last_commit_id")

    @_builtins.property
    @pulumi.getter
    def owner(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "owner")

    @_builtins.property
    @pulumi.getter
    def provider(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "provider")

    @_builtins.property
    @pulumi.getter
    def repository(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "repository")


@pulumi.output_type
class MLTransformInputRecordTable(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "tableName":
            suggest = "table_name"
        elif key == "catalogId":
            suggest = "catalog_id"
        elif key == "connectionName":
            suggest = "connection_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MLTransformInputRecordTable. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MLTransformInputRecordTable.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MLTransformInputRecordTable.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_name: _builtins.str,
                 table_name: _builtins.str,
                 catalog_id: Optional[_builtins.str] = None,
                 connection_name: Optional[_builtins.str] = None):
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "table_name", table_name)
        if catalog_id is not None:
            pulumi.set(__self__, "catalog_id", catalog_id)
        if connection_name is not None:
            pulumi.set(__self__, "connection_name", connection_name)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> _builtins.str:
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="tableName")
    def table_name(self) -> _builtins.str:
        return pulumi.get(self, "table_name")

    @_builtins.property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "catalog_id")

    @_builtins.property
    @pulumi.getter(name="connectionName")
    def connection_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "connection_name")


@pulumi.output_type
class MLTransformParameters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "findMatchesParameters":
            suggest = "find_matches_parameters"
        elif key == "transformType":
            suggest = "transform_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MLTransformParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MLTransformParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MLTransformParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 find_matches_parameters: 'outputs.MLTransformParametersFindMatchesParameters',
                 transform_type: _builtins.str):
        pulumi.set(__self__, "find_matches_parameters", find_matches_parameters)
        pulumi.set(__self__, "transform_type", transform_type)

    @_builtins.property
    @pulumi.getter(name="findMatchesParameters")
    def find_matches_parameters(self) -> 'outputs.MLTransformParametersFindMatchesParameters':
        return pulumi.get(self, "find_matches_parameters")

    @_builtins.property
    @pulumi.getter(name="transformType")
    def transform_type(self) -> _builtins.str:
        return pulumi.get(self, "transform_type")


@pulumi.output_type
class MLTransformParametersFindMatchesParameters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accuracyCostTradeOff":
            suggest = "accuracy_cost_trade_off"
        elif key == "enforceProvidedLabels":
            suggest = "enforce_provided_labels"
        elif key == "precisionRecallTradeOff":
            suggest = "precision_recall_trade_off"
        elif key == "primaryKeyColumnName":
            suggest = "primary_key_column_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MLTransformParametersFindMatchesParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MLTransformParametersFindMatchesParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MLTransformParametersFindMatchesParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 accuracy_cost_trade_off: Optional[_builtins.float] = None,
                 enforce_provided_labels: Optional[_builtins.bool] = None,
                 precision_recall_trade_off: Optional[_builtins.float] = None,
                 primary_key_column_name: Optional[_builtins.str] = None):
        if accuracy_cost_trade_off is not None:
            pulumi.set(__self__, "accuracy_cost_trade_off", accuracy_cost_trade_off)
        if enforce_provided_labels is not None:
            pulumi.set(__self__, "enforce_provided_labels", enforce_provided_labels)
        if precision_recall_trade_off is not None:
            pulumi.set(__self__, "precision_recall_trade_off", precision_recall_trade_off)
        if primary_key_column_name is not None:
            pulumi.set(__self__, "primary_key_column_name", primary_key_column_name)

    @_builtins.property
    @pulumi.getter(name="accuracyCostTradeOff")
    def accuracy_cost_trade_off(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "accuracy_cost_trade_off")

    @_builtins.property
    @pulumi.getter(name="enforceProvidedLabels")
    def enforce_provided_labels(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enforce_provided_labels")

    @_builtins.property
    @pulumi.getter(name="precisionRecallTradeOff")
    def precision_recall_trade_off(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "precision_recall_trade_off")

    @_builtins.property
    @pulumi.getter(name="primaryKeyColumnName")
    def primary_key_column_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "primary_key_column_name")


@pulumi.output_type
class MLTransformSchema(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataType":
            suggest = "data_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MLTransformSchema. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MLTransformSchema.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MLTransformSchema.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_type: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        if data_type is not None:
            pulumi.set(__self__, "data_type", data_type)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "data_type")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class PartitionIndexPartitionIndex(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "indexName":
            suggest = "index_name"
        elif key == "indexStatus":
            suggest = "index_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PartitionIndexPartitionIndex. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PartitionIndexPartitionIndex.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PartitionIndexPartitionIndex.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index_name: Optional[_builtins.str] = None,
                 index_status: Optional[_builtins.str] = None,
                 keys: Optional[Sequence[_builtins.str]] = None):
        if index_name is not None:
            pulumi.set(__self__, "index_name", index_name)
        if index_status is not None:
            pulumi.set(__self__, "index_status", index_status)
        if keys is not None:
            pulumi.set(__self__, "keys", keys)

    @_builtins.property
    @pulumi.getter(name="indexName")
    def index_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "index_name")

    @_builtins.property
    @pulumi.getter(name="indexStatus")
    def index_status(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "index_status")

    @_builtins.property
    @pulumi.getter
    def keys(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "keys")


@pulumi.output_type
class PartitionStorageDescriptor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalLocations":
            suggest = "additional_locations"
        elif key == "bucketColumns":
            suggest = "bucket_columns"
        elif key == "inputFormat":
            suggest = "input_format"
        elif key == "numberOfBuckets":
            suggest = "number_of_buckets"
        elif key == "outputFormat":
            suggest = "output_format"
        elif key == "serDeInfo":
            suggest = "ser_de_info"
        elif key == "skewedInfo":
            suggest = "skewed_info"
        elif key == "sortColumns":
            suggest = "sort_columns"
        elif key == "storedAsSubDirectories":
            suggest = "stored_as_sub_directories"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PartitionStorageDescriptor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PartitionStorageDescriptor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PartitionStorageDescriptor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_locations: Optional[Sequence[_builtins.str]] = None,
                 bucket_columns: Optional[Sequence[_builtins.str]] = None,
                 columns: Optional[Sequence['outputs.PartitionStorageDescriptorColumn']] = None,
                 compressed: Optional[_builtins.bool] = None,
                 input_format: Optional[_builtins.str] = None,
                 location: Optional[_builtins.str] = None,
                 number_of_buckets: Optional[_builtins.int] = None,
                 output_format: Optional[_builtins.str] = None,
                 parameters: Optional[Mapping[str, _builtins.str]] = None,
                 ser_de_info: Optional['outputs.PartitionStorageDescriptorSerDeInfo'] = None,
                 skewed_info: Optional['outputs.PartitionStorageDescriptorSkewedInfo'] = None,
                 sort_columns: Optional[Sequence['outputs.PartitionStorageDescriptorSortColumn']] = None,
                 stored_as_sub_directories: Optional[_builtins.bool] = None):
        if additional_locations is not None:
            pulumi.set(__self__, "additional_locations", additional_locations)
        if bucket_columns is not None:
            pulumi.set(__self__, "bucket_columns", bucket_columns)
        if columns is not None:
            pulumi.set(__self__, "columns", columns)
        if compressed is not None:
            pulumi.set(__self__, "compressed", compressed)
        if input_format is not None:
            pulumi.set(__self__, "input_format", input_format)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if number_of_buckets is not None:
            pulumi.set(__self__, "number_of_buckets", number_of_buckets)
        if output_format is not None:
            pulumi.set(__self__, "output_format", output_format)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if ser_de_info is not None:
            pulumi.set(__self__, "ser_de_info", ser_de_info)
        if skewed_info is not None:
            pulumi.set(__self__, "skewed_info", skewed_info)
        if sort_columns is not None:
            pulumi.set(__self__, "sort_columns", sort_columns)
        if stored_as_sub_directories is not None:
            pulumi.set(__self__, "stored_as_sub_directories", stored_as_sub_directories)

    @_builtins.property
    @pulumi.getter(name="additionalLocations")
    def additional_locations(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "additional_locations")

    @_builtins.property
    @pulumi.getter(name="bucketColumns")
    def bucket_columns(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "bucket_columns")

    @_builtins.property
    @pulumi.getter
    def columns(self) -> Optional[Sequence['outputs.PartitionStorageDescriptorColumn']]:
        return pulumi.get(self, "columns")

    @_builtins.property
    @pulumi.getter
    def compressed(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "compressed")

    @_builtins.property
    @pulumi.getter(name="inputFormat")
    def input_format(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "input_format")

    @_builtins.property
    @pulumi.getter
    def location(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "location")

    @_builtins.property
    @pulumi.getter(name="numberOfBuckets")
    def number_of_buckets(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "number_of_buckets")

    @_builtins.property
    @pulumi.getter(name="outputFormat")
    def output_format(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "output_format")

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "parameters")

    @_builtins.property
    @pulumi.getter(name="serDeInfo")
    def ser_de_info(self) -> Optional['outputs.PartitionStorageDescriptorSerDeInfo']:
        return pulumi.get(self, "ser_de_info")

    @_builtins.property
    @pulumi.getter(name="skewedInfo")
    def skewed_info(self) -> Optional['outputs.PartitionStorageDescriptorSkewedInfo']:
        return pulumi.get(self, "skewed_info")

    @_builtins.property
    @pulumi.getter(name="sortColumns")
    def sort_columns(self) -> Optional[Sequence['outputs.PartitionStorageDescriptorSortColumn']]:
        return pulumi.get(self, "sort_columns")

    @_builtins.property
    @pulumi.getter(name="storedAsSubDirectories")
    def stored_as_sub_directories(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "stored_as_sub_directories")


@pulumi.output_type
class PartitionStorageDescriptorColumn(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 comment: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        pulumi.set(__self__, "name", name)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "comment")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class PartitionStorageDescriptorSerDeInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serializationLibrary":
            suggest = "serialization_library"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PartitionStorageDescriptorSerDeInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PartitionStorageDescriptorSerDeInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PartitionStorageDescriptorSerDeInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 parameters: Optional[Mapping[str, _builtins.str]] = None,
                 serialization_library: Optional[_builtins.str] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if serialization_library is not None:
            pulumi.set(__self__, "serialization_library", serialization_library)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "parameters")

    @_builtins.property
    @pulumi.getter(name="serializationLibrary")
    def serialization_library(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "serialization_library")


@pulumi.output_type
class PartitionStorageDescriptorSkewedInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "skewedColumnNames":
            suggest = "skewed_column_names"
        elif key == "skewedColumnValueLocationMaps":
            suggest = "skewed_column_value_location_maps"
        elif key == "skewedColumnValues":
            suggest = "skewed_column_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PartitionStorageDescriptorSkewedInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PartitionStorageDescriptorSkewedInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PartitionStorageDescriptorSkewedInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 skewed_column_names: Optional[Sequence[_builtins.str]] = None,
                 skewed_column_value_location_maps: Optional[Mapping[str, _builtins.str]] = None,
                 skewed_column_values: Optional[Sequence[_builtins.str]] = None):
        if skewed_column_names is not None:
            pulumi.set(__self__, "skewed_column_names", skewed_column_names)
        if skewed_column_value_location_maps is not None:
            pulumi.set(__self__, "skewed_column_value_location_maps", skewed_column_value_location_maps)
        if skewed_column_values is not None:
            pulumi.set(__self__, "skewed_column_values", skewed_column_values)

    @_builtins.property
    @pulumi.getter(name="skewedColumnNames")
    def skewed_column_names(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "skewed_column_names")

    @_builtins.property
    @pulumi.getter(name="skewedColumnValueLocationMaps")
    def skewed_column_value_location_maps(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "skewed_column_value_location_maps")

    @_builtins.property
    @pulumi.getter(name="skewedColumnValues")
    def skewed_column_values(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "skewed_column_values")


@pulumi.output_type
class PartitionStorageDescriptorSortColumn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortOrder":
            suggest = "sort_order"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PartitionStorageDescriptorSortColumn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PartitionStorageDescriptorSortColumn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PartitionStorageDescriptorSortColumn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: _builtins.str,
                 sort_order: _builtins.int):
        pulumi.set(__self__, "column", column)
        pulumi.set(__self__, "sort_order", sort_order)

    @_builtins.property
    @pulumi.getter
    def column(self) -> _builtins.str:
        return pulumi.get(self, "column")

    @_builtins.property
    @pulumi.getter(name="sortOrder")
    def sort_order(self) -> _builtins.int:
        return pulumi.get(self, "sort_order")


@pulumi.output_type
class SecurityConfigurationEncryptionConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudwatchEncryption":
            suggest = "cloudwatch_encryption"
        elif key == "jobBookmarksEncryption":
            suggest = "job_bookmarks_encryption"
        elif key == "s3Encryption":
            suggest = "s3_encryption"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityConfigurationEncryptionConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityConfigurationEncryptionConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityConfigurationEncryptionConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloudwatch_encryption: 'outputs.SecurityConfigurationEncryptionConfigurationCloudwatchEncryption',
                 job_bookmarks_encryption: 'outputs.SecurityConfigurationEncryptionConfigurationJobBookmarksEncryption',
                 s3_encryption: 'outputs.SecurityConfigurationEncryptionConfigurationS3Encryption'):
        pulumi.set(__self__, "cloudwatch_encryption", cloudwatch_encryption)
        pulumi.set(__self__, "job_bookmarks_encryption", job_bookmarks_encryption)
        pulumi.set(__self__, "s3_encryption", s3_encryption)

    @_builtins.property
    @pulumi.getter(name="cloudwatchEncryption")
    def cloudwatch_encryption(self) -> 'outputs.SecurityConfigurationEncryptionConfigurationCloudwatchEncryption':
        return pulumi.get(self, "cloudwatch_encryption")

    @_builtins.property
    @pulumi.getter(name="jobBookmarksEncryption")
    def job_bookmarks_encryption(self) -> 'outputs.SecurityConfigurationEncryptionConfigurationJobBookmarksEncryption':
        return pulumi.get(self, "job_bookmarks_encryption")

    @_builtins.property
    @pulumi.getter(name="s3Encryption")
    def s3_encryption(self) -> 'outputs.SecurityConfigurationEncryptionConfigurationS3Encryption':
        return pulumi.get(self, "s3_encryption")


@pulumi.output_type
class SecurityConfigurationEncryptionConfigurationCloudwatchEncryption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudwatchEncryptionMode":
            suggest = "cloudwatch_encryption_mode"
        elif key == "kmsKeyArn":
            suggest = "kms_key_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityConfigurationEncryptionConfigurationCloudwatchEncryption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityConfigurationEncryptionConfigurationCloudwatchEncryption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityConfigurationEncryptionConfigurationCloudwatchEncryption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloudwatch_encryption_mode: Optional[_builtins.str] = None,
                 kms_key_arn: Optional[_builtins.str] = None):
        if cloudwatch_encryption_mode is not None:
            pulumi.set(__self__, "cloudwatch_encryption_mode", cloudwatch_encryption_mode)
        if kms_key_arn is not None:
            pulumi.set(__self__, "kms_key_arn", kms_key_arn)

    @_builtins.property
    @pulumi.getter(name="cloudwatchEncryptionMode")
    def cloudwatch_encryption_mode(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cloudwatch_encryption_mode")

    @_builtins.property
    @pulumi.getter(name="kmsKeyArn")
    def kms_key_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "kms_key_arn")


@pulumi.output_type
class SecurityConfigurationEncryptionConfigurationJobBookmarksEncryption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jobBookmarksEncryptionMode":
            suggest = "job_bookmarks_encryption_mode"
        elif key == "kmsKeyArn":
            suggest = "kms_key_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityConfigurationEncryptionConfigurationJobBookmarksEncryption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityConfigurationEncryptionConfigurationJobBookmarksEncryption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityConfigurationEncryptionConfigurationJobBookmarksEncryption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 job_bookmarks_encryption_mode: Optional[_builtins.str] = None,
                 kms_key_arn: Optional[_builtins.str] = None):
        if job_bookmarks_encryption_mode is not None:
            pulumi.set(__self__, "job_bookmarks_encryption_mode", job_bookmarks_encryption_mode)
        if kms_key_arn is not None:
            pulumi.set(__self__, "kms_key_arn", kms_key_arn)

    @_builtins.property
    @pulumi.getter(name="jobBookmarksEncryptionMode")
    def job_bookmarks_encryption_mode(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "job_bookmarks_encryption_mode")

    @_builtins.property
    @pulumi.getter(name="kmsKeyArn")
    def kms_key_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "kms_key_arn")


@pulumi.output_type
class SecurityConfigurationEncryptionConfigurationS3Encryption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kmsKeyArn":
            suggest = "kms_key_arn"
        elif key == "s3EncryptionMode":
            suggest = "s3_encryption_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityConfigurationEncryptionConfigurationS3Encryption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityConfigurationEncryptionConfigurationS3Encryption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityConfigurationEncryptionConfigurationS3Encryption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kms_key_arn: Optional[_builtins.str] = None,
                 s3_encryption_mode: Optional[_builtins.str] = None):
        if kms_key_arn is not None:
            pulumi.set(__self__, "kms_key_arn", kms_key_arn)
        if s3_encryption_mode is not None:
            pulumi.set(__self__, "s3_encryption_mode", s3_encryption_mode)

    @_builtins.property
    @pulumi.getter(name="kmsKeyArn")
    def kms_key_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "kms_key_arn")

    @_builtins.property
    @pulumi.getter(name="s3EncryptionMode")
    def s3_encryption_mode(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "s3_encryption_mode")


@pulumi.output_type
class TriggerAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "crawlerName":
            suggest = "crawler_name"
        elif key == "jobName":
            suggest = "job_name"
        elif key == "notificationProperty":
            suggest = "notification_property"
        elif key == "securityConfiguration":
            suggest = "security_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TriggerAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TriggerAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TriggerAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arguments: Optional[Mapping[str, _builtins.str]] = None,
                 crawler_name: Optional[_builtins.str] = None,
                 job_name: Optional[_builtins.str] = None,
                 notification_property: Optional['outputs.TriggerActionNotificationProperty'] = None,
                 security_configuration: Optional[_builtins.str] = None,
                 timeout: Optional[_builtins.int] = None):
        if arguments is not None:
            pulumi.set(__self__, "arguments", arguments)
        if crawler_name is not None:
            pulumi.set(__self__, "crawler_name", crawler_name)
        if job_name is not None:
            pulumi.set(__self__, "job_name", job_name)
        if notification_property is not None:
            pulumi.set(__self__, "notification_property", notification_property)
        if security_configuration is not None:
            pulumi.set(__self__, "security_configuration", security_configuration)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def arguments(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "arguments")

    @_builtins.property
    @pulumi.getter(name="crawlerName")
    def crawler_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "crawler_name")

    @_builtins.property
    @pulumi.getter(name="jobName")
    def job_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "job_name")

    @_builtins.property
    @pulumi.getter(name="notificationProperty")
    def notification_property(self) -> Optional['outputs.TriggerActionNotificationProperty']:
        return pulumi.get(self, "notification_property")

    @_builtins.property
    @pulumi.getter(name="securityConfiguration")
    def security_configuration(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "security_configuration")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "timeout")


@pulumi.output_type
class TriggerActionNotificationProperty(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "notifyDelayAfter":
            suggest = "notify_delay_after"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TriggerActionNotificationProperty. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TriggerActionNotificationProperty.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TriggerActionNotificationProperty.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 notify_delay_after: Optional[_builtins.int] = None):
        if notify_delay_after is not None:
            pulumi.set(__self__, "notify_delay_after", notify_delay_after)

    @_builtins.property
    @pulumi.getter(name="notifyDelayAfter")
    def notify_delay_after(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "notify_delay_after")


@pulumi.output_type
class TriggerEventBatchingCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "batchSize":
            suggest = "batch_size"
        elif key == "batchWindow":
            suggest = "batch_window"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TriggerEventBatchingCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TriggerEventBatchingCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TriggerEventBatchingCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 batch_size: _builtins.int,
                 batch_window: Optional[_builtins.int] = None):
        pulumi.set(__self__, "batch_size", batch_size)
        if batch_window is not None:
            pulumi.set(__self__, "batch_window", batch_window)

    @_builtins.property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> _builtins.int:
        return pulumi.get(self, "batch_size")

    @_builtins.property
    @pulumi.getter(name="batchWindow")
    def batch_window(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "batch_window")


@pulumi.output_type
class TriggerPredicate(dict):
    def __init__(__self__, *,
                 conditions: Sequence['outputs.TriggerPredicateCondition'],
                 logical: Optional[_builtins.str] = None):
        pulumi.set(__self__, "conditions", conditions)
        if logical is not None:
            pulumi.set(__self__, "logical", logical)

    @_builtins.property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.TriggerPredicateCondition']:
        return pulumi.get(self, "conditions")

    @_builtins.property
    @pulumi.getter
    def logical(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "logical")


@pulumi.output_type
class TriggerPredicateCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "crawlState":
            suggest = "crawl_state"
        elif key == "crawlerName":
            suggest = "crawler_name"
        elif key == "jobName":
            suggest = "job_name"
        elif key == "logicalOperator":
            suggest = "logical_operator"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TriggerPredicateCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TriggerPredicateCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TriggerPredicateCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 crawl_state: Optional[_builtins.str] = None,
                 crawler_name: Optional[_builtins.str] = None,
                 job_name: Optional[_builtins.str] = None,
                 logical_operator: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None):
        if crawl_state is not None:
            pulumi.set(__self__, "crawl_state", crawl_state)
        if crawler_name is not None:
            pulumi.set(__self__, "crawler_name", crawler_name)
        if job_name is not None:
            pulumi.set(__self__, "job_name", job_name)
        if logical_operator is not None:
            pulumi.set(__self__, "logical_operator", logical_operator)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="crawlState")
    def crawl_state(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "crawl_state")

    @_builtins.property
    @pulumi.getter(name="crawlerName")
    def crawler_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "crawler_name")

    @_builtins.property
    @pulumi.getter(name="jobName")
    def job_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "job_name")

    @_builtins.property
    @pulumi.getter(name="logicalOperator")
    def logical_operator(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "logical_operator")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "state")


@pulumi.output_type
class UserDefinedFunctionResourceUri(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceType":
            suggest = "resource_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserDefinedFunctionResourceUri. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserDefinedFunctionResourceUri.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserDefinedFunctionResourceUri.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_type: _builtins.str,
                 uri: _builtins.str):
        pulumi.set(__self__, "resource_type", resource_type)
        pulumi.set(__self__, "uri", uri)

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> _builtins.str:
        return pulumi.get(self, "resource_type")

    @_builtins.property
    @pulumi.getter
    def uri(self) -> _builtins.str:
        return pulumi.get(self, "uri")


@pulumi.output_type
class GetCatalogTablePartitionIndexResult(dict):
    def __init__(__self__, *,
                 index_name: _builtins.str,
                 index_status: _builtins.str,
                 keys: Sequence[_builtins.str]):
        pulumi.set(__self__, "index_name", index_name)
        pulumi.set(__self__, "index_status", index_status)
        pulumi.set(__self__, "keys", keys)

    @_builtins.property
    @pulumi.getter(name="indexName")
    def index_name(self) -> _builtins.str:
        return pulumi.get(self, "index_name")

    @_builtins.property
    @pulumi.getter(name="indexStatus")
    def index_status(self) -> _builtins.str:
        return pulumi.get(self, "index_status")

    @_builtins.property
    @pulumi.getter
    def keys(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "keys")


@pulumi.output_type
class GetCatalogTablePartitionKeyResult(dict):
    def __init__(__self__, *,
                 comment: _builtins.str,
                 name: _builtins.str,
                 parameters: Mapping[str, _builtins.str],
                 type: _builtins.str):
        pulumi.set(__self__, "comment", comment)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "parameters", parameters)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> _builtins.str:
        return pulumi.get(self, "comment")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "parameters")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetCatalogTableStorageDescriptorResult(dict):
    def __init__(__self__, *,
                 additional_locations: Sequence[_builtins.str],
                 bucket_columns: Sequence[_builtins.str],
                 columns: Sequence['outputs.GetCatalogTableStorageDescriptorColumnResult'],
                 compressed: _builtins.bool,
                 input_format: _builtins.str,
                 location: _builtins.str,
                 number_of_buckets: _builtins.int,
                 output_format: _builtins.str,
                 parameters: Mapping[str, _builtins.str],
                 schema_references: Sequence['outputs.GetCatalogTableStorageDescriptorSchemaReferenceResult'],
                 ser_de_infos: Sequence['outputs.GetCatalogTableStorageDescriptorSerDeInfoResult'],
                 skewed_infos: Sequence['outputs.GetCatalogTableStorageDescriptorSkewedInfoResult'],
                 sort_columns: Sequence['outputs.GetCatalogTableStorageDescriptorSortColumnResult'],
                 stored_as_sub_directories: _builtins.bool):
        pulumi.set(__self__, "additional_locations", additional_locations)
        pulumi.set(__self__, "bucket_columns", bucket_columns)
        pulumi.set(__self__, "columns", columns)
        pulumi.set(__self__, "compressed", compressed)
        pulumi.set(__self__, "input_format", input_format)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "number_of_buckets", number_of_buckets)
        pulumi.set(__self__, "output_format", output_format)
        pulumi.set(__self__, "parameters", parameters)
        pulumi.set(__self__, "schema_references", schema_references)
        pulumi.set(__self__, "ser_de_infos", ser_de_infos)
        pulumi.set(__self__, "skewed_infos", skewed_infos)
        pulumi.set(__self__, "sort_columns", sort_columns)
        pulumi.set(__self__, "stored_as_sub_directories", stored_as_sub_directories)

    @_builtins.property
    @pulumi.getter(name="additionalLocations")
    def additional_locations(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "additional_locations")

    @_builtins.property
    @pulumi.getter(name="bucketColumns")
    def bucket_columns(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "bucket_columns")

    @_builtins.property
    @pulumi.getter
    def columns(self) -> Sequence['outputs.GetCatalogTableStorageDescriptorColumnResult']:
        return pulumi.get(self, "columns")

    @_builtins.property
    @pulumi.getter
    def compressed(self) -> _builtins.bool:
        return pulumi.get(self, "compressed")

    @_builtins.property
    @pulumi.getter(name="inputFormat")
    def input_format(self) -> _builtins.str:
        return pulumi.get(self, "input_format")

    @_builtins.property
    @pulumi.getter
    def location(self) -> _builtins.str:
        return pulumi.get(self, "location")

    @_builtins.property
    @pulumi.getter(name="numberOfBuckets")
    def number_of_buckets(self) -> _builtins.int:
        return pulumi.get(self, "number_of_buckets")

    @_builtins.property
    @pulumi.getter(name="outputFormat")
    def output_format(self) -> _builtins.str:
        return pulumi.get(self, "output_format")

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "parameters")

    @_builtins.property
    @pulumi.getter(name="schemaReferences")
    def schema_references(self) -> Sequence['outputs.GetCatalogTableStorageDescriptorSchemaReferenceResult']:
        return pulumi.get(self, "schema_references")

    @_builtins.property
    @pulumi.getter(name="serDeInfos")
    def ser_de_infos(self) -> Sequence['outputs.GetCatalogTableStorageDescriptorSerDeInfoResult']:
        return pulumi.get(self, "ser_de_infos")

    @_builtins.property
    @pulumi.getter(name="skewedInfos")
    def skewed_infos(self) -> Sequence['outputs.GetCatalogTableStorageDescriptorSkewedInfoResult']:
        return pulumi.get(self, "skewed_infos")

    @_builtins.property
    @pulumi.getter(name="sortColumns")
    def sort_columns(self) -> Sequence['outputs.GetCatalogTableStorageDescriptorSortColumnResult']:
        return pulumi.get(self, "sort_columns")

    @_builtins.property
    @pulumi.getter(name="storedAsSubDirectories")
    def stored_as_sub_directories(self) -> _builtins.bool:
        return pulumi.get(self, "stored_as_sub_directories")


@pulumi.output_type
class GetCatalogTableStorageDescriptorColumnResult(dict):
    def __init__(__self__, *,
                 comment: _builtins.str,
                 name: _builtins.str,
                 parameters: Mapping[str, _builtins.str],
                 type: _builtins.str):
        pulumi.set(__self__, "comment", comment)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "parameters", parameters)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> _builtins.str:
        return pulumi.get(self, "comment")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "parameters")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetCatalogTableStorageDescriptorSchemaReferenceResult(dict):
    def __init__(__self__, *,
                 schema_ids: Sequence['outputs.GetCatalogTableStorageDescriptorSchemaReferenceSchemaIdResult'],
                 schema_version_id: _builtins.str,
                 schema_version_number: _builtins.int):
        pulumi.set(__self__, "schema_ids", schema_ids)
        pulumi.set(__self__, "schema_version_id", schema_version_id)
        pulumi.set(__self__, "schema_version_number", schema_version_number)

    @_builtins.property
    @pulumi.getter(name="schemaIds")
    def schema_ids(self) -> Sequence['outputs.GetCatalogTableStorageDescriptorSchemaReferenceSchemaIdResult']:
        return pulumi.get(self, "schema_ids")

    @_builtins.property
    @pulumi.getter(name="schemaVersionId")
    def schema_version_id(self) -> _builtins.str:
        return pulumi.get(self, "schema_version_id")

    @_builtins.property
    @pulumi.getter(name="schemaVersionNumber")
    def schema_version_number(self) -> _builtins.int:
        return pulumi.get(self, "schema_version_number")


@pulumi.output_type
class GetCatalogTableStorageDescriptorSchemaReferenceSchemaIdResult(dict):
    def __init__(__self__, *,
                 registry_name: _builtins.str,
                 schema_arn: _builtins.str,
                 schema_name: _builtins.str):
        pulumi.set(__self__, "registry_name", registry_name)
        pulumi.set(__self__, "schema_arn", schema_arn)
        pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter(name="registryName")
    def registry_name(self) -> _builtins.str:
        return pulumi.get(self, "registry_name")

    @_builtins.property
    @pulumi.getter(name="schemaArn")
    def schema_arn(self) -> _builtins.str:
        return pulumi.get(self, "schema_arn")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> _builtins.str:
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class GetCatalogTableStorageDescriptorSerDeInfoResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 parameters: Mapping[str, _builtins.str],
                 serialization_library: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "parameters", parameters)
        pulumi.set(__self__, "serialization_library", serialization_library)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "parameters")

    @_builtins.property
    @pulumi.getter(name="serializationLibrary")
    def serialization_library(self) -> _builtins.str:
        return pulumi.get(self, "serialization_library")


@pulumi.output_type
class GetCatalogTableStorageDescriptorSkewedInfoResult(dict):
    def __init__(__self__, *,
                 skewed_column_names: Sequence[_builtins.str],
                 skewed_column_value_location_maps: Mapping[str, _builtins.str],
                 skewed_column_values: Sequence[_builtins.str]):
        pulumi.set(__self__, "skewed_column_names", skewed_column_names)
        pulumi.set(__self__, "skewed_column_value_location_maps", skewed_column_value_location_maps)
        pulumi.set(__self__, "skewed_column_values", skewed_column_values)

    @_builtins.property
    @pulumi.getter(name="skewedColumnNames")
    def skewed_column_names(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "skewed_column_names")

    @_builtins.property
    @pulumi.getter(name="skewedColumnValueLocationMaps")
    def skewed_column_value_location_maps(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "skewed_column_value_location_maps")

    @_builtins.property
    @pulumi.getter(name="skewedColumnValues")
    def skewed_column_values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "skewed_column_values")


@pulumi.output_type
class GetCatalogTableStorageDescriptorSortColumnResult(dict):
    def __init__(__self__, *,
                 column: _builtins.str,
                 sort_order: _builtins.int):
        pulumi.set(__self__, "column", column)
        pulumi.set(__self__, "sort_order", sort_order)

    @_builtins.property
    @pulumi.getter
    def column(self) -> _builtins.str:
        return pulumi.get(self, "column")

    @_builtins.property
    @pulumi.getter(name="sortOrder")
    def sort_order(self) -> _builtins.int:
        return pulumi.get(self, "sort_order")


@pulumi.output_type
class GetCatalogTableTargetTableResult(dict):
    def __init__(__self__, *,
                 catalog_id: _builtins.str,
                 database_name: _builtins.str,
                 name: _builtins.str,
                 region: _builtins.str):
        pulumi.set(__self__, "catalog_id", catalog_id)
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> _builtins.str:
        return pulumi.get(self, "catalog_id")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> _builtins.str:
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        return pulumi.get(self, "region")


@pulumi.output_type
class GetConnectionPhysicalConnectionRequirementResult(dict):
    def __init__(__self__, *,
                 availability_zone: _builtins.str,
                 security_group_id_lists: Sequence[_builtins.str],
                 subnet_id: _builtins.str):
        pulumi.set(__self__, "availability_zone", availability_zone)
        pulumi.set(__self__, "security_group_id_lists", security_group_id_lists)
        pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> _builtins.str:
        return pulumi.get(self, "availability_zone")

    @_builtins.property
    @pulumi.getter(name="securityGroupIdLists")
    def security_group_id_lists(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "security_group_id_lists")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class GetDataCatalogEncryptionSettingsDataCatalogEncryptionSettingResult(dict):
    def __init__(__self__, *,
                 connection_password_encryptions: Sequence['outputs.GetDataCatalogEncryptionSettingsDataCatalogEncryptionSettingConnectionPasswordEncryptionResult'],
                 encryption_at_rests: Sequence['outputs.GetDataCatalogEncryptionSettingsDataCatalogEncryptionSettingEncryptionAtRestResult']):
        pulumi.set(__self__, "connection_password_encryptions", connection_password_encryptions)
        pulumi.set(__self__, "encryption_at_rests", encryption_at_rests)

    @_builtins.property
    @pulumi.getter(name="connectionPasswordEncryptions")
    def connection_password_encryptions(self) -> Sequence['outputs.GetDataCatalogEncryptionSettingsDataCatalogEncryptionSettingConnectionPasswordEncryptionResult']:
        return pulumi.get(self, "connection_password_encryptions")

    @_builtins.property
    @pulumi.getter(name="encryptionAtRests")
    def encryption_at_rests(self) -> Sequence['outputs.GetDataCatalogEncryptionSettingsDataCatalogEncryptionSettingEncryptionAtRestResult']:
        return pulumi.get(self, "encryption_at_rests")


@pulumi.output_type
class GetDataCatalogEncryptionSettingsDataCatalogEncryptionSettingConnectionPasswordEncryptionResult(dict):
    def __init__(__self__, *,
                 aws_kms_key_id: _builtins.str,
                 return_connection_password_encrypted: _builtins.bool):
        pulumi.set(__self__, "aws_kms_key_id", aws_kms_key_id)
        pulumi.set(__self__, "return_connection_password_encrypted", return_connection_password_encrypted)

    @_builtins.property
    @pulumi.getter(name="awsKmsKeyId")
    def aws_kms_key_id(self) -> _builtins.str:
        return pulumi.get(self, "aws_kms_key_id")

    @_builtins.property
    @pulumi.getter(name="returnConnectionPasswordEncrypted")
    def return_connection_password_encrypted(self) -> _builtins.bool:
        return pulumi.get(self, "return_connection_password_encrypted")


@pulumi.output_type
class GetDataCatalogEncryptionSettingsDataCatalogEncryptionSettingEncryptionAtRestResult(dict):
    def __init__(__self__, *,
                 catalog_encryption_mode: _builtins.str,
                 catalog_encryption_service_role: _builtins.str,
                 sse_aws_kms_key_id: _builtins.str):
        pulumi.set(__self__, "catalog_encryption_mode", catalog_encryption_mode)
        pulumi.set(__self__, "catalog_encryption_service_role", catalog_encryption_service_role)
        pulumi.set(__self__, "sse_aws_kms_key_id", sse_aws_kms_key_id)

    @_builtins.property
    @pulumi.getter(name="catalogEncryptionMode")
    def catalog_encryption_mode(self) -> _builtins.str:
        return pulumi.get(self, "catalog_encryption_mode")

    @_builtins.property
    @pulumi.getter(name="catalogEncryptionServiceRole")
    def catalog_encryption_service_role(self) -> _builtins.str:
        return pulumi.get(self, "catalog_encryption_service_role")

    @_builtins.property
    @pulumi.getter(name="sseAwsKmsKeyId")
    def sse_aws_kms_key_id(self) -> _builtins.str:
        return pulumi.get(self, "sse_aws_kms_key_id")


@pulumi.output_type
class GetScriptDagEdgeResult(dict):
    def __init__(__self__, *,
                 source: _builtins.str,
                 target: _builtins.str,
                 target_parameter: Optional[_builtins.str] = None):
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "target", target)
        if target_parameter is not None:
            pulumi.set(__self__, "target_parameter", target_parameter)

    @_builtins.property
    @pulumi.getter
    def source(self) -> _builtins.str:
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter
    def target(self) -> _builtins.str:
        return pulumi.get(self, "target")

    @_builtins.property
    @pulumi.getter(name="targetParameter")
    def target_parameter(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "target_parameter")


@pulumi.output_type
class GetScriptDagNodeResult(dict):
    def __init__(__self__, *,
                 args: Sequence['outputs.GetScriptDagNodeArgResult'],
                 id: _builtins.str,
                 node_type: _builtins.str,
                 line_number: Optional[_builtins.int] = None):
        pulumi.set(__self__, "args", args)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "node_type", node_type)
        if line_number is not None:
            pulumi.set(__self__, "line_number", line_number)

    @_builtins.property
    @pulumi.getter
    def args(self) -> Sequence['outputs.GetScriptDagNodeArgResult']:
        return pulumi.get(self, "args")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="nodeType")
    def node_type(self) -> _builtins.str:
        return pulumi.get(self, "node_type")

    @_builtins.property
    @pulumi.getter(name="lineNumber")
    def line_number(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "line_number")


@pulumi.output_type
class GetScriptDagNodeArgResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str,
                 param: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)
        if param is not None:
            pulumi.set(__self__, "param", param)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter
    def param(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "param")


