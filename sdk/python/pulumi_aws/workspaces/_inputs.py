# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'ConnectionAliasTimeoutsArgs',
    'ConnectionAliasTimeoutsArgsDict',
    'DirectoryActiveDirectoryConfigArgs',
    'DirectoryActiveDirectoryConfigArgsDict',
    'DirectoryCertificateBasedAuthPropertiesArgs',
    'DirectoryCertificateBasedAuthPropertiesArgsDict',
    'DirectorySamlPropertiesArgs',
    'DirectorySamlPropertiesArgsDict',
    'DirectorySelfServicePermissionsArgs',
    'DirectorySelfServicePermissionsArgsDict',
    'DirectoryWorkspaceAccessPropertiesArgs',
    'DirectoryWorkspaceAccessPropertiesArgsDict',
    'DirectoryWorkspaceCreationPropertiesArgs',
    'DirectoryWorkspaceCreationPropertiesArgsDict',
    'IpGroupRuleArgs',
    'IpGroupRuleArgsDict',
    'WebUserSettingsCookieSynchronizationConfigurationArgs',
    'WebUserSettingsCookieSynchronizationConfigurationArgsDict',
    'WebUserSettingsCookieSynchronizationConfigurationAllowlistArgs',
    'WebUserSettingsCookieSynchronizationConfigurationAllowlistArgsDict',
    'WebUserSettingsCookieSynchronizationConfigurationBlocklistArgs',
    'WebUserSettingsCookieSynchronizationConfigurationBlocklistArgsDict',
    'WebUserSettingsToolbarConfigurationArgs',
    'WebUserSettingsToolbarConfigurationArgsDict',
    'WorkspaceWorkspacePropertiesArgs',
    'WorkspaceWorkspacePropertiesArgsDict',
]

MYPY = False

if not MYPY:
    class ConnectionAliasTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
elif False:
    ConnectionAliasTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionAliasTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[builtins.str]] = None,
                 delete: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "create", value)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "delete", value)


if not MYPY:
    class DirectoryActiveDirectoryConfigArgsDict(TypedDict):
        domain_name: pulumi.Input[builtins.str]
        """
        Fully qualified domain name of the AWS Directory Service directory.
        """
        service_account_secret_arn: pulumi.Input[builtins.str]
        """
        ARN of the Secrets Manager secret that contains the credentials for the service account. For more information, see [Service Account Details](https://docs.aws.amazon.com/workspaces/latest/adminguide/pools-service-account-details.html).
        """
elif False:
    DirectoryActiveDirectoryConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DirectoryActiveDirectoryConfigArgs:
    def __init__(__self__, *,
                 domain_name: pulumi.Input[builtins.str],
                 service_account_secret_arn: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] domain_name: Fully qualified domain name of the AWS Directory Service directory.
        :param pulumi.Input[builtins.str] service_account_secret_arn: ARN of the Secrets Manager secret that contains the credentials for the service account. For more information, see [Service Account Details](https://docs.aws.amazon.com/workspaces/latest/adminguide/pools-service-account-details.html).
        """
        pulumi.set(__self__, "domain_name", domain_name)
        pulumi.set(__self__, "service_account_secret_arn", service_account_secret_arn)

    @property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> pulumi.Input[builtins.str]:
        """
        Fully qualified domain name of the AWS Directory Service directory.
        """
        return pulumi.get(self, "domain_name")

    @domain_name.setter
    def domain_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "domain_name", value)

    @property
    @pulumi.getter(name="serviceAccountSecretArn")
    def service_account_secret_arn(self) -> pulumi.Input[builtins.str]:
        """
        ARN of the Secrets Manager secret that contains the credentials for the service account. For more information, see [Service Account Details](https://docs.aws.amazon.com/workspaces/latest/adminguide/pools-service-account-details.html).
        """
        return pulumi.get(self, "service_account_secret_arn")

    @service_account_secret_arn.setter
    def service_account_secret_arn(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "service_account_secret_arn", value)


if not MYPY:
    class DirectoryCertificateBasedAuthPropertiesArgsDict(TypedDict):
        certificate_authority_arn: NotRequired[pulumi.Input[builtins.str]]
        """
        The Amazon Resource Name (ARN) of the certificate manager private certificate authority (ACM-PCA) that is used for certificate-based authentication.
        """
        status: NotRequired[pulumi.Input[builtins.str]]
        """
        Status of certificate-based authentication. Default `DISABLED`.
        """
elif False:
    DirectoryCertificateBasedAuthPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DirectoryCertificateBasedAuthPropertiesArgs:
    def __init__(__self__, *,
                 certificate_authority_arn: Optional[pulumi.Input[builtins.str]] = None,
                 status: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] certificate_authority_arn: The Amazon Resource Name (ARN) of the certificate manager private certificate authority (ACM-PCA) that is used for certificate-based authentication.
        :param pulumi.Input[builtins.str] status: Status of certificate-based authentication. Default `DISABLED`.
        """
        if certificate_authority_arn is not None:
            pulumi.set(__self__, "certificate_authority_arn", certificate_authority_arn)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="certificateAuthorityArn")
    def certificate_authority_arn(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The Amazon Resource Name (ARN) of the certificate manager private certificate authority (ACM-PCA) that is used for certificate-based authentication.
        """
        return pulumi.get(self, "certificate_authority_arn")

    @certificate_authority_arn.setter
    def certificate_authority_arn(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "certificate_authority_arn", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Status of certificate-based authentication. Default `DISABLED`.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class DirectorySamlPropertiesArgsDict(TypedDict):
        relay_state_parameter_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The relay state parameter name supported by the SAML 2.0 identity provider (IdP). Default `RelayState`.
        """
        status: NotRequired[pulumi.Input[builtins.str]]
        """
        Status of SAML 2.0 authentication. Default `DISABLED`.
        """
        user_access_url: NotRequired[pulumi.Input[builtins.str]]
        """
        The SAML 2.0 identity provider (IdP) user access URL.
        """
elif False:
    DirectorySamlPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DirectorySamlPropertiesArgs:
    def __init__(__self__, *,
                 relay_state_parameter_name: Optional[pulumi.Input[builtins.str]] = None,
                 status: Optional[pulumi.Input[builtins.str]] = None,
                 user_access_url: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] relay_state_parameter_name: The relay state parameter name supported by the SAML 2.0 identity provider (IdP). Default `RelayState`.
        :param pulumi.Input[builtins.str] status: Status of SAML 2.0 authentication. Default `DISABLED`.
        :param pulumi.Input[builtins.str] user_access_url: The SAML 2.0 identity provider (IdP) user access URL.
        """
        if relay_state_parameter_name is not None:
            pulumi.set(__self__, "relay_state_parameter_name", relay_state_parameter_name)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if user_access_url is not None:
            pulumi.set(__self__, "user_access_url", user_access_url)

    @property
    @pulumi.getter(name="relayStateParameterName")
    def relay_state_parameter_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The relay state parameter name supported by the SAML 2.0 identity provider (IdP). Default `RelayState`.
        """
        return pulumi.get(self, "relay_state_parameter_name")

    @relay_state_parameter_name.setter
    def relay_state_parameter_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "relay_state_parameter_name", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Status of SAML 2.0 authentication. Default `DISABLED`.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter(name="userAccessUrl")
    def user_access_url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The SAML 2.0 identity provider (IdP) user access URL.
        """
        return pulumi.get(self, "user_access_url")

    @user_access_url.setter
    def user_access_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "user_access_url", value)


if not MYPY:
    class DirectorySelfServicePermissionsArgsDict(TypedDict):
        change_compute_type: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether WorkSpaces directory users can change the compute type (bundle) for their workspace. Default `false`.
        """
        increase_volume_size: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether WorkSpaces directory users can increase the volume size of the drives on their workspace. Default `false`.
        """
        rebuild_workspace: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether WorkSpaces directory users can rebuild the operating system of a workspace to its original state. Default `false`.
        """
        restart_workspace: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether WorkSpaces directory users can restart their workspace. Default `true`.
        """
        switch_running_mode: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether WorkSpaces directory users can switch the running mode of their workspace. Default `false`.
        """
elif False:
    DirectorySelfServicePermissionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DirectorySelfServicePermissionsArgs:
    def __init__(__self__, *,
                 change_compute_type: Optional[pulumi.Input[builtins.bool]] = None,
                 increase_volume_size: Optional[pulumi.Input[builtins.bool]] = None,
                 rebuild_workspace: Optional[pulumi.Input[builtins.bool]] = None,
                 restart_workspace: Optional[pulumi.Input[builtins.bool]] = None,
                 switch_running_mode: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.bool] change_compute_type: Whether WorkSpaces directory users can change the compute type (bundle) for their workspace. Default `false`.
        :param pulumi.Input[builtins.bool] increase_volume_size: Whether WorkSpaces directory users can increase the volume size of the drives on their workspace. Default `false`.
        :param pulumi.Input[builtins.bool] rebuild_workspace: Whether WorkSpaces directory users can rebuild the operating system of a workspace to its original state. Default `false`.
        :param pulumi.Input[builtins.bool] restart_workspace: Whether WorkSpaces directory users can restart their workspace. Default `true`.
        :param pulumi.Input[builtins.bool] switch_running_mode: Whether WorkSpaces directory users can switch the running mode of their workspace. Default `false`.
        """
        if change_compute_type is not None:
            pulumi.set(__self__, "change_compute_type", change_compute_type)
        if increase_volume_size is not None:
            pulumi.set(__self__, "increase_volume_size", increase_volume_size)
        if rebuild_workspace is not None:
            pulumi.set(__self__, "rebuild_workspace", rebuild_workspace)
        if restart_workspace is not None:
            pulumi.set(__self__, "restart_workspace", restart_workspace)
        if switch_running_mode is not None:
            pulumi.set(__self__, "switch_running_mode", switch_running_mode)

    @property
    @pulumi.getter(name="changeComputeType")
    def change_compute_type(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether WorkSpaces directory users can change the compute type (bundle) for their workspace. Default `false`.
        """
        return pulumi.get(self, "change_compute_type")

    @change_compute_type.setter
    def change_compute_type(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "change_compute_type", value)

    @property
    @pulumi.getter(name="increaseVolumeSize")
    def increase_volume_size(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether WorkSpaces directory users can increase the volume size of the drives on their workspace. Default `false`.
        """
        return pulumi.get(self, "increase_volume_size")

    @increase_volume_size.setter
    def increase_volume_size(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "increase_volume_size", value)

    @property
    @pulumi.getter(name="rebuildWorkspace")
    def rebuild_workspace(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether WorkSpaces directory users can rebuild the operating system of a workspace to its original state. Default `false`.
        """
        return pulumi.get(self, "rebuild_workspace")

    @rebuild_workspace.setter
    def rebuild_workspace(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "rebuild_workspace", value)

    @property
    @pulumi.getter(name="restartWorkspace")
    def restart_workspace(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether WorkSpaces directory users can restart their workspace. Default `true`.
        """
        return pulumi.get(self, "restart_workspace")

    @restart_workspace.setter
    def restart_workspace(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "restart_workspace", value)

    @property
    @pulumi.getter(name="switchRunningMode")
    def switch_running_mode(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether WorkSpaces directory users can switch the running mode of their workspace. Default `false`.
        """
        return pulumi.get(self, "switch_running_mode")

    @switch_running_mode.setter
    def switch_running_mode(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "switch_running_mode", value)


if not MYPY:
    class DirectoryWorkspaceAccessPropertiesArgsDict(TypedDict):
        device_type_android: NotRequired[pulumi.Input[builtins.str]]
        """
        Indicates whether users can use Android devices to access their WorkSpaces.
        """
        device_type_chromeos: NotRequired[pulumi.Input[builtins.str]]
        """
        Indicates whether users can use Chromebooks to access their WorkSpaces.
        """
        device_type_ios: NotRequired[pulumi.Input[builtins.str]]
        """
        Indicates whether users can use iOS devices to access their WorkSpaces.
        """
        device_type_linux: NotRequired[pulumi.Input[builtins.str]]
        """
        Indicates whether users can use Linux clients to access their WorkSpaces.
        """
        device_type_osx: NotRequired[pulumi.Input[builtins.str]]
        """
        Indicates whether users can use macOS clients to access their WorkSpaces.
        """
        device_type_web: NotRequired[pulumi.Input[builtins.str]]
        """
        Indicates whether users can access their WorkSpaces through a web browser.
        """
        device_type_windows: NotRequired[pulumi.Input[builtins.str]]
        """
        Indicates whether users can use Windows clients to access their WorkSpaces.
        """
        device_type_zeroclient: NotRequired[pulumi.Input[builtins.str]]
        """
        Indicates whether users can use zero client devices to access their WorkSpaces.
        """
elif False:
    DirectoryWorkspaceAccessPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DirectoryWorkspaceAccessPropertiesArgs:
    def __init__(__self__, *,
                 device_type_android: Optional[pulumi.Input[builtins.str]] = None,
                 device_type_chromeos: Optional[pulumi.Input[builtins.str]] = None,
                 device_type_ios: Optional[pulumi.Input[builtins.str]] = None,
                 device_type_linux: Optional[pulumi.Input[builtins.str]] = None,
                 device_type_osx: Optional[pulumi.Input[builtins.str]] = None,
                 device_type_web: Optional[pulumi.Input[builtins.str]] = None,
                 device_type_windows: Optional[pulumi.Input[builtins.str]] = None,
                 device_type_zeroclient: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] device_type_android: Indicates whether users can use Android devices to access their WorkSpaces.
        :param pulumi.Input[builtins.str] device_type_chromeos: Indicates whether users can use Chromebooks to access their WorkSpaces.
        :param pulumi.Input[builtins.str] device_type_ios: Indicates whether users can use iOS devices to access their WorkSpaces.
        :param pulumi.Input[builtins.str] device_type_linux: Indicates whether users can use Linux clients to access their WorkSpaces.
        :param pulumi.Input[builtins.str] device_type_osx: Indicates whether users can use macOS clients to access their WorkSpaces.
        :param pulumi.Input[builtins.str] device_type_web: Indicates whether users can access their WorkSpaces through a web browser.
        :param pulumi.Input[builtins.str] device_type_windows: Indicates whether users can use Windows clients to access their WorkSpaces.
        :param pulumi.Input[builtins.str] device_type_zeroclient: Indicates whether users can use zero client devices to access their WorkSpaces.
        """
        if device_type_android is not None:
            pulumi.set(__self__, "device_type_android", device_type_android)
        if device_type_chromeos is not None:
            pulumi.set(__self__, "device_type_chromeos", device_type_chromeos)
        if device_type_ios is not None:
            pulumi.set(__self__, "device_type_ios", device_type_ios)
        if device_type_linux is not None:
            pulumi.set(__self__, "device_type_linux", device_type_linux)
        if device_type_osx is not None:
            pulumi.set(__self__, "device_type_osx", device_type_osx)
        if device_type_web is not None:
            pulumi.set(__self__, "device_type_web", device_type_web)
        if device_type_windows is not None:
            pulumi.set(__self__, "device_type_windows", device_type_windows)
        if device_type_zeroclient is not None:
            pulumi.set(__self__, "device_type_zeroclient", device_type_zeroclient)

    @property
    @pulumi.getter(name="deviceTypeAndroid")
    def device_type_android(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Indicates whether users can use Android devices to access their WorkSpaces.
        """
        return pulumi.get(self, "device_type_android")

    @device_type_android.setter
    def device_type_android(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "device_type_android", value)

    @property
    @pulumi.getter(name="deviceTypeChromeos")
    def device_type_chromeos(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Indicates whether users can use Chromebooks to access their WorkSpaces.
        """
        return pulumi.get(self, "device_type_chromeos")

    @device_type_chromeos.setter
    def device_type_chromeos(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "device_type_chromeos", value)

    @property
    @pulumi.getter(name="deviceTypeIos")
    def device_type_ios(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Indicates whether users can use iOS devices to access their WorkSpaces.
        """
        return pulumi.get(self, "device_type_ios")

    @device_type_ios.setter
    def device_type_ios(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "device_type_ios", value)

    @property
    @pulumi.getter(name="deviceTypeLinux")
    def device_type_linux(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Indicates whether users can use Linux clients to access their WorkSpaces.
        """
        return pulumi.get(self, "device_type_linux")

    @device_type_linux.setter
    def device_type_linux(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "device_type_linux", value)

    @property
    @pulumi.getter(name="deviceTypeOsx")
    def device_type_osx(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Indicates whether users can use macOS clients to access their WorkSpaces.
        """
        return pulumi.get(self, "device_type_osx")

    @device_type_osx.setter
    def device_type_osx(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "device_type_osx", value)

    @property
    @pulumi.getter(name="deviceTypeWeb")
    def device_type_web(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Indicates whether users can access their WorkSpaces through a web browser.
        """
        return pulumi.get(self, "device_type_web")

    @device_type_web.setter
    def device_type_web(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "device_type_web", value)

    @property
    @pulumi.getter(name="deviceTypeWindows")
    def device_type_windows(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Indicates whether users can use Windows clients to access their WorkSpaces.
        """
        return pulumi.get(self, "device_type_windows")

    @device_type_windows.setter
    def device_type_windows(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "device_type_windows", value)

    @property
    @pulumi.getter(name="deviceTypeZeroclient")
    def device_type_zeroclient(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Indicates whether users can use zero client devices to access their WorkSpaces.
        """
        return pulumi.get(self, "device_type_zeroclient")

    @device_type_zeroclient.setter
    def device_type_zeroclient(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "device_type_zeroclient", value)


if not MYPY:
    class DirectoryWorkspaceCreationPropertiesArgsDict(TypedDict):
        custom_security_group_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The identifier of your custom security group. Should relate to the same VPC, where workspaces reside in.
        """
        default_ou: NotRequired[pulumi.Input[builtins.str]]
        """
        The default organizational unit (OU) for your WorkSpace directories. Should conform `"OU=<value>,DC=<value>,...,DC=<value>"` pattern.
        """
        enable_internet_access: NotRequired[pulumi.Input[builtins.bool]]
        """
        Indicates whether internet access is enabled for your WorkSpaces.
        """
        enable_maintenance_mode: NotRequired[pulumi.Input[builtins.bool]]
        """
        Indicates whether maintenance mode is enabled for your WorkSpaces. Valid only if `workspace_type` is set to `PERSONAL`.
        """
        user_enabled_as_local_administrator: NotRequired[pulumi.Input[builtins.bool]]
        """
        Indicates whether users are local administrators of their WorkSpaces. Valid only if `workspace_type` is set to `PERSONAL`.
        """
elif False:
    DirectoryWorkspaceCreationPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DirectoryWorkspaceCreationPropertiesArgs:
    def __init__(__self__, *,
                 custom_security_group_id: Optional[pulumi.Input[builtins.str]] = None,
                 default_ou: Optional[pulumi.Input[builtins.str]] = None,
                 enable_internet_access: Optional[pulumi.Input[builtins.bool]] = None,
                 enable_maintenance_mode: Optional[pulumi.Input[builtins.bool]] = None,
                 user_enabled_as_local_administrator: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.str] custom_security_group_id: The identifier of your custom security group. Should relate to the same VPC, where workspaces reside in.
        :param pulumi.Input[builtins.str] default_ou: The default organizational unit (OU) for your WorkSpace directories. Should conform `"OU=<value>,DC=<value>,...,DC=<value>"` pattern.
        :param pulumi.Input[builtins.bool] enable_internet_access: Indicates whether internet access is enabled for your WorkSpaces.
        :param pulumi.Input[builtins.bool] enable_maintenance_mode: Indicates whether maintenance mode is enabled for your WorkSpaces. Valid only if `workspace_type` is set to `PERSONAL`.
        :param pulumi.Input[builtins.bool] user_enabled_as_local_administrator: Indicates whether users are local administrators of their WorkSpaces. Valid only if `workspace_type` is set to `PERSONAL`.
        """
        if custom_security_group_id is not None:
            pulumi.set(__self__, "custom_security_group_id", custom_security_group_id)
        if default_ou is not None:
            pulumi.set(__self__, "default_ou", default_ou)
        if enable_internet_access is not None:
            pulumi.set(__self__, "enable_internet_access", enable_internet_access)
        if enable_maintenance_mode is not None:
            pulumi.set(__self__, "enable_maintenance_mode", enable_maintenance_mode)
        if user_enabled_as_local_administrator is not None:
            pulumi.set(__self__, "user_enabled_as_local_administrator", user_enabled_as_local_administrator)

    @property
    @pulumi.getter(name="customSecurityGroupId")
    def custom_security_group_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The identifier of your custom security group. Should relate to the same VPC, where workspaces reside in.
        """
        return pulumi.get(self, "custom_security_group_id")

    @custom_security_group_id.setter
    def custom_security_group_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "custom_security_group_id", value)

    @property
    @pulumi.getter(name="defaultOu")
    def default_ou(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The default organizational unit (OU) for your WorkSpace directories. Should conform `"OU=<value>,DC=<value>,...,DC=<value>"` pattern.
        """
        return pulumi.get(self, "default_ou")

    @default_ou.setter
    def default_ou(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "default_ou", value)

    @property
    @pulumi.getter(name="enableInternetAccess")
    def enable_internet_access(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Indicates whether internet access is enabled for your WorkSpaces.
        """
        return pulumi.get(self, "enable_internet_access")

    @enable_internet_access.setter
    def enable_internet_access(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable_internet_access", value)

    @property
    @pulumi.getter(name="enableMaintenanceMode")
    def enable_maintenance_mode(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Indicates whether maintenance mode is enabled for your WorkSpaces. Valid only if `workspace_type` is set to `PERSONAL`.
        """
        return pulumi.get(self, "enable_maintenance_mode")

    @enable_maintenance_mode.setter
    def enable_maintenance_mode(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable_maintenance_mode", value)

    @property
    @pulumi.getter(name="userEnabledAsLocalAdministrator")
    def user_enabled_as_local_administrator(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Indicates whether users are local administrators of their WorkSpaces. Valid only if `workspace_type` is set to `PERSONAL`.
        """
        return pulumi.get(self, "user_enabled_as_local_administrator")

    @user_enabled_as_local_administrator.setter
    def user_enabled_as_local_administrator(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "user_enabled_as_local_administrator", value)


if not MYPY:
    class IpGroupRuleArgsDict(TypedDict):
        source: pulumi.Input[builtins.str]
        """
        The IP address range, in CIDR notation, e.g., `10.0.0.0/16`
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        The description of the IP group.
        """
elif False:
    IpGroupRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IpGroupRuleArgs:
    def __init__(__self__, *,
                 source: pulumi.Input[builtins.str],
                 description: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] source: The IP address range, in CIDR notation, e.g., `10.0.0.0/16`
        :param pulumi.Input[builtins.str] description: The description of the IP group.
        """
        pulumi.set(__self__, "source", source)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def source(self) -> pulumi.Input[builtins.str]:
        """
        The IP address range, in CIDR notation, e.g., `10.0.0.0/16`
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The description of the IP group.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class WebUserSettingsCookieSynchronizationConfigurationArgsDict(TypedDict):
        allowlists: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebUserSettingsCookieSynchronizationConfigurationAllowlistArgsDict']]]]
        """
        List of cookie specifications that are allowed to be synchronized to the remote browser.
        """
        blocklists: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebUserSettingsCookieSynchronizationConfigurationBlocklistArgsDict']]]]
        """
        List of cookie specifications that are blocked from being synchronized to the remote browser.
        """
elif False:
    WebUserSettingsCookieSynchronizationConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebUserSettingsCookieSynchronizationConfigurationArgs:
    def __init__(__self__, *,
                 allowlists: Optional[pulumi.Input[Sequence[pulumi.Input['WebUserSettingsCookieSynchronizationConfigurationAllowlistArgs']]]] = None,
                 blocklists: Optional[pulumi.Input[Sequence[pulumi.Input['WebUserSettingsCookieSynchronizationConfigurationBlocklistArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebUserSettingsCookieSynchronizationConfigurationAllowlistArgs']]] allowlists: List of cookie specifications that are allowed to be synchronized to the remote browser.
        :param pulumi.Input[Sequence[pulumi.Input['WebUserSettingsCookieSynchronizationConfigurationBlocklistArgs']]] blocklists: List of cookie specifications that are blocked from being synchronized to the remote browser.
        """
        if allowlists is not None:
            pulumi.set(__self__, "allowlists", allowlists)
        if blocklists is not None:
            pulumi.set(__self__, "blocklists", blocklists)

    @property
    @pulumi.getter
    def allowlists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebUserSettingsCookieSynchronizationConfigurationAllowlistArgs']]]]:
        """
        List of cookie specifications that are allowed to be synchronized to the remote browser.
        """
        return pulumi.get(self, "allowlists")

    @allowlists.setter
    def allowlists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebUserSettingsCookieSynchronizationConfigurationAllowlistArgs']]]]):
        pulumi.set(self, "allowlists", value)

    @property
    @pulumi.getter
    def blocklists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebUserSettingsCookieSynchronizationConfigurationBlocklistArgs']]]]:
        """
        List of cookie specifications that are blocked from being synchronized to the remote browser.
        """
        return pulumi.get(self, "blocklists")

    @blocklists.setter
    def blocklists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebUserSettingsCookieSynchronizationConfigurationBlocklistArgs']]]]):
        pulumi.set(self, "blocklists", value)


if not MYPY:
    class WebUserSettingsCookieSynchronizationConfigurationAllowlistArgsDict(TypedDict):
        domain: pulumi.Input[builtins.str]
        """
        Domain of the cookie.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the cookie.
        """
        path: NotRequired[pulumi.Input[builtins.str]]
        """
        Path of the cookie.
        """
elif False:
    WebUserSettingsCookieSynchronizationConfigurationAllowlistArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebUserSettingsCookieSynchronizationConfigurationAllowlistArgs:
    def __init__(__self__, *,
                 domain: pulumi.Input[builtins.str],
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 path: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] domain: Domain of the cookie.
        :param pulumi.Input[builtins.str] name: Name of the cookie.
        :param pulumi.Input[builtins.str] path: Path of the cookie.
        """
        pulumi.set(__self__, "domain", domain)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def domain(self) -> pulumi.Input[builtins.str]:
        """
        Domain of the cookie.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "domain", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the cookie.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Path of the cookie.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "path", value)


if not MYPY:
    class WebUserSettingsCookieSynchronizationConfigurationBlocklistArgsDict(TypedDict):
        domain: pulumi.Input[builtins.str]
        """
        Domain of the cookie.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the cookie.
        """
        path: NotRequired[pulumi.Input[builtins.str]]
        """
        Path of the cookie.
        """
elif False:
    WebUserSettingsCookieSynchronizationConfigurationBlocklistArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebUserSettingsCookieSynchronizationConfigurationBlocklistArgs:
    def __init__(__self__, *,
                 domain: pulumi.Input[builtins.str],
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 path: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] domain: Domain of the cookie.
        :param pulumi.Input[builtins.str] name: Name of the cookie.
        :param pulumi.Input[builtins.str] path: Path of the cookie.
        """
        pulumi.set(__self__, "domain", domain)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def domain(self) -> pulumi.Input[builtins.str]:
        """
        Domain of the cookie.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "domain", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the cookie.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Path of the cookie.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "path", value)


if not MYPY:
    class WebUserSettingsToolbarConfigurationArgsDict(TypedDict):
        hidden_toolbar_items: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of toolbar items to be hidden.
        """
        max_display_resolution: NotRequired[pulumi.Input[builtins.str]]
        """
        Maximum display resolution that is allowed for the session.
        """
        toolbar_type: NotRequired[pulumi.Input[builtins.str]]
        """
        Type of toolbar displayed during the session.
        """
        visual_mode: NotRequired[pulumi.Input[builtins.str]]
        """
        Visual mode of the toolbar.
        """
elif False:
    WebUserSettingsToolbarConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebUserSettingsToolbarConfigurationArgs:
    def __init__(__self__, *,
                 hidden_toolbar_items: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 max_display_resolution: Optional[pulumi.Input[builtins.str]] = None,
                 toolbar_type: Optional[pulumi.Input[builtins.str]] = None,
                 visual_mode: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] hidden_toolbar_items: List of toolbar items to be hidden.
        :param pulumi.Input[builtins.str] max_display_resolution: Maximum display resolution that is allowed for the session.
        :param pulumi.Input[builtins.str] toolbar_type: Type of toolbar displayed during the session.
        :param pulumi.Input[builtins.str] visual_mode: Visual mode of the toolbar.
        """
        if hidden_toolbar_items is not None:
            pulumi.set(__self__, "hidden_toolbar_items", hidden_toolbar_items)
        if max_display_resolution is not None:
            pulumi.set(__self__, "max_display_resolution", max_display_resolution)
        if toolbar_type is not None:
            pulumi.set(__self__, "toolbar_type", toolbar_type)
        if visual_mode is not None:
            pulumi.set(__self__, "visual_mode", visual_mode)

    @property
    @pulumi.getter(name="hiddenToolbarItems")
    def hidden_toolbar_items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of toolbar items to be hidden.
        """
        return pulumi.get(self, "hidden_toolbar_items")

    @hidden_toolbar_items.setter
    def hidden_toolbar_items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "hidden_toolbar_items", value)

    @property
    @pulumi.getter(name="maxDisplayResolution")
    def max_display_resolution(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Maximum display resolution that is allowed for the session.
        """
        return pulumi.get(self, "max_display_resolution")

    @max_display_resolution.setter
    def max_display_resolution(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "max_display_resolution", value)

    @property
    @pulumi.getter(name="toolbarType")
    def toolbar_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Type of toolbar displayed during the session.
        """
        return pulumi.get(self, "toolbar_type")

    @toolbar_type.setter
    def toolbar_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "toolbar_type", value)

    @property
    @pulumi.getter(name="visualMode")
    def visual_mode(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Visual mode of the toolbar.
        """
        return pulumi.get(self, "visual_mode")

    @visual_mode.setter
    def visual_mode(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "visual_mode", value)


if not MYPY:
    class WorkspaceWorkspacePropertiesArgsDict(TypedDict):
        compute_type_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The compute type. For more information, see [Amazon WorkSpaces Bundles](http://aws.amazon.com/workspaces/details/#Amazon_WorkSpaces_Bundles). Valid values are `VALUE`, `STANDARD`, `PERFORMANCE`, `POWER`, `GRAPHICS`, `POWERPRO`, `GRAPHICSPRO`, `GRAPHICS_G4DN`, and `GRAPHICSPRO_G4DN`.
        """
        root_volume_size_gib: NotRequired[pulumi.Input[builtins.int]]
        """
        The size of the root volume.
        """
        running_mode: NotRequired[pulumi.Input[builtins.str]]
        """
        The running mode. For more information, see [Manage the WorkSpace Running Mode](https://docs.aws.amazon.com/workspaces/latest/adminguide/running-mode.html). Valid values are `AUTO_STOP` and `ALWAYS_ON`.
        """
        running_mode_auto_stop_timeout_in_minutes: NotRequired[pulumi.Input[builtins.int]]
        """
        The time after a user logs off when WorkSpaces are automatically stopped. Configured in 60-minute intervals.
        """
        user_volume_size_gib: NotRequired[pulumi.Input[builtins.int]]
        """
        The size of the user storage.
        """
elif False:
    WorkspaceWorkspacePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkspaceWorkspacePropertiesArgs:
    def __init__(__self__, *,
                 compute_type_name: Optional[pulumi.Input[builtins.str]] = None,
                 root_volume_size_gib: Optional[pulumi.Input[builtins.int]] = None,
                 running_mode: Optional[pulumi.Input[builtins.str]] = None,
                 running_mode_auto_stop_timeout_in_minutes: Optional[pulumi.Input[builtins.int]] = None,
                 user_volume_size_gib: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.str] compute_type_name: The compute type. For more information, see [Amazon WorkSpaces Bundles](http://aws.amazon.com/workspaces/details/#Amazon_WorkSpaces_Bundles). Valid values are `VALUE`, `STANDARD`, `PERFORMANCE`, `POWER`, `GRAPHICS`, `POWERPRO`, `GRAPHICSPRO`, `GRAPHICS_G4DN`, and `GRAPHICSPRO_G4DN`.
        :param pulumi.Input[builtins.int] root_volume_size_gib: The size of the root volume.
        :param pulumi.Input[builtins.str] running_mode: The running mode. For more information, see [Manage the WorkSpace Running Mode](https://docs.aws.amazon.com/workspaces/latest/adminguide/running-mode.html). Valid values are `AUTO_STOP` and `ALWAYS_ON`.
        :param pulumi.Input[builtins.int] running_mode_auto_stop_timeout_in_minutes: The time after a user logs off when WorkSpaces are automatically stopped. Configured in 60-minute intervals.
        :param pulumi.Input[builtins.int] user_volume_size_gib: The size of the user storage.
        """
        if compute_type_name is not None:
            pulumi.set(__self__, "compute_type_name", compute_type_name)
        if root_volume_size_gib is not None:
            pulumi.set(__self__, "root_volume_size_gib", root_volume_size_gib)
        if running_mode is not None:
            pulumi.set(__self__, "running_mode", running_mode)
        if running_mode_auto_stop_timeout_in_minutes is not None:
            pulumi.set(__self__, "running_mode_auto_stop_timeout_in_minutes", running_mode_auto_stop_timeout_in_minutes)
        if user_volume_size_gib is not None:
            pulumi.set(__self__, "user_volume_size_gib", user_volume_size_gib)

    @property
    @pulumi.getter(name="computeTypeName")
    def compute_type_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The compute type. For more information, see [Amazon WorkSpaces Bundles](http://aws.amazon.com/workspaces/details/#Amazon_WorkSpaces_Bundles). Valid values are `VALUE`, `STANDARD`, `PERFORMANCE`, `POWER`, `GRAPHICS`, `POWERPRO`, `GRAPHICSPRO`, `GRAPHICS_G4DN`, and `GRAPHICSPRO_G4DN`.
        """
        return pulumi.get(self, "compute_type_name")

    @compute_type_name.setter
    def compute_type_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "compute_type_name", value)

    @property
    @pulumi.getter(name="rootVolumeSizeGib")
    def root_volume_size_gib(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The size of the root volume.
        """
        return pulumi.get(self, "root_volume_size_gib")

    @root_volume_size_gib.setter
    def root_volume_size_gib(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "root_volume_size_gib", value)

    @property
    @pulumi.getter(name="runningMode")
    def running_mode(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The running mode. For more information, see [Manage the WorkSpace Running Mode](https://docs.aws.amazon.com/workspaces/latest/adminguide/running-mode.html). Valid values are `AUTO_STOP` and `ALWAYS_ON`.
        """
        return pulumi.get(self, "running_mode")

    @running_mode.setter
    def running_mode(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "running_mode", value)

    @property
    @pulumi.getter(name="runningModeAutoStopTimeoutInMinutes")
    def running_mode_auto_stop_timeout_in_minutes(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The time after a user logs off when WorkSpaces are automatically stopped. Configured in 60-minute intervals.
        """
        return pulumi.get(self, "running_mode_auto_stop_timeout_in_minutes")

    @running_mode_auto_stop_timeout_in_minutes.setter
    def running_mode_auto_stop_timeout_in_minutes(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "running_mode_auto_stop_timeout_in_minutes", value)

    @property
    @pulumi.getter(name="userVolumeSizeGib")
    def user_volume_size_gib(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The size of the user storage.
        """
        return pulumi.get(self, "user_volume_size_gib")

    @user_volume_size_gib.setter
    def user_volume_size_gib(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "user_volume_size_gib", value)


