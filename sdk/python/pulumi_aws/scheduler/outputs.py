# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'ScheduleFlexibleTimeWindow',
    'ScheduleTarget',
    'ScheduleTargetDeadLetterConfig',
    'ScheduleTargetEcsParameters',
    'ScheduleTargetEcsParametersCapacityProviderStrategy',
    'ScheduleTargetEcsParametersNetworkConfiguration',
    'ScheduleTargetEcsParametersPlacementConstraint',
    'ScheduleTargetEcsParametersPlacementStrategy',
    'ScheduleTargetEventbridgeParameters',
    'ScheduleTargetKinesisParameters',
    'ScheduleTargetRetryPolicy',
    'ScheduleTargetSagemakerPipelineParameters',
    'ScheduleTargetSagemakerPipelineParametersPipelineParameter',
    'ScheduleTargetSqsParameters',
]

@pulumi.output_type
class ScheduleFlexibleTimeWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maximumWindowInMinutes":
            suggest = "maximum_window_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduleFlexibleTimeWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduleFlexibleTimeWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduleFlexibleTimeWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mode: str,
                 maximum_window_in_minutes: Optional[int] = None):
        """
        :param str mode: Determines whether the schedule is invoked within a flexible time window. One of: `OFF`, `FLEXIBLE`.
        :param int maximum_window_in_minutes: Maximum time window during which a schedule can be invoked. Ranges from `1` to `1440` minutes.
        """
        ScheduleFlexibleTimeWindow._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            mode=mode,
            maximum_window_in_minutes=maximum_window_in_minutes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             mode: Optional[str] = None,
             maximum_window_in_minutes: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if mode is None:
            raise TypeError("Missing 'mode' argument")
        if maximum_window_in_minutes is None and 'maximumWindowInMinutes' in kwargs:
            maximum_window_in_minutes = kwargs['maximumWindowInMinutes']

        _setter("mode", mode)
        if maximum_window_in_minutes is not None:
            _setter("maximum_window_in_minutes", maximum_window_in_minutes)

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        Determines whether the schedule is invoked within a flexible time window. One of: `OFF`, `FLEXIBLE`.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="maximumWindowInMinutes")
    def maximum_window_in_minutes(self) -> Optional[int]:
        """
        Maximum time window during which a schedule can be invoked. Ranges from `1` to `1440` minutes.
        """
        return pulumi.get(self, "maximum_window_in_minutes")


@pulumi.output_type
class ScheduleTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleArn":
            suggest = "role_arn"
        elif key == "deadLetterConfig":
            suggest = "dead_letter_config"
        elif key == "ecsParameters":
            suggest = "ecs_parameters"
        elif key == "eventbridgeParameters":
            suggest = "eventbridge_parameters"
        elif key == "kinesisParameters":
            suggest = "kinesis_parameters"
        elif key == "retryPolicy":
            suggest = "retry_policy"
        elif key == "sagemakerPipelineParameters":
            suggest = "sagemaker_pipeline_parameters"
        elif key == "sqsParameters":
            suggest = "sqs_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduleTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduleTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduleTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: str,
                 role_arn: str,
                 dead_letter_config: Optional['outputs.ScheduleTargetDeadLetterConfig'] = None,
                 ecs_parameters: Optional['outputs.ScheduleTargetEcsParameters'] = None,
                 eventbridge_parameters: Optional['outputs.ScheduleTargetEventbridgeParameters'] = None,
                 input: Optional[str] = None,
                 kinesis_parameters: Optional['outputs.ScheduleTargetKinesisParameters'] = None,
                 retry_policy: Optional['outputs.ScheduleTargetRetryPolicy'] = None,
                 sagemaker_pipeline_parameters: Optional['outputs.ScheduleTargetSagemakerPipelineParameters'] = None,
                 sqs_parameters: Optional['outputs.ScheduleTargetSqsParameters'] = None):
        """
        :param str arn: ARN of the target of this schedule, such as a SQS queue or ECS cluster. For universal targets, this is a [Service ARN specific to the target service](https://docs.aws.amazon.com/scheduler/latest/UserGuide/managing-targets-universal.html#supported-universal-targets).
        :param str role_arn: ARN of the IAM role that EventBridge Scheduler will use for this target when the schedule is invoked. Read more in [Set up the execution role](https://docs.aws.amazon.com/scheduler/latest/UserGuide/setting-up.html#setting-up-execution-role).
               
               The following arguments are optional:
        :param 'ScheduleTargetDeadLetterConfigArgs' dead_letter_config: Information about an Amazon SQS queue that EventBridge Scheduler uses as a dead-letter queue for your schedule. If specified, EventBridge Scheduler delivers failed events that could not be successfully delivered to a target to the queue. Detailed below.
        :param 'ScheduleTargetEcsParametersArgs' ecs_parameters: Templated target type for the Amazon ECS [`RunTask`](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_RunTask.html) API operation. Detailed below.
        :param 'ScheduleTargetEventbridgeParametersArgs' eventbridge_parameters: Templated target type for the EventBridge [`PutEvents`](https://docs.aws.amazon.com/eventbridge/latest/APIReference/API_PutEvents.html) API operation. Detailed below.
        :param str input: Text, or well-formed JSON, passed to the target. Read more in [Universal target](https://docs.aws.amazon.com/scheduler/latest/UserGuide/managing-targets-universal.html).
        :param 'ScheduleTargetKinesisParametersArgs' kinesis_parameters: Templated target type for the Amazon Kinesis [`PutRecord`](https://docs.aws.amazon.com/kinesis/latest/APIReference/API_PutRecord.html) API operation. Detailed below.
        :param 'ScheduleTargetRetryPolicyArgs' retry_policy: Information about the retry policy settings. Detailed below.
        :param 'ScheduleTargetSagemakerPipelineParametersArgs' sagemaker_pipeline_parameters: Templated target type for the Amazon SageMaker [`StartPipelineExecution`](https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_StartPipelineExecution.html) API operation. Detailed below.
        :param 'ScheduleTargetSqsParametersArgs' sqs_parameters: The templated target type for the Amazon SQS [`SendMessage`](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/APIReference/API_SendMessage.html) API operation. Detailed below.
        """
        ScheduleTarget._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            role_arn=role_arn,
            dead_letter_config=dead_letter_config,
            ecs_parameters=ecs_parameters,
            eventbridge_parameters=eventbridge_parameters,
            input=input,
            kinesis_parameters=kinesis_parameters,
            retry_policy=retry_policy,
            sagemaker_pipeline_parameters=sagemaker_pipeline_parameters,
            sqs_parameters=sqs_parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             role_arn: Optional[str] = None,
             dead_letter_config: Optional['outputs.ScheduleTargetDeadLetterConfig'] = None,
             ecs_parameters: Optional['outputs.ScheduleTargetEcsParameters'] = None,
             eventbridge_parameters: Optional['outputs.ScheduleTargetEventbridgeParameters'] = None,
             input: Optional[str] = None,
             kinesis_parameters: Optional['outputs.ScheduleTargetKinesisParameters'] = None,
             retry_policy: Optional['outputs.ScheduleTargetRetryPolicy'] = None,
             sagemaker_pipeline_parameters: Optional['outputs.ScheduleTargetSagemakerPipelineParameters'] = None,
             sqs_parameters: Optional['outputs.ScheduleTargetSqsParameters'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if arn is None:
            raise TypeError("Missing 'arn' argument")
        if role_arn is None and 'roleArn' in kwargs:
            role_arn = kwargs['roleArn']
        if role_arn is None:
            raise TypeError("Missing 'role_arn' argument")
        if dead_letter_config is None and 'deadLetterConfig' in kwargs:
            dead_letter_config = kwargs['deadLetterConfig']
        if ecs_parameters is None and 'ecsParameters' in kwargs:
            ecs_parameters = kwargs['ecsParameters']
        if eventbridge_parameters is None and 'eventbridgeParameters' in kwargs:
            eventbridge_parameters = kwargs['eventbridgeParameters']
        if kinesis_parameters is None and 'kinesisParameters' in kwargs:
            kinesis_parameters = kwargs['kinesisParameters']
        if retry_policy is None and 'retryPolicy' in kwargs:
            retry_policy = kwargs['retryPolicy']
        if sagemaker_pipeline_parameters is None and 'sagemakerPipelineParameters' in kwargs:
            sagemaker_pipeline_parameters = kwargs['sagemakerPipelineParameters']
        if sqs_parameters is None and 'sqsParameters' in kwargs:
            sqs_parameters = kwargs['sqsParameters']

        _setter("arn", arn)
        _setter("role_arn", role_arn)
        if dead_letter_config is not None:
            _setter("dead_letter_config", dead_letter_config)
        if ecs_parameters is not None:
            _setter("ecs_parameters", ecs_parameters)
        if eventbridge_parameters is not None:
            _setter("eventbridge_parameters", eventbridge_parameters)
        if input is not None:
            _setter("input", input)
        if kinesis_parameters is not None:
            _setter("kinesis_parameters", kinesis_parameters)
        if retry_policy is not None:
            _setter("retry_policy", retry_policy)
        if sagemaker_pipeline_parameters is not None:
            _setter("sagemaker_pipeline_parameters", sagemaker_pipeline_parameters)
        if sqs_parameters is not None:
            _setter("sqs_parameters", sqs_parameters)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        ARN of the target of this schedule, such as a SQS queue or ECS cluster. For universal targets, this is a [Service ARN specific to the target service](https://docs.aws.amazon.com/scheduler/latest/UserGuide/managing-targets-universal.html#supported-universal-targets).
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> str:
        """
        ARN of the IAM role that EventBridge Scheduler will use for this target when the schedule is invoked. Read more in [Set up the execution role](https://docs.aws.amazon.com/scheduler/latest/UserGuide/setting-up.html#setting-up-execution-role).

        The following arguments are optional:
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="deadLetterConfig")
    def dead_letter_config(self) -> Optional['outputs.ScheduleTargetDeadLetterConfig']:
        """
        Information about an Amazon SQS queue that EventBridge Scheduler uses as a dead-letter queue for your schedule. If specified, EventBridge Scheduler delivers failed events that could not be successfully delivered to a target to the queue. Detailed below.
        """
        return pulumi.get(self, "dead_letter_config")

    @property
    @pulumi.getter(name="ecsParameters")
    def ecs_parameters(self) -> Optional['outputs.ScheduleTargetEcsParameters']:
        """
        Templated target type for the Amazon ECS [`RunTask`](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_RunTask.html) API operation. Detailed below.
        """
        return pulumi.get(self, "ecs_parameters")

    @property
    @pulumi.getter(name="eventbridgeParameters")
    def eventbridge_parameters(self) -> Optional['outputs.ScheduleTargetEventbridgeParameters']:
        """
        Templated target type for the EventBridge [`PutEvents`](https://docs.aws.amazon.com/eventbridge/latest/APIReference/API_PutEvents.html) API operation. Detailed below.
        """
        return pulumi.get(self, "eventbridge_parameters")

    @property
    @pulumi.getter
    def input(self) -> Optional[str]:
        """
        Text, or well-formed JSON, passed to the target. Read more in [Universal target](https://docs.aws.amazon.com/scheduler/latest/UserGuide/managing-targets-universal.html).
        """
        return pulumi.get(self, "input")

    @property
    @pulumi.getter(name="kinesisParameters")
    def kinesis_parameters(self) -> Optional['outputs.ScheduleTargetKinesisParameters']:
        """
        Templated target type for the Amazon Kinesis [`PutRecord`](https://docs.aws.amazon.com/kinesis/latest/APIReference/API_PutRecord.html) API operation. Detailed below.
        """
        return pulumi.get(self, "kinesis_parameters")

    @property
    @pulumi.getter(name="retryPolicy")
    def retry_policy(self) -> Optional['outputs.ScheduleTargetRetryPolicy']:
        """
        Information about the retry policy settings. Detailed below.
        """
        return pulumi.get(self, "retry_policy")

    @property
    @pulumi.getter(name="sagemakerPipelineParameters")
    def sagemaker_pipeline_parameters(self) -> Optional['outputs.ScheduleTargetSagemakerPipelineParameters']:
        """
        Templated target type for the Amazon SageMaker [`StartPipelineExecution`](https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_StartPipelineExecution.html) API operation. Detailed below.
        """
        return pulumi.get(self, "sagemaker_pipeline_parameters")

    @property
    @pulumi.getter(name="sqsParameters")
    def sqs_parameters(self) -> Optional['outputs.ScheduleTargetSqsParameters']:
        """
        The templated target type for the Amazon SQS [`SendMessage`](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/APIReference/API_SendMessage.html) API operation. Detailed below.
        """
        return pulumi.get(self, "sqs_parameters")


@pulumi.output_type
class ScheduleTargetDeadLetterConfig(dict):
    def __init__(__self__, *,
                 arn: str):
        """
        :param str arn: ARN of the SQS queue specified as the destination for the dead-letter queue.
        """
        ScheduleTargetDeadLetterConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if arn is None:
            raise TypeError("Missing 'arn' argument")

        _setter("arn", arn)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        ARN of the SQS queue specified as the destination for the dead-letter queue.
        """
        return pulumi.get(self, "arn")


@pulumi.output_type
class ScheduleTargetEcsParameters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taskDefinitionArn":
            suggest = "task_definition_arn"
        elif key == "capacityProviderStrategies":
            suggest = "capacity_provider_strategies"
        elif key == "enableEcsManagedTags":
            suggest = "enable_ecs_managed_tags"
        elif key == "enableExecuteCommand":
            suggest = "enable_execute_command"
        elif key == "launchType":
            suggest = "launch_type"
        elif key == "networkConfiguration":
            suggest = "network_configuration"
        elif key == "placementConstraints":
            suggest = "placement_constraints"
        elif key == "placementStrategies":
            suggest = "placement_strategies"
        elif key == "platformVersion":
            suggest = "platform_version"
        elif key == "propagateTags":
            suggest = "propagate_tags"
        elif key == "referenceId":
            suggest = "reference_id"
        elif key == "taskCount":
            suggest = "task_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduleTargetEcsParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduleTargetEcsParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduleTargetEcsParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 task_definition_arn: str,
                 capacity_provider_strategies: Optional[Sequence['outputs.ScheduleTargetEcsParametersCapacityProviderStrategy']] = None,
                 enable_ecs_managed_tags: Optional[bool] = None,
                 enable_execute_command: Optional[bool] = None,
                 group: Optional[str] = None,
                 launch_type: Optional[str] = None,
                 network_configuration: Optional['outputs.ScheduleTargetEcsParametersNetworkConfiguration'] = None,
                 placement_constraints: Optional[Sequence['outputs.ScheduleTargetEcsParametersPlacementConstraint']] = None,
                 placement_strategies: Optional[Sequence['outputs.ScheduleTargetEcsParametersPlacementStrategy']] = None,
                 platform_version: Optional[str] = None,
                 propagate_tags: Optional[str] = None,
                 reference_id: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 task_count: Optional[int] = None):
        """
        :param str task_definition_arn: ARN of the task definition to use.
               
               The following arguments are optional:
        :param Sequence['ScheduleTargetEcsParametersCapacityProviderStrategyArgs'] capacity_provider_strategies: Up to `6` capacity provider strategies to use for the task. Detailed below.
        :param bool enable_ecs_managed_tags: Specifies whether to enable Amazon ECS managed tags for the task. For more information, see [Tagging Your Amazon ECS Resources](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-using-tags.html) in the Amazon ECS Developer Guide.
        :param bool enable_execute_command: Specifies whether to enable the execute command functionality for the containers in this task.
        :param str group: Specifies an ECS task group for the task. At most 255 characters.
        :param str launch_type: Specifies the launch type on which your task is running. The launch type that you specify here must match one of the launch type (compatibilities) of the target task. One of: `EC2`, `FARGATE`, `EXTERNAL`.
        :param 'ScheduleTargetEcsParametersNetworkConfigurationArgs' network_configuration: Configures the networking associated with the task. Detailed below.
        :param Sequence['ScheduleTargetEcsParametersPlacementConstraintArgs'] placement_constraints: A set of up to 10 placement constraints to use for the task. Detailed below.
        :param Sequence['ScheduleTargetEcsParametersPlacementStrategyArgs'] placement_strategies: A set of up to 5 placement strategies. Detailed below.
        :param str platform_version: Specifies the platform version for the task. Specify only the numeric portion of the platform version, such as `1.1.0`.
        :param str propagate_tags: Specifies whether to propagate the tags from the task definition to the task. One of: `TASK_DEFINITION`.
        :param str reference_id: Reference ID to use for the task.
        :param Mapping[str, str] tags: The metadata that you apply to the task. Each tag consists of a key and an optional value. For more information, see [`RunTask`](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_RunTask.html) in the Amazon ECS API Reference.
        :param int task_count: The number of tasks to create. Ranges from `1` (default) to `10`.
        """
        ScheduleTargetEcsParameters._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            task_definition_arn=task_definition_arn,
            capacity_provider_strategies=capacity_provider_strategies,
            enable_ecs_managed_tags=enable_ecs_managed_tags,
            enable_execute_command=enable_execute_command,
            group=group,
            launch_type=launch_type,
            network_configuration=network_configuration,
            placement_constraints=placement_constraints,
            placement_strategies=placement_strategies,
            platform_version=platform_version,
            propagate_tags=propagate_tags,
            reference_id=reference_id,
            tags=tags,
            task_count=task_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             task_definition_arn: Optional[str] = None,
             capacity_provider_strategies: Optional[Sequence['outputs.ScheduleTargetEcsParametersCapacityProviderStrategy']] = None,
             enable_ecs_managed_tags: Optional[bool] = None,
             enable_execute_command: Optional[bool] = None,
             group: Optional[str] = None,
             launch_type: Optional[str] = None,
             network_configuration: Optional['outputs.ScheduleTargetEcsParametersNetworkConfiguration'] = None,
             placement_constraints: Optional[Sequence['outputs.ScheduleTargetEcsParametersPlacementConstraint']] = None,
             placement_strategies: Optional[Sequence['outputs.ScheduleTargetEcsParametersPlacementStrategy']] = None,
             platform_version: Optional[str] = None,
             propagate_tags: Optional[str] = None,
             reference_id: Optional[str] = None,
             tags: Optional[Mapping[str, str]] = None,
             task_count: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if task_definition_arn is None and 'taskDefinitionArn' in kwargs:
            task_definition_arn = kwargs['taskDefinitionArn']
        if task_definition_arn is None:
            raise TypeError("Missing 'task_definition_arn' argument")
        if capacity_provider_strategies is None and 'capacityProviderStrategies' in kwargs:
            capacity_provider_strategies = kwargs['capacityProviderStrategies']
        if enable_ecs_managed_tags is None and 'enableEcsManagedTags' in kwargs:
            enable_ecs_managed_tags = kwargs['enableEcsManagedTags']
        if enable_execute_command is None and 'enableExecuteCommand' in kwargs:
            enable_execute_command = kwargs['enableExecuteCommand']
        if launch_type is None and 'launchType' in kwargs:
            launch_type = kwargs['launchType']
        if network_configuration is None and 'networkConfiguration' in kwargs:
            network_configuration = kwargs['networkConfiguration']
        if placement_constraints is None and 'placementConstraints' in kwargs:
            placement_constraints = kwargs['placementConstraints']
        if placement_strategies is None and 'placementStrategies' in kwargs:
            placement_strategies = kwargs['placementStrategies']
        if platform_version is None and 'platformVersion' in kwargs:
            platform_version = kwargs['platformVersion']
        if propagate_tags is None and 'propagateTags' in kwargs:
            propagate_tags = kwargs['propagateTags']
        if reference_id is None and 'referenceId' in kwargs:
            reference_id = kwargs['referenceId']
        if task_count is None and 'taskCount' in kwargs:
            task_count = kwargs['taskCount']

        _setter("task_definition_arn", task_definition_arn)
        if capacity_provider_strategies is not None:
            _setter("capacity_provider_strategies", capacity_provider_strategies)
        if enable_ecs_managed_tags is not None:
            _setter("enable_ecs_managed_tags", enable_ecs_managed_tags)
        if enable_execute_command is not None:
            _setter("enable_execute_command", enable_execute_command)
        if group is not None:
            _setter("group", group)
        if launch_type is not None:
            _setter("launch_type", launch_type)
        if network_configuration is not None:
            _setter("network_configuration", network_configuration)
        if placement_constraints is not None:
            _setter("placement_constraints", placement_constraints)
        if placement_strategies is not None:
            _setter("placement_strategies", placement_strategies)
        if platform_version is not None:
            _setter("platform_version", platform_version)
        if propagate_tags is not None:
            _setter("propagate_tags", propagate_tags)
        if reference_id is not None:
            _setter("reference_id", reference_id)
        if tags is not None:
            _setter("tags", tags)
        if task_count is not None:
            _setter("task_count", task_count)

    @property
    @pulumi.getter(name="taskDefinitionArn")
    def task_definition_arn(self) -> str:
        """
        ARN of the task definition to use.

        The following arguments are optional:
        """
        return pulumi.get(self, "task_definition_arn")

    @property
    @pulumi.getter(name="capacityProviderStrategies")
    def capacity_provider_strategies(self) -> Optional[Sequence['outputs.ScheduleTargetEcsParametersCapacityProviderStrategy']]:
        """
        Up to `6` capacity provider strategies to use for the task. Detailed below.
        """
        return pulumi.get(self, "capacity_provider_strategies")

    @property
    @pulumi.getter(name="enableEcsManagedTags")
    def enable_ecs_managed_tags(self) -> Optional[bool]:
        """
        Specifies whether to enable Amazon ECS managed tags for the task. For more information, see [Tagging Your Amazon ECS Resources](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-using-tags.html) in the Amazon ECS Developer Guide.
        """
        return pulumi.get(self, "enable_ecs_managed_tags")

    @property
    @pulumi.getter(name="enableExecuteCommand")
    def enable_execute_command(self) -> Optional[bool]:
        """
        Specifies whether to enable the execute command functionality for the containers in this task.
        """
        return pulumi.get(self, "enable_execute_command")

    @property
    @pulumi.getter
    def group(self) -> Optional[str]:
        """
        Specifies an ECS task group for the task. At most 255 characters.
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter(name="launchType")
    def launch_type(self) -> Optional[str]:
        """
        Specifies the launch type on which your task is running. The launch type that you specify here must match one of the launch type (compatibilities) of the target task. One of: `EC2`, `FARGATE`, `EXTERNAL`.
        """
        return pulumi.get(self, "launch_type")

    @property
    @pulumi.getter(name="networkConfiguration")
    def network_configuration(self) -> Optional['outputs.ScheduleTargetEcsParametersNetworkConfiguration']:
        """
        Configures the networking associated with the task. Detailed below.
        """
        return pulumi.get(self, "network_configuration")

    @property
    @pulumi.getter(name="placementConstraints")
    def placement_constraints(self) -> Optional[Sequence['outputs.ScheduleTargetEcsParametersPlacementConstraint']]:
        """
        A set of up to 10 placement constraints to use for the task. Detailed below.
        """
        return pulumi.get(self, "placement_constraints")

    @property
    @pulumi.getter(name="placementStrategies")
    def placement_strategies(self) -> Optional[Sequence['outputs.ScheduleTargetEcsParametersPlacementStrategy']]:
        """
        A set of up to 5 placement strategies. Detailed below.
        """
        return pulumi.get(self, "placement_strategies")

    @property
    @pulumi.getter(name="platformVersion")
    def platform_version(self) -> Optional[str]:
        """
        Specifies the platform version for the task. Specify only the numeric portion of the platform version, such as `1.1.0`.
        """
        return pulumi.get(self, "platform_version")

    @property
    @pulumi.getter(name="propagateTags")
    def propagate_tags(self) -> Optional[str]:
        """
        Specifies whether to propagate the tags from the task definition to the task. One of: `TASK_DEFINITION`.
        """
        return pulumi.get(self, "propagate_tags")

    @property
    @pulumi.getter(name="referenceId")
    def reference_id(self) -> Optional[str]:
        """
        Reference ID to use for the task.
        """
        return pulumi.get(self, "reference_id")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        The metadata that you apply to the task. Each tag consists of a key and an optional value. For more information, see [`RunTask`](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_RunTask.html) in the Amazon ECS API Reference.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="taskCount")
    def task_count(self) -> Optional[int]:
        """
        The number of tasks to create. Ranges from `1` (default) to `10`.
        """
        return pulumi.get(self, "task_count")


@pulumi.output_type
class ScheduleTargetEcsParametersCapacityProviderStrategy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capacityProvider":
            suggest = "capacity_provider"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduleTargetEcsParametersCapacityProviderStrategy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduleTargetEcsParametersCapacityProviderStrategy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduleTargetEcsParametersCapacityProviderStrategy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capacity_provider: str,
                 base: Optional[int] = None,
                 weight: Optional[int] = None):
        """
        :param str capacity_provider: Short name of the capacity provider.
        :param int base: How many tasks, at a minimum, to run on the specified capacity provider. Only one capacity provider in a capacity provider strategy can have a base defined. Ranges from `0` (default) to `100000`.
        :param int weight: Designates the relative percentage of the total number of tasks launched that should use the specified capacity provider. The weight value is taken into consideration after the base value, if defined, is satisfied. Ranges from from `0` to `1000`.
        """
        ScheduleTargetEcsParametersCapacityProviderStrategy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            capacity_provider=capacity_provider,
            base=base,
            weight=weight,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             capacity_provider: Optional[str] = None,
             base: Optional[int] = None,
             weight: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if capacity_provider is None and 'capacityProvider' in kwargs:
            capacity_provider = kwargs['capacityProvider']
        if capacity_provider is None:
            raise TypeError("Missing 'capacity_provider' argument")

        _setter("capacity_provider", capacity_provider)
        if base is not None:
            _setter("base", base)
        if weight is not None:
            _setter("weight", weight)

    @property
    @pulumi.getter(name="capacityProvider")
    def capacity_provider(self) -> str:
        """
        Short name of the capacity provider.
        """
        return pulumi.get(self, "capacity_provider")

    @property
    @pulumi.getter
    def base(self) -> Optional[int]:
        """
        How many tasks, at a minimum, to run on the specified capacity provider. Only one capacity provider in a capacity provider strategy can have a base defined. Ranges from `0` (default) to `100000`.
        """
        return pulumi.get(self, "base")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        """
        Designates the relative percentage of the total number of tasks launched that should use the specified capacity provider. The weight value is taken into consideration after the base value, if defined, is satisfied. Ranges from from `0` to `1000`.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class ScheduleTargetEcsParametersNetworkConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "assignPublicIp":
            suggest = "assign_public_ip"
        elif key == "securityGroups":
            suggest = "security_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduleTargetEcsParametersNetworkConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduleTargetEcsParametersNetworkConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduleTargetEcsParametersNetworkConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subnets: Sequence[str],
                 assign_public_ip: Optional[bool] = None,
                 security_groups: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] subnets: Set of 1 to 16 subnets to be associated with the task. These subnets must all be in the same VPC.
        :param bool assign_public_ip: Specifies whether the task's elastic network interface receives a public IP address. This attribute is a boolean type, where `true` maps to `ENABLED` and `false` to `DISABLED`. You can specify `true` only when the `launch_type` is set to `FARGATE`.
        :param Sequence[str] security_groups: Set of 1 to 5 Security Group ID-s to be associated with the task. These security groups must all be in the same VPC.
        """
        ScheduleTargetEcsParametersNetworkConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            subnets=subnets,
            assign_public_ip=assign_public_ip,
            security_groups=security_groups,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             subnets: Optional[Sequence[str]] = None,
             assign_public_ip: Optional[bool] = None,
             security_groups: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if subnets is None:
            raise TypeError("Missing 'subnets' argument")
        if assign_public_ip is None and 'assignPublicIp' in kwargs:
            assign_public_ip = kwargs['assignPublicIp']
        if security_groups is None and 'securityGroups' in kwargs:
            security_groups = kwargs['securityGroups']

        _setter("subnets", subnets)
        if assign_public_ip is not None:
            _setter("assign_public_ip", assign_public_ip)
        if security_groups is not None:
            _setter("security_groups", security_groups)

    @property
    @pulumi.getter
    def subnets(self) -> Sequence[str]:
        """
        Set of 1 to 16 subnets to be associated with the task. These subnets must all be in the same VPC.
        """
        return pulumi.get(self, "subnets")

    @property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> Optional[bool]:
        """
        Specifies whether the task's elastic network interface receives a public IP address. This attribute is a boolean type, where `true` maps to `ENABLED` and `false` to `DISABLED`. You can specify `true` only when the `launch_type` is set to `FARGATE`.
        """
        return pulumi.get(self, "assign_public_ip")

    @property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[Sequence[str]]:
        """
        Set of 1 to 5 Security Group ID-s to be associated with the task. These security groups must all be in the same VPC.
        """
        return pulumi.get(self, "security_groups")


@pulumi.output_type
class ScheduleTargetEcsParametersPlacementConstraint(dict):
    def __init__(__self__, *,
                 type: str,
                 expression: Optional[str] = None):
        """
        :param str type: The type of constraint. One of: `distinctInstance`, `memberOf`.
        :param str expression: A cluster query language expression to apply to the constraint. You cannot specify an expression if the constraint type is `distinctInstance`. For more information, see [Cluster query language](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/cluster-query-language.html) in the Amazon ECS Developer Guide.
        """
        ScheduleTargetEcsParametersPlacementConstraint._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            expression=expression,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: Optional[str] = None,
             expression: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("type", type)
        if expression is not None:
            _setter("expression", expression)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of constraint. One of: `distinctInstance`, `memberOf`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def expression(self) -> Optional[str]:
        """
        A cluster query language expression to apply to the constraint. You cannot specify an expression if the constraint type is `distinctInstance`. For more information, see [Cluster query language](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/cluster-query-language.html) in the Amazon ECS Developer Guide.
        """
        return pulumi.get(self, "expression")


@pulumi.output_type
class ScheduleTargetEcsParametersPlacementStrategy(dict):
    def __init__(__self__, *,
                 type: str,
                 field: Optional[str] = None):
        """
        :param str type: The type of placement strategy. One of: `random`, `spread`, `binpack`.
        :param str field: The field to apply the placement strategy against.
        """
        ScheduleTargetEcsParametersPlacementStrategy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            field=field,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: Optional[str] = None,
             field: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("type", type)
        if field is not None:
            _setter("field", field)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of placement strategy. One of: `random`, `spread`, `binpack`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def field(self) -> Optional[str]:
        """
        The field to apply the placement strategy against.
        """
        return pulumi.get(self, "field")


@pulumi.output_type
class ScheduleTargetEventbridgeParameters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "detailType":
            suggest = "detail_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduleTargetEventbridgeParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduleTargetEventbridgeParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduleTargetEventbridgeParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 detail_type: str,
                 source: str):
        """
        :param str detail_type: Free-form string used to decide what fields to expect in the event detail. Up to 128 characters.
        :param str source: Source of the event.
        """
        ScheduleTargetEventbridgeParameters._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            detail_type=detail_type,
            source=source,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             detail_type: Optional[str] = None,
             source: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if detail_type is None and 'detailType' in kwargs:
            detail_type = kwargs['detailType']
        if detail_type is None:
            raise TypeError("Missing 'detail_type' argument")
        if source is None:
            raise TypeError("Missing 'source' argument")

        _setter("detail_type", detail_type)
        _setter("source", source)

    @property
    @pulumi.getter(name="detailType")
    def detail_type(self) -> str:
        """
        Free-form string used to decide what fields to expect in the event detail. Up to 128 characters.
        """
        return pulumi.get(self, "detail_type")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        Source of the event.
        """
        return pulumi.get(self, "source")


@pulumi.output_type
class ScheduleTargetKinesisParameters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "partitionKey":
            suggest = "partition_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduleTargetKinesisParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduleTargetKinesisParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduleTargetKinesisParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 partition_key: str):
        """
        :param str partition_key: Specifies the shard to which EventBridge Scheduler sends the event. Up to 256 characters.
        """
        ScheduleTargetKinesisParameters._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            partition_key=partition_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             partition_key: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if partition_key is None and 'partitionKey' in kwargs:
            partition_key = kwargs['partitionKey']
        if partition_key is None:
            raise TypeError("Missing 'partition_key' argument")

        _setter("partition_key", partition_key)

    @property
    @pulumi.getter(name="partitionKey")
    def partition_key(self) -> str:
        """
        Specifies the shard to which EventBridge Scheduler sends the event. Up to 256 characters.
        """
        return pulumi.get(self, "partition_key")


@pulumi.output_type
class ScheduleTargetRetryPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maximumEventAgeInSeconds":
            suggest = "maximum_event_age_in_seconds"
        elif key == "maximumRetryAttempts":
            suggest = "maximum_retry_attempts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduleTargetRetryPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduleTargetRetryPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduleTargetRetryPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 maximum_event_age_in_seconds: Optional[int] = None,
                 maximum_retry_attempts: Optional[int] = None):
        """
        :param int maximum_event_age_in_seconds: Maximum amount of time, in seconds, to continue to make retry attempts. Ranges from `60` to `86400` (default).
        :param int maximum_retry_attempts: Maximum number of retry attempts to make before the request fails. Ranges from `0` to `185` (default).
        """
        ScheduleTargetRetryPolicy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            maximum_event_age_in_seconds=maximum_event_age_in_seconds,
            maximum_retry_attempts=maximum_retry_attempts,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             maximum_event_age_in_seconds: Optional[int] = None,
             maximum_retry_attempts: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if maximum_event_age_in_seconds is None and 'maximumEventAgeInSeconds' in kwargs:
            maximum_event_age_in_seconds = kwargs['maximumEventAgeInSeconds']
        if maximum_retry_attempts is None and 'maximumRetryAttempts' in kwargs:
            maximum_retry_attempts = kwargs['maximumRetryAttempts']

        if maximum_event_age_in_seconds is not None:
            _setter("maximum_event_age_in_seconds", maximum_event_age_in_seconds)
        if maximum_retry_attempts is not None:
            _setter("maximum_retry_attempts", maximum_retry_attempts)

    @property
    @pulumi.getter(name="maximumEventAgeInSeconds")
    def maximum_event_age_in_seconds(self) -> Optional[int]:
        """
        Maximum amount of time, in seconds, to continue to make retry attempts. Ranges from `60` to `86400` (default).
        """
        return pulumi.get(self, "maximum_event_age_in_seconds")

    @property
    @pulumi.getter(name="maximumRetryAttempts")
    def maximum_retry_attempts(self) -> Optional[int]:
        """
        Maximum number of retry attempts to make before the request fails. Ranges from `0` to `185` (default).
        """
        return pulumi.get(self, "maximum_retry_attempts")


@pulumi.output_type
class ScheduleTargetSagemakerPipelineParameters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pipelineParameters":
            suggest = "pipeline_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduleTargetSagemakerPipelineParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduleTargetSagemakerPipelineParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduleTargetSagemakerPipelineParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pipeline_parameters: Optional[Sequence['outputs.ScheduleTargetSagemakerPipelineParametersPipelineParameter']] = None):
        """
        :param Sequence['ScheduleTargetSagemakerPipelineParametersPipelineParameterArgs'] pipeline_parameters: Set of up to 200 parameter names and values to use when executing the SageMaker Model Building Pipeline. Detailed below.
        """
        ScheduleTargetSagemakerPipelineParameters._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            pipeline_parameters=pipeline_parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             pipeline_parameters: Optional[Sequence['outputs.ScheduleTargetSagemakerPipelineParametersPipelineParameter']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if pipeline_parameters is None and 'pipelineParameters' in kwargs:
            pipeline_parameters = kwargs['pipelineParameters']

        if pipeline_parameters is not None:
            _setter("pipeline_parameters", pipeline_parameters)

    @property
    @pulumi.getter(name="pipelineParameters")
    def pipeline_parameters(self) -> Optional[Sequence['outputs.ScheduleTargetSagemakerPipelineParametersPipelineParameter']]:
        """
        Set of up to 200 parameter names and values to use when executing the SageMaker Model Building Pipeline. Detailed below.
        """
        return pulumi.get(self, "pipeline_parameters")


@pulumi.output_type
class ScheduleTargetSagemakerPipelineParametersPipelineParameter(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: Name of parameter to start execution of a SageMaker Model Building Pipeline.
        :param str value: Value of parameter to start execution of a SageMaker Model Building Pipeline.
        """
        ScheduleTargetSagemakerPipelineParametersPipelineParameter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("name", name)
        _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of parameter to start execution of a SageMaker Model Building Pipeline.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value of parameter to start execution of a SageMaker Model Building Pipeline.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ScheduleTargetSqsParameters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "messageGroupId":
            suggest = "message_group_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduleTargetSqsParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduleTargetSqsParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduleTargetSqsParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 message_group_id: Optional[str] = None):
        """
        :param str message_group_id: FIFO message group ID to use as the target.
        """
        ScheduleTargetSqsParameters._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            message_group_id=message_group_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             message_group_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if message_group_id is None and 'messageGroupId' in kwargs:
            message_group_id = kwargs['messageGroupId']

        if message_group_id is not None:
            _setter("message_group_id", message_group_id)

    @property
    @pulumi.getter(name="messageGroupId")
    def message_group_id(self) -> Optional[str]:
        """
        FIFO message group ID to use as the target.
        """
        return pulumi.get(self, "message_group_id")


