# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = [
    'MediaInsightsPipelineConfigurationElementArgs',
    'MediaInsightsPipelineConfigurationElementAmazonTranscribeCallAnalyticsProcessorConfigurationArgs',
    'MediaInsightsPipelineConfigurationElementAmazonTranscribeCallAnalyticsProcessorConfigurationPostCallAnalyticsSettingsArgs',
    'MediaInsightsPipelineConfigurationElementAmazonTranscribeProcessorConfigurationArgs',
    'MediaInsightsPipelineConfigurationElementKinesisDataStreamSinkConfigurationArgs',
    'MediaInsightsPipelineConfigurationElementLambdaFunctionSinkConfigurationArgs',
    'MediaInsightsPipelineConfigurationElementS3RecordingSinkConfigurationArgs',
    'MediaInsightsPipelineConfigurationElementSnsTopicSinkConfigurationArgs',
    'MediaInsightsPipelineConfigurationElementSqsQueueSinkConfigurationArgs',
    'MediaInsightsPipelineConfigurationElementVoiceAnalyticsProcessorConfigurationArgs',
    'MediaInsightsPipelineConfigurationRealTimeAlertConfigurationArgs',
    'MediaInsightsPipelineConfigurationRealTimeAlertConfigurationRuleArgs',
    'MediaInsightsPipelineConfigurationRealTimeAlertConfigurationRuleIssueDetectionConfigurationArgs',
    'MediaInsightsPipelineConfigurationRealTimeAlertConfigurationRuleKeywordMatchConfigurationArgs',
    'MediaInsightsPipelineConfigurationRealTimeAlertConfigurationRuleSentimentConfigurationArgs',
]

@pulumi.input_type
class MediaInsightsPipelineConfigurationElementArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 amazon_transcribe_call_analytics_processor_configuration: Optional[pulumi.Input['MediaInsightsPipelineConfigurationElementAmazonTranscribeCallAnalyticsProcessorConfigurationArgs']] = None,
                 amazon_transcribe_processor_configuration: Optional[pulumi.Input['MediaInsightsPipelineConfigurationElementAmazonTranscribeProcessorConfigurationArgs']] = None,
                 kinesis_data_stream_sink_configuration: Optional[pulumi.Input['MediaInsightsPipelineConfigurationElementKinesisDataStreamSinkConfigurationArgs']] = None,
                 lambda_function_sink_configuration: Optional[pulumi.Input['MediaInsightsPipelineConfigurationElementLambdaFunctionSinkConfigurationArgs']] = None,
                 s3_recording_sink_configuration: Optional[pulumi.Input['MediaInsightsPipelineConfigurationElementS3RecordingSinkConfigurationArgs']] = None,
                 sns_topic_sink_configuration: Optional[pulumi.Input['MediaInsightsPipelineConfigurationElementSnsTopicSinkConfigurationArgs']] = None,
                 sqs_queue_sink_configuration: Optional[pulumi.Input['MediaInsightsPipelineConfigurationElementSqsQueueSinkConfigurationArgs']] = None,
                 voice_analytics_processor_configuration: Optional[pulumi.Input['MediaInsightsPipelineConfigurationElementVoiceAnalyticsProcessorConfigurationArgs']] = None):
        """
        :param pulumi.Input[str] type: Element type.
        :param pulumi.Input['MediaInsightsPipelineConfigurationElementAmazonTranscribeCallAnalyticsProcessorConfigurationArgs'] amazon_transcribe_call_analytics_processor_configuration: Configuration for Amazon Transcribe Call Analytics processor.
        :param pulumi.Input['MediaInsightsPipelineConfigurationElementAmazonTranscribeProcessorConfigurationArgs'] amazon_transcribe_processor_configuration: Configuration for Amazon Transcribe processor.
        :param pulumi.Input['MediaInsightsPipelineConfigurationElementKinesisDataStreamSinkConfigurationArgs'] kinesis_data_stream_sink_configuration: Configuration for Kinesis Data Stream sink.
        :param pulumi.Input['MediaInsightsPipelineConfigurationElementLambdaFunctionSinkConfigurationArgs'] lambda_function_sink_configuration: Configuration for Lambda Function sink.
        :param pulumi.Input['MediaInsightsPipelineConfigurationElementS3RecordingSinkConfigurationArgs'] s3_recording_sink_configuration: Configuration for S3 recording sink.
        :param pulumi.Input['MediaInsightsPipelineConfigurationElementSnsTopicSinkConfigurationArgs'] sns_topic_sink_configuration: Configuration for SNS Topic sink.
        :param pulumi.Input['MediaInsightsPipelineConfigurationElementSqsQueueSinkConfigurationArgs'] sqs_queue_sink_configuration: Configuration for SQS Queue sink.
        :param pulumi.Input['MediaInsightsPipelineConfigurationElementVoiceAnalyticsProcessorConfigurationArgs'] voice_analytics_processor_configuration: Configuration for Voice analytics processor.
        """
        MediaInsightsPipelineConfigurationElementArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            amazon_transcribe_call_analytics_processor_configuration=amazon_transcribe_call_analytics_processor_configuration,
            amazon_transcribe_processor_configuration=amazon_transcribe_processor_configuration,
            kinesis_data_stream_sink_configuration=kinesis_data_stream_sink_configuration,
            lambda_function_sink_configuration=lambda_function_sink_configuration,
            s3_recording_sink_configuration=s3_recording_sink_configuration,
            sns_topic_sink_configuration=sns_topic_sink_configuration,
            sqs_queue_sink_configuration=sqs_queue_sink_configuration,
            voice_analytics_processor_configuration=voice_analytics_processor_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: Optional[pulumi.Input[str]] = None,
             amazon_transcribe_call_analytics_processor_configuration: Optional[pulumi.Input['MediaInsightsPipelineConfigurationElementAmazonTranscribeCallAnalyticsProcessorConfigurationArgs']] = None,
             amazon_transcribe_processor_configuration: Optional[pulumi.Input['MediaInsightsPipelineConfigurationElementAmazonTranscribeProcessorConfigurationArgs']] = None,
             kinesis_data_stream_sink_configuration: Optional[pulumi.Input['MediaInsightsPipelineConfigurationElementKinesisDataStreamSinkConfigurationArgs']] = None,
             lambda_function_sink_configuration: Optional[pulumi.Input['MediaInsightsPipelineConfigurationElementLambdaFunctionSinkConfigurationArgs']] = None,
             s3_recording_sink_configuration: Optional[pulumi.Input['MediaInsightsPipelineConfigurationElementS3RecordingSinkConfigurationArgs']] = None,
             sns_topic_sink_configuration: Optional[pulumi.Input['MediaInsightsPipelineConfigurationElementSnsTopicSinkConfigurationArgs']] = None,
             sqs_queue_sink_configuration: Optional[pulumi.Input['MediaInsightsPipelineConfigurationElementSqsQueueSinkConfigurationArgs']] = None,
             voice_analytics_processor_configuration: Optional[pulumi.Input['MediaInsightsPipelineConfigurationElementVoiceAnalyticsProcessorConfigurationArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if type is None:
            raise TypeError("Missing 'type' argument")
        if amazon_transcribe_call_analytics_processor_configuration is None and 'amazonTranscribeCallAnalyticsProcessorConfiguration' in kwargs:
            amazon_transcribe_call_analytics_processor_configuration = kwargs['amazonTranscribeCallAnalyticsProcessorConfiguration']
        if amazon_transcribe_processor_configuration is None and 'amazonTranscribeProcessorConfiguration' in kwargs:
            amazon_transcribe_processor_configuration = kwargs['amazonTranscribeProcessorConfiguration']
        if kinesis_data_stream_sink_configuration is None and 'kinesisDataStreamSinkConfiguration' in kwargs:
            kinesis_data_stream_sink_configuration = kwargs['kinesisDataStreamSinkConfiguration']
        if lambda_function_sink_configuration is None and 'lambdaFunctionSinkConfiguration' in kwargs:
            lambda_function_sink_configuration = kwargs['lambdaFunctionSinkConfiguration']
        if s3_recording_sink_configuration is None and 's3RecordingSinkConfiguration' in kwargs:
            s3_recording_sink_configuration = kwargs['s3RecordingSinkConfiguration']
        if sns_topic_sink_configuration is None and 'snsTopicSinkConfiguration' in kwargs:
            sns_topic_sink_configuration = kwargs['snsTopicSinkConfiguration']
        if sqs_queue_sink_configuration is None and 'sqsQueueSinkConfiguration' in kwargs:
            sqs_queue_sink_configuration = kwargs['sqsQueueSinkConfiguration']
        if voice_analytics_processor_configuration is None and 'voiceAnalyticsProcessorConfiguration' in kwargs:
            voice_analytics_processor_configuration = kwargs['voiceAnalyticsProcessorConfiguration']

        _setter("type", type)
        if amazon_transcribe_call_analytics_processor_configuration is not None:
            _setter("amazon_transcribe_call_analytics_processor_configuration", amazon_transcribe_call_analytics_processor_configuration)
        if amazon_transcribe_processor_configuration is not None:
            _setter("amazon_transcribe_processor_configuration", amazon_transcribe_processor_configuration)
        if kinesis_data_stream_sink_configuration is not None:
            _setter("kinesis_data_stream_sink_configuration", kinesis_data_stream_sink_configuration)
        if lambda_function_sink_configuration is not None:
            _setter("lambda_function_sink_configuration", lambda_function_sink_configuration)
        if s3_recording_sink_configuration is not None:
            _setter("s3_recording_sink_configuration", s3_recording_sink_configuration)
        if sns_topic_sink_configuration is not None:
            _setter("sns_topic_sink_configuration", sns_topic_sink_configuration)
        if sqs_queue_sink_configuration is not None:
            _setter("sqs_queue_sink_configuration", sqs_queue_sink_configuration)
        if voice_analytics_processor_configuration is not None:
            _setter("voice_analytics_processor_configuration", voice_analytics_processor_configuration)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Element type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="amazonTranscribeCallAnalyticsProcessorConfiguration")
    def amazon_transcribe_call_analytics_processor_configuration(self) -> Optional[pulumi.Input['MediaInsightsPipelineConfigurationElementAmazonTranscribeCallAnalyticsProcessorConfigurationArgs']]:
        """
        Configuration for Amazon Transcribe Call Analytics processor.
        """
        return pulumi.get(self, "amazon_transcribe_call_analytics_processor_configuration")

    @amazon_transcribe_call_analytics_processor_configuration.setter
    def amazon_transcribe_call_analytics_processor_configuration(self, value: Optional[pulumi.Input['MediaInsightsPipelineConfigurationElementAmazonTranscribeCallAnalyticsProcessorConfigurationArgs']]):
        pulumi.set(self, "amazon_transcribe_call_analytics_processor_configuration", value)

    @property
    @pulumi.getter(name="amazonTranscribeProcessorConfiguration")
    def amazon_transcribe_processor_configuration(self) -> Optional[pulumi.Input['MediaInsightsPipelineConfigurationElementAmazonTranscribeProcessorConfigurationArgs']]:
        """
        Configuration for Amazon Transcribe processor.
        """
        return pulumi.get(self, "amazon_transcribe_processor_configuration")

    @amazon_transcribe_processor_configuration.setter
    def amazon_transcribe_processor_configuration(self, value: Optional[pulumi.Input['MediaInsightsPipelineConfigurationElementAmazonTranscribeProcessorConfigurationArgs']]):
        pulumi.set(self, "amazon_transcribe_processor_configuration", value)

    @property
    @pulumi.getter(name="kinesisDataStreamSinkConfiguration")
    def kinesis_data_stream_sink_configuration(self) -> Optional[pulumi.Input['MediaInsightsPipelineConfigurationElementKinesisDataStreamSinkConfigurationArgs']]:
        """
        Configuration for Kinesis Data Stream sink.
        """
        return pulumi.get(self, "kinesis_data_stream_sink_configuration")

    @kinesis_data_stream_sink_configuration.setter
    def kinesis_data_stream_sink_configuration(self, value: Optional[pulumi.Input['MediaInsightsPipelineConfigurationElementKinesisDataStreamSinkConfigurationArgs']]):
        pulumi.set(self, "kinesis_data_stream_sink_configuration", value)

    @property
    @pulumi.getter(name="lambdaFunctionSinkConfiguration")
    def lambda_function_sink_configuration(self) -> Optional[pulumi.Input['MediaInsightsPipelineConfigurationElementLambdaFunctionSinkConfigurationArgs']]:
        """
        Configuration for Lambda Function sink.
        """
        return pulumi.get(self, "lambda_function_sink_configuration")

    @lambda_function_sink_configuration.setter
    def lambda_function_sink_configuration(self, value: Optional[pulumi.Input['MediaInsightsPipelineConfigurationElementLambdaFunctionSinkConfigurationArgs']]):
        pulumi.set(self, "lambda_function_sink_configuration", value)

    @property
    @pulumi.getter(name="s3RecordingSinkConfiguration")
    def s3_recording_sink_configuration(self) -> Optional[pulumi.Input['MediaInsightsPipelineConfigurationElementS3RecordingSinkConfigurationArgs']]:
        """
        Configuration for S3 recording sink.
        """
        return pulumi.get(self, "s3_recording_sink_configuration")

    @s3_recording_sink_configuration.setter
    def s3_recording_sink_configuration(self, value: Optional[pulumi.Input['MediaInsightsPipelineConfigurationElementS3RecordingSinkConfigurationArgs']]):
        pulumi.set(self, "s3_recording_sink_configuration", value)

    @property
    @pulumi.getter(name="snsTopicSinkConfiguration")
    def sns_topic_sink_configuration(self) -> Optional[pulumi.Input['MediaInsightsPipelineConfigurationElementSnsTopicSinkConfigurationArgs']]:
        """
        Configuration for SNS Topic sink.
        """
        return pulumi.get(self, "sns_topic_sink_configuration")

    @sns_topic_sink_configuration.setter
    def sns_topic_sink_configuration(self, value: Optional[pulumi.Input['MediaInsightsPipelineConfigurationElementSnsTopicSinkConfigurationArgs']]):
        pulumi.set(self, "sns_topic_sink_configuration", value)

    @property
    @pulumi.getter(name="sqsQueueSinkConfiguration")
    def sqs_queue_sink_configuration(self) -> Optional[pulumi.Input['MediaInsightsPipelineConfigurationElementSqsQueueSinkConfigurationArgs']]:
        """
        Configuration for SQS Queue sink.
        """
        return pulumi.get(self, "sqs_queue_sink_configuration")

    @sqs_queue_sink_configuration.setter
    def sqs_queue_sink_configuration(self, value: Optional[pulumi.Input['MediaInsightsPipelineConfigurationElementSqsQueueSinkConfigurationArgs']]):
        pulumi.set(self, "sqs_queue_sink_configuration", value)

    @property
    @pulumi.getter(name="voiceAnalyticsProcessorConfiguration")
    def voice_analytics_processor_configuration(self) -> Optional[pulumi.Input['MediaInsightsPipelineConfigurationElementVoiceAnalyticsProcessorConfigurationArgs']]:
        """
        Configuration for Voice analytics processor.
        """
        return pulumi.get(self, "voice_analytics_processor_configuration")

    @voice_analytics_processor_configuration.setter
    def voice_analytics_processor_configuration(self, value: Optional[pulumi.Input['MediaInsightsPipelineConfigurationElementVoiceAnalyticsProcessorConfigurationArgs']]):
        pulumi.set(self, "voice_analytics_processor_configuration", value)


@pulumi.input_type
class MediaInsightsPipelineConfigurationElementAmazonTranscribeCallAnalyticsProcessorConfigurationArgs:
    def __init__(__self__, *,
                 language_code: pulumi.Input[str],
                 call_analytics_stream_categories: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 content_identification_type: Optional[pulumi.Input[str]] = None,
                 content_redaction_type: Optional[pulumi.Input[str]] = None,
                 enable_partial_results_stabilization: Optional[pulumi.Input[bool]] = None,
                 filter_partial_results: Optional[pulumi.Input[bool]] = None,
                 language_model_name: Optional[pulumi.Input[str]] = None,
                 partial_results_stability: Optional[pulumi.Input[str]] = None,
                 pii_entity_types: Optional[pulumi.Input[str]] = None,
                 post_call_analytics_settings: Optional[pulumi.Input['MediaInsightsPipelineConfigurationElementAmazonTranscribeCallAnalyticsProcessorConfigurationPostCallAnalyticsSettingsArgs']] = None,
                 vocabulary_filter_method: Optional[pulumi.Input[str]] = None,
                 vocabulary_filter_name: Optional[pulumi.Input[str]] = None,
                 vocabulary_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] language_code: Language code for the transcription model.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] call_analytics_stream_categories: Filter for category events to be delivered to insights target.
        :param pulumi.Input[str] content_identification_type: Labels all personally identifiable information (PII) identified in Transcript events.
        :param pulumi.Input[str] content_redaction_type: Redacts all personally identifiable information (PII) identified in Transcript events.
        :param pulumi.Input[bool] enable_partial_results_stabilization: Enables partial result stabilization in Transcript events.
        :param pulumi.Input[bool] filter_partial_results: Filters partial Utterance events from delivery to the insights target.
        :param pulumi.Input[str] language_model_name: Name of custom language model for transcription.
        :param pulumi.Input[str] partial_results_stability: Level of stability to use when partial results stabilization is enabled.
        :param pulumi.Input[str] pii_entity_types: Types of personally identifiable information (PII) to redact from a Transcript event.
        :param pulumi.Input['MediaInsightsPipelineConfigurationElementAmazonTranscribeCallAnalyticsProcessorConfigurationPostCallAnalyticsSettingsArgs'] post_call_analytics_settings: Settings for post call analytics.
        :param pulumi.Input[str] vocabulary_filter_method: Method for applying a vocabulary filter to Transcript events.
        :param pulumi.Input[str] vocabulary_filter_name: Name of the custom vocabulary filter to use when processing Transcript events.
        :param pulumi.Input[str] vocabulary_name: Name of the custom vocabulary to use when processing Transcript events.
        """
        MediaInsightsPipelineConfigurationElementAmazonTranscribeCallAnalyticsProcessorConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            language_code=language_code,
            call_analytics_stream_categories=call_analytics_stream_categories,
            content_identification_type=content_identification_type,
            content_redaction_type=content_redaction_type,
            enable_partial_results_stabilization=enable_partial_results_stabilization,
            filter_partial_results=filter_partial_results,
            language_model_name=language_model_name,
            partial_results_stability=partial_results_stability,
            pii_entity_types=pii_entity_types,
            post_call_analytics_settings=post_call_analytics_settings,
            vocabulary_filter_method=vocabulary_filter_method,
            vocabulary_filter_name=vocabulary_filter_name,
            vocabulary_name=vocabulary_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             language_code: Optional[pulumi.Input[str]] = None,
             call_analytics_stream_categories: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             content_identification_type: Optional[pulumi.Input[str]] = None,
             content_redaction_type: Optional[pulumi.Input[str]] = None,
             enable_partial_results_stabilization: Optional[pulumi.Input[bool]] = None,
             filter_partial_results: Optional[pulumi.Input[bool]] = None,
             language_model_name: Optional[pulumi.Input[str]] = None,
             partial_results_stability: Optional[pulumi.Input[str]] = None,
             pii_entity_types: Optional[pulumi.Input[str]] = None,
             post_call_analytics_settings: Optional[pulumi.Input['MediaInsightsPipelineConfigurationElementAmazonTranscribeCallAnalyticsProcessorConfigurationPostCallAnalyticsSettingsArgs']] = None,
             vocabulary_filter_method: Optional[pulumi.Input[str]] = None,
             vocabulary_filter_name: Optional[pulumi.Input[str]] = None,
             vocabulary_name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if language_code is None and 'languageCode' in kwargs:
            language_code = kwargs['languageCode']
        if language_code is None:
            raise TypeError("Missing 'language_code' argument")
        if call_analytics_stream_categories is None and 'callAnalyticsStreamCategories' in kwargs:
            call_analytics_stream_categories = kwargs['callAnalyticsStreamCategories']
        if content_identification_type is None and 'contentIdentificationType' in kwargs:
            content_identification_type = kwargs['contentIdentificationType']
        if content_redaction_type is None and 'contentRedactionType' in kwargs:
            content_redaction_type = kwargs['contentRedactionType']
        if enable_partial_results_stabilization is None and 'enablePartialResultsStabilization' in kwargs:
            enable_partial_results_stabilization = kwargs['enablePartialResultsStabilization']
        if filter_partial_results is None and 'filterPartialResults' in kwargs:
            filter_partial_results = kwargs['filterPartialResults']
        if language_model_name is None and 'languageModelName' in kwargs:
            language_model_name = kwargs['languageModelName']
        if partial_results_stability is None and 'partialResultsStability' in kwargs:
            partial_results_stability = kwargs['partialResultsStability']
        if pii_entity_types is None and 'piiEntityTypes' in kwargs:
            pii_entity_types = kwargs['piiEntityTypes']
        if post_call_analytics_settings is None and 'postCallAnalyticsSettings' in kwargs:
            post_call_analytics_settings = kwargs['postCallAnalyticsSettings']
        if vocabulary_filter_method is None and 'vocabularyFilterMethod' in kwargs:
            vocabulary_filter_method = kwargs['vocabularyFilterMethod']
        if vocabulary_filter_name is None and 'vocabularyFilterName' in kwargs:
            vocabulary_filter_name = kwargs['vocabularyFilterName']
        if vocabulary_name is None and 'vocabularyName' in kwargs:
            vocabulary_name = kwargs['vocabularyName']

        _setter("language_code", language_code)
        if call_analytics_stream_categories is not None:
            _setter("call_analytics_stream_categories", call_analytics_stream_categories)
        if content_identification_type is not None:
            _setter("content_identification_type", content_identification_type)
        if content_redaction_type is not None:
            _setter("content_redaction_type", content_redaction_type)
        if enable_partial_results_stabilization is not None:
            _setter("enable_partial_results_stabilization", enable_partial_results_stabilization)
        if filter_partial_results is not None:
            _setter("filter_partial_results", filter_partial_results)
        if language_model_name is not None:
            _setter("language_model_name", language_model_name)
        if partial_results_stability is not None:
            _setter("partial_results_stability", partial_results_stability)
        if pii_entity_types is not None:
            _setter("pii_entity_types", pii_entity_types)
        if post_call_analytics_settings is not None:
            _setter("post_call_analytics_settings", post_call_analytics_settings)
        if vocabulary_filter_method is not None:
            _setter("vocabulary_filter_method", vocabulary_filter_method)
        if vocabulary_filter_name is not None:
            _setter("vocabulary_filter_name", vocabulary_filter_name)
        if vocabulary_name is not None:
            _setter("vocabulary_name", vocabulary_name)

    @property
    @pulumi.getter(name="languageCode")
    def language_code(self) -> pulumi.Input[str]:
        """
        Language code for the transcription model.
        """
        return pulumi.get(self, "language_code")

    @language_code.setter
    def language_code(self, value: pulumi.Input[str]):
        pulumi.set(self, "language_code", value)

    @property
    @pulumi.getter(name="callAnalyticsStreamCategories")
    def call_analytics_stream_categories(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Filter for category events to be delivered to insights target.
        """
        return pulumi.get(self, "call_analytics_stream_categories")

    @call_analytics_stream_categories.setter
    def call_analytics_stream_categories(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "call_analytics_stream_categories", value)

    @property
    @pulumi.getter(name="contentIdentificationType")
    def content_identification_type(self) -> Optional[pulumi.Input[str]]:
        """
        Labels all personally identifiable information (PII) identified in Transcript events.
        """
        return pulumi.get(self, "content_identification_type")

    @content_identification_type.setter
    def content_identification_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content_identification_type", value)

    @property
    @pulumi.getter(name="contentRedactionType")
    def content_redaction_type(self) -> Optional[pulumi.Input[str]]:
        """
        Redacts all personally identifiable information (PII) identified in Transcript events.
        """
        return pulumi.get(self, "content_redaction_type")

    @content_redaction_type.setter
    def content_redaction_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content_redaction_type", value)

    @property
    @pulumi.getter(name="enablePartialResultsStabilization")
    def enable_partial_results_stabilization(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables partial result stabilization in Transcript events.
        """
        return pulumi.get(self, "enable_partial_results_stabilization")

    @enable_partial_results_stabilization.setter
    def enable_partial_results_stabilization(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_partial_results_stabilization", value)

    @property
    @pulumi.getter(name="filterPartialResults")
    def filter_partial_results(self) -> Optional[pulumi.Input[bool]]:
        """
        Filters partial Utterance events from delivery to the insights target.
        """
        return pulumi.get(self, "filter_partial_results")

    @filter_partial_results.setter
    def filter_partial_results(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "filter_partial_results", value)

    @property
    @pulumi.getter(name="languageModelName")
    def language_model_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of custom language model for transcription.
        """
        return pulumi.get(self, "language_model_name")

    @language_model_name.setter
    def language_model_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "language_model_name", value)

    @property
    @pulumi.getter(name="partialResultsStability")
    def partial_results_stability(self) -> Optional[pulumi.Input[str]]:
        """
        Level of stability to use when partial results stabilization is enabled.
        """
        return pulumi.get(self, "partial_results_stability")

    @partial_results_stability.setter
    def partial_results_stability(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "partial_results_stability", value)

    @property
    @pulumi.getter(name="piiEntityTypes")
    def pii_entity_types(self) -> Optional[pulumi.Input[str]]:
        """
        Types of personally identifiable information (PII) to redact from a Transcript event.
        """
        return pulumi.get(self, "pii_entity_types")

    @pii_entity_types.setter
    def pii_entity_types(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pii_entity_types", value)

    @property
    @pulumi.getter(name="postCallAnalyticsSettings")
    def post_call_analytics_settings(self) -> Optional[pulumi.Input['MediaInsightsPipelineConfigurationElementAmazonTranscribeCallAnalyticsProcessorConfigurationPostCallAnalyticsSettingsArgs']]:
        """
        Settings for post call analytics.
        """
        return pulumi.get(self, "post_call_analytics_settings")

    @post_call_analytics_settings.setter
    def post_call_analytics_settings(self, value: Optional[pulumi.Input['MediaInsightsPipelineConfigurationElementAmazonTranscribeCallAnalyticsProcessorConfigurationPostCallAnalyticsSettingsArgs']]):
        pulumi.set(self, "post_call_analytics_settings", value)

    @property
    @pulumi.getter(name="vocabularyFilterMethod")
    def vocabulary_filter_method(self) -> Optional[pulumi.Input[str]]:
        """
        Method for applying a vocabulary filter to Transcript events.
        """
        return pulumi.get(self, "vocabulary_filter_method")

    @vocabulary_filter_method.setter
    def vocabulary_filter_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vocabulary_filter_method", value)

    @property
    @pulumi.getter(name="vocabularyFilterName")
    def vocabulary_filter_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the custom vocabulary filter to use when processing Transcript events.
        """
        return pulumi.get(self, "vocabulary_filter_name")

    @vocabulary_filter_name.setter
    def vocabulary_filter_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vocabulary_filter_name", value)

    @property
    @pulumi.getter(name="vocabularyName")
    def vocabulary_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the custom vocabulary to use when processing Transcript events.
        """
        return pulumi.get(self, "vocabulary_name")

    @vocabulary_name.setter
    def vocabulary_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vocabulary_name", value)


@pulumi.input_type
class MediaInsightsPipelineConfigurationElementAmazonTranscribeCallAnalyticsProcessorConfigurationPostCallAnalyticsSettingsArgs:
    def __init__(__self__, *,
                 data_access_role_arn: pulumi.Input[str],
                 output_location: pulumi.Input[str],
                 content_redaction_output: Optional[pulumi.Input[str]] = None,
                 output_encryption_kms_key_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_access_role_arn: ARN of the role used by AWS Transcribe to upload your post call analysis.
        :param pulumi.Input[str] output_location: The Amazon S3 location where you want your Call Analytics post-call transcription output stored.
        :param pulumi.Input[str] content_redaction_output: Should output be redacted.
        :param pulumi.Input[str] output_encryption_kms_key_id: ID of the KMS key used to encrypt the output.
        """
        MediaInsightsPipelineConfigurationElementAmazonTranscribeCallAnalyticsProcessorConfigurationPostCallAnalyticsSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_access_role_arn=data_access_role_arn,
            output_location=output_location,
            content_redaction_output=content_redaction_output,
            output_encryption_kms_key_id=output_encryption_kms_key_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_access_role_arn: Optional[pulumi.Input[str]] = None,
             output_location: Optional[pulumi.Input[str]] = None,
             content_redaction_output: Optional[pulumi.Input[str]] = None,
             output_encryption_kms_key_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if data_access_role_arn is None and 'dataAccessRoleArn' in kwargs:
            data_access_role_arn = kwargs['dataAccessRoleArn']
        if data_access_role_arn is None:
            raise TypeError("Missing 'data_access_role_arn' argument")
        if output_location is None and 'outputLocation' in kwargs:
            output_location = kwargs['outputLocation']
        if output_location is None:
            raise TypeError("Missing 'output_location' argument")
        if content_redaction_output is None and 'contentRedactionOutput' in kwargs:
            content_redaction_output = kwargs['contentRedactionOutput']
        if output_encryption_kms_key_id is None and 'outputEncryptionKmsKeyId' in kwargs:
            output_encryption_kms_key_id = kwargs['outputEncryptionKmsKeyId']

        _setter("data_access_role_arn", data_access_role_arn)
        _setter("output_location", output_location)
        if content_redaction_output is not None:
            _setter("content_redaction_output", content_redaction_output)
        if output_encryption_kms_key_id is not None:
            _setter("output_encryption_kms_key_id", output_encryption_kms_key_id)

    @property
    @pulumi.getter(name="dataAccessRoleArn")
    def data_access_role_arn(self) -> pulumi.Input[str]:
        """
        ARN of the role used by AWS Transcribe to upload your post call analysis.
        """
        return pulumi.get(self, "data_access_role_arn")

    @data_access_role_arn.setter
    def data_access_role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_access_role_arn", value)

    @property
    @pulumi.getter(name="outputLocation")
    def output_location(self) -> pulumi.Input[str]:
        """
        The Amazon S3 location where you want your Call Analytics post-call transcription output stored.
        """
        return pulumi.get(self, "output_location")

    @output_location.setter
    def output_location(self, value: pulumi.Input[str]):
        pulumi.set(self, "output_location", value)

    @property
    @pulumi.getter(name="contentRedactionOutput")
    def content_redaction_output(self) -> Optional[pulumi.Input[str]]:
        """
        Should output be redacted.
        """
        return pulumi.get(self, "content_redaction_output")

    @content_redaction_output.setter
    def content_redaction_output(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content_redaction_output", value)

    @property
    @pulumi.getter(name="outputEncryptionKmsKeyId")
    def output_encryption_kms_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the KMS key used to encrypt the output.
        """
        return pulumi.get(self, "output_encryption_kms_key_id")

    @output_encryption_kms_key_id.setter
    def output_encryption_kms_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "output_encryption_kms_key_id", value)


@pulumi.input_type
class MediaInsightsPipelineConfigurationElementAmazonTranscribeProcessorConfigurationArgs:
    def __init__(__self__, *,
                 language_code: pulumi.Input[str],
                 content_identification_type: Optional[pulumi.Input[str]] = None,
                 content_redaction_type: Optional[pulumi.Input[str]] = None,
                 enable_partial_results_stabilization: Optional[pulumi.Input[bool]] = None,
                 filter_partial_results: Optional[pulumi.Input[bool]] = None,
                 language_model_name: Optional[pulumi.Input[str]] = None,
                 partial_results_stability: Optional[pulumi.Input[str]] = None,
                 pii_entity_types: Optional[pulumi.Input[str]] = None,
                 show_speaker_label: Optional[pulumi.Input[bool]] = None,
                 vocabulary_filter_method: Optional[pulumi.Input[str]] = None,
                 vocabulary_filter_name: Optional[pulumi.Input[str]] = None,
                 vocabulary_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] language_code: Language code for the transcription model.
        :param pulumi.Input[str] content_identification_type: Labels all personally identifiable information (PII) identified in Transcript events.
        :param pulumi.Input[str] content_redaction_type: Redacts all personally identifiable information (PII) identified in Transcript events.
        :param pulumi.Input[bool] enable_partial_results_stabilization: Enables partial result stabilization in Transcript events.
        :param pulumi.Input[bool] filter_partial_results: Filters partial Utterance events from delivery to the insights target.
        :param pulumi.Input[str] language_model_name: Name of custom language model for transcription.
        :param pulumi.Input[str] partial_results_stability: Level of stability to use when partial results stabilization is enabled.
        :param pulumi.Input[str] pii_entity_types: Types of personally identifiable information (PII) to redact from a Transcript event.
        :param pulumi.Input[bool] show_speaker_label: Enables speaker partitioning (diarization) in your Transcript events.
        :param pulumi.Input[str] vocabulary_filter_method: Method for applying a vocabulary filter to Transcript events.
        :param pulumi.Input[str] vocabulary_filter_name: Name of the custom vocabulary filter to use when processing Transcript events.
        :param pulumi.Input[str] vocabulary_name: Name of the custom vocabulary to use when processing Transcript events.
        """
        MediaInsightsPipelineConfigurationElementAmazonTranscribeProcessorConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            language_code=language_code,
            content_identification_type=content_identification_type,
            content_redaction_type=content_redaction_type,
            enable_partial_results_stabilization=enable_partial_results_stabilization,
            filter_partial_results=filter_partial_results,
            language_model_name=language_model_name,
            partial_results_stability=partial_results_stability,
            pii_entity_types=pii_entity_types,
            show_speaker_label=show_speaker_label,
            vocabulary_filter_method=vocabulary_filter_method,
            vocabulary_filter_name=vocabulary_filter_name,
            vocabulary_name=vocabulary_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             language_code: Optional[pulumi.Input[str]] = None,
             content_identification_type: Optional[pulumi.Input[str]] = None,
             content_redaction_type: Optional[pulumi.Input[str]] = None,
             enable_partial_results_stabilization: Optional[pulumi.Input[bool]] = None,
             filter_partial_results: Optional[pulumi.Input[bool]] = None,
             language_model_name: Optional[pulumi.Input[str]] = None,
             partial_results_stability: Optional[pulumi.Input[str]] = None,
             pii_entity_types: Optional[pulumi.Input[str]] = None,
             show_speaker_label: Optional[pulumi.Input[bool]] = None,
             vocabulary_filter_method: Optional[pulumi.Input[str]] = None,
             vocabulary_filter_name: Optional[pulumi.Input[str]] = None,
             vocabulary_name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if language_code is None and 'languageCode' in kwargs:
            language_code = kwargs['languageCode']
        if language_code is None:
            raise TypeError("Missing 'language_code' argument")
        if content_identification_type is None and 'contentIdentificationType' in kwargs:
            content_identification_type = kwargs['contentIdentificationType']
        if content_redaction_type is None and 'contentRedactionType' in kwargs:
            content_redaction_type = kwargs['contentRedactionType']
        if enable_partial_results_stabilization is None and 'enablePartialResultsStabilization' in kwargs:
            enable_partial_results_stabilization = kwargs['enablePartialResultsStabilization']
        if filter_partial_results is None and 'filterPartialResults' in kwargs:
            filter_partial_results = kwargs['filterPartialResults']
        if language_model_name is None and 'languageModelName' in kwargs:
            language_model_name = kwargs['languageModelName']
        if partial_results_stability is None and 'partialResultsStability' in kwargs:
            partial_results_stability = kwargs['partialResultsStability']
        if pii_entity_types is None and 'piiEntityTypes' in kwargs:
            pii_entity_types = kwargs['piiEntityTypes']
        if show_speaker_label is None and 'showSpeakerLabel' in kwargs:
            show_speaker_label = kwargs['showSpeakerLabel']
        if vocabulary_filter_method is None and 'vocabularyFilterMethod' in kwargs:
            vocabulary_filter_method = kwargs['vocabularyFilterMethod']
        if vocabulary_filter_name is None and 'vocabularyFilterName' in kwargs:
            vocabulary_filter_name = kwargs['vocabularyFilterName']
        if vocabulary_name is None and 'vocabularyName' in kwargs:
            vocabulary_name = kwargs['vocabularyName']

        _setter("language_code", language_code)
        if content_identification_type is not None:
            _setter("content_identification_type", content_identification_type)
        if content_redaction_type is not None:
            _setter("content_redaction_type", content_redaction_type)
        if enable_partial_results_stabilization is not None:
            _setter("enable_partial_results_stabilization", enable_partial_results_stabilization)
        if filter_partial_results is not None:
            _setter("filter_partial_results", filter_partial_results)
        if language_model_name is not None:
            _setter("language_model_name", language_model_name)
        if partial_results_stability is not None:
            _setter("partial_results_stability", partial_results_stability)
        if pii_entity_types is not None:
            _setter("pii_entity_types", pii_entity_types)
        if show_speaker_label is not None:
            _setter("show_speaker_label", show_speaker_label)
        if vocabulary_filter_method is not None:
            _setter("vocabulary_filter_method", vocabulary_filter_method)
        if vocabulary_filter_name is not None:
            _setter("vocabulary_filter_name", vocabulary_filter_name)
        if vocabulary_name is not None:
            _setter("vocabulary_name", vocabulary_name)

    @property
    @pulumi.getter(name="languageCode")
    def language_code(self) -> pulumi.Input[str]:
        """
        Language code for the transcription model.
        """
        return pulumi.get(self, "language_code")

    @language_code.setter
    def language_code(self, value: pulumi.Input[str]):
        pulumi.set(self, "language_code", value)

    @property
    @pulumi.getter(name="contentIdentificationType")
    def content_identification_type(self) -> Optional[pulumi.Input[str]]:
        """
        Labels all personally identifiable information (PII) identified in Transcript events.
        """
        return pulumi.get(self, "content_identification_type")

    @content_identification_type.setter
    def content_identification_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content_identification_type", value)

    @property
    @pulumi.getter(name="contentRedactionType")
    def content_redaction_type(self) -> Optional[pulumi.Input[str]]:
        """
        Redacts all personally identifiable information (PII) identified in Transcript events.
        """
        return pulumi.get(self, "content_redaction_type")

    @content_redaction_type.setter
    def content_redaction_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content_redaction_type", value)

    @property
    @pulumi.getter(name="enablePartialResultsStabilization")
    def enable_partial_results_stabilization(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables partial result stabilization in Transcript events.
        """
        return pulumi.get(self, "enable_partial_results_stabilization")

    @enable_partial_results_stabilization.setter
    def enable_partial_results_stabilization(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_partial_results_stabilization", value)

    @property
    @pulumi.getter(name="filterPartialResults")
    def filter_partial_results(self) -> Optional[pulumi.Input[bool]]:
        """
        Filters partial Utterance events from delivery to the insights target.
        """
        return pulumi.get(self, "filter_partial_results")

    @filter_partial_results.setter
    def filter_partial_results(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "filter_partial_results", value)

    @property
    @pulumi.getter(name="languageModelName")
    def language_model_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of custom language model for transcription.
        """
        return pulumi.get(self, "language_model_name")

    @language_model_name.setter
    def language_model_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "language_model_name", value)

    @property
    @pulumi.getter(name="partialResultsStability")
    def partial_results_stability(self) -> Optional[pulumi.Input[str]]:
        """
        Level of stability to use when partial results stabilization is enabled.
        """
        return pulumi.get(self, "partial_results_stability")

    @partial_results_stability.setter
    def partial_results_stability(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "partial_results_stability", value)

    @property
    @pulumi.getter(name="piiEntityTypes")
    def pii_entity_types(self) -> Optional[pulumi.Input[str]]:
        """
        Types of personally identifiable information (PII) to redact from a Transcript event.
        """
        return pulumi.get(self, "pii_entity_types")

    @pii_entity_types.setter
    def pii_entity_types(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pii_entity_types", value)

    @property
    @pulumi.getter(name="showSpeakerLabel")
    def show_speaker_label(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables speaker partitioning (diarization) in your Transcript events.
        """
        return pulumi.get(self, "show_speaker_label")

    @show_speaker_label.setter
    def show_speaker_label(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "show_speaker_label", value)

    @property
    @pulumi.getter(name="vocabularyFilterMethod")
    def vocabulary_filter_method(self) -> Optional[pulumi.Input[str]]:
        """
        Method for applying a vocabulary filter to Transcript events.
        """
        return pulumi.get(self, "vocabulary_filter_method")

    @vocabulary_filter_method.setter
    def vocabulary_filter_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vocabulary_filter_method", value)

    @property
    @pulumi.getter(name="vocabularyFilterName")
    def vocabulary_filter_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the custom vocabulary filter to use when processing Transcript events.
        """
        return pulumi.get(self, "vocabulary_filter_name")

    @vocabulary_filter_name.setter
    def vocabulary_filter_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vocabulary_filter_name", value)

    @property
    @pulumi.getter(name="vocabularyName")
    def vocabulary_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the custom vocabulary to use when processing Transcript events.
        """
        return pulumi.get(self, "vocabulary_name")

    @vocabulary_name.setter
    def vocabulary_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vocabulary_name", value)


@pulumi.input_type
class MediaInsightsPipelineConfigurationElementKinesisDataStreamSinkConfigurationArgs:
    def __init__(__self__, *,
                 insights_target: pulumi.Input[str]):
        """
        :param pulumi.Input[str] insights_target: SQS queue to deliver results.
        """
        MediaInsightsPipelineConfigurationElementKinesisDataStreamSinkConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            insights_target=insights_target,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             insights_target: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if insights_target is None and 'insightsTarget' in kwargs:
            insights_target = kwargs['insightsTarget']
        if insights_target is None:
            raise TypeError("Missing 'insights_target' argument")

        _setter("insights_target", insights_target)

    @property
    @pulumi.getter(name="insightsTarget")
    def insights_target(self) -> pulumi.Input[str]:
        """
        SQS queue to deliver results.
        """
        return pulumi.get(self, "insights_target")

    @insights_target.setter
    def insights_target(self, value: pulumi.Input[str]):
        pulumi.set(self, "insights_target", value)


@pulumi.input_type
class MediaInsightsPipelineConfigurationElementLambdaFunctionSinkConfigurationArgs:
    def __init__(__self__, *,
                 insights_target: pulumi.Input[str]):
        """
        :param pulumi.Input[str] insights_target: SQS queue to deliver results.
        """
        MediaInsightsPipelineConfigurationElementLambdaFunctionSinkConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            insights_target=insights_target,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             insights_target: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if insights_target is None and 'insightsTarget' in kwargs:
            insights_target = kwargs['insightsTarget']
        if insights_target is None:
            raise TypeError("Missing 'insights_target' argument")

        _setter("insights_target", insights_target)

    @property
    @pulumi.getter(name="insightsTarget")
    def insights_target(self) -> pulumi.Input[str]:
        """
        SQS queue to deliver results.
        """
        return pulumi.get(self, "insights_target")

    @insights_target.setter
    def insights_target(self, value: pulumi.Input[str]):
        pulumi.set(self, "insights_target", value)


@pulumi.input_type
class MediaInsightsPipelineConfigurationElementS3RecordingSinkConfigurationArgs:
    def __init__(__self__, *,
                 destination: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] destination: S3 URI to deliver recordings.
        """
        MediaInsightsPipelineConfigurationElementS3RecordingSinkConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if destination is not None:
            _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input[str]]:
        """
        S3 URI to deliver recordings.
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class MediaInsightsPipelineConfigurationElementSnsTopicSinkConfigurationArgs:
    def __init__(__self__, *,
                 insights_target: pulumi.Input[str]):
        """
        :param pulumi.Input[str] insights_target: SQS queue to deliver results.
        """
        MediaInsightsPipelineConfigurationElementSnsTopicSinkConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            insights_target=insights_target,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             insights_target: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if insights_target is None and 'insightsTarget' in kwargs:
            insights_target = kwargs['insightsTarget']
        if insights_target is None:
            raise TypeError("Missing 'insights_target' argument")

        _setter("insights_target", insights_target)

    @property
    @pulumi.getter(name="insightsTarget")
    def insights_target(self) -> pulumi.Input[str]:
        """
        SQS queue to deliver results.
        """
        return pulumi.get(self, "insights_target")

    @insights_target.setter
    def insights_target(self, value: pulumi.Input[str]):
        pulumi.set(self, "insights_target", value)


@pulumi.input_type
class MediaInsightsPipelineConfigurationElementSqsQueueSinkConfigurationArgs:
    def __init__(__self__, *,
                 insights_target: pulumi.Input[str]):
        """
        :param pulumi.Input[str] insights_target: SQS queue to deliver results.
        """
        MediaInsightsPipelineConfigurationElementSqsQueueSinkConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            insights_target=insights_target,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             insights_target: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if insights_target is None and 'insightsTarget' in kwargs:
            insights_target = kwargs['insightsTarget']
        if insights_target is None:
            raise TypeError("Missing 'insights_target' argument")

        _setter("insights_target", insights_target)

    @property
    @pulumi.getter(name="insightsTarget")
    def insights_target(self) -> pulumi.Input[str]:
        """
        SQS queue to deliver results.
        """
        return pulumi.get(self, "insights_target")

    @insights_target.setter
    def insights_target(self, value: pulumi.Input[str]):
        pulumi.set(self, "insights_target", value)


@pulumi.input_type
class MediaInsightsPipelineConfigurationElementVoiceAnalyticsProcessorConfigurationArgs:
    def __init__(__self__, *,
                 speaker_search_status: pulumi.Input[str],
                 voice_tone_analysis_status: pulumi.Input[str]):
        """
        :param pulumi.Input[str] speaker_search_status: Enable speaker search.
        :param pulumi.Input[str] voice_tone_analysis_status: Enable voice tone analysis.
        """
        MediaInsightsPipelineConfigurationElementVoiceAnalyticsProcessorConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            speaker_search_status=speaker_search_status,
            voice_tone_analysis_status=voice_tone_analysis_status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             speaker_search_status: Optional[pulumi.Input[str]] = None,
             voice_tone_analysis_status: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if speaker_search_status is None and 'speakerSearchStatus' in kwargs:
            speaker_search_status = kwargs['speakerSearchStatus']
        if speaker_search_status is None:
            raise TypeError("Missing 'speaker_search_status' argument")
        if voice_tone_analysis_status is None and 'voiceToneAnalysisStatus' in kwargs:
            voice_tone_analysis_status = kwargs['voiceToneAnalysisStatus']
        if voice_tone_analysis_status is None:
            raise TypeError("Missing 'voice_tone_analysis_status' argument")

        _setter("speaker_search_status", speaker_search_status)
        _setter("voice_tone_analysis_status", voice_tone_analysis_status)

    @property
    @pulumi.getter(name="speakerSearchStatus")
    def speaker_search_status(self) -> pulumi.Input[str]:
        """
        Enable speaker search.
        """
        return pulumi.get(self, "speaker_search_status")

    @speaker_search_status.setter
    def speaker_search_status(self, value: pulumi.Input[str]):
        pulumi.set(self, "speaker_search_status", value)

    @property
    @pulumi.getter(name="voiceToneAnalysisStatus")
    def voice_tone_analysis_status(self) -> pulumi.Input[str]:
        """
        Enable voice tone analysis.
        """
        return pulumi.get(self, "voice_tone_analysis_status")

    @voice_tone_analysis_status.setter
    def voice_tone_analysis_status(self, value: pulumi.Input[str]):
        pulumi.set(self, "voice_tone_analysis_status", value)


@pulumi.input_type
class MediaInsightsPipelineConfigurationRealTimeAlertConfigurationArgs:
    def __init__(__self__, *,
                 rules: pulumi.Input[Sequence[pulumi.Input['MediaInsightsPipelineConfigurationRealTimeAlertConfigurationRuleArgs']]],
                 disabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['MediaInsightsPipelineConfigurationRealTimeAlertConfigurationRuleArgs']]] rules: Collection of real time alert rules
        :param pulumi.Input[bool] disabled: Disables real time alert rules.
        """
        MediaInsightsPipelineConfigurationRealTimeAlertConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            rules=rules,
            disabled=disabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             rules: Optional[pulumi.Input[Sequence[pulumi.Input['MediaInsightsPipelineConfigurationRealTimeAlertConfigurationRuleArgs']]]] = None,
             disabled: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if rules is None:
            raise TypeError("Missing 'rules' argument")

        _setter("rules", rules)
        if disabled is not None:
            _setter("disabled", disabled)

    @property
    @pulumi.getter
    def rules(self) -> pulumi.Input[Sequence[pulumi.Input['MediaInsightsPipelineConfigurationRealTimeAlertConfigurationRuleArgs']]]:
        """
        Collection of real time alert rules
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: pulumi.Input[Sequence[pulumi.Input['MediaInsightsPipelineConfigurationRealTimeAlertConfigurationRuleArgs']]]):
        pulumi.set(self, "rules", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Disables real time alert rules.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disabled", value)


@pulumi.input_type
class MediaInsightsPipelineConfigurationRealTimeAlertConfigurationRuleArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 issue_detection_configuration: Optional[pulumi.Input['MediaInsightsPipelineConfigurationRealTimeAlertConfigurationRuleIssueDetectionConfigurationArgs']] = None,
                 keyword_match_configuration: Optional[pulumi.Input['MediaInsightsPipelineConfigurationRealTimeAlertConfigurationRuleKeywordMatchConfigurationArgs']] = None,
                 sentiment_configuration: Optional[pulumi.Input['MediaInsightsPipelineConfigurationRealTimeAlertConfigurationRuleSentimentConfigurationArgs']] = None):
        """
        :param pulumi.Input[str] type: Element type.
        :param pulumi.Input['MediaInsightsPipelineConfigurationRealTimeAlertConfigurationRuleIssueDetectionConfigurationArgs'] issue_detection_configuration: Configuration for an issue detection rule.
        :param pulumi.Input['MediaInsightsPipelineConfigurationRealTimeAlertConfigurationRuleKeywordMatchConfigurationArgs'] keyword_match_configuration: Configuration for a keyword match rule.
        :param pulumi.Input['MediaInsightsPipelineConfigurationRealTimeAlertConfigurationRuleSentimentConfigurationArgs'] sentiment_configuration: Configuration for a sentiment rule.
        """
        MediaInsightsPipelineConfigurationRealTimeAlertConfigurationRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            issue_detection_configuration=issue_detection_configuration,
            keyword_match_configuration=keyword_match_configuration,
            sentiment_configuration=sentiment_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: Optional[pulumi.Input[str]] = None,
             issue_detection_configuration: Optional[pulumi.Input['MediaInsightsPipelineConfigurationRealTimeAlertConfigurationRuleIssueDetectionConfigurationArgs']] = None,
             keyword_match_configuration: Optional[pulumi.Input['MediaInsightsPipelineConfigurationRealTimeAlertConfigurationRuleKeywordMatchConfigurationArgs']] = None,
             sentiment_configuration: Optional[pulumi.Input['MediaInsightsPipelineConfigurationRealTimeAlertConfigurationRuleSentimentConfigurationArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if type is None:
            raise TypeError("Missing 'type' argument")
        if issue_detection_configuration is None and 'issueDetectionConfiguration' in kwargs:
            issue_detection_configuration = kwargs['issueDetectionConfiguration']
        if keyword_match_configuration is None and 'keywordMatchConfiguration' in kwargs:
            keyword_match_configuration = kwargs['keywordMatchConfiguration']
        if sentiment_configuration is None and 'sentimentConfiguration' in kwargs:
            sentiment_configuration = kwargs['sentimentConfiguration']

        _setter("type", type)
        if issue_detection_configuration is not None:
            _setter("issue_detection_configuration", issue_detection_configuration)
        if keyword_match_configuration is not None:
            _setter("keyword_match_configuration", keyword_match_configuration)
        if sentiment_configuration is not None:
            _setter("sentiment_configuration", sentiment_configuration)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Element type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="issueDetectionConfiguration")
    def issue_detection_configuration(self) -> Optional[pulumi.Input['MediaInsightsPipelineConfigurationRealTimeAlertConfigurationRuleIssueDetectionConfigurationArgs']]:
        """
        Configuration for an issue detection rule.
        """
        return pulumi.get(self, "issue_detection_configuration")

    @issue_detection_configuration.setter
    def issue_detection_configuration(self, value: Optional[pulumi.Input['MediaInsightsPipelineConfigurationRealTimeAlertConfigurationRuleIssueDetectionConfigurationArgs']]):
        pulumi.set(self, "issue_detection_configuration", value)

    @property
    @pulumi.getter(name="keywordMatchConfiguration")
    def keyword_match_configuration(self) -> Optional[pulumi.Input['MediaInsightsPipelineConfigurationRealTimeAlertConfigurationRuleKeywordMatchConfigurationArgs']]:
        """
        Configuration for a keyword match rule.
        """
        return pulumi.get(self, "keyword_match_configuration")

    @keyword_match_configuration.setter
    def keyword_match_configuration(self, value: Optional[pulumi.Input['MediaInsightsPipelineConfigurationRealTimeAlertConfigurationRuleKeywordMatchConfigurationArgs']]):
        pulumi.set(self, "keyword_match_configuration", value)

    @property
    @pulumi.getter(name="sentimentConfiguration")
    def sentiment_configuration(self) -> Optional[pulumi.Input['MediaInsightsPipelineConfigurationRealTimeAlertConfigurationRuleSentimentConfigurationArgs']]:
        """
        Configuration for a sentiment rule.
        """
        return pulumi.get(self, "sentiment_configuration")

    @sentiment_configuration.setter
    def sentiment_configuration(self, value: Optional[pulumi.Input['MediaInsightsPipelineConfigurationRealTimeAlertConfigurationRuleSentimentConfigurationArgs']]):
        pulumi.set(self, "sentiment_configuration", value)


@pulumi.input_type
class MediaInsightsPipelineConfigurationRealTimeAlertConfigurationRuleIssueDetectionConfigurationArgs:
    def __init__(__self__, *,
                 rule_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] rule_name: Rule name.
        """
        MediaInsightsPipelineConfigurationRealTimeAlertConfigurationRuleIssueDetectionConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            rule_name=rule_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             rule_name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if rule_name is None and 'ruleName' in kwargs:
            rule_name = kwargs['ruleName']
        if rule_name is None:
            raise TypeError("Missing 'rule_name' argument")

        _setter("rule_name", rule_name)

    @property
    @pulumi.getter(name="ruleName")
    def rule_name(self) -> pulumi.Input[str]:
        """
        Rule name.
        """
        return pulumi.get(self, "rule_name")

    @rule_name.setter
    def rule_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "rule_name", value)


@pulumi.input_type
class MediaInsightsPipelineConfigurationRealTimeAlertConfigurationRuleKeywordMatchConfigurationArgs:
    def __init__(__self__, *,
                 keywords: pulumi.Input[Sequence[pulumi.Input[str]]],
                 rule_name: pulumi.Input[str],
                 negate: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] keywords: Collection of keywords to match.
        :param pulumi.Input[str] rule_name: Rule name.
        :param pulumi.Input[bool] negate: Negate the rule.
        """
        MediaInsightsPipelineConfigurationRealTimeAlertConfigurationRuleKeywordMatchConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            keywords=keywords,
            rule_name=rule_name,
            negate=negate,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             keywords: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             rule_name: Optional[pulumi.Input[str]] = None,
             negate: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if keywords is None:
            raise TypeError("Missing 'keywords' argument")
        if rule_name is None and 'ruleName' in kwargs:
            rule_name = kwargs['ruleName']
        if rule_name is None:
            raise TypeError("Missing 'rule_name' argument")

        _setter("keywords", keywords)
        _setter("rule_name", rule_name)
        if negate is not None:
            _setter("negate", negate)

    @property
    @pulumi.getter
    def keywords(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Collection of keywords to match.
        """
        return pulumi.get(self, "keywords")

    @keywords.setter
    def keywords(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "keywords", value)

    @property
    @pulumi.getter(name="ruleName")
    def rule_name(self) -> pulumi.Input[str]:
        """
        Rule name.
        """
        return pulumi.get(self, "rule_name")

    @rule_name.setter
    def rule_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "rule_name", value)

    @property
    @pulumi.getter
    def negate(self) -> Optional[pulumi.Input[bool]]:
        """
        Negate the rule.
        """
        return pulumi.get(self, "negate")

    @negate.setter
    def negate(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negate", value)


@pulumi.input_type
class MediaInsightsPipelineConfigurationRealTimeAlertConfigurationRuleSentimentConfigurationArgs:
    def __init__(__self__, *,
                 rule_name: pulumi.Input[str],
                 sentiment_type: pulumi.Input[str],
                 time_period: pulumi.Input[int]):
        """
        :param pulumi.Input[str] rule_name: Rule name.
        :param pulumi.Input[str] sentiment_type: Sentiment type to match.
        :param pulumi.Input[int] time_period: Analysis interval.
        """
        MediaInsightsPipelineConfigurationRealTimeAlertConfigurationRuleSentimentConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            rule_name=rule_name,
            sentiment_type=sentiment_type,
            time_period=time_period,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             rule_name: Optional[pulumi.Input[str]] = None,
             sentiment_type: Optional[pulumi.Input[str]] = None,
             time_period: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if rule_name is None and 'ruleName' in kwargs:
            rule_name = kwargs['ruleName']
        if rule_name is None:
            raise TypeError("Missing 'rule_name' argument")
        if sentiment_type is None and 'sentimentType' in kwargs:
            sentiment_type = kwargs['sentimentType']
        if sentiment_type is None:
            raise TypeError("Missing 'sentiment_type' argument")
        if time_period is None and 'timePeriod' in kwargs:
            time_period = kwargs['timePeriod']
        if time_period is None:
            raise TypeError("Missing 'time_period' argument")

        _setter("rule_name", rule_name)
        _setter("sentiment_type", sentiment_type)
        _setter("time_period", time_period)

    @property
    @pulumi.getter(name="ruleName")
    def rule_name(self) -> pulumi.Input[str]:
        """
        Rule name.
        """
        return pulumi.get(self, "rule_name")

    @rule_name.setter
    def rule_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "rule_name", value)

    @property
    @pulumi.getter(name="sentimentType")
    def sentiment_type(self) -> pulumi.Input[str]:
        """
        Sentiment type to match.
        """
        return pulumi.get(self, "sentiment_type")

    @sentiment_type.setter
    def sentiment_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "sentiment_type", value)

    @property
    @pulumi.getter(name="timePeriod")
    def time_period(self) -> pulumi.Input[int]:
        """
        Analysis interval.
        """
        return pulumi.get(self, "time_period")

    @time_period.setter
    def time_period(self, value: pulumi.Input[int]):
        pulumi.set(self, "time_period", value)


