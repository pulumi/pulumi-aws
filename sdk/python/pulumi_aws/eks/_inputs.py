# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'AccessPolicyAssociationAccessScopeArgs',
    'AccessPolicyAssociationAccessScopeArgsDict',
    'AddonPodIdentityAssociationArgs',
    'AddonPodIdentityAssociationArgsDict',
    'CapabilityConfigurationArgs',
    'CapabilityConfigurationArgsDict',
    'CapabilityConfigurationArgoCdArgs',
    'CapabilityConfigurationArgoCdArgsDict',
    'CapabilityConfigurationArgoCdAwsIdcArgs',
    'CapabilityConfigurationArgoCdAwsIdcArgsDict',
    'CapabilityConfigurationArgoCdNetworkAccessArgs',
    'CapabilityConfigurationArgoCdNetworkAccessArgsDict',
    'CapabilityConfigurationArgoCdRbacRoleMappingArgs',
    'CapabilityConfigurationArgoCdRbacRoleMappingArgsDict',
    'CapabilityConfigurationArgoCdRbacRoleMappingIdentityArgs',
    'CapabilityConfigurationArgoCdRbacRoleMappingIdentityArgsDict',
    'CapabilityTimeoutsArgs',
    'CapabilityTimeoutsArgsDict',
    'ClusterAccessConfigArgs',
    'ClusterAccessConfigArgsDict',
    'ClusterCertificateAuthorityArgs',
    'ClusterCertificateAuthorityArgsDict',
    'ClusterComputeConfigArgs',
    'ClusterComputeConfigArgsDict',
    'ClusterControlPlaneScalingConfigArgs',
    'ClusterControlPlaneScalingConfigArgsDict',
    'ClusterEncryptionConfigArgs',
    'ClusterEncryptionConfigArgsDict',
    'ClusterEncryptionConfigProviderArgs',
    'ClusterEncryptionConfigProviderArgsDict',
    'ClusterIdentityArgs',
    'ClusterIdentityArgsDict',
    'ClusterIdentityOidcArgs',
    'ClusterIdentityOidcArgsDict',
    'ClusterKubernetesNetworkConfigArgs',
    'ClusterKubernetesNetworkConfigArgsDict',
    'ClusterKubernetesNetworkConfigElasticLoadBalancingArgs',
    'ClusterKubernetesNetworkConfigElasticLoadBalancingArgsDict',
    'ClusterOutpostConfigArgs',
    'ClusterOutpostConfigArgsDict',
    'ClusterOutpostConfigControlPlanePlacementArgs',
    'ClusterOutpostConfigControlPlanePlacementArgsDict',
    'ClusterRemoteNetworkConfigArgs',
    'ClusterRemoteNetworkConfigArgsDict',
    'ClusterRemoteNetworkConfigRemoteNodeNetworksArgs',
    'ClusterRemoteNetworkConfigRemoteNodeNetworksArgsDict',
    'ClusterRemoteNetworkConfigRemotePodNetworksArgs',
    'ClusterRemoteNetworkConfigRemotePodNetworksArgsDict',
    'ClusterStorageConfigArgs',
    'ClusterStorageConfigArgsDict',
    'ClusterStorageConfigBlockStorageArgs',
    'ClusterStorageConfigBlockStorageArgsDict',
    'ClusterUpgradePolicyArgs',
    'ClusterUpgradePolicyArgsDict',
    'ClusterVpcConfigArgs',
    'ClusterVpcConfigArgsDict',
    'ClusterZonalShiftConfigArgs',
    'ClusterZonalShiftConfigArgsDict',
    'FargateProfileSelectorArgs',
    'FargateProfileSelectorArgsDict',
    'IdentityProviderConfigOidcArgs',
    'IdentityProviderConfigOidcArgsDict',
    'NodeGroupLaunchTemplateArgs',
    'NodeGroupLaunchTemplateArgsDict',
    'NodeGroupNodeRepairConfigArgs',
    'NodeGroupNodeRepairConfigArgsDict',
    'NodeGroupNodeRepairConfigNodeRepairConfigOverrideArgs',
    'NodeGroupNodeRepairConfigNodeRepairConfigOverrideArgsDict',
    'NodeGroupRemoteAccessArgs',
    'NodeGroupRemoteAccessArgsDict',
    'NodeGroupResourceArgs',
    'NodeGroupResourceArgsDict',
    'NodeGroupResourceAutoscalingGroupArgs',
    'NodeGroupResourceAutoscalingGroupArgsDict',
    'NodeGroupScalingConfigArgs',
    'NodeGroupScalingConfigArgsDict',
    'NodeGroupTaintArgs',
    'NodeGroupTaintArgsDict',
    'NodeGroupUpdateConfigArgs',
    'NodeGroupUpdateConfigArgsDict',
]

MYPY = False

if not MYPY:
    class AccessPolicyAssociationAccessScopeArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        namespaces: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    AccessPolicyAssociationAccessScopeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyAssociationAccessScopeArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "type", type)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "namespaces", value)


if not MYPY:
    class AddonPodIdentityAssociationArgsDict(TypedDict):
        role_arn: pulumi.Input[_builtins.str]
        service_account: pulumi.Input[_builtins.str]
elif False:
    AddonPodIdentityAssociationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AddonPodIdentityAssociationArgs:
    def __init__(__self__, *,
                 role_arn: pulumi.Input[_builtins.str],
                 service_account: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "service_account", service_account)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="serviceAccount")
    def service_account(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "service_account")

    @service_account.setter
    def service_account(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "service_account", value)


if not MYPY:
    class CapabilityConfigurationArgsDict(TypedDict):
        argo_cd: NotRequired[pulumi.Input['CapabilityConfigurationArgoCdArgsDict']]
elif False:
    CapabilityConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CapabilityConfigurationArgs:
    def __init__(__self__, *,
                 argo_cd: Optional[pulumi.Input['CapabilityConfigurationArgoCdArgs']] = None):
        if argo_cd is not None:
            pulumi.set(__self__, "argo_cd", argo_cd)

    @_builtins.property
    @pulumi.getter(name="argoCd")
    def argo_cd(self) -> Optional[pulumi.Input['CapabilityConfigurationArgoCdArgs']]:
        return pulumi.get(self, "argo_cd")

    @argo_cd.setter
    def argo_cd(self, value: Optional[pulumi.Input['CapabilityConfigurationArgoCdArgs']]):
        pulumi.set(self, "argo_cd", value)


if not MYPY:
    class CapabilityConfigurationArgoCdArgsDict(TypedDict):
        aws_idc: NotRequired[pulumi.Input['CapabilityConfigurationArgoCdAwsIdcArgsDict']]
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        network_access: NotRequired[pulumi.Input['CapabilityConfigurationArgoCdNetworkAccessArgsDict']]
        rbac_role_mappings: NotRequired[pulumi.Input[Sequence[pulumi.Input['CapabilityConfigurationArgoCdRbacRoleMappingArgsDict']]]]
        server_url: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    CapabilityConfigurationArgoCdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CapabilityConfigurationArgoCdArgs:
    def __init__(__self__, *,
                 aws_idc: Optional[pulumi.Input['CapabilityConfigurationArgoCdAwsIdcArgs']] = None,
                 namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 network_access: Optional[pulumi.Input['CapabilityConfigurationArgoCdNetworkAccessArgs']] = None,
                 rbac_role_mappings: Optional[pulumi.Input[Sequence[pulumi.Input['CapabilityConfigurationArgoCdRbacRoleMappingArgs']]]] = None,
                 server_url: Optional[pulumi.Input[_builtins.str]] = None):
        if aws_idc is not None:
            pulumi.set(__self__, "aws_idc", aws_idc)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if network_access is not None:
            pulumi.set(__self__, "network_access", network_access)
        if rbac_role_mappings is not None:
            pulumi.set(__self__, "rbac_role_mappings", rbac_role_mappings)
        if server_url is not None:
            pulumi.set(__self__, "server_url", server_url)

    @_builtins.property
    @pulumi.getter(name="awsIdc")
    def aws_idc(self) -> Optional[pulumi.Input['CapabilityConfigurationArgoCdAwsIdcArgs']]:
        return pulumi.get(self, "aws_idc")

    @aws_idc.setter
    def aws_idc(self, value: Optional[pulumi.Input['CapabilityConfigurationArgoCdAwsIdcArgs']]):
        pulumi.set(self, "aws_idc", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter(name="networkAccess")
    def network_access(self) -> Optional[pulumi.Input['CapabilityConfigurationArgoCdNetworkAccessArgs']]:
        return pulumi.get(self, "network_access")

    @network_access.setter
    def network_access(self, value: Optional[pulumi.Input['CapabilityConfigurationArgoCdNetworkAccessArgs']]):
        pulumi.set(self, "network_access", value)

    @_builtins.property
    @pulumi.getter(name="rbacRoleMappings")
    def rbac_role_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CapabilityConfigurationArgoCdRbacRoleMappingArgs']]]]:
        return pulumi.get(self, "rbac_role_mappings")

    @rbac_role_mappings.setter
    def rbac_role_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CapabilityConfigurationArgoCdRbacRoleMappingArgs']]]]):
        pulumi.set(self, "rbac_role_mappings", value)

    @_builtins.property
    @pulumi.getter(name="serverUrl")
    def server_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "server_url")

    @server_url.setter
    def server_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "server_url", value)


if not MYPY:
    class CapabilityConfigurationArgoCdAwsIdcArgsDict(TypedDict):
        idc_instance_arn: pulumi.Input[_builtins.str]
        idc_managed_application_arn: NotRequired[pulumi.Input[_builtins.str]]
        idc_region: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    CapabilityConfigurationArgoCdAwsIdcArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CapabilityConfigurationArgoCdAwsIdcArgs:
    def __init__(__self__, *,
                 idc_instance_arn: pulumi.Input[_builtins.str],
                 idc_managed_application_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 idc_region: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "idc_instance_arn", idc_instance_arn)
        if idc_managed_application_arn is not None:
            pulumi.set(__self__, "idc_managed_application_arn", idc_managed_application_arn)
        if idc_region is not None:
            pulumi.set(__self__, "idc_region", idc_region)

    @_builtins.property
    @pulumi.getter(name="idcInstanceArn")
    def idc_instance_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "idc_instance_arn")

    @idc_instance_arn.setter
    def idc_instance_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "idc_instance_arn", value)

    @_builtins.property
    @pulumi.getter(name="idcManagedApplicationArn")
    def idc_managed_application_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "idc_managed_application_arn")

    @idc_managed_application_arn.setter
    def idc_managed_application_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "idc_managed_application_arn", value)

    @_builtins.property
    @pulumi.getter(name="idcRegion")
    def idc_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "idc_region")

    @idc_region.setter
    def idc_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "idc_region", value)


if not MYPY:
    class CapabilityConfigurationArgoCdNetworkAccessArgsDict(TypedDict):
        vpce_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    CapabilityConfigurationArgoCdNetworkAccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CapabilityConfigurationArgoCdNetworkAccessArgs:
    def __init__(__self__, *,
                 vpce_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if vpce_ids is not None:
            pulumi.set(__self__, "vpce_ids", vpce_ids)

    @_builtins.property
    @pulumi.getter(name="vpceIds")
    def vpce_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "vpce_ids")

    @vpce_ids.setter
    def vpce_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "vpce_ids", value)


if not MYPY:
    class CapabilityConfigurationArgoCdRbacRoleMappingArgsDict(TypedDict):
        role: pulumi.Input[_builtins.str]
        identities: NotRequired[pulumi.Input[Sequence[pulumi.Input['CapabilityConfigurationArgoCdRbacRoleMappingIdentityArgsDict']]]]
elif False:
    CapabilityConfigurationArgoCdRbacRoleMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CapabilityConfigurationArgoCdRbacRoleMappingArgs:
    def __init__(__self__, *,
                 role: pulumi.Input[_builtins.str],
                 identities: Optional[pulumi.Input[Sequence[pulumi.Input['CapabilityConfigurationArgoCdRbacRoleMappingIdentityArgs']]]] = None):
        pulumi.set(__self__, "role", role)
        if identities is not None:
            pulumi.set(__self__, "identities", identities)

    @_builtins.property
    @pulumi.getter
    def role(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role", value)

    @_builtins.property
    @pulumi.getter
    def identities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CapabilityConfigurationArgoCdRbacRoleMappingIdentityArgs']]]]:
        return pulumi.get(self, "identities")

    @identities.setter
    def identities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CapabilityConfigurationArgoCdRbacRoleMappingIdentityArgs']]]]):
        pulumi.set(self, "identities", value)


if not MYPY:
    class CapabilityConfigurationArgoCdRbacRoleMappingIdentityArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        type: pulumi.Input[_builtins.str]
elif False:
    CapabilityConfigurationArgoCdRbacRoleMappingIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CapabilityConfigurationArgoCdRbacRoleMappingIdentityArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class CapabilityTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    CapabilityTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CapabilityTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class ClusterAccessConfigArgsDict(TypedDict):
        authentication_mode: NotRequired[pulumi.Input[_builtins.str]]
        bootstrap_cluster_creator_admin_permissions: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    ClusterAccessConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterAccessConfigArgs:
    def __init__(__self__, *,
                 authentication_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 bootstrap_cluster_creator_admin_permissions: Optional[pulumi.Input[_builtins.bool]] = None):
        if authentication_mode is not None:
            pulumi.set(__self__, "authentication_mode", authentication_mode)
        if bootstrap_cluster_creator_admin_permissions is not None:
            pulumi.set(__self__, "bootstrap_cluster_creator_admin_permissions", bootstrap_cluster_creator_admin_permissions)

    @_builtins.property
    @pulumi.getter(name="authenticationMode")
    def authentication_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "authentication_mode")

    @authentication_mode.setter
    def authentication_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "authentication_mode", value)

    @_builtins.property
    @pulumi.getter(name="bootstrapClusterCreatorAdminPermissions")
    def bootstrap_cluster_creator_admin_permissions(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "bootstrap_cluster_creator_admin_permissions")

    @bootstrap_cluster_creator_admin_permissions.setter
    def bootstrap_cluster_creator_admin_permissions(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "bootstrap_cluster_creator_admin_permissions", value)


if not MYPY:
    class ClusterCertificateAuthorityArgsDict(TypedDict):
        data: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ClusterCertificateAuthorityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterCertificateAuthorityArgs:
    def __init__(__self__, *,
                 data: Optional[pulumi.Input[_builtins.str]] = None):
        if data is not None:
            pulumi.set(__self__, "data", data)

    @_builtins.property
    @pulumi.getter
    def data(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "data")

    @data.setter
    def data(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "data", value)


if not MYPY:
    class ClusterComputeConfigArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        node_pools: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        node_role_arn: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ClusterComputeConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterComputeConfigArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 node_pools: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 node_role_arn: Optional[pulumi.Input[_builtins.str]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if node_pools is not None:
            pulumi.set(__self__, "node_pools", node_pools)
        if node_role_arn is not None:
            pulumi.set(__self__, "node_role_arn", node_role_arn)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="nodePools")
    def node_pools(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "node_pools")

    @node_pools.setter
    def node_pools(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "node_pools", value)

    @_builtins.property
    @pulumi.getter(name="nodeRoleArn")
    def node_role_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "node_role_arn")

    @node_role_arn.setter
    def node_role_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "node_role_arn", value)


if not MYPY:
    class ClusterControlPlaneScalingConfigArgsDict(TypedDict):
        tier: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ClusterControlPlaneScalingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterControlPlaneScalingConfigArgs:
    def __init__(__self__, *,
                 tier: Optional[pulumi.Input[_builtins.str]] = None):
        if tier is not None:
            pulumi.set(__self__, "tier", tier)

    @_builtins.property
    @pulumi.getter
    def tier(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "tier")

    @tier.setter
    def tier(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tier", value)


if not MYPY:
    class ClusterEncryptionConfigArgsDict(TypedDict):
        provider: pulumi.Input['ClusterEncryptionConfigProviderArgsDict']
        resources: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
elif False:
    ClusterEncryptionConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterEncryptionConfigArgs:
    def __init__(__self__, *,
                 provider: pulumi.Input['ClusterEncryptionConfigProviderArgs'],
                 resources: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(__self__, "provider", provider)
        pulumi.set(__self__, "resources", resources)

    @_builtins.property
    @pulumi.getter
    def provider(self) -> pulumi.Input['ClusterEncryptionConfigProviderArgs']:
        return pulumi.get(self, "provider")

    @provider.setter
    def provider(self, value: pulumi.Input['ClusterEncryptionConfigProviderArgs']):
        pulumi.set(self, "provider", value)

    @_builtins.property
    @pulumi.getter
    def resources(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "resources", value)


if not MYPY:
    class ClusterEncryptionConfigProviderArgsDict(TypedDict):
        key_arn: pulumi.Input[_builtins.str]
elif False:
    ClusterEncryptionConfigProviderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterEncryptionConfigProviderArgs:
    def __init__(__self__, *,
                 key_arn: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "key_arn", key_arn)

    @_builtins.property
    @pulumi.getter(name="keyArn")
    def key_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "key_arn")

    @key_arn.setter
    def key_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key_arn", value)


if not MYPY:
    class ClusterIdentityArgsDict(TypedDict):
        oidcs: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterIdentityOidcArgsDict']]]]
elif False:
    ClusterIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterIdentityArgs:
    def __init__(__self__, *,
                 oidcs: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterIdentityOidcArgs']]]] = None):
        if oidcs is not None:
            pulumi.set(__self__, "oidcs", oidcs)

    @_builtins.property
    @pulumi.getter
    def oidcs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterIdentityOidcArgs']]]]:
        return pulumi.get(self, "oidcs")

    @oidcs.setter
    def oidcs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterIdentityOidcArgs']]]]):
        pulumi.set(self, "oidcs", value)


if not MYPY:
    class ClusterIdentityOidcArgsDict(TypedDict):
        issuer: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ClusterIdentityOidcArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterIdentityOidcArgs:
    def __init__(__self__, *,
                 issuer: Optional[pulumi.Input[_builtins.str]] = None):
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)

    @_builtins.property
    @pulumi.getter
    def issuer(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "issuer")

    @issuer.setter
    def issuer(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "issuer", value)


if not MYPY:
    class ClusterKubernetesNetworkConfigArgsDict(TypedDict):
        elastic_load_balancing: NotRequired[pulumi.Input['ClusterKubernetesNetworkConfigElasticLoadBalancingArgsDict']]
        ip_family: NotRequired[pulumi.Input[_builtins.str]]
        service_ipv4_cidr: NotRequired[pulumi.Input[_builtins.str]]
        service_ipv6_cidr: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ClusterKubernetesNetworkConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterKubernetesNetworkConfigArgs:
    def __init__(__self__, *,
                 elastic_load_balancing: Optional[pulumi.Input['ClusterKubernetesNetworkConfigElasticLoadBalancingArgs']] = None,
                 ip_family: Optional[pulumi.Input[_builtins.str]] = None,
                 service_ipv4_cidr: Optional[pulumi.Input[_builtins.str]] = None,
                 service_ipv6_cidr: Optional[pulumi.Input[_builtins.str]] = None):
        if elastic_load_balancing is not None:
            pulumi.set(__self__, "elastic_load_balancing", elastic_load_balancing)
        if ip_family is not None:
            pulumi.set(__self__, "ip_family", ip_family)
        if service_ipv4_cidr is not None:
            pulumi.set(__self__, "service_ipv4_cidr", service_ipv4_cidr)
        if service_ipv6_cidr is not None:
            pulumi.set(__self__, "service_ipv6_cidr", service_ipv6_cidr)

    @_builtins.property
    @pulumi.getter(name="elasticLoadBalancing")
    def elastic_load_balancing(self) -> Optional[pulumi.Input['ClusterKubernetesNetworkConfigElasticLoadBalancingArgs']]:
        return pulumi.get(self, "elastic_load_balancing")

    @elastic_load_balancing.setter
    def elastic_load_balancing(self, value: Optional[pulumi.Input['ClusterKubernetesNetworkConfigElasticLoadBalancingArgs']]):
        pulumi.set(self, "elastic_load_balancing", value)

    @_builtins.property
    @pulumi.getter(name="ipFamily")
    def ip_family(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "ip_family")

    @ip_family.setter
    def ip_family(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip_family", value)

    @_builtins.property
    @pulumi.getter(name="serviceIpv4Cidr")
    def service_ipv4_cidr(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "service_ipv4_cidr")

    @service_ipv4_cidr.setter
    def service_ipv4_cidr(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service_ipv4_cidr", value)

    @_builtins.property
    @pulumi.getter(name="serviceIpv6Cidr")
    def service_ipv6_cidr(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "service_ipv6_cidr")

    @service_ipv6_cidr.setter
    def service_ipv6_cidr(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service_ipv6_cidr", value)


if not MYPY:
    class ClusterKubernetesNetworkConfigElasticLoadBalancingArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    ClusterKubernetesNetworkConfigElasticLoadBalancingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterKubernetesNetworkConfigElasticLoadBalancingArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class ClusterOutpostConfigArgsDict(TypedDict):
        control_plane_instance_type: pulumi.Input[_builtins.str]
        outpost_arns: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        control_plane_placement: NotRequired[pulumi.Input['ClusterOutpostConfigControlPlanePlacementArgsDict']]
elif False:
    ClusterOutpostConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterOutpostConfigArgs:
    def __init__(__self__, *,
                 control_plane_instance_type: pulumi.Input[_builtins.str],
                 outpost_arns: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 control_plane_placement: Optional[pulumi.Input['ClusterOutpostConfigControlPlanePlacementArgs']] = None):
        pulumi.set(__self__, "control_plane_instance_type", control_plane_instance_type)
        pulumi.set(__self__, "outpost_arns", outpost_arns)
        if control_plane_placement is not None:
            pulumi.set(__self__, "control_plane_placement", control_plane_placement)

    @_builtins.property
    @pulumi.getter(name="controlPlaneInstanceType")
    def control_plane_instance_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "control_plane_instance_type")

    @control_plane_instance_type.setter
    def control_plane_instance_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "control_plane_instance_type", value)

    @_builtins.property
    @pulumi.getter(name="outpostArns")
    def outpost_arns(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "outpost_arns")

    @outpost_arns.setter
    def outpost_arns(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "outpost_arns", value)

    @_builtins.property
    @pulumi.getter(name="controlPlanePlacement")
    def control_plane_placement(self) -> Optional[pulumi.Input['ClusterOutpostConfigControlPlanePlacementArgs']]:
        return pulumi.get(self, "control_plane_placement")

    @control_plane_placement.setter
    def control_plane_placement(self, value: Optional[pulumi.Input['ClusterOutpostConfigControlPlanePlacementArgs']]):
        pulumi.set(self, "control_plane_placement", value)


if not MYPY:
    class ClusterOutpostConfigControlPlanePlacementArgsDict(TypedDict):
        group_name: pulumi.Input[_builtins.str]
elif False:
    ClusterOutpostConfigControlPlanePlacementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterOutpostConfigControlPlanePlacementArgs:
    def __init__(__self__, *,
                 group_name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "group_name", group_name)

    @_builtins.property
    @pulumi.getter(name="groupName")
    def group_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "group_name")

    @group_name.setter
    def group_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "group_name", value)


if not MYPY:
    class ClusterRemoteNetworkConfigArgsDict(TypedDict):
        remote_node_networks: pulumi.Input['ClusterRemoteNetworkConfigRemoteNodeNetworksArgsDict']
        remote_pod_networks: NotRequired[pulumi.Input['ClusterRemoteNetworkConfigRemotePodNetworksArgsDict']]
elif False:
    ClusterRemoteNetworkConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRemoteNetworkConfigArgs:
    def __init__(__self__, *,
                 remote_node_networks: pulumi.Input['ClusterRemoteNetworkConfigRemoteNodeNetworksArgs'],
                 remote_pod_networks: Optional[pulumi.Input['ClusterRemoteNetworkConfigRemotePodNetworksArgs']] = None):
        pulumi.set(__self__, "remote_node_networks", remote_node_networks)
        if remote_pod_networks is not None:
            pulumi.set(__self__, "remote_pod_networks", remote_pod_networks)

    @_builtins.property
    @pulumi.getter(name="remoteNodeNetworks")
    def remote_node_networks(self) -> pulumi.Input['ClusterRemoteNetworkConfigRemoteNodeNetworksArgs']:
        return pulumi.get(self, "remote_node_networks")

    @remote_node_networks.setter
    def remote_node_networks(self, value: pulumi.Input['ClusterRemoteNetworkConfigRemoteNodeNetworksArgs']):
        pulumi.set(self, "remote_node_networks", value)

    @_builtins.property
    @pulumi.getter(name="remotePodNetworks")
    def remote_pod_networks(self) -> Optional[pulumi.Input['ClusterRemoteNetworkConfigRemotePodNetworksArgs']]:
        return pulumi.get(self, "remote_pod_networks")

    @remote_pod_networks.setter
    def remote_pod_networks(self, value: Optional[pulumi.Input['ClusterRemoteNetworkConfigRemotePodNetworksArgs']]):
        pulumi.set(self, "remote_pod_networks", value)


if not MYPY:
    class ClusterRemoteNetworkConfigRemoteNodeNetworksArgsDict(TypedDict):
        cidrs: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    ClusterRemoteNetworkConfigRemoteNodeNetworksArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRemoteNetworkConfigRemoteNodeNetworksArgs:
    def __init__(__self__, *,
                 cidrs: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if cidrs is not None:
            pulumi.set(__self__, "cidrs", cidrs)

    @_builtins.property
    @pulumi.getter
    def cidrs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "cidrs")

    @cidrs.setter
    def cidrs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "cidrs", value)


if not MYPY:
    class ClusterRemoteNetworkConfigRemotePodNetworksArgsDict(TypedDict):
        cidrs: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    ClusterRemoteNetworkConfigRemotePodNetworksArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRemoteNetworkConfigRemotePodNetworksArgs:
    def __init__(__self__, *,
                 cidrs: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if cidrs is not None:
            pulumi.set(__self__, "cidrs", cidrs)

    @_builtins.property
    @pulumi.getter
    def cidrs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "cidrs")

    @cidrs.setter
    def cidrs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "cidrs", value)


if not MYPY:
    class ClusterStorageConfigArgsDict(TypedDict):
        block_storage: NotRequired[pulumi.Input['ClusterStorageConfigBlockStorageArgsDict']]
elif False:
    ClusterStorageConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterStorageConfigArgs:
    def __init__(__self__, *,
                 block_storage: Optional[pulumi.Input['ClusterStorageConfigBlockStorageArgs']] = None):
        if block_storage is not None:
            pulumi.set(__self__, "block_storage", block_storage)

    @_builtins.property
    @pulumi.getter(name="blockStorage")
    def block_storage(self) -> Optional[pulumi.Input['ClusterStorageConfigBlockStorageArgs']]:
        return pulumi.get(self, "block_storage")

    @block_storage.setter
    def block_storage(self, value: Optional[pulumi.Input['ClusterStorageConfigBlockStorageArgs']]):
        pulumi.set(self, "block_storage", value)


if not MYPY:
    class ClusterStorageConfigBlockStorageArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    ClusterStorageConfigBlockStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterStorageConfigBlockStorageArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class ClusterUpgradePolicyArgsDict(TypedDict):
        support_type: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ClusterUpgradePolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterUpgradePolicyArgs:
    def __init__(__self__, *,
                 support_type: Optional[pulumi.Input[_builtins.str]] = None):
        if support_type is not None:
            pulumi.set(__self__, "support_type", support_type)

    @_builtins.property
    @pulumi.getter(name="supportType")
    def support_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "support_type")

    @support_type.setter
    def support_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "support_type", value)


if not MYPY:
    class ClusterVpcConfigArgsDict(TypedDict):
        subnet_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        cluster_security_group_id: NotRequired[pulumi.Input[_builtins.str]]
        endpoint_private_access: NotRequired[pulumi.Input[_builtins.bool]]
        endpoint_public_access: NotRequired[pulumi.Input[_builtins.bool]]
        public_access_cidrs: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        security_group_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        vpc_id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ClusterVpcConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterVpcConfigArgs:
    def __init__(__self__, *,
                 subnet_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 cluster_security_group_id: Optional[pulumi.Input[_builtins.str]] = None,
                 endpoint_private_access: Optional[pulumi.Input[_builtins.bool]] = None,
                 endpoint_public_access: Optional[pulumi.Input[_builtins.bool]] = None,
                 public_access_cidrs: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 security_group_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 vpc_id: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "subnet_ids", subnet_ids)
        if cluster_security_group_id is not None:
            pulumi.set(__self__, "cluster_security_group_id", cluster_security_group_id)
        if endpoint_private_access is not None:
            pulumi.set(__self__, "endpoint_private_access", endpoint_private_access)
        if endpoint_public_access is not None:
            pulumi.set(__self__, "endpoint_public_access", endpoint_public_access)
        if public_access_cidrs is not None:
            pulumi.set(__self__, "public_access_cidrs", public_access_cidrs)
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)
        if vpc_id is not None:
            pulumi.set(__self__, "vpc_id", vpc_id)

    @_builtins.property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "subnet_ids")

    @subnet_ids.setter
    def subnet_ids(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "subnet_ids", value)

    @_builtins.property
    @pulumi.getter(name="clusterSecurityGroupId")
    def cluster_security_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "cluster_security_group_id")

    @cluster_security_group_id.setter
    def cluster_security_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cluster_security_group_id", value)

    @_builtins.property
    @pulumi.getter(name="endpointPrivateAccess")
    def endpoint_private_access(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "endpoint_private_access")

    @endpoint_private_access.setter
    def endpoint_private_access(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "endpoint_private_access", value)

    @_builtins.property
    @pulumi.getter(name="endpointPublicAccess")
    def endpoint_public_access(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "endpoint_public_access")

    @endpoint_public_access.setter
    def endpoint_public_access(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "endpoint_public_access", value)

    @_builtins.property
    @pulumi.getter(name="publicAccessCidrs")
    def public_access_cidrs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "public_access_cidrs")

    @public_access_cidrs.setter
    def public_access_cidrs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "public_access_cidrs", value)

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "security_group_ids")

    @security_group_ids.setter
    def security_group_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "security_group_ids", value)

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "vpc_id")

    @vpc_id.setter
    def vpc_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vpc_id", value)


if not MYPY:
    class ClusterZonalShiftConfigArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    ClusterZonalShiftConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterZonalShiftConfigArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class FargateProfileSelectorArgsDict(TypedDict):
        namespace: pulumi.Input[_builtins.str]
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
elif False:
    FargateProfileSelectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FargateProfileSelectorArgs:
    def __init__(__self__, *,
                 namespace: pulumi.Input[_builtins.str],
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "namespace", namespace)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "labels", value)


if not MYPY:
    class IdentityProviderConfigOidcArgsDict(TypedDict):
        client_id: pulumi.Input[_builtins.str]
        identity_provider_config_name: pulumi.Input[_builtins.str]
        issuer_url: pulumi.Input[_builtins.str]
        groups_claim: NotRequired[pulumi.Input[_builtins.str]]
        groups_prefix: NotRequired[pulumi.Input[_builtins.str]]
        required_claims: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        username_claim: NotRequired[pulumi.Input[_builtins.str]]
        username_prefix: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    IdentityProviderConfigOidcArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IdentityProviderConfigOidcArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[_builtins.str],
                 identity_provider_config_name: pulumi.Input[_builtins.str],
                 issuer_url: pulumi.Input[_builtins.str],
                 groups_claim: Optional[pulumi.Input[_builtins.str]] = None,
                 groups_prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 required_claims: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 username_claim: Optional[pulumi.Input[_builtins.str]] = None,
                 username_prefix: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "identity_provider_config_name", identity_provider_config_name)
        pulumi.set(__self__, "issuer_url", issuer_url)
        if groups_claim is not None:
            pulumi.set(__self__, "groups_claim", groups_claim)
        if groups_prefix is not None:
            pulumi.set(__self__, "groups_prefix", groups_prefix)
        if required_claims is not None:
            pulumi.set(__self__, "required_claims", required_claims)
        if username_claim is not None:
            pulumi.set(__self__, "username_claim", username_claim)
        if username_prefix is not None:
            pulumi.set(__self__, "username_prefix", username_prefix)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "client_id", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderConfigName")
    def identity_provider_config_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "identity_provider_config_name")

    @identity_provider_config_name.setter
    def identity_provider_config_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_config_name", value)

    @_builtins.property
    @pulumi.getter(name="issuerUrl")
    def issuer_url(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "issuer_url")

    @issuer_url.setter
    def issuer_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "issuer_url", value)

    @_builtins.property
    @pulumi.getter(name="groupsClaim")
    def groups_claim(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "groups_claim")

    @groups_claim.setter
    def groups_claim(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "groups_claim", value)

    @_builtins.property
    @pulumi.getter(name="groupsPrefix")
    def groups_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "groups_prefix")

    @groups_prefix.setter
    def groups_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "groups_prefix", value)

    @_builtins.property
    @pulumi.getter(name="requiredClaims")
    def required_claims(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "required_claims")

    @required_claims.setter
    def required_claims(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "required_claims", value)

    @_builtins.property
    @pulumi.getter(name="usernameClaim")
    def username_claim(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "username_claim")

    @username_claim.setter
    def username_claim(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username_claim", value)

    @_builtins.property
    @pulumi.getter(name="usernamePrefix")
    def username_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "username_prefix")

    @username_prefix.setter
    def username_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username_prefix", value)


if not MYPY:
    class NodeGroupLaunchTemplateArgsDict(TypedDict):
        version: pulumi.Input[_builtins.str]
        id: NotRequired[pulumi.Input[_builtins.str]]
        name: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    NodeGroupLaunchTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodeGroupLaunchTemplateArgs:
    def __init__(__self__, *,
                 version: pulumi.Input[_builtins.str],
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "version", version)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def version(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "version", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class NodeGroupNodeRepairConfigArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        max_parallel_nodes_repaired_count: NotRequired[pulumi.Input[_builtins.int]]
        max_parallel_nodes_repaired_percentage: NotRequired[pulumi.Input[_builtins.int]]
        max_unhealthy_node_threshold_count: NotRequired[pulumi.Input[_builtins.int]]
        max_unhealthy_node_threshold_percentage: NotRequired[pulumi.Input[_builtins.int]]
        node_repair_config_overrides: NotRequired[pulumi.Input[Sequence[pulumi.Input['NodeGroupNodeRepairConfigNodeRepairConfigOverrideArgsDict']]]]
elif False:
    NodeGroupNodeRepairConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodeGroupNodeRepairConfigArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 max_parallel_nodes_repaired_count: Optional[pulumi.Input[_builtins.int]] = None,
                 max_parallel_nodes_repaired_percentage: Optional[pulumi.Input[_builtins.int]] = None,
                 max_unhealthy_node_threshold_count: Optional[pulumi.Input[_builtins.int]] = None,
                 max_unhealthy_node_threshold_percentage: Optional[pulumi.Input[_builtins.int]] = None,
                 node_repair_config_overrides: Optional[pulumi.Input[Sequence[pulumi.Input['NodeGroupNodeRepairConfigNodeRepairConfigOverrideArgs']]]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if max_parallel_nodes_repaired_count is not None:
            pulumi.set(__self__, "max_parallel_nodes_repaired_count", max_parallel_nodes_repaired_count)
        if max_parallel_nodes_repaired_percentage is not None:
            pulumi.set(__self__, "max_parallel_nodes_repaired_percentage", max_parallel_nodes_repaired_percentage)
        if max_unhealthy_node_threshold_count is not None:
            pulumi.set(__self__, "max_unhealthy_node_threshold_count", max_unhealthy_node_threshold_count)
        if max_unhealthy_node_threshold_percentage is not None:
            pulumi.set(__self__, "max_unhealthy_node_threshold_percentage", max_unhealthy_node_threshold_percentage)
        if node_repair_config_overrides is not None:
            pulumi.set(__self__, "node_repair_config_overrides", node_repair_config_overrides)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="maxParallelNodesRepairedCount")
    def max_parallel_nodes_repaired_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "max_parallel_nodes_repaired_count")

    @max_parallel_nodes_repaired_count.setter
    def max_parallel_nodes_repaired_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_parallel_nodes_repaired_count", value)

    @_builtins.property
    @pulumi.getter(name="maxParallelNodesRepairedPercentage")
    def max_parallel_nodes_repaired_percentage(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "max_parallel_nodes_repaired_percentage")

    @max_parallel_nodes_repaired_percentage.setter
    def max_parallel_nodes_repaired_percentage(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_parallel_nodes_repaired_percentage", value)

    @_builtins.property
    @pulumi.getter(name="maxUnhealthyNodeThresholdCount")
    def max_unhealthy_node_threshold_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "max_unhealthy_node_threshold_count")

    @max_unhealthy_node_threshold_count.setter
    def max_unhealthy_node_threshold_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_unhealthy_node_threshold_count", value)

    @_builtins.property
    @pulumi.getter(name="maxUnhealthyNodeThresholdPercentage")
    def max_unhealthy_node_threshold_percentage(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "max_unhealthy_node_threshold_percentage")

    @max_unhealthy_node_threshold_percentage.setter
    def max_unhealthy_node_threshold_percentage(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_unhealthy_node_threshold_percentage", value)

    @_builtins.property
    @pulumi.getter(name="nodeRepairConfigOverrides")
    def node_repair_config_overrides(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NodeGroupNodeRepairConfigNodeRepairConfigOverrideArgs']]]]:
        return pulumi.get(self, "node_repair_config_overrides")

    @node_repair_config_overrides.setter
    def node_repair_config_overrides(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NodeGroupNodeRepairConfigNodeRepairConfigOverrideArgs']]]]):
        pulumi.set(self, "node_repair_config_overrides", value)


if not MYPY:
    class NodeGroupNodeRepairConfigNodeRepairConfigOverrideArgsDict(TypedDict):
        min_repair_wait_time_mins: pulumi.Input[_builtins.int]
        node_monitoring_condition: pulumi.Input[_builtins.str]
        node_unhealthy_reason: pulumi.Input[_builtins.str]
        repair_action: pulumi.Input[_builtins.str]
elif False:
    NodeGroupNodeRepairConfigNodeRepairConfigOverrideArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodeGroupNodeRepairConfigNodeRepairConfigOverrideArgs:
    def __init__(__self__, *,
                 min_repair_wait_time_mins: pulumi.Input[_builtins.int],
                 node_monitoring_condition: pulumi.Input[_builtins.str],
                 node_unhealthy_reason: pulumi.Input[_builtins.str],
                 repair_action: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "min_repair_wait_time_mins", min_repair_wait_time_mins)
        pulumi.set(__self__, "node_monitoring_condition", node_monitoring_condition)
        pulumi.set(__self__, "node_unhealthy_reason", node_unhealthy_reason)
        pulumi.set(__self__, "repair_action", repair_action)

    @_builtins.property
    @pulumi.getter(name="minRepairWaitTimeMins")
    def min_repair_wait_time_mins(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "min_repair_wait_time_mins")

    @min_repair_wait_time_mins.setter
    def min_repair_wait_time_mins(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "min_repair_wait_time_mins", value)

    @_builtins.property
    @pulumi.getter(name="nodeMonitoringCondition")
    def node_monitoring_condition(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "node_monitoring_condition")

    @node_monitoring_condition.setter
    def node_monitoring_condition(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "node_monitoring_condition", value)

    @_builtins.property
    @pulumi.getter(name="nodeUnhealthyReason")
    def node_unhealthy_reason(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "node_unhealthy_reason")

    @node_unhealthy_reason.setter
    def node_unhealthy_reason(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "node_unhealthy_reason", value)

    @_builtins.property
    @pulumi.getter(name="repairAction")
    def repair_action(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "repair_action")

    @repair_action.setter
    def repair_action(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "repair_action", value)


if not MYPY:
    class NodeGroupRemoteAccessArgsDict(TypedDict):
        ec2_ssh_key: NotRequired[pulumi.Input[_builtins.str]]
        source_security_group_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    NodeGroupRemoteAccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodeGroupRemoteAccessArgs:
    def __init__(__self__, *,
                 ec2_ssh_key: Optional[pulumi.Input[_builtins.str]] = None,
                 source_security_group_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if ec2_ssh_key is not None:
            pulumi.set(__self__, "ec2_ssh_key", ec2_ssh_key)
        if source_security_group_ids is not None:
            pulumi.set(__self__, "source_security_group_ids", source_security_group_ids)

    @_builtins.property
    @pulumi.getter(name="ec2SshKey")
    def ec2_ssh_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "ec2_ssh_key")

    @ec2_ssh_key.setter
    def ec2_ssh_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ec2_ssh_key", value)

    @_builtins.property
    @pulumi.getter(name="sourceSecurityGroupIds")
    def source_security_group_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "source_security_group_ids")

    @source_security_group_ids.setter
    def source_security_group_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "source_security_group_ids", value)


if not MYPY:
    class NodeGroupResourceArgsDict(TypedDict):
        autoscaling_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input['NodeGroupResourceAutoscalingGroupArgsDict']]]]
        remote_access_security_group_id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    NodeGroupResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodeGroupResourceArgs:
    def __init__(__self__, *,
                 autoscaling_groups: Optional[pulumi.Input[Sequence[pulumi.Input['NodeGroupResourceAutoscalingGroupArgs']]]] = None,
                 remote_access_security_group_id: Optional[pulumi.Input[_builtins.str]] = None):
        if autoscaling_groups is not None:
            pulumi.set(__self__, "autoscaling_groups", autoscaling_groups)
        if remote_access_security_group_id is not None:
            pulumi.set(__self__, "remote_access_security_group_id", remote_access_security_group_id)

    @_builtins.property
    @pulumi.getter(name="autoscalingGroups")
    def autoscaling_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NodeGroupResourceAutoscalingGroupArgs']]]]:
        return pulumi.get(self, "autoscaling_groups")

    @autoscaling_groups.setter
    def autoscaling_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NodeGroupResourceAutoscalingGroupArgs']]]]):
        pulumi.set(self, "autoscaling_groups", value)

    @_builtins.property
    @pulumi.getter(name="remoteAccessSecurityGroupId")
    def remote_access_security_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "remote_access_security_group_id")

    @remote_access_security_group_id.setter
    def remote_access_security_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "remote_access_security_group_id", value)


if not MYPY:
    class NodeGroupResourceAutoscalingGroupArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    NodeGroupResourceAutoscalingGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodeGroupResourceAutoscalingGroupArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class NodeGroupScalingConfigArgsDict(TypedDict):
        desired_size: pulumi.Input[_builtins.int]
        max_size: pulumi.Input[_builtins.int]
        min_size: pulumi.Input[_builtins.int]
elif False:
    NodeGroupScalingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodeGroupScalingConfigArgs:
    def __init__(__self__, *,
                 desired_size: pulumi.Input[_builtins.int],
                 max_size: pulumi.Input[_builtins.int],
                 min_size: pulumi.Input[_builtins.int]):
        pulumi.set(__self__, "desired_size", desired_size)
        pulumi.set(__self__, "max_size", max_size)
        pulumi.set(__self__, "min_size", min_size)

    @_builtins.property
    @pulumi.getter(name="desiredSize")
    def desired_size(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "desired_size")

    @desired_size.setter
    def desired_size(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "desired_size", value)

    @_builtins.property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "max_size")

    @max_size.setter
    def max_size(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "max_size", value)

    @_builtins.property
    @pulumi.getter(name="minSize")
    def min_size(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "min_size")

    @min_size.setter
    def min_size(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "min_size", value)


if not MYPY:
    class NodeGroupTaintArgsDict(TypedDict):
        effect: pulumi.Input[_builtins.str]
        key: pulumi.Input[_builtins.str]
        value: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    NodeGroupTaintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodeGroupTaintArgs:
    def __init__(__self__, *,
                 effect: pulumi.Input[_builtins.str],
                 key: pulumi.Input[_builtins.str],
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "effect", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NodeGroupUpdateConfigArgsDict(TypedDict):
        max_unavailable: NotRequired[pulumi.Input[_builtins.int]]
        max_unavailable_percentage: NotRequired[pulumi.Input[_builtins.int]]
        update_strategy: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    NodeGroupUpdateConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodeGroupUpdateConfigArgs:
    def __init__(__self__, *,
                 max_unavailable: Optional[pulumi.Input[_builtins.int]] = None,
                 max_unavailable_percentage: Optional[pulumi.Input[_builtins.int]] = None,
                 update_strategy: Optional[pulumi.Input[_builtins.str]] = None):
        if max_unavailable is not None:
            pulumi.set(__self__, "max_unavailable", max_unavailable)
        if max_unavailable_percentage is not None:
            pulumi.set(__self__, "max_unavailable_percentage", max_unavailable_percentage)
        if update_strategy is not None:
            pulumi.set(__self__, "update_strategy", update_strategy)

    @_builtins.property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "max_unavailable")

    @max_unavailable.setter
    def max_unavailable(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_unavailable", value)

    @_builtins.property
    @pulumi.getter(name="maxUnavailablePercentage")
    def max_unavailable_percentage(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "max_unavailable_percentage")

    @max_unavailable_percentage.setter
    def max_unavailable_percentage(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_unavailable_percentage", value)

    @_builtins.property
    @pulumi.getter(name="updateStrategy")
    def update_strategy(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "update_strategy")

    @update_strategy.setter
    def update_strategy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update_strategy", value)


